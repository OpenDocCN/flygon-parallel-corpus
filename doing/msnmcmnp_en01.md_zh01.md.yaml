- en: Chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一、使用 NumPy 数组
- en: Working with NumPy Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ''
- en: Scientific computing is a multidisciplinary field, with its applications spanning
    across disciplines such as numerical analysis, computational finance, and bioinformatics.
  prefs: []
  type: TYPE_NORMAL
  zh: 科学计算是一个多学科领域，其应用跨越数值分析，计算金融和生物信息学等学科。
- en: Let's consider a case for financial markets. When you think about financial
    markets, there is a huge interconnected web of interactions. Governments, banks,
    investment funds, insurance companies, pensions, individual investors, and others
    are involved in this exchange of financial instruments. You can't simply model
    all the interactions between market participants because everyone who is involved
    in financial transactions has different motives and different risk/return objectives.
    There are also other factors which affect the prices of financial assets. Even
    modeling one asset price requires you to do a tremendous amount of work, and your
    success is not guaranteed. In mathematical terms, this doesn't have a closed-form
    solution and this makes a great case for utilizing scientific computing where
    you can use advanced computing techniques to attack such problems.
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下金融市场的情况。 当您考虑金融市场时，会有巨大的相互联系的互动网络。 政府，银行，投资基金，保险公司，养老金，个人投资者和其他人都参与了这种金融工具的交换。
    您不能简单地模拟市场参与者之间的所有互动，因为参与金融交易的每个人都有不同的动机和不同的风险/回报目标。 还有其他因素会影响金融资产的价格。 即使为一个资产价格建模也需要您做大量工作，并且不能保证成功。
    用数学术语来说，这没有封闭形式的解决方案，这为利用科学计算提供了一个很好的案例，您可以在其中使用高级计算技术来解决此类问题。
- en: By writing computer programs, you will have the power to better understand the
    system you are working on. Usually, the computer program you will be writing will
    be some sort of simulation, such as the Monte Carlo simulation. By using a simulation
    such as Monte Carlo, you can model the price of option contracts. Pricing financial
    assets is a good material for simulations, simply because of the complexity of
    financial markets. All of these mathematical computations need a powerful, scalable
    and convenient structure for your data (which is mostly in matrix form) when you
    do your computation. In other words, you need a more compact structure than a *list* in
    order to simplify your task. NumPy is a perfect candidate for performant vector/matrix
    operations and its extensive library of mathematical operations makes numeric
    computing easy and efficient.
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写计算机程序，您将有能力更好地了解正在使用的系统。 通常，您将要编写的计算机程序将是某种模拟，例如蒙特卡洛模拟。 通过使用诸如蒙特卡洛的模拟，您可以对期权合约的价格进行建模。
    仅仅由于金融市场的复杂性，对金融资产进行定价是进行模拟的良好材料。 在进行计算时，所有这些数学计算都需要一个功能强大，可扩展且方便的数据结构（大多数为矩阵形式）。
    换句话说，您需要比*列表*更紧凑的结构，以简化您的任务。 NumPy 是高效向量/矩阵运算的理想选择，其广泛的数学运算库使数值计算变得简单而高效。
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The importance of NumPy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy 的重要性
- en: Theoretical and practical information about vectors and matrices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于向量和矩阵的理论和实践信息
- en: NumPy array operations and their usage in multidimensional arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy 数组操作及其在多维数组中的用法
- en: The question is, where should we start practicing coding skills? In this book,
    you will be using Python because of its huge adoption in the scientific community,
    and you will mainly work with a specific library called NumPy, which stands for
    numerical Python.
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，我们应该从哪里开始练习编码技能？ 在本书中，由于 Python 在科学界的广泛应用，您将在使用它，并且您将主要使用名为 NumPy 的特定库（它代表数字
    Python）。
- en: Chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ''
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this book, we will use Jupyter Notebooks. We will edit and run Python code
    via a web browser. It''s an open source platform which you can install by following
    the instructions in this link: [http://jupyter.org/install](http://jupyter.org/install).'
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用 Jupyter 笔记本。 我们将通过网络浏览器编辑和运行 Python 代码。 这是一个开源平台，您可以按照此链接中的说明进行安装：[`jupyter.org/install`](http://jupyter.org/install)。
- en: This book will be using Python 3.x, so when you open a new notebook, you should
    pick Python 3 kernel. Alternatively, you can install Jupyter Notebook using Anaconda
    (Python version 3.6), which is highly recommended. You can install it by following
    the instructions in this link: [https://www.anaconda.com/download/](https://www.anaconda.com/download/).
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将使用 Python 3.x，因此在打开新笔记本时，应选择 Python 3 内核。 另外，也可以使用 Anaconda（Python 版本 3.6）安装
    Jupyter 笔记本。 您可以按照此链接中的说明进行安装：[`www.anaconda.com/download`](https://www.anaconda.com/download/)。
- en: Chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ''
- en: Why do we need NumPy?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们需要 NumPy？
- en: 'Python has become a rockstar programming language recently, not only because
    it has friendly syntax and readability, but because it can be used for a variety
    of purposes. Python''s ecosystem of various libraries makes various computations
    relatively easy for programmers. Stack Overflow is one the most popular websites
    for programmers. Users can ask questions by tagging which programming language
    they relate to. The following figure shows the growth of major programming languages
    by calculating these tags and plot the popularity of major programming languages over
    the years. The research conducted by Stack Overflow can be further analyzed via
    this link to their official blog:[ https://stackoverflow.blog/2017/09/06/incredible-growth-python/](https://stackoverflow.blog/2017/09/06/incredible-growth-python/):'
  prefs: []
  type: TYPE_NORMAL
  zh: Python 最近成为一种摇滚明星的编程语言，不仅因为它具有友好的语法和可读性，而且因为它可以用于多种用途。 各种库的 Python 生态系统使程序员相对容易进行各种计算。
    堆栈溢出是程序员最受欢迎的网站之一。 用户可以通过标记与之相关的编程语言来提问。 下图通过计算这些标签显示了主要编程语言的增长，并绘制了多年来主流编程语言的流行程度。
    通过 Stack Overflow 进行的研究可以通过其官方博客链接进行进一步分析：[`stackoverflow.blog/2017/09/06/incredible-growth-python`](https://stackoverflow.blog/2017/09/06/incredible-growth-python/)：
- en: ''
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29d1b18e-2b01-41b1-a634-38cb82c0fafc.png)'
- en: '![](img/29d1b18e-2b01-41b1-a634-38cb82c0fafc.png)Growth of major programming
    languages'
  prefs: []
  type: TYPE_NORMAL
  zh: 主要编程语言的发展
- en: '**NumPy** is the most fundamental package for scientific computing in Python
    and is the base for many other packages. Since Python was not initially designed
    for numerical computing, this need has arised in the late 90''s when Python started
    to become popular among engineers and programmers who needed faster vector operations.
    As you can see from the following figure, many popular machine learning and computational
    packages use some of NumPy''s features, and the most important thing is that they
    use NumPy arrays heavily in their methods, which makes NumPy an essential library
    for scientific projects.'
  prefs: []
  type: TYPE_NORMAL
  zh: '**NumPy** 是 Python 中科学计算的最基本软件包，也是许多其他软件包的基础。 由于 Python 最初并不是为数字计算而设计的，因此在
    90 年代后期开始出现这种需求时，Python 开始在需要更快的向量运算的工程师和程序员中流行。 从下图可以看到，许多流行的机器学习和计算包都使用了 NumPy
    的某些功能，最重要的是它们在其方法中大量使用了 NumPy 数组，这使 NumPy 成为科学项目的基本库。'
- en: 'The figure shows some well-known libraries which use NumPy features:'
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了一些使用 NumPy 功能的知名库：
- en: ''
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fcc206b1-a961-45d6-b518-bf8bea28eae0.png)'
- en: '![](img/fcc206b1-a961-45d6-b518-bf8bea28eae0.png)NumPy stack'
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 栈
- en: For numerical computing, you mainly work with vectors and matrices. You can
    manipulate them in different ways by using a range of mathematical functions.
    NumPy is a perfect fit for these kinds of situations since it allows users to
    have their computations completed efficiently. Even though Python lists are very
    easy to create and manipulate, they don't support *vectorized* operations. Python
    doesn't have fixed type elements in lists and for example, for loop is not very
    efficient because, at every iteration, data type needs to be checked. In NumPy
    arrays, however, the data type is fixed and also supports *vectorized* operations.
    NumPy is not just more efficient in multidimensional array operations comparing
    to Python lists; it also provides many mathematical methods that you can apply
    as soon as it's imported. NumPy is a core library for the scientific Python data
    science stack.
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数值计算，您主要处理向量和矩阵。 您可以通过使用一系列数学函数以不同的方式来操作它们。 NumPy 非常适合此类情况，因为它允许用户有效地完成其计算。
    尽管 Python 列表很容易创建和操作，但它们不支持*向量化*操作。 Python 在列表中没有固定的类型元素，例如，`for`循环效率不高，因为在每次迭代中都需要检查数据类型。
    但是，在 NumPy 数组中，数据类型是固定的，并且还支持*向量化*运算。 与 Python 列表相比，NumPy 在多维数组操作中不仅效率更高。 它还提供了许多数学方法，您可以在导入后立即应用它们。
    NumPy 是用于科学 Python 数据科学堆栈的核心库。
- en: SciPy has strong relationship with NumPy as it's using NumPy multidimensional
    arrays as a base data structure for its scientific functions for linear algebra,
    optimization. interpolation, integration, FFT, signal and image processing and
    others. SciPy was built on top of the NumPy array framework and uplifted scientific
    programming with its advanced mathematical functions. Therefore some parts of
    the NumPy API have been moved to SciPy. This relationship with NumPy makes SciPy
    more convenient for advanced scientific computing in many cases.
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy 与 NumPy 有着密切的关系，因为它使用 NumPy 多维数组作为其线性代数，优化，插值，积分，FFT，信号，图像处理和其它的科学函数的基础数据结构。
    SciPy 建立在 NumPy 数组框架之上，并凭借其先进的数学函数提升了科学编程能力。 因此，NumPy API 的某些部分已移至 SciPy。 在许多情况下，与
    NumPy 的这种关系使 SciPy 更便于进行高级科学计算。
- en: 'To sum this up, we can summarize NumPy''s advantages as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 综上所述，我们可以总结出 NumPy 的优势如下：
- en: It's open source and zero-cost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是开源的，零成本
- en: It's a high-level programming language with user-friendly syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一种具有用户友好语法的高级编程语言
- en: It's more efficient than Python lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比 Python 列表更有效
- en: It has more advanced built-in functions and is well-integrated with other libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有更高级的内置函数，并与其他库很好地集成在一起
- en: Chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ''
- en: Who uses NumPy?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谁使用 NumPy？
- en: In both academic and business circles, you will hear people talking about the
    tools and technologies they use in their work. Depending on the environment and
    conditions, you might need to work with specific technologies. For example, if
    your company has already invested in SAS, you will need to carry out your project
    in the SAS development environment suited to your problem.
  prefs: []
  type: TYPE_NORMAL
  zh: 在学术界和商业界，您都会听到人们谈论他们在工作中使用的工具和技术。 根据环境和条件，您可能需要使用特定技术。 例如，如果您的公司已经投资了 SAS，则需要在适合您问题的
    SAS 开发环境中进行项目。
- en: However, one of the advantages of NumPy is that it's open source, and it costs
    nothing for you to utilize it in your project. If you have already coded in Python,
    it's super easy to learn. If performance is your concern, you can easily embed
    C or Fortran code. Moreover, it will introduce you to a whole other set of libraries
    such as SciPy and Scikit-learn, which you can use to solve almost any problem.
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，NumPy 的优点之一是它是开源的，在您的项目中使用它无需花费任何成本。 如果您已经使用 Python 编写过代码，那么它非常容易学习。 如果您关心性能，则可以轻松嵌入
    C 或 Fortran 代码。 此外，它将为您介绍其他完整的库集，例如 SciPy 和 Scikit-learn，您可以使用它们来解决几乎所有问题。
- en: Since data mining and predictive analytics became really important recently,
    roles like *Data Scientist* and *Data Analyst* are mentioned as the hottest jobs
    of the 21st century in many business journals such as Forbes, Bloomberg, and so
    on. People who need to work with data and do analysis, modeling, or forecasting
    should become familiar with NumPy's usage and its capabilities, as it will help
    you quickly prototype and test your ideas. If you are a working professional,
    your firm most probably wants to use data analysis methods in order to move one
    step ahead of its competitors. If they can better understand the data they have,
    they can understand the business better, and this will lead them to make better
    decisions. NumPy plays a critical role here as it is capable of performing wide
    range of operations and making your projects timewise efficient.
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据挖掘和预测分析在最近变得非常重要，因此*数据科学家*和*数据分析师*等角色在 21 世纪最热门的工作中被提及，例如《福布斯》，彭博社， 等等。
    需要处理数据并进行分析，建模或预测的人员应该熟悉 NumPy 的用法及其功能，因为它将帮助您快速创建原型并测试您的想法。 如果您是专业工作人员，那么您的公司很可能希望使用数据分析方法，以使其领先于竞争对手。
    如果他们能够更好地理解他们拥有的数据，那么他们就可以更好地理解业务，这将使他们做出更好的决策。 NumPy 在这里起着至关重要的作用，因为它能够执行各种操作，并使您的项目及时有效。
- en: Chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ''
- en: Introduction to vectors and matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量和矩阵简介
- en: 'A matrix is a group of numbers or elements which are arranged as a rectangular
    array. The matrix''s rows and columns are usually indexed by letter. For a *n
    x m* matrix, n represents the number of rows and m represents the number of columns.
    If we have a hypothetical *n x m* matrix, it will be structured as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵是一组数字或元素，它们以矩形数组的形式排列。 矩阵的行和列通常按字母索引。 对于`n x m`矩阵，`n`表示行数，`m`表示列数。 如果我们有一个假设的`n×m`矩阵，则其结构如下：
- en: '![](img/9b6065a7-739d-4cdf-8d17-87f454807eb0.png)'
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b6065a7-739d-4cdf-8d17-87f454807eb0.png)'
- en: 'If *n* *= m,* then it iscalled a square matrix:'
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`n = m`，则称为称为方阵：
- en: '![](img/1a374d12-15ce-4f4b-82f9-ca5d54f2f409.png)'
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a374d12-15ce-4f4b-82f9-ca5d54f2f409.png)'
- en: A vector is actually a matrix with one row or one column with more than one
    element. It can also be defined as the *1-by-m* or *n-by-1* matrix. You can interpret
    a vector as an arrow or direction in an *m* dimensional space. Generally, the
    capital letter denotes a matrix, like *X* in this example, and lowercase letters
    with subscripts like *X[11]* denote the element of the matrix *X*.
  prefs: []
  type: TYPE_NORMAL
  zh: 向量实际上是具有多于一个元素的一行或一列的矩阵。 也可以将其定义为`1 x m`或`n x 1`矩阵。 您可以将向量解释为`m`维空间中的箭头或方向。
    通常，大写字母表示矩阵，例如`X`；小写字母带有下标，例如`x[11]`，表示矩阵`X`的元素。
- en: 'In addition, there are some important special matrices: the zero matrix (null
    matrix) and the identity matrix. *0* denotes the zero matrix, which is a matrix
    of all *0*s (MacDufee 1943 p.27). In a *0* matrix, it''s optional to add subscripts:'
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些重要的特殊矩阵：零矩阵（空矩阵）和恒等矩阵。`0`表示零矩阵，它是所有`0`的矩阵（MacDufee 1943 p.27）。 在`0`矩阵中，添加下标是可选的：
- en: '![](img/b724928f-b193-4519-a19e-b585d4c6985f.png)'
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b724928f-b193-4519-a19e-b585d4c6985f.png)'
- en: 'The identity matrix denoted by *I*, and its diagonal elements are *1* while
    the others are *0*:'
  prefs: []
  type: TYPE_NORMAL
  zh: 由`I`表示的单位矩阵及其对角线元素为`1`，其他元素为`0`：
- en: '![](img/4f0d67f1-4d75-40ab-9956-dfa660351542.png)'
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f0d67f1-4d75-40ab-9956-dfa660351542.png)'
- en: 'When you multiply a matrix *X* with the identity matrix, the result will be
    equal to *X*:'
  prefs: []
  type: TYPE_NORMAL
  zh: 将矩阵`X`与单位矩阵相乘时，结果将等于`X`：
- en: '![](img/fae2b981-76bc-4e18-a376-6e3136f64e76.png)'
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fae2b981-76bc-4e18-a376-6e3136f64e76.png)'
- en: 'An identity matrix is very useful for calculating the inverse of a matrix.
    When you multiply any given matrix with its inverse, the result will be an identity
    matrix:'
  prefs: []
  type: TYPE_NORMAL
  zh: 单位矩阵对于计算矩阵的逆非常有用。 当您将任何给定矩阵与其逆矩阵相乘时，结果将是一个单位矩阵：
- en: '![](img/152ca8a5-d857-41e3-abf8-6b8257f7fe25.png)'
  prefs: []
  type: TYPE_IMG
  zh: '![](img/152ca8a5-d857-41e3-abf8-6b8257f7fe25.png)'
- en: 'Let''s briefly see the matrix algebra on NumPy arrays. Addition and subtraction
    operations for matrices are similar to math equations with ordinary single numbers.
    As an example:'
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看一下 NumPy 数组上的矩阵代数。 矩阵的加减法运算与具有普通单数的数学方程式相似。 举个例子：
- en: '![](img/e4867959-245b-4ee4-a22d-d8a946b9a27c.png)![](img/355ce16f-e1a8-4863-a6c4-6adbb21845d5.png)'
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4867959-245b-4ee4-a22d-d8a946b9a27c.png)'
- en: ''
  prefs: []
  type: TYPE_IMG
  zh: '![](img/355ce16f-e1a8-4863-a6c4-6adbb21845d5.png)'
- en: 'Scalar multiplication is also pretty straightforward. As an example, if you
    multiply your matrix *X* by *4*, the only thing that you should do is multiply
    each element with the value *4* as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 标量乘法也非常简单。 例如，如果将矩阵`X`乘以`4`，则唯一要做的就是将每个元素乘以`4`值，如下所示：
- en: '![](img/b9530e67-17e4-4cf5-98a8-8b312f9ecaba.png)![](img/b3b7e55e-880a-4d44-b90e-bda5982d065c.png)'
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9530e67-17e4-4cf5-98a8-8b312f9ecaba.png)'
- en: ''
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3b7e55e-880a-4d44-b90e-bda5982d065c.png)'
- en: The seemingly complicated part of matrix manipulation at the beginning is matrix
    multiplication.
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时矩阵处理看似复杂的部分是矩阵乘法。
- en: 'Imagine you have two matrices as *X*and *Y*, where *X* is an ![](img/42a4db1c-64a7-46dd-8263-54d675e077f2.png) matrix
    and *Y* is an ![](img/172c79a3-53ed-4890-86ae-be57c1cea263.png) matrix:'
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有两个矩阵，分别为`X`和`Y`，其中`X`是 ![](img/42a4db1c-64a7-46dd-8263-54d675e077f2.png)
    矩阵，`Y`是 ![](img/172c79a3-53ed-4890-86ae-be57c1cea263.png) 矩阵：
- en: '![](img/4f1cd787-fc1b-464e-92f5-5c5415a2db8f.png) ![](img/d47f3f47-101c-4e87-a5c1-85bada7a8836.png)'
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f1cd787-fc1b-464e-92f5-5c5415a2db8f.png)'
- en: ''
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d47f3f47-101c-4e87-a5c1-85bada7a8836.png)'
- en: 'The product of these two matrices will be as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个矩阵的乘积将如下所示：
- en: '![](img/6be113b6-edf9-46bb-8978-a85f959bcb9b.png)'
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6be113b6-edf9-46bb-8978-a85f959bcb9b.png)'
- en: 'So each element of the product matrix is calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，乘积矩阵的每个元素的计算方式如下：
- en: '![](img/80d37c31-3ed6-4ad4-a277-fd69efcb7b88.png)'
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d37c31-3ed6-4ad4-a277-fd69efcb7b88.png)'
- en: 'Don''t worry if you didn''t understand the notation. The following example
    will make things clearer. You have matrices *X*and *Y* and the goal is to get
    the matrix product of these matrices:'
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不了解该符号，请不要担心。 以下示例将使事情变得更清楚。 您有矩阵`X`和`Y`，目标是获得这些矩阵的矩阵乘积：
- en: '![](img/5f8962d0-d8fd-4dec-acda-c089f2277fc5.png)'
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f8962d0-d8fd-4dec-acda-c089f2277fc5.png)'
- en: 'The basic idea is that the product of the *i[th]* row of *X* and the *j*[*th* ]of
    column *Y* will become the *i[th], j[th]* element of the matrix in the result.
    Multiplication will start with the first row of *X* and the first column of *Y*,
    so their product will be Z*[1,1]*:'
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是`X`的`i`行与`Y`的`j`列的乘积将成为结果矩阵的第`i, j`个元素。 乘法将从`X`的第一行和`Y`的第一列开始，因此它们的乘积将为`Z[1,
    1]`：
- en: '![](img/5d163980-894a-40aa-ac80-32239e5bea8e.png)'
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d163980-894a-40aa-ac80-32239e5bea8e.png)'
- en: 'You can cross-check the results easily with the following four lines of code:'
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下四行代码轻松地交叉检查结果：
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The previous code block is just a demonstration of how easy to calculate the
    dot product of two matrices by use of NumPy. In later chapters, we will go more
    in deep into matrix operations and linear algebra.
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码块只是演示如何使用 NumPy 计算两个矩阵的点积。 在后面的章节中，我们将更深入地研究矩阵运算和线性代数。
- en: Chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ''
- en: Basics of NumPy array objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NumPy 数组对象的基础
- en: As mentioned in the preceding section, what makes NumPy special is the usage
    of multidimensional arrays called **ndarrays**. All `ndarray` items are homogeneous
    and use the same size in memory. Let's start by importing NumPy and analyzing
    the structure of a NumPy array object by creating the array. You can easily import
    this library by typing the following statement into your console. You can use
    any naming convention instead of `np`, but in this book, `np` will be used as
    it's the standard convention. Let's create a simple array and explain what the
    attributes hold by Python behind the scenes as metadata of the created array,
    so-called **attributes:**
  prefs: []
  type: TYPE_NORMAL
  zh: 如上一节所述，使 NumPy 与众不同的是使用称为`ndarrays`的多维数组。 所有`ndarray`项目都是同类的，并且在内存中使用相同的大小。
    让我们首先导入 NumPy，然后通过创建数组来分析 NumPy 数组对象的结构。 您可以通过在控制台中键入以下语句来轻松导入该库。 您可以使用任何命名约定代替`np`，但是在本书中，将使用`np`作为标准约定。
    让我们创建一个简单的数组，并说明 Python 在幕后所具有的属性作为所创建数组的元数据，即所谓的**属性**：
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, the type of our object is a NumPy array. `x.shape` returns
    a tuple which gives you the dimension of the array as an output such as *(n,m)*.
    You can get the total number of elements in an array by using `x.size`*.* In our
    example, we have six elements in total. Knowing attributes such as *shape and
    dimension* is very important. The more you know, the more you will be comfortable
    with computations. If you don''t know your array''s size and dimensions, it wouldn''t
    be wise to start doing computations with it. In NumPy, you can use `x.ndim` to
    check what the dimension of your array is. There are other attributes such as `dtype` and `nbytes`*,* which
    are very useful while you are checking memory consumption and verifying what kind
    of data type you should use in the array. In our example, each element has a data
    type of `int32` that consumes 24 bytes in total. You can also force some of these
    attributes while creating your array such as `dtype`. Previously, the data type
    was an integer. Let''s switch it to `float`, `complex`, or `uint` (unsigned integer). In
    order to see what the data type change does, let''s analyze what byte consumption
    is, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们对象的类型是 NumPy 数组。`x.shape`返回一个元组，该元组为您提供数组的维度作为输出，例如`(n, m)`。 您可以使用`x.size`获得数组中元素的总数。
    在我们的示例中，我们总共有六个元素。 知道*形状和大小*等属性非常重要。 您了解的越多，您对计算的适应就越多。 如果您不知道数组的大小和大小，那么开始使用数组进行计算就不明智了。
    在 NumPy 中，您可以使用`x.ndim`来检查数组的维数。 还有其他属性，例如`dtype`和`nbytes`，这些属性在检查内存使用情况并验证应该在数组中使用哪种数据类型时非常有用。
    在我们的示例中，每个元素的数据类型为`int32`，总共消耗 24 个字节。 您还可以在创建数组时强制使用其中某些属性，例如`dtype`。 以前，数据类型是整数。
    让我们将其切换为`float`，`complex`或`uint`（无符号整数）。 为了查看数据类型更改的作用，让我们分析一下字节消耗量，如下所示：
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, each type consumes a different number of bytes. Imagine you
    have a matrix as follows and that you are using `int64` or `int32` as the data
    type:'
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每种类型消耗不同数量的字节。 假设您有一个如下矩阵，并且您正在使用`int64`或`int32`作为数据类型：
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The memory need is doubled if you use `int64`. Ask this question to yourself;
    which data type would suffice? Until your numbers are higher than 2,147,483,648
    and lower than -2,147,483,647, using `int32` is enough. Imagine you have a huge
    array with a size over 100 MB. In such cases, this conversion plays a crucial
    role in performance.
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`int64`，则内存需求将增加一倍。 向自己问这个问题； 哪种数据类型就足够了？ 在您的数字大于 2,147,483,648 且小于 -2,147,483,647
    之前，使用`int32`就足够了。 假设您有一个大小超过 100MB 的巨大数组。 在这种情况下，这种转换对性能起着至关重要的作用。
- en: 'As you may have noticed in the previous example, when you were changing the
    data types, you were creating an array each time. Technically, you cannot change
    the `dtype` after you create the array. However, what you can do is either create
    it again or copy the existing one with a new `dtype` and with the `astype` attribute.
    Let''s create a copy of the array with the new `dtype`*.* Here is an example of
    how you can also change your `dtype` with the `astype` attribute:'
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上一个示例中可能已经注意到的那样，当您更改数据类型时，每次都在创建一个数组。 从技术上讲，创建数组后无法更改`dtype`。 但是，您可以做的是再次创建它，或者使用新的`dtype`和`astype`属性复制现有的文件。
    让我们使用新的`dtype`*创建数组的副本*。 下面是一个示例，说明如何使用`astype`属性也可以更改`dtype`：
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Please keep in mind that when you use the `astype` attribute, it doesn''t change
    the `dtype` of the `x_copy`, even though you applied it to `x_copy`*.* It keeps
    the `x_copy`, but creates a `x_copy_int`:'
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用`astype`属性时，即使将其应用于`x_copy`，它也不会更改`x_copy`的`dtype`。它保留`x_copy`，但创建一个`x_copy_int`：
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s imagine a case where you are working in a research group that tries
    to identify and calculate the risks of an individual patient who has cancer. You
    have 100,000 records (rows), where each row represents a single patient, and each
    patient has 100 features (results of some of the tests). As a result, you have
    (100000, 100) arrays:'
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个案例，您正在一个研究小组中工作，该研究小组试图确定和计算每个患癌症患者的风险。 您有 100,000 条记录（行），其中每一行代表一位患者，每位患者具有
    100 个特征（某些测试的结果）。 结果，您有`(100000, 100)`的数组：
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see from the preceding code, their size decreases from 80 MB to 40
    MB just by changing the `dtype`. What we get in return is less precision after
    decimal points. Instead of being precise to 16 decimals points, you will have
    only 7 decimals. In some machine learning algorithms, precision can be negligible.
    In such cases, you should feel free to adjust your `dtype` so that it minimizes
    your memory usage.
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看到，仅通过更改`dtype`即可将它们的大小从 80MB 减小到 40MB。 我们得到的回报是小数点后的精度较低。 除了精确到 16
    位小数点外，您将只有 7 位小数。 在某些机器学习算法中，精度可以忽略不计。 在这种情况下，您应该随意调整`dtype`，以最大程度地减少内存使用量。
- en: Chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ''
- en: NumPy array operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NumPy 数组操作
- en: 'This section will guide you through the creation and manipulation of numerical
    data with NumPy. Let''s start by creating a NumPy array from the list:'
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将指导您使用 NumPy 创建和处理数字数据。 让我们从列表中创建一个 NumPy 数组开始：
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s do some addition, subtraction, multiplication, and division with scalar
    values:'
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用标量值做一些加法，减法，乘法和除法：
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It''s much harder to do the same operations in a list because the list does
    not support vectorized operations and you need to iterate its elements. There
    are many ways to create NumPy arrays, and now you will use one of these methods
    to create an array which is full of zeros. Later, you will perform some arithmetic
    operations to see how NumPy behaves in element-wise operations between two arrays:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中执行相同的操作要困难得多，因为该列表不支持向量化操作，并且您需要迭代其元素。 创建 NumPy 数组的方法有很多，现在您将使用这些方法之一来创建一个充满零的数组。
    稍后，您将执行一些算术运算，以查看 NumPy 在两个数组之间的按元素运算中的行为：
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As we did in the previous code, you can create an array which is full of ones
    with `np.ones` or an identity array with `np.identity` and do the same algebraic
    operations that you did previously:'
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在前面的代码中所做的那样，您可以创建一个充满`np.ones`的数组或一个充满`np.identity`的标识数组，并执行与之前相同的代数运算：
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It works as expected with the `np.ones` method, but when you use the identity
    matrix, the calculation returns a *(4,4)* array as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以通过`np.ones`方法按预期工作，但是当您使用单位矩阵时，计算将返回`(4, 4)`数组，如下所示：
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'What this does is subtract the first element of `my_array` from all of the
    elements of the first column of `second_array` and the `second_element` of the
    second column, and so on. The same rule is applied to division as well. Please
    keep in mind that you can successfully do array operations even if they are not
    exactly the same shape. Later in this chapter, you will learn about broadcasting
    errors when computation cannot be done between two arrays due to differences in
    their shapes:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从`second_array`的第一列的所有元素和第二列的`second_element`的所有元素中减去`my_array`的第一个元素，依此类推。
    同样的规则也适用于除法。 请记住，即使形状不完全相同，也可以成功执行数组操作。 在本章的后面，您将了解当两个数组由于形状不同而无法进行计算时的广播错误：
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'One of the most useful methods in creating NumPy arrays is `arange`. This returns
    an array for a given interval between your start and end values. The first argument
    is the start value of your array, the second is the end value (where it stops
    creating values), and the third one is the interval. Optionally, you can define
    your `dtype` as the fourth argument. The default interval values are 1:'
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 NumPy 数组最有用的方法之一是`arange`。 这将在起始值和结束值之间的给定间隔内返回一个数组。 第一个参数是数组的起始值，第二个参数是终止值（在该位置它不再创建值），第三个参数是间隔。
    您可以选择将`dtype`定义为第四个参数。 默认间隔值为 1：
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There is another way to create an array with fixed intervals between the start
    and stop point when you cannot decide what the interval should be, but you should
    know how many splits your array should have:'
  prefs: []
  type: TYPE_NORMAL
  zh: 当您无法确定间隔应该是多少时，还有另一种方法可以在起点和终点之间创建具有固定间隔的数组，但是您应该知道数组应该有多少个拆分：
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There are two different methods which are similar in usage but return different
    sequences of numbers because their base scale is different. This means that the
    distribution of the numbers will be different as well. The first one is `geomspace`*,*
    which returns numbers on a logarithmic scale with a geometric progression:'
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种用法相似的不同方法，但由于它们的基本尺度不同，它们返回不同的数字序列。 这意味着数字的分布也将不同。 第一个是`geomspace`，它以几何级数返回对数刻度上的数字：
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The other important method is `logspace`, where you can return the values for
    your start and stop points, which are evenly scaled in:'
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的方法是`logspace`，您可以在其中返回起点和终点的值，这些值在以下位置均匀缩放：
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'What are these arguments? If the starting point is `3` and the ending point
    is `4`, then these functions return the numbers which are much higher than the
    initial range. Your starting point is actually set as default to `10**Start Argument
    and the ending is set as 10**End Argument`. So technically, in this example, the
    starting point is `10**3` and the ending point is `10**4`. You can avoid such
    situations and keep your start and end points the same as when you put them as
    arguments in the method. The trick is to use base 10 logarithms of the given arguments:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数是什么？ 如果起始点为`3`，结束点为`4`，则这些函数将返回比初始范围大得多的数字。 实际上，您的起点默认设置为`10`，终点也设置为`10`。
    因此，从技术上讲，在此示例中，起点为`10**3`，终点为`10**4`。 您可以避免这种情况，并使起点和终点与在方法中将其用作参数时相同。 诀窍是使用给定参数的以
    10 为底的对数：
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'By now, you should be familiar with different ways of creating arrays with
    different distributions. You have also learned how to do some basic operations
    with them. Let''s continue with other useful functions that you will definitely
    use in your day to day work. Most of the time, you will have to work with multiple
    arrays and you will need to compare them very quickly. NumPy has a great solution
    for this problem; you can compare the arrays as you would compare two integers:'
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该熟悉创建具有不同分布的数组的不同方法。 您还学习了如何对它们进行一些基本操作。 让我们继续您在日常工作中肯定会使用的其他有用函数。 大多数时候，您将不得不使用多个数组，并且需要非常快速地比较它们。
    NumPy 对这个问题有很好的解决方案。 您可以像比较两个整数一样比较数组：
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The comparison is done element-wise and it returns a Boolean vector, whether
    elements are matching in two different arrays or not. This method works well in
    small size arrays and also gives you more details. You can see from the output
    array where the values are represented as False, that these indexed values are
    not matching in these two arrays. If you have a large array, you may also choose
    to get a single answer to your question, whether the elements are matching in
    two different arrays or not:'
  prefs: []
  type: TYPE_NORMAL
  zh: 比较是逐个元素进行的，无论元素是否在两个不同的数组中匹配，它都会返回一个布尔向量。 此方法在小大小数组中效果很好，以及也为您提供了更多详细信息。 您可以从输出数组中看到以`False`表示的值，这些索引值在这两个数组中不匹配。
    如果数组很大，则还可以选择对问题的单个答案，即元素是否在两个不同的数组中匹配：
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, you have a single Boolean output. You only know that arrays are not equal,
    but you don''t know which elements exactly are not equal. The comparison is not
    only limited to checking whether two arrays are equal or not. You can also do
    element-wise higher- lower comparison between two arrays:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您只有一个布尔输出。 您只知道数组不相等，但是您不知道哪些元素完全不相等。 比较不仅限于检查两个数组是否相等。 您还可以在两个数组之间进行逐元素的上下比较：
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you need to do logical comparison (`AND`, `OR`, `XOR`), you can use them
    in your array as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要进行逻辑比较（`AND`，`OR`和`XOR`）时，可以在数组中使用它们，如下所示：
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So far, algebraic operations such as addition and multiplication have been covered.
    How can we use these operations with transcendental functions such as the exponential
    function, logarithms, or trigonometric functions?
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，已经介绍了诸如加法和乘法之类的代数运算。 我们如何将这些运算与指数函数，对数函数或三角函数之类的超越函数一起使用？
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What about the transpose of a matrix? First, you will use the `reshape` function
    with `arange` to set the desired shape of the matrix:'
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的转置呢？ 首先，您将`reshape`函数与`arange`一起使用以设置所需的矩阵形状：
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You transpose the *3*3* array, so the shape doesn''t change because both dimensions
    are *3*. Let''s see what happens when you don''t have a square array:'
  prefs: []
  type: TYPE_NORMAL
  zh: 您转置了`3 * 3`数组，因此形状不会改变，因为两个大小均为`3`。 让我们看看没有平方数组时会发生什么：
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The transpose works as expected and the dimensions are switched as well. You
    can also get summary statistics from arrays such as mean, median, and standard
    deviation. Let''s start with methods that NumPy offers for calculating basic statistics:'
  prefs: []
  type: TYPE_NORMAL
  zh: 转置将按预期工作，并且大小也会切换。 您还可以从数组中获取摘要统计信息，例如均值，中位数和标准差。 让我们从 NumPy 提供的用于计算基本统计信息的方法开始：
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **说明** |'
- en: '| `np.sum` | Returns the sum of all array values or along the specified axis
    |'
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `np.amin` | Returns the minimum value of all arrays or along the specified
    axis |'
  prefs: []
  type: TYPE_TB
  zh: '| `np.sum` | 返回数组所有值沿指定轴的总和 |'
- en: '| `np.amax` | Returns the maximum value of all arrays or along the specified
    axis |'
  prefs: []
  type: TYPE_TB
  zh: '| `np.amin` | 返回数组所有值或沿指定轴的最小值 |'
- en: '| `np.percentile` | Returns the given q^(th) percentile of all arrays or along
    the specified axis |'
  prefs: []
  type: TYPE_TB
  zh: '| `np.amax` | 返回数组所有值或沿指定轴的最大值 |'
- en: '| `np.nanmin` | The same as `np.amin`, but ignores NaN values in an array |'
  prefs: []
  type: TYPE_TB
  zh: '| `np.percentile` | 返回数组所有值或沿指定轴的第 n 个的给定百分数 |'
- en: '| `np.nanmax` | The same as `np.amax`, but ignores NaN values in an array |'
  prefs: []
  type: TYPE_TB
  zh: '| `np.nanmin` | 与`np.amin`相同，但忽略数组中的 NaN 值 |'
- en: '| `np.nanpercentile` | The same as `np.percentile`, but ignores NaN values
    in an array |'
  prefs: []
  type: TYPE_TB
  zh: '| `np.nanmax` | 与`np.amax`相同，但忽略数组中的 NaN 值 |'
- en: ''
  prefs: []
  type: TYPE_TB
  zh: '| `np.nanpercentile` | 与`np.percentile`相同，但忽略数组中的 NaN 值 |'
- en: 'The following code block gives an example of the preceding statistical methods
    of NumPy. These methods are very useful as you can operate the methods in a whole
    array or axis-wise according to your needs. You should note that you can find
    more fully-featured and better implementations of these methods in SciPy as it
    uses NumPy multidimensional arrays as a data structure:'
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块给出了前面的 NumPy 统计方法的示例。 这些方法非常有用，因为您可以根据需要在整个数组中或轴向操作这些方法。 您应该注意，由于 SciPy
    使用 NumPy 多维数组作为数据结构，因此可以在 SciPy 中找到这些方法的功能更完善的更好的实现：
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The axis argument determines the dimension that this function will operate
    on. In this example, axis=0 represents the first axis which is the *x* axis, and
    axis = 1 represents the second axis which is `y`. When we use a regular `amin(x)`,
    we return a single value because it calculates the minimum value in all arrays,
    but when we specify the axis, it starts evaluating the function axis-wise and
    returns an array which shows the results for each row or column. Imagine you have
    a large array; you find the max value by using `amax`, but what will happen if
    you need to pass the index of this value to another function? In such cases, `argmin`
    and `argmax` come to the rescue, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`axis`参数确定此函数将要作用的大小。 在此示例中，轴`= 0`代表第一个轴，即`x`轴，轴`= 1`代表第二个轴，即`y`。 当我们使用常规`amin(x)`时，我们返回单个值，因为它会计算所有数组中的最小值，但是当我们指定轴时，它将开始沿轴方向计算函数并返回一个数组，该数组显示每行或列的结果。
    想象一下，您有很多人。 您可以使用`amax`找到最大值，但是如果您需要将此值的索引传递给另一个函数，将会发生什么？ 在这种情况下，`argmin`和`argmax`可以提供帮助，如以下代码片段所示：'
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s continue with more statistical functions:'
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续更多的统计函数：
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **说明** |'
- en: '| `np.mean` | Returns the mean of all array values or along the specific axis
    |'
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `np.median` | Returns the median of all array values or along the specific
    axis |'
  prefs: []
  type: TYPE_TB
  zh: '| `np.mean` | 返回数组所有值或沿特定轴的平均值 |'
- en: '| `np.std` | Returns the standard deviation of all array values or along the
    specific axis |'
  prefs: []
  type: TYPE_TB
  zh: '| `np.median` | 返回数组所有值或沿特定轴的中值 |'
- en: '| `np.nanmean` | The same as `np.mean`, but ignores NaN values in an array
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `np.std` | 返回数组所有值或沿特定轴的标准差 |'
- en: '| `np.nanmedian` | The same as `np.nanmedian`, but ignores NaN values in an
    array |'
  prefs: []
  type: TYPE_TB
  zh: '| `np.nanmean` | 与`np.mean`相同，但忽略数组中的 NaN 值 |'
- en: '| `np.nonstd` | The same as `np.nanstd`, but ignores NaN values in an array
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `np.nanmedian` | 与`np.nanmedian`相同，但忽略数组中的 NaN 值 |'
- en: ''
  prefs: []
  type: TYPE_TB
  zh: '| `np.nonstd` | 与`np.nanstd`相同，但忽略数组中的 NaN 值 |'
- en: 'The following code gives more examples of the preceding statistical methods
    of NumPy. These methods are heavily used in data discovery phases, where you analyze
    your data features and distribution:'
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码提供了 NumPy 的先前统计方法的更多示例。 这些方法在数据发现阶段中大量使用，您可以在其中分析数据特征和分布：
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ''
- en: Working with multidimensional arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理多维数组
- en: This section will give you a brief understanding of multidimensional arrays
    by going through different matrix operations.
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将通过执行不同的矩阵运算使您对多维数组有一个简要的了解。
- en: 'In order to do matrix multiplication in NumPy, you have to use `dot()` instead
    of `***`. Let''s see some examples:'
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 NumPy 中进行矩阵乘法，您必须使用`dot()`而不是`*`。 让我们看一些例子：
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The most important topic in working with multidimensional arrays is stacking,
    in other words how to merge two arrays. `hstack` is used for stacking arrays horizontally
    (column-wise) and `vstack` is used for stacking arrays vertically (row-wise).
    You can also split the columns with the `hsplit` and `vsplit` methods in the same
    way that you stacked them:'
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多维数组时，最重要的主题是堆栈，即如何合并两个数组。`hstack`用于水平（列方式）堆叠数组，`vstack`用于垂直（行方式）堆叠数组。 您还可以使用`hsplit`和`vsplit`方法拆分列，方法与堆叠它们相同：
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'These methods are very useful in machine learning applications, especially
    when creating datasets. After you stack your arrays, you can check their descriptive
    statistics by using `Scipy.stats`. Imagine a case where you have `100` records,
    and each record has `10` features, which means you have a 2D matrix which has
    `100` rows and `10` columns. The following example shows how you can easily get
    some descriptive statistics for each feature:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法在机器学习应用中非常有用，尤其是在创建数据集时。 堆叠数组后，可以使用`Scipy.stats`检查其描述性统计信息。 假设有一个`100`记录，并且每个记录都具有`10`个特征，这意味着您有一个
    2D 矩阵，其中包含`100`行和`10`列。 下面的示例说明如何轻松获取每个特征的一些描述性统计信息：
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'NumPy has a great module named `numpy.ma`, which is used for masking array
    elements. It''s very useful when you want to mask (ignore) some elements while
    doing your calculations. When NumPy masks, it will be treated as an invalid and
    does not take into account computation:'
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 有一个很棒的模块`numpy.ma`，用于屏蔽数组元素。 当您要在计算时屏蔽（忽略）某些元素时，它非常有用。 当 NumPy 数组被屏蔽时，它将被视为无效，并且不考虑计算：
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding code, you have an array `x = [0,1,2,3,4,5]`. What you do is
    mask the first element of the array and then calculate the mean. When an element
    is masked as `1(True)`, the associated index value in the array will be masked.
    This method is also very useful while replacing the NAN values:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您有一个数组`x = [0,1,2,3,4,5]`。 您要做的是屏蔽数组的第一个元素，然后计算平均值。 当一个元素被屏蔽为`1(True)`时，数组中的关联索引值将被屏蔽。
    在替换 NAN 值时，此方法也非常有用：
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In preceding code, we changed the value of the first five elements to `nan` by
    putting a condition with index. `x[x<5]` refers to the elements which indexed
    for 0, 1, 2, 3, and 4\. Then we overwrite these values with the mean of each column(excluding
    `nan` values). There are many other useful methods in array operations in order
    help your code be more concise:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过放置一个带有索引的条件将前五个元素的值更改为`nan`。`x[x<5]`指的是索引为 0、1、2、3 和 4 的元素。然后，我们用每列的平均值覆盖这些值（`nan`值除外）。
    为了帮助您的代码更简洁，数组操作中还有许多其他有用的方法：
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **说明** |'
- en: '| `np.concatenate` | Join to the matrix in a sequence with a given matrix |'
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `np.repeat` | Repeat the element of an array along a specific axis |'
  prefs: []
  type: TYPE_TB
  zh: '| `np.concatenate` | 连接列表中的给定数组 |'
- en: '| `np.delete` | Return a new array with the deleted subarrays |'
  prefs: []
  type: TYPE_TB
  zh: '| `np.repeat` | 沿特定轴重复数组的元素 |'
- en: '| `np.insert` | Insert values before the specified axis |'
  prefs: []
  type: TYPE_TB
  zh: '| `np.delete` | 返回一个带有删除的子数组的新数组 |'
- en: '| `np.unique` | Find unique values in an array |'
  prefs: []
  type: TYPE_TB
  zh: '| `np.insert` | 在指定轴之前插入值 |'
- en: '| `np.tile` | Create an array by repeating a given input for a given number
    of repetitions |'
  prefs: []
  type: TYPE_TB
  zh: '| `np.unique` | 在数组中查找唯一值 |'
- en: ''
  prefs: []
  type: TYPE_TB
  zh: '| `np.tile` | 通过以给定的重复次数重复给定的输入来创建数组 |'
- en: ''
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引，切片，重塑，调整大小和广播
- en: ''
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在机器学习项目中使用大量数组时，通常需要索引，切片，调整形状和调整大小。
- en: ''
  prefs: []
  type: TYPE_NORMAL
  zh: 索引是数学和计算机科学中使用的一个基本术语。 一般而言，索引可帮助您指定如何返回各种数据结构的所需元素。 下面的示例显示列表和元组的索引：
- en: ''
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ''
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NumPy 中，索引的主要用途是控制和操纵数组的元素。 这是一种创建通用查找值的方法。 索引包含三个子操作，分别是字段访问，基本切片和高级索引。 在字段访问中，只需指定数组中元素的索引即可返回给定索引的值。
- en: ''
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 在索引和切片方面非常强大。 在许多情况下，您需要在数组中引用所需的元素，然后对该切片区域执行操作。 您可以对数组进行索引，类似于对元组或带有方括号的列表进行索引。
    让我们从字段访问和使用一维数组的简单切片开始，然后继续使用更高级的技术：
- en: ''
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ''
  prefs: []
  type: TYPE_NORMAL
  zh: 索引从`0`开始，因此在创建带有元素的数组时，第一个元素被索引为`x[0]`，与最后一个元素`x[n-1]`相同。 如您在前面的示例中看到的，`x[5]`指的是第六个元素。
    您也可以在索引中使用负值。 NumPy 将这些值理解为倒数第`n`个。 像示例中一样，`x[-2]`指倒数第二个元素。 您还可以通过声明开始索引和结束索引来选择数组中的多个元素，也可以通过将增量级别作为第三个参数声明来创建顺序索引，如代码的最后一行所示。
- en: ''
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了一维数组中的索引和切片。 逻辑不会改变，但是为了演示起见，我们也对多维数组进行一些练习。 当您拥有多维数组时，唯一发生变化的就是只有更多的轴。
    您可以在以下代码中将 n 维数组切片为`[x 轴切片，y 轴切片]`：
- en: ''
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ''
  prefs: []
  type: TYPE_NORMAL
  zh: 您按行和列对数组进行了切片，但没有以更加不规则或更具动态性的方式对元素进行切片，这意味着您始终以矩形或正方形的方式对其进行切片。 想象一下我们要切片的`4
    * 4`数组，如下所示：
- en: ''
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa3abe44-7bc3-4b18-ace5-94cb83554861.png)'
- en: ''
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得前面的切片，我们执行以下代码：
- en: ''
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ''
  prefs: []
  type: TYPE_NORMAL
  zh: 在高级索引中，第一部分指示要切片的行的索引，第二部分指示相应的列。 在前面的示例中，您首先切片了第一，第二和第三行（`[0,1,2]`），然后切片第一，第二和第四列。
- en: ''
  prefs: []
  type: TYPE_NORMAL
  zh: 整形和调整大小方法似乎很相似，但是这些操作的输出有所不同。 重新排列数组的形状时，只是输出会临时更改数组的形状，但不会更改数组本身。 调整数组大小时，它将永久更改数组的大小，如果新数组的大小大于旧数组的大小，则新数组元素将填充旧数组的重复副本。
    相反，如果新数组较小，则新数组将从旧数组中获取元素，并按索引顺序填充新数组。 请注意，相同的数据可以由不同的`ndarray`共享。这意味着一个`ndarray`可以是另一个`ndarray`的视图。
    在这种情况下，对一个数组进行的更改将对其他视图产生影响。
- en: ''
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码给出了一个示例，说明当大小大于或小于原始数组时如何填充新数组元素：
- en: ''
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ''
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节的最后一个重要术语是广播，它解释了当 NumPy 具有不同形状时在数组的算术运算中如何表现。 NumPy 有两个广播规则：数组的大小相等或其中之一为
    1。如果不满足以下条件之一，则将得到以下两个错误之一：`frames are not aligned`或`operands could not be broadcast
    together`：
- en: ''
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ''
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经看到可以将两个矩阵的形状分别为`(4, 4)`和`(4,)`或`(2, 2)`和`(1, 2)`。 第一种情况满足具有一维的条件，因此乘法成为向量`*`数组，这不会引起任何广播问题：
- en: ''
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ''
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块提供了第二种情况的示例，其中在计算过程中，小数组迭代通过大数组，并且输出扩展到整个数组。 这就是为什么有`(4, 4)`和`(2, 2)`输出的原因：在乘法过程中，两个数组都以较大的大小广播。
- en: ''
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: ''
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您熟悉了 NumPy 数组操作的基础知识，并刷新了有关基本矩阵操作的知识。 NumPy 是用于 Python 科学堆栈的极其重要的库，它具有用于数组操作的广泛方法。
    您已经学习了如何使用多维数组，并涵盖了重要的主题，例如索引，切片，整形，调整大小和广播。 本章的主要目的是让您简要了解有关数字数据集的 NumPy 的工作方式，这将对您的日常数据分析工作有所帮助。
- en: ''
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习线性代数的基础知识以及使用 NumPy 完整的实际示例。
- en: Chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ''
- en: Indexing, slicing, reshaping, resizing, and broadcasting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ''
- en: When you are working with huge arrays in machine learning projects, you often
    need to index, slice, reshape, and resize.
  prefs: []
  type: TYPE_NORMAL
  zh: ''
- en: 'Indexing is a fundamental term used in mathematics and computer science. As
    a general term, indexing helps you to specify how to return desired elements of
    various data structures. The following example shows indexing for a list and a
    tuple:'
  prefs: []
  type: TYPE_NORMAL
  zh: ''
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
  zh: ''
- en: In NumPy, the main usage of indexing is controlling and manipulating the elements
    of arrays. It's a way of creating generic lookup values. Indexing contains three
    child operations, which are field access, basic slicing, and advanced indexing.
    In field access, you just specify the index of an element in an array to return
    the value for a given index.
  prefs: []
  type: TYPE_NORMAL
  zh: ''
- en: 'NumPy is very powerful when it comes to indexing and slicing. In many cases,
    you need to refer your desired element in an array and do the operations on this
    sliced area. You can index your array similarly to what you do with tuples or
    lists with square bracket notations. Let''s start with field access and simple
    slicing with one-dimensional arrays and move on to more advanced techniques:'
  prefs: []
  type: TYPE_NORMAL
  zh: ''
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
  zh: ''
- en: Indexing starts from `0`, so when you create an array with an element, your
    first element is indexed as `x[0]`, the same way as your last element, `x[n-1]`.
    As you can see in the preceding example, `x[5]` refers to the sixth element. You
    can also use negative values in indexing. NumPy understands these values as the
    *n^(th)* orders backwards. Like in the example, `x[-2]` refers to the second to
    last element. You can also select multiple elements in your array by stating the
    starting and ending indexes and also creating sequential indexing by stating the
    increment level as a third argument, as in the last line of the code.
  prefs: []
  type: TYPE_NORMAL
  zh: ''
- en: 'So far, we have seen indexing and slicing in 1D arrays. The logic does not
    change, but for the sake of demonstration, let''s do some practice for multidimensional
    arrays as well. The only thing that changes when you have multidimensional arrays
    is just having more axis. You can slice the n-dimensional array as [slicing in
    x-axis, slicing in y-axis] in the following code:'
  prefs: []
  type: TYPE_NORMAL
  zh: ''
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
  zh: ''
- en: 'You sliced the arrays row and column-wise, but you haven''t sliced the elements
    in a more irregular or more dynamic fashion, which means you always slice them
    in a rectangular or square way. Imagine a 4*4 array that we want to slice as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: ''
- en: '![](img/aa3abe44-7bc3-4b18-ace5-94cb83554861.png)'
  prefs: []
  type: TYPE_IMG
  zh: ''
- en: 'To obtain the preceding slicing, we execute the following code:'
  prefs: []
  type: TYPE_NORMAL
  zh: ''
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
  zh: ''
- en: In advanced indexing, the first part indicates the index of rows to be sliced
    and the second part indicates the corresponding columns. In the preceding example,
    you first sliced the *1^(st)*, *2^(nd)*, and *3^(rd)* rows (`[0,1,2]`) and then
    sliced the *1^(st)*, *2^(nd)* and *4^(th)* columns (`[0,1,3]`) into sliced rows.
  prefs: []
  type: TYPE_NORMAL
  zh: ''
- en: The reshape and resize methods may seem similar, but there are differences in
    the outputs of these operations. When you reshape the array, it's just the output
    that changes the shape of the array temporarily, but it does not change the array
    itself. When you resize the array, it changes the size of the array permanently,
    and if the new array's size is bigger than the old one, the new array elements
    will be filled with repeated copies of the old ones. On the contrary, if the new
    array is smaller, a new array will take the elements from the old array with the
    order of index which is required to fill the new one. Please note that same data
    can be shared by different ndarrays which means that an ndarray can be a view
    to another ndarray. In such cases changes made in one array will have consequences
    on other views.
  prefs: []
  type: TYPE_NORMAL
  zh: ''
- en: 'The following code gives an example of how the new array elements are filled
    when the size is bigger or smaller than the original array:'
  prefs: []
  type: TYPE_NORMAL
  zh: ''
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
  zh: ''
- en: 'The last important term of this subsection is broadcasting, which explains
    how NumPy behaves in arithmetic operations of the array when they have different
    shapes. NumPy has two rules for broadcasting: either the dimensions of the arrays
    are equal, or one of them is 1\. If one of these conditions is not met, then you
    will get one of the two errors: `frames are not aligned` or `operands could not
    be broadcast together`:'
  prefs: []
  type: TYPE_NORMAL
  zh: ''
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
  zh: ''
- en: 'You might have seen that you can multiply two matrices with shapes *(4, 4)*
    and *(4,)* or with *(2, 2)* and *(2, 1)*. The first case meets the condition of
    having one dimension so that the multiplication becomes a vector `*` array, which
    does not cause any broadcasting problems:'
  prefs: []
  type: TYPE_NORMAL
  zh: ''
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
  zh: ''
- en: 'The preceding code block gives an example for the second case, where during
    computation small arrays iterate through the large array and the output is stretched
    across the whole array. That''s the reason why there are *(4, 4)* and *(2, 2)*
    outputs: during the multiplication, both arrays are broadcast to larger dimensions.'
  prefs: []
  type: TYPE_NORMAL
  zh: ''
- en: Chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ''
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ''
- en: In this chapter, you got familiar with NumPy basics for array operations and
    refreshed your knowledge about basic matrix operations. NumPy is an extremely
    important library for Python scientific stacks, with its extensive methods for
    array operations. You have learned how to work with multidimensional arrays and
    covered important topics such as indexing, slicing, reshaping, resizing, and broadcasting.
    The main goal of this chapter was to give you a brief idea of how NumPy works
    when it comes to numerical datasets, which will be helpful in your daily data
    analysis work.
  prefs: []
  type: TYPE_NORMAL
  zh: ''
- en: In the next chapter, you will learn the basics of linear algebra and complete
    practical examples with NumPy.
  prefs: []
  type: TYPE_NORMAL
  zh: ''

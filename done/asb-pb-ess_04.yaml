- en: Chapter 3. Separating Code and Data – Variables, Facts, and Templates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。分离代码和数据-变量、事实和模板
- en: In the previous chapter, we looked at how to write a role to provide modularity
    and abstraction. While doing so, we created the configuration file and copied
    the file over to the destination host using Ansible's copy module.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看了如何编写一个角色来提供模块化和抽象。在这样做的过程中，我们创建了配置文件，并使用Ansible的复制模块将文件复制到目标主机。
- en: 'In this chapter, we will cover the following concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下概念：
- en: How do you separate data from code?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何将数据与代码分开？
- en: What are Jinja2 templates? How are these created?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jinja2模板是什么？它们是如何创建的？
- en: What are variables? How and where are they used?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量是什么？它们是如何以及在哪里被使用的？
- en: What are system facts? How are they discovered?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统事实是什么？它们是如何被发现的？
- en: What are the different types of variables?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的变量是什么？
- en: What is a variable merge order? What are its precedence rules?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量合并顺序是什么？它的优先规则是什么？
- en: Static content explosion
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态内容爆炸
- en: 'Let''s imagine that we are managing a cluster of hundreds of web servers spanning
    across multiple data centers. Since we have the `server_name` parameter hardcoded
    in to the `config` file, we will have to create one file per server. This also
    means that we will manage hundreds of static files, which will quickly get out
    of control. Our infrastructure is dynamic, and managing change is one of the most
    common aspects of a DevOps engineer''s routine tasks. If tomorrow, our company
    policy states that we should run web servers on the port 8080 instead of the port
    80, only in a production environment, imagine the headache you''d get having to
    change all these files individually. Wouldn''t it be better to have a single file
    that takes dynamic inputs, which are specific to the host it''s running on? This
    is exactly what templates are for and, as depicted in the following diagram, a
    single template could replace a multitude of static files:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们正在管理跨越多个数据中心的数百台Web服务器的集群。由于`server_name`参数硬编码到`config`文件中，我们将不得不为每台服务器创建一个文件。这也意味着我们将管理数百个静态文件，这将很快失控。我们的基础设施是动态的，管理变化是DevOps工程师日常任务中最常见的方面之一。如果明天，我们公司的政策规定我们应该在端口8080而不是端口80上运行Web服务器，只在生产环境中，想象一下你必须逐个更改所有这些文件会有多头痛。有一个单一的文件，它接受特定于其运行的主机的动态输入，这不是更好吗？这正是模板的用途，如下图所示，一个模板可以替换大量的静态文件：
- en: '![Static content explosion](graphics/B03800_03_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![静态内容爆炸](graphics/B03800_03_01.jpg)'
- en: Before we define what a template is, let's begin by understanding how to separate
    code from data and how this would help us solve the problem of static content
    explosion.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义模板是什么之前，让我们先了解如何将代码与数据分开，以及这如何帮助我们解决静态内容爆炸的问题。
- en: Separating code and data
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离代码和数据
- en: 'The real magic of infrastructure as code tools, such as Ansible, lies in its
    ability to separate data and code. In our example, the `default.conf` file is
    a configuration file that is specific to an Nginx web server. The configuration
    parameters, such as ports, users, paths, and so on, remain generic and constant
    at all times, no matter who installs and configures them. What is not constant
    are the values those parameters take. That''s what is specific to our organization.
    So, for this, we would decide the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施即代码工具（如Ansible）的真正魔力在于它能够将数据和代码分开。在我们的例子中，`default.conf`文件是特定于Nginx Web服务器的配置文件。配置参数，如端口、用户、路径等，在任何时候都保持通用和恒定，无论谁安装和配置它们。不恒定的是这些参数的值。这就是我们组织的特定之处。因此，对于这一点，我们将决定以下事项：
- en: Which port should Nginx run on?
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nginx应该运行在哪个端口上？
- en: Which user should own the web server process?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个用户应该拥有Web服务器进程？
- en: Where should the log files go?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志文件应该放在哪里？
- en: How many worker processes should be run?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该运行多少个工作进程？
- en: Our organization-specific policies may also require us to pass different values
    to these parameters based on the environment or geography the hosts run in.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组织特定的策略也可能要求我们根据主机运行的环境或地理位置传递不同的值给这些参数。
- en: 'Ansible splits these in to two parts:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible将其分为两部分：
- en: The code that is generic
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用的代码
- en: The data that is specific to an organization
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定于组织的数据
- en: This has two advantages; one advantage is that it solves our problem of static
    data explosion. Now that we have separated the code and data, we can create `config`
    files flexibly and dynamically. The second advantage, you may realize, is now
    that the code and data are split, there is nothing in the code that is specific
    to a particular organization. This makes it easy to share the site with the world
    for anyone who finds it useful. That's exactly what you would find on Ansible-Galaxy
    or even on GitHub, fueling the growth of tools, such as Ansible. Instead of reinventing
    the wheel, you can download the code that someone else has written, customize
    it, fill in the data specific to the code, and get the work done.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两个优点；一个优点是解决了静态数据爆炸的问题。现在我们已经将代码和数据分开，可以灵活动态地创建`config`文件。第二个优点，你可能会意识到，现在代码和数据分开了，代码中没有任何特定于特定组织的内容。这使得可以轻松地与发现它有用的任何人分享该网站。这正是您在Ansible-Galaxy甚至GitHub上找到的，推动了诸如Ansible之类的工具的增长。您可以下载其他人编写的代码，自定义它，填写特定于代码的数据，并完成工作，而不是重新发明轮子。
- en: 'Now, how is this code separate from the data? The answer is that Ansible has
    two primitives:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这段代码如何与数据分离？答案是Ansible有两个基本原则：
- en: Jinja templates (code)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jinja模板（代码）
- en: The variables (data)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量（数据）
- en: 'The following diagram explains how the resulting file is generated from templates
    and variables:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图解释了如何从模板和变量生成结果文件：
- en: '![Separating code and data](graphics/B03800_03_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![分离代码和数据](graphics/B03800_03_02.jpg)'
- en: Templates provide placeholders in place of parameter values, which are then
    defined in variables. Variables can then be fed in from various places, including
    roles, playbooks, inventories, and even from the command line when you launch
    Ansible. Let's now understand templates and variables in detail.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 模板提供了参数值的占位符，然后在变量中定义。变量可以从各个地方输入，包括角色、playbooks、清单，甚至在启动Ansible时从命令行输入。现在让我们详细了解模板和变量。
- en: Jinja2 templates
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jinja2模板
- en: What is **Jinja** all about? **Jinja2** is a very popular and powerful Python-based
    template engine. Since Ansible is written in Python, it becomes the default choice
    for most users, just like other Python-based configuration management systems,
    such as **Fabric** and **SaltStack**. The name Jinja originated from the Japanese
    word for temple, which is similar in phonetics to the word template.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jinja**是什么？**Jinja2**是一个非常流行和强大的基于Python的模板引擎。由于Ansible是用Python编写的，它成为大多数用户的默认选择，就像其他基于Python的配置管理系统，如**Fabric**和**SaltStack**一样。Jinja的名称源自日语中的寺庙一词，与模板一词在语音上相似。'
- en: 'Some of the important features of Jinja2 are:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2的一些重要特性是：
- en: It is fast and compiled just in time with the Python byte code
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它快速，并且使用Python字节码进行即时编译
- en: It has an optional sandboxed environment
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个可选的沙盒环境
- en: It is easy to debug
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于调试
- en: It supports template inheritance
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持模板继承
- en: The template formation
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板形成
- en: 'Templates look very similar to normal text-based files except for the occasional
    variables or code that surrounds the special tags. These get evaluated and are
    mostly replaced by values at runtime, creating a text file, which is then copied
    to the destination host. The following are the two types of tags that Jinja2 templates
    accept:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 模板看起来与普通的基于文本的文件非常相似，除了偶尔出现的变量或围绕特殊标记的代码。这些被评估并在运行时大多被值替换，从而创建一个文本文件，然后将其复制到目标主机。以下是Jinja2模板接受的两种类型的标记：
- en: '`{{ }}` embeds variables inside a template and prints its value in the resulting
    file. This is the most common use of a template.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{ }}`将变量嵌入到模板中，并在生成的文件中打印其值。这是模板的最常见用法。'
- en: 'For example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`{% %}` embeds statements of code inside a template, for example, for a loop,
    it embeds the if-else statements, which are evaluated at runtime but are not printed.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{% %}`将代码语句嵌入到模板中，例如，用于循环的if-else语句，这些语句在运行时进行评估，但不会被打印。'
- en: Facts and variables
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事实和变量
- en: Now that we have looked at the code that Jinja2 templates provide, let's understand
    where this data comes from, which is then embedded in the template at runtime.
    Data can come from either facts or variables. When it comes to a Jinja2 template,
    the same rules apply to the usage of facts and variables. Facts are a type of
    variable; the differentiating factor here is the origin of the two. Facts are
    automatically available and discovered at runtime, and variables are user-defined.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看过Jinja2模板提供的代码，让我们了解一下这些数据来自哪里，然后在运行时嵌入到模板中。数据可以来自事实或变量。当涉及到Jinja2模板时，相同的规则适用于事实和变量的使用。事实是一种变量；这里的区别因素是这两者的来源。事实在运行时自动可用和发现，而变量是用户定义的。
- en: Automatic variables – facts
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动变量-事实
- en: 'A lot of data in our systems is automatically discovered and made available
    to Ansible by the managed hosts during the handshake process. This data is very
    useful and tells us everything about that system, such as:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们系统中的许多数据是在握手过程中由受管主机自动发现并提供给Ansible的。这些数据非常有用，并告诉我们有关该系统的一切，例如：
- en: The hostname, network interface, and IP address
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机名、网络接口和IP地址
- en: The system architecture
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统架构
- en: The operating system
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统
- en: The disk drives
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘驱动器
- en: The processor used and amount of memory
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的处理器和内存量
- en: Whether it is a VM; if yes, is it a virtualization/cloud provider?
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论是VM；如果是，它是虚拟化/云提供商吗？
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Facts are collected at the very beginning of an Ansible run. Remember the line
    in the output that says **GATHERING FACTS *********? That's exactly when this
    happens.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是在Ansible运行的最开始收集的。记住输出中的一行说**GATHERING FACTS *********吗？这正是发生这种情况的时候。
- en: 'You can find facts about any system by running the following command followed
    by a shortened output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令找到有关任何系统的事实，然后是缩短的输出：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding output is in Ansible''s own format and uses its core setup module.
    Akin to the setup module, there is another module by the name `facter`, which
    discovers and displays facts in the format discovered with Puppet, another configuration
    management system. The following is an example of how to use the `facter` module
    to discover facts for the same host:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出是以Ansible自己的格式并使用其核心设置模块。类似于设置模块，还有另一个名为`facter`的模块，它以Puppet发现的格式发现并显示事实，Puppet是另一个配置管理系统。以下是如何使用`facter`模块来发现相同主机的事实的示例：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While using the `facter` module, a point that you need to note is that this
    module is not a core module and comes as part of extra modules. Extras modules
    are a subset of the Ansible module, which is used less frequently and is less
    popular in comparison with the core modules. Moreover, to use the `facter` module,
    you require the "`facter`" and "`ruby-json`" packages preinstalled on the target
    host.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`facter`模块时，您需要注意的一点是，该模块不是核心模块，而是作为额外模块的一部分。额外模块是Ansible模块的一个子集，使用频率较低，与核心模块相比较不受欢迎。此外，要使用`facter`模块，您需要在目标主机上预先安装"`facter`"和"`ruby-json`"软件包。
- en: User-defined variables
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户定义的变量
- en: 'We looked at facts, which are automatically available, and the amount of data
    that is discovered is overwhelming. However, it does not provide us with every
    attribute of our infrastructure that we need. For example, Ansible can not discover:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看了事实，这些事实是自动可用的，发现的数据量是令人震惊的。但是，它并没有为我们提供我们需要的基础设施的每个属性。例如，Ansible无法发现：
- en: Which port we want our web server to listen to
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望我们的Web服务器监听哪个端口
- en: Which user should own a process
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个用户应该拥有一个进程
- en: Which system the users need to create, with which authorization rules
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户需要创建哪个系统，使用哪些授权规则
- en: All this data is external to a system profile and is to be provided by us, the
    users. It's user-defined for sure, but how and where should we define it? That's
    what we are going to look at next.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数据都是外部的系统配置文件，并且需要我们用户提供。这肯定是用户定义的，但我们应该如何在哪里定义它呢？这就是我们接下来要看的。
- en: Where to define a variable
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在哪里定义变量
- en: Where a variable can be defined from is a complex phenomenon, as Ansible offers
    abundant choices in this regard. This also offers a lot of flexibility to users
    to configure portions of their infrastructures divergently. For example, all Linux
    hosts in a production environment should use local package repositories or web
    servers in staging and should run on the port 8080\. All this without changing
    the code, and driven by data alone is done, by variables.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以从哪里定义是一个复杂的现象，因为Ansible在这方面提供了丰富的选择。这也为用户提供了很大的灵活性，可以以不同的方式配置其基础设施的部分。例如，生产环境中的所有Linux主机应该使用本地软件包存储库或分期中的Web服务器，并且应该在端口8080上运行。所有这些都不需要更改代码，仅通过数据驱动完成，通过变量。
- en: 'The following are the places from where Ansible accepts variables:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Ansible接受变量的位置：
- en: The `default` directory inside a role
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色内的`default`目录
- en: Inventory variables
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清单变量
- en: The `host_vars` and `group_vars` parameters defined in separate directories
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单独的目录中定义的`host_vars`和`group_vars`参数
- en: The `host/group vars` parameter defined in an inventory file
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在清单文件中定义的`host/group vars`参数
- en: Variables in playbooks and role parameters
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: playbooks和角色参数中的变量
- en: The `vars` directory inside a role and variables defined inside a play
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色内的`vars`目录和在play内定义的变量
- en: Extra variables provided with the `-e` option at runtime
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时使用`-e`选项提供的额外变量
- en: How to define a variable
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何定义变量
- en: After looking at where to define the variable from, we will start looking at
    how to define it at various places.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看了变量的定义位置之后，我们将开始查看如何在各个位置定义它。
- en: 'Here are some simple rules you can use to form a valid Ansible variable:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以使用的一些简单规则来形成有效的Ansible变量：
- en: A variable should always start with a letter
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量应该始终以字母开头
- en: 'It can contain:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以包含：
- en: Letters
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字母
- en: Numbers
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: Underscores
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下划线
- en: 'Let''s take a look at the following table:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下下表：
- en: '| Valid variable | Invalid variable |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 有效变量 | 无效变量 |'
- en: '| --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `app_port` | `app-port` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `app_port` | `app-port` |'
- en: '| `userid_5` | `5userid` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `userid_5` | `5userid` |'
- en: '| `logdir` | `log.dir` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `logdir` | `log.dir` |'
- en: We looked at the precedence rules and now we know that there are multiple places
    where you can define variables. Irrespective of the precedence levels, all use
    the same syntax to define a variable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看了优先规则，现在我们知道有多个地方可以定义变量。不考虑优先级，所有使用相同的语法来定义变量。
- en: 'To define a simple variable in a key-value pair format, use, `var: value`,
    for example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '要以键值对格式定义一个简单的变量，使用`var: value`，例如：'
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A dictionary or hash can be defined as Nginx:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将字典或哈希定义为Nginx：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'An array could be defined as:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以定义为：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Templating the Nginx configurations
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板化Nginx配置
- en: 'You have learnt a lot about facts, variables, and templates. Now, lets transform
    our Nginx role to be data driven. We will start templating the `default.conf`
    file for Nginx that we created earlier. The approach toward converting a file
    into a template would be as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学到了很多关于事实、变量和模板的知识。现在，让我们将我们的Nginx角色转换为数据驱动。我们将开始为我们之前创建的Nginx的`default.conf`文件进行模板化。将文件转换为模板的方法如下：
- en: 'Create the directories required to hold templates and default variables inside
    a role:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建必要的目录来保存角色内的模板和默认变量：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Always start with the actual configuration file, our end result of this process,
    to know all of the parameters it would take. Then, work backwards. For example,
    the configuration for the `default.conf` file on our system is as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 始终从实际的配置文件开始，这是我们这个过程的最终结果，以了解它需要哪些参数。然后，向后工作。例如，我们系统上`default.conf`文件的配置如下：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Identify the configuration parameters that you would like to generate dynamically,
    remove the values for those parameters, note them down separately, and replace
    them with template variables:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定您想要动态生成的配置参数，删除这些参数的值，单独记录下来，并用模板变量替换它们：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If the values for any of the configuration parameters are supposed to be sourced
    from facts, typically system parameters or topology information, such as the hostname,
    IP address, and so on, then find out the relevant facts with the help of the following
    command:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任何配置参数的值应该来自事实，通常是系统参数或拓扑信息，比如主机名、IP地址等，那么可以使用以下命令来找出相关的事实：
- en: 'For example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To find out the hostname of the system:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找系统的主机名：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use the discovered fact inside the template instead of a user-defined variable.
    For example:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板中使用发现的事实，而不是用户定义的变量。例如：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Save the resulting file inside the template''s directory, ideally with the
    `.j2` extension. For example, for `roles/nginx/templates/default.conf.j2`, the
    resulting file becomes:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果文件保存在模板目录中，最好使用`.j2`扩展名。例如，对于`roles/nginx/templates/default.conf.j2`，结果文件变为：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create `roles/nginx/defaults/main.yml` and store the sane defaults as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`roles/nginx/defaults/main.yml`并存储相同的默认值如下：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once the template has been created, change the task in the `configure.yml` file
    to use the template instead of the copy module:![Templating the Nginx configurations](graphics/B03800_03_04.jpg)
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦模板被创建，就将`configure.yml`文件中的任务更改为使用模板而不是复制模块：![模板化Nginx配置](graphics/B03800_03_04.jpg)
- en: 'Finally, it''s time to remove the static file we used earlier with the copy
    module:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，是时候删除我们之前使用的静态文件了，使用复制模块：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then it''s time to run the Ansible playbook:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是运行Ansible playbook的时候了：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s take a look at the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下的屏幕截图：
- en: '![Templating the Nginx configurations](graphics/B03800_03_05.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![模板化Nginx配置](graphics/B03800_03_05.jpg)'
- en: 'Let''s analyze what happened during this run:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这次运行发生了什么：
- en: We changed the configuration task to use the template instead of the copy module,
    which is reflected in the screenshot when a task shows its changed status
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将配置任务更改为使用模板而不是复制模块，这在任务显示其更改状态的屏幕截图中反映出来
- en: Since the task has been updated, a notification gets triggered, which calls
    the handler to restart the service
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于任务已经更新，触发了一个通知，调用处理程序重新启动服务
- en: 'Our code tree for the Nginx role looks like the following after we make this
    change:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对Nginx角色的代码树在我们做出这些更改后看起来如下：
- en: '![Templating the Nginx configurations](graphics/B03800_03_06.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![模板化Nginx配置](graphics/B03800_03_06.jpg)'
- en: Adding another layer – the MySQL role
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加另一层 - MySQL角色
- en: So far, we have been focusing on the single tier of our infrastructure, that
    is, the web server layer. Writing code for just one tier is not a lot of fun.
    Being a cool DevOps team, we will create a multi-tier infrastructure with database,
    web server, and then, a load balancer. We will start creating the MySQL role next,
    apply everything that we have learnt so far, and extend that knowledge with a
    few new concepts.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在关注我们基础设施的单个层面，也就是Web服务器层。仅为一个层编写代码并不是很有趣。作为一个很酷的DevOps团队，我们将创建一个包括数据库、Web服务器和负载均衡器的多层基础设施。我们将开始创建MySQL角色，应用我们迄今为止学到的一切，并通过一些新概念扩展这些知识。
- en: 'Here is our specification for the MySQL role:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的MySQL角色规范：
- en: It should install the MySQL server package
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该安装MySQL服务器包
- en: It should configure '`my.cnf`', which is the main configuration for the MySQL
    server
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该配置'`my.cnf`'，这是MySQL服务器的主要配置
- en: It should start the MySQL server daemon
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该启动MySQL服务器守护程序
- en: It should support Ubuntu 12.04 as well as CentOS/RedHat Enterprise 6.x
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该支持Ubuntu 12.04以及CentOS/RedHat Enterprise 6.x
- en: Creating the scaffolding for the roles with Ansible-Galaxy
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ansible-Galaxy创建角色的脚手架
- en: So far, we have been doing all the hard work to understand and create the directory
    structure required by the roles. However, to make our lives easier, Ansible ships
    with a tool called **Ansible-Galaxy**, which should help us initialize a role
    by creating the scaffolding automatically and could help us follow the best practices.
    Ansible-Galaxy actually does more than that. It's a utility to connect to the
    repository of the freely available Ansible roles hosted at [http://galaxy.ansible.com](http://galaxy.ansible.com).
    This is similar to the way we use **CPAN** or **RubyGems**.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在努力理解和创建角色所需的目录结构。然而，为了让我们的生活更轻松，Ansible附带了一个名为**Ansible-Galaxy**的工具，它应该帮助我们通过自动创建脚手架来初始化角色，并帮助我们遵循最佳实践。实际上，Ansible-Galaxy做的不仅仅是这些。它是一个实用工具，用于连接到[http://galaxy.ansible.com](http://galaxy.ansible.com)上托管的免费可用的Ansible角色的存储库。这类似于我们使用**CPAN**或**RubyGems**的方式。
- en: 'Let''s start by initializing the MySQL role with Ansible-Galaxy using the following
    command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用以下命令用Ansible-Galaxy初始化MySQL角色开始：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, the following is the analysis of the preceding command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，以下是对前面命令的分析：
- en: '`init`: This is the subcommand given to Ansible-Galaxy to create the scaffolding'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`：这是给Ansible-Galaxy的子命令，用于创建脚手架'
- en: '`--init-path` or `-p`: These provide the path to the roles directory, under
    which the directory structure is created'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--init-path`或`-p`：这些提供了角色目录的路径，在该路径下创建目录结构'
- en: '`mysql`: This is the name of the role'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mysql`：这是角色的名称'
- en: 'Let''s take a look at the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下的屏幕截图：
- en: '![Creating the scaffolding for the roles with Ansible-Galaxy](graphics/B03800_03_07.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![使用Ansible-Galaxy创建角色的脚手架](graphics/B03800_03_07.jpg)'
- en: The preceding diagram shows the directory layout created after you initialize
    the role with Ansible-Galaxy, which creates an empty role with a structure suitable
    for upload on to Galaxy. It also initializes the necessary components, including
    tasks, handlers, vars, and meta files with placeholders.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Ansible-Galaxy初始化角色后创建的目录布局如前图所示，它创建了一个适合上传到Galaxy的空角色结构。它还初始化了必要的组件，包括任务、处理程序、变量和带有占位符的元数据文件。
- en: Adding metadata to the role
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向角色添加元数据
- en: 'We used the `meta` file earlier to specify the dependency on another role.
    In addition to specifying the dependencies, meta files can specify much more data
    for the roles, such as:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用`meta`文件来指定对另一个角色的依赖关系。除了指定依赖关系，元文件还可以为角色指定更多数据，例如：
- en: The author and company information
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者和公司信息
- en: The supported OS and platforms
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的操作系统和平台
- en: A brief description of what a role does
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色的简要描述
- en: The Ansible versions supported
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的Ansible版本
- en: The category of software that this role attempts to automate
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此角色试图自动化的软件类别
- en: The licensing information
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许可信息
- en: 'Let''s update all this data by editing `roles/meta/main.yml`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编辑`roles/meta/main.yml`来更新所有这些数据：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding snippet, we added metadata to the role, such as the author
    and company details, a brief description of what a role does, its compatibility
    with Ansible versions, the supported platforms, the category the role belongs
    to, and so on.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述片段中，我们为角色添加了元数据，例如作者和公司详细信息，角色的简要描述，与Ansible版本的兼容性，支持的平台，角色所属的类别等。
- en: Using variables in tasks and handlers
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在任务和处理程序中使用变量
- en: 'You have learnt how to use variables in templates. That''s not all the code
    there is used to define the variables. In addition to templates, we can also use
    variables inside tasks, plays, and so on. This time around, we have also committed
    to provide a multiplatform role, supporting Ubuntu and RedHat both. Unlike **Chef**
    and **Puppet**, Ansible uses OS-specific modules (for example, `apt` and `yum`)
    and not platform-independent resources (package). We will have to create OS-specific
    task files and call them selectively based on the OS they are going to run on.
    Here''s how we do so:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了如何在模板中使用变量。那不是定义变量所使用的所有代码。除了模板，我们还可以在任务、播放等中使用变量。这一次，我们还承诺提供一个支持Ubuntu和RedHat的多平台角色。与**Chef**和**Puppet**不同，Ansible使用特定于操作系统的模块（例如，`apt`和`yum`），而不是平台无关的资源（软件包）。我们将不得不创建特定于操作系统的任务文件，并根据它们将它们有选择地调用。我们是这样做的：
- en: 'We will find a fact that will determine the OS platform/family. We have a couple
    of options here:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将找到一个事实，确定操作系统平台/系列。我们在这里有几个选项：
- en: '`ansible_distribution`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_distribution`'
- en: '`ansible_os_family`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_os_family`'
- en: RedHat, CentOS, and Amazon Linux are all based on `rpm` and have similar behavior.
    The same goes for Ubuntu and Debian operating systems, which are part of the same
    platform family. Hence, we choose to use the `ansible_os_family` fact, which will
    give us wider support.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RedHat、CentOS和Amazon Linux都基于`rpm`，并具有类似的行为。Ubuntu和Debian操作系统也是同一平台系列的一部分。因此，我们选择使用`ansible_os_family`事实，这将为我们提供更广泛的支持。
- en: 'We will define variables from two places in the roles:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在角色中的两个位置定义变量：
- en: From the default `vars` file with the sane defaults for Debian.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从具有Debian合理默认值的默认`vars`文件中。
- en: From the variables specific to `os_family` if not Debian.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从特定于`os_family`的变量中，如果不是Debian。
- en: We will also create OS-specific task files, since we may need to call different
    modules (`apt` versus `yum`) and additional tasks that are specific to that OS.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将创建特定于操作系统的任务文件，因为我们可能需要调用不同的模块（`apt`与`yum`）和特定于该操作系统的附加任务。
- en: For handlers and tasks, we will use variables to provide OS-specific names (for
    example, MySQL versus mysqld, for service).
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于处理程序和任务，我们将使用变量来提供特定于操作系统的名称（例如，对于服务，MySQL与mysqld）。
- en: Finally, we will create the `main.yml` file, which will selectively include
    host-specific vars as well as task files by checking the value of this fact.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将创建`main.yml`文件，通过检查此事实的值，有选择地包含特定于主机的变量以及任务文件。
- en: Creating variables
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建变量
- en: 'We will begin with the creation of variables. Let''s set up the sane defaults
    for Debian/Ubuntu inside the `/mysql/defaults/main.yml` file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建变量开始。让我们在`/mysql/defaults/main.yml`文件中为Debian/Ubuntu设置合理的默认值：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then it will run on RedHat/CentOS machines, however, we will need to override
    a few of these variables to configure the RedHat-specific parameters.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它将在RedHat/CentOS机器上运行，但是我们需要覆盖其中一些变量以配置特定于RedHat的参数。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the filename should match the exact name (RedHat) that is returned
    by the `ansible_os_family` fact with the correct case.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，文件名应与`ansible_os_family`事实返回的确切名称（RedHat）完全匹配，并且大小写正确。
- en: 'We will create and edit the `roles/mysql/vars/RedHat.yml` file, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建并编辑`roles/mysql/vars/RedHat.yml`文件，如下所示：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we will create the `group_vars` fact with one variable to override
    our default settings. You have learnt that you can specify variables in the `inventory`
    files, the `group_vars` and the `host_vars` facts. We will start using the `group_vars`
    fact for now. You could either create these in your inventory file or create a
    separate directory for it with the name `group_vars`. We are going to take the
    second approach, which is recommended:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建`group_vars`事实，并添加一个变量来覆盖我们的默认设置。您已经学会了可以在`inventory`文件、`group_vars`和`host_vars`事实中指定变量。我们现在将开始使用`group_vars`事实。您可以在您的清单文件中创建这些变量，或者创建一个名为`group_vars`的单独目录。我们将采取第二种方法，这是推荐的：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Edit the `group_vars`/`all` file and add the following line:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`group_vars`/`all`文件并添加以下行：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Creating tasks
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建任务
- en: 'It''s now time to create tasks. Following the best practices, we will split
    tasks into multiple files and use include statements, just like we did for Nginx.
    Let''s start by creating the default `main.yml` file inside `roles/mysql/tasks`,
    as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是创建任务的时候了。遵循最佳实践，我们将任务分割成多个文件，并使用`include`语句，就像我们为Nginx所做的那样。让我们从在`roles/mysql/tasks`目录中创建默认的`main.yml`文件开始，如下所示：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We saw the `include` statements earlier. What''s new here is the `include_vars`
    fact and the use of the `ansible_os_family` fact. If you notice:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到了`include`语句。这里的新内容是`include_vars`事实和`ansible_os_family`事实的使用。如果你注意到：
- en: We are using the `ansible_os_family` fact here with the `include_vars` fact
    to determine whether to include OS-specific variables when the OS family is not
    Debian. Why not for the Debian system? That's because we are already specifying
    Debian-specific configurations in the `default` file. The `include_vars` fact
    works well with the preceding conditionals.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在这里使用`ansible_os_family`事实和`include_vars`事实来确定在操作系统家族不是Debian时是否包含特定于操作系统的变量。为什么不适用于Debian系统？因为我们已经在`default`文件中指定了特定于Debian的配置。`include_vars`事实与前面的条件很好地配合使用。
- en: We are also calling OS-specific installation scripts using the `when` condition.
    We have included two scripts for now to support the Debian and RedHat families.
    However, later on, we could just extend the scripts by adding more `install_<os_family>.yml`
    scripts to support additional platforms.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还使用`when`条件调用特定于操作系统的安装脚本。目前我们已经包含了两个脚本来支持Debian和RedHat系列。但是，以后我们可以通过添加更多的`install_<os_family>.yml`脚本来支持其他平台来扩展这些脚本。
- en: 'Now, let''s create the install tasks for Debian and RedHat:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为Debian和RedHat创建安装任务：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then edit the file, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照以下方式编辑文件：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After running the preceding command, edit the file as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令后，按照以下方式编辑文件：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding example, we used the `apt` and `yum` modules, respectively,
    for Debian- and RedHat-based systems. Following the best practices, we will write
    a data-driven role by providing the package name using a variable `mysql_pkg`.
    This variable is set based on the platform it runs on. Let''s take a look at the
    following steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们分别为基于Debian和基于RedHat的系统使用了`apt`和`yum`模块。遵循最佳实践，我们将通过使用变量`mysql_pkg`来提供包名称来编写一个数据驱动的角色。该变量是根据其运行的平台设置的。让我们看一下以下步骤：
- en: 'The next step is to create a task to configure MySQL. Since we know that every
    configuration file should be a template, we will create one for the `my.cnf` file,
    the default configuration file for the MySQL server:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一个任务来配置MySQL。由于我们知道每个配置文件都应该是一个模板，我们将为`my.cnf`文件创建一个默认配置文件，MySQL服务器的默认配置文件：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then edit the file, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照以下方式编辑文件：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We created a template with the `.j2` extension since it's a Jinja2 template.
    It's not a must, but a recommended practice.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个带有`.j2`扩展名的模板，因为它是一个Jinja2模板。这不是必须的，但是推荐的做法。
- en: All configuration parameters come from variables in the `{{var}}` format. This
    is a recommended practice for managing a configuration file. We could let the
    attribute precedence decide where the values comes from.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有配置参数都来自`{{var}}`格式的变量。这是管理配置文件的推荐做法。我们可以让属性优先级决定值来自哪里。
- en: Tip
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's good practice to add a notice to every file being managed by Ansible. This
    will avoid possible manual updates or ad hoc changes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个由Ansible管理的文件中添加通知是一个好习惯。这将避免可能的手动更新或临时更改。
- en: 'We will write a task that will manage this template, and copy over the resulting
    file to the desired path on the host:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个任务来管理这个模板，并将生成的文件复制到主机上的所需路径：
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We have a common configuration file template; however, the path to copy this
    varies from platform to platform, also based on the flavor of MySQL that you plan
    to use. Here, we are using a MySQL distribution that comes with the Ubuntu and
    CentOS repositories by default, and we will set the `mysql_cnfpath` path from
    the role variables, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个通用的配置文件模板；然而，复制这个文件的路径因平台而异，也取决于您计划使用的MySQL版本。在这里，我们使用的是默认情况下带有Ubuntu和CentOS存储库的MySQL发行版，并且我们将从角色变量中设置`mysql_cnfpath`路径，如下所示：
- en: 'On Ubuntu/Debian, use the command: `mysql_cnfpath = /etc/mysql/my.cnf`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Ubuntu/Debian上，使用命令：`mysql_cnfpath = /etc/mysql/my.cnf`
- en: 'On RedHat/CentOS, use the command: `mysql_cnfpath = /etc/my.cnf`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在RedHat/CentOS上，使用命令：`mysql_cnfpath = /etc/my.cnf`
- en: Also, we are sending the notification to the MySQL service restart handler.
    This will make sure that if there are any changes to the configuration file, the
    service will automatically be restarted.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们正在发送通知给MySQL服务重启处理程序。这将确保如果配置文件有任何更改，服务将自动重新启动。
- en: 'To manage a service, we will create a service task and handler:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理一个服务，我们将创建一个服务任务和处理程序：
- en: 'The task:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 任务：
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then edit the file, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照以下方式编辑文件：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The handler:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After running the preceding commands, edit the file as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令后，按照以下方式编辑文件：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, the task and handler are similar to the Nginx service, so nothing much
    needs to be described. The only change is that we are using the `mysql_service`
    variable to decide the service name to start, or restart, the service.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，任务和处理程序与Nginx服务类似，因此不需要进行太多描述。唯一的变化是我们使用`mysql_service`变量来决定要启动或重新启动服务的服务名称。
- en: Using variables in playbooks
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在playbooks中使用变量
- en: Variables can also be specified in playbooks. The preferred method of doing
    so would be to pass them as role parameters, an example of which is shown as follows.
    This is typically useful when you have defaults in the role and you'd like to
    override some configuration parameters specific to your setup. That way, roles
    are still generic and sharable, and do not contain organization-specific data.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 变量也可以在playbooks中指定。这样做的首选方法是将它们作为角色参数传递，下面显示了一个示例。当角色中有默认值并且您想要覆盖一些特定于您的设置的配置参数时，这通常很有用。这样，角色仍然是通用的和可共享的，并且不包含组织特定的数据。
- en: 'We are going to create a playbook to manage our databases and then we will
    include it in the site-wide playbook, as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个playbook来管理我们的数据库，然后将其包含在全局playbook中，如下所示：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then edit the file, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后编辑文件，如下所示：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we assume that the host''s inventory contains a host group by the name
    `db`. In our example, we have two `db` servers, one running on Ubuntu, the other
    running on CentOS. This is added as:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设主机清单包含一个名为`db`的主机组。在我们的例子中，我们有两个`db`服务器，一个在Ubuntu上运行，另一个在CentOS上运行。这被添加为：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding playbook, we used a parameterized role, which overrides one
    variable, that is, `mysql_bind`. The value is set from a multilevel fact.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的playbook中，我们使用了一个参数化角色，它覆盖了一个变量，即`mysql_bind`。该值是从多级事实中设置的。
- en: 'Let''s take a look at the following screenshot:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下的截图：
- en: '![Using variables in playbooks](graphics/B03800_03_08.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: 使用变量在playbooks中
- en: A multilevel fact can also be specified as `ansible_eth1["ipv4"]["address"]`
    and both the formats are valid. Parameterized roles are also useful when we want
    to create multiple instances of the role, for example, virtual hosts and WordPress
    instances running on different ports.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 多级事实也可以指定为`ansible_eth1["ipv4"]["address"]`，这两种格式都是有效的。当我们想要创建角色的多个实例时，例如在不同端口上运行的虚拟主机和WordPress实例时，参数化角色也很有用。
- en: 'Let''s now include this playbook in the top-level `site.yml` file using the
    `include` statement:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在顶层的`site.yml`文件中使用`include`语句来包含这个playbook：
- en: 'Edit the `site.yml` file as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`site.yml`文件如下：
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Applying a MySQL role to the DB servers
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将MySQL角色应用于DB服务器
- en: 'We are all set to configure our database servers. Let''s go ahead and apply
    the newly created role to all the `db` servers we have in the inventory:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好配置我们的数据库服务器。让我们继续将新创建的角色应用到我们清单中所有的`db`服务器上：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following image contains the snippet of the output which is only relevant
    to the database play:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像包含了仅与数据库操作相关的输出片段：
- en: '![Applying a MySQL role to the DB servers](graphics/B03800_03_09.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: 将MySQL角色应用于DB服务器
- en: We have explained the Ansible run in the previous chapters, when we created
    our first playbook as well as when we applied the Nginx role. The only new concept
    here is the `include_var` part. Ansible will check our condition based on the
    `ansible_os_family` fact and call variables specific to the OS. In our case, we
    have one Ubuntu and CentOS host each, and both of them call for the `RedHat.yml`
    file when it runs on the CentOS host alone.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中已经解释了Ansible运行，当我们创建我们的第一个playbook以及应用Nginx角色时。这里唯一的新概念是`include_var`部分。Ansible将根据`ansible_os_family`事实检查我们的条件，并调用特定于操作系统的变量。在我们的例子中，我们每个有一个Ubuntu和CentOS主机，并且当它仅在CentOS主机上运行时，它们都调用`RedHat.yml`文件。
- en: What will be really interesting here is to find out what happened to our configuration
    files on each platform and which variables took precedence.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里真正有趣的是找出我们的配置文件在每个平台上发生了什么，以及哪些变量优先。
- en: Variable precedence
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量优先级
- en: We specified variable defaults, used them in inventory files, and defined the
    same variable from different places (for example, defaults, vars, and inventory).
    Let's now analyze the output of the templates to understand what happened with
    all those variables.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了变量默认值，在清单文件中使用它们，并从不同位置（例如默认值，vars和清单）定义了相同的变量。现在让我们分析模板的输出，以了解所有这些变量发生了什么。
- en: 'The following is the figure showing the `my.cnf` file on Ubuntu:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是显示Ubuntu上`my.cnf`文件的图：
- en: '![Variable precedence](graphics/B03800_03_11.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![变量优先级](graphics/B03800_03_11.jpg)'
- en: 'The following is the analysis of the screenshot:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对截图的分析：
- en: The file has a notice in the comments section. This can deter admins from making
    manual changes to the file.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件在注释部分有一个通知。这可以阻止管理员对文件进行手动更改。
- en: Most of the variables come from the defaults in a role. This is because Debian
    is our default family of operating systems and we already have sane defaults set
    for it. Similarly, for other operating system platforms, we are setting variable
    defaults from the `vars` directory in a role.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数变量来自角色中的默认值。这是因为Debian是我们默认的操作系统系列，我们已经为其设置了合理的默认值。同样，对于其他操作系统平台，我们正在从角色的`vars`目录设置变量默认值。
- en: Even though the `bind_address` parameter is specified in the defaults and `group_vars`,
    it takes a value from the playbook's role parameter, which has a higher precedence
    over the other two levels.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管`bind_address`参数在默认值和`group_vars`中指定，但它从playbook的角色参数中获取值，这比其他两个级别具有更高的优先级。
- en: 'The following diagram explains what happens when there are variables defined
    at various levels. All of them are merged at runtime. If the same variables are
    defined in more than one place, the precedence rules apply:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 下图解释了在不同级别定义变量时会发生什么。所有这些变量在运行时都会合并。如果相同的变量在多个地方定义，那么优先规则就会应用：
- en: '![Variable precedence](graphics/B03800_03_10.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![变量优先级](graphics/B03800_03_10.jpg)'
- en: 'To understand the precedence rules, let''s look at what happened on our CentOS
    host. The following is the `my.cnf` file created on CentOS:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解优先规则，让我们看看在我们的CentOS主机上发生了什么。以下是在CentOS上创建的`my.cnf`文件：
- en: '![Variable precedence](graphics/B03800_03_12.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![变量优先级](graphics/B03800_03_12.jpg)'
- en: 'As seen in the preceding figure, in the case of CentOS, we see some interesting
    results:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，在CentOS的情况下，我们看到了一些有趣的结果：
- en: The values for **user**, **pid**, **datadir**, and **port** come from the defaults.
    We have looked at the merge order. If the variables are not identical, they are
    merged to create the final configuration.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**user**，**pid**，**datadir**和**port**的值来自默认值。我们已经查看了合并顺序。如果变量不相同，它们将合并以创建最终配置。'
- en: The value for a socket comes from vars as that's the only place it has been
    defined. Nevertheless, we want this socket to be constant for the RedHat-based
    system, hence, we specified it in the vars directory of the role.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字的值来自vars，因为那是唯一定义它的地方。尽管如此，我们希望这个套接字对于基于RedHat的系统是恒定的，因此我们在角色的vars目录中指定了它。
- en: 'The `bind_address` parameter comes from the vars directory again. This is interesting
    as we have the `mysql_bind` variable defined at the following locations:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bind_address`参数再次来自vars目录。这很有趣，因为我们在以下位置定义了`mysql_bind`变量：'
- en: '`Default` in a role'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色中的`默认`值
- en: '`group_vars`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group_vars`'
- en: '`playbook`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playbook`'
- en: '`vars` in a role'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vars`在一个角色中'
- en: 'The following figure depicts the precedence rules when we define the same variable
    more than once:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了当我们多次定义相同变量时的优先规则：
- en: '![Variable precedence](graphics/B03800_03_03.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![变量优先级](graphics/B03800_03_03.jpg)'
- en: Since our role defines the `bind_address` parameter in the `vars` directory,
    it takes precedence over the rest.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的角色在`vars`目录中定义了`bind_address`参数，它优先于其他参数。
- en: There is a way to override a role parameter using extra variables or the `-e`
    switch while running Ansible. This is the supreme level of precedence for a variable
    that Ansible manages.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以在运行Ansible时使用额外变量或`-e`开关来覆盖角色参数。这是Ansible管理的变量的最高优先级。
- en: 'For example:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE38]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding launch command, we used the `-e` switch, which will override
    all the other variable levels and make sure that the MySQL server is bound to
    `127.0.0.1`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的启动命令中，我们使用了`-e`开关，它将覆盖所有其他变量级别，并确保MySQL服务器绑定到`127.0.0.1`。
- en: The best practices for variable usage
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量使用的最佳实践
- en: 'Overwhelming, eh? Do not worry. We will give you the recommendations on the
    best practices while using variables:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 压倒性了吧？别担心。我们将为您提供在使用变量时的最佳实践建议：
- en: Start with defaults in a role. This has the lowest precedence of all. This is
    also a good place to provide the sane defaults of your application, which can
    be later overridden from various places.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从角色中的默认值开始。这是所有优先级中最低的。这也是提供应用程序的合理默认值的好地方，稍后可以从各种地方覆盖。
- en: Group variables are very useful. A lot of the time we will do region-specific
    or environment-specific configurations. We would also apply certain roles to a
    certain group of servers, for example, for all web servers in Asia, we apply the
    Nginx role. There is also a default group by the name "`all`", which will contain
    all the hosts for all groups. It's a good practice to put the variables common
    for all groups in "`all`" (`group_vars/all`), which can then be overridden by
    more specific groups.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组变量非常有用。很多时候，我们会进行特定于区域或特定于环境的配置。我们还会将某些角色应用于某些服务器组，例如，对于亚洲的所有web服务器，我们应用Nginx角色。还有一个名为"`all`"的默认组，其中包含所有组的所有主机。将所有组通用的变量放在"`all`"(`group_vars/all`)中是一个很好的做法，然后可以被更具体的组覆盖。
- en: If there are host-specific exceptions, use `hosts_vars`, for example, `host_vars/specialhost.example.org`.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有特定于主机的异常情况，请使用`hosts_vars`，例如，`host_vars/specialhost.example.org`。
- en: 'If you would like to separate variables in different files, create directories
    named after the hosts and put the variable files inside it. All files inside those
    directories will be evaluated:'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想要在不同文件中分离变量，请创建以主机命名的目录，并将变量文件放在其中。这些目录中的所有文件都将被评估：
- en: '`group_vars/asia/web`'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group_vars/asia/web`'
- en: '`host_vars/specialhost/nginx`'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host_vars/specialhost/nginx`'
- en: '`host_vars/specialhost/mysql`'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host_vars/specialhost/mysql`'
- en: If you would like to keep your roles generic and sharable, use defaults in the
    roles and then specify organization-specific variables from playbooks. These can
    be specified as role parameters.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您希望保持角色的通用性和可共享性，请在角色中使用默认值，然后从playbooks中指定组织特定的变量。这些可以被指定为角色参数。
- en: If you would like role variables to always take precedence over inventory variables
    and playbooks, specify them in the `vars` directory inside a role. This is useful
    for providing role constants for specific platforms.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您希望角色变量始终优先于清单变量和playbooks，请在角色内的`vars`目录中指定它们。这对于为特定平台提供角色常量非常有用。
- en: Finally, if you would like to override any of the preceding variables and provide
    some data during runtime, provide an extra variable with Ansible commands using
    the `-e` option.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果您想要覆盖前面的任何变量并在运行时提供一些数据，请使用Ansible命令使用`-e`选项提供额外的变量。
- en: 'By now, our tree for the MySQL role and DB playbook should look like the following
    figure:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的MySQL角色和DB playbook的树应该如下图所示：
- en: '![The best practices for variable usage](graphics/B03800_03_13.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![变量使用的最佳实践](graphics/B03800_03_13.jpg)'
- en: Review questions
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查问题
- en: 'Do you think you''ve understood the chapter well enough? Try answering the
    following questions to test your understanding:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您认为自己已经足够理解本章了吗？尝试回答以下问题来测试您的理解：
- en: How are Jinja2 templates different from static files?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jinja2模板与静态文件有什么不同？
- en: What are facts? How are they discovered?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事实是什么？它们是如何被发现的？
- en: What is the difference between `{{ }}` and `{% %}` in the context of Jinja2
    templates?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Jinja2模板的上下文中，`{{ }}`和`{% %}`有什么区别？
- en: Can you use a variable anywhere apart from templates? If yes, where?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了模板之外，你可以在任何地方使用变量吗？如果可以，在哪里？
- en: If you define a variable `foo` in the `vars` directory in a role and the same
    variable in the `hosts_var` file, which of these will take precedence?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在角色的`vars`目录中定义了一个变量`foo`，并且在`hosts_var`文件中也定义了相同的变量，这两者中哪个会优先？
- en: How do you write Ansible roles that are supported on multiple platforms?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何编写适用于多个平台的Ansible角色？
- en: Where can you specify the author and licensing information in a role?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在角色中你可以在哪里指定作者和许可信息？
- en: How do you provide variables while launching an Ansible-playbook command?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动Ansible-playbook命令时如何提供变量？
- en: Which command would you use to create a directory structure required by the
    roles automatically?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪个命令来自动创建角色所需的目录结构？
- en: How do you override a variable specified in the `vars` directory of a role?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何覆盖角色的`vars`目录中指定的变量？
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter by learning about why and how to separate data from
    code using Ansible variables, facts, and Jinja2 templates. You learnt how to create
    data-driven roles by providing variables and facts in templates, tasks, handlers,
    and playbooks. Additionally, we created a new role for the database tier, which
    supports both the Debian and RedHat families of operating systems. You learnt
    what system facts are and how they are discovered and used. You learnt how variables
    can be specified from more than one place, how they are merged, and the precedence
    rules. Finally, you learnt about the best practices for using variables.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过学习使用Ansible变量、事实和Jinja2模板将数据与代码分离的原因和方法开始了本章。您学会了如何通过在模板、任务、处理程序和playbooks中提供变量和事实来创建数据驱动的角色。此外，我们为数据库层创建了一个新角色，支持Debian和RedHat操作系统家族。您学会了系统事实是什么，以及它们是如何被发现和使用的。您学会了变量可以从多个地方指定，它们是如何合并的，以及优先规则。最后，您学会了使用变量的最佳实践。
- en: In the next chapter, we will work with custom commands and scripts, understand
    what registered variables are, and deploy a sample WordPress application using
    all this information.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用自定义命令和脚本，了解注册变量是什么，并使用所有这些信息部署一个示例WordPress应用程序。

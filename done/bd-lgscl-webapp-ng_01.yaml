- en: Building Our First App - 7 Minute Workout
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的第一个应用程序 - 7分钟锻炼
- en: We will be building a new app in Angular, and in the process, become more familiar
    with the framework. This app will also help us explore some new capabilities of
    Angular.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Angular中构建一个新的应用程序，并在此过程中更加熟悉这个框架。这个应用程序还将帮助我们探索Angular的一些新功能。
- en: 'The topics that we will cover in this chapter include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖的主题包括以下内容：
- en: '**7 Minute Workout problem description**: We detail the functionality of the
    app that we build in this chapter.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**7分钟锻炼问题描述**：我们详细介绍了本章中构建的应用程序的功能。'
- en: '**Code organization**: For our first real app, we will try to explain how to
    organize code, specifically Angular code.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码组织**：对于我们的第一个真正的应用程序，我们将尝试解释如何组织代码，特别是Angular代码。'
- en: '**Designing the model**: One of the building blocks of our app is its model.
    We design the app model based on the app''s requirements.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计模型**：我们应用程序的构建块之一是其模型。我们根据应用程序的要求设计应用程序模型。'
- en: '**Understanding the data binding infrastructure**: While building the *7 Minute
    Workout* view, we will look at the data binding capabilities of the framework,
    which include *property*, *attribute*, *class*, *style*, and *event* bindings.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解数据绑定基础设施**：在构建*7分钟锻炼*视图时，我们将研究框架的数据绑定能力，其中包括*属性*、*属性*、*类*、*样式*和*事件*绑定。'
- en: '**Exploring the Angular platform directives**: Some of the directives that
    we will cover are `ngFor`, `ngIf`, `ngClass`, `ngStyle`, and `ngSwitch`.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**探索Angular平台指令**：我们将涵盖的一些指令包括`ngFor`、`ngIf`、`ngClass`、`ngStyle`和`ngSwitch`。'
- en: '**Cross-component communication with input properties**: As we build nested
    components, we learn how input properties can be used to pass data from the parent
    to its child components.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用输入属性进行跨组件通信**：当我们构建嵌套组件时，我们将学习如何使用输入属性将数据从父组件传递给子组件。'
- en: '**Cross-component communication with events**: Angular components can subscribe
    to and raise events. We get introduced to event binding support in Angular.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用事件进行跨组件通信**：Angular组件可以订阅和触发事件。我们将介绍Angular中的事件绑定支持。'
- en: '**Angular pipes**: Angular pipes provide a mechanism to format view content.
    We explore some standard Angular pipes and build our own pipe to support conversions
    from seconds to hh:mm:ss.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular管道**：Angular管道提供了一种格式化视图内容的机制。我们探讨了一些标准的Angular管道，并构建了我们自己的管道，以支持从秒转换为hh:mm:ss。'
- en: Let's get started! The first thing we will do is to define our *7 Minute Workout*
    app.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！我们要做的第一件事是定义我们的*7分钟锻炼*应用程序。
- en: What is 7 Minute Workout?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是7分钟锻炼？
- en: We want everyone reading this book to be physically fit. Therefore, this book
    should serve a dual purpose; it should not only stimulate your grey matter but
    also urge you to look after your physical fitness. What better way to do it than
    to build an app that targets physical fitness!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望每个阅读本书的人都能保持身体健康。因此，这本书应该具有双重目的；它不仅应该激发你的大脑，还应该督促你关注自己的身体健康。有什么比构建一个针对身体健康的应用程序更好的方式呢！
- en: '*7 Minute Workout* is an exercise/workout app that requires us to perform a
    set of 12 exercises in quick succession within the seven-minute time span. *7
    Minute Workout* has become quite popular due to its bite-sized length and great
    benefits. We cannot confirm or refute the claims, but doing any form of strenuous
    physical activity is better than doing nothing at all. If you are interested to
    know more about the workout, then check out [http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/](http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*7分钟锻炼*是一款需要我们在七分钟的时间范围内快速连续进行一组12个练习的锻炼/健身应用程序。由于其简短的长度和巨大的好处，*7分钟锻炼*已经变得非常受欢迎。我们无法确认或否认这些说法，但进行任何形式的剧烈体育活动总比什么都不做要好。如果您对这种锻炼感兴趣，请查看[http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/](http://well.blogs.nytimes.com/2013/05/09/the-scientific-7-minute-workout/)。'
- en: The technicalities of the app include performing a set of 12 exercises, dedicating
    30 seconds for each of the exercises. This is followed by a brief rest period
    before starting the next exercise. For the app that we are building, we will be
    taking rest periods of 10 seconds each. So, the total duration comes out at a
    little more than seven minutes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序的技术细节包括进行一组12个练习，每个练习花费30秒。然后在开始下一个练习之前有一个简短的休息时间。对于我们正在构建的应用程序，我们将每次休息10秒。因此，总持续时间略长于七分钟。
- en: 'At the end of the chapter, we will have the *7 Minute Workout* app ready, which
    will look something like the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将准备好*7分钟锻炼*应用程序，它将看起来像以下内容：
- en: '![](Images/8378988e-4540-482e-ac33-e91d1e49b659.png)The 7 Minute Workout app'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](Images/8378988e-4540-482e-ac33-e91d1e49b659.png)7分钟锻炼应用程序
- en: Downloading the code base
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载代码库
- en: The code for this app can be downloaded from the GitHub site ([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample))
    dedicated to this book. Since we are building the app incrementally, we have created
    **multiple checkpoints** that map to **GitHub branches** such as `checkpoint2.1`,
    `checkpoint2.2`, and so on. During the narration, we will highlight the branch
    for reference. These branches will contain the work done on the app up until that
    point in time.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序的代码可以从GitHub网站（[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)）下载，该网站专门为本书而设。由于我们正在逐步构建应用程序，我们已经创建了**多个检查点**，这些检查点映射到**GitHub分支**，例如`checkpoint2.1`，`checkpoint2.2`等。在叙述过程中，我们将突出显示用于参考的分支。这些分支将包含截至该时间点的应用程序工作。
- en: The *7 Minute Workout* code is available in the repository folder named `trainer`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*7分钟锻炼*代码可在名为`trainer`的存储库文件夹中找到。'
- en: So, let's get started!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Setting up the build
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置构建
- en: Remember that we are building on a modern platform for which browsers still
    lack support. Therefore, directly referencing script files in HTML is out of the
    question (while common, it's a dated approach that we should avoid anyway). Browsers
    do not understand **TypeScript**; this implies that there has to be a process
    that converts code written in TypeScript into standard **JavaScript (ES5)**. Hence,
    having a build set up for any Angular app becomes imperative. And thanks to the
    growing popularity of Angular, we are never short of options.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们正在构建一个现代平台，而浏览器仍然缺乏支持。因此，在HTML中直接引用脚本文件是不可能的（虽然常见，但这是一种过时的方法，我们无论如何都应该避免）。浏览器不理解**TypeScript**；这意味着必须有一个过程将TypeScript中的代码转换为标准的**JavaScript（ES5）**。因此，为任何Angular应用程序设置构建变得至关重要。由于Angular越来越受欢迎，我们从来不缺选项。
- en: If you are a frontend developer working on the web stack, you cannot avoid **Node.js**.
    This is the most widely used platform for web/JavaScript development. So, no prizes
    for guessing that most of the Angular build solutions out there are supported
    by Node. Packages such as **Grunt**, **Gulp**, **JSPM**, and **webpack** are the
    most common building blocks for any build system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是在Web堆栈上工作的前端开发人员，那么您无法避免使用**Node.js**。这是用于Web/JavaScript开发的最广泛使用的平台。因此，毫无疑问，大多数Angular构建解决方案都受到Node的支持。像**Grunt**、**Gulp**、**JSPM**和**webpack**这样的包是任何构建系统的最常见的构建模块。
- en: Since we too are building on the Node.js platform, install Node.js before starting.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们也是在Node.js平台上构建，所以在开始之前请安装Node.js。
- en: For this book and this sample app, we endorse **Angular CLI** ([http://bit.ly/ng6be-angular-cli](http://bit.ly/ng6be-angular-cli)).
    A command line tool, it has a build system and a scaffolding tool that hugely
    simplifies Angular's development workflow. It is popular, easy to set up, easy
    to manage, and supports almost everything that a modern build system should have.
    More about it later.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书和本示例应用程序，我们推荐使用**Angular CLI** ([http://bit.ly/ng6be-angular-cli](http://bit.ly/ng6be-angular-cli))。这是一个命令行工具，它具有一个构建系统和一个脚手架工具，极大地简化了Angular的开发工作流程。它受欢迎，易于设置，易于管理，并支持几乎所有现代构建系统应该具有的功能。稍后会详细介绍。
- en: 'As with any mature framework, Angular CLI is not the only option out there
    on the web. Some of the notable starter sites plus build setups created by the
    community are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何成熟的框架一样，Angular CLI并不是网络上唯一的选择。社区创建的一些著名的入门网站和构建设置如下：
- en: '| **Start site** | **Location** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **开始网站** | **位置** |'
- en: '| `angular2-webpack-starter` | [http://bit.ly/ng2webpack](http://bit.ly/ng2webpack)
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `angular2-webpack-starter` | [http://bit.ly/ng2webpack](http://bit.ly/ng2webpack)
    |'
- en: '| `angular-seed` | [https://github.com/mgechev/angular-seed](https://github.com/mgechev/angular-seed)
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `angular-seed` | [https://github.com/mgechev/angular-seed](https://github.com/mgechev/angular-seed)
    |'
- en: 'Let''s start with installing Angular CLI. On the command line, type the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装Angular CLI开始。在命令行上，输入以下内容：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once installed, Angular CLI adds a new command `ng` to our execution environment.
    To create a new Angular project from the command line, run the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，Angular CLI会向我们的执行环境添加一个新的命令`ng`。要从命令行创建一个新的Angular项目，请运行以下命令：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This generates a folder structure with a bunch of files, a boilerplate Angular
    application, and a preconfigured build system. To run the application from the
    command line, execute the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个带有一堆文件、一个样板Angular应用程序和一个预配置的构建系统的文件夹结构。要从命令行运行应用程序，请执行以下操作：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: And you can see a basic Angular application in action!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您就可以看到一个基本的Angular应用程序在运行了！
- en: 'For our *7 Minute Workout* app, instead of starting from scratch, we are going
    to start from a version that is based on the project structure generated by `ng
    new` with minor modification. Start with the following steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的*7分钟锻炼*应用程序，我们不是从头开始，而是从基于`ng new`生成的项目结构的一个版本开始，稍作修改。按照以下步骤开始：
- en: Curious about what the default project includes? Go ahead and run `ng new PROJECT-NAME`.
    Look at the generated content structure and the Angular CLI documentation to get
    an idea of what's part of a default setup.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 想知道默认项目包括什么？继续运行`ng new PROJECT-NAME`。查看生成的内容结构和Angular CLI文档，了解默认设置的内容。
- en: 'Download the base version of this app from [http://bit.ly/ngbe-base](http://bit.ly/ngbe-base)
    and unzip it to a location on your machine. If you are familiar with how Git works,
    you can just clone the repository and check out the`base` branch:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://bit.ly/ngbe-base](http://bit.ly/ngbe-base)下载此应用的基本版本，并将其解压缩到计算机上的某个位置。如果您熟悉Git的工作原理，可以克隆存储库并检出`base`分支：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code serves as the starting point for our app.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码作为我们应用程序的起点。
- en: Navigate to the `trainer` folder from the command line and execute the command
    `npm install` from the command line to install the **package dependencies** for
    our application.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行导航到`trainer`文件夹，并执行命令`npm install`来安装我们应用程序的**包依赖项**。
- en: '**Packages** in the Node.js world are third-party libraries (such as Angular
    for our app) that are either used by the app or support the app''s building process.
    **npm** is a command-line tool for pulling these packages from a remote repository.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js世界中，**包**是第三方库（例如我们应用程序中的Angular）或支持应用程序构建过程的库。**npm**是一个命令行工具，用于从远程存储库中拉取这些包。
- en: 'Once npm pulls the app dependencies from the npm store, we are ready to build
    and run the application. From the command line, enter the following command:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦npm从npm存储库中拉取了应用程序的依赖项，我们就可以开始构建和运行应用程序。从命令行输入以下命令：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This compiles and runs the app. If the build process goes fine, the default
    browser window/tab will open with a rudimentary app page (`http://localhost:4200/`).
    We are all set to begin developing our app in Angular!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译和运行应用程序。如果构建过程顺利进行，将会在默认浏览器窗口/标签中打开一个基本的应用程序页面（`http://localhost:4200/`）。我们已经准备好开始在Angular中开发我们的应用程序了！
- en: But before we do that, it would be interesting to know a bit more about Angular
    CLI and the customization that we have done on the default project template that
    Angular CLI generates.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这之前，了解一下Angular CLI以及我们对Angular CLI生成的默认项目模板进行的自定义会很有趣。
- en: Angular CLI
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular CLI
- en: '**Angular CLI** was created with the aim of standardizing and simplifying the development
    and deployment workflow for Angular apps. As the documentation suggests:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**Angular CLI**的创建目的是为了标准化和简化Angular应用程序的开发和部署工作流程。正如文档所建议的：'
- en: '"The Angular CLI makes it easy to create an application that already works,
    right out of the box. It already follows our best practices!"'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: “Angular CLI使创建一个应用程序变得非常容易，开箱即用。它已经遵循了我们的最佳实践！”
- en: 'It incorporates:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括：
- en: A build system based on **webpack**
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于**webpack**的构建系统
- en: A **scaffolding tool** to generate all standard Angular artifacts including
    modules, directives, components, and pipes
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于生成所有标准Angular构件的**脚手架工具**，包括模块、指令、组件和管道
- en: Adherence to **Angular style guide** ([http://bit.ly/ngbe-styleguide](http://bit.ly/ngbe-styleguide)),
    making sure we use community-driven standards for projects of every shape and
    size
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循**Angular风格指南**（[http://bit.ly/ngbe-styleguide](http://bit.ly/ngbe-styleguide)），确保我们为各种形状和大小的项目使用社区驱动的标准。
- en: You may have never heard the term style guide, or may not understand its significance.
    A style guide in any technology is a set of guidelines that help us organize and
    write code that is easy to develop, maintain, and extend. To understand and appreciate
    Angular's own style guide, some familiarity with the framework itself is desirable,
    and we have started that journey.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能从未听说过风格指南这个术语，或者不理解它的重要性。在任何技术中，风格指南都是一组指导方针，帮助我们组织和编写易于开发、维护和扩展的代码。要理解和欣赏Angular自己的风格指南，对框架本身有一定的了解是有帮助的，我们已经开始了这个旅程。
- en: A targeted **linter;** Angular CLI integrates with **codelyzer** ([http://bit.ly/ngbe-codelyzer](http://bit.ly/ngbe-codelyzer)),
    a **static code analysis tool** that validates our Angular code against a set
    of rules to make sure that the code we write adheres to standards laid down in
    the Angular style guide
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有针对性的**检查器**；Angular CLI与**codelyzer**（[http://bit.ly/ngbe-codelyzer](http://bit.ly/ngbe-codelyzer)）集成，这是一个**静态代码分析工具**，用于验证我们的Angular代码是否符合一组规则，以确保我们编写的代码符合Angular风格指南中制定的标准
- en: Preconfigured **unit** and **end-to-end** (**e2e**) test framework
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预配置的**单元测试**和**端到端**（**e2e**）测试框架
- en: And much more!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以及更多！
- en: Imagine if we had to do all this manually! The steep learning curve would quickly
    overwhelm us. Thankfully, we don't have to deal with it, Angular CLI does it for
    us.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下如果我们不得不手动完成所有这些工作！陡峭的学习曲线会很快让我们不知所措。幸运的是，我们不必处理这些，Angular CLI会为我们完成。
- en: The Angular CLI build setup is based on webpack, but it does not expose the
    underlying webpack configuration; this is intentional. The Angular team wanted
    to shield developers from the complexities and internal workings of webpack. The
    ultimate aim of Angular CLI is to eliminate any entry level barriers and make
    setting up and running Angular code simple.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI的构建设置基于webpack，但它不会暴露底层的webpack配置；这是有意为之的。Angular团队希望屏蔽开发人员对webpack的复杂性和内部工作的理解。Angular
    CLI的最终目标是消除任何入门障碍，并使设置和运行Angular代码变得简单。
- en: It doesn't mean Angular CLI is not configurable. There is a *config file* (`angular.json`)
    that we can use to alter the build setup. We will not cover that here. Check the
    configuration file for 7 Minute Workout and read the documentation here: [http://bit.ly/ng6be-angular-cli-config](http://bit.ly/ng6be-angular-cli-config).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI并不是不可配置的。有一个*配置文件*（`angular.json`）可以用来改变构建设置。我们在这里不会涉及到这个。查看7分钟锻炼的配置文件，并阅读这里的文档：[http://bit.ly/ng6be-angular-cli-config](http://bit.ly/ng6be-angular-cli-config)。
- en: 'The tweaks that we have done to the default generated project template are:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对默认生成的项目模板所做的调整是：
- en: Referenced Bootstrap CSS in the `style.css` file.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`style.css`文件中引用了Bootstrap CSS。
- en: Upgraded some npm library versions.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级了一些npm库的版本。
- en: Changed the prefix configuration for generated code to use `abe` (short for
    Angular By Example) from `app`. With this change, all our components and directive
    selectors will be prefixed by `abe` instead of `app`. Check `app.component.ts`;
    the `selector` is `abe-root` instead of `app-root`.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改了生成代码的前缀配置，使用`abe`（代表Angular By Example）而不是`app`。通过这个改变，我们所有的组件和指令选择器都将以`abe`作为前缀，而不是`app`。查看`app.component.ts`；`selector`是`abe-root`而不是`app-root`。
- en: While on the topic of Angular CLI and builds, there is something that we should
    understand before proceeding.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论Angular CLI和构建时，有一件事情在继续之前我们应该了解。
- en: '*What happens to the TypeScript code we write?*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们编写的TypeScript代码会发生什么？*'
- en: Code transpiling
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码转译
- en: Browsers, as we all know, only work with JavaScript, they don't understand TypeScript.
    We hence need a mechanism to convert our TypeScript code into plain JavaScript
    (**ES5** is our safest bet). The **TypeScript compiler** does this job. The compiler
    takes the TypeScript code and converts it into JavaScript. This process is commonly
    referred to as **transpiling**, and since the TypeScript compiler does it, it's
    called a **transpiler**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，浏览器只能处理JavaScript，它们无法理解TypeScript。因此，我们需要一种机制将我们的TypeScript代码转换成普通的JavaScript（**ES5**是我们最安全的选择）。**TypeScript编译器**完成了这项工作。编译器接收TypeScript代码并将其转换为JavaScript。这个过程通常被称为**转译**，由于TypeScript编译器完成了这项工作，它被称为**转译器**。
- en: JavaScript as a language has evolved over the years with every new version adding
    new features/capabilities to the language. The latest avatar, ES2015, succeeds
    ES5 and is a major update to the language. While released in June 2015, some of
    the older browsers still lack support for the ES2015 flavor, of JavaScript making
    its adoption a challenge.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每个新版本为语言添加新功能/能力，JavaScript作为一种语言在多年来不断发展。最新的版本ES2015在ES5的基础上进行了重大更新。尽管在2015年6月发布，一些旧版浏览器仍然缺乏对ES2015版本JavaScript的支持，这使得它的采用成为一个挑战。
- en: When transpiling code from TypeScript to JavaScript, we can specify the flavor
    of JavaScript to use. As mentioned earlier, ES5 is our safest bet, but if we plan
    to work with only the latest and greatest browsers, go for ES2015\. For 7 Minute
    Workout, our code to transpile to is ES5 format. We set this TypeScript compiler
    configuration in `tsconfig.json` (see the `target` property).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将TypeScript代码转换为JavaScript时，我们可以指定要使用的JavaScript版本。如前所述，ES5是我们最安全的选择，但如果我们打算只与最新和最伟大的浏览器一起工作，就选择ES2015。对于7分钟锻炼，我们要转换的代码是ES5格式。我们在`tsconfig.json`中设置了TypeScript编译器配置（参见`target`属性）。
- en: 'Interestingly, transpilation can happen at both build/compile time and at runtime:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，转译可以在构建/编译时和运行时都发生：
- en: '**Build-time transpilation**: Transpilation as part of the build process takes
    the script files (in our case, TypeScript `.ts` files) and compiles them into
    plain JavaScript. Angular CLI does build-time transpilation.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建时转译**：作为构建过程的一部分进行转译，将脚本文件（在我们的情况下是TypeScript `.ts`文件）编译成普通的JavaScript。Angular
    CLI进行构建时转译。'
- en: '**Runtime transpilation**: This happens in the browser at runtime. We directly
    reference the TypeScript files (`.ts` in our case), and the TypeScript compiler,
    which is loaded in the browser beforehand, compiles these script files on the
    fly. This is a workable setup only for small examples/code snippets, as there
    is an additional performance overhead involved in loading the transpiler and transpiling
    the code on the fly.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时转译**：这发生在浏览器中的运行时。我们直接引用TypeScript文件（在我们的情况下是`.ts`文件），并且浏览器中预先加载的TypeScript编译器会即时编译这些脚本文件。这只适用于小例子/代码片段，因为加载转译器并即时转译代码会带来额外的性能开销。'
- en: The process of transpiling is not limited to TypeScript. Every language targeted
    towards the web, such as **CoffeeScript**, **ES2015**, (yes JavaScript itself!)
    or any other language that is not inherently understood by a browser needs transpilation.
    There are transpilers for most languages, and the prominent ones (other than TypeScript)
    are **tracuer** and **babel.**
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 转译的过程不仅限于TypeScript。针对Web的每种语言，如**CoffeeScript**，**ES2015**（是的，JavaScript本身！）或任何其他浏览器本身无法理解的语言都需要转译。大多数语言都有转译器，除了TypeScript之外，主要的转译器还有**tracuer**和**babel**。
- en: The Angular CLI build system takes care of setting up the TypeScript compiler
    and sets up file watchers that recompile the code every time we make changes to
    our TypeScript file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI构建系统负责设置TypeScript编译器，并设置文件监视器，每当我们对TypeScript文件进行更改时，它就会重新编译代码。
- en: If you are new to TypeScript, remember that TypeScript does not depend on Angular;
    in fact, Angular has been built on TypeScript. I highly recommend that you look
    at the official documentation on TypeScript ([https://www.typescriptlang.org/](https://www.typescriptlang.org/))
    and learn the language outside the realms of Angular.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是TypeScript的新手，请记住TypeScript并不依赖于Angular；事实上，Angular是建立在TypeScript之上的。我强烈建议你查看TypeScript的官方文档（[https://www.typescriptlang.org/](https://www.typescriptlang.org/)）并在Angular之外的领域学习这门语言。
- en: Let's get back to the app we are building and start exploring the code setup.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们正在构建的应用程序，并开始探索代码设置。
- en: Organizing code
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码组织
- en: 'The advantage of Angular CLI is that is dictates a code organization structure
    that works for applications of all sizes. Here is how the current code organization
    looks:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI的优势在于它规定了适用于各种规模应用程序的代码组织结构。当前的代码组织结构如下：
- en: '![](Images/b1552b1b-0bd6-427a-b0f8-0fe6145d65ec.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b1552b1b-0bd6-427a-b0f8-0fe6145d65ec.png)'
- en: '`trainer` is the application root folder.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trainer`是应用程序的根文件夹。'
- en: The files inside `trainer` are configuration files and some standard files that
    are part of every standard node application.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trainer`内部的文件是配置文件和一些标准文件，它们是每个标准的Node应用程序的一部分。'
- en: The `e2e` folder will contain end to end tests for the app.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e2e`文件夹将包含应用的端到端测试。'
- en: '`src` is the primary folder where all the development happens. All the application
    artifacts go into `src`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`是所有开发发生的主要文件夹。所有应用程序构件都放在`src`中。'
- en: The `assets` folder inside `src` hosts static content (such as images, CSS,
    audio files, and others).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`文件夹内的`assets`文件夹托管静态内容（如图像、CSS、音频文件等）。'
- en: The `app` folder has the app's source code.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app`文件夹包含应用程序的源代码。'
- en: The `environments` folder is useful to set configurations for different deployment
    environments (such as *dev, qa, production*).
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environments`文件夹对于为不同的部署环境（如*dev, qa, production*）设置配置非常有用。'
- en: To organize Angular code inside the `app` folder, we take a leaf from the Angular
    style guide ([http://bit.ly/ng6be-style-guide](http://bit.ly/ng6be-style-guide))
    released by the Angular team.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`app`文件夹内组织Angular代码，我们从Angular团队发布的Angular样式指南（[http://bit.ly/ng6be-style-guide](http://bit.ly/ng6be-style-guide)）中汲取了灵感。
- en: Feature folders
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能文件夹
- en: The style guide recommends the use of **feature folders** to organize code.
    With feature folders, files linked to a single feature are placed together. If
    a feature grows, we break it down further into sub features and tuck the code
    into sub folders. Consider the `app` folder to be our first feature folder! As
    the application grows, `app` will add sub features for better code organization.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 样式指南建议使用**功能文件夹**来组织代码。使用功能文件夹，与单个功能相关的文件放在一起。如果一个功能增长，我们将进一步将其分解为子功能，并将代码放入子文件夹中。考虑`app`文件夹是我们的第一个功能文件夹！随着应用程序的增长，`app`将添加子功能以更好地组织代码。
- en: Let's get straight into building the application. Our first focus area, the
    app's model!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接开始构建应用程序。我们的第一个关注点，应用程序的模型！
- en: The 7 Minute Workout model
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7分钟锻炼模型
- en: 'Designing the model for this app requires us to first detail the functional
    aspects of the *7 Minute Workout* app, and then derive a model that satisfies
    those requirements. Based on the problem statement defined earlier, some of the
    obvious requirements are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为这个应用程序设计模型需要我们首先详细说明*7分钟锻炼*应用程序的功能方面，然后得出满足这些要求的模型。根据之前定义的问题陈述，一些明显的要求如下：
- en: Being able to start the workout.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够开始锻炼。
- en: 'Providing a visual clue about the current exercise and its progress. This includes
    the following:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供关于当前练习及其进度的视觉线索。这包括以下内容：
- en: Providing a visual depiction of the current exercise
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供当前练习的视觉描述
- en: Providing step-by-step instructions on how to do a specific exercise
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供如何做特定练习的逐步说明。
- en: The time left for the current exercise
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前练习的剩余时间
- en: Notifying the user when the workout ends.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在锻炼结束时通知用户。
- en: 'Some other valuable features that we will add to this app are as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个应用程序添加的一些其他有价值的功能如下：
- en: The ability to pause the current workout.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停当前的锻炼能力。
- en: Providing information about the next exercise to follow.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供关于接下来要进行的练习的信息。
- en: 'Providing audio clues so that the user can perform the workout without constantly
    looking at the screen. This includes:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供音频线索，以便用户可以在不断盯着屏幕的情况下进行锻炼。这包括：
- en: A timer click sound
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时器点击声
- en: Details about the next exercise
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于下一个练习的详细信息
- en: Signaling that the exercise is about to start
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号表明练习即将开始
- en: Showing related videos for the exercise in progress and the ability to play
    them.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示正在进行的练习的相关视频，并能够播放它们的能力。
- en: As we can see, the central themes for this app are **workout** and **exercise**.
    Here, a workout is a set of exercises performed in a specific order for a particular
    duration. So, let's go ahead and define the model for our workout and exercise.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这个应用程序的中心主题是**锻炼**和**练习**。在这里，锻炼是按特定顺序进行的一组练习，持续一段特定时间。因此，让我们继续为我们的锻炼和练习定义模型。
- en: 'Based on the requirements just mentioned, we will need the following details
    about an exercise:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 根据刚才提到的要求，我们将需要关于练习的以下详细信息：
- en: The name. This should be unique.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称。这应该是唯一的。
- en: The title. This is shown to the user.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题。这将显示给用户看。
- en: The description of the exercise.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习的描述。
- en: Instructions on how to perform the exercise.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于如何执行练习的说明。
- en: Images for the exercise.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习的图片。
- en: The name of the audio clip for the exercise.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习的音频剪辑的名称。
- en: Related videos.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关视频。
- en: With TypeScript, we can define the classes for our model.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TypeScript，我们可以为我们的模型定义类。
- en: 'The `Exercise` class looks as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exercise`类如下所示：'
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: TypeScript tips
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript提示
- en: Declaring constructor parameters with `public` or `private` is a shorthand for
    creating and initializing class members at one go. The `?` suffix after `nameSound`,
    `procedure`, and `videos` implies that these are optional parameters.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`public`或`private`声明构造函数参数是一种快捷方式，可以一次创建和初始化类成员。在`nameSound`，`procedure`和`videos`后面的`?`后缀意味着这些是可选参数。
- en: 'For the workout, we need to track the following properties:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于锻炼，我们需要跟踪以下属性：
- en: The name. This should be unique.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称。这应该是唯一的。
- en: The title. This is shown to the user.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题。这将显示给用户看。
- en: The exercises that are part of the workout.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为锻炼一部分的练习。
- en: The duration for each exercise.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个练习的持续时间。
- en: The rest duration between two exercises.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个练习之间的休息时间。
- en: 'The model class to track workout progress (`WorkoutPlan`) looks as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 用于跟踪锻炼进度的模型类（`WorkoutPlan`）如下所示：
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `totalWorkoutDuration` function returns the total duration of the workout
    in seconds.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`totalWorkoutDuration`函数返回锻炼的总持续时间（以秒为单位）。'
- en: '`WorkoutPlan` has a reference to another class in the preceding definition,
    `ExercisePlan`. It tracks the exercise and the duration of the exercise in a workout,
    which is quite apparent once we look at the definition of `ExercisePlan`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutPlan`在前面的定义中引用了另一个类，`ExercisePlan`。它跟踪锻炼和锻炼在锻炼中的持续时间，一旦我们查看`ExercisePlan`的定义，这就显而易见了：'
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let me save you some typing and tell you where to get the model classes, but
    before that, we need to decide where to add them. We are ready for our first feature.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我帮你节省一些打字的时间，并告诉你在哪里获取模型类，但在此之前，我们需要决定在哪里添加它们。我们已经准备好了我们的第一个特性。
- en: First feature module
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个特性模块
- en: The primary feature of *7 Minute Workout* is to execute a predefined set of
    exercises. Hence we are going to create a feature module now and later add the
    feature implementation to this module. We call this module `workout-runner`. Let's
    initialize the feature with Angular CLI's scaffolding capabilities.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*7分钟锻炼*的主要特点是执行一组预定义的练习。因此，我们现在要创建一个特性模块，稍后将特性实现添加到此模块中。我们将这个模块称为`workout-runner`。让我们使用Angular
    CLI的脚手架功能初始化该特性。'
- en: 'From the command line, navigate to the `trainer/src/app` folder and run the
    following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行导航到`trainer/src/app`文件夹，并运行以下命令：
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Follow the console logs to know what files are generated. The command essentially:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随控制台日志以了解生成了哪些文件。该命令本质上是：
- en: Creates a new Angular `WorkoutRunnerModule` module inside a new `workout-runner`
    folder
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新的`workout-runner`文件夹内创建一个新的Angular `WorkoutRunnerModule`模块
- en: Imports the newly created module into the main application module app (`app.module.ts`)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新创建的模块导入到主应用程序模块app（`app.module.ts`）中
- en: We now have a new **feature module**.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一个新的**特性模块**。
- en: Give every feature its own module.Make special note of the conventions Angular
    CLI follows when scaffolding Angular artifacts. From the preceding example, the
    module name provided with the command line was `workout-runner`. While the generated
    folder and filenames use the same name, the class name for the generated module
    is `WorkoutRunnerModule` (pascal case with the `Module` suffix).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 给每个功能都分配一个自己的模块。特别注意 Angular CLI 在构建 Angular 构件时遵循的约定。在前面的示例中，命令行提供的模块名称是 `workout-runner`。虽然生成的文件夹和文件名使用相同的名称，但生成的模块的类名是
    `WorkoutRunnerModule`（帕斯卡命名法，带有 `Module` 后缀）。
- en: Open the newly generated module definition (`workout-runner.module.ts`) and
    look at the generated content. `WorkoutRunnerModule` imports `CommonModule`, a
    module with common Angular directives such as `ngIf` and `ngFor`, allowing us
    to use these common directives across any component/directive defined in `WorkoutRunnerModule`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 打开新生成的模块定义（`workout-runner.module.ts`）并查看生成的内容。`WorkoutRunnerModule` 导入 `CommonModule`，这是一个具有常见
    Angular 指令（如 `ngIf` 和 `ngFor`）的模块，允许我们在 `WorkoutRunnerModule` 中定义的任何组件/指令中使用这些常见指令。
- en: Modules are Angular's way of organizing code. We will touch upon Angular modules
    shortly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是 Angular 组织代码的方式。我们将很快讨论 Angular 模块。
- en: Copy the `model.ts` file from [http://bit.ly/ng6be-2-1-model-ts](http://bit.ly/ng6be-2-1-model-ts) into
    the `workout-runner` folder. Shortly, we will see how these model classes are
    utilized.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将 [http://bit.ly/ng6be-2-1-model-ts](http://bit.ly/ng6be-2-1-model-ts) 中的 `model.ts`
    文件复制到 `workout-runner` 文件夹中。不久，我们将看到这些模型类是如何被使用的。
- en: Since we have started with a preconfigured Angular app, we just need to understand
    how the app starts.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经开始了一个预配置的 Angular 应用程序，我们只需要了解应用程序是如何启动的。
- en: App bootstrapping
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序引导
- en: 'The app bootstrapping process for *7 Minute Workout* can be carried out from
    the `src` folder. There is a `main.ts` file that bootstraps the application by
    calling the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*7 Minute Workout* 应用程序的引导过程可以从 `src` 文件夹中进行。有一个 `main.ts` 文件，通过调用以下内容引导应用程序：'
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The heavy lifting is done by the Angular CLI, which compiles the application,
    includes the script and CSS reference into `index.html`, and runs the application.
    We don't need to configure anything. These configurations are part of the default
    Angular CLI configuration (`.angular-cli.json`).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI 执行了大部分工作，它编译应用程序，将脚本和 CSS 引用包含到 `index.html` 中，并运行应用程序。我们不需要配置任何东西。这些配置是默认的
    Angular CLI 配置（`.angular-cli.json`）的一部分。
- en: We have created a new module and added some model classes to the `module` folder.
    Before we go any further and start implementing the feature, let's talk a bit
    about **Angular modules**.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个新模块，并将一些模型类添加到了 `module` 文件夹中。在我们进一步实现该功能之前，让我们稍微谈谈 **Angular 模块**。
- en: Exploring Angular modules
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Angular 模块
- en: As the *7 Minute Workout* app grows and we add new components/directives/pipes/other
    artifacts to it, a need arises to organize these items. Each of these items needs
    to be part of an Angular module.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 *7 Minute Workout* 应用程序的增长，我们向其中添加新的组件/指令/管道/其他构件，需要组织这些项目的需求出现。每个项目都需要成为
    Angular 模块的一部分。
- en: A naïve approach would be to declare everything in our app's root module (`AppModule`),
    as we did with `WorkoutRunnerComponent`, but this defeats the whole purpose of
    Angular modules.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一个天真的方法是在我们应用程序的根模块（`AppModule`）中声明所有内容，就像我们在 `WorkoutRunnerComponent` 中所做的那样，但这违背了
    Angular 模块的整体目的。
- en: To understand why a single-module approach is never a good idea, let's explore
    Angular modules.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么单一模块方法永远不是一个好主意，让我们探索 Angular 模块。
- en: Comprehending Angular modules
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Angular 模块
- en: In Angular, **modules** are a way to organize code into chunks that belong together
    and work as a cohesive unit. Modules are Angular's way of grouping and organizing
    code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，**模块** 是一种将代码组织成属于一起并作为一个统一单元工作的方式。模块是 Angular 分组和组织代码的方式。
- en: 'An Angular module primarily defines:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Angular模块主要定义：
- en: The components/directives/pipes it owns
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它拥有的组件/指令/管道
- en: The components/directives/pipes it makes public for other modules to consume
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它公开供其他模块使用的组件/指令/管道
- en: Other modules that it depends on
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它依赖的其他模块
- en: Services that the module wants to make available application-wide
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块希望在整个应用程序中提供的服务
- en: 'Any decent-sized Angular app will have modules interlinked with each other:
    some modules consuming artifacts from other, some providing artifacts to others,
    and some modules doing both.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 任何规模较大的Angular应用程序都将模块相互链接：一些模块从其他模块消费构件，一些模块向其他模块提供构件，一些模块两者都做。
- en: 'As a standard practice, module segregation is feature-based. One divides the
    app into features or subfeatures (for large features) and modules are created
    for each of the features. Even the framework adheres to this guideline as all
    of the framework constructs are divided across modules:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 作为标准实践，模块分离是基于特性的。将应用程序分成特性或子特性（对于大特性），并为每个特性创建模块。即使框架也遵循这一指南，因为所有框架构造都分布在模块之间：
- en: There is `CommonModule` that aggregates the standard framework constructs used
    in every browser-based Angular app
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有`CommonModule`，它聚合了每个基于浏览器的Angular应用程序中使用的标准框架构造。
- en: There is `RouterModule` if we want to use the Angular routing framework
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想要使用Angular路由框架，则有`RouterModule`。
- en: There is `HtppModule` if our app needs to communicate with the server over HTTP
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的应用程序需要通过HTTP与服务器通信，则有`HtppModule`。
- en: Angular modules are created by applying the `@NgModule` decorator to a TypeScript
    class. The decorator definition exposes enough metadata, allowing Angular to load
    everything the module refers to.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Angular模块是通过将`@NgModule`装饰器应用于TypeScript类来创建的。装饰器定义公开了足够的元数据，允许Angular加载模块引用的所有内容。
- en: 'The decorator has multiple attributes that allow us to define:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器具有多个属性，允许我们定义：
- en: External dependencies (using `imports`).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部依赖项（使用`imports`）。
- en: Module artifacts (using `declarations`).
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块构件（使用`declarations`）。
- en: Module exports (using `exports`).
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块导出（使用`exports`）。
- en: The services defined inside the module that need to be registered globally (using
    `providers`).
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块内定义的需要全局注册的服务（使用`providers`）。
- en: The main application view, called the **root component**, which hosts all other
    app views. Only the root module should set this using the `bootstrap` property.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 称为**根组件**的主应用程序视图，它托管所有其他应用程序视图。只有根模块应该使用`bootstrap`属性设置这一点。
- en: 'This diagram highlights the internals of a module and how they link to each
    other:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此图示了模块的内部及其如何相互链接：
- en: '![](Images/9596f561-ea75-4d83-b999-7d9853ab892e.jpg)Modules defined in the
    context of Angular (using the `@NgModule` decorator) are different from modules
    we import using the `import` statement in our TypeScript file. Modules imported
    through the `import` statement are **JavaScript modules**, which can be in different
    formats adhering to *CommonJS*, *AMD*, or *ES2015* specifications, whereas Angular
    modules are constructs used by Angular to segregate and organize its artifacts.
    Unless the context of the discussion is specifically a JavaScript module, any
    reference to module implies an Angular module. We can learn more about this here: [http://bit.ly/ng2be6-module-vs-ngmodule](http://bit.ly/ng2be6-module-vs-ngmodule).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/9596f561-ea75-4d83-b999-7d9853ab892e.jpg)在Angular上下文中定义的模块（使用`@NgModule`装饰器）与我们在TypeScript文件中使用`import`语句导入的模块不同。通过`import`语句导入的模块是**JavaScript模块**，可以采用符合*CommonJS*、*AMD*或*ES2015*规范的不同格式，而Angular模块是Angular用来分隔和组织其构件的构造。除非讨论的上下文明确是JavaScript模块，否则对模块的任何引用都意味着Angular模块。我们可以在这里了解更多信息：[http://bit.ly/ng2be6-module-vs-ngmodule](http://bit.ly/ng2be6-module-vs-ngmodule)。'
- en: 'We hope one thing is clear from all this discussion: creating a single application-wide
    module is not the right use of Angular modules unless you are building something
    rudimentary.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望从所有这些讨论中有一件事是清楚的：创建一个单一的应用程序范围模块并不是Angular模块的正确用法，除非你正在构建一些基本的东西。
- en: It's time to get into the thick of the action; let's build our first component.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候投入行动了；让我们构建我们的第一个组件。
- en: Our first component - WorkoutRunnerComponent
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个组件 - WorkoutRunnerComponent
- en: '`WorkoutRunnerComponent`, is the central piece of our *7 Minute Workout* app
    and it will contain the logic to execute the workout.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`是我们*7分钟锻炼*应用程序的核心部分，它将包含执行锻炼的逻辑。'
- en: 'What we are going to do in the `WorkoutRunnerComponent` implementation is as
    follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`WorkoutRunnerComponent`实现中要做的是：
- en: Start the workout
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始锻炼
- en: Show the workout in progress and show the progress indicator
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示正在进行的锻炼并显示进度指示器
- en: After the time elapses for an exercise, show the next exercise
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在练习时间结束后，显示下一个练习
- en: Repeat this process until all the exercises are over
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复此过程，直到所有练习结束
- en: We are ready to create (or scaffold) our component.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备创建（或脚手架）我们的组件。
- en: 'From the command line, navigate to the `src/app` folder and execute the following
    `ng` command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行导航到`src/app`文件夹，并执行以下`ng`命令：
- en: '[PRE10]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The generator generates a bunch of files (three) in the `workout-runner` folder
    and updates the module declaration in `WorkoutRunnerModule` to include the newly
    created `WorkoutRunnerComponent`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器在`workout-runner`文件夹中生成一堆文件（三个），并更新`WorkoutRunnerModule`中的模块声明，以包括新创建的`WorkoutRunnerComponent`。
- en: The `-is` flag is used to stop generation of a separate CSS file for the component.
    Since we are using global styles, we do not need component-specific styles.Remember
    to run this command from the `src/app` folder and not from the `src/app/workout-runner`
    folder. If we run the preceding command from `src/app/workout-runner`, Angular
    CLI will create a new subfolder with the `workout-runner` component definition.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`-is`标志用于停止为组件生成单独的CSS文件。由于我们使用全局样式，我们不需要组件特定的样式。记得从`src/app`文件夹而不是从`src/app/workout-runner`文件夹运行此命令。如果我们从`src/app/workout-runner`运行上述命令，Angular
    CLI将创建一个新的子文件夹，其中包含`workout-runner`组件定义。'
- en: 'The preceding `ng generate` command for component generates these three files:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的`ng generate`命令生成这三个文件：
- en: '`<component-name>.component.html`: This is the component''s view HTML.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<component-name>.component.html`：这是组件的视图HTML。'
- en: '`<component-name>.component.spec.ts`: Test specification file used in unit
    testing.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<component-name>.component.spec.ts`：用于单元测试的测试规范文件。'
- en: '`<component-name>.component.ts`: Main component file containing component implementation.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<component-name>.component.ts`：包含组件实现的主要组件文件。'
- en: Again, we will encourage you to have a look at the generated code to understand
    what gets generated. The Angular CLI component generator saves us some keystrokes
    and once generated, the boilerplate code can evolve as desired.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们鼓励您查看生成的代码，以了解生成了什么。Angular CLI组件生成器为我们节省了一些按键操作，一旦生成，样板代码可以按需演变。
- en: While we see only four decorator metadata properties (such as `templateUrl`),
    the component decorator supports some other useful properties too. Look at the
    Angular documentation for component to learn more about these properties and their
    application.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只看到四个装饰器元数据属性（如`templateUrl`）时，组件装饰器也支持一些其他有用的属性。查看Angular文档以了解这些属性及其应用。
- en: An observant reader might have noticed that the generated `selector` property
    value has a prefix `abe`; this is intentional. Since we are extending the HTML
    **domain-specific language** (**DSL**) to incorporate a new element, the prefix
    `abe` helps us demarcate HTML extensions that we have developed. So instead of
    using `<workout-runner></workout-runner>` in HTML we use `<abe-workout-runner></abe-workout-runner>`.
    The prefix value has been configured in `angular.json`, see the `prefix` property.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 敏锐的读者可能已经注意到生成的`selector`属性值具有前缀`abe`；这是有意的。由于我们正在扩展HTML**领域特定语言**（**DSL**）以纳入新元素，前缀`abe`帮助我们标记我们开发的HTML扩展。因此，我们在HTML中使用`<abe-workout-runner></abe-workout-runner>`而不是`<workout-runner></workout-runner>`。前缀值已在`angular.json`中配置，参见`prefix`属性。
- en: Always add a prefix to your component selector.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 始终为组件选择器添加前缀。
- en: We now have the `WorkoutRunnerComponent` boilerplate; let's start adding the
    implementation, starting with adding the model reference.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`WorkoutRunnerComponent`的样板；让我们开始添加实现，首先是添加模型引用。
- en: 'In `workout-runner.component.ts`, import all the workout models:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在`workout-runner.component.ts`中，导入所有的锻炼模型：
- en: '[PRE11]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we need to set up the workout data. Let''s do that by adding some code
    in the generated `ngOnInit` function and related class properties to the `WorkoutRunnerComponent`
    class:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置锻炼数据。让我们通过在生成的`ngOnInit`函数和相关类属性中添加一些代码来完成`WorkoutRunnerComponent`类。
- en: '[PRE12]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`ngOnInit` is a special function that Angular calls when a component is initialized.
    We will talk about `ngOnInit` shortly.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngOnInit`是Angular在组件初始化时调用的特殊函数。我们很快会谈到`ngOnInit`。'
- en: The `buildWorkout` on `WorkoutRunnerComponent` sets up the complete workout,
    as we will define shortly. We also initialize a `restExercise` variable to track
    even the rest periods as exercise (note that `restExercise` is an object of type
    `ExercisePlan`).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`上的`buildWorkout`设置完整的锻炼计划，我们很快将定义。我们还初始化了一个`restExercise`变量来跟踪休息期间的锻炼（注意`restExercise`是`ExercisePlan`类型的对象）。'
- en: 'The `buildWorkout` function is a lengthy function, so it''s better to copy
    the implementation from the workout runner''s implementation available in Git
    branch checkpoint2.1 ([http://bit.ly/ng6be-2-1-workout-runner-component-ts](http://bit.ly/ng6be-2-1-workout-runner-component-ts)).
    The `buildWorkout` code looks as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildWorkout`函数是一个冗长的函数，最好从Git分支checkpoint2.1中的锻炼运行器的实现中复制实现（[http://bit.ly/ng6be-2-1-workout-runner-component-ts](http://bit.ly/ng6be-2-1-workout-runner-component-ts)）。`buildWorkout`代码如下：'
- en: '[PRE13]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code builds the `WorkoutPlan` object and pushes the exercise data into
    the `exercises` array (an array of `ExercisePlan` objects), returning the newly
    built workout.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码构建了`WorkoutPlan`对象，并将锻炼数据推入`exercises`数组（一个`ExercisePlan`对象数组），返回新构建的锻炼计划。
- en: 'The initialization is complete; now, it''s time to actually implement the *start*
    workout. Add a `start` function to the `WorkoutRunnerComponent` implementation,
    as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化完成；现在是时候实际实现*开始*锻炼了。在`WorkoutRunnerComponent`实现中添加一个`start`函数，如下所示：
- en: '[PRE14]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then declare the new variables used in the function at the top, with other
    variable declarations:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在顶部声明函数中使用的新变量，以及其他变量声明：
- en: '[PRE15]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `workoutTimeRemaining` variable tracks the total time remaining for the
    workout, and `currentExerciseIndex` tracks the currently executing exercise index.
    The call to `startExercise` actually starts an exercise. This is how the code
    for `startExercise` looks:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`workoutTimeRemaining`变量跟踪锻炼剩余的总时间，`currentExerciseIndex`跟踪当前执行的锻炼索引。调用`startExercise`实际上开始了一项锻炼。`startExercise`的代码如下：'
- en: '[PRE16]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We start by initializing `currentExercise` and `exerciseRunningDuration`. The
    `currentExercise` variable tracks the exercise in progress and `exerciseRunningDuration`
    tracks its duration. These two variables also need to be declared at the top:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先初始化`currentExercise`和`exerciseRunningDuration`。`currentExercise`变量跟踪正在进行的运动，`exerciseRunningDuration`跟踪其持续时间。这两个变量也需要在顶部声明：
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We use the `setInterval` JavaScript function with a delay of one second (1,000
    milliseconds) to make progress. Inside the `setInterval` callback, `exerciseRunningDuration`
    is incremented with each passing second. The nested `clearInterval` call stops
    the timer once the exercise duration lapses.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`setInterval` JavaScript函数，延迟一秒（1,000毫秒）来进行进度。在`setInterval`回调内，`exerciseRunningDuration`每秒递增一次。嵌套的`clearInterval`调用在运动持续时间结束后停止计时器。
- en: TypeScript arrow functions
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript箭头函数
- en: The callback parameter passed to `setInterval` (`()=>{...}`) is a lambda function
    (or an arrow function in ES 2015). Lambda functions are short-form representations
    of anonymous functions, with added benefits. You can learn more about them at
    [http://bit.ly/ng2be-ts-arrow-functions](http://bit.ly/ng2be-ts-arrow-functions).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`setInterval`传递的回调参数(`()=>{...}`)是一个lambda函数（或者在ES 2015中是箭头函数）。Lambda函数是匿名函数的简写表示，具有附加的好处。您可以在[http://bit.ly/ng2be-ts-arrow-functions](http://bit.ly/ng2be-ts-arrow-functions)了解更多关于它们的信息。'
- en: 'The first cut of the component is almost complete, except it currently has
    a static view (UI) and hence we cannot verify the implementation. We can quickly
    rectify this situation by adding a rudimentary view definition. Open `workout-runner.component.ts`,
    comment out the `templateUrl` property, and add an inline template property (`template`)
    and set it to the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的第一个版本几乎完成了，除了它目前有一个静态视图（UI），因此我们无法验证实现。我们可以通过添加一个基本的视图定义来快速纠正这种情况。打开`workout-runner.component.ts`，注释掉`templateUrl`属性，并添加一个内联模板属性(`template`)，并将其设置为以下内容：
- en: '[PRE18]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Strings enclosed in backticks (`` ``) are a new addition to ES2015\. Also called
    template literals, such string literals can be multiline and allow expressions
    to be embedded inside (not to be confused with Angular expressions). Look at the
    MDN article at [http://bit.ly/template-literals](http://bit.ly/template-literals)
    for more details.Inline versus external view templateThe preceding `template`
    property is an example of **inline component template**. This allows the component
    developer to specify the component template inline instead of using a separate
    HTML file. The inline template approach generally works for components with a
    trivial view. Inline templates have a disadvantage: formatting HTML becomes difficult
    and IDE support is very limited as the content is treated as a string literal.
    When we externalize HTML, we can develop a template as a normal HTML document.
    We recommend you use an **external template file** (specified using `templateUrl`)
    for elaborate views. Angular CLI by default generates an external template reference,
    but we can affect this behavior by passing the `--inline-template` flag to the `ng`
    component generation command, such as `--inline-template true`.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 反引号(`` `` ``)括起来的字符串是ES2015的一个新添加。也称为模板字面量，这样的字符串文字可以是多行的，并允许嵌入表达式（不要与Angular表达式混淆）。查看MDN文章[http://bit.ly/template-literals](http://bit.ly/template-literals)了解更多详情。内联与外部视图模板前面的`template`属性是**内联组件模板**的一个例子。这允许组件开发人员内联指定组件模板，而不是使用单独的HTML文件。内联模板方法通常适用于具有琐碎视图的组件。内联模板有一个缺点：格式化HTML变得困难，IDE支持非常有限，因为内容被视为字符串文字。当我们将HTML外部化时，我们可以将模板开发为普通的HTML文档。我们建议您为复杂的视图使用**外部模板文件**（使用`templateUrl`指定）。Angular
    CLI默认生成外部模板引用，但我们可以通过向`ng`组件生成命令传递`--inline-template`标志来影响此行为，例如`--inline-template
    true`。
- en: 'The preceding template HTML will render the raw `ExercisePlan` object and the
    exercise time remaining. It has an interesting expression inside the first interpolation:
    `currentExercise | json`. The `currentExercise` property is defined in `WorkoutRunnerComponent`,
    but what about the `|` symbol and what follows it (`json`)? In the Angular world,
    it is called a **pipe**. The sole purpose of a pipe is to transform/format template
    data.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模板HTML将呈现原始的`ExercisePlan`对象和剩余的锻炼时间。在第一个插值内有一个有趣的表达式：`currentExercise | json`。`currentExercise`属性在`WorkoutRunnerComponent`中定义，但`|`符号和其后的内容（`json`）是什么？在Angular世界中，它被称为**管道**。管道的唯一目的是转换/格式化模板数据。
- en: The `json` pipe here does JSON data formatting. You will learn more about pipes
    later in this chapter, but to get a general sense of what the `json` pipe does,
    we can remove the `json` pipe plus the `|` symbol and render the template; we
    are going to do this next.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`json`管道进行JSON数据格式化。您将在本章后面学到更多关于管道的知识，但为了对`json`管道的作用有一个大致的了解，我们可以移除`json`管道和`|`符号，然后渲染模板；我们接下来要做的就是这个。
- en: 'To render the new `WorkoutRunnerComponent` implementation, it has to be added
    to the root component''s view. Modify `src/components/app/app.component.html`
    and replace the `h3` tag with the following code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染新的`WorkoutRunnerComponent`实现，它必须添加到根组件的视图中。修改`src/components/app/app.component.html`，并用以下代码替换`h3`标签：
- en: '[PRE19]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: While the implementation may look complete, there is a crucial piece missing.
    Nowhere in the code do we actually start the workout. The workout should start
    as soon as we load the page.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实现看起来很完整，但缺少一个关键部分。在代码中我们实际上没有启动锻炼。锻炼应该在页面加载时立即开始。
- en: Component lifecycle hooks are going to rescue us!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 组件生命周期钩子将拯救我们！
- en: Component lifecycle hooks
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件生命周期钩子
- en: 'The life of an Angular component is eventful. Components get created, change
    state during their lifetime, and finally, they are destroyed. Angular provides
    some **lifecycle hooks**/**functions** that the framework invokes (on the component)
    when such an event occurs. Consider these examples:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Angular组件的生命周期是多事之秋。组件被创建，它们在其生命周期中改变状态，最终被销毁。Angular提供了一些**生命周期钩子**/**函数**，当发生这样的事件时，框架会调用（在组件上）。考虑以下例子：
- en: When a component is initialized, Angular invokes `ngOnInit`
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当组件初始化时，Angular会调用`ngOnInit`
- en: When a component's data-bound properties change, Angular invokes `ngOnChanges`
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当组件的数据绑定属性发生变化时，Angular会调用`ngOnChanges`
- en: When a component is destroyed, Angular invokes `ngOnDestroy`
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当组件被销毁时，Angular会调用`ngOnDestroy`
- en: As developers, we can tap into these key moments and perform some custom logic
    inside the respective component.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们可以利用这些关键时刻，在各自的组件内执行一些自定义逻辑。
- en: The hook we are going to utilize here is `ngOnInit`. The `ngOnInit` function
    gets fired the first time the component's data-bound properties are initialized,
    but before the view initialization starts.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要利用的钩子是`ngOnInit`。`ngOnInit`函数在组件的数据绑定属性初始化完成后第一次被触发，但在视图初始化开始之前。
- en: While `ngOnInit` and the class constructor seem to look similar, they have a
    different purpose. *A constructor* is a language feature and it is used to initialize
    class members. `ngOnInit`, on the other hand, is used to do some initialization
    stuff once the component is ready. Avoid use of a constructor for anything other
    than member initialization.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`ngOnInit`和类构造函数看起来相似，但它们有不同的目的。*构造函数*是一种语言特性，用于初始化类成员。另一方面，`ngOnInit`用于在组件准备就绪后进行一些初始化工作。除了成员初始化，避免在构造函数中使用其他任何内容。
- en: 'Update the `ngOnInit` function to the `WorkoutRunnerComponent` class with a
    call to start the workout:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 将`ngOnInit`函数更新到`WorkoutRunnerComponent`类，调用开始锻炼：
- en: '[PRE20]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Angular CLI as part of component scaffolding already generates the signature
    for `ngOnInit`. The `ngOnInit` function is declared on the `OnInit` interface,
    which is part of the core Angular framework. We can confirm this by looking at
    the import section of `WorkoutRunnerComponent`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 作为组件脚手架的一部分，Angular CLI已经为`ngOnInit`生成了签名。`ngOnInit`函数在`OnInit`接口上声明，该接口是核心Angular框架的一部分。我们可以通过查看`WorkoutRunnerComponent`的导入部分来确认这一点：
- en: '[PRE21]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There are a number of other lifecycle hooks, including `ngOnDestroy`, `ngOnChanges`,
    and `ngAfterViewInit`, that components support, but we are not going to dwell
    on any of them here. Look at the developer guide ([https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks))
    on lifecycle hooks to learn more about other such hooks.Implementing the interface
    (`OnInit` in the preceding example) is optional. These lifecycle hooks work as
    long as the function name matches. We still recommend you use interfaces to clearly
    communicate the intent.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的生命周期钩子，包括`ngOnDestroy`、`ngOnChanges`和`ngAfterViewInit`，组件支持，但我们不打算在这里详细讨论任何一个。查看开发者指南（[https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks)）了解更多关于这些钩子的信息。在前面的示例中实现接口（`OnInit`）是可选的。只要函数名匹配，这些生命周期钩子就会起作用。我们仍然建议您使用接口来清楚地传达意图。
- en: 'Time to run our app! Open the command line, navigate to the `trainer` folder,
    and type this line:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行我们的应用程序了！打开命令行，导航到`trainer`文件夹，并输入以下命令：
- en: '[PRE22]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code compiles, but no UI is rendered. What is failing us? Let's look at
    the browser console for errors.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 代码编译通过，但没有UI呈现。是什么出了问题？让我们查看浏览器控制台是否有错误。
- en: 'Open the browser''s dev tools (common keyboard shortcut `F12`) and look at
    the console tab for errors. There is a template parsing error. Angular is not
    able to locate the `abe-workout-runner` component. Let''s do some sanity checks
    to verify our setup:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器的开发工具（常见的键盘快捷键`F12`），并查看控制台选项卡以查看错误。有一个模板解析错误。Angular无法找到`abe-workout-runner`组件。让我们进行一些合理性检查来验证我们的设置：
- en: '`WorkoutRunnerComponent` implementation complete - *check*'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`实现完成- *检查*'
- en: Component declared in `WorkoutRunnerModule`- *check*
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`WorkoutRunnerModule`中声明的组件- *检查*
- en: '`WorkoutRunnerModule` imported into `AppModule` - *check*'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerModule`导入到`AppModule`- *检查*'
- en: Still, the `AppComponent` template cannot locate the `WorkoutRunnerComponent`.
    Is it because `WorkoutRunnerComponent` and `AppComponent` are in different modules?
    Indeed, that is the problem! While `WorkoutRunnerModule` has been imported into `AppModule`, `WorkoutRunnerModule`
    still does not export the new `WorkoutRunnerComponent` that will allow `AppComponent`
    to use it.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然，`AppComponent`模板无法找到`WorkoutRunnerComponent`。这是因为`WorkoutRunnerComponent`和`AppComponent`在不同的模块中吗？确实，这就是问题所在！虽然`WorkoutRunnerModule`已经导入到`AppModule`中，但`WorkoutRunnerModule`仍然没有导出新的`WorkoutRunnerComponent`，这将允许`AppComponent`使用它。
- en: Remember, adding a component/directive/pipe to the `declaration` section of
    a module makes them available inside the module. It's only after we export the
    component/directive/pipe that it becomes available to be used across modules.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，将组件/指令/管道添加到模块的`declaration`部分会使它们在模块内可用。只有在我们导出组件/指令/管道之后，它才能在模块之间使用。
- en: 'Let''s export `WorkoutRunnerComponent` by updating the export array of the `WorkoutRunnerModule`
    declaration to the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过更新`WorkoutRunnerModule`声明的导出数组来导出`WorkoutRunnerComponent`如下所示：
- en: '[PRE23]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This time, we should see the following output:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们应该看到以下输出：
- en: '![](Images/5e765f48-c0a6-43ce-ab18-b6f4a5d3a612.png)Always export artifacts
    defined inside an Angular module if you want them to be used across other modules.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/5e765f48-c0a6-43ce-ab18-b6f4a5d3a612.png)如果你希望在其他模块中使用，始终导出在Angular模块中定义的构件。'
- en: The model data updates with every passing second! Now you'll understand why
    interpolations (`{{ }}`) are a great debugging tool.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 模型数据每秒都在更新！现在你会明白为什么插值 (`{{ }}`) 是一个很好的调试工具。
- en: This will also be a good time to try rendering `currentExercise` without the
    `json` pipe and see what gets rendered.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是一个很好的时机，尝试渲染 `currentExercise` 而不使用 `json` 管道，看看会渲染出什么。
- en: We are not done yet! Wait long enough on the page and we realize that the timer
    stops after 30 seconds. The app does not load the next exercise data. Time to
    fix it!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成！在页面上等待足够长的时间，我们会发现计时器在30秒后停止。应用程序没有加载下一个运动数据。是时候修复它了！
- en: 'Update the code inside the `setInterval` function:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `setInterval` 函数内的代码：
- en: '[PRE24]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `if` condition `if (this.exerciseRunningDuration >= this.currentExercise.duration)`
    is used to transition to the next exercise once the time duration of the current
    exercise lapses. We use `getNextExercise` to get the next exercise and call `startExercise`
    again to repeat the process. If no exercise is returned by the `getNextExercise`
    call, the workout is considered complete.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 条件 `if (this.exerciseRunningDuration >= this.currentExercise.duration)`
    用于在当前运动持续时间结束后过渡到下一个运动。我们使用 `getNextExercise` 获取下一个运动，并再次调用 `startExercise` 来重复这个过程。如果
    `getNextExercise` 调用没有返回任何运动，那么锻炼被视为完成。'
- en: During exercise transitioning, we increment `currentExerciseIndex` only if the
    next exercise is not a rest exercise. Remember that the original workout plan
    does not have a rest exercise. For the sake of consistency, we have created a
    rest exercise and are now swapping between rest and the standard exercises that
    are part of the workout plan. Therefore, `currentExerciseIndex` does not change
    when the next exercise is rest.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在运动过渡期间，只有下一个运动不是休息运动时，我们才会增加 `currentExerciseIndex`。请记住，原始的锻炼计划没有休息运动。为了保持一致，我们创建了一个休息运动，并且现在在休息和锻炼计划中的标准运动之间进行交换。因此，当下一个运动是休息时，`currentExerciseIndex`
    不会改变。
- en: 'Let''s quickly add the `getNextExercise` function too. Add the function to
    the `WorkoutRunnerComponent` class:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速添加 `getNextExercise` 函数。将该函数添加到 `WorkoutRunnerComponent` 类中：
- en: '[PRE25]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `getNextExercise` function returns the next exercise that needs to be performed.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNextExercise` 函数返回需要执行的下一个运动。'
- en: Note that the returned object for `getNextExercise` is an `ExercisePlan` object
    that internally contains the exercise details and the duration for which the exercise
    runs.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`getNextExercise` 返回的对象是一个 `ExercisePlan` 对象，它内部包含了运动的细节和运动持续的时间。
- en: The implementation is quite self-explanatory. If the current exercise is rest,
    take the next exercise from the `workoutPlan.exercises` array (based on `currentExerciseIndex`);
    otherwise, the next exercise is rest, given that we are not on the last exercise
    (the `else if` condition check).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相当不言自明。如果当前运动是休息，从 `workoutPlan.exercises` 数组中取下一个运动（基于 `currentExerciseIndex`）；否则，下一个运动是休息，假设我们不在最后一个运动（`else
    if` 条件检查）。
- en: With this, we are ready to test our implementation. The exercises should flip
    after every 10 or 30 seconds. Great!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们准备测试我们的实现。运动应该在每10或30秒后翻转。太棒了！
- en: The current build setup automatically compiles any changes made to the script
    files when the files are saved; it also refreshes the browser after these changes.
    But just in case the UI does not update or things do not work as expected, refresh
    the browser window. If you are having a problem with running the code, look at
    the Git branch `checkpoint2.1` for a working version of what we have done thus
    far. Or if you are not using Git, download the snapshot of Checkpoint 2.1 (a ZIP
    file) from [http://bit.ly/ng6be-checkpoint2-1](http://bit.ly/ng6be-checkpoint2-1).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的构建设置在保存文件时自动编译对脚本文件的任何更改；它还在这些更改后刷新浏览器。但是，以防UI不更新或事情不如预期那样工作，刷新浏览器窗口。如果您在运行代码时遇到问题，请查看Git分支`checkpoint2.1`，以获取到目前为止我们所做的工作的可工作版本。或者，如果您不使用Git，请从[http://bit.ly/ng6be-checkpoint2-1](http://bit.ly/ng6be-checkpoint2-1)下载Checkpoint
    2.1的快照（ZIP文件）。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: We have done enough work on the component for now, let's build the view.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们已经对组件做了足够的工作，让我们构建视图。
- en: Building the 7 Minute Workout view
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建7分钟锻炼视图
- en: Most of the hard work has already been done while defining the model and implementing
    the component. Now, we just need to skin the HTML using the super-awesome data
    binding capabilities of Angular. It's going to be simple, sweet, and elegant!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义模型和实现组件时，大部分工作已经完成。现在，我们只需要使用Angular的超级数据绑定能力来美化HTML。这将是简单、甜美和优雅的！
- en: 'For the *7 Minute Workout* view, we need to show the exercise name, the exercise
    image, a progress indicator, and the time remaining. Replace the local content
    of the `workout-runner.component.html` file with the content of the file from
    the Git branch `checkpoint2.2`, (or download it from [http://bit.ly/ng6be-2-2-workout-runner-component-html](http://bit.ly/ng6be-2-2-workout-runner-component-html)).
    The view HTML looks as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*7分钟锻炼*视图，我们需要显示锻炼名称、锻炼图片、进度指示器和剩余时间。用来自Git分支`checkpoint2.2`的文件内容替换`workout-runner.component.html`文件的本地内容，（或者从[http://bit.ly/ng6be-2-2-workout-runner-component-html](http://bit.ly/ng6be-2-2-workout-runner-component-html)下载）。视图HTML如下所示：
- en: '[PRE26]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`WorkoutRunnerComponent` currently uses an inline template; instead, we need
    to revert back to using an external template. Update the `workout-runner.component.ts`
    file and get rid of the `template` property, then uncomment `templateUrl`, which
    we commented out earlier.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`目前使用内联模板；相反，我们需要恢复使用外部模板。更新`workout-runner.component.ts`文件，去掉`template`属性，然后取消之前注释掉的`templateUrl`。'
- en: 'Before we understand the Angular pieces in the view, let''s just run the app
    again. Save the changes in `workout-runner.component.html` and if everything went
    fine, we will see the workout app in its full glory:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们理解视图中的Angular部分之前，让我们再次运行应用程序。保存`workout-runner.component.html`中的更改，如果一切顺利，我们将看到完整的锻炼应用程序：
- en: '![](Images/9734dbc5-314b-4653-b332-aea8bcd586e5.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9734dbc5-314b-4653-b332-aea8bcd586e5.png)'
- en: The basic app is now up and running. The exercise image and title show up, the
    progress indicator shows the progress, and exercise transitioning occurs when
    the exercise time lapses. This surely feels great!
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 基本应用程序现在已经启动并运行。锻炼图片和标题显示出来，进度指示器显示进度，并且当锻炼时间结束时，锻炼过渡发生。这确实感觉很棒！
- en: If you are having a problem with running the code, look at the Git branch `checkpoint2.2`
    for a working version of what we have done thus far. You can also download the
    snapshot of `checkpoint2.2` (a ZIP file) from this GitHub location: [http://bit.ly/ng6be-checkpoint-2-2](http://bit.ly/ng6be-checkpoint-2-2)
    . Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在运行代码时遇到问题，请查看Git分支`checkpoint2.2`，以获取迄今为止我们所做的工作的可用版本。您还可以从GitHub位置下载`checkpoint2.2`的快照（ZIP文件）：[http://bit.ly/ng6be-checkpoint-2-2](http://bit.ly/ng6be-checkpoint-2-2)。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: 'Looking at the view HTML, other than some Bootstrap styles, there are some
    interesting Angular pieces that need our attention. Before we dwell on these view
    constructs in detail, let''s break down these elements and provide a quick summary:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 查看视图HTML，除了一些Bootstrap样式之外，还有一些需要我们注意的有趣的Angular片段。在我们详细研究这些视图构造之前，让我们分解这些元素并提供一个快速摘要：
- en: '`<h1 ...>{{currentExercise.exercise.title}}</h1>`: Uses **interpolation**'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<h1 ...>{{currentExercise.exercise.title}}</h1>`：使用**插值**'
- en: '`<img ... [src]="''/assets/images/'' + currentExercise.exercise.image" .../>`:
    Uses **property binding** to bind the `src` property of the image to the component
    model property `currentExercise.exercise.image`'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<img ... [src]="''/assets/images/'' + currentExercise.exercise.image" .../>`：使用**属性绑定**将图像的`src`属性绑定到组件模型属性`currentExercise.exercise.image`'
- en: '`<div ... [attr.aria-valuenow]="exerciseRunningDuration" ... >`: Uses **attribute
    binding** to bind the aria attribute on *div* to `exerciseRunningDuration`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<div ... [attr.aria-valuenow]="exerciseRunningDuration" ... >`：使用**属性绑定**将*div*上的aria属性绑定到`exerciseRunningDuration`'
- en: '`< div ... [ngStyle]="{''width'':(exerciseRunningDuration/currentExercise.duration)
    * 100 + ''%''}">`: Uses a **directive** `ngStyle` to bind the `style` property
    on the progress-bar `div` to an expression that evaluates the exercise progress'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`< div ... [ngStyle]="{''width'':(exerciseRunningDuration/currentExercise.duration)
    * 100 + ''%''}">`：使用**指令**`ngStyle`将进度条`div`上的`style`属性绑定到评估练习进度的表达式'
- en: Phew! There is a lot of binding involved. Let's dig deeper into the binding
    infrastructure.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！涉及了很多绑定。让我们深入了解绑定基础设施。
- en: The Angular binding infrastructure
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular绑定基础设施
- en: Most modern JavaScript frameworks today come with strong model-view binding
    support, and Angular is no different. The primary aim of any binding infrastructure
    is to reduce the boilerplate code that a developer needs to write to keep the
    model and view in sync. A robust binding infrastructure is always declarative
    and terse.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 今天大多数现代JavaScript框架都具有强大的模型-视图绑定支持，Angular也不例外。任何绑定基础设施的主要目标都是减少开发人员需要编写的样板代码，以保持模型和视图的同步。强大的绑定基础设施总是声明性和简洁的。
- en: 'The Angular binding infrastructure allows us to transform template (raw) HTML
    into a live view that is bound to model data. Based on the binding constructs
    used, data can flow and be synced in both directions: from model to view and view
    to model.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Angular绑定基础设施允许我们将模板（原始）HTML转换为绑定到模型数据的实时视图。根据所使用的绑定构造，数据可以在两个方向上流动和同步：从模型到视图，以及从视图到模型。
- en: The link between the component's model and its view is established using the
    `template` or `templateUrl` property of the `@Component` decorator. With the exception
    of the `script` tag, almost any piece of HTML can act as a template for the Angular
    binding infrastructure.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 组件模型与其视图之间的链接是使用`@Component`装饰器的`template`或`templateUrl`属性建立的。除了`script`标签之外，几乎任何HTML片段都可以作为Angular绑定基础设施的模板。
- en: To make this binding magic work, Angular needs to take the view template, compile
    it, link it to the model data, and keep it in sync with model updates without
    the need for any custom boilerplate synchronization code.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这种绑定魔法生效，Angular需要获取视图模板，编译它，将其链接到模型数据，并在不需要任何自定义样板同步代码的情况下保持与模型更新的同步。
- en: 'Based on the data flow direction, these bindings can be of three types:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据流方向，这些绑定可以分为三种类型：
- en: '**One-way binding from model to view**: In model-to-view binding, changes to
    the model are kept in sync with the view. Interpolations, property, attribute,
    class, and style bindings fall in this category.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模型到视图的单向绑定：在模型到视图的绑定中，对模型的更改与视图保持同步。内插、属性、属性、类和样式绑定属于这一类。
- en: '**One-way binding from view to model**: In this category, view changes flow
    towards the model. Event bindings fall in this category.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从视图到模型的单向绑定：在这个类别中，视图更改流向模型。事件绑定属于这一类。
- en: '**Two-way/bidirectional binding**: Two-way binding, as the name suggests, keeps
    the view and model in sync. There is a special binding construct used for two-way
    binding, `ngModel`, and some standard HTML data entry elements such as `input`
    and `select` support two-way binding.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向绑定：双向绑定保持视图和模型同步。有一个特殊的绑定构造用于双向绑定，`ngModel`，一些标准的HTML数据输入元素，如`input`和`select`支持双向绑定。
- en: 'Let''s understand how to utilize the binding capabilities of Angular to support
    view templatization. Angular provides these binding constructs:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解如何利用Angular的绑定能力来支持视图模板化。Angular提供了这些绑定构造：
- en: Interpolations
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内插
- en: Property binding
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性绑定
- en: Attribute binding
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性绑定
- en: Class binding
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类绑定
- en: Style binding
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式绑定
- en: Event binding
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件绑定
- en: This is a good time to learn about all these binding constructs. **Interpolation**
    is the first one.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是学习所有这些绑定构造的好时机。**内插**是第一个。
- en: Interpolations
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内插
- en: '**Interpolations** are quite simple. The expression (commonly known as a **template
    expression**) inside the interpolation symbols (`{{ }}`) is evaluated in the context
    of the model (or the component class members), and the outcome of the evaluation
    (string) is embedded in HTML. A handy framework construct to display a component''s
    data/properties. We render the exercise title and the exercise time remaining
    using interpolation:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 内插非常简单。内插符号（`{{ }}`）内的表达式（通常称为**模板表达式**）在模型的上下文中进行评估，评估结果（字符串）嵌入到HTML中。这是一个方便的框架构造，用于显示组件的数据/属性。我们使用内插来呈现练习标题和剩余练习时间：
- en: '[PRE27]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Remember that interpolations synchronize model changes with the view. Interpolation
    is one way of binding from a model to a view.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，内插将模型更改与视图同步。内插是从模型到视图的一种绑定方式。
- en: View bindings in Angular are always evaluated in the context of the component's
    scope.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，视图绑定始终在组件范围的上下文中进行评估。
- en: Interpolations, in fact, are a special case of property binding, which allows
    us to bind any HTML element/component properties to a model. We will shortly discuss
    how an interpolation can be written using property binding syntax. Consider interpolation
    as syntactical sugar over property binding.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，内插是属性绑定的一种特殊情况，它允许我们将任何HTML元素/组件属性绑定到模型。我们将很快讨论如何使用属性绑定语法编写内插。将内插视为属性绑定的语法糖。
- en: Property binding
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性绑定
- en: Property bindings allow us to bind native HTML/component properties to the component's
    model and keep them in sync (from model->view). Let's look at property binding
    from a different context.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定允许我们将本机HTML/组件属性绑定到组件的模型并保持它们同步（从模型->视图）。让我们从不同的上下文来看属性绑定。
- en: 'Look at this view excerpt from the 7 Minute Workout''s component view (`workout-runner.component.html`):'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下来自7分钟锻炼组件视图（`workout-runner.component.html`）的这个视图摘录：
- en: '[PRE28]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It seems that we are setting the `src` attribute of `img` to an expression that
    gets evaluated at runtime. But are we really binding to an attribute? Or is this
    a property? Are properties and attributes different?
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们正在将`img`的`src`属性设置为在运行时评估的表达式。但我们真的在绑定到一个属性吗？还是这是一个属性？属性和属性有什么不同？
- en: In Angular realms, while the preceding syntax looks like it is setting an HTML
    element's attribute, it is, in fact, doing **property binding**. Moreover, since
    many of us are not aware of the difference between an HTML element's properties
    and its attributes, this statement is very confusing. Therefore, before we look
    at how property bindings work, let's try to grasp the difference between an element's
    property and its attribute.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular领域中，虽然前面的语法看起来像是设置HTML元素的属性，实际上是在进行**属性绑定**。此外，由于我们许多人并不了解HTML元素的属性和属性之间的区别，这个语句非常令人困惑。因此，在我们了解属性绑定的工作原理之前，让我们试着理解一下元素的属性和属性之间的区别。
- en: Property versus attribute
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性与属性之间的区别
- en: 'Take any DOM element API and you will find attributes, properties, functions,
    and events. While events and functions are self-explanatory, it is difficult to
    understand the difference between properties and attributes. In daily use, we
    use these words interchangeably, which does not help much either. Take, for example,
    this line of code:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 获取任何DOM元素API，你会发现属性、属性、函数和事件。虽然事件和函数是不言自明的，但很难理解属性和属性之间的区别。在日常使用中，我们经常互换使用这些词，这也没有帮助。例如，这行代码：
- en: '[PRE29]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When the browser creates a DOM element (`HTMLInputElement` to be precise) for
    this input textbox, it uses the `value` attribute on `input` to set the initial
    state of the  `value` property of `input` to `Awesome Angular`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器为这个输入文本框创建一个DOM元素（确切地说是`HTMLInputElement`）时，它使用`input`上的`value`属性来设置`input`的`value`属性的初始状态为`Awesome
    Angular`。
- en: After this initialization, any changes to the `value` property of `input` do
    not reflect on the `value` attribute; the attribute always has `Awesome Angular`
    (unless set explicitly again). This can be confirmed by querying the `input` state.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化后，对`input`的`value`属性的任何更改都不会反映在`value`属性上；属性始终是`Awesome Angular`（除非再次明确设置）。这可以通过查询`input`的状态来确认。
- en: 'Suppose we change the `input` data to `Angular rocks!` and query the `input`
    element state:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将`input`数据更改为`Angular rocks!`并查询`input`元素的状态：
- en: '[PRE30]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `value` property always returns the current input content, which is `Angular
    rocks!`. Whereas this DOM API function:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`value`属性始终返回当前的输入内容，即`Angular rocks!`。而这个DOM API函数：'
- en: '[PRE31]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Returns the `value` attribute, and is always the `Awesome Angular` that was
    set initially.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`value`属性，并且始终是最初设置的`Awesome Angular`。
- en: The primary role of an element attribute is to initialize the state of the element
    when the corresponding DOM object is created.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 元素属性的主要作用是在创建相应的DOM对象时初始化元素的状态。
- en: 'There are a number of other nuances that add to this confusion. These include
    the following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他细微差别增加了这种混淆。其中包括以下内容：
- en: Attribute and property synchronization is not consistent across properties.
    As we saw in the preceding example, changes to the `value` property on `input`
    do not affect the `value` attribute, but this is not true for all property-value
    pairs. The `src` property of an image element is a prime example of this; changes
    to property or attribute values are always kept in sync.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性和属性之间的同步在不同属性之间并不一致。正如我们在前面的例子中看到的，对`input`的`value`属性的更改不会影响`value`属性，但对于所有属性-值对来说并非如此。图像元素的`src`属性就是一个很好的例子；对属性或属性值的更改始终保持同步。
- en: It's surprising to learn that the mapping between attributes and properties
    is also not one-to-one. There are a number of properties that do not have any
    backing attribute (such as `innerHTML`), and there are also attributes that do
    not have a corresponding property defined on the DOM (such as `colspan`).
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令人惊讶的是，属性和属性之间的映射也不是一对一的。有许多属性没有任何支持属性（例如`innerHTML`），也有一些属性在DOM上没有相应的属性定义（例如`colspan`）。
- en: 'Attribute and property mapping adds to this confusion too, as they do not follow
    a consistent pattern. An excellent example of this is available in the Angular
    developer''s guide, which we are going to reproduce here verbatim:'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性和属性映射也增加了这种混乱，因为它们没有遵循一致的模式。一个很好的例子可以在Angular开发者指南中找到，我们将在这里逐字重现：
- en: The `disabled` attribute is another peculiar example. A button's `disabled`
    property is `false` by default so the button is enabled. When we add the disabled
    attribute, its presence alone initializes the button's `disabled` property to
    `true` so the button is disabled. Adding and removing the disabled attribute disables
    and enables the button. The value of the attribute is irrelevant, which is why
    we cannot enable a button by writing `<button disabled="false">Still Disabled</button>`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`disabled`属性是另一个特殊的例子。按钮的`disabled`属性默认为`false`，因此按钮是启用的。当我们添加disabled属性时，仅其存在就会将按钮的`disabled`属性初始化为`true`，因此按钮被禁用。添加和移除disabled属性会禁用和启用按钮。属性的值是无关紧要的，这就是为什么我们不能通过编写`<button
    disabled="false">Still Disabled</button>`来启用按钮。'
- en: The aim of this discussion is to make sure that we understand the difference
    between the properties and attributes of a DOM element. This new mental model
    will help us as we continue to explore the framework's property and attribute
    binding capabilities. Let's get back to our discussion on property binding.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 本次讨论的目的是确保我们理解DOM元素的属性和属性的区别。这种新的思维模式将有助于我们继续探索框架的属性和属性绑定能力。让我们回到我们对属性绑定的讨论。
- en: Property binding continued...
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性绑定继续...
- en: 'Now that we understand the difference between a property and an attribute,
    let''s look at the binding example again:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了属性和属性之间的区别，让我们再次看一下绑定的例子：
- en: '[PRE32]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `[propertName]` square bracket syntax is used to bind the `img.src` property
    to an Angular expression.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`[propertName]`方括号语法用于将`img.src`属性绑定到Angular表达式。'
- en: 'The general syntax for property binding looks as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定的一般语法如下：
- en: '[PRE33]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the case of property binding, the `target` is a property on the DOM element
    or component. With property binding, we can literally bind to any property on
    the element's DOM. The `src` property on the `img` element is what we use; this
    binding works for any HTML element and every property on it.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性绑定的情况下，“目标”是DOM元素或组件上的属性。通过属性绑定，我们可以绑定到元素DOM上的任何属性。`img`元素上的`src`属性是我们使用的；这种绑定适用于任何HTML元素及其上的每个属性。
- en: Expression target can also be an event, as we will see shortly when we explore
    event binding.Binding source and targetIt is important to understand the difference
    between source and target in an Angular binding. The property appearing inside
    `[]` is a target, sometimes called **binding target**. The target is the consumer
    of the data and always refers to a property on the component/element. The **source**
    expression constitutes the data source that provides data to the target.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式目标也可以是一个事件，我们将很快看到这一点，当我们探索事件绑定时。绑定源和目标重要的是要理解Angular绑定中源和目标之间的区别。出现在`[]`内的属性是目标，有时被称为**绑定目标**。目标是数据的消费者，并且始终指的是组件/元素上的属性。**源**表达式构成提供数据给目标的数据源。
- en: At runtime, the expression is evaluated in the context of the component's/element's
    property (the `WorkoutRunnerComponent.currentExercise.exercise.image` property
    in the preceding case).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，表达式在组件/元素属性的上下文中进行评估（在前面的情况下是`WorkoutRunnerComponent.currentExercise.exercise.image`属性）。
- en: Always remember to add square brackets `[]` around the target. If we don't,
    Angular treats the expression as a string constant and the target is simply assigned
    the string value.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 始终记得在目标周围添加方括号`[]`。如果不这样做，Angular会将表达式视为字符串常量，目标只是被赋予字符串值。
- en: 'Property binding, event binding, and attribute binding do not use the interpolation
    symbol. The following is invalid: `[src]="{{''/static/images/'' + currentExercise.exercise.image}}".`If
    you have worked on AngularJS, property binding together with event binding allows
    Angular to get rid of a number of directives, such as `ng-disable`, `ng-src`,
    `ng-key*`, `ng-mouse*`, and a few others.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定、事件绑定和属性绑定不使用插值符号。以下是无效的：`[src]="{{'/static/images/' + currentExercise.exercise.image}}"`。如果您曾经使用过AngularJS，属性绑定和事件绑定允许Angular摆脱许多指令，比如`ng-disable`、`ng-src`、`ng-key*`、`ng-mouse*`等等。
- en: 'From a data binding perspective, Angular treats components in the same way
    as it treats native elements. Hence, property binding works on component properties
    too! Components can define **input** and **output properties** that can be bound
    to the view, such as this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据绑定的角度来看，Angular对待组件的方式与对待原生元素的方式相同。因此，属性绑定也适用于组件属性！组件可以定义**输入**和**输出属性**，这些属性可以绑定到视图，就像这样：
- en: '[PRE34]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This hypothetical snippet binds the `exerciseRestDuration` property on the `WorkoutRunnerComponent`
    class to the `restDuration` property defined on the container component (parent),
    allowing us to pass the rest duration as a parameter to the `WorkoutRunnerComponent`.
    As we enhance our app and develop new components, you will learn how to define
    custom properties and events on a component.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这个假设的片段将`WorkoutRunnerComponent`类上的`exerciseRestDuration`属性绑定到容器组件（父组件）上定义的`restDuration`属性，允许我们将休息时间作为参数传递给`WorkoutRunnerComponent`。随着我们增强应用程序并开发新组件，您将学习如何在组件上定义自定义属性和事件。
- en: 'We can enable property binding using the `bind-` syntax, which is a canonical
    form of property binding. This implies that `[src]="''/assets/images/'' + currentExercise.exercise.image"` is
    equivalent to the following: `bind-src="''/static/images/'' + currentExercise.exercise.image"`.Property
    binding, like interpolation, is unidirectional, from the component/element source
    to the view. Changes to the model data are kept in sync with the view.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`bind-`语法启用属性绑定，这是属性绑定的规范形式。这意味着`[src]="'/assets/images/' + currentExercise.exercise.image"`等同于以下内容：`bind-src="'/static/images/'
    + currentExercise.exercise.image"`。属性绑定，就像插值一样，是单向的，从组件/元素源到视图。对模型数据的更改与视图保持同步。
- en: The template view that we just created has only one property binding (on `[src]`).
    The other bindings with square brackets aren't property bindings. We will cover
    them shortly.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的模板视图只有一个属性绑定（在`[src]`上）。带方括号的其他绑定不是属性绑定。我们将很快介绍它们。
- en: Interpolation syntactic sugar over property binding
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插值是属性绑定的语法糖
- en: 'We concluded the section on interpolations by describing interpolation as syntactical
    sugar over property binding. The intent was to highlight how both can be used
    interchangeably. The interpolation syntax is terser than property binding and
    hence is very useful. This is how Angular interprets an interpolation:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过描述插值为属性绑定的语法糖来结束了插值部分。意图是强调两者可以互换使用。插值语法比属性绑定更简洁，因此非常有用。这就是Angular解释插值的方式：
- en: '[PRE35]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Angular translates the interpolation in the first statement into the `textContent`
    property binding (second statement).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Angular将第一个语句中的插值转换为`textContent`属性绑定（第二个语句）。
- en: 'Interpolation can be used in more places than you can imagine. The following
    example contrasts the same binding using interpolation and property binding:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 插值可以用在比你想象的更多的地方。以下示例对比了使用插值和属性绑定的相同绑定：
- en: '[PRE36]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: While property binding (and interpolations) makes it easy for us to bind any
    expression to the target property, we should be careful with the expression we
    use. Angular's change detection system will evaluate your expression binding multiple
    times during the life cycle of the application, as long as our component is alive.
    Therefore, while binding an expression to a property target, keep these two guidelines
    in mind.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然属性绑定（和插值）使我们能够将任何表达式绑定到目标属性，但我们应该小心使用表达式。只要我们的组件还活着，Angular的变更检测系统就会在应用程序的生命周期中多次评估您的表达式绑定。因此，在将表达式绑定到属性目标时，请牢记这两个准则。
- en: Quick expression evaluation
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速表达式评估
- en: 'A property binding expression should evaluate quickly. Slow expression evaluation
    can kill your app''s performance. This happens when a function performing CPU
    intensive work is part of an expression. Consider this binding:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定表达式应该快速评估。慢速表达式评估会影响应用的性能。当执行CPU密集型工作的函数是表达式的一部分时就会发生这种情况。考虑以下绑定：
- en: '[PRE37]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Angular will evaluate the preceding `doLotsOfWork()` expression every time it
    performs a change detection run. These change detection runs happen more often
    than we imagine and are based on some internal heuristics, so it becomes imperative
    that the expressions we use evaluate quickly.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: Angular将在每次执行变更检测时评估前面的`doLotsOfWork()`表达式。这些变更检测运行的频率比我们想象的要高，并且基于一些内部启发式算法，因此我们使用的表达式应该快速评估。
- en: Side effect-free binding expressions
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无副作用的绑定表达式
- en: 'If a function is used in a binding expression, it should be side effect-free.
    Consider yet another binding:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在绑定表达式中使用了一个函数，它应该是无副作用的。再考虑一个绑定：
- en: '[PRE38]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And the underlying function, `getContent`:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 并且底层函数`getContent`：
- en: '[PRE39]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `getContent` call changes the state of the component by updating the `timesContentRequested`
    property every time it is called. If this property is used in views such as:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`getContent`调用通过更新`timesContentRequested`属性改变了组件的状态，每次调用时都会这样。如果这个属性在视图中被使用，比如：'
- en: '[PRE40]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Angular throws errors such as:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: Angular会抛出诸如：
- en: '[PRE41]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The Angular framework works in two modes, dev and production. If we enable production
    mode in the application, the preceding error does not show up. Look at the framework
    documentation at [http://bit.ly/enableProdMode](http://bit.ly/enableProdMode)
    for more details.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Angular框架有两种模式，开发模式和生产模式。如果我们在应用中启用生产模式，上述错误就不会出现。请查看框架文档[http://bit.ly/enableProdMode](http://bit.ly/enableProdMode)了解更多详情。
- en: The bottom line is that your expression used inside property binding should
    be side effect-free.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，在属性绑定中使用的表达式应该是无副作用的。
- en: Let's now look at something interesting, `[ngStyle]`, which looks like a property
    binding, but it's not. The target specified in `[]` is not a component/element
    property (`div` does not have an `ngStyle` property), it's a directive.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一些有趣的东西，`[ngStyle]`，看起来像是属性绑定，但实际上不是。在`[]`中指定的目标不是组件/元素属性（`div`没有`ngStyle`属性），而是一个指令。
- en: Two new concepts need to be introduced, **target selection** and **directives**.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 需要介绍两个新概念，**目标选择**和**指令**。
- en: Angular directives
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular指令
- en: 'As a framework, Angular tries to enhance the HTML **DSL** (short for **Domain-Specific
    Language**):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个框架，Angular试图增强HTML的**DSL**（特定领域语言）：
- en: Components are referenced in HTML using custom tags such as `<abe-workout-runner></abe-workout-runner>`
    (not part of standard HTML constructs). This highlights the first extension point.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件在HTML中使用自定义标签引用，例如`<abe-workout-runner></abe-workout-runner>`（不是标准HTML构造的一部分）。这突显了第一个扩展点。
- en: The use of `[]` and `()` for property and event binding defines the second.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`[]`和`()`进行属性和事件绑定定义了第二个。
- en: And then there are **directives**, the third extension point which are further
    classified into **attribute** and **structural directives**, and **components**
    (components are directive too!).
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后还有**指令**，第三个扩展点，进一步分类为**属性**和**结构指令**，以及**组件**（组件也是指令！）。
- en: While components come with their own view, attribute directives are there to
    enhance the appearance and/or behavior of existing elements/components.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然组件自带其自己的视图，但属性指令用于增强现有元素/组件的外观和/或行为。
- en: Structural directives do not have their own view too; they change the DOM layout
    of the elements on which they are applied. We will dedicate a complete section
    later in the chapter to understanding these structural directives.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 结构指令也没有自己的视图；它们改变应用的元素的DOM布局。我们将在本章的后面专门讨论这些结构指令。
- en: 'The `ngStyle` directive used in the `workout-runner` view is, in fact, an attribute
    directive:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在`workout-runner`视图中使用的`ngStyle`指令实际上是一个属性指令：
- en: '[PRE42]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `ngStyle` directive does not have its own view; instead, it allows us to
    set multiple styles (`width` in this case) on an HTML element using binding expressions.
    We will be covering a number of framework attribute directives later in this book.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngStyle`指令没有自己的视图；相反，它允许我们使用绑定表达式在HTML元素上设置多个样式（在这种情况下是`width`）。我们将在本书的后面涵盖许多框架属性指令。'
- en: Directive nomenclature
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 指令命名
- en: Directives is an umbrella term used for component directives (also known as
    components), attribute directives, and structural directives. Throughout the book,
    when we use the term directive, we will be referring to either an attribute directive
    or a structural directive depending on the context. Component directives are always
    referred to as components.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 指令是一个用于组件指令（也称为组件）、属性指令和结构指令的总称。在本书中，当我们使用术语指令时，根据上下文，我们将指的是属性指令或结构指令。组件指令总是被称为组件。
- en: With a basic understanding of the directive types that Angular has, we can comprehend
    the process of target selection for binding.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 具有对Angular的指令类型的基本理解后，我们可以理解绑定的目标选择过程。
- en: Target selection for binding
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定的目标选择
- en: 'The target specified in `[]` is not limited to a component/element property.
    While the property name is a common target, the Angular templating engine actually
    does heuristics to decide the target type. Angular first searches the registered
    known directives (attribute or structural) that have matching selectors before
    looking for a property that matches the target expression. Consider this view
    fragment:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在`[]`中指定的目标不仅限于组件/元素属性。虽然属性名是一个常见的目标，但Angular模板引擎实际上会根据启发式规则来决定目标类型。在寻找与目标表达式匹配的已注册的已知指令（属性或结构）之前，Angular首先搜索已知的指令（属性或结构）来决定目标类型。考虑这个视图片段：
- en: '[PRE43]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The search for a target starts with a framework looking at all internal and
    custom directives with a matching selector (`ngStyle`). Since Angular already
    has an `NgStyle` directive, it becomes the target (the directive class name is
    `NgStyle`, whereas the selector is `ngStyle`). If Angular did not have a built-in
    `NgStyle` directive, the binding engine would have looked for a property called
    `ngStyle` on the underlying component.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索目标始于框架查看所有具有匹配选择器（`ngStyle`）的内部和自定义指令。由于Angular已经有了`NgStyle`指令，它成为了目标（指令类名是`NgStyle`，而选择器是`ngStyle`）。如果Angular没有内置的`NgStyle`指令，绑定引擎将会在底层组件上查找名为`ngStyle`的属性。
- en: If nothing matches the target expression, an unknown directive error is thrown*.*
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有匹配目标表达式，将抛出未知指令错误*。*
- en: That completes our discussion on target selection. The next section is about
    attribute binding.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对目标选择的讨论。下一节是关于属性绑定。
- en: Attribute binding
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性绑定
- en: The only reason attribute binding exists in Angular is that there are HTML attributes
    that do not have a backing DOM property. The `colspan` and `aria` attributes are
    some good examples of attributes without backing properties. The progress bar
    div in our view uses attribute binding.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中存在属性绑定的唯一原因是有一些HTML属性没有对应的DOM属性。`colspan`和`aria`属性就是一些没有对应属性的很好的例子。我们视图中的进度条div使用了属性绑定。
- en: If attribute directives are still playing your head, I cannot blame you, it
    can become a bit confusing. Fundamentally, they are different. Attribute directives
    (such as `[ngStyle]`) change the appearance or behavior of DOM elements and as
    the name suggests are directives. There is no attribute or property named `ngStyle`
    on any HTML element. Attribute binding, on the other hand, is all about binding
    to HTML attributes that do not have backing for a DOM property.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性指令仍然让你头疼，我也不怪你，这可能会变得有点混乱。从根本上讲，它们是不同的。属性指令（如`[ngStyle]`）改变DOM元素的外观或行为，正如其名称所示，它们是指令。在任何HTML元素上都没有名为`ngStyle`的属性或属性。另一方面，属性绑定是关于绑定到没有DOM属性支持的HTML属性。
- en: 'The *7 Minute Workout* uses attribute binding at two places, `[attr.aria-valuenow]`
    and `[attr.aria-valuemax]`. We may ask a question: can we use standard interpolation
    syntax to set an attribute? No, that does not work! Let''s try it: open `workout-runner.component.html`
    and replace the two aria attributes `attr.aria-valuenow` and `attr.aria-valuemax`
    enclosed in `[]` with this highlighted code:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '*7分钟锻炼*在两个地方使用了属性绑定，`[attr.aria-valuenow]`和`[attr.aria-valuemax]`。我们可能会问一个问题：我们可以使用标准的插值语法来设置属性吗？不，那行不通！让我们试试：打开`workout-runner.component.html`，并用这个突出显示的代码替换两个aria属性`attr.aria-valuenow`和`attr.aria-valuemax`中的`[]`：'
- en: '[PRE44]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Save the view and if the app is not running, run it. This error will pop up
    in the browser console:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 保存视图，如果应用程序没有运行，请运行它。这个错误将在浏览器控制台中弹出：
- en: '[PRE45]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Angular is trying to search for a property called `ariaValuenow` in the `div`
    that does not exist! Remember, interpolations are actually property bindings.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Angular正在尝试在`div`中搜索名为`ariaValuenow`的属性，但这个属性并不存在！记住，插值实际上是属性绑定。
- en: 'We hope that this gets the point across: to bind to an HTML attribute, use
    attribute binding.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这一点能够得到解释：要绑定到HTML属性，请使用属性绑定。
- en: Angular binds to properties by default and not to attributes.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Angular默认绑定到属性而不是属性。
- en: 'To support attribute binding, Angular uses a prefix notation, `attr`, within
    `[]`. An attribute binding looks as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持属性绑定，Angular在`[]`内使用前缀表示法`attr`。属性绑定如下所示：
- en: '[PRE46]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Revert to the original aria setup to make attribute binding work:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复原始的aria设置以使属性绑定工作：
- en: '[PRE47]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Remember that unless an explicit `attr.` prefix is attached, attribute binding
    does not work.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，除非附加了显式的`attr.`前缀，否则属性绑定不起作用。
- en: While we have not used style and class-based binding in our workout view, these
    are some binding capabilities that can come in handy. Hence, they are worth exploring.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在锻炼视图中没有使用样式和基于类的绑定，但这些是一些有用的绑定能力。因此，值得探索。
- en: Style and class binding
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式和类绑定
- en: 'We use **class binding** to set and remove a specific class based on the component
    state, as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**类绑定**根据组件状态设置和移除特定类，如下所示：
- en: '[PRE48]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This adds `class-name` when `expression` is `true` and removes it when it is
    `false`. A simple example can look as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 当`expression`为`true`时，添加`class-name`，当为`false`时移除。一个简单的例子可以如下所示：
- en: '[PRE49]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Use style bindings to set inline styles based on the component state:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 使用样式绑定根据组件状态设置内联样式：
- en: '[PRE50]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'While we have used the `ngStyle` directive for the workout view, we could have
    easily used style binding as well, as we are dealing with a single style. With
    style binding, the same `ngStyle` expression would become the following:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在锻炼视图中使用了`ngStyle`指令，但我们也可以使用样式绑定，因为我们处理的是单个样式。使用样式绑定，相同的`ngStyle`表达式将变成以下内容：
- en: '[PRE51]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`width` is a style, and since it takes units too, we extend our target expression
    to include the `%` symbol.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`width`是一种样式，因为它也需要单位，所以我们将目标表达式扩展为包括`%`符号。'
- en: 'Remember that `style.` and `class.` are convenient bindings for setting a single
    class or style. For more flexibility, there are corresponding attribute directives:
    `ngClass` and `ngStyle`.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`style.`和`class.`是设置单个类或样式的便捷绑定。为了更灵活，还有相应的属性指令：`ngClass`和`ngStyle`。
- en: Earlier in the chapter, we formally introduced directives and their classifications.
    One of the directives types, attribute directives (again, don't confuse them with
    attribute binding, which we introduced in the preceding section) are the focus
    of our attention in the next section.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们正式介绍了指令及其分类。其中一种指令类型，属性指令（不要将它们与我们在前一节介绍的属性绑定混淆），是我们下一节关注的焦点。
- en: Attribute directives
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性指令
- en: Attribute directives are HTML extensions that change the look, feel or behavior
    of a component/element. As described in the section on Angular directives, these
    directives do not define their own view.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 属性指令是改变组件/元素外观、感觉或行为的HTML扩展。正如在Angular指令部分所述，这些指令不定义自己的视图。
- en: Other than `ngStyle` and `ngClass` directives, there are a few more attribute
    directives that are part of the core framework. `ngValue`, `ngModel`, `ngSelectOptions`,
    `ngControl`, and `ngFormControl` are some of the attribute directives that Angular
    provides.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`ngStyle`和`ngClass`指令，还有一些核心框架的属性指令。`ngValue`，`ngModel`，`ngSelectOptions`，`ngControl`和`ngFormControl`是Angular提供的一些属性指令。
- en: Since *7 Minute Workout* uses the `ngStyle` directive, it would be wise to dwell
    more on this directive and its close associate `ngClass`.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*7分钟锻炼*使用了`ngStyle`指令，因此更多地停留在这个指令及其密切相关的`ngClass`上是明智的。
- en: While the next section is dedicated to learning how to use the `ngClass` and
    `ngStyle` attribute directives, it is not until [Chapter 4](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml),
    *Angular Directives in Depth*, that we learn how to create our own attribute directives.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将专门学习如何使用`ngClass`和`ngStyle`属性指令，但直到[第4章](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml)，*深入理解Angular指令*，我们才学习如何创建自己的属性指令。
- en: Styling HTML with ngClass and ngStyle
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ngClass和ngStyle为HTML设置样式
- en: 'Angular has two excellent directives that allow us to dynamically set styles
    on any element and toggle CSS classes. For the bootstrap progress bar, we use
    the `ngStyle` directive to dynamically set the element''s style, `width`, as the
    exercise progresses:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: Angular有两个优秀的指令，允许我们动态设置任何元素的样式并切换CSS类。对于Bootstrap进度条，我们使用`ngStyle`指令动态设置元素的样式`width`，随着练习的进行：
- en: '[PRE52]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`ngStyle` allows us to bind one or more styles to a component''s properties
    at once. It takes an object as a parameter. Each property name on the object is
    the style name, and the value is the Angular expression bound to that property,
    such as the following example:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngStyle`允许我们一次绑定一个或多个样式到组件的属性。它以对象作为参数。对象上的每个属性名称都是样式名称，值是绑定到该属性的Angular表达式，例如以下示例：'
- en: '[PRE53]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The styles can not only bind to component properties (`componentWidth` and `componentHeight`),
    but also be set to a constant value (`'larger'`). The expression parser also allows
    the use of the ternary operator (`?:`); check out `isRequired`.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 样式不仅可以绑定到组件属性（`componentWidth`和`componentHeight`），还可以设置为常量值（`'larger'`）。表达式解析器还允许使用三元运算符（`?:`）；查看`isRequired`。
- en: 'If styles become too unwieldy in HTML, we also have the option of writing in
    our component a function that returns the object hash, and setting that as an
    expression:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在HTML中样式变得过于笨重，我们还可以选择在我们的组件中编写一个返回对象哈希的函数，并将其设置为一个表达式：
- en: '[PRE54]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Moreover, `getStyles` on the component looks as follows:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，组件上的`getStyles`如下所示：
- en: '[PRE55]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`ngClass` works on the same lines too, except that it is used to toggle one
    or multiple classes. For example, check out the following code:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngClass`也是如此，只是它用于切换一个或多个类。例如，查看以下代码：'
- en: '[PRE56]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `required` class is applied when `inputRequired` is `true` and is removed
    when it evaluates to `false`.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 当`inputRequired`为`true`时，应用`required`类，并在其评估为`false`时移除。
- en: Directives (custom or platform) like any other Angular artifact, always belong
    to a module. To use them across modules, the module needs to be imported. Wondering
    where `ngStyle` is defined? `ngStyle` is part of the core framework module, `CommonModule,`,
    and has been imported in the workout runner module definition (`workout-runner.module.ts`).
    `CommonModule` defines a number of handy directives that are used across Angular.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 指令（自定义或平台）像任何其他Angular构件一样，总是属于一个模块。要在模块之间使用它们，需要导入该模块。想知道`ngStyle`是在哪里定义的吗？`ngStyle`是核心框架模块`CommonModule`的一部分，并已在锻炼运行器模块定义（`workout-runner.module.ts`）中导入。`CommonModule`定义了许多方便的指令，这些指令在Angular中被广泛使用。
- en: Well! That covers everything we had to learn about our newly developed view.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！这涵盖了我们需要了解的关于我们新开发的视图的一切。
- en: And as described earlier, if you are having a problem with running the code,
    look at the Git branch `checkpoint2.2`. If not using Git, download the snapshot
    of `checkpoint2.2` (a ZIP file) from [http://bit.ly/ng2be-checkpoint2-2](http://bit.ly/ng2be-checkpoint2-2).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所描述的，如果您在运行代码时遇到问题，请查看Git分支`checkpoint2.2`。如果不使用Git，请从[http://bit.ly/ng2be-checkpoint2-2](http://bit.ly/ng2be-checkpoint2-2)下载`checkpoint2.2`的快照（ZIP文件）。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Time to add some enhancements and learn a bit more about the framework!
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加一些增强功能并更多地了解框架了！
- en: Learning more about an exercise
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多了解一项锻炼
- en: For people who are doing this workout for the first time, it will be good to
    detail the steps involved in each exercise. We can also add references to some
    YouTube videos for each exercise to help the user understand the exercise better.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一次进行这项锻炼的人来说，详细说明每个练习涉及的步骤将是有益的。我们还可以为每个练习添加一些YouTube视频的参考，以帮助用户更好地理解练习。
- en: We are going to add the exercise description and instructions in the left panel
    and call it the **description panel**. We will also add references to YouTube
    videos in the right panel, which is the video player panel. To make things more
    modular and learn some new concepts, we are going to create independent components
    for each description panel and video panel.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在左侧面板中添加练习描述和说明，并称其为**描述面板**。我们还将在右侧面板中添加对YouTube视频的引用，这是视频播放器面板。为了使事情更模块化并学习一些新概念，我们将为每个描述面板和视频面板创建独立的组件。
- en: The model data for this is already available. The `description` and `procedure`
    properties in the `Exercise` class (see `model.ts`) provide the necessary details
    about the exercise. The `videos` array contains some related YouTube video IDs,
    which will be used to fetch these videos.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型数据已经可用。`Exercise`类（参见`model.ts`）中的`description`和`procedure`属性提供了有关练习的必要细节。`videos`数组包含一些相关的YouTube视频ID，将用于获取这些视频。
- en: Adding descriptions and video panels
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加描述和视频面板
- en: 'An Angular app is nothing but a hierarchy of components, similar to a tree
    structure. As of now, *7 Minute Workout* has two components, the root component,
    `AppComponent`, and its child, `WorkoutRunnerComponent`, in line with the HTML
    component layout, which now looks as follows:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: Angular应用程序只是一个组件层次结构，类似于树结构。目前为止，“7分钟锻炼”有两个组件，根组件`AppComponent`和其子组件`WorkoutRunnerComponent`，与HTML组件布局一致，现在看起来如下：
- en: '[PRE57]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Run the app and do a view source to verify this hierarchy. As we all more components
    to implement new features in the application this component tree grows and branches
    out.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并查看源代码以验证此层次结构。随着我们在应用程序中添加更多组件来实现新功能，这个组件树会不断增长和分支。
- en: We are going to add two subcomponents to `WorkoutRunnerComponent`, one each
    to support the exercise description and exercise videos. While we could have added
    some HTML directly to the `WorkoutRunnerComponent` view, what we are hoping here
    is to learn a bit more about cross-component communication. Let's start with adding
    the description panel on the left and understand how a component can accept inputs.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向`WorkoutRunnerComponent`添加两个子组件，一个用于支持练习描述，另一个用于练习视频。虽然我们可以直接向`WorkoutRunnerComponent`视图添加一些HTML，但我们希望在这里学习更多关于跨组件通信的知识。让我们从在左侧添加描述面板开始，并了解组件如何接受输入。
- en: Component with inputs
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有输入的组件
- en: 'Navigate to the `workour-runner` folder and generate a boilerplate exercise
    description component:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`workour-runner`文件夹并生成一个样板练习描述组件：
- en: '[PRE58]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To the generated `exercise-description.component.ts` file, add the highlighted
    code:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的`exercise-description.component.ts`文件中添加突出显示的代码：
- en: '[PRE59]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `@Input` decorator signifies that the component property is available for
    data binding. Before we dig into the `@Input` decorator, let's complete the view
    and integrate it with `WorkoutRunnerComponent`.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Input`装饰器表示组件属性可用于数据绑定。在我们深入研究`@Input`装饰器之前，让我们完成视图并将其与`WorkoutRunnerComponent`集成。'
- en: 'Copy the view definition for exercise description, `exercise-description.component.html`,
    from the Git branch `checkpoint2.3`, in the `workout-runner/exercise-description` folder.
    Look at the highlighted HTML for the exercise description:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 从Git分支`checkpoint2.3`的`workout-runner/exercise-description`文件夹中复制练习描述的视图定义`exercise-description.component.html`。查看练习描述的突出显示的HTML：
- en: '[PRE60]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The preceding interpolation references the input properties of `ExerciseDescriptionComponent`:
    `description` and `steps`.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的插值引用了`ExerciseDescriptionComponent`的输入属性：`description`和`steps`。
- en: The component definition is complete. Now, we just need to reference `ExerciseDescriptionComponent`
    in `WorkoutRunnerComponent` and provide values for `description` and `steps` for
    the `ExerciseDescriptionComponent` view to render correctly.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 组件定义完成。现在，我们只需要在 `WorkoutRunnerComponent` 中引用 `ExerciseDescriptionComponent`
    并为 `ExerciseDescriptionComponent` 的视图提供 `description` 和 `steps` 的值，以便正确渲染。
- en: 'Open `workout-runner.component.html` and update the HTML fragments as highlighted
    in the following code. Add a new div called `description-panel` before the `exercise-pane`
    div and adjust some styles on the `exercise-pane` div, as follows:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `workout-runner.component.html` 并按照以下代码中的突出显示的部分更新 HTML 片段。在 `exercise-pane`
    div 之前添加一个名为 `description-panel` 的新 div，并调整 `exercise-pane` div 上的一些样式，如下所示：
- en: '[PRE61]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If the app is running, the description panel should show up on the left with
    the relevant exercise details.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用正在运行，描述面板应该会显示在左侧，并显示相关的锻炼细节。
- en: '`WorkoutRunnerComponent` was able to use `ExerciseDescriptionComponent` because
    it has been declared on `WorkoutRunnerModule` (see the `workout-runner.module.ts` declaration
    property). The Angular CLI component generator does this work for us.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent` 能够使用 `ExerciseDescriptionComponent` 是因为它已经在 `WorkoutRunnerModule`
    中声明过（参见 `workout-runner.module.ts` 的声明属性）。Angular CLI 组件生成器为我们完成了这项工作。'
- en: Look back at the `abe-exercise-description` declaration in the preceding view.
    We are referring to the `description` and `steps` properties in the same manner
    as we did with the HTML element properties earlier in the chapter (`<img [src]='expression'
    ...`). Simple, intuitive, and very elegant!
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾前面视图中的 `abe-exercise-description` 声明。我们以与本章前面的 HTML 元素属性相同的方式引用 `description`
    和 `steps` 属性。简单、直观、非常优雅！
- en: The Angular data binding infrastructure makes sure that whenever the `currentExercise.exercise.description`
    and `currentExercise.exercise.procedure` properties on `WorkoutRunnerComponent`
    change, the bound properties on `ExerciseDescriptionComponent`, `description`,
    and `steps` are also updated.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 数据绑定基础设施确保每当 `WorkoutRunnerComponent` 上的 `currentExercise.exercise.description`
    和 `currentExercise.exercise.procedure` 属性发生变化时，`ExerciseDescriptionComponent`
    上的绑定属性 `description` 和 `steps` 也会被更新。
- en: 'The `@Input` decoration can take a property alias as a parameter, which means
    the following: consider a property declaration such as: `@Input("myAwesomeProperty")
    myProperty:string`. It can be referenced in the view as follows: `<my-component
    [myAwesomeProperty]="expression"....`'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Input` 装饰器可以接受一个属性别名作为参数，这意味着以下内容：考虑一个属性声明，如：`@Input("myAwesomeProperty")
    myProperty:string`。它可以在视图中如下引用：`<my-component [myAwesomeProperty]="expression"....`'
- en: 'The power of the Angular binding infrastructure allows us to use any component
    property as a bindable property by attaching the `@Input` decorator (and `@Output`
    too) to it. We are not limited to basic data types such as `string`, `number`,
    and `boolean`; there can be complex objects too, which we will see next as we
    add the video player:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 绑定基础设施的强大之处在于，我们可以通过给它附加 `@Input` 装饰器（还有 `@Output`）来将任何组件属性用作可绑定属性。我们不仅限于基本数据类型，如
    `string`、`number` 和 `boolean`；也可以是复杂对象，接下来我们将看到这一点，当我们添加视频播放器时：
- en: The `@Input` decorator can be applied to complex objects too.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Input` 装饰器也可以应用于复杂对象。'
- en: 'Generate a new component in the `workout-runner` directory for the video player:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `workout-runner` 目录中为视频播放器生成一个新的组件：
- en: '[PRE62]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Update the generated boilerplate code by copying implementation from `video-player.component.ts`
    and `video-player.component.html` available in the Git branch `checkpoint2.3`
    in the `trainer/src/components/workout-runner/video-player` folder (GitHub location:
    [http://bit.ly/ng6be-2-3-video-player](http://bit.ly/ng6be-2-3-video-player)).'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从位于`trainer/src/components/workout-runner/video-player`文件夹中`video-player.component.ts`和`video-player.component.html`的`checkpoint2.3`分支中复制实现来更新生成的样板代码（GitHub位置：[http://bit.ly/ng6be-2-3-video-player](http://bit.ly/ng6be-2-3-video-player)）。
- en: 'Let''s look at the implementation for the video player. Open `video-player.component.ts`
    and check out the `VideoPlayerComponent` class:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下视频播放器的实现。打开`video-player.component.ts`文件，查看`VideoPlayerComponent`类：
- en: '[PRE63]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `videos` input property here takes an array of strings (YouTube video codes).
    While we take the `videos` array as input, we do not use this array directly in
    video player view; instead, we transform the input array into a new array of `safeVideoUrls`
    and bind it. This can be confirmed by looking at the view implementation:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`videos`输入属性接受一个字符串数组（YouTube视频代码）。虽然我们将`videos`数组作为输入，但我们并不直接在视频播放器视图中使用此数组；相反，我们将输入数组转换为一个新的`safeVideoUrls`数组并进行绑定。可以通过查看视图实现来确认：
- en: '[PRE64]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The view also uses a new Angular directive called `ngFor` to bind to the `safeVideoUrls`
    array. The `ngFor` directive belongs to a class of directives called **structural
    directives**. The directive's job is to take an HTML fragment and regenerate it
    based on the number of elements in the bound collection.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 视图还使用了一个名为`ngFor`的新的Angular指令来绑定到`safeVideoUrls`数组。`ngFor`指令属于一类称为**结构指令**的指令。该指令的作用是根据绑定集合中的元素数量重新生成HTML片段。
- en: If you are confused about how the `ngFor` directive works with `safeVideoUrls`,
    and why we need to generate `safeVideoUrls` instead of using the `videos` input
    array, wait for a while as we are shortly going to address these queries. But,
    let's first complete the integration of `VideoPlayerComponent` with `WorkoutRunnerComponent`
    to see the final outcome.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对`ngFor`指令如何与`safeVideoUrls`一起工作以及为什么我们需要生成`safeVideoUrls`而不是使用`videos`输入数组感到困惑，请稍等片刻，因为我们很快就会解决这些疑问。但是，让我们首先完成`VideoPlayerComponent`与`WorkoutRunnerComponent`的集成，以查看最终结果。
- en: 'Update the `WorkoutRunnerComponent` view by adding the component declaration
    after the `exercise-pane` div:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`exercise-pane` div之后添加组件声明来更新`WorkoutRunnerComponent`视图：
- en: '[PRE65]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `VideoPlayerComponent`'s `videos` property binds to the exercise's videos
    collection.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '`VideoPlayerComponent`的`videos`属性绑定到了练习的视频集合。'
- en: Start/refresh the app and the video thumbnails should show up on the right.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 启动/刷新应用程序，视频缩略图应该会显示在右侧。
- en: If you are having a problem with running the code, look at the Git branch `checkpoint2.3`
    for a working version of what we have done thus far. You can also download the
    snapshot of `checkpoint2.3` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-2-3](http://bit.ly/ng6be-checkpoint-2-3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在运行代码时遇到问题，请查看`checkpoint2.3`分支，以获取迄今为止我们所做的工作的可工作版本。您还可以从[http://bit.ly/ng6be-checkpoint-2-3](http://bit.ly/ng6be-checkpoint-2-3)下载`checkpoint2.3`的快照（ZIP文件）。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: 'Now, it''s time to go back and look at the parts of the `VideoPlayerComponent`
    implementation. We specifically need to understand:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候回过头来看`VideoPlayerComponent`实现的部分了。我们特别需要理解：
- en: How the `ngFor` directive works
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngFor`指令的工作原理'
- en: Why there is a need to transform the input `videos` array into `safeVideoUrls`
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么需要将输入的`videos`数组转换为`safeVideoUrls`？
- en: The significance of the Angular component life cycle event `OnChanges` (used
    in the video player)
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular组件生命周期事件`OnChanges`的重要性（在视频播放器中使用）
- en: 'To start with, it''s time to formally introduce `ngFor` and the class of directives
    it belongs to: structural directives.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，是时候正式介绍`ngFor`和它所属的指令类别：结构指令。
- en: Structural directives
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构指令
- en: The third categorization of directives, structural directives, work on the components/elements
    to manipulate their layout.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 指令的第三种分类，结构指令，用于操作组件/元素以操纵它们的布局。
- en: 'The Angular documentation describes structural directives in a succinct manner:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: Angular文档简洁地描述了结构指令：
- en: '"Instead of defining and controlling a view like a Component Directive, or
    modifying the appearance and behavior of an element like an Attribute Directive,
    the Structural Directive manipulates the layout by adding and removing entire
    element sub-trees."'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: “结构指令不像组件指令那样定义和控制视图，也不像属性指令那样修改元素的外观和行为，而是通过添加和删除整个元素子树来操纵布局。”
- en: Since we have already touched upon component directives (such as `workout-runner`
    and `exercise-description`) and attribute directives (such as `ngClass` and `ngStyle`),
    we can very well contrast their behaviors with structural directives.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经涉及了组件指令（如`workout-runner`和`exercise-description`）和属性指令（如`ngClass`和`ngStyle`），我们可以很好地将它们的行为与结构指令进行对比。
- en: The `ngFor` directive belongs to this class. We can easily identify such directives
    by the `*` prefix. Other than `ngFor`, Angular comes with some other structural
    directives such as `ngIf` and `ngSwitch`.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngFor`指令属于这个类。我们可以通过`*`前缀轻松识别这样的指令。除了`ngFor`，Angular还带有一些其他结构指令，如`ngIf`和`ngSwitch`。'
- en: The ever-so-useful NgForOf
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非常有用的NgForOf
- en: 'Every templating language has constructs that allow the templating engine to
    generate HTML (by repetition). Angular has `NgForOf`. The `NgForOf` directive
    is a super useful directive used to duplicate a piece of an HTML fragment n number
    of times. Let''s again look at how we have used `NgForOf` in the video player:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 每种模板语言都有构造，允许模板引擎生成HTML（通过重复）。Angular有`NgForOf`。`NgForOf`指令是一个非常有用的指令，用于将HTML片段的一部分重复n次。让我们再次看看我们如何在视频播放器中使用`NgForOf`：
- en: '[PRE66]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The directive selector for `NgForOf` is `{selector: ''[ngFor][ngForOf]''}`,
    so we can use either `ngFor` or `ngForOf` in the view template. We also at times
    refer to this directive as `ngFor`.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgForOf`的指令选择器是`{selector: ''[ngFor][ngForOf]''}`，所以我们可以在视图模板中使用`ngFor`或`ngForOf`。我们有时也称这个指令为`ngFor`。'
- en: 'The preceding code repeats the `div` fragment for each exercise video (using
    the `safeVideoUrls` array). The `let video of safeVideoUrls` string expression
    is interpreted as follows: take each video in the `safeVideoUrls` array and assign
    it to a template input variable, `video`.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码重复了每个练习视频的`div`片段（使用`safeVideoUrls`数组）。`let video of safeVideoUrls`字符串表达式的解释如下：取`safeVideoUrls`数组中的每个视频，并将其分配给模板输入变量`video`。
- en: This input variable can now be referenced inside the `ngFor` template HTML,
    as we do when we set the `src` property binding.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在`ngFor`模板HTML中引用这个输入变量，就像我们设置`src`属性绑定时那样。
- en: Interestingly, the string assigned to the `ngFor` directive is not a typical
    Angular expression. Instead, it's a **microsyntax**—a micro language, which the
    Angular engine can parse.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，分配给`ngFor`指令的字符串并不是典型的Angular表达式。相反，它是一种**微语法**—一种微型语言，Angular引擎可以解析。
- en: You can learn more about microsyntax in Angular's developer guide: [http://bit.ly/ng6be-micro-syntax](http://bit.ly/ng6be-micro-syntax).
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Angular的开发者指南中了解更多关于微语法的信息：[http://bit.ly/ng6be-micro-syntax](http://bit.ly/ng6be-micro-syntax)。
- en: This microsyntax exposes a number of iteration context properties that we can
    assign to template input variables and use them inside the `ngFor` HTML block.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 这种微语法暴露了许多迭代上下文属性，我们可以将其分配给模板输入变量，并在`ngFor` HTML块中使用它们。
- en: 'One such example is `index`. `index` increases from 0 to the length of the
    array for each iteration, something similar to a `for` loop, in any programming
    language. The following example shows how to capture it:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '`index`就是一个这样的例子。`index`在每次迭代时从0增加到数组的长度，类似于任何编程语言中的`for`循环。以下示例显示了如何捕获它：'
- en: '[PRE67]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Other than `index`, there are some more iteration context variables; these
    include `first`, `last`, `even`, and `odd`. This context data allows us to do
    some nifty stuff. Consider this example:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`index`之外，还有一些迭代上下文变量；这些包括`first`，`last`，`even`和`odd`。这些上下文数据使我们能够做一些巧妙的事情。考虑这个例子：
- en: '[PRE68]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It applies a `special` class to the first video `div`.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 它将`special`类应用于第一个视频`div`。
- en: 'The `NgForOf` directive can be applied to HTML elements as well as our custom
    components. This is a valid use of `NgForOf`:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgForOf`指令可以应用于HTML元素以及我们的自定义组件。这是`NgForOf`的有效用法：'
- en: '[PRE69]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Always remember to add an asterisk (`*`) before `ngFor` (and other structural
    directives). `*` has a significance.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 始终记得在`ngFor`（和其他结构指令）之前加上星号（`*`）。`*`具有重要意义。
- en: Asterisk (*) in structural directives
  id: totrans-512
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构指令中的星号（*）
- en: 'The `*` prefix is a terser format to represent a structural directive. Take,
    for example, the usage of `ngFor` by the video player. The `ngFor` template:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`前缀是表示结构指令的一种更简洁的格式。例如，视频播放器使用`ngFor`的用法。`ngFor`模板：'
- en: '[PRE70]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Actually expands to the following:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上扩展到以下内容：
- en: '[PRE71]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `ng-template` tag is an Angular element that has a declaration for `ngFor`,
    a template input variable (`video`), and a property (`ngForOf`) that points to
    the `safeVideoUrls` array. Both the preceding declarations are a valid usage of
    `ngFor`.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng-template`标签是一个Angular元素，它声明了`ngFor`，一个模板输入变量（`video`），以及一个指向`safeVideoUrls`数组的属性（`ngForOf`）。前面的声明都是`ngFor`的有效用法。'
- en: Not sure about you, but I prefer the terser first format for `ngFor`!
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 不知道你怎么想，但我更喜欢`ngFor`的更简洁的第一种格式！
- en: NgForOf performance
  id: totrans-519
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgForOf性能
- en: 'Since `NgForOf` generates HTML based on collection elements, it is notorious
    for causing performance issues. But we cannot blame the directive. It does what
    it is supposed to do: iterate and generate elements! If the underlying collection
    is huge, UI rendering can take a performance hit, especially if the collection
    changes too often. The cost of continuously destroying and creating elements in
    response to a changing collection can quickly become prohibitive.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`NgForOf`基于集合元素生成HTML，因此它以性能问题而臭名昭著。但我们不能责怪指令。它做了它应该做的事情：迭代和生成元素！如果底层集合很大，UI渲染可能会受到性能影响，特别是如果集合经常发生变化。不断销毁和创建元素以响应不断变化的集合的成本可能会迅速变得高昂。
- en: One of the performance tweaks for `NgForOf` allows us to alter the behavior
    of `ngForOf` when it comes to creating and destroying DOM elements (when the underlying
    collection elements are added or removed).
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgForOf`的性能调整之一允许我们在创建和销毁DOM元素（当底层集合元素被添加或移除时）时改变`ngForOf`的行为。'
- en: Imagine a scenario where we frequently get an array of objects from the server
    and bind it to the view using `NgForOf`. The default behavior of `NgForOf` is
    to regenerate the DOM every time we refresh the list (since Angular does a standard
    object equality check). However, as developers, we may very well know not much
    has changed. Some new objects may have been added, some removed, and maybe some
    modified. But Angular just regenerates the complete DOM.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景，我们经常从服务器获取一个对象数组，并使用`NgForOf`将其绑定到视图上。`NgForOf`的默认行为是每次刷新列表时重新生成DOM（因为Angular执行标准对象相等性检查）。然而，作为开发人员，我们可能很清楚并没有太多改变。可能添加了一些新对象，删除了一些对象，也许修改了一些对象。但Angular只是重新生成完整的DOM。
- en: 'To alleviate this situation, Angular allows us to specify a custom **tracking
    function**, which lets Angular know when two objects being compared are equal.
    Have a look at the following function:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解这种情况，Angular允许我们指定一个自定义的**跟踪函数**，让Angular知道被比较的两个对象何时相等。看一下下面的函数：
- en: '[PRE72]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: A function such as this can be used in the `NgForOf` template to tell Angular
    to compare the *user* object based on its `id` property instead of doing a reference
    equality check.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NgForOf`模板中使用这样的函数可以告诉Angular根据其`id`属性而不是进行引用相等性检查来比较*user*对象。
- en: 'This is how we then use the preceding function in the `NgForOf` template:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在`NgForOf`模板中使用上述函数：
- en: '[PRE73]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`NgForOf` will now avoid recreating DOM for users with IDs already rendered.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgForOf`现在将避免为已经呈现的具有ID的用户重新创建DOM。'
- en: Remember, Angular may still update the existing DOM elements if the bound properties
    of a user have changed.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果用户的绑定属性发生了变化，Angular仍然可能会更新现有的DOM元素。
- en: That's enough on the `ngFor` directive; let's move ahead.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngFor`指令就讲到这里，让我们继续向前。'
- en: We still need to understand the role of the `safeVideoUrls` and the `OnChange`
    life cycle events in the `VideoPlayerComponent` implementation. Let's tackle the
    former first and understand the need for `safeVideoUrls`.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要理解`VideoPlayerComponent`实现中`safeVideoUrls`和`OnChange`生命周期事件的作用。让我们先解决前者，并理解`safeVideoUrls`的必要性。
- en: Angular security
  id: totrans-532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular安全
- en: 'The easiest way to understand why we need to bind to `safeVideoUrls` instead
    of the `videos` input property is by trying the `videos` array out. Replace the
    existing `ngFor` fragment HTML with the following:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 理解为什么我们需要绑定到`safeVideoUrls`而不是`videos`输入属性的最简单方法是尝试一下`videos`数组。用以下内容替换现有的`ngFor`片段HTML：
- en: '[PRE74]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'And look at the browser''s console log (a page refresh may be required). There
    are a bunch of errors thrown by the framework, such as:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 并查看浏览器的控制台日志（可能需要刷新页面）。框架抛出了一堆错误，比如：
- en: '`Error: unsafe value used in a resource URL context (see http://g.co/ng/security#xss)`'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`错误：在资源URL上下文中使用了不安全的值（请参阅http://g.co/ng/security#xss）`'
- en: No prize for guessing what is happening! Angular is trying to safeguard our
    application against a **Cross-Site Scripting** (**XSS**) attack.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜发生了什么事情！Angular正在试图保护我们的应用免受**跨站脚本攻击**（**XSS**）。
- en: Such an attack enables the attacker to inject malicious code into our web pages.
    Once injected, the malicious code can read data from the current site context.
    This allows it to steal confidential data and also impersonate the logged-in user,
    hence gaining access to privileged resources.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击使攻击者能够向我们的网页注入恶意代码。一旦注入，恶意代码可以从当前站点上下文中读取数据。这使它能够窃取机密数据，并冒充已登录用户，从而获得对特权资源的访问权限。
- en: Angular has been designed to block these attacks by sanitizing any external
    code/script that is injected into an Angular view. Remember, content can be injected
    into a view through a number of mechanisms, including property/attribute/style
    bindings or interpolation.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: Angular被设计为通过对注入到Angular视图中的任何外部代码/脚本进行消毒来阻止这些攻击。记住，内容可以通过多种机制注入到视图中，包括属性/属性/样式绑定或插值。
- en: 'Consider an example of binding HTML markup through a component model to the `innerHTML`
    property of an HTML element (property binding):'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑通过组件模型将HTML标记绑定到HTML元素的`innerHTML`属性（属性绑定）的一个例子：
- en: '[PRE75]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: While the HTML content is emitted, any unsafe content (such as a *script*) if
    present is stripped.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然HTML内容被发出，但如果存在任何不安全的内容（比如*脚本*），它将被剥离。
- en: But what about Iframes? In our preceding example, Angular is blocking property
    binding to Iframe's `src` property too. This is a warning against third-party
    content being embedded in our own site using Iframe. Angular prevents this too.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 但是Iframes呢？在我们之前的例子中，Angular也阻止了将属性绑定到Iframe的`src`属性。这是针对使用Iframe在我们自己的网站中嵌入第三方内容的警告。Angular也阻止了这一点。
- en: 'All in all, the framework defines four security contexts around content sanitization.
    These include:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 总而言之，该框架围绕内容清理定义了四个安全上下文。这些包括：
- en: '**HTML content sanitization**, when HTML content is bound using the `innerHTML`
    property'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTML内容清理，当使用`innerHTML`属性绑定HTML内容时
- en: '**Style sanitization**, when binding CSS into the `style` property'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 样式清理，当将CSS绑定到`style`属性时
- en: '**URL sanitization**, when URLs are used with tags such as `anchor` and `img`'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: URL清理，当URL与`anchor`和`img`等标签一起使用时
- en: '**Resource sanitization**, when using `Iframes` or `script` tags; in this case,
    content cannot be sanitized and hence it is blocked by default'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源清理，当使用`Iframes`或`script`标签时；在这种情况下，内容无法被清理，因此默认情况下会被阻止
- en: Angular is trying its best to keep us out of danger. But at times, we know that
    the content is safe to render and hence want to circumvent the default sanitization
    behavior.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: Angular正在尽力使我们远离危险。但有时，我们知道内容是安全的，因此希望规避默认的清理行为。
- en: Trusting safe content
  id: totrans-550
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信任安全内容
- en: 'To let Angular know that the content being bound is safe, we use `DomSanitizer`
    and call the appropriate method based on the security contexts just described.
    The available functions are as follows:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Angular知道绑定的内容是安全的，我们使用`DomSanitizer`并根据刚刚描述的安全上下文调用适当的方法。可用的函数如下：
- en: '`bypassSecurityTrustHtml`'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bypassSecurityTrustHtml`'
- en: '`bypassSecurityTrustScript`'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bypassSecurityTrustScript`'
- en: '`bypassSecurityTrustStyle`'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bypassSecurityTrustStyle`'
- en: '`bypassSecurityTrustUrl`'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bypassSecurityTrustUrl`'
- en: '`bypassSecurityTrustResourceUrl`'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bypassSecurityTrustResourceUrl`'
- en: 'In our video player implementation, we use `bypassSecurityTrustResourceUrl`;
    it converts the video URL into a trusted `SafeResourceUrl` object:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的视频播放器实现中，我们使用`bypassSecurityTrustResourceUrl`；它将视频URL转换为受信任的`SafeResourceUrl`对象：
- en: '[PRE76]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `map` method transforms the videos array into a collection of `SafeResourceUrl`
    objects and assigns it to `safeVideoUrls`.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`方法将视频数组转换为一组`SafeResourceUrl`对象，并将其分配给`safeVideoUrls`。'
- en: Each of the methods listed previously takes a string parameter. This is the
    content we want Angular to know is safe. The return object, which could be any
    of `SafeStyle`, `SafeHtml`, `SafeScript`, `SafeUrl`, or `SafeResourceUrl`, can
    then be bound to the view.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 先前列出的每种方法都接受一个字符串参数。这是我们希望Angular知道是安全的内容。然后，返回的对象，可以是`SafeStyle`、`SafeHtml`、`SafeScript`、`SafeUrl`或`SafeResourceUrl`中的任何一个，可以绑定到视图。
- en: A comprehensive treatment of this topic is available in the framework security
    guide available at [http://bit.ly/ng6be-security](http://bit.ly/ng6be-security).
    A highly recommended read!
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此主题的全面处理可在框架安全指南中找到，网址为[http://bit.ly/ng6be-security](http://bit.ly/ng6be-security)。强烈推荐阅读！
- en: The last question to answer is why do this in the `OnChanges` Angular life cycle
    event?
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要回答的问题是为什么要在`OnChanges` Angular生命周期事件中这样做？
- en: OnChange life cycle event
  id: totrans-563
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OnChange生命周期事件
- en: The `OnChanges` life cycle event is triggered whenever the component's input(s)
    change. In the case of `VideoPlayerComponent`, it is the `videos` array input
    property that changes whenever a new exercise is loaded. We use this life cycle
    event to recreate the `safeVideoUrls` array and re-bind it to the view. Simple!
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnChanges`生命周期事件在组件的输入发生变化时触发。在`VideoPlayerComponent`的情况下，每当加载新的练习时，`videos`数组输入属性都会发生变化。我们使用这个生命周期事件来重新创建`safeVideoUrls`数组并重新绑定到视图。简单！'
- en: Video panel implementation is now complete. Let's add a few more minor enhancements
    and explore it a bit more in Angular.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 视频面板的实现现在已经完成。让我们添加一些小的增强，并在Angular中进一步探索它。
- en: Formatting exercise steps with innerHTML binding
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用innerHTML绑定格式化练习步骤
- en: One of the sore points in the current app is the formatting of the exercise
    steps. It's a bit difficult to read these steps.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 当前应用程序中的一个痛点是练习步骤的格式。阅读这些步骤有点困难。
- en: 'The steps should either have a line break (`<br>`) or be formatted as an HTML
    `list` for easy readability. This seems to be a straightforward task, and we can
    just go ahead and change the data that is bound to the step interpolation, or
    write a pipe that can add some HTML formatting using the line delimiting convention
    (`.`). For a quick verification, let''s update the first exercise steps in `workout-runner.component.ts`
    by adding a break (`<br>`) after each line:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤应该要么有一个换行（`<br>`），要么格式化为HTML`list`以便易读。这似乎是一个直接的任务，我们可以继续并改变绑定到步骤插值的数据，或者编写一个管道，使用行分隔约定（`.`）来添加一些HTML格式。为了快速验证，让我们在`workout-runner.component.ts`中更新第一个练习的步骤，添加一个换行（`<br>`）在每一行之后：
- en: '[PRE77]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As the workout restarts, look at the first exercise steps. The output does
    not match our expectations, as shown here:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 当锻炼重新开始时，看一下第一个练习的步骤。输出结果与我们的期望不符，如下所示：
- en: '![](Images/a2dce051-39a3-4779-93c1-3b5695ab0e55.png)'
  id: totrans-571
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a2dce051-39a3-4779-93c1-3b5695ab0e55.png)'
- en: The break tags were literally rendered in the browser. Angular did not render
    the interpolation as HTML; instead, it escaped the HTML characters, and we know
    why, security!
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 换行标签在浏览器中被直接呈现。Angular没有将插值呈现为HTML；相反，它转义了HTML字符，我们知道为什么，安全！
- en: How to fix it? Easy! Replace the interpolation with the property binding to
    bind step data to the element's `innerHTML` property (in `exercise-description.html`),
    and you are done!
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 如何修复？很简单！用属性绑定替换插值，将步骤数据绑定到元素的`innerHTML`属性（在`exercise-description.html`中），然后就完成了！
- en: '[PRE78]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Refresh the workout page to confirm.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新锻炼页面以确认。
- en: Preventing Cross-Site Scripting Security (XSS) issues
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 防止跨站脚本安全（XSS）问题
- en: By using `innerHTML`, we instruct Angular to not escape HTML, but Angular still
    sanitizes the input HTML as described in the security section earlier. It removes
    things such as `<script>` tags and other JavaScript to safeguard against XSS attacks.
    If you want to dynamically inject styles/scripts into HTML, use the `DomSanitizer`
    to bypass this sanitization check.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`innerHTML`，我们指示Angular不要转义HTML，但Angular仍然像在之前的安全部分中描述的那样对输入的HTML进行消毒。它会删除诸如`<script>`标签和其他JavaScript之类的东西，以防止XSS攻击。如果您想要动态地将样式/脚本注入HTML中，请使用`DomSanitizer`来绕过此消毒检查。
- en: Time for another enhancement! It's time to learn about Angular pipes.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进行另一个增强了！是时候了解Angular管道了。
- en: Displaying the remaining workout duration using pipes
  id: totrans-579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道显示剩余的锻炼持续时间
- en: It will be nice if we can tell the user the time left to complete the workout
    and not just the duration of the exercise in progress. We can add a countdown
    timer somewhere in the exercise pane to show the overall time remaining.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能告诉用户剩余完成锻炼的时间，而不仅仅是正在进行的练习的持续时间，那将很好。我们可以在练习窗格的某个地方添加一个倒计时器，显示总体剩余时间。
- en: The approach that we are going to take here is to define a component property
    called `workoutTimeRemaining`. This property will be initialized with the total
    time at the start of the workout and will reduce with every passing second until
    it reaches zero. Since `workoutTimeRemaining` is a numeric value, but we want
    to display a timer in the `hh:mm:ss` format, we need to make a conversion between
    the seconds data and the time format. **Angular pipes** are a great option for
    implementing such a feature.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要采取的方法是定义一个名为`workoutTimeRemaining`的组件属性。该属性将在锻炼开始时初始化为总时间，并且会随着每秒的流逝而减少，直到达到零。由于`workoutTimeRemaining`是一个数值，但我们希望在`hh:mm:ss`格式中显示计时器，因此我们需要在秒数据和时间格式之间进行转换。**Angular管道**是实现这种功能的一个很好的选择。
- en: Angular pipes
  id: totrans-582
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular管道
- en: The primary aim of a pipe is to format the data displayed in the view. **Pipes**
    allow us to package this content transformation logic (formatting) as a reusable
    element. The framework itself comes with multiple predefined pipes, such as `date`,
    `currency`, `lowercase`, `uppercase`, `slice`, and others.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 管道的主要目的是格式化视图中显示的数据。**管道**允许我们将内容转换逻辑（格式化）打包为可重用的元素。框架本身带有多个预定义的管道，如`date`、`currency`、`lowercase`、`uppercase`、`slice`等。
- en: 'This is how we use a pipe with a view:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何在视图中使用管道的方式：
- en: '[PRE79]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'An expression is followed by the pipe symbol (`|`), which is followed by the
    pipe name and then an optional parameter (`inputParam1`) separated by a colon
    (`:`). If the pipe takes multiple inputs, they can be placed one after another
    separated by a colon, such as the inbuilt `slice` pipe, which can slice an array
    or string:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式后跟着管道符号（`|`），然后是管道名称，然后是一个可选参数（`inputParam1`），用冒号（`:`）分隔。如果管道接受多个输入，它们可以一个接一个地放置，用冒号分隔，例如内置的`slice`管道，可以对数组或字符串进行切片：
- en: '[PRE80]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The parameter passed to the pipe can be a constant or a component property,
    which implies we can use template expressions with pipe parameter. See the following
    example:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给管道的参数可以是常量或组件属性，这意味着我们可以在管道参数中使用模板表达式。请参阅以下示例：
- en: '[PRE81]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Here are some examples of the use of the `date` pipe, as described in the Angular
    `date` documentation. Assume that `dateObj` is initialized to *June 15,* 2015
    *21:43:11* and locale is *en-US*:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使用`date`管道的示例，如Angular`date`文档中所述。假设`dateObj`初始化为*2015年6月15日* *21:43:11*，区域设置为*en-US*：
- en: '[PRE82]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Some of the most commonly used pipes are the following:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最常用的管道如下：
- en: '**date**: As we just saw, the date filter is used to format the date in a specific
    manner. This filter supports quite a number of formats and is locale-aware too.
    To know about the other formats supported by the date pipe, check out the framework
    documentation at [http://bit.ly/ng2-date](http://bit.ly/ng2-date).'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期：正如我们刚才看到的，日期过滤器用于以特定方式格式化日期。该过滤器支持许多格式，并且也支持区域设置。要了解日期管道支持的其他格式，请查看框架文档[http://bit.ly/ng2-date](http://bit.ly/ng2-date)。
- en: '**uppercase** and **lowercase**: These two pipes, as the name suggests, change
    the case of the string input.'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**uppercase**和**lowercase**：这两个管道，顾名思义，改变了字符串输入的大小写。'
- en: '**decimal** and **percent**: `decimal` and `percent` pipes are there to format
    decimal and percentage values based on the current browser locale.'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**decimal**和**percent**：`decimal`和`percent`管道用于根据当前浏览器区域设置格式化小数和百分比值。'
- en: '**currency**: This is used to format numeric values as a currency based on
    the current browser locale:'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**currency**：用于根据当前浏览器区域设置将数值格式化为货币：'
- en: '[PRE83]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '**json**: This is a handy pipe for debugging that can transform any input into
    a string using `JSON.stringify`. We made good use of it at the start of this chapter
    to render the `WorkoutPlan` object (see the Checkpoint 2.1 code).'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**json**：这是一个方便的用于调试的管道，可以使用`JSON.stringify`将任何输入转换为字符串。我们在本章开头很好地利用了它来呈现`WorkoutPlan`对象（请参阅2.1节的代码）。'
- en: '**slice:** This pipe allows us to split a list or a string value to create
    a smaller trimmed down list/string. We saw an example in the preceding code.'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**slice**：这个管道允许我们将列表或字符串值拆分为一个更小的修剪列表/字符串。我们在前面的代码中看到了一个例子。'
- en: We are not going to cover the preceding pipes in detail. From a development
    perspective, as long as we know what pipes are there and what they are useful
    for, we can always refer to the platform documentation for exact usage instructions.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算详细介绍前面的管道。从开发的角度来看，只要我们知道有哪些管道以及它们有什么用处，我们总是可以参考平台文档以获取确切的使用说明。
- en: Pipe chaining
  id: totrans-601
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道链
- en: 'A really powerful feature of pipes is that they can be chained, where the output
    from one pipe can serve as the input to another pipe. Consider this example:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 管道的一个非常强大的特性是它们可以链接在一起，其中一个管道的输出可以作为另一个管道的输入。考虑这个例子：
- en: '[PRE84]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The first pipe slices the first 20 characters of `fullName` and the second pipe
    transforms them to uppercase.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个管道切割`fullName`的前20个字符，第二个管道将它们转换为大写。
- en: 'Now that we have seen what pipes are and how to use them, why not implement
    one for the *7 Minute Workout* app: a **seconds to time** pipe?'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了管道是什么以及如何使用它们，为什么不为*7分钟锻炼*应用程序实现一个**秒到时间**管道呢？
- en: Implementing a custom pipe - SecondsToTimePipe
  id: totrans-606
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现自定义管道-SecondsToTimePipe
- en: '`SecondsToTimePipe`, as the name suggests, should convert a numeric value into
    the `hh:mm:ss` format.'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecondsToTimePipe`，顾名思义，应该将一个数字值转换为`hh:mm:ss`格式。'
- en: 'Create a folder `shared` in the `workout-runner` folder and from the shared
    folder invoke this CLI command to generate the pipe boilerplate:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 在`workout-runner`文件夹中创建一个名为`shared`的文件夹，并从shared文件夹中调用此CLI命令来生成管道样板：
- en: '[PRE85]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `shared` folder has been created to add common components/directives/pipes
    that can be used in the `workout-runner` module. It is a convention we follow
    to organize shared code at different levels. In the future, we can create a shared
    folder at the app module level, which has artifacts shared globally. In fact,
    if the second to time pipe needs to be used across other application modules,
    it can also be moved into the app module.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared`文件夹已经被创建，用于添加可以在`workout-runner`模块中使用的常见组件/指令/管道。这是我们遵循的一个组织共享代码的惯例。将来，我们可以在应用程序模块级别创建一个共享文件夹，其中包含全局共享的工件。实际上，如果需要在其他应用程序模块中使用秒到时间管道，也可以将其移动到应用程序模块中。'
- en: 'Copy the following `transform` function implementation into `seconds-to-time.pipe.ts`(the
    definition can also be downloaded from the Git branch `checkpoint.2.4` on the
    GitHub site at [http://bit.ly/nng6be-2-4-seconds-to-time-pipe-ts](http://bit.ly/nng6be-2-4-seconds-to-time-pipe-ts)):'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下`transform`函数实现复制到`seconds-to-time.pipe.ts`中（也可以从GitHub网站的Git分支`checkpoint.2.4`上下载定义，网址为[http://bit.ly/nng6be-2-4-seconds-to-time-pipe-ts](http://bit.ly/nng6be-2-4-seconds-to-time-pipe-ts)）：
- en: '[PRE86]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In an Angular pipe, the implementation logic goes into the `transform` function.
    Defined as part of the `PipeTransform` interface, the preceding `transform` function
    transforms the input seconds value into an *hh:mm:ss* string. The first parameter
    to the `transform` function is the pipe input. The subsequent parameters, if provided,
    are the arguments to the pipe, passed using a colon separator (`pipe:argument1:arugment2..`)
    from the view.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular管道中，实现逻辑放在`transform`函数中。作为`PipeTransform`接口的一部分，前面的`transform`函数将输入的秒值转换为*hh:mm:ss*字符串。`transform`函数的第一个参数是管道输入。如果提供了后续参数，它们是管道的参数，使用冒号分隔符（`pipe:argument1:arugment2..`）从视图中传递。
- en: For `SecondsToTimePipe`, while Angular CLI generates a boilerplate argument
    (`args?:any`), we do not make use of any pipe argument as the implementation does
    not require it.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`SecondsToTimePipe`，虽然Angular CLI生成了一个样板参数（`args?:any`），但我们并没有使用任何管道参数，因为实现不需要它。
- en: The pipe implementation is quite straightforward, as we convert seconds into
    hours, minutes, and seconds. Then, we concatenate the result into a string value
    and return the value. The addition of 0 on the left for each of the `hours`, `minutes`,
    and `seconds` variables is done to format the value with a leading 0 in case the
    calculated value for hours, minutes, or seconds is less than 10.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 管道的实现非常简单，因为我们将秒转换为小时、分钟和秒。然后，我们将结果连接成一个字符串值并返回该值。对于`hours`、`minutes`和`seconds`变量的左侧添加0是为了在小时、分钟或秒的计算值小于10时格式化该值以具有前导0。
- en: 'The pipe that we just created is just a standard TypeScript class. It''s the
    Pipe decorator (`@Pipe`) that instructs Angular to treat this class as a pipe:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的管道只是一个标准的TypeScript类。是Pipe装饰器（`@Pipe`）指示Angular将这个类视为管道：
- en: '[PRE87]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The pipe definition is complete, but to use the pipe in `WorkoutRunnerComponent`
    the pipe has to be declared on `WorkoutRunnerModule.` Angular CLI has already
    done this for us as part of the boilerplate generation (see the `declaration`
    section in `workout-runner.module.ts`).
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 管道定义已经完成，但是要在`WorkoutRunnerComponent`中使用管道，必须在`WorkoutRunnerModule`中声明管道。Angular
    CLI已经在样板生成的一部分中为我们完成了这一步（请参见`workout-runner.module.ts`中的`declaration`部分）。
- en: 'Now we just need to add the pipe in the view. Update `workout-runner.component.html`
    by adding the highlighted fragment:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要在视图中添加管道。通过添加高亮显示的片段来更新`workout-runner.component.html`：
- en: '[PRE88]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Surprisingly, the implementation is still not complete! There is one more step
    left. We have a pipe definition, and we have referenced it in the view, but `workoutTimeRemaining`
    needs to update with each passing second for `SecondsToTimePipe` to be effective.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，实现还没有完成！还有一步。我们已经有了管道定义，并在视图中引用了它，但是`workoutTimeRemaining`需要在每秒钟过去时更新，才能使`SecondsToTimePipe`生效。
- en: 'We have already initialized `WorkoutRunnerComponent`''s `workoutTimeRemaining`
    property in the `start` function with the total workout time:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`start`函数中使用总练习时间初始化了`WorkoutRunnerComponent`的`workoutTimeRemaining`属性：
- en: '[PRE89]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now the question is: how to update the `workoutTimeRemaining` variable with
    each passing second? Remember that we already have a `setInterval` set up that
    updates `exerciseRunningDuration`. While we can write another `setInterval` implementation
    for `workoutTimeRemaining`, it will be better if a single `setInterval` setup
    can take care of both the requirements.'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是：如何在每秒钟过去时更新`workoutTimeRemaining`变量？请记住，我们已经设置了一个`setInterval`来更新`exerciseRunningDuration`。虽然我们可以为`workoutTimeRemaining`编写另一个`setInterval`实现，但最好是一个单独的`setInterval`设置可以满足这两个要求。
- en: 'Add a function called `startExerciseTimeTracking` to `WorkoutRunnerComponent`;
    it looks as follows:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WorkoutRunnerComponent`中添加一个名为`startExerciseTimeTracking`的函数；它如下所示：
- en: '[PRE90]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: As you can see, the primary purpose of the function is to track the exercise
    progress and flip the exercise once it is complete. However, it also tracks `workoutTimeRemaining`
    (it decrements this counter). The first `if` condition setup just makes sure that
    we clear the timer once all the exercises are done. The inner `if` conditions
    are used to keep `currentExerciseIndex` in sync with the running exercise.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个函数的主要目的是跟踪练习进度，并在完成后翻转练习。然而，它还跟踪`workoutTimeRemaining`（它递减这个计数器）。第一个`if`条件设置只是确保我们在所有练习完成后清除计时器。内部的`if`条件用于保持`currentExerciseIndex`与正在进行的练习同步。
- en: This function uses a numeric instance variable called `exerciseTrackingInterval`.
    Add it to the class declaration section. We are going to use this variable later
    to implement an exercise pausing behavior.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用一个名为`exerciseTrackingInterval`的数值实例变量。将其添加到类声明部分。我们将在稍后使用这个变量来实现练习暂停行为。
- en: 'Remove the complete `setInterval` setup from `startExercise` and replace it
    with a call to `this.startExerciseTimeTracking();`. We are all set to test our
    implementation. If required, refresh the browser and verify the implementation:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 从`startExercise`中删除完整的`setInterval`设置，并用`this.startExerciseTimeTracking();`替换它。我们已经准备好测试我们的实现。如果需要，刷新浏览器并验证实现：
- en: '![](Images/bcfb02e4-245e-42b8-86a1-2dc661c1b3b8.png)'
  id: totrans-630
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bcfb02e4-245e-42b8-86a1-2dc661c1b3b8.png)'
- en: The next section is about another inbuilt Angular directive, `ngIf`, and another
    small enhancement.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节是关于另一个内置的Angular指令`ngIf`，以及另一个小的增强。
- en: Adding the next exercise indicator using ngIf
  id: totrans-632
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ngIf添加下一个练习指示器
- en: It will be nice for the user to be told what the next exercise is during the
    short rest period between exercises. This will help them prepare for the next
    exercise. So let's add it.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 在练习之间的短暂休息期间，告诉用户下一个练习是什么将是很好的。这将帮助他们为下一个练习做准备。所以让我们添加它。
- en: To implement this feature, we can simply output the title of the next exercise
    from the `workoutPlan.exercises` array. We show the title next to the `Time Remaining`
    countdown section.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个功能，我们可以简单地从`workoutPlan.exercises`数组中输出下一个练习的标题。我们将标题显示在`剩余时间`倒计时部分旁边。
- en: 'Change the workout div (`class="exercise-pane"`) to include the highlighted
    content, and remove existing `Time Remaining` `h1`:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 更改锻炼div（`class="exercise-pane"`）以包含突出显示的内容，并删除现有的`剩余时间` `h1`：
- en: '[PRE91]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We wrap the existing `Time Remaining h1` and add another `h3` tag to show the
    next exercise inside a new `div` with some style updates. Also, there is a new
    directive, `ngIf`, in the second `h3`. The `*` prefix implies that it belongs
    to the same set of directives that `ngFor` belongs: **structural directives**.
    Let''s talk a bit about `ngIf`.'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包装现有的`剩余时间h1`并在一个新的`div`中添加另一个`h3`标签来显示下一个练习，并进行一些样式更新。此外，第二个`h3`中还有一个新的指令，`ngIf`。`*`前缀意味着它属于与`ngFor`相同的一组指令：**结构指令**。让我们稍微谈一下`ngIf`。
- en: 'The `ngIf` directive is used to add or remove a specific section of the DOM
    based on whether the expression provided to it returns `true` or `false`. The
    DOM element is added when the expression evaluates to `true` and is destroyed
    otherwise. Isolate the `ngIf` declaration from the preceding view:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngIf`指令用于根据提供给它的表达式返回`true`或`false`来添加或移除DOM的特定部分。当表达式求值为`true`时，DOM元素被添加，否则被销毁。将`ngIf`声明与前面的视图隔离开来：'
- en: '[PRE92]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The directive expression checks whether we are currently in the rest phase and
    accordingly shows or hides the linked `h3`.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 指令表达式检查我们当前是否处于休息阶段，并相应地显示或隐藏链接的`h3`。
- en: Also in the same `h3`, we have an interpolation that shows the name of the exercise
    from the `workoutPlan.exercises` array.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 同样在同一个`h3`中，我们有一个插值，显示来自`workoutPlan.exercises`数组的练习名称。
- en: 'A word of caution here: `ngIf` adds and destroys the DOM element, and hence
    it is not similar to the visibility constructs that we employed to show and hide
    elements. While the end result of `style`, `display:none` is the same as that
    of `ngIf`, the mechanism is entirely different:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是：`ngIf`添加和销毁DOM元素，因此它与我们用来显示和隐藏元素的可见性构造不同。虽然`style`，`display:none`的最终结果与`ngIf`相同，但机制完全不同：
- en: '[PRE93]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Versus this line:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 与这一行相对：
- en: '[PRE94]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'With `ngIf`, whenever the expression changes from `false` to `true`, a complete
    re-initialization of the content occurs. Recursively, new elements/components
    are created and data binding is set up, starting from the parent down to the children.
    The reverse happens when the expression changes from `true` to `false`: all of
    this is destroyed. Therefore, using `ngIf` can sometimes become an expensive operation
    if it wraps a large chunk of content and the expression attached to it changes
    very often. But otherwise, wrapping a view in `ngIf` is more performant than using
    CSS/style-based show or hide, as neither the DOM is created nor the data binding
    expressions are set up when the `ngIf` expression evaluates to `false`.'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ngIf`，每当表达式从`false`变为`true`时，内容会完全重新初始化。递归地，会创建新的元素/组件并设置数据绑定，从父级到子级。当表达式从`true`变为`false`时，就会发生相反的情况：所有这些都会被销毁。因此，如果`ngIf`包裹了大量内容并且与其关联的表达式经常变化，使用`ngIf`有时可能会变得很昂贵。但除此之外，将视图包装在`ngIf`中比使用基于CSS/样式的显示或隐藏更高效，因为当`ngIf`表达式评估为`false`时，既不会创建DOM，也不会设置数据绑定表达式。
- en: 'New version of Angular support branching constructs too. This allows us to
    implement the **if then else** flow in the view HTML. The following sample has
    been lifted directly from the platform documentation of `ngIf`:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本的Angular也支持分支结构。这使我们能够在视图HTML中实现**if then else**流程。以下示例直接摘自`ngIf`的平台文档：
- en: '[PRE95]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The `else` binding points to a `ng-template` with template variable `#elseBlock`.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '`else`绑定指向具有模板变量`#elseBlock`的`ng-template`。'
- en: 'There is another directive that belongs in this league: `ngSwitch`. When defined
    on the parent HTML, it can swap the child HTML elements based on the `ngSwitch`
    expression. Consider this example:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个指令属于这个类别：`ngSwitch`。当在父HTML上定义时，它可以根据`ngSwitch`表达式交换子HTML元素。考虑以下示例：
- en: '[PRE96]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We bind the `userType` expression to `ngSwitch`. Based on the value of `userType`
    (`admin`, `powerUser`, or any other `userType`), one of the inner div elements
    will be rendered. The `ngSwitchDefault` directive is a wildcard match/fallback
    match, and it gets rendered when `userType` is neither `admin` nor `powerUser`.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`userType`表达式绑定到`ngSwitch`。根据`userType`的值（`admin`，`powerUser`或任何其他`userType`），将呈现一个内部div元素。`ngSwitchDefault`指令是通配符匹配/回退匹配，当`userType`既不是`admin`也不是`powerUser`时，它会被呈现。
- en: 'If you have not realized it yet, note that there are three directives working
    together here to achieve switch-case-like behavior:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有意识到，注意这里有三个指令一起工作，以实现类似switch-case的行为：
- en: '`ngSwitch`'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngSwitch`'
- en: '`ngSwitchCase`'
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngSwitchCase`'
- en: '`ngSwitchDefault`'
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngSwitchDefault`'
- en: 'Coming back to our next exercise implementation, we are ready to verify the
    implementation, start the app, and wait for the rest period. There should be a
    mention of the next exercise during the rest phase, as shown here:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的下一个练习实现，我们已经准备好验证实现，启动应用程序，并等待休息时间。在休息阶段应该提到下一个练习，如下所示：
- en: '![](Images/576ca7a4-2fc2-4d11-81d0-a37470c878a6.png)'
  id: totrans-658
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/576ca7a4-2fc2-4d11-81d0-a37470c878a6.png)'
- en: The app is shaping up well. If you have used the app and done some physical
    workouts along with it, you will be missing the exercise pause functionality badly.
    The workout just does not stop until it reaches the end. We need to fix this behavior.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序正在良好地发展。如果您已经使用了该应用程序并进行了一些体育锻炼，您会非常想念练习暂停功能。锻炼一直持续到结束。我们需要修复这种行为。
- en: Pausing an exercise
  id: totrans-660
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂停练习
- en: To pause an exercise, we need to stop the timer. We also need to add a button
    somewhere in the view that allows us to pause and resume the workout. We plan
    to do this by drawing a button overlay over the exercise area in the center of
    the page. When clicked on, it will toggle the exercise state between paused and
    running. We will also add keyboard support to pause and resume the workout using
    the key binding `p` or `P`. Let's update the component.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 要暂停锻炼，我们需要停止计时器。我们还需要在视图的某个地方添加一个按钮，允许我们暂停和恢复锻炼。我们计划通过在页面中心的锻炼区域上绘制一个按钮覆盖层来实现这一点。单击时，它将在暂停和运行之间切换锻炼状态。我们还将添加键盘支持以使用键绑定`p`或`P`暂停和恢复锻炼。让我们更新组件。
- en: 'Update the `WorkoutRunnerComponent` class, add these three functions, and add
    a declaration for the `workoutPaused` variable:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`WorkoutRunnerComponent`类，添加这三个函数，并为`workoutPaused`变量添加声明：
- en: '[PRE97]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The implementation for pausing is simple. The first thing we do is cancel the
    existing `setInterval` setup by calling `clearInterval(this.exerciseTrackingInterval);`.
    While resuming, we again call `startExerciseTimeTracking`, which again starts
    tracking the time from where we left off.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停的实现很简单。我们要做的第一件事是通过调用`clearInterval(this.exerciseTrackingInterval);`取消现有的`setInterval`设置。在恢复时，我们再次调用`startExerciseTimeTracking`，它会再次从我们离开的地方开始跟踪时间。
- en: 'Now we just need to invoke the `pauseResumeToggle` function for the view. Add
    the following content to `workout-runner.html`:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要为视图调用`pauseResumeToggle`函数。将以下内容添加到`workout-runner.html`：
- en: '[PRE98]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The `click` event handler on the div toggles the workout running state, and
    the `ngClass` directive is used to toggle the class between `ion-md-pause` and
    `ion-md-play`- standard Angular stuff. What is missing now is the ability to pause
    and resume on a *P* key press.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: div上的`click`事件处理程序切换了锻炼运行状态，`ngClass`指令用于在`ion-md-pause`和`ion-md-play`之间切换类-标准的Angular内容。现在缺少的是能够在按下*P*键时暂停和恢复。
- en: 'One approach could be to apply a `keyup` event handler on the div:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是在div上应用`keyup`事件处理程序：
- en: '[PRE99]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'But there are some shortcomings to this approach:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这种方法有一些缺点：
- en: The `div` element does not have a concept of focus, so we also need to add the
    `tabIndex` attribute on the div to make it work
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`div`元素没有焦点的概念，所以我们还需要在div上添加`tabIndex`属性使其工作'
- en: Even then, it works only when we have clicked on the div at least once
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使如此，它仅在我们至少点击div一次时才起作用。
- en: 'There is a better way to implement this; attach the event handler to the global
    `window` event `keyup`. This is how the event binding should be applied on the
    `div`:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更好的方法来实现这一点；将事件处理程序附加到全局`window`事件`keyup`上。这是事件绑定应该应用在`div`上的方式：
- en: '[PRE100]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Make note of the special `window:` prefix before the `keyup` event. We can
    use this syntax to attach events to any global object, such as the `document`.
    A handy and very powerful feature of Angular binding infrastructure! The `onKeyPressed`
    event handler needs to be added to `WorkoutRunnerComponent`. Add this function
    to the class:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`keyup`事件之前的特殊`window:`前缀。我们可以使用这种语法将事件附加到任何全局对象，比如`document`。这是Angular绑定基础设施的一个方便且非常强大的特性！`onKeyPressed`事件处理程序需要添加到`WorkoutRunnerComponent`。将此函数添加到类中：
- en: '[PRE101]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The `$event` object is the standard **DOM event object** that Angular makes
    available for manipulation. Since this is a keyboard event, the specialized class
    is `KeyboardEvent`. The `which` property is matched to ASCII values of `p` or
    `P`. Refresh the page and you should see the play/pause icon when your mouse hovers
    over the exercise image, as follows:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '`$event`对象是Angular提供用于操作的标准**DOM事件对象**。由于这是一个键盘事件，所以专门的类是`KeyboardEvent`。`which`属性与`p`或`P`的ASCII值匹配。刷新页面，当鼠标悬停在锻炼图像上时，您应该看到播放/暂停图标，如下所示：'
- en: '![](Images/e98c6d82-9004-466e-8788-93534ad69cdf.png)'
  id: totrans-678
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e98c6d82-9004-466e-8788-93534ad69cdf.png)'
- en: While we are on the topic of **event binding**, it would be a good opportunity
    to explore Angular's event binding infrastructure
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论**事件绑定**时，这将是一个很好的机会来探索Angular的事件绑定基础设施
- en: The Angular event binding infrastructure
  id: totrans-680
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular事件绑定基础设施
- en: Angular event binding allows a component to communicate with its parent through
    events.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: Angular事件绑定允许组件通过事件与其父组件通信。
- en: If we look back at the app implementation, what we have encountered thus far
    are the property/attribute bindings. Such bindings allow a component/element to
    take inputs from the outside world. The data flows into the component.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下应用程序的实现，到目前为止我们遇到的是属性/属性绑定。这些绑定允许组件/元素从外部接收输入。数据流入组件。
- en: Event bindings are the reverse of property bindings. They allow a component/element
    to inform the outside world about any state change.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 事件绑定是属性绑定的反向。它允许组件/元素通知外部世界有关任何状态更改。
- en: 'As we saw in the pause/resume implementation, event binding employs round brackets
    (`()`) to specify the target event:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在暂停/恢复实现中看到的，事件绑定使用圆括号(`()`)来指定目标事件：
- en: '[PRE102]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This attaches a `click` event handler to the `div` that invokes the expression
    `pauseResumeToggle()` when the `div` is clicked.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 这将一个`click`事件处理程序附加到`div`，当单击`div`时调用表达式`pauseResumeToggle()`。
- en: 'Like properties, there is a canonical form for events too. Instead of using
    round brackets, the `on-` prefix can be used: `on-click="pauseResumeToggle()"`'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 与属性一样，事件也有一个规范形式。可以使用`on-`前缀，而不是使用圆括号：`on-click="pauseResumeToggle()"`
- en: 'Angular supports all types of events. Events related to keyboard inputs, mouse
    movements, button clicks, and touches. The framework even allows us to define
    our own event for the components we create, such as:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: Angular支持所有类型的事件。与键盘输入、鼠标移动、按钮点击和触摸相关的事件。该框架甚至允许我们为创建的组件定义自己的事件，例如：
- en: '[PRE103]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: It is expected that events have side effects; in other words, an event handler
    may change the state of the component, which in turn may trigger a chain reaction
    in which multiple components react to the state change and change their own state.
    This is unlike a property binding expression, which should be side-effect-free.
    Even in our implementation, clicking on the `div` element toggles the exercise
    run state.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 预期事件具有副作用；换句话说，事件处理程序可能会改变组件的状态，从而可能触发连锁反应，其中多个组件对状态更改做出反应并改变自己的状态。这与属性绑定表达式不同，后者应该是无副作用的。即使在我们的实现中，单击`div`元素也会切换练习运行状态。
- en: Event bubbling
  id: totrans-691
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件冒泡
- en: 'When Angular attaches event handlers to standard HTML element events, the event
    propagation works in the same way as standard DOM event propagation works. This
    is also called **event bubbling**. Events on child elements are propagated upwards,
    and hence event binding is also possible on a parent element, as follows:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 当Angular将事件处理程序附加到标准HTML元素事件时，事件传播的工作方式与标准DOM事件传播的工作方式相同。这也被称为**事件冒泡**。子元素上的事件向上传播，因此也可以在父元素上进行事件绑定，如下所示：
- en: '[PRE104]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Clicking on either of the divs results in the invocation of the `doWork` function
    on the parent `div`. Moreover, `$event.target` contains the reference to the `div`
    that dispatched the event.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 单击任一`div`都会导致在父`div`上调用`doWork`函数。此外，`$event.target`包含分派事件的`div`的引用。
- en: Custom events created on Angular components do not support event bubbling.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular组件上创建的自定义事件不支持事件冒泡。
- en: 'Event bubbling stops if the expression assigned to the target evaluates to
    a `falsey` value (such as `void`, `false`). Therefore, to continue propagation,
    the expression should evaluate to `true`:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分配给目标的表达式求值为`falsey`值（如`void`，`false`），事件冒泡将停止。因此，要继续传播，表达式应该求值为`true`：
- en: '[PRE105]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Here too, the `$event` object deserves some special attention.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`$event`对象也值得特别关注。
- en: Event binding an $event object
  id: totrans-699
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件绑定和$event对象
- en: Angular makes an `$event` object available whenever the target event is triggered.
    This `$event` contains the details of the event that occurred.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 当目标事件被触发时，Angular会提供一个$event对象。这个$event包含了发生的事件的详细信息。
- en: The important thing to note here is that the shape of the `$event` object is
    decided based on the event type. For HTML elements, it is a DOM event object ([https://developer.mozilla.org/en-US/docs/Web/Events](https://developer.mozilla.org/en-US/docs/Web/Events)),
    which may vary based on the actual event.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的重要事情是，$event对象的形状是根据事件类型决定的。对于HTML元素，它是一个DOM事件对象（[https://developer.mozilla.org/en-US/docs/Web/Events](https://developer.mozilla.org/en-US/docs/Web/Events)），根据实际事件可能会有所不同。
- en: But if it is a custom component event, what is passed in the `$event` object
    is decided by the component implementation.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果是自定义组件事件，传递给$event对象的内容取决于组件的实现。
- en: We have now covered most of the data binding capabilities of Angular, with the
    exception of two-way binding. A quick introduction to the two-way binding constructs
    is warranted before we conclude the chapter.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了Angular的大部分数据绑定能力，除了双向绑定。在我们结束本章之前，有必要快速介绍一下双向绑定构造。
- en: Two-way binding with ngModel
  id: totrans-704
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ngModel进行双向绑定
- en: '**Two-way binding** helps us keep the model and view in sync. Changes to the
    model update the view and changes to the view update the model. The obvious area
    where two-way binding is applicable is form input. Let''s look at a simple example:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '**双向绑定**帮助我们保持模型和视图同步。对模型的更改会更新视图，对视图的更改会更新模型。双向绑定适用的明显领域是表单输入。让我们看一个简单的例子：'
- en: '[PRE106]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The `ngModel` directive here sets a two-way binding between the `input`'s `value`
    property and the `workout.name` property on the underlying component. Anything
    that the user enters in the preceding  `input` is synced with `workout.name`,
    and any changes to `workout.name` are reflected back on the preceding `input`.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngModel`指令在此处在`input`的`value`属性和底层组件的`workout.name`属性之间建立了双向绑定。用户在前面的`input`中输入的任何内容都会与`workout.name`同步，对`workout.name`的任何更改都会反映在前面的`input`上。'
- en: 'Interestingly, we can achieve the same result without using the `ngModel` directive
    too, by combining both property and event binding syntax. Consider the next example;
    it works in the same way as `input` before:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们也可以在不使用`ngModel`指令的情况下通过结合属性和事件绑定语法来实现相同的结果。考虑下一个例子；它的工作方式与之前的`input`相同：
- en: '[PRE107]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: There is a property binding set up on the `value` property and an event binding
    set up on the `input` event that make the bidirectional sync work.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 在`value`属性上设置了属性绑定，并在`input`事件上设置了事件绑定，使双向同步工作。
- en: We will get into more details on two-way binding in [Chapter 2](4b0ad450-2a56-4c24-b431-116d7225a57e.xhtml),* Personal
    Trainer*, where we build our own custom workouts.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第2章](4b0ad450-2a56-4c24-b431-116d7225a57e.xhtml)中更详细地讨论双向绑定，*个人健身教练*，在那里我们将构建自己的自定义锻炼。
- en: 'We have created a diagram that summarizes the data flow patterns for all the
    bindings that we have discussed thus far. Here is a handy diagram to help you
    memorize each of the binding constructs and how data flows:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个图表，总结了我们迄今讨论过的所有绑定的数据流模式。以下是一个方便的图表，可帮助您记忆每个绑定构造以及数据流的方式：
- en: '![](Images/15166818-fb41-410a-8e11-a6843f5217a1.png)'
  id: totrans-713
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15166818-fb41-410a-8e11-a6843f5217a1.png)'
- en: We now have a fully functional *7 Minute Workout*, with some bells and whistles
    too, and hopefully you had fun creating the app. It's time to conclude the chapter
    and summarize the lessons.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完全功能的*7分钟锻炼*，还有一些花里胡哨的东西，希望您在创建应用程序时玩得开心。现在是时候结束本章并总结所学的课程了。
- en: If you are having a problem with running the code, look at the Git branch `checkpoint2.4`
    for a working version of what we have done thus far. You can also download a snapshot
    of `checkpoint2.4` (a ZIP file) from this GitHub location: [http://bit.ly/ng6be-checkpoint-2-4](http://bit.ly/ng6be-checkpoint-2-4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在运行代码时遇到问题，请查看Git分支`checkpoint2.4`，以获取到目前为止我们所做的工作的可用版本。你也可以从GitHub位置[http://bit.ly/ng6be-checkpoint-2-4](http://bit.ly/ng6be-checkpoint-2-4)下载`checkpoint2.4`的快照（ZIP文件）。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Cross-component communication using Angular events
  id: totrans-716
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular事件进行跨组件通信
- en: It's time now to look at eventing in more depth. Let's add audio support to *7-Minute
    Workout*.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候更深入地了解事件了。让我们为*7分钟锻炼*添加音频支持。
- en: Tracking exercise progress with audio
  id: totrans-718
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用音频跟踪锻炼进度
- en: For the *7-Minute Workout* app, adding sound support is vital. One cannot exercise
    while constantly staring at the screen. Audio clues help the user perform the
    workout effectively as they can just follow the audio instructions.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*7分钟锻炼*应用程序，添加声音支持至关重要。人们无法一直盯着屏幕锻炼。音频线索帮助用户有效地进行锻炼，因为他们可以只需跟随音频指示。
- en: 'Here is how we are going to support exercise tracking using audio clues:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将如何使用音频线索支持锻炼跟踪的方法：
- en: A ticking clock soundtrack progress during the exercise
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在锻炼期间播放滴答声音轨
- en: A half-way indicator sounds, indicating that the exercise is halfway through
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一声半程指示器响起，表明锻炼已经进行了一半
- en: An exercise-completion audio clip plays when the exercise is about to end
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当锻炼即将结束时，会播放一个锻炼完成的音频片段
- en: An audio clip plays during the rest phase and informs users about the next exercise
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在休息阶段播放音频片段，通知用户下一个锻炼
- en: There will be an audio clip for each of these scenarios.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 每种情况都会有一个音频片段。
- en: Modern browsers have good support for audio. The HTML5 `<audio>` tag provides
    a mechanism to embed audio clips into HTML content. We too will use the `<audio>` tag
    to play back our clips.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器对音频有很好的支持。HTML5的`<audio>`标签提供了一种将音频片段嵌入HTML内容的机制。我们也将使用`<audio>`标签来播放我们的片段。
- en: Since the plan is to use the HTML `<audio>` element, we need to create a wrapper
    directive that allows us to control audio elements from Angular. Remember that
    directives are HTML extensions without a view.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计划使用HTML `<audio>` 元素，我们需要创建一个包装指令，允许我们从Angular控制音频元素。请记住，指令是没有视图的HTML扩展。
- en: The `checkpoint3.4` Git and the `trainer/static/audio` folder contain all the
    audio files used for playback; copy them first. If you are not using Git, a snapshot
    of the chapter code is available at [http://bit.ly/ng6be-checkpoint-3-4](http://bit.ly/ng6be-checkpoint-3-4).
    Download and unzip the contents and copy the audio files.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkpoint3.4` Git和`trainer/static/audio`文件夹包含用于播放的所有音频文件；首先复制它们。如果你不使用Git，章节代码的快照可以在[http://bit.ly/ng6be-checkpoint-3-4](http://bit.ly/ng6be-checkpoint-3-4)下载并解压内容并复制音频文件。'
- en: Building Angular directives to wrap HTML audio
  id: totrans-729
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Angular指令来包装HTML音频
- en: If you have worked a lot with JavaScript and jQuery, you may have realized we have
    purposefully shied away from directly accessing the DOM for any of our component
    implementations. There has not been a need to do it. The Angular data-binding
    infrastructure, including property, attribute, and event binding, has helped us
    manipulate HTML without touching the DOM.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在JavaScript和jQuery上有很多工作经验，你可能已经意识到我们有意地避免直接访问DOM来实现任何组件。目前还没有这样的需要。Angular的数据绑定基础设施，包括属性、属性和事件绑定，帮助我们在不触摸DOM的情况下操作HTML。
- en: For the audio element too, the access pattern should be Angularish. In Angular,
    the only place where direct DOM manipulation is acceptable and practiced is inside
    directives. Let's create a directive that wraps access to audio elements.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 对于音频元素，访问模式也应符合Angular的规范。在Angular中，唯一可以接受和实践直接DOM操作的地方是在指令内部。让我们创建一个包装对音频元素访问的指令。
- en: 'Navigate to `trainer/src/app/shared` and run this command to generate a template
    directive:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`trainer/src/app/shared`并运行以下命令以生成模板指令：
- en: '[PRE108]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Since it is the first time we are creating a directive, we encourage you to
    look at the generated code.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们第一次创建指令，我们鼓励您查看生成的代码。
- en: 'Since the directive is added to the shared module, it needs to be exported
    too. Add the `MyAudioDirective` reference in the `exports` array too (`shared.module.ts`).
    Then update the directive definition with the following code:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该指令已添加到共享模块中，因此也需要导出。在`exports`数组中也添加`MyAudioDirective`引用（`shared.module.ts`）。然后使用以下代码更新指令定义：
- en: '[PRE109]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The `MyAudioDirective` class is decorated with `@Directive`. The `@Directive` decorator
    is similar to the `@Component` decorator except we cannot have an attached view.
    Therefore, no `template` or `templateUrl` is allowed!
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyAudioDirective`类被装饰为`@Directive`。`@Directive`装饰器类似于`@Component`装饰器，只是我们不能有附加的视图。因此，不允许有`template`或`templateUrl`！'
- en: The preceding `selector` property allows the framework to identify where to
    apply the directive. We have replaced the generated `[abeMyAudioDirective]` attribute
    selector with just `audio`. Using `audio` as the selector makes our directive
    load for every `<audio>` tag used in HTML. The new selector works as an element
    selector.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`selector`属性允许框架识别应用指令的位置。我们用`audio`替换了生成的`[abeMyAudioDirective]`属性选择器。使用`audio`作为选择器使我们的指令在HTML中使用的每个`<audio>`标签中加载。新的选择器作为元素选择器起作用。
- en: In a standard scenario, directive selectors are attribute-based (such as `[abeMyAudioDirective]` for
    the generated code), which helps us identify where the directive has been applied.
    We deviate from this norm and use an element selector for the `MyAudioDirective` directive.
    We want this directive to be loaded for every audio element, and it becomes cumbersome
    to go to each audio declaration and add a directive-specific attribute. Hence
    an element selector.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准情况下，指令选择器是基于属性的（例如生成的代码中的`[abeMyAudioDirective]`），这有助于我们识别指令的应用位置。我们偏离了这个规范，使用了元素选择器来定义`MyAudioDirective`指令。我们希望该指令加载到每个音频元素中，因此逐个音频声明并添加特定指令属性变得繁琐。因此使用了元素选择器。
- en: The use of `exportAs` becomes clear when we use this directive in view templates.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在视图模板中使用该指令时，使用`exportAs`的用途变得清晰起来。
- en: The `ElementRef` object injected in the constructor is the Angular element (`audio` in
    this case) for which the directive is loaded. Angular creates the `ElementRef` instance
    for every component and directive when it compiles and executes the HTML template.
    When requested in the constructor, the DI framework locates the corresponding `ElementRef` and
    injects it. We use `ElementRef` to get hold of the underlying audio element in
    the code (the instance of `HTMLAudioElement`). The `audioPlayer` property holds
    this reference.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中注入的`ElementRef`对象是Angular元素（在本例中为`audio`），用于加载指令。当Angular编译和执行HTML模板时，会为每个组件和指令创建`ElementRef`实例。在构造函数中请求时，DI框架会定位相应的`ElementRef`并注入它。我们使用`ElementRef`在代码中获取基础音频元素（`HTMLAudioElement`的实例）。`audioPlayer`属性保存了这个引用。
- en: 'The directive now needs to expose an API to manipulate the audio player. Add
    these functions to the `MyAudioDirective` directive:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令现在需要暴露一个API来操作音频播放器。将这些函数添加到`MyAudioDirective`指令中：
- en: '[PRE110]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The `MyAudioDirective` API has two functions (`start` and `stop`) and three
    getters (`currentTime`, `duration`, and a Boolean property called `playbackComplete`).
    The implementations for these functions and properties just wrap the audio element
    functions.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyAudioDirective` API有两个函数（`start`和`stop`）和三个getter（`currentTime`，`duration`，以及一个名为`playbackComplete`的布尔属性）。这些函数和属性的实现只是包装了音频元素的函数。'
- en: Learn about these audio functions from the MDN documentation here: [http://bit.ly/html-media-element](http://bit.ly/html-media-element).
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 从MDN文档中了解这些音频函数：[http://bit.ly/html-media-element](http://bit.ly/html-media-element)。
- en: To understand how we use the audio directive, let's create a new component that
    manages audio playback.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解我们如何使用音频指令，让我们创建一个新的组件来管理音频播放。
- en: Creating WorkoutAudioComponent for audio support
  id: totrans-747
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为音频支持创建WorkoutAudioComponent
- en: If we go back and look at the audio cues that are required, there are four distinct
    audio cues, and hence we are going to create a component with five embedded `<audio>` tags
    (two audio tags work together for next-up audio).
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回头看一下所需的音频提示，有四个不同的音频提示，因此我们将创建一个带有五个嵌入的`<audio>`标签的组件（两个音频标签一起工作以提供接下来的音频）。
- en: From the command line go to the `trainer/src/app/workout-runner` folder and
    add a new `WorkoutAudioComponent` component using Angular CLI.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行转到`trainer/src/app/workout-runner`文件夹，并使用Angular CLI添加一个新的`WorkoutAudioComponent`组件。
- en: 'Open `workout-audio.component.html` and replace the existing view template
    with this HTML snippet:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`workout-audio.component.html`并用这个HTML片段替换现有的视图模板：
- en: '[PRE111]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'There are five `<audio>` tags, one for each of the following:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 有五个`<audio>`标签，分别用于以下内容：
- en: '**Ticking audio**: The first audio tag produces the ticking sound and is started as
    soon as the workout starts.'
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滴答声音**：第一个音频标签产生滴答声音，并在训练开始时开始播放。'
- en: '**Next up audio and exercise audio**: There next two audio tags work together.
    The first tag produces the "Next up" sound. And the actual exercise audio is handled
    by the third tag (in the preceding code snippet).'
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接下来是音频和练习音频**：接下来的两个音频标签一起工作。第一个标签产生“接下来”声音。实际的练习音频由第三个标签处理（在前面的代码片段中）。'
- en: '**Halfway audio**: The fourth audio tag plays halfway through the exercise.'
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中途音频**：第四个音频标签在练习进行到一半时播放。'
- en: '**About to complete audio**: The final audio tag plays a piece to denote the
    completion of an exercise.'
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**即将完成的音频**：最后一个音频标签播放一段音乐以表示练习的完成。'
- en: Did you notice the usage of the `#` symbol in each of the `audio` tags? There
    are some variable assignments prefixed with `#`. In the Angular world, these variables are
    known as **template reference variables** or at times **template variables**.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到了每个`audio`标签中`#`符号的使用？有一些以`#`为前缀的变量赋值。在Angular世界中，这些变量被称为**模板引用变量**或者有时候是**模板变量**。
- en: 'As the platform guide defines:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 正如平台指南所定义的：
- en: A template reference variable is often a reference to a DOM element or directive
    within a template.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引用变量通常是模板中的DOM元素或指令的引用。
- en: Don't confuse them with the template input variables that we have used with
    the `ngFor` directive earlier, `*ngFor="let` video `of videos"`. The **template
    input variable's** (`video` in this case) scope is within the HTML fragment it
    is declared, whereas the template reference variable can be accessed across the
    entire template.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将它们与我们之前与`ngFor`指令一起使用的模板输入变量混淆，`*ngFor="let video of videos"`。**模板输入变量**（在这种情况下是`video`）的作用域仅限于它声明的HTML片段内，而模板引用变量可以在整个模板中访问。
- en: 'Look at the last section where `MyAudioDirective` was defined. The `exportAs` metadata
    is set to `MyAudio`. We repeat that same `MyAudio` string while assigning the `template
    reference variable` for each audio tag:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下上一节中定义了`MyAudioDirective`的部分。`exportAs`元数据设置为`MyAudio`。我们在为每个音频标签分配`模板引用变量`时重复了相同的`MyAudio`字符串：
- en: '[PRE112]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The role of `exportAs` is to define the name that can be used in the view to
    assign this directive to a variable. Remember, a single element/component can
    have multiple directives applied to it. `exportAs` allows us to select which directive
    should be assigned to a template-reference variable based on what is on the right
    side of equals.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '`exportAs`的作用是定义可以在视图中用来将该指令分配给变量的名称。请记住，单个元素/组件可以应用多个指令。`exportAs`允许我们根据等号右侧的内容选择应该分配给模板引用变量的指令。'
- en: Typically, template variables, once declared, give access to the view element/component
    they are attached to, to other parts of the view, something we will discuss shortly.
    But in our case, we will use template variables to refer to the multiple `MyAudioDirective` from
    the parent component's code. Let's understand how to use them.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一旦声明了模板变量，就可以访问它们所附加的视图元素/组件，我们很快会讨论这一点。但在我们的情况下，我们将使用模板变量来引用父组件代码中的多个`MyAudioDirective`。让我们了解如何使用它们。
- en: 'Update the generated `workout-audio.compnent.ts` with the following outline:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下大纲更新生成的`workout-audio.compnent.ts`：
- en: '[PRE113]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The interesting bit in this outline is the `@ViewChild` decorator against the
    five properties. The `@ViewChild` decorator allows us to inject a child component/directive/element
    reference into its parent. The parameter passed to the decorator is the template
    variable name, which helps DI match the element/directive to inject. When Angular
    instantiates the main `WorkoutAudioComponent`, it injects the corresponding audio
    directives based on the `@ViewChild` decorator and the template reference variable
    name passed. Let's complete the basic class implementation before we look at `@ViewChild` in
    detail.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 这个大纲中有趣的部分是针对五个属性的`@ViewChild`装饰器。`@ViewChild`装饰器允许我们将子组件/指令/元素引用注入到其父组件中。传递给装饰器的参数是模板变量名称，它有助于DI匹配要注入的元素/指令。当Angular实例化主`WorkoutAudioComponent`时，它根据`@ViewChild`装饰器和传递的模板引用变量名称注入相应的音频指令。让我们在详细查看`@ViewChild`之前完成基本的类实现。
- en: Without `exportAs` set on the `MyAudioDirective` directive, the `@ViewChild` injection
    injects the related `ElementRef` instance instead of the `MyAudioDirective` instance.
    We can confirm this by removing the `exportAs` attribute from `myAudioDirective` and
    then looking at the injected dependencies in `WorkoutAudioComponent`.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有在`MyAudioDirective`指令上设置`exportAs`，那么`@ViewChild`注入将会注入相关的`ElementRef`实例，而不是`MyAudioDirective`实例。我们可以通过从`myAudioDirective`中删除`exportAs`属性，然后查看`WorkoutAudioComponent`中注入的依赖项来确认这一点。
- en: 'The remaining task is to just play the correct audio component at the right
    time. Add these functions to `WorkoutAudioComponent`:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的任务只是在正确的时间播放正确的音频组件。将这些函数添加到`WorkoutAudioComponent`中：
- en: '[PRE114]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Having trouble writing these functions? They are available in the `checkpoint3.3` Git
    branch.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 在写这些函数时遇到了困难吗？它们可以在`checkpoint3.3` Git分支中找到。
- en: 'There are two new model classes used in the preceding code. Add their declarations
    to `model.ts`, as follows (again available in `checkpoint3.3`):'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中使用了两个新的模型类。将它们的声明添加到`model.ts`中，如下所示（同样可以在`checkpoint3.3`中找到）：
- en: '[PRE115]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: These are model classes to track progress events. The `WorkoutAudioComponent` implementation
    consumes this data. Remember to import the reference for `ExerciseProgressEvent` and `ExerciseProgressEvent` in `workout-audio.component.ts`.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是用于跟踪进度事件的模型类。`WorkoutAudioComponent`的实现会消耗这些数据。记得在`workout-audio.component.ts`中导入`ExerciseProgressEvent`和`ExerciseProgressEvent`的引用。
- en: To reiterate, the audio component consumes the events by defining two event
    handlers: `onExerciseProgress` and `onExerciseChanged.` How the events are generated
    becomes clear as we move along.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 重申一下，音频组件通过定义两个事件处理程序`onExerciseProgress`和`onExerciseChanged`来消耗这些事件。随着我们的进展，事件是如何生成的就变得清晰了。
- en: The `start` and `resume` functions stop and resume audio whenever a workout
    starts, pauses, or completes. The extra complexity in the resume function it to
    tackle cases when the workout was paused during next up, about to complete, or
    half-way audio playback. We just want to continue from where we left off.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`和`resume`函数在开始、暂停或完成训练时停止和恢复音频。在恢复函数中的额外复杂性是解决训练在下一个练习、即将完成或半程音频播放时被暂停的情况。我们只想从上次离开的地方继续。'
- en: The `onExerciseProgress` function should be called to report the workout progress.
    It's used to play the halfway audio and about-to-complete audio based on the state
    of the workout. The parameter passed to it is an object that contains exercise
    progress data.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 应该调用`onExerciseProgress`函数来报告训练进度。它用于根据训练的状态播放半程音频和即将完成音频。传递给它的参数是一个包含练习进度数据的对象。
- en: The `onExerciseChanged` function should be called when the exercise changes.
    The input parameter contains the current and next exercise in line and helps `WorkoutAudioComponent` to
    decide when to play the next up exercise audio.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 当练习改变时，应该调用`onExerciseChanged`函数。输入参数包含当前和下一个练习，并帮助`WorkoutAudioComponent`决定何时播放下一个练习的音频。
- en: 'We touched upon two new concepts in this section: template reference variables
    and injecting child elements/directives into the parent. It''s worth exploring
    these two concepts in more detail before we continue with the implementation.
    We''ll start with learning more about template reference variables.'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们涉及了两个新概念：模板引用变量和将子元素/指令注入到父元素中。在继续实现之前，值得更详细地探索这两个概念。我们将从学习更多关于模板引用变量开始。
- en: Understanding template reference variables
  id: totrans-780
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模板引用变量
- en: '**Template reference variables** are created on the view template and are mostly
    consumed from the view. As you have already learned, these variables can be identified
    by the `#` prefix used to declare them.'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板引用变量**是在视图模板上创建的，大部分是从视图中消耗的。正如你已经学到的，这些变量可以通过`#`前缀来识别。'
- en: 'One of the greatest benefits of template variables is that they facilitate
    cross-component communication at the view template level. Once declared, such
    variables can be referenced by sibling elements/components and their children.
    Check out the following snippet:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 模板变量的最大好处之一是它们在视图模板级别促进了跨组件通信。一旦声明，这些变量可以被同级元素/组件及其子元素引用。看看下面的代码片段：
- en: '[PRE116]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This snippet declares a template variable, `emailId`, and then references it
    in the interpolation and the button `click` expression.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码声明了一个模板变量`emailId`，然后在插值和按钮的`click`表达式中引用它。
- en: The Angular templating engine assigns the DOM object for `input` (an instance
    of `HTMLInputElement`) to the `emailId` variable. Since the variable is available
    across siblings, we use it in a button's `click` expression.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: Angular模板引擎将`input`的DOM对象（一个`HTMLInputElement`的实例）分配给`emailId`变量。由于变量在同级元素中可用，我们在按钮的`click`表达式中使用它。
- en: 'Template variables work with components too. We can easily do this:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 模板变量也适用于组件。我们可以轻松地这样做：
- en: '[PRE117]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: In this case, `runner` has a reference to the `WorkoutRunnerComponent` object,
    and the button is used to start the workout.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`runner`引用了`WorkoutRunnerComponent`对象，并且按钮用于开始锻炼。
- en: The `ref-` prefix is the canonical alternative to `#`. The `#runner` variable
    can also be declared as `ref-runner`.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref-`前缀是`#`的规范替代品。`#runner`变量也可以声明为`ref-runner`。'
- en: Template variable assignment
  id: totrans-790
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板变量分配
- en: 'You may not have noticed but there is something interesting about the template variable
    assignments described in the last few sections. To recap, the three examples that
    we have used are:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能没有注意到，但在最近几节中描述的模板变量分配中有一些有趣的地方。回顾一下，我们使用的三个示例是：
- en: '[PRE118]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'What got assigned to the variable depends on where the variable was declared.
    This is governed by rules in Angular:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 变量分配取决于变量声明的位置。这受Angular中的规则约束：
- en: If a directive is present on the element, such as `MyAudioDirective` in the
    first example shown previously, the directive sets the value. The `MyAudioDirective` directive
    sets the `ticks` variable to an instance of `MyAudioDirective`.
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果元素上存在指令，例如在先前显示的第一个示例中的`MyAudioDirective`，则指令设置该值。`MyAudioDirective`指令将`ticks`变量设置为`MyAudioDirective`的一个实例。
- en: If there is no directive present, either the underlying HTML DOM element is
    assigned or a component object is assigned (as shown in the `input` and `workout-runner` examples).
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有指令存在，要么分配基础HTML DOM元素，要么分配一个组件对象（如`input`和`workout-runner`示例中所示）。
- en: We will be employing this technique to implement the workout audio component
    integration with the workout runner component. This introduction gives us the
    head start that we need.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用这种技术来实现锻炼音频组件与锻炼运行器组件的集成。这个介绍给了我们我们需要的先发优势。
- en: The other new concept that we promised to cover is child element/directive injection
    using the `ViewChild` and `ViewChildren` decorators.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 我们承诺要介绍的另一个新概念是使用`ViewChild`和`ViewChildren`装饰器进行子元素/指令注入。
- en: Using the @ViewChild decorator
  id: totrans-798
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@ViewChild装饰器
- en: The `@ViewChild` decorator instructs the Angular DI framework to search for
    some specific child component/directive/element in the component tree and inject
    it into the parent. This allows the parent component to interact with child components/element
    using the reference to the child, a new communication pattern!
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ViewChild`装饰器指示Angular DI框架在组件树中搜索特定的子组件/指令/元素，并将其注入到父组件中。这允许父组件使用对子组件的引用与子组件/元素进行交互，这是一种新的通信模式！'
- en: In the preceding code, the audio element directive (the `MyAudioDirective` class)
    is injected into the `WorkoutAudioComponent` code.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，音频元素指令（`MyAudioDirective`类）被注入到`WorkoutAudioComponent`代码中。
- en: 'To establish the context, let''s recheck a view fragment from `WorkoutAudioComponent`:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立上下文，让我们重新检查一下`WorkoutAudioComponent`中的视图片段：
- en: '[PRE119]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Angular injects the directive (`MyAudioDirective`) into the `WorkoutAudioComponent` property: `ticks`.
    The search is done based on the selector passed to the `@ViewChild` decorator.
    Let''s see the audio example again:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: Angular将指令（`MyAudioDirective`）注入到`WorkoutAudioComponent`属性：`ticks`。搜索是基于传递给`@ViewChild`装饰器的选择器进行的。让我们再次看一下音频示例：
- en: '[PRE120]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The selector parameter on `ViewChild` can be a string value, in which case Angular
    searches for a matching template variable, as before.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewChild`的选择器参数可以是一个字符串值，在这种情况下，Angular会搜索匹配的模板变量，就像以前一样。'
- en: 'Or it can be a *type.* This is valid and should inject an instance of `MyAudioDirective`:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它可以是一个*类型*。这是有效的，应该注入`MyAudioDirective`的一个实例：
- en: '[PRE121]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: However, it does not work in our case. Why? Because there are multiple `MyAudioDirective` directives
    declared in the `WorkoutAudioComponent` view, one for each of the `<audio>` tags.
    In such a scenario, the first match is injected. Not very useful. Passing the
    type selector would have worked if there was only one `<audio>` tag in the view!
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的情况下，它不起作用。为什么？因为在`WorkoutAudioComponent`视图中声明了多个`MyAudioDirective`指令，每个`<audio>`标签都有一个。在这种情况下，只会注入第一个匹配项。并不是很有用。如果视图中只有一个`<audio>`标签，那么传递类型选择器就可以起作用！
- en: Properties decorated with `@ViewChild` are sure to be set before the `ngAfterViewInit` event
    hook on the component is called. This implies such properties are `null` if accessed
    inside the constructor.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@ViewChild`装饰的属性在调用组件的`ngAfterViewInit`事件钩子之前肯定会被设置。这意味着如果在构造函数中访问这些属性，它们将是`null`。
- en: Angular also has a decorator to locate and inject multiple child components/directives: `@ViewChildren`.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: Angular还有一个装饰器来定位和注入多个子组件/指令：`@ViewChildren`。
- en: The @ViewChildren decorator
  id: totrans-811
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@ViewChildren装饰器'
- en: '`@ViewChildren` works similarly to `@ViewChild`, except it can be used to inject
    multiple child types into the parent. Again taking the previous audio component
    above as an example, using `@ViewChildren`, we can get all the `MyAudioDirective` directive
    instances in `WorkoutAudioComponent`, as shown here:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ViewChildren`的工作方式与`@ViewChild`类似，只是它可以用来将多个子类型注入到父组件中。再次以上面的音频组件为例，使用`@ViewChildren`，我们可以在`WorkoutAudioComponent`中获取所有`MyAudioDirective`指令的实例，如下所示：'
- en: '[PRE122]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Look carefully; `allAudios` is not a standard JavaScript array, but a custom
    class, `QueryList<Type>`. The `QueryList` class is an immutable collection that
    contains the reference to the components/directives that Angular was able to locate
    based on the filter criteria passed to the `@ViewChildren` decorator. The best
    thing about this list is that Angular will keep this list in sync with the state
    of the view. When directives/components get added/removed from the view dynamically,
    this list is updated too. Components/directives generated using `ng-for` are a
    prime example of this dynamic behavior. Consider the preceding `@ViewChildren` usage
    and this view template:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看；`allAudios`不是标准的JavaScript数组，而是一个自定义类`QueryList<Type>`。`QueryList`类是一个不可变的集合，其中包含了Angular能够根据传递给`@ViewChildren`装饰器的过滤条件定位到的组件/指令的引用。这个列表最好的地方在于Angular会将这个列表与视图的状态保持同步。当动态地向视图中添加/移除指令/组件时，这个列表也会被更新。使用`ng-for`生成的组件/指令就是这种动态行为的一个典型例子。考虑前面的`@ViewChildren`用法和这个视图模板：
- en: '[PRE123]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The number of `MyAudioDirective` directives created by Angular depends upon
    the number of `clips`. When `@ViewChildren` is used, Angular injects the correct
    number of `MyAudioDirective` instances into the `allAudio` property and keeps
    it in sync when items are added or removed from the `clips` array.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: Angular创建的`MyAudioDirective`指令的数量取决于`clips`的数量。当使用`@ViewChildren`时，Angular会将正确数量的`MyAudioDirective`实例注入到`allAudio`属性中，并在从`clips`数组中添加或移除项目时保持同步。
- en: While the usage of `@ViewChildren` allows us to get hold of all `MyAudioDirective` directives,
    it cannot be used to control the playback. You see, we need to get hold of individual `MyAudioDirective` instances
    as the audio playback timing varies. Hence the distinct `@ViewChild` implementation.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用`@ViewChildren`允许我们获取所有`MyAudioDirective`指令，但它不能用于控制播放。你看，我们需要获取单独的`MyAudioDirective`实例，因为音频播放的时间不同。因此需要使用不同的`@ViewChild`实现。
- en: Once we get hold of the `MyAudioDirective` directive attached to each audio
    element, it is just a matter of playing the audio tracks at the right time.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了附加到每个音频元素的`MyAudioDirective`指令，只需要在正确的时间播放音频轨道。
- en: Integrating WorkoutAudioComponent
  id: totrans-819
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成WorkoutAudioComponent
- en: While we have componentized the audio playback functionality into `WorkoutAudioComponent`,
    it is and always will be tightly coupled to the `WorkoutRunnerComponent` implementation. `WorkoutAudioComponent` derives
    its operational intelligence from `WorkoutRunnerComponent`. Hence the two components
    need to interact. `WorkoutRunnerComponent` needs to provide the `WorkoutAudioComponent` state
    change data, including when the workout started, exercise progress, workout stopped,
    paused, and resumed.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经将音频播放功能组件化为`WorkoutAudioComponent`，但它始终与`WorkoutRunnerComponent`实现紧密耦合。`WorkoutAudioComponent`从`WorkoutRunnerComponent`获取其操作智能。因此，这两个组件需要互动。`WorkoutRunnerComponent`需要提供`WorkoutAudioComponent`的状态变化数据，包括锻炼开始、练习进度、锻炼停止、暂停和恢复时的数据。
- en: One way to achieve this integration would be to use the currently exposed `WorkoutAudioComponent` API
    (stop, resume, and other functions) from `WorkoutRunnerComponent`.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种集成的一种方法是从`WorkoutRunnerComponent`中使用当前公开的`WorkoutAudioComponent`API（停止、恢复和其他函数）。
- en: Something can be done by injecting `WorkoutAudioComponent` into `WorkoutRunnerComponent`,
    as we did earlier when we injected `MyAudioDirective` into `WorkoutAudioComponent`.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将`WorkoutAudioComponent`注入到`WorkoutRunnerComponent`中来完成某些操作，就像我们之前将`MyAudioDirective`注入到`WorkoutAudioComponent`中一样。
- en: 'Declare the `WorkoutAudioComponent` in the `WorkoutRunnerComponent''s` view,
    such as:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WorkoutRunnerComponent`的视图中声明`WorkoutAudioComponent`，如下所示：
- en: '[PRE124]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Doing so gives us a reference to the `WorkoutAudioComponent` inside the `WorkoutRunnerComponent` implementation:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以在`WorkoutRunnerComponent`实现中获得对`WorkoutAudioComponent`的引用：
- en: '[PRE125]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The `WorkoutAudioComponent` functions can then be invoked from `WorkoutRunnerComponent` from
    different places in the code. For example, this is how `pause` would change:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以从代码的不同位置从`WorkoutRunnerComponent`中调用`WorkoutAudioComponent`函数。例如，这就是`pause`会发生变化的方式：
- en: '[PRE126]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'And to play the next-up audio, we would need to change parts of the `startExerciseTimeTracking` function:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要播放下一个音频，我们需要更改`startExerciseTimeTracking`函数的部分内容：
- en: '[PRE127]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: This is a perfectly viable option where `WorkoutAudioComponent` becomes a dumb
    component controlled by `WorkoutRunnerComponent`. The only problem with this solution
    is that it adds some noise to the `WorkoutRunnerComponent` implementation. `WorkoutRunnerComponent` now
    needs to manage audio playback too.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完全可行的选择，其中`WorkoutAudioComponent`成为由`WorkoutRunnerComponent`控制的哑组件。这种解决方案唯一的问题是它给`WorkoutRunnerComponent`的实现增加了一些噪音。`WorkoutRunnerComponent`现在也需要管理音频播放。
- en: There is an alternative, however.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一种替代方法。
- en: '`WorkoutRunnerComponent` can expose events that are triggered during different
    times of workout execution, such as workout started, exercise started, and workout
    paused. The advantage of having `WorkoutRunnerComponent` expose events is that
    it allows us to integrate other components/directives with `WorkoutRunnerComponent` using
    the same events. Be it the `WorkoutAudioComponent` or components we create in
    future.'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutRunnerComponent`可以公开在锻炼执行的不同时间触发的事件，例如锻炼开始、练习开始和锻炼暂停。`WorkoutRunnerComponent`公开事件的优势在于，它允许我们使用相同的事件将其他组件/指令与`WorkoutRunnerComponent`集成。无论是`WorkoutAudioComponent`还是我们将来创建的组件。'
- en: Exposing WorkoutRunnerComponent events
  id: totrans-834
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公开WorkoutRunnerComponent事件
- en: Till now we have only explored how to consume events. Angular allows us to raise
    events too. Angular components and directives can expose custom events using the `EventEmitter` class
    and the `@Output` decorator.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只探讨了如何消费事件。Angular还允许我们触发事件。Angular组件和指令可以使用`EventEmitter`类和`@Output`装饰器公开自定义事件。
- en: 'Add these event declarations to `WorkoutRunnerComponent` at the end of the
    variable declaration section:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量声明部分的末尾，将这些事件声明添加到`WorkoutRunnerComponent`中：
- en: '[PRE128]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The names of the events are self-explanatory, and within our `WorkoutRunnerComponent` implementation,
    we need to raise them at the appropriate times.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的名称是不言自明的，在我们的WorkoutRunnerComponent实现中，我们需要在适当的时候引发它们。
- en: Remember to add the `ExerciseProgressEvent` and `ExerciseChangeEvent` imports
    to the `model` already declared on top. And add the `Output` and `EventEmitter` imports
    to `@angular/core`.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将ExerciseProgressEvent和ExerciseChangeEvent导入到已在顶部声明的model中。并将Output和EventEmitter导入到@angular/core中。
- en: Let's try to understand the role of the `@Output` decorator and the `EventEmitter` class.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着理解@Output装饰器和EventEmitter类的作用。
- en: The @Output decorator
  id: totrans-841
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Output装饰器'
- en: We covered a decent amount of Angular eventing capabilities in this chapter. Specifically,
    we learned how we can consume any event on a component, directive, or DOM element
    using the `bracketed ()` syntax. How about raising our own events?
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了相当多的Angular事件处理能力。具体来说，我们学会了如何使用括号()语法在组件、指令或DOM元素上消耗任何事件。那我们如何引发自己的事件呢？
- en: In Angular, we can create and raise our own events, events that signify something
    noteworthy has happened in our component/directive. Using the `@Output` decorator
    and the `EventEmitter` class, we can define and raise custom events.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，我们可以创建和引发自己的事件，这些事件表示组件/指令中发生了值得注意的事情。使用@Output装饰器和EventEmitter类，我们可以定义和引发自定义事件。
- en: It's also a good time to refresh what we learned about events.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候复习一下我们对事件的了解了。
- en: 'Remember this: it is through events that components can communicate with the
    outside world. When we declare:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：正是通过事件，组件才能与外部世界进行通信。当我们声明：
- en: '[PRE129]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: It signifies that `WorkoutRunnerComponent` exposes an event, `exercisePaused` (raised
    when the workout is paused).
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 它表示WorkoutRunnerComponent公开了一个事件，即exercisePaused（当锻炼暂停时引发）。
- en: 'To subscribe to this event, we can do the following:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 要订阅此事件，我们可以这样做：
- en: '[PRE130]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'This looks absolutely similar to how we did the DOM event subscription in the
    workout runner template. See this sample stipped from the workout-runner''s view:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与我们在workout runner模板中进行DOM事件订阅的方式非常相似。看看从workout-runner的视图中剥离出来的这个示例：
- en: '[PRE131]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The `@Output` decorator instructs Angular to make this event available for template
    binding. Events created without the `@Output` decorator cannot be referenced in
    HTML.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '@Output装饰器指示Angular使此事件可用于模板绑定。没有@Output装饰器创建的事件不能在HTML中引用。'
- en: 'The `@Output` decorator can also take a parameter, signifying the name of the
    event. If not provided, the decorator uses the property name: `@Output("workoutPaused")
    exercisePaused: EventEmitter<number> ...`. This declares a `workoutPaused` event
    instead of `exercisePaused`.'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: '@Output装饰器还可以带一个参数，表示事件的名称。如果未提供，装饰器将使用属性名称：@Output("workoutPaused") exercisePaused:
    EventEmitter<number> ...。这将声明一个workoutPaused事件，而不是exercisePaused。'
- en: Like any decorator, the `@Output` decorator is there just to provide metadata
    for the Angular framework to work with. The real heavy lifting is done by the `EventEmitter` class.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何装饰器一样，@Output装饰器只是为了提供Angular框架使用的元数据。真正的重活是由EventEmitter类完成的。
- en: Eventing with EventEmitter
  id: totrans-855
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EventEmitter进行事件处理
- en: Angular embraces **reactive programming** (also dubbed **Rx**-style programming)
    to support asynchronous operations with events. If you are hearing this term for
    the first time or don't have much idea about what reactive programming is, you're
    not alone.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: Angular采用**响应式编程**（也称为**Rx**风格编程）来支持事件的异步操作。如果您第一次听到这个术语，或者对响应式编程不太了解，那么您并不孤单。
- en: Reactive programming is all about programming against **asynchronous data streams**.
    Such a stream is nothing but a sequence of ongoing events ordered based on the
    time they occur. We can imagine a stream as a pipe generating data (in some manner)
    and pushing it to one or more subscribers. Since these events are captured asynchronously
    by subscribers, they are called asynchronous data streams.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程就是针对**异步数据流**进行编程。这样的流实际上就是按时间顺序排列的一系列持续事件。我们可以将流想象成一个生成数据（以某种方式）并将其推送给一个或多个订阅者的管道。由于这些事件被订阅者异步捕获，它们被称为异步数据流。
- en: The data can be anything, ranging from browser/DOM element events to user input
    to loading remote data using AJAX. With *Rx* style, we consume this data uniformly.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以是任何东西，从浏览器/DOM元素事件到用户输入再到使用AJAX加载远程数据。使用*Rx*风格，我们统一消耗这些数据。
- en: In the Rx world, there are Observers and Observables, a concept derived from
    the very popular **Observer design pattern**. **Observables** are streams that
    emit data. **Observers**, on the other hand, subscribe to these events.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rx世界中，有观察者和可观察对象，这是从非常流行的**观察者设计模式**派生出来的概念。**可观察对象**是发出数据的流。**观察者**则订阅这些事件。
- en: The `EventEmitter` class in Angular is primarily responsible for providing eventing
    support. It acts both as an *observer* and *observable*. We can fire events on
    it and it can also listen to events.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中的`EventEmitter`类主要负责提供事件支持。它既充当*观察者*又充当*可观察对象*。我们可以在其上触发事件，它也可以监听事件。
- en: 'There are two functions available on `EventEmitter` that are of interest to
    us:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter`上有两个我们感兴趣的函数：'
- en: '`emit`: As the name suggests, use this function to raise events. It takes a
    single argument that is the event data. `emit` *is the observable side*.'
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emit`：顾名思义，使用此函数来触发事件。它接受一个事件数据作为参数。`emit`*是可观察对象的一面*。'
- en: '`subscribe`: Use this function to subscribe to the events raised by `EventEmitter`. `subscribe` is
    the observer side.'
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe`：使用此函数订阅`EventEmitter`触发的事件。`subscribe`是观察者的一面。'
- en: Let's do some event publishing and subscriptions to understand how the preceding
    functions work.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一些事件发布和订阅，以了解前述函数如何工作。
- en: Raising events from WorkoutRunnerComponent
  id: totrans-865
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从WorkoutRunnerComponent触发事件
- en: Look at the `EventEmitter` declaration. These have been declared with the `type` parameter.
    The `type` parameter on `EventEmitter` signifies the type of data emitted.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`EventEmitter`声明。这些已经用`type`参数声明了。`EventEmitter`上的`type`参数表示发出的数据类型。
- en: Let's add the event implementation to `workout-runner.component.ts`, starting
    from the top of the file and moving down.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将事件实现添加到`workout-runner.component.ts`，从文件顶部开始向下移动。
- en: 'Add this statement to the end of the `start` function:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 在`start`函数的末尾添加此语句：
- en: '[PRE132]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: We use the `emit` function of  `EventEmitter`  to raise a `workoutStarted` event
    with the current workout plan as an argument.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`EventEmitter`的`emit`函数来触发带有当前锻炼计划作为参数的`workoutStarted`事件。
- en: 'To `pause`, add this line to raise the `exercisePaused` event:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 要`暂停`，请添加以下行以触发`exercisePaused`事件：
- en: '[PRE133]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'To `resume`, add the following line:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 要`恢复`，请添加以下行：
- en: '[PRE134]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Each time, we pass the current exercise index as an argument to `emit` when
    raising the `exercisePaused` and `exerciseResumed` events.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 每次触发`exercisePaused`和`exerciseResumed`事件时，我们都将当前练习索引作为参数传递给`emit`。
- en: 'Inside the `startExerciseTimeTracking` function, add the highlighted code after
    the call to `startExercise`:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 在`startExerciseTimeTracking`函数中，在调用`startExercise`之后添加突出显示的代码：
- en: '[PRE135]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The argument passed contains the exercise that is going to start (`next`) and
    the next exercise in line (`this.getNextExercise()`).
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 传递的参数包含即将开始的练习（`next`）和队列中的下一个练习（`this.getNextExercise()`）。
- en: 'To the same function, add the highlighted code:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个函数中，添加突出显示的代码：
- en: '[PRE136]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The event is raised when the workout is completed.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 当锻炼完成时引发事件。
- en: 'In the same function, we raise an event that communicates the workout progress.
    Add this statement:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个函数中，我们引发一个事件来传达锻炼进度。添加这个语句：
- en: '[PRE137]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: That completes our eventing implementation.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的事件实现。
- en: As you may have guessed, `WorkoutAudioComponent` now needs to consume these
    events. The challenge here is how to organize these components so that they can
    communicate with each other with the minimum dependency on each other.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，`WorkoutAudioComponent`现在需要消耗这些事件。这里的挑战是如何组织这些组件，以便它们可以以最小的相互依赖来相互通信。
- en: Component communication patterns
  id: totrans-886
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件通信模式
- en: 'As the implementation stands now, we have:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前的实现而言，我们有：
- en: A basic `WorkoutAudioComponent` implementation
  id: totrans-888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基本的`WorkoutAudioComponent`实现
- en: Augmented `WorkoutRunnerComponent` by exposing workout life cycle events
  id: totrans-889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过公开锻炼生命周期事件来增强`WorkoutRunnerComponent`
- en: These two components just need to talk to each other now.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个组件现在只需要相互交流。
- en: 'If the parent needs to communicate with its children, it can do this by:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 如果父组件需要与其子组件通信，可以通过以下方式实现：
- en: '**Property binding**: The parent component can set up a property binding on
    the child component to push data to the child component. For example, this property
    binding can stop the audio player when the workout is paused:'
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性绑定**：父组件可以在子组件上设置属性绑定，将数据推送到子组件。例如，这种属性绑定可以在锻炼暂停时停止音频播放器：'
- en: '[PRE138]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Property binding, in this case, works fine. When the workout is paused, the
    audio is stopped too. But not all scenarios can be handled using property bindings.
    Playing the next exercise audio or halfway audio requires a bit more control.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 属性绑定，在这种情况下，运作良好。当锻炼暂停时，音频也会停止。但并非所有情况都可以使用属性绑定来处理。播放下一个练习音频或中途音频需要更多的控制。
- en: '**Calling functions on child components**: The parent component can also call
    functions on the child component if it can get hold of the child component. We
    have already seen how to achieve this using the `@ViewChild` and `@ViewChildren` decorators
    in the `WorkoutAudioComponent` implementation. This approach and its shortcomings
    have also been discussed briefly in the *Integrating WorkoutAudioComponent* section.'
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在子组件上调用函数**：如果父组件可以获取子组件，父组件也可以调用子组件上的函数。我们已经看到了如何在`WorkoutAudioComponent`实现中使用`@ViewChild`和`@ViewChildren`装饰器来实现这一点。这种方法及其缺点也在*集成WorkoutAudioComponent*部分中简要讨论过。'
- en: There is one more not-so-good option. Instead of the parent referencing the
    child component, the child references the parent component. This allows the child
    component to call the parent component's public functions or subscribe to parent
    component events.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个不太好的选择。而不是父组件引用子组件，子组件引用父组件。这允许子组件调用父组件的公共函数或订阅父组件事件。
- en: We are going to try this approach and then scrap the implementation for a better
    one! A lot of learning can be derived from the not-so-optimal solution we plan
    to implement.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试这种方法，然后放弃实现一个更好的！我们计划实施的不太理想的解决方案可以得到很多的学习。
- en: Injecting a parent component into a child component
  id: totrans-898
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将父组件注入到子组件
- en: 'Add the `WorkoutAudioComponent` to the `WorkoutRunnerComponent` view just before the
    last closing `div`:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 将`WorkoutAudioComponent`添加到`WorkoutRunnerComponent`视图中，就在最后一个闭合的`div`之前：
- en: '[PRE139]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Next, inject `WorkoutRunnerComponent` into `WorkoutAudioComponent`. Open `workout-audio.component.ts` and
    add the following declaration and update the constructor:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`WorkoutRunnerComponent`注入到`WorkoutAudioComponent`中。打开`workout-audio.component.ts`并添加以下声明并更新构造函数：
- en: '[PRE140]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'And remember to add these imports:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 并记得添加这些导入：
- en: '[PRE142]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Let's try to understand what we have done before running the app. There is some
    amount of trickery involved in the construction injection. If we directly try
    to inject `WorkoutRunnerComponent` into `WorkoutAudioComponent`, it fails with
    Angular complaining of not being able to find all the dependencies. Read the code
    and think carefully; there is a subtle dependency cycle issue lurking. `WorkoutRunnerComponent` is
    already dependent on `WorkoutAudioComponent`, as we have referenced `WorkoutAudioComponent` in
    the `WorkoutRunnerComponent` view. Now by injecting `WorkoutRunnerComponent` in `WorkoutAudioComponent`,
    we have created a dependency cycle.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行应用程序之前，让我们试着理解我们之前做了什么。在构造注入中涉及一定程度的诡计。如果我们直接尝试将WorkoutRunnerComponent注入到WorkoutAudioComponent中，它会失败，Angular会抱怨无法找到所有的依赖项。仔细阅读代码并仔细思考；潜在的依赖循环问题正在潜伏。WorkoutRunnerComponent已经依赖于WorkoutAudioComponent，因为我们在WorkoutRunnerComponent视图中引用了WorkoutAudioComponent。现在通过在WorkoutAudioComponent中注入WorkoutRunnerComponent，我们创建了一个依赖循环。
- en: Cyclic dependencies are challenging for any DI framework. When creating a component
    with a cyclic dependency, the framework has to somehow resolve the cycle. In the
    preceding example, we resolve the circular dependency issue by using an `@Inject` decorator
    and passing in the token created using the `forwardRef()` global framework function.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 循环依赖对于任何DI框架来说都是具有挑战性的。当创建具有循环依赖的组件时，框架必须以某种方式解决这个循环。在前面的例子中，我们通过使用@Inject装饰器并传入使用forwardRef()全局框架函数创建的标记来解决循环依赖问题。
- en: Once the injection is done correctly, inside the constructor, we attach a handler
    to the `WorkoutRunnerComponent` events, using the `subscribe` function of `EventEmitter`.
    The arrow function passed to `subscribe` is called whenever the event occurs with
    a specific event argument. We collect all the subscriptions into a `subscription` array.
    This array comes in handy when we unsubscribe, which we need to, to avoid memory
    leaks.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦注入正确完成，在构造函数内，我们使用EventEmitter的subscribe函数将处理程序附加到WorkoutRunnerComponent事件上。传递给subscribe的箭头函数在特定事件发生时被调用，并带有特定的事件参数。我们将所有订阅收集到一个subscription数组中。当我们需要取消订阅时，这个数组非常有用，以避免内存泄漏。
- en: 'A bit about `EventEmitter`: the `EventEmmiter` subscription (`subscribe` function)
    takes three arguments:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 关于EventEmitter：EventEmmiter订阅（subscribe）函数有三个参数：
- en: '[PRE143]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: The first argument is a callback, which is invoked whenever an event is emitted
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是一个回调函数，每当事件被触发时就会被调用
- en: The second argument is an error callback function, invoked when the observable
    (the part that is generating events) errors out
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是一个错误回调函数，当可观察对象（生成事件的部分）发生错误时调用
- en: The final argument takes a callback function that is called when the observable
    is done publishing events
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个参数接受一个回调函数，当可观察对象完成发布事件时调用
- en: We have done enough to make audio integration work. Run the app and start the
    workout. Except for the ticking audio, all the `\` audio clips play at the right
    time. You may have to wait some time to hear the other audio clips. What is the
    problem?
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做了足够的工作来使音频集成工作。运行应用程序并开始锻炼。除了滴答声音之外，所有的音频剪辑都在正确的时间播放。您可能需要等一段时间才能听到其他音频剪辑。问题出在哪里？
- en: As it turns out, we never started the ticking audio clip at the start of the
    workout. We can fix it by either setting the `autoplay` attribute on the `ticks` audio
    element or using the component life cycle events to trigger the ticking sound.
    Let's take the second approach.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，我们从未在锻炼开始时启动滴答声音。我们可以通过在ticks音频元素上设置autoplay属性或使用组件生命周期事件来触发滴答声音来修复它。让我们采用第二种方法。
- en: Using component life cycle events
  id: totrans-916
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件生命周期事件
- en: 'The injected `MyAudioDirective` in `WorkoutAudioComponent`, shown as follows,
    is not available till the view is initialized:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WorkoutAudioComponent`中注入的`MyAudioDirective`如下所示，在视图初始化之前是不可用的：
- en: '[PRE144]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: We can verify it by accessing the `ticks` variable inside the constructor; it
    will be null. Angular has still not done its magic and we need to wait for the
    children of `WorkoutAudioComponent` to be initialized.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在构造函数中访问`ticks`变量来验证它；它将为null。Angular仍然没有发挥其魔力，我们需要等待`WorkoutAudioComponent`的子组件被初始化。
- en: The component's life cycle hooks can help us here. The `AfterViewInit` event
    hook is called once the component's view has been initialized and hence is a safe
    place from which to access the component's child directives/elements. Let's do
    it quickly.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的生命周期钩子可以帮助我们。`AfterViewInit`事件钩子在组件视图初始化后调用，因此是访问组件子指令/元素的安全位置。让我们快速做一下。
- en: 'Update `WorkoutAudioComponent` by adding the interface implementation, and
    the necessary imports, as highlighted:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加接口实现和必要的导入来更新`WorkoutAudioComponent`，如下所示：
- en: '[PRE145]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Go ahead and test the app. The app has come to life with full-fledged audio
    feedback. Nice!
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 继续测试应用程序。应用程序已经完全具备了音频反馈。不错！
- en: While everything looks fine and dandy on the surface, there is a memory leak
    in the application now. If, in the middle of the workout, we navigate away from
    the workout page (to the start or finish page) and again return to the workout
    page, multiple audio clips play at random times.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然表面上一切看起来都很好，但现在应用程序中存在内存泄漏。如果在锻炼过程中，我们从锻炼页面导航到其他页面（开始或结束页面），然后再返回到锻炼页面，多个音频片段会在随机时间播放。
- en: It seems that `WorkoutRunnerComponent` is not getting destroyed on route navigation,
    and due to this, none of the child components are destroyed, including `WorkoutAudioComponent`.
    The net result? A new `WorkoutRunnerComponent` is being created every time we
    navigate to the workout page but is never removed from the memory on navigating
    away.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来`WorkoutRunnerComponent`在路由导航时没有被销毁，因此，包括`WorkoutAudioComponent`在内，没有任何子组件被销毁。结果是？每次我们导航到锻炼页面时都会创建一个新的`WorkoutRunnerComponent`，但在导航离开时却从内存中永远不会被移除。
- en: The primary reason for this memory leak is the event handlers we have added
    in `WorkoutAudioComponent`. We need to unsubscribe from these events when the
    audio component unloads, or else the `WorkoutRunnerComponent` reference will never
    be dereferenced.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 这个内存泄漏的主要原因是我们在`WorkoutAudioComponent`中添加的事件处理程序。当音频组件卸载时，我们需要取消订阅这些事件，否则`WorkoutRunnerComponent`的引用将永远不会被取消引用。
- en: 'Another component lifecycle event comes to our rescue here: `OnDestroy` Add
    this implementation to the `WorkoutAudioComponent` class:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个组件生命周期事件在这里拯救了我们：`OnDestroy`将此实现添加到`WorkoutAudioComponent`类中：
- en: '[PRE146]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Also, remember to add references to the `OnDestroy` event interface as we did
    for `AfterViewInit`.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记得为`OnDestroy`事件接口添加引用，就像我们为`AfterViewInit`做的那样。
- en: Hope the `subscription` array that we created during event subscription makes
    sense now. One-shot unsubscribe!
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 希望我们在事件订阅期间创建的`subscription`数组现在有意义了。一次性取消订阅！
- en: This audio integration is now complete. While this approach is not an awfully
    bad way of integrating the two components, we can do better. Child components
    referring to the parent component seems to be undesirable.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 这个音频集成现在已经完成。虽然这种方法并不是集成这两个组件的一个非常糟糕的方式，但我们可以做得更好。子组件引用父组件似乎是不可取的。
- en: Before proceeding, delete the code that we have added to `workout-audio.component.ts` from
    the *Injecting a parent component into a child component* section onward.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，删除我们从*将父组件注入子组件*部分添加到`workout-audio.component.ts`的代码。
- en: Sibling component interaction using events and template variables
  id: totrans-933
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件和模板变量进行兄弟组件交互
- en: What if `WorkoutRunnerComponent` and `WorkoutAudioComponent` were organized
    as sibling components?
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`WorkoutRunnerComponent`和`WorkoutAudioComponent`被组织为兄弟组件会怎样？
- en: 'If `WorkoutAudioComponent` and `WorkoutRunnerComponent` become siblings, we
    can make good use of Angular''s *eventing* and *template reference variables*.
    Confused? Well, to start with, this is how the components should be laid out:'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`WorkoutAudioComponent`和`WorkoutRunnerComponent`变成兄弟组件，我们可以充分利用Angular的*事件*和*模板引用变量*。困惑吗？好吧，首先，组件应该这样布局：
- en: '[PRE147]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Does it ring any bells? Starting from this template, can you guess how the final
    HTML template would look? Think about it before you proceed further.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么想法吗？从这个模板开始，你能猜到最终的HTML模板会是什么样子吗？在继续之前先想一想。
- en: 'Still struggling? As soon as we make them sibling components, the power of
    the Angular templating engine comes to the fore. The following template code is
    enough to integrate `WorkoutRunnerComponent` and `WorkoutAudioComponent`:'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 还在挣扎吗？一旦我们将它们设置为兄弟组件，Angular模板引擎的强大功能就会显现出来。以下模板代码足以集成`WorkoutRunnerComponent`和`WorkoutAudioComponent`：
- en: '[PRE148]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The `WorkoutAudioComponent` template variable, `wa`, is being manipulated by
    referencing the variable in the event handler expressions on `WorkoutRunnerComponent`.
    Quite elegant! We still need to solve the biggest puzzle in this approach: Where
    does the preceding code go? Remember, `WorkoutRunnerComponent` is loaded as part
    of route loading. Nowhere in the code have we had a statement like this:'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutAudioComponent`模板变量`wa`是通过在`WorkoutRunnerComponent`的事件处理程序表达式中引用该变量来操作的。相当优雅！我们仍然需要解决这种方法中最大的难题：前面的代码放在哪里？记住，`WorkoutRunnerComponent`是作为路由加载的一部分加载的。在代码中我们从来没有像这样的语句：'
- en: '[PRE149]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: We need to reorganize the component tree and bring in a container component
    that can host `WorkoutRunnerComponent` and `WorkoutAudioComponent`. The router
    then loads this container component instead of `WorkoutRunnerComponent`. Let's
    do it.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重新组织组件树，并引入一个可以承载`WorkoutRunnerComponent`和`WorkoutAudioComponent`的容器组件。然后路由器加载这个容器组件，而不是`WorkoutRunnerComponent`。让我们来做吧。
- en: 'Generate a new component code from command line by navigating to `trainer/src/app/workout-runner` and
    executing:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导航到`trainer/src/app/workout-runner`并执行以下命令，从命令行生成一个新的组件代码：
- en: '[PRE150]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Copy the HTML code with the events described to the template file. The workout
    container component is ready.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 将描述事件的HTML代码复制到模板文件中。训练容器组件已经准备好了。
- en: 'We just need to rewire the routing setup. Open `app-routing.module.ts`. Change
    the route for the workout runner and add the necessary import:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要重新连接路由设置。打开`app-routing.module.ts`。更改训练运行器的路由并添加必要的导入：
- en: '[PRE151]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: And we have a working audio integration that is clear, concise, and pleasing
    to the eye!
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个工作的音频集成，清晰、简洁，令人愉悦！
- en: It's time now to wrap up the chapter, but not before addressing the video player
    dialog glitch introduced in the earlier sections. The workout does not stop/pause
    when the video player dialog is open.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候结束本章了，但在结束之前，我们要解决在前几节中引入的视频播放器对话框故障。当视频播放器对话框打开时，训练不会停止/暂停。
- en: We are not going to detail the fix here, and urge the readers to give it a try
    without consulting the `checkpoint3.4` code.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算在这里详细说明修复方法，并敦促读者在不咨询`checkpoint3.4`代码的情况下尝试一下。
- en: Here is an obvious hint. Use the eventing infrastructure!
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个明显的提示。使用事件基础设施！
- en: 'And another one: raise events from `VideoPlayerComponent`, one for each playback
    started and ended.'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个：从`VideoPlayerComponent`中引发事件，一个用于每次播放开始和结束。
- en: 'And one last hint: the `open` function on the dialog service (`Modal`) returns
    a promise, which is resolved when the dialog is closed.'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个提示：对话服务（`Modal`）上的`open`函数返回一个promise，在对话框关闭时解决。
- en: If you are having a problem with running the code, look at the `checkpoint3.4` Git
    branch for a working version of what we have done thus far. Or if you are not
    using Git, download the snapshot of `checkpoint3.4` (a ZIP file) from [http://bit.ly/ng6be-checkpoint-3-4](http://bit.ly/ng6be-checkpoint-3-4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在运行代码时遇到问题，请查看`checkpoint3.4` Git分支，以获取我们迄今为止所做的工作的可工作版本。或者，如果您不使用Git，请从[http://bit.ly/ng6be-checkpoint-3-4](http://bit.ly/ng6be-checkpoint-3-4)下载`checkpoint3.4`的快照（ZIP文件）。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Summary
  id: totrans-955
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We started this chapter with the aim of creating a complex Angular app. The
    *7 Minute Workout* app fitted the bill, and you learned a lot about the Angular
    framework while building this app.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从创建一个复杂的Angular应用开始了这一章。*7分钟锻炼*应用程序符合要求，而在构建此应用程序时，您学到了很多关于Angular框架的知识。
- en: To build the app, we started off by defining the model of the app. Once the
    model was in place, we started the actual implementation by building an **Angular
    component**. Angular components are nothing but classes that are decorated with
    a framework-specific decorator, `@Component`.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建应用程序，我们首先定义了应用程序的模型。一旦模型就位，我们就开始实际的实现，构建一个**Angular组件**。Angular组件只是用框架特定装饰器`@Component`装饰的类。
- en: We also learned about **Angular modules** and how Angular uses them to organize
    code artifacts.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了**Angular模块**以及Angular如何使用它们来组织代码构件。
- en: Once we had a fully functional component, we created a supporting view for the
    app. We also explored the data binding capabilities of the framework, including
    **property**, **attribute**, **class**, **style,** and **event binding**. Plus,
    we highlighted how **interpolations** are a special case of property binding.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了一个完全功能的组件，我们为应用程序创建了一个支持视图。我们还探索了框架的数据绑定能力，包括**属性**、**属性**、**类**、**样式**和**事件绑定**。此外，我们强调了**插值**是属性绑定的一种特殊情况。
- en: Components are a special class of directives that have an attached view. We
    touched upon what directives are and the special classes of directives, including
    **attribute** and **structural directives**.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是一种特殊类的指令，具有附加的视图。我们提到了指令是什么，以及指令的特殊类，包括**属性**和**结构指令**。
- en: We learned how to perform cross-component communication using **input properties**.
    The two child components that we put together (`ExerciseDescriptionComponent`
    and `VideoPlayerComponent`) derived their inputs from the parent `WorkoutRunnerComponent`
    using input properties.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了如何使用**输入属性**进行跨组件通信。我们组合的两个子组件（`ExerciseDescriptionComponent`和`VideoPlayerComponent`）使用输入属性从父组件`WorkoutRunnerComponent`获取它们的输入。
- en: We then covered another core construct in Angular, **pipes**. We saw how to
    use pipes such as the date pipe and how to create one of our own.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们介绍了Angular中的另一个核心构造，**管道**。我们看到了如何使用诸如日期管道之类的管道，以及如何创建我们自己的管道。
- en: 'Throughout the chapter, we touched upon a number of Angular directives, including
    the following:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个章节中，我们提到了许多Angular指令，包括以下内容：
- en: '`ngClass/ngStyle`: For applying multiple styles and classes using Angular binding
    capabilities'
  id: totrans-964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngClass/ngStyle`：使用Angular绑定能力应用多个样式和类'
- en: '`ngFor`: For generating dynamic HTML content using a looping construct'
  id: totrans-965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngFor`：使用循环结构生成动态HTML内容'
- en: '`ngIf`: For conditionally creating/destroying DOM elements'
  id: totrans-966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngIf`：有条件地创建/销毁DOM元素'
- en: '`ngSwitch`: For creating/destroying DOM elements using the switch-case construct'
  id: totrans-967
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngSwitch`：使用switch-case结构创建/销毁DOM元素'
- en: We now have a basic *7 Minute Workout* app. For a better user experience, we
    have added a number of small enhancements to it too, but we are still missing
    some good-to-have features that would make our app more usable. From the framework
    perspective, we have purposefully ignored some core/advanced concepts such as
    **change detection**, **dependency injection**, **component** **routing**, and
    data flow patterns.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个基本的*7分钟锻炼*应用程序。为了提供更好的用户体验，我们还对其进行了一些小的增强，但我们仍然缺少一些使我们的应用更易用的功能。从框架的角度来看，我们有意忽略了一些核心/高级概念，比如**变更检测**、**依赖注入**、**组件路由**和数据流模式。
- en: 'Lastly, we touched upon an important topic: cross-component communication,
    primarily using Angular eventing. We detailed how to create custom events using
    the `@Output` decorator and `EventEmitter`.'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们谈到了一个重要的话题：跨组件通信，主要使用Angular事件。我们详细介绍了如何使用`@Output`装饰器和`EventEmitter`创建自定义事件。
- en: The `@ViewChild` and `@ViewChildren` decorators that we touched upon in this
    chapter helped us understand how a parent can get hold of a child component for
    use. Angular DI also allows injecting a parent component into a child.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了`@ViewChild`和`@ViewChildren`装饰器，帮助我们了解父组件如何获取子组件以供使用。Angular DI还允许将父组件注入到子组件中。
- en: We concluded this chapter by building a `WorkoutAudioComponent` and highlighted
    how sibling-component communication can happen using Angular events and template
    variables.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过构建一个`WorkoutAudioComponent`来结束了本章，并强调了如何使用Angular事件和模板变量进行兄弟组件通信。
- en: What's next? We are going to build a new app, *Personal Trainer*. This app will
    allow us to build our own custom workouts. Once we can create our own workout,
    we are going to morph the *7-Minute Workout* app into a generic *Workout Runner* app
    that can run workouts that we build using *Personal Trainer*.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来呢？我们将构建一个新的应用程序，*个人健身教练*。这个应用程序将允许我们构建自己的定制锻炼。一旦我们能够创建自己的锻炼，我们将把*7分钟锻炼*应用程序改造成一个通用的*锻炼运行器*应用程序，可以运行我们使用*个人健身教练*创建的锻炼。
- en: For the next chapter, we'll showcase Angular's form capabilities while we build
    a UI that allows us to create, update, and view our own custom workouts/exercises.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将展示Angular的表单功能，同时构建一个允许我们创建、更新和查看自己的定制锻炼/练习的UI。

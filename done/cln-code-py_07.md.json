["```py\n<purchase_date>, <price>\n...\n```", "```py\nclass PurchasesStats:\n\n    def __init__(self, purchases):\n        self.purchases = iter(purchases)\n        self.min_price: float = None\n        self.max_price: float = None\n        self._total_purchases_price: float = 0.0\n        self._total_purchases = 0\n        self._initialize()\n\n    def _initialize(self):\n        try:\n            first_value = next(self.purchases)\n        except StopIteration:\n            raise ValueError(\"no values provided\")\n\n        self.min_price = self.max_price = first_value\n        self._update_avg(first_value)\n\n    def process(self):\n        for purchase_value in self.purchases:\n            self._update_min(purchase_value)\n            self._update_max(purchase_value)\n            self._update_avg(purchase_value)\n        return self\n\n    def _update_min(self, new_value: float):\n        if new_value < self.min_price:\n            self.min_price = new_value\n\n    def _update_max(self, new_value: float):\n        if new_value > self.max_price:\n            self.max_price = new_value\n\n    @property\n    def avg_price(self):\n        return self._total_purchases_price / self._total_purchases\n\n    def _update_avg(self, new_value: float):\n        self._total_purchases_price += new_value\n        self._total_purchases += 1\n\n    def __str__(self):\n        return (\n            f\"{self.__class__.__name__}({self.min_price}, \"\n            f\"{self.max_price}, {self.avg_price})\"\n        )\n```", "```py\ndef _load_purchases(filename):\n    purchases = []\n    with open(filename) as f:\n        for line in f:\n            *_, price_raw = line.partition(\",\")\n            purchases.append(float(price_raw))\n\n    return purchases\n```", "```py\ndef load_purchases(filename):\n    with open(filename) as f:\n        for line in f:\n            *_, price_raw = line.partition(\",\")\n            yield float(price_raw)\n```", "```py\n>>> load_purchases(\"file\")\n<generator object load_purchases at 0x...>\n```", "```py\n>>> [x**2 for x in range(10)]\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n>>> (x**2 for x in range(10))\n<generator object <genexpr> at 0x...>\n\n>>> sum(x**2 for x in range(10))\n285\n```", "```py\n>>> list(enumerate(\"abcdef\"))\n[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd'), (4, 'e'), (5, 'f')]\n```", "```py\nclass NumberSequence:\n\n    def __init__(self, start=0):\n        self.current = start\n\n    def next(self):\n        current = self.current\n        self.current += 1\n        return current\n```", "```py\n>>> seq = NumberSequence()\n>>> seq.next()\n0\n>>> seq.next()\n1\n\n>>> seq2 = NumberSequence(10)\n>>> seq2.next()\n10\n>>> seq2.next()\n11\n```", "```py\n>>> list(zip(NumberSequence(), \"abcdef\"))\nTraceback (most recent call last):\n File \"...\", line 1, in <module>\nTypeError: zip argument #1 must support iteration\n```", "```py\nclass SequenceOfNumbers:\n\n    def __init__(self, start=0):\n        self.current = start\n\n    def __next__(self):\n        current = self.current\n        self.current += 1\n        return current\n\n    def __iter__(self):\n        return self\n```", "```py\n>>> list(zip(SequenceOfNumbers(), \"abcdef\"))\n[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd'), (4, 'e'), (5, 'f')]\n>>> seq = SequenceOfNumbers(100)\n>>> next(seq)\n100\n>>> next(seq)\n101\n```", "```py\n>>> word = iter(\"hello\")\n>>> next(word)\n'h'\n>>> next(word)\n'e'  # ...\n```", "```py\n>>> ...\n>>> next(word)\n'o'\n>>> next(word)\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nStopIteration\n>>>\n```", "```py\n>>> next(word, \"default value\")\n'default value'\n```", "```py\ndef sequence(start=0):\n    while True:\n        yield start\n        start += 1\n```", "```py\n>>> seq = sequence(10)\n>>> next(seq)\n10\n>>> next(seq)\n11\n\n>>> list(zip(sequence(), \"abcdef\"))\n[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd'), (4, 'e'), (5, 'f')]\n```", "```py\n# ...\n    def process(self):\n        for purchase in self.purchases:\n            if purchase > 1000.0:\n                ...\n```", "```py\n>>> from itertools import islice\n>>> purchases = islice(filter(lambda p: p > 1000.0, purchases), 10)\n>>> stats = PurchasesStats(purchases).process()  # ...\n```", "```py\ndef process_purchases(purchases):\n    min_, max_, avg = itertools.tee(purchases, 3)\n    return min(min_), max(max_), median(avg)\n```", "```py\ndef search_nested_bad(array, desired_value):\n    coords = None\n    for i, row in enumerate(array):\n        for j, cell in enumerate(row):\n            if cell == desired_value:\n                coords = (i, j)\n                break\n\n        if coords is not None:\n            break\n\n    if coords is None:\n        raise ValueError(f\"{desired_value} not found\")\n\n    logger.info(\"value %r found at [%i, %i]\", desired_value, *coords)\n    return coords\n```", "```py\ndef _iterate_array2d(array2d):\n    for i, row in enumerate(array2d):\n        for j, cell in enumerate(row):\n            yield (i, j), cell\n\ndef search_nested(array, desired_value):\n    try:\n        coord = next(\n            coord\n            for (coord, cell) in _iterate_array2d(array)\n            if cell == desired_value\n        )\n    except StopIteration:\n        raise ValueError(\"{desired_value} not found\")\n\n    logger.info(\"value %r found at [%i, %i]\", desired_value, *coord)\n    return coord\n```", "```py\nclass SequenceIterator:\n    def __init__(self, start=0, step=1):\n        self.current = start\n        self.step = step\n\n    def __next__(self):\n        value = self.current\n        self.current += self.step\n        return value\n```", "```py\n>>> si = SequenceIterator(1, 2)\n>>> next(si)\n1\n>>> next(si)\n3\n>>> next(si)\n5\n>>> for _ in SequenceIterator(): pass\n... \nTraceback (most recent call last):\n ...\nTypeError: 'SequenceIterator' object is not iterable\n```", "```py\n# generators_iteration_2.py\n\nclass MappedRange:\n    \"\"\"Apply a transformation to a range of numbers.\"\"\"\n\n    def __init__(self, transformation, start, end):\n        self._transformation = transformation\n        self._wrapped = range(start, end)\n\n    def __getitem__(self, index):\n        value = self._wrapped.__getitem__(index)\n        result = self._transformation(value)\n        logger.info(\"Index %d: %s\", index, result)\n        return result\n\n    def __len__(self):\n        return len(self._wrapped)\n```", "```py\n>>> mr = MappedRange(abs, -10, 5)\n>>> mr[0]\nIndex 0: 10\n10\n>>> mr[-1]\nIndex -1: 4\n4\n>>> list(mr)\nIndex 0: 10\nIndex 1: 9\nIndex 2: 8\nIndex 3: 7\nIndex 4: 6\nIndex 5: 5\nIndex 6: 4\nIndex 7: 3\nIndex 8: 2\nIndex 9: 1\nIndex 10: 0\nIndex 11: 1\nIndex 12: 2\nIndex 13: 3\nIndex 14: 4\n[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4]\n```", "```py\ndef stream_db_records(db_handler):\n    try:\n        while True:\n            yield db_handler.read_n_records(10)\n    except GeneratorExit:\n        db_handler.close()\n```", "```py\n>>> streamer = stream_db_records(DBHandler(\"testdb\"))\n>>> next(streamer)\n[(0, 'row 0'), (1, 'row 1'), (2, 'row 2'), (3, 'row 3'), ...]\n>>> next(streamer)\n[(0, 'row 0'), (1, 'row 1'), (2, 'row 2'), (3, 'row 3'), ...]\n>>> streamer.close()\nINFO:...:closing connection to database 'testdb'\n```", "```py\nclass CustomException(Exception):\n    pass\n\ndef stream_data(db_handler):\n    while True:\n        try:\n            yield db_handler.read_n_records(10)\n        except CustomException as e:\n            logger.info(\"controlled error %r, continuing\", e)\n        except Exception as e:\n            logger.info(\"unhandled error %r, stopping\", e)\n            db_handler.close()\n            break\n```", "```py\n>>> streamer = stream_data(DBHandler(\"testdb\"))\n>>> next(streamer)\n[(0, 'row 0'), (1, 'row 1'), (2, 'row 2'), (3, 'row 3'), (4, 'row 4'), ...]\n>>> next(streamer)\n[(0, 'row 0'), (1, 'row 1'), (2, 'row 2'), (3, 'row 3'), (4, 'row 4'), ...]\n>>> streamer.throw(CustomException)\nWARNING:controlled error CustomException(), continuing\n[(0, 'row 0'), (1, 'row 1'), (2, 'row 2'), (3, 'row 3'), (4, 'row 4'), ...]\n>>> streamer.throw(RuntimeError)\nERROR:unhandled error RuntimeError(), stopping\nINFO:closing connection to database 'testdb'\nTraceback (most recent call last):\n ...\nStopIteration\n```", "```py\ndef stream_db_records(db_handler):\n    retrieved_data = None\n    previous_page_size = 10\n    try:\n        while True:\n            page_size = yield retrieved_data\n            if page_size is None:\n                page_size = previous_page_size\n\n            previous_page_size = page_size\n\n            retrieved_data = db_handler.read_n_records(page_size)\n    except GeneratorExit:\n        db_handler.close()\n```", "```py\nreceive = yield produced\n```", "```py\n>>> c = coro()\n>>> c.send(1)\nTraceback (most recent call last):\n ...\nTypeError: can't send non-None value to a just-started generator\n```", "```py\ndef stream_db_records(db_handler):\n    retrieved_data = None\n    page_size = 10\n    try:\n        while True:\n            page_size = (yield retrieved_data) or page_size\n            retrieved_data = db_handler.read_n_records(page_size)\n    except GeneratorExit:\n        db_handler.close()\n```", "```py\n@prepare_coroutine\ndef stream_db_records(db_handler):\n    retrieved_data = None\n    page_size = 10\n    try:\n        while True:\n            page_size = (yield retrieved_data) or page_size\n            retrieved_data = db_handler.read_n_records(page_size)\n    except GeneratorExit:\n        db_handler.close()\n\n>>> streamer = stream_db_records(DBHandler(\"testdb\"))\n>>> len(streamer.send(5))\n5\n```", "```py\n>>> def generator():\n...     yield 1\n...     yield 2\n...     return 3\n... \n>>> value = generator()\n>>> next(value)\n1\n>>> next(value)\n2\n>>> try:\n...     next(value)\n... except StopIteration as e:\n...     print(\">>>>>> returned value \", e.value)\n... \n>>>>>> returned value  3\n```", "```py\ndef chain(*iterables):\n    for it in iterables:\n        for value in it:\n            yield value\n```", "```py\ndef chain(*iterables):\n    for it in iterables:\n        yield from it\n```", "```py\n>>> list(chain(\"hello\", [\"world\"], (\"tuple\", \" of \", \"values.\")))\n['h', 'e', 'l', 'l', 'o', 'world', 'tuple', ' of ', 'values.']\n```", "```py\ndef all_powers(n, pow):\n    yield from (n ** i for i in range(pow + 1))\n```", "```py\ndef sequence(name, start, end):\n    logger.info(\"%s started at %i\", name, start)\n    yield from range(start, end)\n    logger.info(\"%s finished at %i\", name, end)\n    return end\n\ndef main():\n    step1 = yield from sequence(\"first\", 0, 5)\n    step2 = yield from sequence(\"second\", step1, 10)\n    return step1 + step2\n```", "```py\n>>> g = main()\n>>> next(g)\nINFO:generators_yieldfrom_2:first started at 0\n0\n>>> next(g)\n1\n>>> next(g)\n2\n>>> next(g)\n3\n>>> next(g)\n4\n>>> next(g)\nINFO:generators_yieldfrom_2:first finished at 5\nINFO:generators_yieldfrom_2:second started at 5\n5\n>>> next(g)\n6\n>>> next(g)\n7\n>>> next(g)\n8\n>>> next(g)\n9\n>>> next(g)\nINFO:generators_yieldfrom_2:second finished at 10\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nStopIteration: 15\n```", "```py\ndef sequence(name, start, end):\n    value = start\n    logger.info(\"%s started at %i\", name, value)\n    while value < end:\n        try:\n            received = yield value\n            logger.info(\"%s received %r\", name, received)\n            value += 1\n        except CustomException as e:\n            logger.info(\"%s is handling %s\", name, e)\n            received = yield \"OK\"\n    return end\n```", "```py\n>>> g = main()\n>>> next(g)\nINFO: first started at 0\n0\n>>> next(g)\nINFO: first received None\n1\n>>> g.send(\"value for 1\")\nINFO: first received 'value for 1'\n2\n>>> g.throw(CustomException(\"controlled error\"))\nINFO: first is handling controlled error\n'OK'\n... # advance more times\nINFO:second started at 5\n5\n>>> g.throw(CustomException(\"exception at second generator\"))\nINFO: second is handling exception at second generator\n'OK'\n```", "```py\nresult = yield from iterable_or_awaitable()\n```"]
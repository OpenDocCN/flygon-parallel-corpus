["```cs\n        public void DoBackgroundTask()\n        {\n          WriteLine($\"Thread {Thread.CurrentThread.ManagedThreadId} has\n          a threadstate of {Thread.CurrentThread.ThreadState} with\n          {Thread.CurrentThread.Priority} priority\");\n          WriteLine($\"Start thread sleep at {DateTime.Now.Second}\n                    seconds\");\n          Thread.Sleep(3000);\n          WriteLine($\"End thread sleep at {DateTime.Now.Second} seconds\");\n        }\n\n```", "```cs\n        static void Main(string[] args)\n        {\n          Demo oRecipe = new Demo();\n          var backgroundThread = new Thread(oRecipe.DoBackgroundTask);\n          backgroundThread.IsBackground = true;\n          backgroundThread.Start();\n          Thread.Sleep(5000);\n        }\n\n```", "```cs\n        backgroundThread.Priority = ThreadPriority.Lowest;\n\n```", "```cs\n        Demo oRecipe = new Demo();\n        var backgroundThread = new Thread(oRecipe.DoBackgroundTask);\n        backgroundThread.IsBackground = true;\n        backgroundThread.Priority = ThreadPriority.Lowest;\n        backgroundThread.Start();\n        Thread.Sleep(5000);\n\n```", "```cs\n        public void DoBackgroundTask()\n        {\n          WriteLine($\"Thread {Thread.CurrentThread.ManagedThreadId} has a\n          threadstate of {Thread.CurrentThread.ThreadState} with\n          {Thread.CurrentThread.Priority} priority\");   \n          WriteLine($\"Start thread sleep at {DateTime.Now.Second} \n                    seconds\");\n          Thread.CurrentThread.Abort();\n          Thread.Sleep(3000);\n          WriteLine($\"End thread sleep at {DateTime.Now.Second} seconds\");\n        }\n\n```", "```cs\n        public class Demo\n        {\n          public void IncreaseThreadPoolSize()\n          {\n             int numberOfProcessors = Environment.ProcessorCount;\n             WriteLine($\"Processor Count = {numberOfProcessors}\");\n          }\n        }\n\n```", "```cs\n        int maxworkerThreads; \n        int maxconcurrentActiveRequests; \n        int minworkerThreads; \n        int minconcurrentActiveRequests; \n        ThreadPool.GetMinThreads(out minworkerThreads, \n          out  minconcurrentActiveRequests);\n        WriteLine($\"ThreadPool minimum Worker = {minworkerThreads} \n          and minimum Requests = {minconcurrentActiveRequests}\");\n        ThreadPool.GetMaxThreads(out maxworkerThreads, \n          out  maxconcurrentActiveRequests);\n        WriteLine($\"ThreadPool maximum Worker = {maxworkerThreads} \n          and maximum Requests = {maxconcurrentActiveRequests}\");\n\n```", "```cs\n        Random rndWorkers = new Random(); \n        int newMaxWorker = rndWorkers.Next(minworkerThreads, \n          maxworkerThreads);\n        WriteLine($\"New Max Worker Thread generated = {newMaxWorker}\"); \n\n        Random rndConRequests = new Random(); \n        int newMaxRequests = rndConRequests.Next(\n        minconcurrentActiveRequests, maxconcurrentActiveRequests);\n        WriteLine($\"New Max Active Requests generated = {newMaxRequests}\");\n\n```", "```cs\n        bool changeSucceeded = ThreadPool.SetMaxThreads(\n          newMaxWorker, newMaxRequests); \n        if (changeSucceeded) \n        { \n           WriteLine(\"SetMaxThreads completed\"); \n           int maxworkerThreadCount; \n           int maxconcurrentActiveRequestCount; \n           ThreadPool.GetMaxThreads(out maxworkerThreadCount, \n           out maxconcurrentActiveRequestCount); \n           WriteLine($\"ThreadPool Max Worker = {maxworkerThreadCount} \n           and Max Requests = {maxconcurrentActiveRequestCount}\"); \n        } \n        else \n           WriteLine(\"SetMaxThreads failed\");\n\n```", "```cs\n        public class Demo\n        { \n          public void IncreaseThreadPoolSize() \n          { \n            int numberOfProcessors = Environment.ProcessorCount; \n            WriteLine($\"Processor Count = {numberOfProcessors}\"); \n\n            int maxworkerThreads; \n            int maxconcurrentActiveRequests; \n            int minworkerThreads; \n            int minconcurrentActiveRequests; \n            ThreadPool.GetMinThreads(out minworkerThreads, \n              out minconcurrentActiveRequests);  \n            WriteLine($\"ThreadPool minimum Worker = {minworkerThreads}\n              and minimum Requests = {minconcurrentActiveRequests}\"); \n            ThreadPool.GetMaxThreads(out maxworkerThreads, \n              out maxconcurrentActiveRequests);\n            WriteLine($\"ThreadPool maximum Worker = {maxworkerThreads} \n              and maximum Requests = {maxconcurrentActiveRequests}\"); \n\n            Random rndWorkers = new Random(); \n            int newMaxWorker = rndWorkers.Next(minworkerThreads, \n              maxworkerThreads);\n            WriteLine($\"New Max Worker Thread generated = {newMaxWorker}\"); \n\n            Random rndConRequests = new Random(); \n            int newMaxRequests = rndConRequests.Next(\n              minconcurrentActiveRequests, \n              maxconcurrentActiveRequests);        \n            WriteLine($\"New Max Active Requests generated = \n                      {newMaxRequests}\");\n\n            bool changeSucceeded = ThreadPool.SetMaxThreads(\n              newMaxWorker, newMaxRequests); \n            if (changeSucceeded) \n            { \n              WriteLine(\"SetMaxThreads completed\"); \n              int maxworkerThreadCount; \n              int maxconcurrentActiveRequestCount; \n              ThreadPool.GetMaxThreads(out maxworkerThreadCount, \n                out maxconcurrentActiveRequestCount);             \n              WriteLine($\"ThreadPool Max Worker = {maxworkerThreadCount} \n              and Max Requests = {maxconcurrentActiveRequestCount}\"); \n            } \n            else \n              WriteLine(\"SetMaxThreads failed\"); \n\n          } \n        }\n\n```", "```cs\n        Demo oRecipe = new Demo(); \n        oRecipe.IncreaseThreadPoolSize(); \n        Console.ReadLine();\n\n```", "```cs\n        public class Demo \n        { \n          public void MultipleThreadWait() \n          {         \n\n          } \n\n          private void RunThread(int sleepSeconds) \n          {         \n\n          } \n        }\n\n```", "```cs\n        Task thread1 = Task.Factory.StartNew(() => RunThread(3)); \n        Task thread2 = Task.Factory.StartNew(() => RunThread(5)); \n        Task thread3 = Task.Factory.StartNew(() => RunThread(2)); \n\n        Task.WaitAll(thread1, thread2, thread3); \n        WriteLine(\"All tasks completed\");\n\n```", "```cs\n        int thread\n        ID = Thread.CurrentThread.ManagedThreadId; \n\n        WriteLine($\"Sleep thread {threadID} for {sleepSeconds} \n          seconds at {DateTime.Now.Second} seconds\"); \n        Thread.Sleep(sleepSeconds * 1000); \n        WriteLine($\"Wake thread {threadID} at {DateTime.Now.Second} \n                  seconds\");\n\n```", "```cs\n        public class Demo \n        { \n          public void MultipleThreadWait() \n          { \n            Task thread1 = Task.Factory.StartNew(() => RunThread(3)); \n            Task thread2 = Task.Factory.StartNew(() => RunThread(5)); \n            Task thread3 = Task.Factory.StartNew(() => RunThread(2)); \n\n            Task.WaitAll(thread1, thread2, thread3); \n            WriteLine(\"All tasks completed\"); \n          } \n\n          private void RunThread(int sleepSeconds) \n          { \n            int threadID = Thread.CurrentThread.ManagedThreadId; \n            WriteLine($\"Sleep thread {threadID} for {sleepSeconds} \n              seconds at {DateTime.Now.Second}          seconds\"); \n            Thread.Sleep(sleepSeconds * 1000); \n            WriteLine($\"Wake thread {threadID} at {DateTime.Now.Second} \n                      seconds\"); \n          } \n        }\n\n```", "```cs\n        Demo oRecipe = new Demo(); \n        oRecipe.MultipleThreadWait(); \n        Console.ReadLine();\n\n```", "```cs\n        public class Demo \n        { \n          private object threadLock = new object(); \n          public void LockThreadExample() \n          {         \n\n          } \n\n          private void ContendedResource(int sleepSeconds) \n          {         \n\n          } \n        }\n\n```", "```cs\n        Task thread1 = Task.Factory.StartNew(() => ContendedResource(3));\n        Task thread2 = Task.Factory.StartNew(() => ContendedResource(5));\n        Task thread3 = Task.Factory.StartNew(() => ContendedResource(2)); \n\n        Task.WaitAll(thread1, thread2, thread3); \n        WriteLine(\"All tasks completed\");\n\n```", "```cs\n        int threadID = Thread.CurrentThread.ManagedThreadId; \n        lock (threadLock) \n        { \n          WriteLine($\"Locked for thread {threadID}\"); \n          Thread.Sleep(sleepSeconds * 1000); \n        } \n        WriteLine($\"Lock released for thread {threadID}\");\n\n```", "```cs\n        Demo oRecipe = new Demo(); \n        oRecipe.LockThreadExample(); \n        Console.ReadLine();\n\n```", "```cs\n        public class Demo \n        { \n          public void ParallelInvoke() \n          {         \n\n          } \n\n          private void PerformSomeTask(int sleepSeconds) \n          {         \n\n          } \n        }\n\n```", "```cs\n        WriteLine($\"Parallel.Invoke started at \n          {DateTime.Now.Second} seconds\"); \n        Parallel.Invoke( \n          () => PerformSomeTask(3), \n          () => PerformSomeTask(5), \n          () => PerformSomeTask(2) \n        ); \n\n        WriteLine($\"Parallel.Invoke completed at \n          {DateTime.Now.Second} seconds\");\n\n```", "```cs\n        int threadID = Thread.CurrentThread.ManagedThreadId; \n        WriteLine($\"Sleep thread {threadID} for \n          {sleepSeconds}  seconds\"); \n        Thread.Sleep(sleepSeconds * 1000); \n        WriteLine($\"Thread {threadID} resumed\");\n\n```", "```cs\n        public class Demo \n        { \n          public void ParallelInvoke() \n          { \n            WriteLine($\"Parallel.Invoke started at \n                      {DateTime.Now.Second} seconds\"); \n            Parallel.Invoke( \n              () => PerformSomeTask(3), \n              () => PerformSomeTask(5), \n              () => PerformSomeTask(2) \n            ); \n\n            WriteLine($\"Parallel.Invoke completed at {DateTime.Now.Second} \n                      seconds\");            \n          } \n\n          private void PerformSomeTask(int sleepSeconds) \n          {         \n            int threadID = Thread.CurrentThread.ManagedThreadId; \n            WriteLine($\"Sleep thread {threadID} for {sleepSeconds} \n                      seconds\"); \n            Thread.Sleep(sleepSeconds * 1000); \n            WriteLine($\"Thread {threadID} resumed\"); \n          } \n        }\n\n```", "```cs\n        Demo oRecipe = new Demo(); \n        oRecipe.ParallelInvoke(); \n        Console.ReadLine();\n\n```", "```cs\n        public class Demo \n        { \n          public double ReadCollectionForEach(List<string> intCollection) \n          {         \n\n          } \n\n          public double ReadCollectionParallelForEach(List<string> \n            intCollection) \n          {         \n\n          } \n        }\n\n```", "```cs\n        var timer = Stopwatch.StartNew(); \n        foreach (string integer in intCollection) \n        { \n          WriteLine(integer); \n          Clear(); \n        } \n        return timer.Elapsed.TotalSeconds;\n\n```", "```cs\n        var timer = Stopwatch.StartNew(); \n        Parallel.ForEach(intCollection, integer => \n        { \n          WriteLine(integer); \n          Clear(); \n        }); \n        return timer.Elapsed.TotalSeconds;\n\n```", "```cs\n        public class Demo \n        { \n          public double ReadCollectionForEach(List<string> intCollection) \n          {         \n            var timer = Stopwatch.StartNew(); \n            foreach (string integer in intCollection) \n            { \n              WriteLine(integer); \n              Clear(); \n            } \n            return timer.Elapsed.TotalSeconds; \n          } \n\n          public double ReadCollectionParallelForEach(List<string> \n            intCollection) \n          {         \n            var timer = Stopwatch.StartNew(); \n            Parallel.ForEach(intCollection, integer => \n            { \n              WriteLine(integer); \n              Clear(); \n            }); \n            return timer.Elapsed.TotalSeconds; \n          } \n        }\n\n```", "```cs\n        List<string> integerList = new List<string>(); \n        for (int i = 0; i <= 500; i++) \n        { \n          integerList.Add(i.ToString()); \n        } \n        Demo oRecipe = new Demo(); \n        double timeElapsed1 = oRecipe.ReadCollectionForEach(integerList); \n        double timeElapsed2 = oRecipe.ReadCollectionParallelForEach(\n          integerList); \n        WriteLine($\"foreach executed in {timeElapsed1}\"); \n        WriteLine($\"Parallel.ForEach executed in {timeElapsed2}\");\n\n```", "```cs\n        public class Demo \n        { \n          public void CreateWriteFilesForEach(List<string> intCollection) \n          {         \n\n          } \n\n          public void CreateWriteFilesParallelForEach(List<string> \n            intCollection) \n          {         \n\n          } \n        }\n\n```", "```cs\n        WriteLine($\"Start foreach File method\"); \n        var timer = Stopwatch.StartNew(); \n        foreach (string integer in intCollection) \n        {     \n\n        } \n        WriteLine($\"foreach File method executed in           {timer.Elapsed.TotalSeconds} seconds\");\n\n```", "```cs\n        string filePath =  $\"C:\\temp\\output\\ForEach_Log{integer}.txt\"; \n        if (!File.Exists(filePath)) \n        { \n          File.Create(filePath).Dispose(); \n          using (StreamWriter sw = new StreamWriter(filePath, false)) \n          { \n            sw.WriteLine($\"{integer}. Log file start:               {DateTime.Now.ToUniversalTime().ToString()}\"); \n          } \n        }\n\n```", "```cs\n        WriteLine($\"Start Parallel.ForEach File method\"); \n        var timer = Stopwatch.StartNew(); \n        Parallel.ForEach(intCollection, integer => \n        { \n\n        }); \n        WriteLine($\"Parallel.ForEach File method executed in          {timer.Elapsed.TotalSeconds} seconds\");\n\n```", "```cs\n        string filePath = $\"C:\\temp\\output\\ParallelForEach_Log{\n          integer}.txt\"; \n        if (!File.Exists(filePath)) \n        { \n          File.Create(filePath).Dispose(); \n          using (StreamWriter sw = new StreamWriter(filePath, false)) \n          { \n            sw.WriteLine($\"{integer}. Log file start:               {DateTime.Now.ToUniversalTime().ToString()}\"); \n          } \n        }\n\n```", "```cs\n        public class Demo \n        { \n          public void CreateWriteFilesForEach(List<string> intCollection) \n          {         \n            WriteLine($\"Start foreach File method\"); \n            var timer = Stopwatch.StartNew(); \n            foreach (string integer in intCollection) \n            { \n              string filePath = $\"C:\\temp\\output\\ForEach_Log{integer}.txt\"; \n              if (!File.Exists(filePath)) \n              { \n                File.Create(filePath).Dispose(); \n                using (StreamWriter sw = new StreamWriter(filePath, false)) \n                { \n                    sw.WriteLine($\"{integer}. Log file start:                     {DateTime.Now.ToUniversalTime().ToString()}\"); \n                } \n              } \n            } \n            WriteLine($\"foreach File method executed in {\n                      timer.Elapsed.TotalSeconds} seconds\"); \n          } \n\n          public void CreateWriteFilesParallelForEach(List<string> \n            intCollection) \n          {         \n            WriteLine($\"Start Parallel.ForEach File method\"); \n            var timer = Stopwatch.StartNew(); \n            Parallel.ForEach(intCollection, integer => \n            { \n              string filePath = $\"C:\\temp\\output\\ParallelForEach_Log \n                {integer}.txt\"; \n              if (!File.Exists(filePath)) \n              { \n                File.Create(filePath).Dispose(); \n                using (StreamWriter sw = new StreamWriter(filePath, false)) \n                { \n                  sw.WriteLine($\"{integer}. Log file start:                     {DateTime.Now.ToUniversalTime().ToString()}\"); \n                } \n              }                 \n            }); \n            WriteLine($\"Parallel.ForEach File method executed in             {timer.Elapsed.TotalSeconds} seconds\"); \n          } \n        }\n\n```", "```cs\n        List<string> integerList = new List<string>(); \n        for (int i = 0; i <= 1000; i++) \n        { \n          integerList.Add(i.ToString()); \n        } \n\n        Demo oRecipe = new Demo(); \n        oRecipe.CreateWriteFilesForEach(integerList); \n        oRecipe.CreateWriteFilesParallelForEach(integerList); \n        ReadLine();\n\n```", "```cs\n        public class Demo \n        { \n          public void CancelParallelForEach(List<string> intCollection, \n            int timeOut) \n          {         \n\n          }     \n        }\n\n```", "```cs\n        var timer = Stopwatch.StartNew(); \n        Parallel.ForEach(intCollection, (integer, state) => \n        { \n          Thread.Sleep(1000); \n          if (timer.Elapsed.Seconds > timeOut) \n          { \n            WriteLine($\"Terminate thread {Thread.CurrentThread\n              .ManagedThreadId}. Elapsed time {\n              timer.Elapsed.Seconds} seconds\"); \n            state.Break(); \n          } \n          WriteLine($\"Processing item {integer} on thread           {Thread.CurrentThread.ManagedThreadId}\"); \n        });\n\n```", "```cs\n        List<string> integerList = new List<string>(); \n        for (int i = 0; i <= 1000; i++) \n        { \n          integerList.Add(i.ToString()); \n        } \n\n        Demo oRecipe = new Demo(); \n        oRecipe.CancelParallelForEach(integerList, 5); \n        WriteLine($\"Parallel.ForEach loop terminated\"); \n        ReadLine();\n\n```", "```cs\n        public class Recipes \n        { \n          public void CheckClientMachinesOnline(List<string> ipAddresses, \n            int minimumLive) \n          {         \n\n          }    \n\n          private bool MachineReturnedPing(string ip)   \n          {             \n            return false; \n          }  \n        }\n\n```", "```cs\n        try \n        { \n          int machineCount = ipAddresses.Count();                 \n          var options = new ParallelOptions(); \n          options.MaxDegreeOfParallelism = machineCount; \n          int deadMachines = 0; \n\n          Parallel.ForEach(ipAddresses, options, ip => \n          { \n\n          }); \n        } \n        catch (AggregateException aex) \n        { \n          WriteLine(\"An AggregateException has occurred\"); \n          throw; \n        }\n\n```", "```cs\n        if (MachineReturnedPing(ip)) \n        { \n\n        } \n        else \n        {                         \n          if (machineCount - Interlocked.Increment(ref deadMachines) \n              < minimumLive) \n          { \n            WriteLine($\"Machines to check = {machineCount}\"); \n            WriteLine($\"Dead machines = {deadMachines}\"); \n            WriteLine($\"Minimum machines required = {minimumLive}\"); \n            WriteLine($\"Live Machines = {machineCount - deadMachines}\"); \n            throw new Exception($\"Minimum machines requirement of \n              {minimumLive} not met\"); \n          } \n        }\n\n```", "```cs\n        public class Demo \n        { \n          public void CheckClientMachinesOnline(List<string> ipAddresses, \n            int minimumLive) \n          {         \n            try \n            { \n              int machineCount = ipAddresses.Count();                 \n              var options = new ParallelOptions(); \n              options.MaxDegreeOfParallelism = machineCount; \n              int deadMachines = 0; \n\n              Parallel.ForEach(ipAddresses, options, ip => \n              { \n                if (MachineReturnedPing(ip)) \n                { \n\n                } \n                else \n                {                         \n                  if (machineCount - Interlocked.Increment(\n                      ref deadMachines) < minimumLive) \n                  { \n                    WriteLine($\"Machines to check = {machineCount}\");                            \n                    WriteLine($\"Dead machines = {deadMachines}\"); \n                    WriteLine($\"Minimum machines required = \n                              {minimumLive}\"); \n                    WriteLine($\"Live Machines = {machineCount - \n                              deadMachines}\"); \n                    throw new Exception($\"Minimum machines requirement \n                                        of {minimumLive} not met\"); \n                  } \n                } \n              }); \n            } \n            catch (AggregateException aex) \n            { \n              WriteLine(\"An AggregateException has occurred\"); \n              throw; \n            } \n          }    \n\n          private bool MachineReturnedPing(string ip) \n          {             \n            return false; \n          }  \n        }\n\n```", "```cs\n        List<string> ipList = new List<string>(); \n        for (int i = 0; i <= 10; i++) \n        { \n          ipList.Add($\"10.0.0.{i.ToString()}\"); \n        } \n\n        try \n        { \n          Demo oRecipe = new Demo(); \n          oRecipe.CheckClientMachinesOnline(ipList, 2); \n        } \n        catch (Exception ex) \n        { \n          WriteLine(ex.InnerException.Message); \n        } \n        ReadLine();\n\n```", "```cs\n        public void LockThreadExample()\n        {\n          Task thread1 = Task.Factory.StartNew(() => ContendedResource(3));\n          Task thread2 = Task.Factory.StartNew(() => ContendedResource(5));\n          Task thread3 = Task.Factory.StartNew(() => ContendedResource(2)); \n\n          int threadID = Thread.CurrentThread.ManagedThreadId; \n          Thread.CurrentThread.Name = $\"New Thread{threadID}\";\n\n          Task.WaitAll(thread1, thread2, thread3); \n          WriteLine(\"All tasks completed\");\n        }\n\n```"]
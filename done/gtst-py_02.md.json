["```py\n>>> age = 42\n>>> age\n42\n>>> age = 43  #A\n>>> age\n43\n```", "```py\n>>> age = 42\n>>> id(age)\n4377553168\n>>> age = 43\n>>> id(age)\n4377553200\n```", "```py\n>>> class Person():\n...     def __init__(self, age):\n...         self.age = age\n...\n>>> fab = Person(age=42)\n>>> fab.age\n42\n>>> id(fab)\n4380878496\n>>> id(fab.age)\n4377553168\n>>> fab.age = 25  # I wish!\n>>> id(fab)  # will be the same\n4380878496\n>>> id(fab.age)  # will be different\n4377552624\n```", "```py\n>>> a = 14\n>>> b = 3\n>>> a + b  # addition\n17\n>>> a - b  # subtraction\n11\n>>> a * b  # multiplication\n42\n>>> a / b  # true division\n4.666666666666667\n>>> a // b  # integer division\n4\n>>> a % b  # modulo operation (reminder of division)\n2\n>>> a ** b  # power operation\n2744\n```", "```py\n>>> 7 / 4  # true division\n1.75\n>>> 7 // 4  # integer division, truncation returns 1\n1\n>>> -7 / 4  # true division again, result is opposite of previous\n-1.75\n>>> -7 // 4  # integer div., result not the opposite of previous\n-2\n```", "```py\n>>> int(1.75)\n1\n>>> int(-1.75)\n-1\n```", "```py\n>>> 10 % 3  # remainder of the division 10 // 3\n1\n>>> 10 % 4  # remainder of the division 10 // 4\n2\n```", "```py\n>>> n = 1_024\n>>> n\n1024\n>>> hex_n = 0x_4_0_0  # 0x400 == 1024\n>>> hex_n\n1024 \n```", "```py\n>>> int(True)  # True behaves like 1\n1\n>>> int(False)  # False behaves like 0\n0\n>>> bool(1)  # 1 evaluates to True in a boolean context\nTrue\n>>> bool(-42)  # and so does every non-zero number\nTrue\n>>> bool(0)  # 0 evaluates to False\nFalse\n>>> # quick peak at the operators (and, or, not)\n>>> not True\nFalse\n>>> not False\nTrue\n>>> True and True\nTrue\n>>> False or True\nTrue\n```", "```py\n>>> 1 + True\n2\n>>> False + 42\n42\n>>> 7 - True\n6 \n```", "```py\n>>> pi = 3.1415926536  # how many digits of PI can you remember?\n>>> radius = 4.5\n>>> area = pi * (radius ** 2)\n>>> area\n63.617251235400005 \n```", "```py\n>>> import sys\n>>> sys.float_info\nsys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)\n```", "```py\n>>> 0.3 - 0.1 * 3  # this should be 0!!!\n-5.551115123125783e-17 \n```", "```py\n>>> c = 3.14 + 2.73j\n>>> c.real  # real part\n3.14\n>>> c.imag  # imaginary part\n2.73\n>>> c.conjugate()  # conjugate of A + Bj is A - Bj\n(3.14-2.73j)\n>>> c * 2  # multiplication is allowed\n(6.28+5.46j)\n>>> c ** 2  # power operation as well\n(2.4067000000000007+17.1444j)\n>>> d = 1 + 1j  # addition and subtraction as well\n>>> c - d\n(2.14+1.73j)\n```", "```py\n>>> from fractions import Fraction\n>>> Fraction(10, 6)  # mad hatter?\nFraction(5, 3)  # notice it's been simplified\n>>> Fraction(1, 3) + Fraction(2, 3)  # 1/3 + 2/3 == 3/3 == 1/1\nFraction(1, 1)\n>>> f = Fraction(10, 6)\n>>> f.numerator\n5\n>>> f.denominator\n3\n```", "```py\n>>> from decimal import Decimal as D  # rename for brevity\n>>> D(3.14)  # pi, from float, so approximation issues\nDecimal('3.140000000000000124344978758017532527446746826171875')\n>>> D('3.14')  # pi, from a string, so no approximation issues\nDecimal('3.14')\n>>> D(0.1) * D(3) - D(0.3)  # from float, we still have the issue\nDecimal('2.775557561565156540423631668E-17')\n>>> D('0.1') * D(3) - D('0.3')  # from string, all perfect\nDecimal('0.0')\n>>> D('1.4').as_integer_ratio()  # 7/5 = 1.4 (isn't this cool?!)\n(7, 5)\n```", "```py\n>>> # 4 ways to make a string\n>>> str1 = 'This is a string. We built it with single quotes.'\n>>> str2 = \"This is also a string, but built with double quotes.\"\n>>> str3 = '''This is built using triple quotes,\n... so it can span multiple lines.'''\n>>> str4 = \"\"\"This too\n... is a multiline one\n... built with triple double-quotes.\"\"\"\n>>> str4  #A\n'This too\\nis a multiline one\\nbuilt with triple double-quotes.'\n>>> print(str4)  #B\nThis too\nis a multiline one\nbuilt with triple double-quotes.\n```", "```py\n>>> len(str1)\n49\n```", "```py\n>>> s = \"This is \u00fc\u014b\u00edc0de\"  # unicode string: code points\n>>> type(s)\n<class 'str'>\n>>> encoded_s = s.encode('utf-8')  # utf-8 encoded version of s\n>>> encoded_s\nb'This is \\xc3\\xbc\\xc5\\x8b\\xc3\\xadc0de'  # result: bytes object\n>>> type(encoded_s)  # another way to verify it\n<class 'bytes'>\n>>> encoded_s.decode('utf-8')  # let's revert to the original\n'This is \u00fc\u014b\u00edc0de'\n>>> bytes_obj = b\"A bytes object\"  # a bytes object\n>>> type(bytes_obj)\n<class 'bytes'>\n```", "```py\n>>> s = \"The trouble is you think you have time.\"\n>>> s[0]  # indexing at position 0, which is the first char\n'T'\n>>> s[5]  # indexing at position 5, which is the sixth char\n'r'\n>>> s[:4]  # slicing, we specify only the stop position\n'The '\n>>> s[4:]  # slicing, we specify only the start position\n'trouble is you think you have time.'\n>>> s[2:14]  # slicing, both start and stop positions\n'e trouble is'\n>>> s[2:14:3]  # slicing, start, stop and step (every 3 chars)\n'erb '\n>>> s[:]  # quick way of making a copy\n'The trouble is you think you have time.'\n```", "```py\n>>> greet_old = 'Hello %s!'\n>>> greet_old % 'Fabrizio'\n'Hello Fabrizio!'\n>>> greet_positional = 'Hello {} {}!'\n>>> greet_positional.format('Fabrizio', 'Romano')\n'Hello Fabrizio Romano!' \n>>> greet_positional_idx = 'This is {0}! {1} loves {0}!'\n>>> greet_positional_idx.format('Python', 'Fabrizio')\n'This is Python! Fabrizio loves Python!'\n>>> greet_positional_idx.format('Coffee', 'Fab')\n'This is Coffee! Fab loves Coffee!'\n >>> keyword = 'Hello, my name is {name} {last_name}'\n>>> keyword.format(name='Fabrizio', last_name='Romano')\n'Hello, my name is Fabrizio Romano'\n```", "```py\n>>> name = 'Fab'\n>>> age = 42\n>>> f\"Hello! My name is {name} and I'm {age}\"\n\"Hello! My name is Fab and I'm 42\"\n>>> from math import pi\n>>> f\"No arguing with {pi}, it's irrational...\"\n\"No arguing with 3.141592653589793, it's irrational...\"\n```", "```py\n>>> t = ()  # empty tuple\n>>> type(t)\n<class 'tuple'>\n>>> one_element_tuple = (42, )  # you need the comma!\n>>> three_elements_tuple = (1, 3, 5)  # braces are optional here\n>>> a, b, c = 1, 2, 3  # tuple for multiple assignment\n>>> a, b, c  # implicit tuple to print with one instruction\n(1, 2, 3)\n>>> 3 in three_elements_tuple  # membership test\nTrue\n```", "```py\n>>> a, b = 1, 2\n>>> c = a  # we need three lines and a temporary var c\n>>> a = b\n>>> b = c\n>>> a, b  # a and b have been swapped\n(2, 1)\n```", "```py\n>>> a, b = 0, 1\n>>> a, b = b, a  # this is the Pythonic way to do it\n>>> a, b\n(1, 0)\n```", "```py\n>>> []  # empty list\n[]\n>>> list()  # same as []\n[]\n>>> [1, 2, 3]  # as with tuples, items are comma separated\n[1, 2, 3]\n>>> [x + 5 for x in [2, 3, 4]]  # Python is magic\n[7, 8, 9]\n>>> list((1, 3, 5, 7, 9))  # list from a tuple\n[1, 3, 5, 7, 9]\n>>> list('hello')  # list from a string\n['h', 'e', 'l', 'l', 'o']\n```", "```py\n>>> a = [1, 2, 1, 3]\n>>> a.append(13)  # we can append anything at the end\n>>> a\n[1, 2, 1, 3, 13]\n>>> a.count(1)  # how many `1` are there in the list?\n2\n>>> a.extend([5, 7])  # extend the list by another (or sequence)\n>>> a\n[1, 2, 1, 3, 13, 5, 7]\n>>> a.index(13)  # position of `13` in the list (0-based indexing)\n4\n>>> a.insert(0, 17)  # insert `17` at position 0\n>>> a\n[17, 1, 2, 1, 3, 13, 5, 7]\n>>> a.pop()  # pop (remove and return) last element\n7\n>>> a.pop(3)  # pop element at position 3\n1\n>>> a\n[17, 1, 2, 3, 13, 5]\n>>> a.remove(17)  # remove `17` from the list\n>>> a\n[1, 2, 3, 13, 5]\n>>> a.reverse()  # reverse the order of the elements in the list\n>>> a\n[5, 13, 3, 2, 1]\n>>> a.sort()  # sort the list\n>>> a\n[1, 2, 3, 5, 13]\n>>> a.clear()  # remove all elements from the list\n>>> a\n[]\n```", "```py\n>>> a = list('hello')  # makes a list from a string\n>>> a\n['h', 'e', 'l', 'l', 'o']\n>>> a.append(100)  # append 100, heterogeneous type\n>>> a\n['h', 'e', 'l', 'l', 'o', 100]\n>>> a.extend((1, 2, 3))  # extend using tuple\n>>> a\n['h', 'e', 'l', 'l', 'o', 100, 1, 2, 3]\n>>> a.extend('...')  # extend using string\n>>> a\n['h', 'e', 'l', 'l', 'o', 100, 1, 2, 3, '.', '.', '.']\n```", "```py\n>>> a = [1, 3, 5, 7]\n>>> min(a)  # minimum value in the list\n1\n>>> max(a)  # maximum value in the list\n7\n>>> sum(a)  # sum of all values in the list\n16\n>>> len(a)  # number of elements in the list\n4\n>>> b = [6, 7, 8]\n>>> a + b  # `+` with list means concatenation\n[1, 3, 5, 7, 6, 7, 8]\n>>> a * 2  # `*` has also a special meaning\n[1, 3, 5, 7, 1, 3, 5, 7]\n```", "```py\n>>> from operator import itemgetter\n>>> a = [(5, 3), (1, 3), (1, 2), (2, -1), (4, 9)]\n>>> sorted(a)\n[(1, 2), (1, 3), (2, -1), (4, 9), (5, 3)]\n>>> sorted(a, key=itemgetter(0))\n[(1, 3), (1, 2), (2, -1), (4, 9), (5, 3)]\n>>> sorted(a, key=itemgetter(0, 1))\n[(1, 2), (1, 3), (2, -1), (4, 9), (5, 3)]\n>>> sorted(a, key=itemgetter(1))\n[(2, -1), (1, 2), (5, 3), (1, 3), (4, 9)]\n>>> sorted(a, key=itemgetter(1), reverse=True)\n[(4, 9), (5, 3), (1, 3), (1, 2), (2, -1)]\n```", "```py\n>>> bytearray()  # empty bytearray object\nbytearray(b'')\n>>> bytearray(10)  # zero-filled instance with given length\nbytearray(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n>>> bytearray(range(5)) # bytearray from iterable of integers\nbytearray(b'\\x00\\x01\\x02\\x03\\x04')\n>>> name = bytearray(b'Lina')  #A - bytearray from bytes\n>>> name.replace(b'L', b'l')\nbytearray(b'lina')\n>>> name.endswith(b'na')\nTrue\n>>> name.upper()\nbytearray(b'LINA')\n>>> name.count(b'L')\n1\n```", "```py\n>>> small_primes = set()  # empty set\n>>> small_primes.add(2)  # adding one element at a time\n>>> small_primes.add(3)\n>>> small_primes.add(5)\n>>> small_primes\n{2, 3, 5}\n>>> small_primes.add(1)  # Look what I've done, 1 is not a prime!\n>>> small_primes\n{1, 2, 3, 5}\n>>> small_primes.remove(1)  # so let's remove it\n>>> 3 in small_primes # membership test\nTrue\n>>> 4 in small_primes\nFalse\n>>> 4 not in small_primes  # negated membership test\nTrue\n>>> small_primes.add(3)  # trying to add 3 again\n>>> small_primes\n{2, 3, 5}  # no change, duplication is not allowed\n>>> bigger_primes = set([5, 7, 11, 13])  # faster creation\n>>> small_primes | bigger_primes # union operator `|`\n{2, 3, 5, 7, 11, 13}\n>>> small_primes & bigger_primes  # intersection operator `&`\n{5}\n>>> small_primes - bigger_primes  # difference operator `-`\n{2, 3}\n```", "```py\n>>> small_primes = {2, 3, 5, 5, 3}\n>>> small_primes\n{2, 3, 5}\n```", "```py\n>>> small_primes = frozenset([2, 3, 5, 7])\n>>> bigger_primes = frozenset([5, 7, 11])\n>>> small_primes.add(11)  # we cannot add to a frozenset\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nAttributeError: 'frozenset' object has no attribute 'add'\n>>> small_primes.remove(2)  # neither we can remove\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nAttributeError: 'frozenset' object has no attribute 'remove'\n>>> small_primes & bigger_primes  # intersect, union, etc. allowed\nfrozenset({5, 7})\n```", "```py\n>>> a = dict(A=1, Z=-1)\n>>> b = {'A': 1, 'Z': -1}\n>>> c = dict(zip(['A', 'Z'], [1, -1]))\n>>> d = dict([('A', 1), ('Z', -1)])\n>>> e = dict({'Z': -1, 'A': 1})\n>>> a == b == c == d == e  # are they all the same?\nTrue  # They are indeed\n```", "```py\n>>> list(zip(['h', 'e', 'l', 'l', 'o'], [1, 2, 3, 4, 5]))\n[('h', 1), ('e', 2), ('l', 3), ('l', 4), ('o', 5)]\n>>> list(zip('hello', range(1, 6)))  # equivalent, more Pythonic\n[('h', 1), ('e', 2), ('l', 3), ('l', 4), ('o', 5)]\n```", "```py\n>>> d = {}\n>>> d['a'] = 1  # let's set a couple of (key, value) pairs\n>>> d['b'] = 2\n>>> len(d)  # how many pairs?\n2\n>>> d['a']  # what is the value of 'a'?\n1\n>>> d  # how does `d` look now?\n{'a': 1, 'b': 2}\n>>> del d['a']  # let's remove `a`\n>>> d\n{'b': 2}\n>>> d['c'] = 3  # let's add 'c': 3\n>>> 'c' in d  # membership is checked against the keys\nTrue\n>>> 3 in d  # not the values\nFalse\n>>> 'e' in d\nFalse\n>>> d.clear()  # let's clean everything from this dictionary\n>>> d\n{}\n```", "```py\n>>> d = dict(zip('hello', range(5)))\n>>> d\n{'h': 0, 'e': 1, 'l': 3, 'o': 4}\n>>> d.keys()\ndict_keys(['h', 'e', 'l', 'o'])\n>>> d.values()\ndict_values([0, 1, 3, 4])\n>>> d.items()\ndict_items([('h', 0), ('e', 1), ('l', 3), ('o', 4)])\n>>> 3 in d.values()\nTrue\n>>> ('o', 4) in d.items()\nTrue\n```", "```py\n>>> d\n{'e': 1, 'h': 0, 'o': 4, 'l': 3}\n>>> d.popitem()  # removes a random item (useful in algorithms)\n('o', 4)\n>>> d\n{'h': 0, 'e': 1, 'l': 3}\n>>> d.pop('l')  # remove item with key `l`\n3\n>>> d.pop('not-a-key')  # remove a key not in dictionary: KeyError\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nKeyError: 'not-a-key'\n>>> d.pop('not-a-key', 'default-value')  # with a default value?\n'default-value'  # we get the default value\n>>> d.update({'another': 'value'})  # we can update dict this way\n>>> d.update(a=13)  # or this way (like a function call)\n>>> d\n{'h': 0, 'e': 1, 'another': 'value', 'a': 13}\n>>> d.get('a')  # same as d['a'] but if key is missing no KeyError\n13\n>>> d.get('a', 177)  # default value used if key is missing\n13\n>>> d.get('b', 177)  # like in this case\n177\n>>> d.get('b')  # key is not there, so None is returned\n```", "```py\n>>> d = {}\n>>> d.setdefault('a', 1)  # 'a' is missing, we get default value\n1\n>>> d\n{'a': 1}  # also, the key/value pair ('a', 1) has now been added\n>>> d.setdefault('a', 5)  # let's try to override the value\n1\n>>> d\n{'a': 1}  # no override, as expected\n```", "```py\n>>> d = {}\n>>> d.setdefault('a', {}).setdefault('b', []).append(1)\n```", "```py\n>>> vision = (9.5, 8.8)\n>>> vision\n(9.5, 8.8)\n>>> vision[0]  # left eye (implicit positional reference)\n9.5\n>>> vision[1]  # right eye (implicit positional reference)\n8.8\n```", "```py\n>>> from collections import namedtuple\n>>> Vision = namedtuple('Vision', ['left', 'right'])\n>>> vision = Vision(9.5, 8.8)\n>>> vision[0]\n9.5\n>>> vision.left  # same as vision[0], but explicit\n9.5\n>>> vision.right  # same as vision[1], but explicit\n8.8\n```", "```py\n>>> Vision = namedtuple('Vision', ['left', 'combined', 'right'])\n>>> vision = Vision(9.5, 9.2, 8.8)\n>>> vision.left  # still correct\n9.5\n>>> vision.right  # still correct (though now is vision[2])\n8.8\n>>> vision.combined  # the new vision[1]\n9.2\n```", "```py\n>>> d = {}\n>>> d['age'] = d.get('age', 0) + 1  # age not there, we get 0 + 1\n>>> d\n{'age': 1}\n>>> d = {'age': 39}\n>>> d['age'] = d.get('age', 0) + 1  # age is there, we get 40\n>>> d\n{'age': 40}\n```", "```py\n>>> from collections import defaultdict\n>>> dd = defaultdict(int)  # int is the default type (0 the value)\n>>> dd['age'] += 1  # short for dd['age'] = dd['age'] + 1\n>>> dd\ndefaultdict(<class 'int'>, {'age': 1})  # 1, as expected\n```", "```py\n>>> from collections import ChainMap\n>>> default_connection = {'host': 'localhost', 'port': 4567}\n>>> connection = {'port': 5678}\n>>> conn = ChainMap(connection, default_connection)  # map creation\n>>> conn['port']  # port is found in the first dictionary\n5678\n>>> conn['host']  # host is fetched from the second dictionary\n'localhost'\n>>> conn.maps  # we can see the mapping objects\n[{'port': 5678}, {'host': 'localhost', 'port': 4567}]\n>>> conn['host'] = 'packtpub.com'  # let's add host\n>>> conn.maps\n[{'port': 5678, 'host': 'packtpub.com'},\n {'host': 'localhost', 'port': 4567}]\n>>> del conn['port']  # let's remove the port information\n>>> conn.maps\n[{'host': 'packtpub.com'}, {'host': 'localhost', 'port': 4567}]\n>>> conn['port']  # now port is fetched from the second dictionary\n4567\n>>> dict(conn)  # easy to merge and convert to regular dictionary\n{'host': 'packtpub.com', 'port': 4567}\n```", "```py\n>>> GREEN = 1\n>>> YELLOW = 2\n>>> RED = 4\n>>> TRAFFIC_LIGHTS = (GREEN, YELLOW, RED)\n>>> # or with a dict\n>>> traffic_lights = {'GREEN': 1, 'YELLOW': 2, 'RED': 4}\n```", "```py\n>>> from enum import Enum\n>>> class TrafficLight(Enum):\n...     GREEN = 1\n...     YELLOW = 2\n...     RED = 4\n...\n>>> TrafficLight.GREEN\n<TrafficLight.GREEN: 1>\n>>> TrafficLight.GREEN.name\n'GREEN'\n>>> TrafficLight.GREEN.value\n1\n>>> TrafficLight(1)\n<TrafficLight.GREEN: 1>\n>>> TrafficLight(4)\n<TrafficLight.RED: 4>\n```", "```py\n>>> a = 1000000\n>>> b = 1000000\n>>> id(a) == id(b)\nFalse\n```", "```py\n>>> a = 5\n>>> b = 5\n>>> id(a) == id(b)\nTrue\n```", "```py\n# example customer objects \ncustomer1 = {'id': 'abc123', 'full_name': 'Master Yoda'} \ncustomer2 = {'id': 'def456', 'full_name': 'Obi-Wan Kenobi'} \ncustomer3 = {'id': 'ghi789', 'full_name': 'Anakin Skywalker'} \n# collect them in a tuple \ncustomers = (customer1, customer2, customer3) \n# or collect them in a list \ncustomers = [customer1, customer2, customer3] \n# or maybe within a dictionary, they have a unique id after all \ncustomers = { \n    'abc123': customer1, \n    'def456': customer2, \n    'ghi789': customer3, \n} \n```", "```py\n>>> a = list(range(10))  # `a` has 10 elements. Last one is 9.\n>>> a\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> len(a)  # its length is 10 elements\n10\n>>> a[len(a) - 1]  # position of last one is len(a) - 1\n9\n>>> a[-1]  # but we don't need len(a)! Python rocks!\n9\n>>> a[-2]  # equivalent to len(a) - 2\n8\n>>> a[-3]  # equivalent to len(a) - 3\n7\n```"]
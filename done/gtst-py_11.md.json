["```py\n    graph = dict() \n    graph['A'] = ['B', 'C'] \n    graph['B'] = ['E','A'] \n    graph['C'] = ['A', 'B', 'E','F'] \n    graph['E'] = ['B', 'C'] \n    graph['F'] = ['C'] \n```", "```py\n    matrix_elements = sorted(graph.keys()) \n    cols = rows = len(matrix_elements) \n```", "```py\n    adjacency_matrix = [[0 for x in range(rows)] for y in range(cols)] \n    edges_list = [] \n```", "```py\n    for key in matrix_elements: \n        for neighbor in graph[key]: \n            edges_list.append((key,neighbor)) \n```", "```py\n>>> [('A', 'B'), ('A', 'C'), ('B', 'E'), ('B', 'A'), ('C', 'A'), \n     ('C', 'B'), ('C', 'E'), ('C', 'F'), ('E', 'B'), ('E', 'C'), \n     ('F', 'C')]\n```", "```py\n    for edge in edges_list: \n        index_of_first_vertex = matrix_elements.index(edge[0]) \n        index_of_second_vertex = matrix_elements.index(edge[1]) \n        adjacecy_matrix[index_of_first_vertex][index_of_second_vertex] = 1 \n```", "```py\n>>>\n[0, 1, 1, 0, 0]\n[1, 0, 0, 1, 0]\n[1, 1, 0, 1, 1]\n[0, 1, 1, 0, 0]\n[0, 0, 1, 0, 0]\n```", "```py\n    graph = dict() \n    graph['A'] = ['B', 'G', 'D'] \n    graph['B'] = ['A', 'F', 'E'] \n    graph['C'] = ['F', 'H'] \n    graph['D'] = ['F', 'A'] \n    graph['E'] = ['B', 'G'] \n    graph['F'] = ['B', 'D', 'C'] \n    graph['G'] = ['A', 'E'] \n    graph['H'] = ['C'] \n```", "```py\n    from collections import deque \n\n    def breadth_first_search(graph, root): \n        visited_vertices = list() \n        graph_queue = deque([root]) \n        visited_vertices.append(root) \n        node = root \n\n        while len(graph_queue) > 0: \n            node = graph_queue.popleft() \n            adj_nodes = graph[node] \n\n            remaining_elements = \n                set(adj_nodes).difference(set(visited_vertices)) \n            if len(remaining_elements) > 0: \n                for elem in sorted(remaining_elements): \n                    visited_vertices.append(elem) \n                    graph_queue.append(elem) \n\n        return visited_vertices \n```", "```py\n    def depth_first_search(graph, root): \n        visited_vertices = list() \n        graph_stack = list() \n\n        graph_stack.append(root) \n        node = root \n```", "```py\n        while len(graph_stack) > 0: \n\n            if node not in visited_vertices: \n                visited_vertices.append(node) \n\n            adj_nodes = graph[node] \n\n            if set(adj_nodes).issubset(set(visited_vertices)): \n                graph_stack.pop() \n            if len(graph_stack) > 0: \n                node = graph_stack[-1] \n                continue \n            else: \n                remaining_elements = \n                set(adj_nodes).difference(set(visited_vertices)) \n\n            first_adj_node = sorted(remaining_elements)[0] \n            graph_stack.append(first_adj_node) \n            node = first_adj_node \n                return visited_vertices \n```", "```py\n    graph = dict() \n    graph['A'] = ['B', 'S'] \n    graph['B'] = ['A'] \n    graph['S'] = ['A','G','C'] \n    graph['D'] = ['C'] \n    graph['G'] = ['S','F','H'] \n    graph['H'] = ['G','E'] \n    graph['E'] = ['C','H'] \n    graph['F'] = ['C','G'] \n    graph['C'] = ['D','S','E','F'] \n```", "```py\n    if set(adj_nodes).issubset(set(visited_vertices)): \n        graph_stack.pop() \n        if len(graph_stack) > 0: \n            node = graph_stack[-1] \n        continue \n```", "```py\n    first_adj_node = sorted(remaining_elements)[0] \n    graph_stack.append(first_adj_node) \n    node = first_adj_node \n```", "```py\n     class Heap: \n        def __init__(self): \n            self.heap = [0] \n            self.size = 0 \n```", "```py\n    def float(self, k): \n```", "```py\n        while k // 2 > 0: \n```", "```py\n        if self.heap[k] < self.heap[k//2]: \n            self.heap[k], self.heap[k//2] = self.heap[k//2], \n            self.heap[k] \n```", "```py\n        k //= 2 \n```", "```py\n    def insert(self, item): \n        self.heap.append(item) \n        self.size += 1 \n        self.float(self.size) \n```", "```py\n    def minindex(self, k): \n```", "```py\n        if k * 2 + 1 > self.size: \n            return k * 2 \n```", "```py\n        elif self.heap[k*2] < self.heap[k*2+1]: \n            return k * 2 \n        else: \n            return k * 2 + 1 \n```", "```py\n    def sink(self, k): \n```", "```py\n        while k * 2 <= self.size: \n```", "```py\n            mi = self.minindex(k) \n```", "```py\n            if self.heap[k] > self.heap[mi]: \n                self.heap[k], self.heap[mi] = self.heap[mi], \n                self.heap[k] \n```", "```py\n            k = mi \n```", "```py\n    def pop(self): \n        item = self.heap[1] \n        self.heap[1] = self.heap[self.size] \n        self.size -= 1 \n        self.heap.pop() \n        self.sink(1) \n        return item\n```", "```py\n    h = Heap() \n    for i in (4, 8, 7, 2, 9, 10, 5, 1, 3, 6): \n        h.insert(i) \n```", "```py\n    print(h.heap) \n```", "```py\n    for i in range(10): \n        n = h.pop() \n        print(n) \n        print(h.heap) \n```"]
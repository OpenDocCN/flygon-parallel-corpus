- en: Object-Oriented Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象设计
- en: 'In software development, design is often considered as the step done *before*
    programming. This isn''t true; in reality, analysis, programming, and design tend
    to overlap, combine, and interweave. In this chapter, we will cover the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，设计通常被认为是编程之前的步骤。这并不正确；实际上，分析、编程和设计往往重叠、结合和交织。在本章中，我们将涵盖以下主题：
- en: What object-oriented means
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象的含义
- en: The difference between object-oriented design and object-oriented programming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象设计和面向对象编程之间的区别
- en: The basic principles of object-oriented design
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象设计的基本原则
- en: Basic **Unified Modeling Language** (**UML**) and when it isn't evil
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的**统一建模语言**（**UML**）及其不邪恶的时候
- en: Introducing object-oriented
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍面向对象
- en: 'Everyone knows what an object is: a tangible thing that we can sense, feel,
    and manipulate. The earliest objects we interact with are typically baby toys.
    Wooden blocks, plastic shapes, and over-sized puzzle pieces are common first objects.
    Babies learn quickly that certain objects do certain things: bells ring, buttons
    are pressed, and levers are pulled.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都知道什么是对象：我们可以感知、感觉和操作的有形物体。我们最早接触的对象通常是婴儿玩具。木块、塑料形状和超大拼图块是常见的第一个对象。婴儿很快学会了某些对象会做某些事情：铃响、按钮被按下，杠杆被拉动。
- en: The definition of an object in software development is not terribly different.
    Software objects may not be tangible things that you can pick up, sense, or feel,
    but they are models of something that can do certain things and have certain things
    done to them. Formally, an object is a collection of **data** and associated **behaviors**.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，对象的定义并没有太大的不同。软件对象可能不是可以拿起、感知或感觉的有形物体，但它们是能够做某些事情并且可以对它们做某些事情的模型。形式上，一个对象是一组**数据**和相关**行为**。
- en: So, knowing what an object is, what does it mean to be object-oriented? In the
    dictionary, *oriented* means *directed toward*. So object-oriented means functionally
    directed toward modeling objects. This is one of many techniques used for modeling
    complex systems. It is defined by describing a collection of interacting objects
    via their data and behavior.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，知道了什么是对象，什么是面向对象呢？在词典中，*oriented*的意思是*朝向*。因此，面向对象意味着在功能上朝向建模对象。这是用于建模复杂系统的众多技术之一。它通过描述一组通过它们的数据和行为相互作用的对象来定义。
- en: If you've read any hype, you've probably come across the terms *object-oriented
    analysis*, *object-oriented design*, *object-oriented analysis and design*, and
    *object-oriented programming*. These are all highly related concepts under the
    general *object-oriented* umbrella.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你读过一些炒作，你可能会遇到*面向对象分析*、*面向对象设计*、*面向对象分析与设计*和*面向对象编程*等术语。这些都是与*面向对象*相关的概念。
- en: In fact, analysis, design, and programming are all stages of software development.
    Calling them object-oriented simply specifies what level of software development
    is being pursued.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，分析、设计和编程都是软件开发的各个阶段。将它们称为面向对象只是指定了正在追求的软件开发水平。
- en: '**Object-oriented analysis** (**OOA**) is the process of looking at a problem,
    system, or task (that somebody wants to turn into an application) and identifying
    the objects and interactions between those objects. The analysis stage is all
    about *what* needs to be done.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象分析**（**OOA**）是查看一个问题、系统或任务（某人想要将其转化为应用程序）并识别对象和对象之间交互的过程。分析阶段关乎于*需要*做什么。'
- en: 'The output of the analysis stage is a set of requirements. If we were to complete
    the analysis stage in one step, we would have turned a task, such as *I need a
    website*, into a set of requirements.  As an example, here or some requirements
    as to what a website visitor might need to do (*italic* represents actions, **bold**
    represents objects):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 分析阶段的输出是一组需求。如果我们能够在一个步骤中完成分析阶段，我们将把一个任务，比如*我需要一个网站*，转化为一组需求。例如，这里有一些关于网站访问者可能需要做的需求（*斜体*表示动作，**粗体**表示对象）：
- en: '*Review* our **history**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*回顾*我们的**历史**'
- en: '*Apply* for **jobs**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*申请* **工作**'
- en: '*Browse*, *compare*, and *order* **products**'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*浏览*、*比较*和*订购* **产品**'
- en: In some ways, *analysis* is a misnomer. The baby we discussed earlier doesn't
    analyze the blocks and puzzle pieces. Instead, she explores her environment, manipulates
    shapes, and sees where they might fit. A better turn of phrase might be *object-oriented
    exploration*. In software development, the initial stages of analysis include
    interviewing customers, studying their processes, and eliminating possibilities.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，*分析*是一个误称。我们之前讨论的婴儿并不分析木块和拼图块。相反，她探索她的环境，操纵形状，并看看它们可能适合在哪里。一个更好的说法可能是*面向对象的探索*。在软件开发中，分析的初始阶段包括采访客户，研究他们的流程，并排除可能性。
- en: '**Object-oriented design** (**OOD**) is the process of converting such requirements
    into an implementation specification. The designer must name the objects, define
    the behaviors, and formally specify which objects can activate specific behaviors
    on other objects. The design stage is all about *how* things should be done.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象设计**（**OOD**）是将这些要求转化为实现规范的过程。设计师必须命名对象，定义行为，并正式指定哪些对象可以激活其他对象上的特定行为。设计阶段关乎于*如何*完成事情。'
- en: The output of the design stage is an implementation specification. If we were
    to complete the design stage in a single step, we would have turned the requirements
    defined during object-oriented analysis into a set of classes and interfaces that
    could be implemented in (ideally) any object-oriented programming language.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 设计阶段的输出是一个实现规范。如果我们能够在一个步骤中完成设计阶段，我们将把面向对象分析期间定义的需求转化为一组类和接口，这些类和接口可以在（理想情况下）任何面向对象编程语言中实现。
- en: '**Object-oriented programming** (**OOP**) is the process of converting this
    perfectly-defined design into a working program that does exactly what the CEO
    originally requested.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）是将这个完全定义的设计转化为一个完全满足CEO最初要求的工作程序的过程。'
- en: Yeah, right! It would be lovely if the world met this ideal and we could follow
    these stages one by one, in perfect order, like all the old textbooks told us
    to. As usual, the real world is much murkier. No matter how hard we try to separate
    these stages, we'll always find things that need further analysis while we're
    designing. When we're programming, we find features that need clarification in
    the design.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，没错！如果世界符合这个理想，我们可以按照这些阶段一步一步地按照完美的顺序进行，就像所有旧教科书告诉我们的那样。通常情况下，现实世界要复杂得多。无论我们多么努力地分隔这些阶段，我们总会发现在设计时需要进一步分析的事情。当我们编程时，我们会发现设计中需要澄清的特性。
- en: Most twenty-first century development happens in an iterative development model.
    In iterative development, a small part of the task is modeled, designed, and programmed,
    and then the program is reviewed and expanded to improve each feature and include
    new features in a series of short development cycles.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 21世纪的大部分开发都是以迭代开发模型进行的。在迭代开发中，任务的一小部分被建模、设计和编程，然后程序被审查和扩展，以改进每个功能并在一系列短期开发周期中包括新功能。
- en: The rest of this book is about object-oriented programming, but in this chapter,
    we will cover the basic object-oriented principles in the context of design. This
    allows us to understand these (rather simple) concepts without having to argue
    with software syntax or Python tracebacks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的其余部分是关于面向对象编程的，但在本章中，我们将在设计的背景下介绍基本的面向对象原则。这使我们能够理解这些（相当简单的）概念，而不必与软件语法或Python的错误信息争论。
- en: Objects and classes
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象和类
- en: So, an object is a collection of data with associated behaviors. How do we differentiate
    between types of objects? Apples and oranges are both objects, but it is a common
    adage that they cannot be compared. Apples and oranges aren't modeled very often
    in computer programming, but let's pretend we're doing an inventory application
    for a fruit farm. To facilitate the example, we can assume that apples go in barrels
    and oranges go in baskets.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对象是具有相关行为的数据集合。我们如何区分对象的类型？苹果和橙子都是对象，但有一个常见的谚语说它们不能相提并论。苹果和橙子在计算机编程中并不经常被建模，但让我们假设我们正在为一个水果农场做库存应用。为了便于理解，我们可以假设苹果放在桶里，橙子放在篮子里。
- en: 'Now, we have four kinds of objects: apples, oranges, baskets, and barrels.
    In object-oriented modeling, the term used for a *kind of object* is **class**.
    So, in technical terms, we now have four classes of objects.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有四种对象：苹果、橙子、篮子和桶。在面向对象建模中，用于表示*对象类型*的术语是**类**。因此，在技术术语中，我们现在有四个对象类。
- en: 'It''s important to understand the difference between an object and a class.
    Classes describe objects. They are like blueprints for creating an object. You
    might have three oranges sitting on the table in front of you. Each orange is
    a distinct object, but all three have the attributes and behaviors associated
    with one class: the general class of oranges.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 理解对象和类之间的区别很重要。类描述对象。它们就像创建对象的蓝图。你可能在桌子上看到三个橙子。每个橙子都是一个独特的对象，但所有三个都具有与一个类相关的属性和行为：橙子的一般类。
- en: 'The relationship between the four classes of objects in our inventory system
    can be described using a **Unified Modeling Language** (invariably referred to
    as **UML**, because three-letter acronyms never go out of style) class diagram.
    Here is our first class diagram:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们库存系统中的四个对象类之间的关系可以使用**统一建模语言**（通常简称为**UML**，因为三个字母的缩写永远不会过时）类图来描述。这是我们的第一个类图：
- en: '![](assets/3cb4d194-9753-4636-bd36-dbeb26140d58.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3cb4d194-9753-4636-bd36-dbeb26140d58.png)'
- en: This diagram shows that an **Orange** is somehow associated with a **Basket**
    and that an **Apple** is also somehow associated with a **Barrel**. *Association*
    is the most basic way for two classes to be related.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图表显示**橙子**与**篮子**以某种方式相关联，而**苹果**也以某种方式与**桶**相关联。*关联*是两个类相关的最基本方式。
- en: UML is very popular among managers, and occasionally disparaged by programmers.
    The syntax of a UML diagram is generally pretty obvious; you don't have to read
    a tutorial to (mostly) understand what is going on when you see one. UML is also
    fairly easy to draw, and quite intuitive. After all, many people, when describing
    classes and their relationships, will naturally draw boxes with lines between
    them. Having a standard based on these intuitive diagrams makes it easy for programmers
    to communicate with designers, managers, and each other.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: UML在经理中非常受欢迎，有时会受到程序员的贬低。UML图表的语法通常相当明显；当你看到一个UML图表时，你不必阅读教程就能（大部分）理解发生了什么。UML也相当容易绘制，而且相当直观。毕竟，许多人在描述类及其关系时，自然会画出盒子和它们之间的线。基于这些直观图表的标准使程序员能够与设计师、经理和彼此进行轻松的沟通。
- en: However, some programmers think UML is a waste of time. Citing iterative development,
    they will argue that formal specifications done up in fancy UML diagrams are going
    to be redundant before they're implemented, and that maintaining these formal
    diagrams will only waste time and not benefit anyone.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些程序员认为UML是浪费时间。他们引用迭代开发，他们会认为用花哨的UML图表制定的正式规范在实施之前就会变得多余，并且维护这些正式图表只会浪费时间，对任何人都没有好处。
- en: Depending on the corporate structure involved, this may or may not be true.
    However, every programming team consisting of more than one person will occasionally
    have to sit down and hash out the details of the subsystem it is currently working
    on. UML is extremely useful in these brainstorming sessions for quick and easy
    communication. Even those organizations that scoff at formal class diagrams tend
    to use some informal version of UML in their design meetings or team discussions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于所涉及的公司结构，这可能是真的，也可能不是真的。然而，每个由多个人组成的编程团队都会偶尔坐下来详细讨论他们当前正在处理的子系统的细节。在这些头脑风暴会议中，UML非常有用，可以进行快速而轻松的沟通。即使那些嘲笑正式类图的组织也倾向于在设计会议或团队讨论中使用某种非正式版本的UML。
- en: Furthermore, the most important person you will ever have to communicate with
    is yourself. We all think we can remember the design decisions we've made, but
    there will always be the *Why did I do that?* moments hiding in our future. If
    we keep the scraps of papers we did our initial diagramming on when we started
    a design, we'll eventually find them a useful reference.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你将要与之交流的最重要的人是你自己。我们都认为自己能记住我们所做的设计决策，但在未来总会有*我为什么那样做？*的时刻。如果我们保存我们在开始设计时做初始图表的纸屑，最终我们会发现它们是有用的参考资料。
- en: This chapter, however, is not meant to be a tutorial on UML. There are many
    of those available on the internet, as well as numerous books on the topic. UML
    covers far more than class and object diagrams; it also has a syntax for use cases,
    deployment, state changes, and activities. We'll be dealing with some common class
    diagram syntax in this discussion of object-oriented design. You can pick up the
    structure by example, and you'll subconsciously choose the UML-inspired syntax
    in your own team or personal design sessions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本章并不意味着是UML的教程。互联网上有许多这方面的教程，以及大量关于这个主题的书籍。UML涵盖的远不止类和对象图表；它还有用例、部署、状态变化和活动的语法。在这个面向对象设计的讨论中，我们将处理一些常见的类图表语法。你可以通过示例了解结构，并在你自己的团队或个人设计会议中下意识地选择受UML启发的语法。
- en: Our initial diagram, while correct, does not remind us that apples go in barrels
    or how many barrels a single apple can go in. It only tells us that apples are
    somehow associated with barrels. The association between classes is often obvious
    and needs no further explanation, but we have the option to add further clarification
    as needed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的初始图表虽然是正确的，但没有提醒我们苹果是放在桶里的，或者一个苹果可以放在多少个桶里。它只告诉我们苹果与桶子有某种关联。类之间的关联通常是显而易见的，不需要进一步解释，但我们可以根据需要添加进一步的说明。
- en: 'The beauty of UML is that most things are optional. We only need to specify
    as much information in a diagram as makes sense for the current situation. In
    a quick whiteboard session, we might just quickly draw lines between boxes. In
    a formal document, we might go into more detail. In the case of apples and barrels,
    we can be fairly confident that the association is **many apples go in one barrel**,
    but just to make sure nobody confuses it with **one apple spoils one barrel**,
    we can enhance the diagram as shown:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: UML的美妙之处在于大多数东西都是可选的。我们只需要在图表中指定与当前情况相符的信息。在一个快速的白板会议中，我们可能只是快速地在方框之间画线。在正式文件中，我们可能会更详细地说明。在苹果和桶子的情况下，我们可以相当有信心地说这个关联是**许多苹果放在一个桶里**，但为了确保没有人将其与**一个苹果糟蹋一个桶**混淆，我们可以增强图表如下所示：
- en: '![](assets/efa10098-f74b-4cdb-96b3-e95491f940ac.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/efa10098-f74b-4cdb-96b3-e95491f940ac.png)'
- en: This diagram tells us that oranges **go in** baskets, with a little arrow showing
    what goes in what. It also tells us the number of that object that can be used
    in the association on both sides of the relationship. One **Basket** can hold
    many (represented by a *****) **Orange** objects. Any one **Orange** can go in
    exactly one **Basket**. This number is referred to as the *multiplicity* of the
    object. You may also hear it described as the *cardinality*. These are actually
    slightly distinct terms. Cardinality refers to the actual number of items in the
    set, whereas multiplicity specifies how small or how large the set could be.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表告诉我们橙子**放在**篮子里，有一个小箭头显示了什么放在什么里。它还告诉我们在关联的两端可以使用的对象的数量。一个**Basket**可以容纳许多（用*****表示）**Orange**对象。任何一个**Orange**可以放在一个**Basket**里。这个数字被称为对象的*多重性*。你可能也听说过它被描述为*基数*。这些实际上是稍微不同的术语。基数是指集合中实际的项目数量，而多重性指定了集合可以有多小或多大。
- en: I sometimes forget which end of the relationship line is supposed to have which
    multiplicity number. The multiplicity nearest to a class is the number of objects
    of that class that can be associated with any one object at the other end of the
    association. For the apple goes in barrel association, reading from left to right,
    many instances of the **Apple** class (that is many **Apple** objects) can go
    in any one **Barrel**. Reading from right to left, exactly one **Barrel** can
    be associated with any one **Apple**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我有时会忘记关系线的哪一端应该有哪个多重性数字。靠近类的多重性是该类的对象可以与关联的另一端的任何一个对象相关联的数量。对于苹果放在桶子的关联，从左到右阅读，**Apple**类的许多实例（即许多**Apple**对象）可以放在任何一个**Barrel**中。从右到左阅读，一个**Barrel**可以与任何一个**Apple**相关联。
- en: Specifying attributes and behaviors
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定属性和行为
- en: We now have a grasp of some basic object-oriented terminology. Objects are instances
    of classes that can be associated with each other. An object instance is a specific
    object with its own set of data and behaviors; a specific orange on the table
    in front of us is said to be an instance of the general class of oranges. That's
    simple enough, but let's dive into the meaning of those two words, *data* and
    *behaviors*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对一些基本的面向对象术语有了了解。对象是可以相互关联的类的实例。对象实例是具有自己一组数据和行为的特定对象；我们面前桌子上的一个特定的橙子被称为是橙子类的一个实例。这已经足够简单了，但让我们深入探讨一下这两个词的含义，*数据*和*行为*。
- en: Data describes objects
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据描述对象
- en: Let's start with data. Data represents the individual characteristics of a certain
    object. A class can define specific sets of characteristics that are shared by
    all objects from that class. Any specific object can have different data values
    for the given characteristics. For example, the three oranges on our table (if
    we haven't eaten any) could each weigh a different amount. The orange class could
    have a weight attribute to represent that datum. All instances of the orange class
    have a weight attribute, but each orange has a different value for this attribute.
    Attributes don't have to be unique, though; any two oranges may weigh the same
    amount. As a more realistic example, two objects representing different customers
    might have the same value for a first name attribute.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从数据开始。数据代表特定对象的个体特征。一个类可以定义所有该类对象共享的特定特征集。任何特定对象可以对给定特征具有不同的数据值。例如，我们桌子上的三个橙子（如果我们没有吃掉）可能每个重量都不同。橙子类可以有一个重量属性来表示这个数据。橙子类的所有实例都有一个重量属性，但是每个橙子对于这个属性有不同的值。属性不必是唯一的，任何两个橙子可能重量相同。作为一个更现实的例子，代表不同客户的两个对象可能对于名字属性有相同的值。
- en: Attributes are frequently referred to as **members** or **properties**. Some
    authors suggest that the terms have different meanings, usually that attributes
    are settable, while properties are read-only. In Python, the concept of *read-only* is
    rather pointless, so throughout this book, we'll see the two terms used interchangeably.
    In addition, as we'll discuss in [Chapter 19](e639a907-22c5-4f1d-b125-f2b9a269c9f6.xhtml),
    *When to Use Object-Oriented Programming*, the `property` keyword has a special
    meaning in Python for a particular kind of attribute.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 属性经常被称为**成员**或**属性**。一些作者认为这些术语有不同的含义，通常是属性是可设置的，而属性是只读的。在Python中，*只读*的概念相当无意义，所以在本书中，我们会看到这两个术语可以互换使用。此外，正如我们将在[第19章](e639a907-22c5-4f1d-b125-f2b9a269c9f6.xhtml)中讨论的那样，`property`关键字在Python中对于特定类型的属性有特殊的含义。
- en: 'In our fruit inventory application, the fruit farmer may want to know what
    orchard the orange came from, when it was picked, and how much it weighs. They
    might also want to keep track of where each **Basket** is stored. Apples might
    have a color attribute, and barrels might come in different sizes. Some of these
    properties may also belong to multiple classes (we may want to know when apples
    are picked, too), but for this first example, let''s just add a few different
    attributes to our class diagram:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的水果库存应用程序中，果农可能想要知道橙子来自哪个果园，何时采摘，以及重量是多少。他们可能还想跟踪每个**篮子**存放在哪里。苹果可能有颜色属性，桶可能有不同的大小。这些属性中的一些也可能属于多个类（我们可能也想知道何时采摘苹果），但是对于这个第一个例子，让我们只向我们的类图添加一些不同的属性：
- en: '![](assets/a51e0907-ddd5-4591-8c84-f2631eb9598c.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a51e0907-ddd5-4591-8c84-f2631eb9598c.png)'
- en: 'Depending on how detailed our design needs to be, we can also specify the type
    for each attribute. Attribute types are often primitives that are standard to
    most programming languages, such as integer, floating-point number, string, byte,
    or Boolean. However, they can also represent data structures such as lists, trees,
    or graphs, or most notably, other classes. This is one area where the design stage
    can overlap with the programming stage. The various primitives or objects available
    in one programming language may be different from what is available in another:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的设计需要多么详细，我们还可以为每个属性指定类型。属性类型通常是大多数编程语言中标准的原始数据类型，例如整数、浮点数、字符串、字节或布尔值。然而，它们也可以表示数据结构，如列表、树或图，或者更重要的是其他类。这是设计阶段可以与编程阶段重叠的一个领域。一个编程语言中可用的各种原始数据类型或对象可能与另一个编程语言中可用的不同：
- en: '![](assets/9197d2fe-33b3-4c8d-aff5-c0316b177366.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9197d2fe-33b3-4c8d-aff5-c0316b177366.png)'
- en: Usually, we don't need to be overly concerned with data types at the design
    stage, as implementation-specific details are chosen during the programming stage.
    Generic names are normally sufficient for design. If our design calls for a list
    container type, Java programmers can choose to use a `LinkedList` or an `ArrayList`
    when implementing it, while Python programmers (that's us!) might choose between
    the `list` built-in and a `tuple`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在设计阶段我们不需要过于关注数据类型，因为在编程阶段会选择实现特定的细节。对于设计来说，通用名称通常足够了。如果我们的设计需要列表容器类型，Java程序员可以选择在实现时使用`LinkedList`或`ArrayList`，而Python程序员（就是我们！）可能会在`list`内置和`tuple`之间进行选择。
- en: In our fruit-farming example so far, our attributes are all basic primitives.
    However, there are some implicit attributes that we can make explicit—the associations.
    For a given orange, we might have an attribute referring to the basket that holds
    that orange.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的水果种植示例中，我们的属性都是基本的原始数据类型。然而，有一些隐含的属性我们可以明确表示——关联。对于给定的橙子，我们可能有一个属性指向包含该橙子的篮子。
- en: Behaviors are actions
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为是动作
- en: Now that we know what data is, the last undefined term is *behaviors*. Behaviors
    are actions that can occur on an object. The behaviors that can be performed on
    a specific class of object are called **methods**. At the programming level, methods
    are like functions in structured programming, but they *magically* have access
    to all the data associated with this object. Like functions, methods can also
    accept **parameters** and return **values**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了数据是什么，最后一个未定义的术语是*行为*。行为是可以在对象上发生的动作。可以在特定对象类上执行的行为称为**方法**。在编程级别上，方法就像结构化编程中的函数，但是它们*神奇地*可以访问与该对象关联的所有数据。与函数一样，方法也可以接受**参数**并返回**值**。
- en: A method's parameters are provided to it as a list of objects that need to be
    **passed** into that method. The actual object instances that are passed into
    a method during a specific invocation are usually referred to as **arguments**.
    These objects are used by the method to perform whatever behavior or task it is
    meant to do. Returned values are the results of that task.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的参数以对象列表的形式提供给它。在特定调用期间传递给方法的实际对象实例通常被称为**参数**。这些对象被方法用于执行其所需的行为或任务。返回的值是该任务的结果。
- en: 'We''ve stretched our *comparing apples and oranges* example into a basic (if
    far-fetched) inventory application. Let''s stretch it a little further and see
    whether it breaks. One action that can be associated with oranges is the **pick**
    action. If you think about implementation, **pick** would need to do two things:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将我们*比较苹果和橙子*的例子扩展成了一个基本的（虽然牵强）库存应用程序。让我们再扩展一下，看看是否会出现问题。可以与橙子相关联的一个动作是**采摘**。如果考虑实现，**采摘**需要做两件事：
- en: Place the orange in a basket by updating the **Basket** attribute of the orange
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过更新橙子的**篮子**属性将橙子放入篮子中
- en: Add the orange to the **Orange** list on the given **Basket**.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将橙子添加到给定**篮子**上的**橙子**列表中。
- en: So, **pick** needs to know what basket it is dealing with. We do this by giving
    the **pick** method a **Basket** parameter. Since our fruit farmer also sells
    juice, we can add a **squeeze** method to the **Orange** class. When called, the
    **squeeze** method might return the amount of juice retrieved, while also removing
    the **Orange** from the **Basket** it was in.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**采摘**需要知道它正在处理的篮子是哪一个。我们通过给**采摘**方法一个**篮子**参数来实现这一点。由于我们的果农还销售果汁，我们可以在**橙子**类中添加一个**挤**方法。当调用时，**挤**方法可能会返回所取得的果汁量，同时将**橙子**从其所在的**篮子**中移除。
- en: 'The class **Basket** can have a **sell** action. When a basket is sold, our
    inventory system might update some data on as-yet unspecified objects for accounting
    and profit calculations. Alternatively, our basket of oranges might go bad before
    we can sell them, so we add a **discard** method. Let''s add these methods to
    our diagram:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**篮子**类可以有一个**卖**的动作。当篮子被卖出时，我们的库存系统可能会更新一些尚未指定的对象的数据，用于会计和利润计算。或者，我们的橙子篮在我们卖出之前可能会变坏，所以我们添加了一个**丢弃**的方法。让我们把这些方法添加到我们的图表中：'
- en: '![](assets/66193cca-e9ef-4a2b-85fc-c9854405daac.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/66193cca-e9ef-4a2b-85fc-c9854405daac.png)'
- en: Adding attributes and methods to individual objects allows us to create a **system**
    of interacting objects. Each object in the system is a member of a certain class.
    These classes specify what types of data the object can hold and what methods
    can be invoked on it. The data in each object can be in a different state from
    other instances of the same class; each object may react to method calls differently
    because of the differences in state.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 向个别对象添加属性和方法使我们能够创建一个相互作用的对象系统。系统中的每个对象都是某个类的成员。这些类指定了对象可以保存的数据类型以及可以在其上调用的方法。每个对象中的数据可能与同一类的其他实例处于不同的状态；由于状态的不同，每个对象对方法调用的反应可能会有所不同。
- en: Object-oriented analysis and design is all about figuring out what those objects
    are and how they should interact. The next section describes principles that can
    be used to make those interactions as simple and intuitive as possible.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的分析和设计主要是弄清楚这些对象是什么，以及它们应该如何相互作用。接下来的部分描述了可以用来使这些交互尽可能简单和直观的原则。
- en: Hiding details and creating the public interface
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏细节并创建公共接口
- en: The key purpose of modeling an object in object-oriented design is to determine
    what the public **interface** of that object will be. The interface is the collection
    of attributes and methods that other objects can access to interact with that
    object. They do not need, and are often not allowed, to access the internal workings
    of the object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象设计中对对象进行建模的关键目的是确定该对象的公共**接口**。接口是其他对象可以访问以与该对象交互的属性和方法的集合。它们不需要，通常也不允许访问对象的内部工作。
- en: A common real-world example is the television. Our interface to the television
    is the remote control. Each button on the remote control represents a method that
    can be called on the television object. When we, as the calling object, access
    these methods, we do not know or care if the television is getting its signal
    from a cable connection, a satellite dish, or an internet-enabled device. We don't
    care what electronic signals are being sent to adjust the volume, or whether the
    sound is destined for speakers or headphones. If we open the television to access
    the internal workings, for example, to split the output signal to both external
    speakers and a set of headphones, we will void the warranty.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的现实世界的例子是电视。我们与电视的接口是遥控器。遥控器上的每个按钮代表着可以在电视对象上调用的方法。当我们作为调用对象访问这些方法时，我们不知道也不关心电视是通过有线连接、卫星接收器还是互联网设备接收信号。我们不关心调整音量时发送的电子信号，或者声音是发往扬声器还是耳机。如果我们打开电视以访问内部工作，例如将输出信号分成外部扬声器和一副耳机，我们将会失去保修。
- en: This process of hiding the implementation of an object is suitably called **information
    hiding**. It is also sometimes referred to as **encapsulation**, but encapsulation
    is actually a more all-encompassing term. Encapsulated data is not necessarily
    hidden. Encapsulation is, literally, creating a capsule (think of creating a time
    capsule). If you put a bunch of information into a time capsule, and lock and
    bury it, it is both encapsulated and the information is hidden. On the other hand,
    if the time capsule, has not been buried and is unlocked or made of clear plastic,
    the items inside it are still encapsulated, but there is no information hiding.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种隐藏对象实现的过程称为**信息隐藏**。有时也被称为**封装**，但封装实际上是一个更全面的术语。封装的数据不一定是隐藏的。封装，字面上来说，是创建一个胶囊（想象一下制作一个时间胶囊）。如果你把一堆信息放进一个时间胶囊里，然后锁上并埋起来，它既被封装又被隐藏。另一方面，如果时间胶囊没有被埋起来，是解锁的或者是由透明塑料制成的，里面的物品仍然被封装，但没有信息隐藏。
- en: The distinction between encapsulation and information hiding is largely irrelevant,
    especially at the design level. Many practical references use these terms interchangeably.
    As Python programmers, we don't actually have or need true information hiding
    (we'll discuss the reasons for this in [Chapter 16](9179e7f0-fea3-4c8a-b134-a190544099b4.xhtml),
    *Objects in Python*), so the more encompassing definition for encapsulation is
    suitable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 封装和信息隐藏之间的区别在设计层面上基本上是无关紧要的。许多实际参考资料都将这些术语互换使用。作为Python程序员，我们实际上并不需要真正的信息隐藏（我们将在《Python对象》一章中讨论这一点的原因），因此更全面的封装定义是合适的。
- en: The public interface, however, is very important. It needs to be carefully designed
    as it is difficult to change it in the future. Changing the interface will break
    any client objects that are accessing it. We can change the internals all we like,
    for example, to make it more efficient, or to access data over the network as
    well as locally, and the client objects will still be able to talk to it, unmodified,
    using the public interface. On the other hand, if we alter the interface by changing
    publicly accessed attribute names or the order or types of arguments that a method
    can accept, all client classes will also have to be modified. When designing public
    interfaces, keep it simple. Always design the interface of an object based on
    how easy it is to use, not how hard it is to code (this advice applies to user
    interfaces as well).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，公共接口非常重要。它需要仔细设计，因为将来很难更改它。更改接口将破坏任何正在访问它的客户对象。我们可以随意更改内部，例如使其更有效，或者在本地和网络上访问数据，客户对象仍然可以使用公共接口与之通信，而无需修改。另一方面，如果我们通过更改公开访问的属性名称或方法可以接受的参数的顺序或类型来更改接口，所有客户类也必须进行修改。在设计公共接口时，保持简单。始终根据使用的便捷性而不是编码的难度来设计对象的接口（这个建议也适用于用户界面）。
- en: Remember, program objects may represent real objects, but that does not make
    them real objects. They are models. One of the greatest gifts of modeling is the
    ability to ignore irrelevant details. The model car I built as a child looked
    like a real 1956 Thunderbird on the outside, but it obviously doesn't run. When
    I was too young to drive, these details were overly complex and irrelevant. The
    model is an **abstraction** of a real concept.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，程序对象可能代表真实对象，但这并不意味着它们是真实对象。它们是模型。建模的最大好处之一是能够忽略不相关的细节。我小时候制作的模型汽车外观看起来像一辆真正的1956年的雷鸟，但显然它不能跑。当我还太小不能开车时，这些细节过于复杂和无关紧要。这个模型是对真实概念的**抽象**。
- en: '**Abstraction** is another object-oriented term related to encapsulation and
    information hiding.  Abstraction means dealing with the level of detail that is
    most appropriate to a given task. It is the process of extracting a public interface
    from the inner details. A car''s driver needs to interact with the steering, accelerator,
    and brakes. The workings of the motor, drive train, and brake subsystem don''t
    matter to the driver. A mechanic, on the other hand, works at a different level
    of abstraction, tuning the engine and bleeding the brakes. Here''s an example
    of two abstraction levels for a car:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象**是与封装和信息隐藏相关的另一个面向对象的术语。抽象意味着处理最适合特定任务的细节级别。这是从内部细节中提取公共接口的过程。汽车的驾驶员需要与转向、油门和刹车进行交互。发动机、传动系统和刹车子系统的工作对驾驶员并不重要。另一方面，技工在不同的抽象级别上工作，调整发动机和排气刹车。这是汽车的两个抽象级别的例子：'
- en: '![](assets/51b17661-6fcb-4cb2-a609-7baec14f881f.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/51b17661-6fcb-4cb2-a609-7baec14f881f.png)'
- en: 'Now, we have several new terms that refer to similar concepts. Let''s summarize
    all this jargon in a couple of sentences: abstraction is the process of encapsulating
    information with separate public and private interfaces. The private interfaces
    can be subject to information hiding.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有几个指涉相似概念的新术语。让我们用几句话总结所有这些行话：抽象是使用单独的公共和私有接口封装信息的过程。私有接口可能会受到信息隐藏的影响。
- en: The important lesson to take from all these definitions is to make our models
    understandable to other objects that have to interact with them. This means paying
    careful attention to small details. Ensure methods and properties have sensible
    names. When analyzing a system, objects typically represent nouns in the original
    problem, while methods are normally verbs. Attributes may show up as adjectives
    or more nouns. Name your classes, attributes, and methods accordingly.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从所有这些定义中得出的重要教训是使我们的模型能够被必须与其交互的其他对象理解。这意味着要特别注意细节。确保方法和属性具有合理的名称。在分析系统时，对象通常代表原始问题中的名词，而方法通常是动词。属性可能显示为形容词或更多名词。相应地为您的类、属性和方法命名。
- en: When designing the interface, imagine you are the object and that you have a
    very strong preference for privacy. Don't let other objects have access to data
    about you unless you feel it is in your best interest for them to have it. Don't
    give them an interface to force you to perform a specific task unless you are
    certain you want them to be able to do that to you.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计接口时，想象自己是对象，并且你非常注重隐私。除非你认为让其他对象访问关于你的数据对你最有利，否则不要让它们访问。除非你确定你希望它们能够这样做，否则不要给它们一个接口来强迫你执行特定的任务。
- en: Composition
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: So far, we have learned to design systems as a group of interacting objects,
    where each interaction involves viewing objects at an appropriate level of abstraction.
    But we don't know yet how to create these levels of abstraction. There are a variety
    of ways to do this; we'll discuss some advanced design patterns in [Chapter 21](b9232138-1747-4f88-b7ac-002c40332e92.xhtml),
    *The Iterator Pattern*. But even most design patterns rely on two basic object-oriented
    principles known as **composition** and **inheritance**. Composition is simpler,
    so let's start with it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了将系统设计为一组相互作用的对象，其中每个交互都涉及以适当的抽象级别查看对象。但我们还不知道如何创建这些抽象级别。有多种方法可以做到这一点；我们将在[第21章](b9232138-1747-4f88-b7ac-002c40332e92.xhtml)中讨论一些高级设计模式，*迭代器模式*。但是，大多数设计模式都依赖于两个基本的面向对象原则，即**组合**和**继承**。组合更简单，所以我们从它开始。
- en: Composition is the act of collecting several objects together to create a new
    one. Composition is usually a good choice when one object is part of another object.
    We've already seen a first hint of composition in the mechanic example. A fossil-fueled
    car is composed of an engine, transmission, starter, headlights, and windshield,
    among numerous other parts. The engine, in turn, is composed of pistons, a crank
    shaft, and valves. In this example, composition is a good way to provide levels
    of abstraction. The **Car** object can provide the interface required by a driver,
    while also giving access to its component parts, which offers the deeper level
    of abstraction suitable for a mechanic. Those component parts can, of course,
    be further broken down if the mechanic needs more information to diagnose a problem
    or tune the engine.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是将几个对象收集在一起创建一个新对象的行为。当一个对象是另一个对象的一部分时，组合通常是一个不错的选择。我们已经在机械示例中看到了组合的第一个迹象。燃油汽车由发动机、变速器、起动机、前灯和挡风玻璃等众多部件组成。发动机又由活塞、曲轴和气门组成。在这个例子中，组合是提供抽象级别的一种好方法。**汽车**对象可以提供驾驶员所需的接口，同时也可以访问其组件部件，这为技师提供了更深层次的抽象，适合于诊断问题或调整发动机时进一步分解这些组件部件。
- en: A car is a common introductory example of composition, but it's not overly useful
    when it comes to designing computer systems. Physical objects are easy to break
    into component objects. People have been doing this at least since the ancient
    Greeks originally postulated that atoms were the smallest units of matter (they,
    of course, didn't have access to particle accelerators). Computer systems are
    generally less complicated than physical objects, yet identifying the component
    objects in such systems does not happen as naturally.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车是一个常见的组合示例，但在设计计算机系统时并不是特别有用。物理对象很容易分解成组件对象。人们至少自古希腊时代以来一直在做这件事，最初假设原子是物质的最小单位（当然，他们当时无法接触到粒子加速器）。计算机系统通常比物理对象更简单，但是在这种系统中识别组件对象并不会自然发生。
- en: The objects in an object-oriented system occasionally represent physical objects
    such as people, books, or telephones. More often, however, they represent abstract
    ideas. People have names, books have titles, and telephones are used to make calls.
    Calls, titles, accounts, names, appointments, and payments are not usually considered
    objects in the physical world, but they are all frequently-modeled components
    in computer systems.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象系统中的对象有时代表诸如人、书籍或电话等物理对象。然而更多时候，它们代表抽象的概念。人有名字，书有标题，电话用于打电话。电话、标题、账户、名字、约会和付款通常不被认为是物理世界中的对象，但它们在计算机系统中经常被建模为组件。
- en: Let's try modeling a more computer-oriented example to see composition in action.
    We'll be looking at the design of a computerized chess game. This was a very popular
    pastime among academics in the 80s and 90s. People were predicting that computers
    would one day be able to defeat a human chess master. When this happened in 1997
    (IBM's Deep Blue defeated world chess champion, Gary Kasparov), interest in the
    problem waned. Nowadays, the computer always wins.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试建模一个更加面向计算机的例子来看看组合是如何发挥作用的。我们将研究一个计算机化的国际象棋游戏的设计。这在80年代和90年代是学者们非常受欢迎的消遣。人们曾经预测计算机有一天会能够击败人类国际象棋大师。当这在1997年发生时（IBM的深蓝击败了世界国际象棋冠军加里·卡斯帕罗夫），人们对这个问题的兴趣减弱了。如今，计算机总是赢。
- en: As a basic, high-level analysis, a *game* of chess is **played** between two
    *players*, using a chess set featuring a *board* containing sixty-four *positions*
    in an 8x8 grid. The board can have two sets of sixteen *pieces* that can be **moved**,
    in alternating *turns* by the two players in different ways. Each piece can **take**
    other pieces. The board will be required to **draw** itself on the computer *screen*
    after each turn.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 作为基本的高层分析，*国际象棋*是由两个*玩家*之间**进行**的，使用一个包含八个8x8网格中的六十四个*位置*的*棋盘*的国际象棋套装。棋盘上可以有两组十六个*棋子*，可以以不同的方式由两个玩家交替*轮流*
    **移动**。每个棋子可以**吃掉**其他棋子。棋盘将需要在每个回合之后在计算机*屏幕*上**绘制**自己。
- en: I've identified some of the possible objects in the description using *italics*,
    and a few key methods using **bold**. This is a common first step in turning an
    object-oriented analysis into a design. At this point, to emphasize composition,
    we'll focus on the board, without worrying too much about the players or the different
    types of pieces.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我用*斜体*标识了描述中一些可能的对象，并使用**粗体**标识了一些关键方法。这是将面向对象分析转化为设计的常见第一步。在这一点上，为了强调组合，我们将专注于棋盘，而不会过多担心玩家或不同类型的棋子。
- en: 'Let''s start at the highest level of abstraction possible. We have two players
    interacting with a **Chess Set** by taking turns making moves:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从可能的最高抽象级别开始。我们有两个玩家通过轮流走棋与**国际象棋棋盘**交互：
- en: '![](assets/60082735-9075-44eb-8ecf-7f21d10076c4.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/60082735-9075-44eb-8ecf-7f21d10076c4.png)'
- en: 'This doesn''t quite look like our earlier class diagrams, which is a good thing
    since it isn''t one! This is an **object diagram**, also called an **instance
    diagram**. It describes the system at a specific state in time, and is describing
    specific instances of objects, not the interaction between classes. Remember,
    both players are members of the same class, so the class diagram looks a little
    different:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不太像我们早期的类图，这是一件好事，因为它不是一个！这是一个**对象图**，也称为**实例图**。它描述了系统在特定时间点的状态，并描述了对象的特定实例，而不是类之间的交互。请记住，两个玩家都是同一个类的成员，所以类图看起来有点不同：
- en: '![](assets/f416111d-e8a4-4574-9f0f-f81a6944ba94.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f416111d-e8a4-4574-9f0f-f81a6944ba94.png)'
- en: The diagram shows that exactly two players can interact with one chess set.
    This also indicates that any one player can be playing with only one **Chess Set**
    at a time.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 该图表明只有两个玩家可以与一个国际象棋棋盘交互。这也表明任何一个玩家一次只能玩一个**国际象棋棋盘**。
- en: However, we're discussing composition, not UML, so let's think about what the
    **Chess Set** is composed of. We don't care what the player is composed of at
    this time. We can assume that the player has a heart and brain, among other organs,
    but these are irrelevant to our model. Indeed, there is nothing stopping said
    player from being Deep Blue itself, which has neither a heart nor a brain.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们正在讨论组合，而不是UML，所以让我们考虑一下**国际象棋棋盘**由什么组成。我们暂时不关心玩家由什么组成。我们可以假设玩家有心脏和大脑等器官，但这些对我们的模型无关紧要。事实上，没有什么能阻止说的玩家本身就是深蓝，它既没有心脏也没有大脑。
- en: The chess set, then, is composed of a board and 32 pieces. The board further
    comprises 64 positions. You could argue that pieces are not part of the chess
    set because you could replace the pieces in a chess set with a different set of
    pieces. While this is unlikely or impossible in a computerized version of chess,
    it introduces us to **aggregation**.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，国际象棋棋盘由棋盘和32个棋子组成。棋盘又包括64个位置。你可以争辩说棋子不是国际象棋棋盘的一部分，因为你可以用不同的棋子替换国际象棋棋盘中的棋子。虽然在计算机版本的国际象棋中这是不太可能或不可能的，但这向我们介绍了**聚合**。
- en: Aggregation is almost exactly like composition. The difference is that aggregate
    objects can exist independently. It would be impossible for a position to be associated
    with a different chess board, so we say the board is composed of positions. But
    the pieces, which might exist independently of the chess set, are said to be in
    an aggregate relationship with that set.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合几乎与组合完全相同。不同之处在于聚合对象可以独立存在。一个位置不可能与不同的国际象棋棋盘相关联，所以我们说棋盘由位置组成。但是，棋子可能独立于国际象棋棋盘存在，因此被称为与该棋盘处于聚合关系。
- en: Another way to differentiate between aggregation and composition is to think
    about the lifespan of the object. If the composite (outside) object controls when
    the related (inside) objects are created and destroyed, composition is most suitable.
    If the related object is created independently of the composite object, or can
    outlast that object, an aggregate relationship makes more sense. Also, keep in
    mind that composition is aggregation; aggregation is simply a more general form
    of composition. Any composite relationship is also an aggregate relationship,
    but not vice versa.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 区分聚合和组合的另一种方法是考虑对象的生命周期。如果组合（外部）对象控制相关（内部）对象的创建和销毁，那么组合是最合适的。如果相关对象独立于组合对象创建，或者可以比组合对象存在更久，那么聚合关系更合理。另外，请记住，组合是聚合；聚合只是组合的一种更一般的形式。任何组合关系也是聚合关系，但反之则不然。
- en: 'Let''s describe our current **Chess Set** composition and add some attributes
    to the objects to hold the composite relationships:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述我们当前的**国际象棋棋盘**组合，并为对象添加一些属性来保存组合关系：
- en: '![](assets/f00831e5-9a36-4517-a19f-e7a933ebfcd0.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f00831e5-9a36-4517-a19f-e7a933ebfcd0.png)'
- en: The composition relationship is represented in UML as a solid diamond. The hollow
    diamond represents the aggregate relationship. You'll notice that the board and
    pieces are stored as part of the **Chess Set** in exactly the same way a reference
    to them is stored as an attribute on the chess set. This shows that, once again,
    in practice, the distinction between aggregation and composition is often irrelevant
    once you get past the design stage. When implemented, they behave in much the
    same way. However, it can help to differentiate between the two when your team
    is discussing how the different objects interact. Often, you can treat them as
    the same thing, but when you need to distinguish between them (usually when talking
    about how long related objects exist), it's great to know the difference.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 组合关系在UML中表示为实心菱形。空心菱形代表聚合关系。你会注意到棋盘和棋子以与将它们的引用存储为**国际象棋棋盘**的一部分，方式完全相同。这表明，一旦再次实践中，聚合和组合之间的区别通常在设计阶段过后就不再重要。在实现时，它们的行为方式大致相同。然而，当你的团队讨论不同对象如何交互时，区分它们可能有所帮助。通常情况下，你可以将它们视为相同的东西，但当你需要区分它们时（通常是在谈论相关对象存在多长时间时），了解区别是很重要的。
- en: Inheritance
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: 'We discussed three types of relationships between objects: association, composition,
    and aggregation. However, we have not fully specified our chess set, and these
    tools don''t seem to give us all the power we need. We discussed the possibility
    that a player might be a human or it might be a piece of software featuring artificial
    intelligence. It doesn''t seem right to say that a player is *associated* with
    a human, or that the artificial intelligence implementation is *part of* the player
    object. What we really need is the ability to say that *Deep Blue is a player,*
    or that *Gary Kasparov is a player*.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了对象之间的三种关系：关联、组合和聚合。然而，我们还没有完全指定我们的国际象棋棋盘，而这些工具似乎并不能给我们提供所有我们需要的功能。我们讨论了玩家可能是人类，也可能是具有人工智能的软件。说玩家与人类*关联*，或者说人工智能实现是玩家对象的一部分，似乎都不太合适。我们真正需要的是能够说*Deep
    Blue是一个玩家*，或者*加里·卡斯帕罗夫是一个玩家*的能力。
- en: The *is a* relationship is formed by **inheritance**. Inheritance is the most
    famous, well-known, and over-used relationship in object-oriented programming.
    Inheritance is sort of like a family tree. My grandfather's last name was Phillips
    and my father inherited that name. I inherited it from him. In object-oriented
    programming, instead of inheriting features and behaviors from a person, one class
    can inherit attributes and methods from another class.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*is a*关系是由**继承**形成的。继承是面向对象编程中最著名、最知名和最常用的关系。继承有点像家谱。我的祖父姓菲利普斯，我父亲继承了这个姓氏。我从他那里继承了它。在面向对象编程中，一个类可以从另一个类继承属性和方法，而不是从一个人那里继承特征和行为。'
- en: 'For example, there are 32 chess pieces in our chess set, but there are only
    six different types of pieces (pawns, rooks, bishops, knights, king, and queen),
    each of which behaves differently when it is moved. All of these classes of piece
    have properties, such as color and the chess set they are part of, but they also
    have unique shapes when drawn on the chess board, and make different moves. Let''s
    see how the six types of pieces can inherit from a **Piece** class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的国际象棋棋盘上有32个棋子，但只有六种不同类型的棋子（兵、车、象、马、国王和皇后），每种棋子在移动时的行为都不同。所有这些棋子类都有属性，比如颜色和它们所属的国际象棋棋盘，但它们在国际象棋棋盘上绘制时也有独特的形状，并且移动方式不同。让我们看看这六种类型的棋子如何从**Piece**类继承：
- en: '![](assets/d56b9ae4-694c-46d0-9c85-78660120acf2.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d56b9ae4-694c-46d0-9c85-78660120acf2.png)'
- en: The hollow arrows indicate that the individual classes of pieces inherit from
    the **Piece** class. All the child classes automatically have a **chess_set**
    and **color** attribute inherited from the base class. Each piece provides a different
    shape property (to be drawn on the screen when rendering the board), and a different
    **move** method to move the piece to a new position on the board at each turn.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 空心箭头表示各个棋子类从**Piece**类继承。所有子类都自动从基类继承**chess_set**和**color**属性。每个棋子提供一个不同的形状属性（在渲染棋盘时绘制在屏幕上），以及一个不同的**move**方法，以在每一轮中将棋子移动到棋盘上的新位置。
- en: We actually know that all subclasses of the **Piece** class need to have a **move**
    method; otherwise, when the board tries to move the piece, it will get confused.
    It is possible that we would want to create a new version of the game of chess
    that has one additional piece (the wizard). Our current design will allow us to
    design this piece without giving it a **move** method. The board would then choke
    when it asked the piece to move itself.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上知道**Piece**类的所有子类都需要有一个**move**方法；否则，当棋盘试图移动棋子时，它会感到困惑。我们可能希望创建国际象棋的一个新版本，其中有一个额外的棋子（巫师）。我们当前的设计将允许我们设计这个棋子，而不给它一个**move**方法。然后当棋盘要求棋子移动时，它会出错。
- en: We can fix this by creating a dummy move method on the **Piece** class. The
    subclasses can then **override** this method with a more specific implementation.
    The default implementation might, for example, pop up an error message that says **That
    piece cannot be moved**.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在**Piece**类上创建一个虚拟的移动方法来解决这个问题。然后子类可以用更具体的实现**覆盖**这个方法。默认实现可能会弹出一个错误消息，说**该棋子无法移动**。
- en: Overriding methods in subclasses allows very powerful object-oriented systems
    to be developed. For example, if we wanted to implement a **Player** class with
    artificial intelligence, we might provide a `calculate_move` method that takes
    a **Board** object and decides which piece to move where. A very basic class might
    randomly choose a piece and direction and move it accordingly. We could then override
    this method in a subclass with the Deep Blue implementation. The first class would
    be suitable for play against a raw beginner; the latter would challenge a grand
    master. The important thing is that other methods in the class, such as the ones
    that inform the board as to which move was chosen, need not be changed; this implementation
    can be shared between the two classes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在子类中重写方法可以开发非常强大的面向对象系统。例如，如果我们想要实现一个具有人工智能的**Player**类，我们可以提供一个`calculate_move`方法，该方法接受一个**Board**对象，并决定将哪个棋子移动到哪里。一个非常基本的类可能会随机选择一个棋子和方向，然后相应地移动它。然后我们可以在子类中重写这个方法，使用Deep
    Blue的实现。第一个类适合与一个新手玩；后者将挑战一个国际象棋大师。重要的是，类中的其他方法，比如通知棋盘选择了哪个移动的方法，不需要改变；这个实现可以在两个类之间共享。
- en: 'In the case of chess pieces, it doesn''t really make sense to provide a default
    implementation of the move method. All we need to do is specify that the move
    method is required in any subclasses. This can be done by making **Piece** an
    **abstract class** with the move method declared **abstract**. Abstract methods
    basically say this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在国际象棋棋子的情况下，提供移动方法的默认实现并没有太多意义。我们只需要指定移动方法在任何子类中都是必需的。这可以通过使**Piece**成为一个**抽象类**，并声明**abstract**的移动方法来实现。抽象方法基本上是这样说的：
- en: We demand this method exist in any non-abstract subclass, but we are declining
    to specify an implementation in this class.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求这种方法存在于任何非抽象子类中，但我们拒绝在这个类中指定实现。
- en: Indeed, it is possible to make a class that does not implement any methods at
    all. Such a class would simply tell us what the class should do, but provides
    absolutely no advice on how to do it. In object-oriented parlance, such classes
    are called **interfaces**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，可能会创建一个根本不实现任何方法的类。这样的类只会告诉我们类应该做什么，但绝对不会提供如何做的建议。在面向对象的术语中，这样的类被称为**接口**。
- en: Inheritance provides abstraction
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承提供了抽象
- en: Let's explore the longest word in object-oriented argot. **Polymorphism** is
    the ability to treat a class differently, depending on which subclass is implemented.
    We've already seen it in action with the pieces system we've described. If we
    took the design a bit further, we'd probably see that the **Board** object can
    accept a move from the player and call the **move** function on the piece. The
    board need not ever know what type of piece it is dealing with. All it has to
    do is call the **move** method, and the proper subclass will take care of moving
    it as a **Knight** or a **Pawn**.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探讨面向对象术语中最长的单词。**多态性**是指根据实现了哪个子类来对待一个类的能力。我们已经在我们描述的棋子系统中看到了它的作用。如果我们进一步设计，我们可能会发现**Board**对象可以接受玩家的移动并调用棋子的**move**函数。棋盘不需要知道它正在处理什么类型的棋子。它只需要调用**move**方法，适当的子类将负责将其移动为**Knight**或**Pawn**。
- en: Polymorphism is pretty cool, but it is a word that is rarely used in Python
    programming. Python goes an extra step past allowing a subclass of an object to
    be treated like a parent class. A board implemented in Python could take any object
    that has a **move** method, whether it is a bishop piece, a car, or a duck. When
    **move** is called, the **Bishop** will move diagonally on the board, the car
    will drive someplace, and the duck will swim or fly, depending on its mood.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性很酷，但在Python编程中很少使用这个词。Python在允许将对象的子类视为父类的基础上又迈出了一步。在Python中实现的棋盘可以接受任何具有**move**方法的对象，无论是主教棋子、汽车还是鸭子。当调用**move**时，**Bishop**将在棋盘上对角线移动，汽车将驾驶到某个地方，而鸭子将根据心情游泳或飞行。
- en: 'This sort of polymorphism in Python is typically referred to as **duck typing**:
    *if it walks like a duck or swims like a duck, it''s a duck*. We don''t care if
    it really *is a* duck (*is a* being a cornerstone of inheritance), only that it
    swims or walks. Geese and swans might easily be able to provide the duck-like
    behavior we are looking for. This allows future designers to create new types
    of birds without actually specifying an inheritance hierarchy for aquatic birds.
    It also allows them to create completely different drop-in behaviors that the
    original designers never planned for. For example, future designers might be able
    to make a walking, swimming penguin that works with the same interface without
    ever suggesting that penguins are ducks.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，这种多态性通常被称为**鸭子类型**：*如果它走起来像鸭子或游泳像鸭子，那它就是鸭子*。我们不在乎它是否真的是一只鸭子（*是一个*是继承的基石），只在乎它是游泳还是走路。雁和天鹅可能很容易提供我们所寻找的鸭子般的行为。这使得未来的设计者可以创建新类型的鸟类，而无需实际指定水鸟的继承层次结构。它还允许他们创建完全不同的插入行为，原始设计者从未计划过。例如，未来的设计者可能能够创建一个行走、游泳的企鹅，它可以使用相同的接口，而从未暗示企鹅是鸭子。
- en: Multiple inheritance
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重继承
- en: When we think of inheritance in our own family tree, we can see that we inherit
    features from more than just one parent. When strangers tell a proud mother that
    her son has *his father's eyes*, she will typically respond along the lines of,
    *yes, but he got my nose*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想到我们自己家族谱中的继承时，我们会发现我们不仅从一个父类那里继承特征。当陌生人告诉一个骄傲的母亲她的儿子有*他父亲的眼睛*时，她通常会回答类似于，*是的，但他有我的鼻子*。
- en: Object-oriented design can also feature such **multiple inheritance**, which
    allows a subclass to inherit functionality from multiple parent classes. In practice,
    multiple inheritance can be a tricky business, and some programming languages
    (most famously, Java) strictly prohibit it. However, multiple inheritance can
    have its uses. Most often, it can be used to create objects that have two distinct
    sets of behaviors. For example, an object designed to connect to a scanner and
    send a fax of the scanned document might be created by inheriting from two separate
    `scanner` and `faxer` objects.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象设计也可以包括这种**多重继承**，它允许子类从多个父类中继承功能。在实践中，多重继承可能会很棘手，一些编程语言（最著名的是Java）严格禁止它。然而，多重继承也有其用途。最常见的用途是创建具有两组不同行为的对象。例如，一个设计用于连接扫描仪并发送扫描文档的传真的对象可能是通过从两个独立的`scanner`和`faxer`对象继承而创建的。
- en: As long as two classes have distinct interfaces, it is not normally harmful
    for a subclass to inherit from both of them. However, it gets messy if we inherit
    from two classes that provide overlapping interfaces. For example, if we have
    a motorcycle class that has a `move` method, and a boat class also featuring a
    `move` method, and we want to merge them into the ultimate amphibious vehicle,
    how does the resulting class know what to do when we call `move`? At the design
    level, this needs to be explained, and, at the implementation level, each programming
    language has different ways of deciding which parent class's method is called,
    or in what order.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 只要两个类具有不同的接口，子类从它们两者继承通常不会有害。但是，如果我们从提供重叠接口的两个类继承，情况就会变得混乱。例如，如果我们有一个具有`move`方法的摩托车类，还有一个同样具有`move`方法的船类，我们想将它们合并成终极两栖车时，当我们调用`move`时，结果类如何知道该做什么？在设计层面上，这需要解释，在实现层面上，每种编程语言都有不同的方式来决定调用哪个父类的方法，或以什么顺序调用。
- en: Often, the best way to deal with it is to avoid it. If you have a design showing
    up like this, you're *probably* doing it wrong. Take a step back, analyze the
    system again, and see if you can remove the multiple inheritance relationship
    in favor of some other association or composite design.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，处理它的最佳方式是避免它。如果你的设计出现这样的情况，你很可能做错了。退一步，重新分析系统，看看是否可以取消多重继承关系，转而使用其他关联或组合设计。
- en: Inheritance is a very powerful tool for extending behavior. It is also one of
    the most marketable advancements of object-oriented design over earlier paradigms.
    Therefore, it is often the first tool that object-oriented programmers reach for.
    However, it is important to recognize that owning a hammer does not turn screws
    into nails. Inheritance is the perfect solution for obvious *is a* relationships,
    but it can be abused. Programmers often use inheritance to share code between
    two kinds of objects that are only distantly related, with no *is a* relationship
    in sight. While this is not necessarily a bad design, it is a terrific opportunity
    to ask just why they decided to design it that way, and whether a different relationship
    or design pattern would have been more suitable.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是扩展行为的一个非常强大的工具。它也是面向对象设计相对于早期范例的最具市场潜力的进步之一。因此，它通常是面向对象程序员首先使用的工具。然而，重要的是要认识到拥有一把锤子并不会把螺丝钉变成钉子。继承是明显的“是一个”关系的完美解决方案，但它可能会被滥用。程序员经常使用继承来在两种只有遥远关联的对象之间共享代码，而看不到“是一个”关系。虽然这不一定是一个坏设计，但这是一个很好的机会去问他们为什么决定以这种方式设计，以及是否不同的关系或设计模式更合适。
- en: Case study
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: Let's tie all our new object-oriented knowledge together by going through a
    few iterations of object-oriented design on a somewhat real-world example. The
    system we'll be modeling is a library catalog. Libraries have been tracking their
    inventory for centuries, originally using card catalogs, and more recently, electronic
    inventories. Modern libraries have web-based catalogs that we can query from our
    homes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过对一个现实世界的例子进行几次迭代的面向对象设计，将我们所有新的面向对象的知识联系在一起。我们将要建模的系统是一个图书馆目录。图书馆几个世纪以来一直在跟踪他们的库存，最初使用卡片目录，最近使用电子库存。现代图书馆有基于网络的目录，我们可以在家里查询。
- en: Let's start with an analysis. The local librarian has asked us to write a new
    card catalog program because their ancient Windows XP-based program is ugly and
    out of date. That doesn't give us much detail, but before we start asking for
    more information, let's consider what we already know about library catalogs.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从分析开始。当地的图书管理员要求我们编写一个新的卡片目录程序，因为他们古老的基于Windows XP的程序既难看又过时。这并没有给我们太多细节，但在我们开始寻求更多信息之前，让我们考虑一下我们已经对图书馆目录了解的情况。
- en: Catalogs contain lists of books. People search them to find books on certain
    subjects, with specific titles, or by a particular author. Books can be uniquely
    identified by an **International Standard Book Number** (**ISBN**). Each book
    has a **Dewey Decimal System** (**DDS**) number assigned to help find it on a
    particular shelf.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 目录包含书籍列表。人们搜索它们以找到特定主题的书籍，特定标题的书籍，或者特定作者的书籍。书籍可以通过国际标准书号（ISBN）来唯一标识。每本书都有一个杜威十进制分类法（DDS）号码，用于帮助在特定书架上找到它。
- en: This simple analysis tells us some of the obvious objects in the system. We
    quickly identify **Book** as the most important object, with several attributes
    already mentioned, such as author, title, subject, ISBN, and DDS number, and catalog
    as a sort of manager for books.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的分析告诉我们系统中一些明显的对象。我们很快确定**Book**是最重要的对象，其中已经提到了几个属性，比如作者、标题、主题、ISBN和DDS号码，以及作为书籍管理者的编目。
- en: We also notice a few other objects that may or may not need to be modeled in
    the system. For cataloging purposes, all we need to search a book by author is
    an `author_name` attribute on the book. However, authors are also objects, and
    we might want to store some other data about the author. As we ponder this, we
    might remember that some books have multiple authors. Suddenly, the idea of having
    a single `author_name` attribute on objects seems a bit silly. A list of authors
    associated with each book is clearly a better idea.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注意到一些其他可能需要或不需要在系统中建模的对象。为了编目的目的，我们只需要在书上搜索作者的`author_name`属性。然而，作者也是对象，我们可能想要存储一些关于作者的其他数据。当我们思考这一点时，我们可能会记起一些书籍有多个作者的情况。突然间，在对象上有一个单一的`author_name`属性的想法似乎有点愚蠢。与每本书相关联的作者列表显然是一个更好的想法。
- en: The relationship between author and book is clearly association, since you would
    never say *a book is an author* (it's not inheritance), and saying *a book has
    an author*, though grammatically correct, does not imply that authors are part
    of books (it's not aggregation). Indeed, any one author may be associated with
    multiple books.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 作者和书籍之间的关系显然是关联，因为你永远不会说“一本书是一个作者”（这不是继承），而说“一本书有一个作者”，虽然在语法上是正确的，但并不意味着作者是书籍的一部分（这不是聚合）。事实上，任何一个作者可能与多本书相关联。
- en: We should also pay attention to the noun (nouns are always good candidates for
    objects) *shelf*. Is a shelf an object that needs to be modeled in a cataloging
    system? How do we identify an individual shelf? What happens if a book is stored
    at the end of one shelf, and later moved to the beginning of the next shelf because
    a new book was inserted in the previous shelf?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该注意名词（名词总是对象的好候选者）*shelf*。书架是需要在编目系统中建模的对象吗？我们如何识别单独的书架？如果一本书存放在一个书架的末尾，后来因为前一个书架插入了一本新书而移到了下一个书架的开头，会发生什么？
- en: DDS was designed to help locate physical books in a library. As such, storing
    a DDS attribute with the book should be enough to locate it, regardless of which
    shelf it is stored on. So we can, at least for the moment, remove shelf from our
    list of contending objects.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: DDS旨在帮助在图书馆中找到实体书籍。因此，将DDS属性与书籍一起存储应该足以找到它，无论它存放在哪个书架上。因此，我们可以暂时将书架从我们竞争对象的列表中移除。
- en: Another questionable object in the system is the user. Do we need to know anything
    about a specific user, such as their name, address, or list of overdue books?
    So far, the librarian has told us only that they want a catalog; they said nothing
    about tracking subscriptions or overdue notices. In the back of our minds, we
    also note that authors and users are both specific kinds of people; there might
    be a useful inheritance relationship here in the future.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中的另一个有问题的对象是用户。我们需要了解特定用户的任何信息吗，比如他们的姓名、地址或逾期书目清单？到目前为止，图书管理员只告诉我们他们想要一个目录；他们没有提到跟踪订阅或逾期通知。在我们的脑海中，我们还注意到作者和用户都是特定类型的人；在未来可能会有一个有用的继承关系。
- en: For cataloging purposes, we decide we don't need to identify the user for now.
    We can assume that a user will be searching the catalog, but we don't have to
    actively model them in the system, beyond providing an interface that allows them
    to search.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编目的目的，我们决定暂时不需要识别用户。我们可以假设用户将搜索目录，但我们不必在系统中积极对他们进行建模，只需提供一个允许他们搜索的界面即可。
- en: We have identified a few attributes on the book, but what properties does a
    catalog have? Does any one library have more than one catalog? Do we need to uniquely
    identify them? Obviously, the catalog has to have a collection of the books it
    contains, somehow, but this list is probably not part of the public interface.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了书上的一些属性，但目录有什么属性？任何一个图书馆有多个目录吗？我们需要对它们进行唯一标识吗？显然，目录必须有它包含的书的集合，但这个列表可能不是公共接口的一部分。
- en: What about behaviors? The catalog clearly needs a search method, possibly separate
    ones for authors, titles, and subjects. Are there any behaviors on books? Would
    it need a preview method? Or could preview be identified by a first page attribute
    instead of a method?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 行为呢？目录显然需要一个搜索方法，可能是作者、标题和主题的分开搜索。书上有什么行为？它需要一个预览方法吗？或者预览可以通过第一页属性而不是方法来识别吗？
- en: The questions in the preceding discussion are all part of the object-oriented
    analysis phase. But intermixed with the questions, we have already identified
    a few key objects that are part of the design. Indeed, what you have just seen
    are several microiterations between analysis and design.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 前面讨论中的问题都是面向对象分析阶段的一部分。但在这些问题中，我们已经确定了一些设计中的关键对象。事实上，你刚刚看到的是分析和设计之间的几个微迭代。
- en: 'Likely, these iterations would all occur in an initial meeting with the librarian.
    Before this meeting, however, we can already sketch out a most basic design for
    the objects we have concretely identified, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，这些迭代都会在与图书管理员的初次会议中发生。然而，在这次会议之前，我们已经可以为我们已经明确定义的对象勾勒出一个最基本的设计，如下所示：
- en: '![](assets/964c512f-bac7-45a6-a7c1-6a56cc66cb4f.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/964c512f-bac7-45a6-a7c1-6a56cc66cb4f.png)'
- en: Armed with this basic diagram and a pencil to interactively improve it, we meet
    up with the librarian. They tell us that this is a good start, but libraries don't
    serve only books; they also have DVDs, magazines, and CDs, none of which have
    an ISBN or DDS number. All of these types of items can be uniquely identified
    by a UPC number, though. We remind the librarian that they have to find the items
    on the shelf, and these items probably aren't organized by UPC.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 拿着这个基本的图表和一支铅笔，我们与图书管理员会面。他们告诉我们这是一个很好的开始，但图书馆不仅仅提供书籍；他们还有DVD、杂志和CD，这些都没有ISBN或DDS号码。所有这些类型的物品都可以通过UPC号码唯一识别。我们提醒图书管理员，他们必须在书架上找到物品，而且这些物品可能不是按UPC号码组织的。
- en: The librarian explains that each type is organized in a different way. The CDs
    are mostly audio books, and they only have two dozen in stock, so they are organized
    by the author's last name. DVDs are divided into genre and further organized by
    title. Magazines are organized by title and then refined by the volume and issue
    number. Books are, as we had guessed, organized by the DDS number.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图书管理员解释说每种类型都是以不同的方式组织的。CD主要是有声书，他们只有两打库存，所以它们是按作者的姓氏组织的。DVD根据类型划分，然后按标题进一步组织。杂志按标题组织，然后按卷和期号进一步细分。书籍，正如我们猜测的那样，是按DDS号码组织的。
- en: 'With no previous object-oriented design experience, we might consider adding
    separate lists of DVDs, CDs, magazines, and books to our catalog, and search each
    one in turn. The trouble is, except for certain extended attributes, and identifying
    the physical location of the item, these items all behave much the same. This
    is a job for inheritance! We quickly update our UML diagram as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 没有以前的面向对象设计经验，我们可能会考虑将DVD、CD、杂志和书籍分别添加到我们的目录中，并依次搜索每一个。问题是，除了某些扩展属性和识别物品的物理位置之外，这些物品的行为都大致相同。这就是继承的工作！我们迅速更新我们的UML图表如下：
- en: '![](assets/3dfb6fee-d3c0-4544-a0f5-ef49c0c640a3.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3dfb6fee-d3c0-4544-a0f5-ef49c0c640a3.png)'
- en: The librarian understands the gist of our sketched diagram, but is a bit confused
    by the **locate** functionality. We explain using a specific use case where the
    user is searching for the word *bunnies*. The user first sends a search request
    to the catalog. The catalog queries its internal list of items and finds a book
    and a DVD with *bunnies* in the title. At this point, the catalog doesn't care
    whether it is holding a DVD, book, CD, or magazine; all items are the same, as
    far as the catalog is concerned. However, the user wants to know how to find the
    physical items, so the catalog would be remiss if it simply returned a list of
    titles. So, it calls the **locate** method on the two items it has uncovered.
    The book's **locate** method returns a DDS number that can be used to find the
    shelf holding the book. The DVD is located by returning the genre and title of
    the DVD. The user can then visit the DVD section, find the section containing
    that genre, and find the specific DVD as sorted by the titles.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图书管理员理解了我们勾画的图表的要点，但对**locate**功能有点困惑。我们使用了一个特定的用例来解释，用户正在搜索单词*bunnies*。用户首先向目录发送搜索请求。目录查询其内部项目列表，找到了一个标题中带有*bunnies*的书和一个DVD。此时，目录并不关心它是否持有DVD、书、CD还是杂志；在目录看来，所有项目都是一样的。然而，用户想知道如何找到这些实体项目，因此如果目录只返回一个标题列表，那就不够完善了。因此，它调用了两个发现的项目的**locate**方法。书的**locate**方法返回一个DDS号码，可以用来找到放置书的书架。DVD通过返回DVD的流派和标题来定位。然后用户可以访问DVD部分，找到包含该流派的部分，并按标题排序找到特定的DVD。
- en: 'As we explain, we sketch a UML **sequence diagram**, explaining how the various
    objects are communicating:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们解释时，我们勾画了一个UML**序列图**，解释了各种对象是如何进行通信的：
- en: '![](assets/bc89e098-32c1-4eec-b7eb-71e843166f17.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bc89e098-32c1-4eec-b7eb-71e843166f17.png)'
- en: While class diagrams describe the relationships between classes, sequence diagrams
    describe specific sequences of messages passed between objects. The dashed line
    hanging from each object is a **lifeline** describing the lifetime of the object.
    The wider boxes on each lifeline represent active processing in that object (where
    there's no box, the object is basically sitting idle, waiting for something to
    happen). The horizontal arrows between the lifelines indicate specific messages.
    The solid arrows represent methods being called, while the dashed arrows with
    solid heads represent the method return values.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然类图描述了类之间的关系，序列图描述了对象之间传递的特定消息序列。从每个对象悬挂的虚线是描述对象的生命周期的**生命线**。每个生命线上的较宽的框表示对象中的活动处理（没有框的地方，对象基本上是空闲的，等待发生某些事情）。生命线之间的水平箭头表示特定的消息。实线箭头表示被调用的方法，而带有实心头的虚线箭头表示方法返回值。
- en: The half arrowheads indicate asynchronous messages sent to or from an object.
    An asynchronous message typically means the first object calls a method on the
    second object, which returns immediately. After some processing, the second object
    calls a method on the first object to give it a value. This is in contrast to
    normal method calls, which do the processing in the method, and return a value
    immediately.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 半箭头表示发送到对象或从对象发送的异步消息。异步消息通常意味着第一个对象调用第二个对象的方法，该方法立即返回。经过一些处理后，第二个对象调用第一个对象的方法来给它一个值。这与正常的方法调用相反，正常的方法调用在方法中进行处理，并立即返回一个值。
- en: Sequence diagrams, like all UML diagrams, are best used only when they are needed.
    There is no point in drawing a UML diagram for the sake of drawing a diagram.
    However, when you need to communicate a series of interactions between two objects,
    the sequence diagram is a very useful tool.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有UML图表一样，序列图只有在需要时才能最好使用。为了画图而画图是没有意义的。但是，当您需要传达两个对象之间的一系列交互时，序列图是一个非常有用的工具。
- en: Unfortunately, our class diagram so far is still a messy design. We notice that
    actors on DVDs and artists on CDs are all types of people, but are being treated
    differently from the book authors. The librarian also reminds us that most of
    their CDs are audio books, which have authors instead of artists.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，到目前为止，我们的类图仍然是一种混乱的设计。我们注意到DVD上的演员和CD上的艺术家都是人的类型，但与书籍作者的处理方式不同。图书管理员还提醒我们，他们的大部分CD都是有声书，有作者而不是艺术家。
- en: 'How can we deal with different kinds of people that contribute to a title?
    One obvious implementation is to create a `Person` class with the person''s name
    and other relevant details, and then create subclasses of this for the artists,
    authors, and actors. However, is inheritance really necessary here? For searching
    and cataloging purposes, we don''t really care that acting and writing are two
    very different activities. If we were doing an economic simulation, it would make
    sense to give separate actor and author classes, and different `calculate_income`
    and `perform_job` methods, but for cataloging purposes, it is enough to know how
    the person contributed to the item. Having thought this through, we recognize
    that all items have one or more `Contributor` objects, so we move the author relationship
    from the book to its parent class:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理为标题做出贡献的不同类型的人？一个明显的实现是创建一个`Person`类，包括人的姓名和其他相关细节，然后为艺术家、作者和演员创建这个类的子类。然而，在这里真的需要继承吗？对于搜索和编目的目的，我们并不真的关心表演和写作是两种非常不同的活动。如果我们正在进行经济模拟，给予单独的演员和作者类，并不同的`calculate_income`和`perform_job`方法是有意义的，但对于编目的目的，知道这个人如何为项目做出贡献就足够了。经过深思熟虑，我们意识到所有项目都有一个或多个`Contributor`对象，因此我们将作者关系从书籍移动到其父类中：
- en: '![](assets/751fbffc-7e61-4f18-b3bd-93499b01b9f7.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/751fbffc-7e61-4f18-b3bd-93499b01b9f7.png)'
- en: The multiplicity of the **Contributor**/**LibraryItem** relationship is **many-to-many**,
    as indicated by the ***** character at both ends of one relationship. Any one
    library item might have more than one contributor (for example, several actors
    and a director on a DVD). And many authors write many books, so they be attached
    to multiple library items.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**Contributor**/**LibraryItem**关系的多重性是**多对多**，如一个关系两端的*****字符所示。任何一个图书馆项目可能有多个贡献者（例如，DVD上的几位演员和一位导演）。许多作者写了很多书，所以他们可以附属于多个图书馆项目。'
- en: This little change, while it looks a bit cleaner and simpler, has lost some
    vital information. We can still tell who contributed to a specific library item,
    but we don't know how they contributed. Were they the director or an actor? Did
    they write the audio book, or were they the voice that narrated the book?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小改变，虽然看起来更清洁、更简单，但丢失了一些重要的信息。我们仍然可以知道谁为特定的图书馆项目做出了贡献，但我们不知道他们是如何贡献的。他们是导演还是演员？他们是写了有声书，还是为书朗读的声音？
- en: It would be nice if we could just add a `contributor_type` attribute on the
    **Contributor** class, but this will fall apart when dealing with multi-talented
    people who have both authored books and directed movies.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以在**Contributor**类上添加一个`contributor_type`属性就好了，但是当处理多才多艺的人既写书又导演电影时，这种方法就会失效。
- en: 'One option is to add attributes to each of our **LibraryItem** subclasses to
    hold the information we need, such as **Author** on **Book**, or **Artist** on
    **CD**, and then make the relationship to those properties all point to the **Contributor**
    class. The problem with this is that we lose a lot of polymorphic elegance. If
    we want to list the contributors to an item, we have to look for specific attributes
    on that item, such as **Authors** or **Actors**. We can solve this by adding a
    **GetContributors** method on the **LibraryItem** class that subclasses can override.
    Then the catalog never has to know what attributes the objects are querying; we''ve
    abstracted the public interface:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选择是向我们的**LibraryItem**子类中添加属性来保存我们需要的信息，比如**Book**上的**Author**，或者**CD**上的**Artist**，然后将这些属性的关系都指向**Contributor**类。问题在于，我们失去了很多多态的优雅。如果我们想列出项目的贡献者，我们必须寻找该项目上的特定属性，比如**Authors**或**Actors**。我们可以通过在**LibraryItem**类上添加一个**GetContributors**方法来解决这个问题，子类可以重写这个方法。然后目录永远不必知道对象正在查询的属性；我们已经抽象了公共接口：
- en: '![](assets/631103fb-f946-41b1-9cbe-cc083f1c3a94.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/631103fb-f946-41b1-9cbe-cc083f1c3a94.png)'
- en: Just looking at this class diagram, it feels like we are doing something wrong.
    It is bulky and fragile. It may do everything we need, but it feels like it will
    be hard to maintain or extend. There are too many relationships, and too many
    classes would be affected by modifications to any one class. It looks like spaghetti
    and meatballs.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅看这个类图，就感觉我们在做错事。它又臃肿又脆弱。它可能做了我们需要的一切，但感觉很难维护或扩展。关系太多，任何一个类的修改都会影响太多的类。看起来就像意大利面和肉丸。
- en: Now that we've explored inheritance as an option, and found it wanting, we might
    look back at our previous composition-based diagram, where **Contributor** was
    attached directly to **LibraryItem**. With some thought, we can see that we actually
    only need to add one more relationship to a brand-new class to identify the type
    of contributor. This is an important step in object-oriented design. We are now
    adding a class to the design that is intended to *support* the other objects,
    rather than modeling any part of the initial requirements. We are **refactoring**
    the design to facilitate the objects in the system, rather than objects in real
    life. Refactoring is an essential process in the maintenance of a program or design.
    The goal of refactoring is to improve the design by moving code around, removing
    duplicate code or complex relationships in favor of simpler, more elegant designs.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了继承作为一个选项，并发现它不够理想，我们可能会回顾我们之前基于组合的图表，其中**Contributor**直接附属于**LibraryItem**。经过一些思考，我们可以看到，实际上我们只需要再添加一个关系到一个全新的类，来标识贡献者的类型。这是面向对象设计中的一个重要步骤。我们现在正在向设计中添加一个旨在*支持*其他对象的类，而不是对初始需求的任何部分进行建模。我们正在**重构**设计，以便系统中的对象，而不是现实生活中的对象。重构是程序或设计维护中的一个重要过程。重构的目标是通过移动代码、删除重复代码或复杂关系，来改进设计，以获得更简单、更优雅的设计。
- en: 'This new class is composed of a **Contributor** and an extra attribute identifying
    the type of contribution the person has made to the given **LibraryItem**. There
    can be many such contributions to a particular **LibraryItem**, and one contributor
    can contribute in the same way to different items. The following diagram communicates
    this design very well:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新类由一个**贡献者**和一个额外的属性组成，用于标识该人对给定**LibraryItem**所做贡献的类型。对于特定的**LibraryItem**可以有许多这样的贡献，一个贡献者可以以相同的方式为不同的项目做出贡献。以下的图表很好地传达了这个设计：
- en: '![](assets/6725f017-9a4c-4dac-8303-216704725fb3.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6725f017-9a4c-4dac-8303-216704725fb3.png)'
- en: 'At first, this composition relationship looks less natural than the inheritance-based
    relationships. However, it has the advantage of allowing us to add new types of
    contributions without adding a new class to the design. Inheritance is most useful
    when the subclasses have some kind of **specialization**. Specialization is creating
    or changing attributes or behaviors on the subclass to make it somehow different
    from the parent class. It seems silly to create a bunch of empty classes solely
    for identifying different types of objects (this attitude is less prevalent among
    Java and other *everything is an object* programmers, but it is common among more
    pragmatic Python designers). If we look at the inheritance version of the diagram,
    we can see a bunch of subclasses that don''t actually do anything:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这种组合关系看起来不如基于继承的关系自然。然而，它的优势在于允许我们添加新类型的贡献，而不必在设计中添加一个新类。当子类有某种**专业化**时，继承是最有用的。专业化是在子类上创建或更改属性或行为，使其在某种程度上与父类不同。创建一堆空类仅用于识别不同类型的对象似乎有些愚蠢（这种态度在Java和其他*一切都是对象*的程序员中不太普遍，但在更务实的Python设计师中很常见）。如果我们看继承版本的图表，我们会看到一堆实际上什么都不做的子类：
- en: '![](assets/f66e8e17-cf8e-46c8-a693-6eadd1a7a1f3.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f66e8e17-cf8e-46c8-a693-6eadd1a7a1f3.png)'
- en: Sometimes, it is important to recognize when not to use object-oriented principles.
    This example of when not to use inheritance is a good reminder that objects are
    just tools, and not rules.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，重要的是要认识到何时不使用面向对象的原则。这个不使用继承的例子很好地提醒我们，对象只是工具，而不是规则。
- en: Exercises
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: This is a practical book, not a textbook. As such, I'm not assigning a bunch
    of fake object-oriented analysis problems to create designs for you to analyze
    and design. Instead, I want to give you some ideas that you can apply to your
    own projects. If you have previous object-oriented experience, you won't need
    to put much effort into this chapter. However, they are useful mental exercises
    if you've been using Python for a while, but have never really cared about all
    that class stuff.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一本实用书，不是教科书。因此，我不会为你创建一堆虚假的面向对象分析问题，让你分析和设计。相反，我想给你一些可以应用到自己项目中的想法。如果你有以前的面向对象经验，你就不需要在这一章节上花太多精力。然而，如果你已经使用Python一段时间，但从来没有真正关心过所有的类的东西，这些都是有用的心理锻炼。
- en: 'First, think about a recent programming project you''ve completed. Identify
    the most prominent object in the design. Try to think of as many attributes for
    this object as possible. Did it have the following: Color? Weight? Size? Profit?
    Cost? Name? ID number? Price? Style?'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，想想你最近完成的一个编程项目。确定设计中最突出的对象。尽量想出这个对象的尽可能多的属性。它有以下属性吗：颜色？重量？大小？利润？成本？名称？ID号码？价格？风格？
- en: Think about the attribute types. Were they primitives or classes? Were some
    of those attributes actually behaviors in disguise? Sometimes, what looks like
    data is actually calculated from other data on the object, and you can use a method
    to do those calculations. What other methods or behaviors did the object have?
    Which objects called those methods? What kinds of relationships did they have
    with this object?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 思考属性类型。它们是基本类型还是类？其中一些属性实际上是伪装成行为？有时，看起来像数据的东西实际上是从对象的其他数据计算出来的，你可以使用一个方法来进行这些计算。这个对象还有哪些其他方法或行为？哪些对象调用了这些方法？它们与这个对象有什么样的关系？
- en: Now, think about an upcoming project. It doesn't matter what the project is;
    it might be a fun free-time project or a multi-million-dollar contract. It doesn't
    have to be a complete application; it could just be one subsystem. Perform a basic
    object-oriented analysis. Identify the requirements and the interacting objects.
    Sketch out a class diagram featuring the highest level of abstraction on that
    system. Identify the major interacting objects. Identify minor supporting objects.
    Go into detail for the attributes and methods of some of the most interesting
    ones. Take different objects to different levels of abstraction. Look for places
    where you can use inheritance or composition. Look for places where you should
    avoid inheritance.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想想即将开始的项目。项目是什么并不重要；它可能是一个有趣的业余项目，也可能是一个价值数百万美元的合同。它不必是一个完整的应用程序；它可能只是一个子系统。进行基本的面向对象分析。确定需求和相互作用的对象。勾画出一个包含该系统最高抽象级别的类图。确定主要相互作用的对象。确定次要支持对象。详细了解一些最有趣的对象的属性和方法。将不同的对象带入不同的抽象级别。寻找可以使用继承或组合的地方。寻找应该避免使用继承的地方。
- en: The goal is not to design a system (although you're certainly welcome to do
    so if inclination meets both ambition and available time). The goal is to think
    about object-oriented design. Focusing on projects that you have worked on, or
    are expecting to work on in the future, simply makes it real.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 目标不是设计一个系统（尽管如果你的兴趣和时间允许，你当然可以这样做）。目标是思考面向对象的设计。专注于你曾经参与过的项目，或者未来打算参与的项目，这样做就更真实了。
- en: Lastly, visit your favorite search engine and look up some tutorials on UML.
    There are dozens, so find one that suits your preferred method of study. Sketch
    some class diagrams or a sequence diagram for the objects you identified earlier.
    Don't get too hung up on memorizing the syntax (after all, if it is important,
    you can always look it up again); just get a feel for the language. Something
    will stay lodged in your brain, and it can make communicating a bit easier if
    you can quickly sketch a diagram for your next OOP discussion.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，访问你最喜欢的搜索引擎，查找一些关于UML的教程。有数十种教程，找一个适合你的学习方法的。为你之前确定的对象勾画一些类图或序列图。不要太过于纠结于记忆语法（毕竟，如果重要的话，你总是可以再次查阅）；只需对这种语言有所了解。你的大脑中会留下一些东西，如果你能快速勾画出下一个面向对象讨论的图表，那么交流会变得更容易一些。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a whirlwind tour through the terminology of the object-oriented
    paradigm, focusing on object-oriented design. We can separate different objects
    into a taxonomy of different classes and describe the attributes and behaviors
    of those objects via the class interface. Abstraction, encapsulation, and information
    hiding are highly-related concepts. There are many different kinds of relationships
    between objects, including association, composition, and inheritance. UML syntax
    can be useful for fun and communication.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们快速浏览了面向对象范式的术语，重点放在面向对象设计上。我们可以将不同的对象分为不同的类别，并通过类接口描述这些对象的属性和行为。抽象、封装和信息隐藏是高度相关的概念。对象之间有许多不同类型的关系，包括关联、组合和继承。UML语法对于乐趣和沟通可能会有用。
- en: In the next chapter, we'll explore how to implement classes and methods in Python.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何在Python中实现类和方法。

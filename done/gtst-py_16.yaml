- en: Objects in Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的对象
- en: So, we now have a design in hand and are ready to turn that design into a working
    program! Of course, it doesn't usually happen this way. We'll be seeing examples
    and hints for good software design throughout the book, but our focus is object-oriented
    programming. So, let's have a look at the Python syntax that allows us to create
    object-oriented software.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在手头上有一个设计，并且准备将该设计转化为一个可工作的程序！当然，通常情况下不会这样。我们将在整本书中看到好的软件设计示例和提示，但我们的重点是面向对象的编程。因此，让我们来看一下Python语法，它允许我们创建面向对象的软件。
- en: 'After completing this chapter, we will understand the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，我们将了解以下内容：
- en: How to create classes and instantiate objects in Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Python中创建类和实例化对象
- en: How to add attributes and behaviors to Python objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向Python对象添加属性和行为
- en: How to organize classes into packages and modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将类组织成包和模块
- en: How to suggest that people don't clobber our data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何建议人们不要破坏我们的数据
- en: Creating Python classes
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Python类
- en: We don't have to write much Python code to realize that Python is a very *clean* language.
    When we want to do something, we can just do it, without having to set up a bunch
    of prerequisite code. The ubiquitous *hello world* in Python, as you've likely
    seen, is only one line.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必写太多Python代码就能意识到Python是一种非常*干净*的语言。当我们想做某事时，我们可以直接做，而不必设置一堆先决条件代码。Python中无处不在的*hello
    world*，正如你可能已经看到的，只有一行。
- en: 'Similarly, the simplest class in Python 3 looks like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Python 3中最简单的类如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There's our first object-oriented program! The class definition starts with
    the `class` keyword. This is followed by a name (of our choice) identifying the
    class, and is terminated with a colon.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个面向对象的程序！类定义以`class`关键字开头。然后是一个名称（我们选择的）来标识类，并以冒号结束。
- en: The class name must follow standard Python variable naming rules (it must start
    with a letter or underscore, and can only be comprised of letters, underscores,
    or numbers). In addition, the Python style guide (search the web for *PEP 8*)
    recommends that classes should be named using **CapWords** notation (start with
    a capital letter; any subsequent words should also start with a capital).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 类名必须遵循标准的Python变量命名规则（必须以字母或下划线开头，只能由字母、下划线或数字组成）。此外，Python风格指南（在网上搜索*PEP 8*）建议使用**CapWords**表示法来命名类（以大写字母开头；任何后续的单词也应以大写字母开头）。
- en: The class definition line is followed by the class contents, indented. As with
    other Python constructs, indentation is used to delimit the classes, rather than
    braces, keywords, or brackets, as many other languages use. Also in line with
    the style guide, use four spaces for indentation unless you have a compelling
    reason not to (such as fitting in with somebody else's code that uses tabs for
    indents).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义行后面是类内容，缩进。与其他Python结构一样，缩进用于界定类，而不是大括号、关键字或括号，就像许多其他语言使用的那样。同样符合风格指南，除非有充分的理由不这样做（比如适应使用制表符缩进的其他人的代码），否则使用四个空格进行缩进。
- en: Since our first class doesn't actually add any data or behaviors, we simply
    use the `pass` keyword on the second line to indicate that no further action needs
    to be taken.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的第一个类实际上并没有添加任何数据或行为，我们只需在第二行使用`pass`关键字表示不需要采取进一步的行动。
- en: 'We might think there isn''t much we can do with this most basic class, but
    it does allow us to instantiate objects of that class. We can load the class into
    the Python 3 interpreter, so we can interactively play with it. To do this, save
    the class definition mentioned earlier in a file named `first_class.py` and then
    run the `python -i first_class.py` command. The `-i` argument tells Python to
    *run the code and then drop to the interactive interpreter*. The following interpreter
    session demonstrates a basic interaction with this class:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会认为这个最基本的类没有太多可以做的，但它确实允许我们实例化该类的对象。我们可以将该类加载到Python 3解释器中，这样我们就可以交互式地使用它。为了做到这一点，将前面提到的类定义保存在一个名为`first_class.py`的文件中，然后运行`python
    -i first_class.py`命令。`-i`参数告诉Python*运行代码然后转到交互式解释器*。以下解释器会话演示了与这个类的基本交互：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code instantiates two objects from the new class, named `a` and `b`. Creating
    an instance of a class is a simple matter of typing the class name, followed by
    a pair of parentheses. It looks much like a normal function call, but Python knows
    we're *calling* a class and not a function, so it understands that its job is
    to create a new object. When printed, the two objects tell us which class they
    are and what memory address they live at. Memory addresses aren't used much in
    Python code, but here, they demonstrate that there are two distinct objects involved.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从新类实例化了两个对象，命名为`a`和`b`。创建一个类的实例只需要输入类名，后面跟着一对括号。它看起来很像一个普通的函数调用，但Python知道我们*调用*的是一个类而不是一个函数，所以它知道它的工作是创建一个新对象。当打印时，这两个对象告诉我们它们属于哪个类以及它们所在的内存地址。在Python代码中很少使用内存地址，但在这里，它们表明有两个不同的对象参与其中。
- en: Adding attributes
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加属性
- en: Now, we have a basic class, but it's fairly useless. It doesn't contain any
    data, and it doesn't do anything. What do we have to do to assign an attribute
    to a given object?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个基本的类，但它相当无用。它不包含任何数据，也不做任何事情。我们需要做什么来为给定的对象分配属性？
- en: 'In fact, we don''t have to do anything special in the class definition. We
    can set arbitrary attributes on an instantiated object using dot notation:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在类定义中我们不必做任何特殊的事情。我们可以使用点符号在实例化的对象上设置任意属性：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we run this code, the two `print` statements at the end tell us the new
    attribute values on the two objects:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，结尾的两个`print`语句会告诉我们两个对象上的新属性值：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code creates an empty `Point` class with no data or behaviors. Then, it
    creates two instances of that class and assigns each of those instances `x` and
    `y` coordinates to identify a point in two dimensions. All we need to do to assign
    a value to an attribute on an object is use the `<object>.<attribute> = <value>`
    syntax. This is sometimes referred to as **dot notation**. You have likely encountered
    this same notation before when reading attributes on objects provided by the standard library
    or a third-party library. The value can be anything: a Python primitive, a built-in
    data type, or another object. It can even be a function or another class!'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个没有数据或行为的空`Point`类。然后，它创建了该类的两个实例，并分别为这些实例分配`x`和`y`坐标，以标识二维空间中的一个点。我们只需要使用`<object>.<attribute>
    = <value>`语法为对象的属性分配一个值。这有时被称为**点符号表示法**。在阅读标准库或第三方库提供的对象属性时，你可能已经遇到过这种表示法。值可以是任何东西：Python原语、内置数据类型或另一个对象。甚至可以是一个函数或另一个类！
- en: Making it do something
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让它做点什么
- en: Now, having objects with attributes is great, but object-oriented programming
    is really about the interaction between objects. We're interested in invoking
    actions that cause things to happen to those attributes. We have data; now it's
    time to add behaviors to our classes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，拥有属性的对象很棒，但面向对象编程实际上是关于对象之间的交互。我们感兴趣的是调用会影响这些属性的动作。我们有数据；现在是时候为我们的类添加行为了。
- en: 'Let''s model a couple of actions on our `Point` class. We can start with a
    **method** called `reset`, which moves the point to the origin (the origin is
    the place where `x` and `y` are both zero). This is a good introductory action
    because it doesn''t require any parameters:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的`Point`类上建模一些动作。我们可以从一个名为`reset`的**方法**开始，它将点移动到原点（原点是`x`和`y`都为零的地方）。这是一个很好的介绍性动作，因为它不需要任何参数：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This `print` statement shows us the two zeros on the attributes:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`print`语句显示了属性上的两个零：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In Python, a method is formatted identically to a function. It starts with the
    `def` keyword , followed by a space, and the name of the method. This is followed
    by a set of parentheses containing the parameter list (we'll discuss that `self`
    parameter in just a moment), and terminated with a colon. The next line is indented
    to contain the statements inside the method. These statements can be arbitrary
    Python code operating on the object itself and any parameters passed in, as the
    method sees fit.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，方法的格式与函数完全相同。它以`def`关键字开头，后面跟着一个空格，然后是方法的名称。然后是一组包含参数列表的括号（我们将在接下来讨论`self`参数），并以冒号结束。下一行缩进包含方法内部的语句。这些语句可以是任意的Python代码，对对象本身和传入的任何参数进行操作，方法会自行决定。
- en: Talking to yourself
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自言自语
- en: The one difference, syntactically, between methods and normal functions is that
    all methods have one required argument. This argument is conventionally named
    `self`; I've never seen a Python programmer use any other name for this variable
    (convention is a very powerful thing). There's nothing stopping you, however,
    from calling it `this` or even `Martha`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法和普通函数之间的一个语法上的区别是，所有方法都有一个必需的参数。这个参数通常被命名为`self`；我从未见过Python程序员使用其他名称来命名这个变量（约定是一件非常有力的事情）。但是没有什么能阻止你将其命名为`this`甚至`Martha`。
- en: The `self` argument to a method is a reference to the object that the method
    is being invoked on. We can access attributes and methods of that object as if
    it were any another object. This is exactly what we do inside the `reset` method
    when we set the `x` and `y` attributes of the `self` object.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 方法中的`self`参数是对调用该方法的对象的引用。我们可以访问该对象的属性和方法，就好像它是另一个对象一样。这正是我们在`reset`方法中所做的，当我们设置`self`对象的`x`和`y`属性时。
- en: Pay attention to the difference between a **class** and an **object** in this
    discussion. We can think of the **method** as a function attached to a class.
    The **self** parameter is a specific instance of that class. When you call the
    method on two different objects, you are calling the same method twice, but passing
    two different **objects** as the **self** parameter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个讨论中，注意**类**和**对象**之间的区别。我们可以将**方法**视为附加到类的函数。**self**参数是该类的特定实例。当你在两个不同的对象上调用方法时，你调用了相同的方法两次，但是将两个不同的**对象**作为**self**参数传递。
- en: Notice that when we call the `p.reset()` method, we do not have to pass the
    `self` argument into it. Python automatically takes care of this part for us.
    It knows we're calling a method on the `p` object, so it automatically passes
    that object to the method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们调用`p.reset()`方法时，我们不必将`self`参数传递给它。Python会自动为我们处理这部分。它知道我们在调用`p`对象上的方法，所以会自动将该对象传递给方法。
- en: 'However, the method really is just a function that happens to be on a class.
    Instead of calling the method on the object, we could invoke the function on the
    class, explicitly passing our object as the `self` argument:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，方法实际上只是一个恰好在类上的函数。我们可以不在对象上调用方法，而是显式地在类上调用函数，将我们的对象作为`self`参数传递：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The output is the same as in the previous example because, internally, the exact
    same process has occurred.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与前面的例子相同，因为在内部发生了完全相同的过程。
- en: 'What happens if we forget to include the `self` argument in our class definition?
    Python will bail with an error message, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在类定义中忘记包括`self`参数会发生什么？Python会报错，如下所示：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The error message is not as clear as it could be (Hey, silly, you forgot the
    `self` argument would be more informative). Just remember that when you see an
    error message that indicates missing arguments, the first thing to check is whether
    you forgot `self` in the method definition.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息并不像它本应该的那样清晰（嘿，傻瓜，你忘了`self`参数会更有信息量）。只要记住，当你看到指示缺少参数的错误消息时，首先要检查的是你是否在方法定义中忘记了`self`。
- en: More arguments
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多参数
- en: 'So, how do we pass multiple arguments to a method? Let''s add a new method
    that allows us to move a point to an arbitrary position, not just to the origin.
    We can also include one that accepts another `Point` object as input and returns
    the distance between them:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何将多个参数传递给一个方法呢？让我们添加一个新的方法，允许我们将一个点移动到任意位置，而不仅仅是原点。我们还可以包括一个接受另一个`Point`对象作为输入并返回它们之间距离的方法：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `print` statements at the end give us the following output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 结尾处的`print`语句给出了以下输出：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A lot has happened here. The class now has three methods. The `move` method
    accepts two arguments, `x` and `y`, and sets the values on the `self` object,
    much like the old `reset` method from the previous example. The old `reset` method
    now calls `move`, since a reset is just a move to a specific known location.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情。这个类现在有三个方法。`move`方法接受两个参数`x`和`y`，并在`self`对象上设置值，就像前面示例中的旧`reset`方法一样。旧的`reset`方法现在调用`move`，因为重置只是移动到一个特定的已知位置。
- en: The `calculate_distance` method uses the not-too-complex Pythagorean theorem
    to calculate the distance between two points. I hope you understand the math (`**2`
    means squared, and `math.sqrt` calculates a square root), but it's not a requirement
    for our current focus, learning how to write methods.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculate_distance`方法使用不太复杂的勾股定理来计算两点之间的距离。我希望你能理解这个数学（`**2`表示平方，`math.sqrt`计算平方根），但这并不是我们当前重点的要求，我们的当前重点是学习如何编写方法。'
- en: 'The sample code at the end of the preceding example shows how to call a method
    with arguments: simply include the arguments inside the parentheses, and use the
    same dot notation to access the method. I just picked some random positions to
    test the methods. The test code calls each method and prints the results on the
    console. The `assert` function is a simple test tool; the program will bail if
    the statement after `assert` evaluates to `False` (or zero, empty, or `None`).
    In this case, we use it to ensure that the distance is the same regardless of
    which point called the other point''s `calculate_distance` method.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例的结尾处的示例代码显示了如何调用带有参数的方法：只需将参数包含在括号内，并使用相同的点表示法来访问方法。我只是随机选择了一些位置来测试这些方法。测试代码调用每个方法并在控制台上打印结果。`assert`函数是一个简单的测试工具；如果`assert`后面的语句评估为`False`（或零、空或`None`），程序将退出。在这种情况下，我们使用它来确保无论哪个点调用另一个点的`calculate_distance`方法，距离都是相同的。
- en: Initializing the object
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化对象
- en: If we don't explicitly set the `x` and `y` positions on our `Point` object,
    either using `move` or by accessing them directly, we have a broken point with
    no real position. What will happen when we try to access it?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不显式设置`Point`对象上的`x`和`y`位置，要么使用`move`，要么直接访问它们，我们就会得到一个没有真实位置的破碎点。当我们尝试访问它时会发生什么呢？
- en: 'Well, let''s just try it and see. *Try it and see* is an extremely useful tool
    for Python study. Open up your interactive interpreter and type away. The following
    interactive session shows what happens if we try to access a missing attribute.
    If you saved the previous example as a file or are using the examples distributed
    with the book, you can load it into the Python interpreter with the `python -i
    more_arguments.py` command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们试试看。*试一试*是Python学习中非常有用的工具。打开你的交互式解释器，然后开始输入。以下交互式会话显示了如果我们尝试访问一个缺失属性会发生什么。如果你将前面的示例保存为文件，或者正在使用本书分发的示例，你可以使用`python
    -i more_arguments.py`命令将其加载到Python解释器中：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Well, at least it threw a useful exception. We'll cover exceptions in detail
    in [Chapter 18](50624d2e-4cec-4b84-89d0-5198af26590d.xhtml), *Expecting the Unexpected*.
    You've probably seen them before (especially the ubiquitous SyntaxError, which
    means you typed something incorrectly!). At this point, simply be aware that it
    means something went wrong.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，至少它抛出了一个有用的异常。我们将在[第18章](50624d2e-4cec-4b84-89d0-5198af26590d.xhtml)中详细介绍异常，*预料之外的情况*。你可能以前见过它们（特别是无处不在的SyntaxError，它意味着你输入了错误的东西！）。在这一点上，只需意识到它意味着出了问题。
- en: The output is useful for debugging. In the interactive interpreter, it tells
    us the error occurred at line 1, which is only partially true (in an interactive
    session, only one line is executed at a time). If we were running a script in
    a file, it would tell us the exact line number, making it easy to find the offending
    code. In addition, it tells us that the error is an `AttributeError`, and gives
    a helpful message telling us what that error means.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出对于调试是有用的。在交互式解释器中，它告诉我们错误发生在第1行，这只是部分正确的（在交互式会话中，一次只执行一行）。如果我们在文件中运行脚本，它会告诉我们确切的行号，这样很容易找到错误的代码。此外，它告诉我们错误是`AttributeError`，并给出一个有用的消息告诉我们这个错误是什么意思。
- en: We can catch and recover from this error, but in this case, it feels like we
    should have specified some sort of default value. Perhaps every new object should
    be `reset()` by default, or maybe it would be nice if we could force the user
    to tell us what those positions should be when they create the object.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以捕获并从这个错误中恢复，但在这种情况下，感觉我们应该指定某种默认值。也许每个新对象默认应该被`reset()`，或者也许当用户创建对象时，我们可以强制用户告诉我们这些位置应该是什么。
- en: Most object-oriented programming languages have the concept of a **constructor**,
    a special method that creates and initializes the object when it is created. Python
    is a little different; it has a constructor *and* an initializer. The constructor
    function is rarely used, unless you're doing something very exotic. So, we'll
    start our discussion with the much more common initialization method.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数面向对象的编程语言都有**构造函数**的概念，这是一个特殊的方法，用于在创建对象时创建和初始化对象。Python有点不同；它有一个构造函数*和*一个初始化器。构造函数很少使用，除非你在做一些非常奇特的事情。所以，我们将从更常见的初始化方法开始讨论。
- en: The Python initialization method is the same as any other method, except it
    has a special name, `__init__`. The leading and trailing double underscores mean
    this is a special method that the Python interpreter will treat as a special case.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Python的初始化方法与任何其他方法相同，只是它有一个特殊的名称`__init__`。前导和尾随的双下划线意味着这是一个特殊的方法，Python解释器将把它视为一个特殊情况。
- en: Never name a method of your own with leading and trailing double underscores.
    It may mean nothing to Python today, but there's always the possibility that the
    designers of Python will add a function that has a special purpose with that name
    in the future, and when they do, your code will break.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要以双下划线开头和结尾命名自己的方法。它可能对Python今天无关紧要，但总有可能Python的设计者将来会添加一个具有该名称特殊目的的函数，当他们这样做时，你的代码将会出错。
- en: 'Let''s add an initialization function on our `Point` class that requires the
    user to supply `x` and `y` coordinates when the `Point` object is instantiated:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的`Point`类上添加一个初始化函数，当实例化`Point`对象时需要用户提供`x`和`y`坐标：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, our point can never go without a `y` coordinate! If we try to construct
    a point without including the proper initialization parameters, it will fail with
    a `not enough arguments` error similar to the one we received earlier when we
    forgot the `self` argument.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的点永远不会没有`y`坐标！如果我们尝试构造一个点而没有包括正确的初始化参数，它将失败，并显示一个类似于我们之前忘记`self`参数时收到的`参数不足`错误。
- en: 'If we don''t want to make the two arguments required, we can use the same syntax
    Python functions use to provide default arguments. The keyword argument syntax
    appends an equals sign after each variable name. If the calling object does not
    provide this argument, then the default argument is used instead. The variables
    will still be available to the function, but they will have the values specified
    in the argument list. Here''s an example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想使这两个参数成为必需的，我们可以使用与Python函数使用的相同语法来提供默认参数。关键字参数语法在每个变量名称后附加一个等号。如果调用对象没有提供此参数，则将使用默认参数。变量仍然可用于函数，但它们将具有参数列表中指定的值。这是一个例子：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Most of the time, we put our initialization statements in an `__init__` function.
    But as mentioned earlier, Python has a constructor in addition to its initialization
    function. You may never need to use the other Python constructor (in well over
    a decade of professional Python coding, I can only think of two cases where I've
    used it, and in one of them, I probably shouldn't have!), but it helps to know
    it exists, so we'll cover it briefly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们将初始化语句放在`__init__`函数中。但正如前面提到的，Python除了初始化函数外还有一个构造函数。你可能永远不需要使用另一个Python构造函数（在十多年的专业Python编码中，我只想到了两种情况，在其中一种情况下，我可能不应该使用它！），但知道它的存在是有帮助的，所以我们将简要介绍一下。
- en: The constructor function is called `__new__` as opposed to `__init__`, and accepts
    exactly one argument; the **class** that is being constructed (it is called *before*
    the object is constructed, so there is no `self` argument). It also has to return
    the newly created object. This has interesting possibilities when it comes to
    the complicated art of metaprogramming, but is not very useful in day-to-day Python.
    In practice, you will rarely, if ever, need to use `__new__`. The `__init__` method
    will almost always be sufficient.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数被称为`__new__`，而不是`__init__`，并且只接受一个参数；正在构造的**类**（在构造对象之前调用，因此没有`self`参数）。它还必须返回新创建的对象。在涉及复杂的元编程时，这具有有趣的可能性，但在日常Python中并不是非常有用。实际上，你几乎永远不需要使用`__new__`。`__init__`方法几乎总是足够的。
- en: Explaining yourself
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我解释
- en: Python is an extremely easy-to-read programming language; some might say it
    is self-documenting. However, when carrying out object-oriented programming, it
    is important to write API documentation that clearly summarizes what each object
    and method does. Keeping documentation up to date is difficult; the best way to
    do it is to write it right into our code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种非常易于阅读的编程语言；有些人可能会说它是自我记录的。然而，在进行面向对象编程时，编写清楚总结每个对象和方法功能的API文档是很重要的。保持文档的最新状态是困难的；最好的方法是将其直接写入我们的代码中。
- en: Python supports this through the use of **docstrings**. Each class, function,
    or method header can have a standard Python string as the first line following
    the definition (the line that ends in a colon). This line should be indented the
    same as the code that follows it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Python通过使用**文档字符串**来支持这一点。每个类、函数或方法头部都可以有一个标准的Python字符串作为定义后面的第一行（以冒号结尾的行）。这一行应与随后的代码缩进相同。
- en: Docstrings are simply Python strings enclosed with apostrophes (`'`) or quotation
    marks (`"`) characters. Often, docstrings are quite long and span multiple lines
    (the style guide suggests that the line length should not exceed 80 characters),
    which can be formatted as multi-line strings, enclosed in matching triple apostrophe
    (`'''`) or triple quote (`"""`) characters.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串只是用撇号（`'`）或引号（`"`）括起来的Python字符串。通常，文档字符串非常长，跨越多行（风格指南建议行长不超过80个字符），可以格式化为多行字符串，用匹配的三个撇号（`'''`）或三引号（`"""`）字符括起来。
- en: A docstring should clearly and concisely summarize the purpose of the class
    or method it is describing. It should explain any parameters whose usage is not
    immediately obvious, and is also a good place to include short examples of how
    to use the API. Any caveats or problems an unsuspecting user of the API should
    be aware of should also be noted.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串应清楚而简洁地总结所描述的类或方法的目的。它应解释任何使用不明显的参数，并且还是包含如何使用API的简短示例的好地方。还应注意任何使用API的不知情用户应该注意的注意事项或问题。
- en: 'To illustrate the use of docstrings, we will end this section with our completely
    documented `Point` class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明文档字符串的用法，我们将以完全记录的`Point`类结束本节：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Try typing or loading (remember, it's `python -i point.py`) this file into the
    interactive interpreter. Then, enter `help(Point)<enter>` at the Python prompt.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在交互式解释器中键入或加载（记住，是`python -i point.py`）这个文件。然后，在Python提示符下输入`help(Point)<enter>`。
- en: 'You should see nicely formatted documentation for the class, as shown in the
    following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类的格式良好的文档，如下面的屏幕截图所示：
- en: '![](assets/42cfc96e-6a55-47a9-aad7-b896b9f4fe59.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/42cfc96e-6a55-47a9-aad7-b896b9f4fe59.png)'
- en: Modules and packages
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块和包
- en: Now we know how to create classes and instantiate objects. You don't need to
    write too many classes (or non-object-oriented code, for that matter) before you
    start to lose track of them. For small programs, we can just put all our classes
    into one file and add a little script at the end of the file to start them interacting.
    However, as our projects grow, it can become difficult to find the one class that
    needs to be edited among the many classes we've defined. This is where **modules**
    come in. Modules are simply Python files, nothing more. The single file in our
    small program is a module. Two Python files are two modules. If we have two files
    in the same folder, we can load a class from one module for use in the other module.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何创建类和实例化对象了。在开始失去追踪之前，你不需要写太多的类（或者非面向对象的代码）。对于小程序，我们可以把所有的类放在一个文件中，并在文件末尾添加一个小脚本来启动它们的交互。然而，随着项目的增长，要在我们定义的许多类中找到需要编辑的类可能会变得困难。这就是**模块**的用武之地。模块只是Python文件，没有别的。我们小程序中的单个文件就是一个模块。两个Python文件就是两个模块。如果我们有两个文件在同一个文件夹中，我们可以从一个模块中加载一个类以在另一个模块中使用。
- en: 'For example, if we are building an e-commerce system, we will likely be storing
    a lot of data in a database. We can put all the classes and functions related
    to database access into a separate file (we''ll call it something sensible: `database.py`).
    Then, our other modules (for example, customer models, product information, and
    inventory) can import classes from that module in order to access the database.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们正在构建一个电子商务系统，我们可能会在数据库中存储大量数据。我们可以把所有与数据库访问相关的类和函数放在一个单独的文件中（我们将其称为一个合理的名字：`database.py`）。然后，我们的其他模块（例如，客户模型、产品信息和库存）可以导入该模块中的类以访问数据库。
- en: The `import` statement is used for importing modules or specific classes or
    functions from modules. We've already seen an example of this in our `Point` class
    in the previous section. We used the `import` statement to get Python's built-in
    `math` module and use its `sqrt` function in the `distance` calculation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句用于导入模块或特定类或函数。我们在前一节的`Point`类中已经看到了一个例子。我们使用`import`语句获取Python的内置`math`模块，并在`distance`计算中使用它的`sqrt`函数。'
- en: Here's a concrete example. Assume we have a module called `database.py`, which
    contains a class called `Database`. A second module called `products.py` is responsible
    for product-related queries. At this point, we don't need to think too much about
    the contents of these files. What we know is that `products.py` needs to instantiate
    the `Database` class from `database.py` so that it can execute queries on the
    product table in the database.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个具体的例子。假设我们有一个名为`database.py`的模块，其中包含一个名为`Database`的类。第二个名为`products.py`的模块负责与产品相关的查询。在这一点上，我们不需要太多考虑这些文件的内容。我们知道的是`products.py`需要从`database.py`中实例化`Database`类，以便它可以在数据库中的产品表上执行查询。
- en: 'There are several variations on the `import` statement syntax that can be used
    to access the class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种`import`语句的变体语法可以用来访问这个类：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This version imports the `database` module into the `products` namespace (the
    list of names currently accessible in a module or function), so any class or function
    in the `database` module can be accessed using the `database.<something>` notation.
    Alternatively, we can import just the one class we need using the `from...import`
    syntax:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本将`database`模块导入到`products`命名空间（模块或函数中当前可访问的名称列表），因此可以使用`database.<something>`的表示法访问`database`模块中的任何类或函数。或者，我们可以使用`from...import`语法只导入我们需要的一个类：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If, for some reason, `products` already has a class called `Database`, and
    we don''t want the two names to be confused, we can rename the class when used
    inside the `products` module:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，`products`已经有一个名为`Database`的类，我们不希望这两个名称混淆，我们可以在`products`模块中使用时重命名该类：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can also import multiple items in one statement. If our `database` module
    also contains a `Query` class, we can import both classes using the following
    code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在一个语句中导入多个项目。如果我们的`database`模块还包含一个`Query`类，我们可以使用以下代码导入两个类：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Some sources say that we can import all classes and functions from the `database`
    module using this syntax:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一些来源称我们可以使用以下语法从`database`模块中导入所有类和函数：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Don''t do this.** Most experienced Python programmers will tell you that
    you should never use this syntax (a few will tell you there are some very specific
    situations where it is useful, but I disagree). They''ll use obscure justifications
    such as *it clutters up the namespace*, which doesn''t make much sense to beginners.
    One way to learn why to avoid this syntax is to use it and try to understand your
    code two years later. But we can save some time and two years of poorly written
    code with a quick explanation now!'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要这样做。** 大多数有经验的Python程序员会告诉你，你不应该使用这种语法（有些人会告诉你有一些非常具体的情况下它是有用的，但我不同意）。他们会使用模糊的理由，比如*它会使命名空间混乱*，这对初学者来说并不太有意义。避免使用这种语法的一个方法是使用它并在两年后尝试理解你的代码。但我们可以通过一个简单的解释来节省一些时间和两年的糟糕代码！'
- en: When we explicitly import the `database` class at the top of our file using
    `from database import Database`, we can easily see where the `Database` class
    comes from. We might use `db = Database()` 400 lines later in the file, and we
    can quickly look at the imports to see where that `Database` class came from.
    Then, if we need clarification as to how to use the `Database` class, we can visit
    the original file (or import the module in the interactive interpreter and use
    the `help(database.Database)` command). However, if we use the `from database
    import *` syntax, it takes a lot longer to find where that class is located. Code
    maintenance becomes a nightmare.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在文件顶部明确导入`database`类时，使用`from database import Database`，我们可以很容易地看到`Database`类来自哪里。我们可能会在文件的后面400行使用`db
    = Database()`，我们可以快速查看导入来看`Database`类来自哪里。然后，如果我们需要澄清如何使用`Database`类，我们可以访问原始文件（或者在交互式解释器中导入模块并使用`help(database.Database)`命令）。然而，如果我们使用`from
    database import *`语法，要找到该类的位置就要花费更多的时间。代码维护变成了一场噩梦。
- en: In addition, most code editors are able to provide extra functionality, such
    as reliable code completion, the ability to jump to the definition of a class,
    or inline documentation, if normal imports are used. The `import *` syntax usually
    completely destroys their ability to do this reliably.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，大多数代码编辑器能够提供额外的功能，比如可靠的代码补全、跳转到类的定义或内联文档，如果使用普通的导入。`import *`语法通常会完全破坏它们可靠地执行这些功能的能力。
- en: Finally, using the `import *` syntax can bring unexpected objects into our local
    namespace. Sure, it will import all the classes and functions defined in the module
    being imported from, but it will also import any classes or modules that were
    themselves imported into that file!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`import *`语法可能会将意外的对象带入我们的本地命名空间。当然，它会导入从被导入的模块中定义的所有类和函数，但它也会导入任何被导入到该文件中的类或模块！
- en: Every name used in a module should come from a well-specified place, whether
    it is defined in that module, or explicitly imported from another module. There
    should be no magic variables that seem to come out of thin air. We should *always*
    be able to immediately identify where the names in our current namespace originated.
    I promise that if you use this evil syntax, you will one day have extremely frustrating
    moments of *where on earth can this class be coming from?*
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 模块中使用的每个名称都应该来自一个明确定义的地方，无论它是在该模块中定义的，还是从另一个模块中明确导入的。不应该有看起来像是凭空出现的魔术变量。我们应该*总是*能够立即确定我们当前命名空间中的名称来自哪里。我保证，如果你使用这种邪恶的语法，总有一天你会非常沮丧地发现*这个类到底是从哪里来的？*
- en: For fun, try typing `import this` into your interactive interpreter. It prints
    a nice poem (with a couple of inside jokes you can ignore) summarizing some of
    the idioms that Pythonistas tend to practice. Specific to this discussion, note
    the line *Explicit is better than implicit*. Explicitly importing names into your
    namespace makes your code much easier to navigate than the implicit `import *`
    syntax.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 玩一下，尝试在交互式解释器中输入`import this`。它会打印一首很好的诗（其中有一些你可以忽略的笑话），总结了一些Python程序员倾向于实践的习惯用法。特别是在这次讨论中，注意到了*明确胜于隐式*这一句。将名称明确导入到你的命名空间中，比隐式的`import
    *`语法使你的代码更容易浏览。
- en: Organizing modules
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块组织
- en: As a project grows into a collection of more and more modules, we may find that
    we want to add another level of abstraction, some kind of nested hierarchy on
    our modules' levels. However, we can't put modules inside modules; one file can
    hold only one file after all, and modules are just files.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目逐渐发展成为越来越多模块的集合，我们可能会发现我们想要在模块的层次上添加另一层抽象，一种嵌套的层次结构。然而，我们不能将模块放在模块内；毕竟，一个文件只能包含一个文件，而模块只是文件。
- en: Files, however, can go in folders, and so can modules. A **package** is a collection
    of modules in a folder. The name of the package is the name of the folder. We
    need to tell Python that a folder is a package to distinguish it from other folders
    in the directory. To do this, place a (normally empty) file in the folder named
    `__init__.py`. If we forget this file, we won't be able to import modules from
    that folder.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，文件可以放在文件夹中，模块也可以。**包**是文件夹中模块的集合。包的名称就是文件夹的名称。我们需要告诉Python一个文件夹是一个包，以区别于目录中的其他文件夹。为此，在文件夹中放置一个（通常是空的）名为`__init__.py`的文件。如果我们忘记了这个文件，我们将无法从该文件夹导入模块。
- en: 'Let''s put our modules inside an `ecommerce` package in our working folder,
    which will also contain a `main.py` file to start the program. Let''s additionally
    add another package inside the `ecommerce` package for various payment options.
    The folder hierarchy will look like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的模块放在一个名为`ecommerce`的包中，该包还将包含一个`main.py`文件来启动程序。此外，让我们在`ecommerce`包内添加另一个用于各种支付选项的包。文件夹层次结构将如下所示：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When importing modules or classes between packages, we have to be cautious
    about the syntax. In Python 3, there are two ways of importing modules: absolute
    imports and relative imports.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在包之间导入模块或类时，我们必须注意语法。在Python 3中，有两种导入模块的方式：绝对导入和相对导入。
- en: Absolute imports
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绝对导入
- en: '**Absolute imports** specify the complete path to the module, function, or
    class we want to import. If we need access to the `Product` class inside the `products`
    module, we could use any of these syntaxes to perform an absolute import:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对导入指定要导入的模块、函数或类的完整路径。如果我们需要访问`products`模块内的`Product`类，我们可以使用以下任何一种语法来执行绝对导入：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `import` statements use the period operator to separate packages or modules.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句使用句点运算符来分隔包或模块。'
- en: These statements will work from any module. We could instantiate a `Product`
    class using this syntax in `main.py`, in the `database` module, or in either of
    the two payment modules. Indeed, assuming the packages are available to Python,
    it will be able to import them. For example, the packages can also be installed
    in the Python site packages folder, or the `PYTHONPATH` environment variable could
    be customized to dynamically tell Python which folders to search for packages
    and modules it is going to import.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语句将从任何模块中起作用。我们可以在`main.py`、`database`模块中或两个支付模块中的任何一个中使用这种语法实例化`Product`类。确实，假设包对Python可用，它将能够导入它们。例如，这些包也可以安装在Python站点包文件夹中，或者`PYTHONPATH`环境变量可以被定制为动态地告诉Python要搜索哪些文件夹以及它要导入的模块。
- en: So, with these choices, which syntax do we choose? It depends on your personal
    taste and the application at hand. If there are dozens of classes and functions
    inside the `products` module that I want to use, I generally import the module
    name using the `from ecommerce import products` syntax, and then access the individual
    classes using `products.Product`. If I only need one or two classes from the `products`
    module, I can import them directly using the `from ecommerce.products import Product`
    syntax. I don't personally use the first syntax very often, unless I have some
    kind of name conflict (for example, I need to access two completely different
    modules called `products` and I need to separate them). Do whatever you think
    makes your code look more elegant.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在这些选择中，我们选择哪种语法呢？这取决于你的个人喜好和手头的应用。如果`products`模块中有数十个类和函数我想要使用，我通常使用`from
    ecommerce import products`语法导入模块名称，然后使用`products.Product`访问单个类。如果我只需要`products`模块中的一个或两个类，我可以直接使用`from
    ecommerce.products import Product`语法导入它们。我个人不经常使用第一种语法，除非我有某种名称冲突（例如，我需要访问两个完全不同的名为`products`的模块并且需要将它们分开）。做任何你认为使你的代码看起来更优雅的事情。
- en: Relative imports
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相对导入
- en: 'When working with related modules inside a package, it seems kind of redundant
    to specify the full path; we know what our parent module is named. This is where
    **relative imports** come in. Relative imports are basically a way of saying find
    a class, function, or module as it is positioned relative to the current module.
    For example, if we are working in the `products` module and we want to import
    the `Database` class from the `database` module next to it, we could use a relative
    import:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在包内使用相关模块时，指定完整路径似乎有些多余；我们知道父模块的名称。这就是**相对导入**的用武之地。相对导入基本上是一种说法，即按照当前模块的位置来查找类、函数或模块。例如，如果我们在`products`模块中工作，并且想要从旁边的`database`模块导入`Database`类，我们可以使用相对导入：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The period in front of `database` says *use the database module inside the current
    package*. In this case, the current package is the package containing the `products.py`
    file we are currently editing, that is, the `ecommerce` package.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`database`前面的句点表示*使用当前包内的数据库模块*。在这种情况下，当前包是包含我们当前正在编辑的`products.py`文件的包，也就是`ecommerce`包。'
- en: 'If we were editing the `paypal` module inside the `ecommerce.payments` package,
    we would want, for example, to *use the database package inside the parent package* instead.
    This is easily done with two periods, as shown here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在编辑`ecommerce.payments`包内的`paypal`模块，我们可能会希望*使用父包内的数据库包*。这很容易通过两个句点来实现，如下所示：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can use more periods to go further up the hierarchy. Of course, we can also
    go down one side and back up the other. We don''t have a deep enough example hierarchy
    to illustrate this properly, but the following would be a valid import if we had
    an `ecommerce.contact` package containing an `email` module and wanted to import
    the `send_mail` function into our `paypal` module:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用更多句点来进一步上溯层次。当然，我们也可以沿着一边下去，然后沿着另一边上来。我们没有足够深的示例层次结构来正确说明这一点，但是如果我们有一个包含`email`模块并且想要将`send_mail`函数导入到我们的`paypal`模块的`ecommerce.contact`包，以下将是一个有效的导入：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This import uses two periods  indicating, *the parent of the payments package*,
    and then uses the normal `package.module` syntax to go back down into the contact
    package.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个导入使用两个句点，表示*父级支付包*，然后使用正常的`package.module`语法返回到联系包。
- en: Finally, we can import code directly from packages, as opposed to just modules
    inside packages. In this example, we have an `ecommerce` package containing two
    modules named `database.py` and `products.py`. The database module contains a
    `db` variable that is accessed from a lot of places. Wouldn't it be convenient
    if this could be imported as `import ecommerce.db` instead of `import ecommerce.database.db`?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以直接从包中导入代码，而不仅仅是包内的模块。在这个例子中，我们有一个名为`ecommerce`的包，其中包含两个名为`database.py`和`products.py`的模块。数据库模块包含一个`db`变量，可以从许多地方访问。如果可以像`import
    ecommerce.db`而不是`import ecommerce.database.db`这样导入，那不是很方便吗？
- en: 'Remember the `__init__.py` file that defines a directory as a package? This
    file can contain any variable or class declarations we like, and they will be
    available as part of the package. In our example, if the `ecommerce/__init__.py`
    file contained the following line:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得`__init__.py`文件定义目录为包吗？这个文件可以包含我们喜欢的任何变量或类声明，并且它们将作为包的一部分可用。在我们的例子中，如果`ecommerce/__init__.py`文件包含以下行：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We could then access the `db` attribute from `main.py` or any other file using
    the following import:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以从`main.py`或任何其他文件中使用以下导入访问`db`属性：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It might help to think of the `__init__.py` file as if it were an `ecommerce.py`
    file, if that file were a module instead of a package. This can also be useful
    if you put all your code in a single module and later decide to break it up into
    a package of modules. The `__init__.py` file for the new package can still be
    the main point of contact for other modules talking to it, but the code can be
    internally organized into several different modules or subpackages.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将`__init__.py`文件视为一个`ecommerce.py`文件可能有所帮助，如果该文件是一个模块而不是一个包。如果您将所有代码放在一个单独的模块中，然后决定将其拆分为多个模块的包，这也可能很有用。新包的`__init__.py`文件仍然可以是其他模块与其交流的主要联系点，但代码可以在几个不同的模块或子包中进行内部组织。
- en: I recommend not putting much code in an `__init__.py` file, though. Programmers
    do not expect actual logic to happen in this file, and much like with `from x
    import *`, it can trip them up if they are looking for the declaration of a particular
    piece of code and can't find it until they check `__init__.py`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议不要在`__init__.py`文件中放太多代码。程序员不希望在这个文件中发生实际逻辑，就像`from x import *`一样，如果他们正在寻找特定代码的声明并且找不到直到他们检查`__init__.py`，它可能会让他们困惑。
- en: Organizing module content
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织模块内容
- en: 'Inside any one module, we can specify variables, classes, or functions. They
    can be a handy way to store the global state without namespace conflicts. For
    example, we have been importing the `Database` class into various modules and
    then instantiating it, but it might make more sense to have only one `database`
    object globally available from the `database` module. The `database` module might
    look like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何一个模块内，我们可以指定变量、类或函数。它们可以是一种方便的方式来存储全局状态，而不会发生命名空间冲突。例如，我们一直在将`Database`类导入各种模块，然后实例化它，但也许更合理的是只有一个`database`对象全局可用于`database`模块。`database`模块可能是这样的：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then we can use any of the import methods we''ve discussed to access the `database`
    object, for example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用我们讨论过的任何导入方法来访问`database`对象，例如：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A problem with the preceding class is that the `database` object is created
    immediately when the module is first imported, which is usually when the program
    starts up. This isn''t always ideal, since connecting to a database can take a
    while, slowing down startup, or the database connection information may not yet
    be available. We could delay creating the database until it is actually needed
    by calling an `initialize_database` function to create a module-level variable:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类的一个问题是，`database`对象在模块第一次被导入时就被立即创建，通常是在程序启动时。这并不总是理想的，因为连接到数据库可能需要一些时间，会减慢启动速度，或者数据库连接信息可能尚未可用。我们可以通过调用`initialize_database`函数来延迟创建数据库，以创建一个模块级变量：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `global` keyword tells Python that the database variable inside `initialize_database`
    is the module level one we just defined. If we had not specified the variable
    as global, Python would have created a new local variable that would be discarded
    when the method exits, leaving the module-level value unchanged.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`global`关键字告诉Python，`initialize_database`内部的数据库变量是我们刚刚定义的模块级变量。如果我们没有将变量指定为全局的，Python会创建一个新的局部变量，当方法退出时会被丢弃，从而保持模块级别的值不变。'
- en: As these two examples illustrate, all module-level code is executed immediately
    at the time it is imported. However, if it is inside a method or function, the
    function will be created, but its internal code will not be executed until the
    function is called. This can be a tricky thing for scripts that perform execution
    (such as the main script in our e-commerce example). Sometimes, we write a program
    that does something useful, and then later find that we want to import a function
    or class from that module into a different program. However, as soon as we import
    it, any code at the module level is immediately executed. If we are not careful,
    we can end up running the first program when we really only meant to access a
    couple of functions inside that module.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这两个例子所说明的，所有模块级代码都会在导入时立即执行。但是，如果它在方法或函数内部，函数会被创建，但其内部代码直到调用函数时才会被执行。对于执行脚本（比如我们电子商务示例中的主要脚本）来说，这可能是一个棘手的问题。有时，我们编写一个执行有用操作的程序，然后后来发现我们想要从该模块导入一个函数或类到另一个程序中。然而，一旦我们导入它，模块级别的任何代码都会立即执行。如果我们不小心，我们可能会在真正只想访问该模块中的一些函数时运行第一个程序。
- en: 'To solve this, we should always put our start up code in a function (conventionally,
    called `main`) and only execute that function when we know we are running the
    module as a script, but not when our code is being imported from a different script.
    We can do this by **guarding** the call to `main` inside a conditional statement,
    demonstrated as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们应该总是将启动代码放在一个函数中（通常称为`main`），并且只有在知道我们正在作为脚本运行模块时才执行该函数，而不是在我们的代码被从另一个脚本导入时执行。我们可以通过在条件语句中**保护**对`main`的调用来实现这一点，如下所示：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Every module has a `__name__` special variable (remember, Python uses double
    underscores for special variables, such as a class's `__init__` method) that specifies
    the name of the module when it was imported. When the module is executed directly
    with `python module.py`, it is never imported, so the `__name__` is arbitrarily
    set to the `"__main__"` string. Make it a policy to wrap all your scripts in an
    `if __name__ == "__main__":` test, just in case you write a function that you
    may want to be imported by other code at some point in the future.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都有一个`__name__`特殊变量（记住，Python使用双下划线表示特殊变量，比如类的`__init__`方法），它指定了模块在导入时的名称。当模块直接用`python
    module.py`执行时，它不会被导入，所以`__name__`会被任意设置为`"__main__"`字符串。制定一个规则，将所有脚本都包裹在`if __name__
    == "__main__":`测试中，以防万一你写了一个以后可能想被其他代码导入的函数。
- en: So, methods go in classes, which go in modules, which go in packages. Is that
    all there is to it?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，方法放在类中，类放在模块中，模块放在包中。这就是全部吗？
- en: 'Actually, no. This is the typical order of things in a Python program, but
    it''s not the only possible layout. Classes can be defined anywhere. They are
    typically defined at the module level, but they can also be defined inside a function
    or method, like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，不是。这是Python程序中的典型顺序，但不是唯一可能的布局。类可以在任何地方定义。它们通常在模块级别定义，但也可以在函数或方法内部定义，就像这样：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output would be as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `format_string` function accepts a string and optional formatter object,
    and then applies the formatter to that string. If no formatter is supplied, it
    creates a formatter of its own as a local class and instantiates it. Since it
    is created inside the scope of the function, this class cannot be accessed from
    anywhere outside of that function. Similarly, functions can be defined inside
    other functions as well; in general, any Python statement can be executed at any
    time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`format_string`函数接受一个字符串和可选的格式化器对象，然后将格式化器应用于该字符串。如果没有提供格式化器，它会创建一个自己的格式化器作为本地类并实例化它。由于它是在函数范围内创建的，这个类不能从函数外部访问。同样，函数也可以在其他函数内部定义；一般来说，任何Python语句都可以在任何时候执行。'
- en: These inner classes and functions are occasionally useful for one-off items
    that don't require or deserve their own scope at the module level, or only make
    sense inside a single method. However, it is not common to see Python code that
    frequently uses this technique.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内部类和函数偶尔对于不需要或不值得在模块级别拥有自己的作用域的一次性项目是有用的，或者只在单个方法内部有意义。然而，通常不会看到频繁使用这种技术的Python代码。
- en: Who can access my data?
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谁可以访问我的数据？
- en: Most object-oriented programming languages have a concept of **access control**.
    This is related to abstraction. Some attributes and methods on an object are marked
    private, meaning only that object can access them. Others are marked protected,
    meaning only that class and any subclasses have access. The rest are public, meaning
    any other object is allowed to access them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数面向对象的编程语言都有**访问控制**的概念。这与抽象有关。对象上的一些属性和方法被标记为私有，意味着只有该对象可以访问它们。其他的被标记为受保护，意味着只有该类和任何子类才能访问。其余的是公共的，意味着任何其他对象都可以访问它们。
- en: Python doesn't do this. Python doesn't really believe in enforcing laws that
    might someday get in your way. Instead, it provides unenforced guidelines and
    best practices. Technically, all methods and attributes on a class are publicly
    available. If we want to suggest that a method should not be used publicly, we
    can put a note in docstrings indicating that the method is meant for internal
    use only (preferably, with an explanation of how the public-facing API works!).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Python不这样做。Python实际上不相信强制执行可能在某一天妨碍你的法律。相反，它提供了未强制执行的指南和最佳实践。从技术上讲，类上的所有方法和属性都是公开可用的。如果我们想表明一个方法不应该公开使用，我们可以在文档字符串中放置一个注释，指出该方法仅用于内部使用（最好还要解释公共API的工作原理！）。
- en: By convention, we should also prefix an internal attribute or method with an
    underscore character, `_`. Python programmers will interpret this as *this is
    an internal variable, think three times before accessing it directly*. But there
    is nothing inside the interpreter to stop them from accessing it if they think
    it is in their best interest to do so. Because, if they think so, why should we
    stop them? We may not have any idea what future uses our classes may be put to.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，我们还应该使用下划线字符`_`作为内部属性或方法的前缀。Python程序员会将其解释为*这是一个内部变量，在直接访问之前要三思*。但是，如果他们认为这样做符合他们的最佳利益，解释器内部没有任何东西可以阻止他们访问它。因为，如果他们这样认为，我们为什么要阻止他们呢？我们可能不知道我们的类将来可能被用于什么用途。
- en: 'There''s another thing you can do to strongly suggest that outside objects
    don''t access a property or method: prefix it with a double underscore, `__`.
    This will perform **name mangling** on the attribute in question. In essence,
    name mangling means that the method can still be called by outside objects if
    they really want to do so, but it requires extra work and is a strong indicator
    that you demand that your attribute remains **private**. Here is an example code
    snippet:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一件事可以强烈建议外部对象不要访问属性或方法：用双下划线`__`作为前缀。这将对属性进行**名称混淆**。实质上，名称混淆意味着如果外部对象真的想这样做，仍然可以调用该方法，但这需要额外的工作，并且强烈表明您要求您的属性保持**私有**。以下是一个示例代码片段：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we load this class and test it in the interactive interpreter, we can see
    that it hides the plain text string from the outside world:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在交互式解释器中加载这个类并测试它，我们可以看到它将明文字符串隐藏在外部世界之外：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It looks like it works; nobody can access our `plain_string` attribute without
    the passphrase, so it must be safe. Before we get too excited, though, let''s
    see how easy it can be to hack our security:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来好像可以了；没有人可以在没有口令的情况下访问我们的`plain_string`属性，所以应该是安全的。然而，在我们过于兴奋之前，让我们看看有多容易破解我们的安全性：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Oh no! Somebody has discovered our secret string. Good thing we checked.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 哦不！有人发现了我们的秘密字符串。好在我们检查了。
- en: This is Python name mangling at work. When we use a double underscore, the property
    is prefixed with `_<classname>`. When methods in the class internally access the
    variable, they are automatically unmangled. When external classes wish to access
    it, they have to do the name mangling themselves. So, name mangling does not guarantee
    privacy; it only strongly recommends it. Most Python programmers will not touch
    a double underscore variable on another object unless they have an extremely compelling
    reason to do so.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Python名称混淆的工作原理。当我们使用双下划线时，属性前缀为`_<classname>`。当类中的方法内部访问变量时，它们会自动取消混淆。当外部类希望访问它时，它们必须自己进行名称混淆。因此，名称混淆并不保证隐私；它只是强烈建议。除非有极其充分的理由，大多数Python程序员不会触碰另一个对象上的双下划线变量。
- en: However, most Python programmers will not touch a single underscore variable
    without a compelling reason either. Therefore, there are very few good reasons
    to use a name-mangled variable in Python, and doing so can cause grief. For example,
    a name-mangled variable may be useful to an as-yet-unknown subclass, and it would
    have to do the mangling itself. Let other objects access your hidden information
    if they want to. Just let them know, using a single-underscore prefix or some
    clear docstrings, that you think this is not a good idea.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数Python程序员不会在没有充分理由的情况下触碰单个下划线变量。因此，在Python中使用名称混淆的变量的很少有很好的理由，这样做可能会引起麻烦。例如，名称混淆的变量可能对尚未知道的子类有用，它必须自己进行混淆。如果其他对象想要访问您的隐藏信息，就让它们知道，使用单下划线前缀或一些清晰的文档字符串，表明您认为这不是一个好主意。
- en: Third-party libraries
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方库
- en: 'Python ships with a lovely standard library, which is a collection of packages
    and modules that are available on every machine that runs Python. However, you''ll
    soon find that it doesn''t contain everything you need. When this happens, you
    have two options:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Python附带了一个可爱的标准库，这是一个包和模块的集合，可以在运行Python的每台机器上使用。然而，您很快会发现它并不包含您所需的一切。当这种情况发生时，您有两个选择：
- en: Write a supporting package yourself
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自己编写一个支持包
- en: Use somebody else's code
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用别人的代码
- en: 'We won''t be covering the details about turning your packages into libraries,
    but if you have a problem you need to solve and you don''t feel like coding it
    (the best programmers are extremely lazy and prefer to reuse existing, proven
    code, rather than write their own), you can probably find the library you want
    on the **Python Package Index** (**PyPI**) at [http://pypi.python.org/](http://pypi.python.org/).
    Once you''ve identified a package that you want to install, you can use a tool
    called `pip` to install it. However, `pip` does not come with Python, but Python
    3.4 and higher contain a useful tool called `ensurepip`. You can use this command
    to install it:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍如何将您的软件包转换为库，但是如果您有需要解决的问题，而且不想编写代码（最好的程序员非常懒惰，更喜欢重用现有的经过验证的代码，而不是编写自己的代码），您可能可以在**Python软件包索引**（**PyPI**）[http://pypi.python.org/](http://pypi.python.org/)上找到您想要的库。确定要安装的软件包后，您可以使用一个名为`pip`的工具来安装它。但是，`pip`不随Python一起提供，但Python
    3.4及更高版本包含一个称为`ensurepip`的有用工具。您可以使用此命令来安装它：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This may fail for you on Linux, macOS, or other Unix systems, in which case,
    you'll need to become a root user to make it work. On most modern Unix systems,
    this can be done with `sudo python -m ensurepip`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能在Linux、macOS或其他Unix系统上失败，这种情况下，您需要成为root用户才能使其工作。在大多数现代Unix系统上，可以使用`sudo
    python -m ensurepip`来完成此操作。
- en: If you are using an older version of Python than Python 3.4, you'll need to
    download and install `pip` yourself, since `ensurepip` isn't available. You can
    do this by following the instructions at: [http://pip.readthedocs.org/](http://pip.readthedocs.org/).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的Python版本早于Python 3.4，您需要自己下载并安装`pip`，因为`ensurepip`不可用。您可以按照以下网址的说明进行操作：[http://pip.readthedocs.org/](http://pip.readthedocs.org/)。
- en: 'Once `pip` is installed and you know the name of the package you want to install,
    you can install it using syntax such as the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了`pip`并且知道要安装的软件包的名称，您可以使用以下语法来安装它：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: However, if you do this, you'll either be installing the third-party library
    directly into your system Python directory, or, more likely, will get an error
    that you don't have permission to do so. You could force the installation as an
    administrator, but common consensus in the Python community is that you should
    only use system installers to install the third-party library to your system Python
    directory.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果这样做，您要么会直接将第三方库安装到系统Python目录中，要么更有可能会收到您没有权限这样做的错误。您可以以管理员身份强制安装，但Python社区的共识是，您应该只使用系统安装程序将第三方库安装到系统Python目录中。
- en: 'Instead, Python 3.4 (and higher) supplies the `venv` tool. This utility basically
    gives you a mini Python installation called a *virtual environment* in your working
    directory. When you activate the mini Python, commands related to Python will
    work on that directory instead of the system directory. So, when you run `pip`
    or `python`, it won''t touch the system Python at all. Here''s how to use it:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Python 3.4（及更高版本）提供了`venv`工具。该实用程序基本上为您的工作目录提供了一个名为*虚拟环境*的迷你Python安装。当您激活迷你Python时，与Python相关的命令将在该目录上运行，而不是在系统目录上运行。因此，当您运行`pip`或`python`时，它根本不会触及系统Python。以下是如何使用它：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Typically, you'll create a different virtual environment for each Python project
    you work on. You can store your virtual environments anywhere, but I traditionally
    keep mine in the same directory as the rest of my project files (but ignored in
    version control), so first we `cd` into that directory. Then, we run the `venv`
    utility to create a virtual environment named `env`. Finally, we use one of the
    last two lines (depending on the operating system, as indicated in the comments)
    to activate the environment. We'll need to execute this line each time we want
    to use that particular virtualenv, and then use the `deactivate` command when
    we are done working on this project.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会为您工作的每个Python项目创建一个不同的虚拟环境。您可以将虚拟环境存储在任何地方，但我传统上将它们保存在与项目文件相同的目录中（但在版本控制中被忽略），因此我们首先`cd`进入该目录。然后，我们运行`venv`实用程序来创建名为`env`的虚拟环境。最后，我们使用最后两行中的一行（取决于操作系统，如注释中所示）来激活环境。每次想要使用特定的虚拟环境时，我们都需要执行此行，然后在完成该项目的工作时使用`deactivate`命令。
- en: Virtual environments are a terrific way to keep your third-party dependencies
    separate. It is common to have different projects that depend on different versions
    of a particular library (for example, an older website might run on Django 1.8,
    while newer versions run on Django 2.1). Keeping each project in separate virtualenvs
    makes it easy to work in either version of Django. Furthermore, it prevents conflicts
    between system-installed packages and `pip`-installed packages if you try to install
    the same package using different tools.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境是保持第三方依赖项分开的绝佳方式。通常会有不同的项目依赖于特定库的不同版本（例如，旧网站可能在Django 1.8上运行，而更新的版本则在Django
    2.1上运行）。将每个项目放在单独的虚拟环境中可以轻松地在Django的任一版本中工作。此外，如果您尝试使用不同的工具安装相同的软件包，它还可以防止系统安装的软件包和`pip`安装的软件包之间发生冲突。
- en: There are several third-party tools for managing virtual environments effectively.
    Some of these include `pyenv`, `virtualenvwrapper`, and `conda`. My personal preference
    at the time of writing is `pyenv`, but there is no clear winner here. Do a quick
    web search and see what works for you.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种有效管理虚拟环境的第三方工具。其中一些包括`pyenv`、`virtualenvwrapper`和`conda`。我个人在撰写本文时更偏好`pyenv`，但这里没有明显的赢家。快速搜索一下，看看哪种适合您。
- en: Case study
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: To tie it all together, let's build a simple command-line notebook application.
    This is a fairly simple task, so we won't be experimenting with multiple packages.
    We will, however, see common usage of classes, functions, methods, and docstrings.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将所有这些联系在一起，让我们构建一个简单的命令行笔记本应用程序。这是一个相当简单的任务，所以我们不会尝试使用多个软件包。但是，我们将看到类、函数、方法和文档字符串的常见用法。
- en: 'Let''s start with a quick analysis: notes are short memos stored in a notebook.
    Each note should record the day it was written and can have tags added for easy
    querying. It should be possible to modify notes. We also need to be able to search
    for notes. All of these things should be done from the command line.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先进行快速分析：笔记是存储在笔记本中的简短备忘录。每个笔记应记录写入的日期，并可以添加标签以便轻松查询。应该可以修改笔记。我们还需要能够搜索笔记。所有这些事情都应该从命令行完成。
- en: An obvious object is the `Note` object; a less obvious one is a `Notebook` container
    object. Tags and dates also seem to be objects, but we can use dates from Python's
    standard library and a comma-separated string for tags. To avoid complexity, in
    the prototype, we need not define separate classes for these objects.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的对象是`Note`对象；一个不太明显的对象是`Notebook`容器对象。标签和日期似乎也是对象，但我们可以使用Python标准库中的日期和逗号分隔的字符串来表示标签。为了避免复杂性，在原型中，我们不需要为这些对象定义单独的类。
- en: '`Note` objects have attributes for `memo` itself, `tags`, and `creation_date`.
    Each note will also need a unique integer `id` so that users can select them in
    a menu interface. Notes could have a method to modify note content and another
    for tags, or we could just let the notebook access those attributes directly.
    To make searching easier, we should put a `match` method on the `Note` object.
    This method will accept a string and can tell us whether a note matches the string
    without accessing the attributes directly. This way, if we want to modify the
    search parameters (to search tags instead of note contents, for example, or to
    make the search case-insensitive), we only have to do it in one place.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Note`对象具有`memo`本身，`tags`和`creation_date`的属性。每个笔记还需要一个唯一的整数`id`，以便用户可以在菜单界面中选择它们。笔记可以有一个修改笔记内容的方法和另一个标签的方法，或者我们可以让笔记本直接访问这些属性。为了使搜索更容易，我们应该在`Note`对象上放置一个`match`方法。这个方法将接受一个字符串，并且可以告诉我们一个笔记是否与字符串匹配，而不直接访问属性。这样，如果我们想修改搜索参数（例如，搜索标签而不是笔记内容，或者使搜索不区分大小写），我们只需要在一个地方做就可以了。'
- en: The `Notebook` object obviously has the list of notes as an attribute. It will
    also need a search method that returns a list of filtered notes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Notebook`对象显然具有笔记列表作为属性。它还需要一个搜索方法，返回一个经过筛选的笔记列表。'
- en: But how do we interact with these objects? We've specified a command-line app,
    which can mean either that we run the program with different options to add or
    edit commands, or we have some kind of menu that allows us to pick different things
    to do to the notebook. We should try to design it such that either interface is
    supported and future interfaces, such as a GUI toolkit or web-based interface,
    could be added in the future.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何与这些对象交互？我们已经指定了一个命令行应用程序，这可能意味着我们以不同的选项运行程序来添加或编辑命令，或者我们有某种菜单，允许我们选择对笔记本做不同的事情。我们应该尽量设计它，以便支持任一接口，并且未来的接口，比如GUI工具包或基于Web的接口，可以在未来添加。
- en: As a design decision, we'll implement the menu interface now, but will keep
    the command-line options version in mind to ensure we design our `Notebook` class
    with extensibility in mind.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个设计决策，我们现在将实现菜单界面，但会牢记命令行选项版本，以确保我们设计`Notebook`类时考虑到可扩展性。
- en: If we have two command-line interfaces, each interacting with the `Notebook`
    object, then `Notebook` will need some methods for those interfaces to interact
    with. We need to be able to `add` a new note, and `modify` an existing note by
    `id`, in addition to the `search` method we've already discussed. The interfaces
    will also need to be able to list all notes, but they can do that by accessing
    the `notes` list attribute directly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有两个命令行界面，每个界面都与`Notebook`对象交互，那么`Notebook`将需要一些方法供这些界面与之交互。我们需要能够`add`一个新的笔记，并且通过`id`来`modify`一个现有的笔记，除了我们已经讨论过的`search`方法。界面还需要能够列出所有笔记，但它们可以通过直接访问`notes`列表属性来实现。
- en: 'We may be missing a few details, but we have a really good overview of the
    code we need to write. We can summarize all this analysis in a simple class diagram:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会错过一些细节，但我们对需要编写的代码有一个很好的概述。我们可以用一个简单的类图总结所有这些分析：
- en: '![](assets/ade40d12-754a-4428-80a5-64690676d0c8.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ade40d12-754a-4428-80a5-64690676d0c8.png)'
- en: 'Before writing any code, let''s define the folder structure for this project.
    The menu interface should clearly be in its own module, since it will be an executable
    script, and we may have other executable scripts accessing the notebook in the
    future. The `Notebook` and `Note` objects can live together in one module. These
    modules can both exist in the same top-level directory without having to put them
    in a package. An empty `command_option.py` module can help remind us in the future
    that we were planning to add new user interfaces:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何代码之前，让我们为这个项目定义文件夹结构。菜单界面应该明确地放在自己的模块中，因为它将是一个可执行脚本，并且我们将来可能会有其他可执行脚本访问笔记本。`Notebook`和`Note`对象可以放在一个模块中。这些模块可以都存在于同一个顶级目录中，而不必将它们放在一个包中。一个空的`command_option.py`模块可以帮助我们在未来提醒自己，我们计划添加新的用户界面：
- en: '[PRE38]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now let''s see some code. We start by defining the `Note` class, as it seems
    simplest. The following example presents `Note` in its entirety. Docstrings within
    the example explain how it all fits together, demonstrated as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一些代码。我们首先定义`Note`类，因为它似乎最简单。以下示例完整呈现了`Note`。示例中的文档字符串解释了它们如何组合在一起，如下所示：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Before continuing, we should quickly fire up the interactive interpreter and
    test our code so far. Test frequently and often, because things never work the
    way you expect them to. Indeed, when I tested my first version of this example,
    I found out I had forgotten the `self` argument in the `match` function! We''ll
    discuss automated testing in [Chapter 24](55ac5d0e-194c-479b-9a2b-550e4045086b.xhtml),
    *Testing Object-Oriented Programs*. For now, it suffices to check a few things
    using the interpreter:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们应该快速启动交互式解释器并测试我们到目前为止的代码。经常测试，因为事情从来不按照你的期望工作。事实上，当我测试这个例子的第一个版本时，我发现我在`match`函数中忘记了`self`参数！我们将在[第24章](55ac5d0e-194c-479b-9a2b-550e4045086b.xhtml)中讨论自动化测试，*测试面向对象的程序*。目前，只需使用解释器检查一些东西就足够了：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It looks like everything is behaving as expected. Let''s create our notebook
    next:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来一切都表现如预期。让我们接下来创建我们的笔记本：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We''ll clean this up in a minute. First, let''s test it to make sure it works:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快整理一下。首先，让我们测试一下以确保它能正常工作：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It does work. The code is a little messy though; our `modify_tags` and `modify_memo`
    methods are almost identical. That's not good coding practice. Let's see how we
    can improve it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实有效。但是代码有点混乱；我们的`modify_tags`和`modify_memo`方法几乎是相同的。这不是良好的编码实践。让我们看看如何改进它。
- en: 'Both methods are trying to identify the note with a given ID before doing something
    to that note. So, let''s add a method to locate the note with a specific ID. We''ll
    prefix the method name with an underscore to suggest that the method is for internal
    use only, but, of course, our menu interface can access the method if it wants
    to:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都试图在对笔记做某事之前识别具有给定ID的笔记。因此，让我们添加一个方法来定位具有特定ID的笔记。我们将在方法名称前加下划线以表明该方法仅供内部使用，但是，当然，我们的菜单界面可以访问该方法，如果它想要的话：
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This should work for now. Let''s have a look at the menu interface. The interface
    needs to present a menu and allow the user to input choices. Here''s our first
    attempt:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该可以工作了。让我们看看菜单界面。界面需要呈现菜单并允许用户输入选择。这是我们的第一次尝试：
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This code first imports the notebook objects using an absolute import. Relative
    imports wouldn't work because we haven't placed our code inside a package. The
    `Menu` class's `run` method repeatedly displays a menu and responds to choices
    by calling functions on the notebook. This is done using an idiom that is rather
    peculiar to Python; it is a lightweight version of the command pattern that we
    will discuss in [Chapter 22](f09b264b-a4c5-4a1e-9911-8f00ca74144c.xhtml), *Python
    Design Patterns I*. The choices entered by the user are strings. In the menu's
    `__init__` method, we create a dictionary that maps strings to functions on the
    menu object itself. Then, when the user makes a choice, we retrieve the object
    from the dictionary. The `action` variable actually refers to a specific method,
    and is called by appending empty brackets (since none of the methods require parameters)
    to the variable. Of course, the user might have entered an inappropriate choice,
    so we check if the action really exists before calling it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先使用绝对导入导入笔记本对象。相对导入不起作用，因为我们还没有将我们的代码放在一个包内。`Menu`类的`run`方法重复显示菜单，并通过调用笔记本上的函数来响应选择。这是使用Python特有的一种习惯用法；它是命令模式的一个轻量级版本，我们将在[第22章](f09b264b-a4c5-4a1e-9911-8f00ca74144c.xhtml)中讨论，*Python设计模式I*。用户输入的选择是字符串。在菜单的`__init__`方法中，我们创建一个将字符串映射到菜单对象本身的函数的字典。然后，当用户做出选择时，我们从字典中检索对象。`action`变量实际上是指特定的方法，并且通过在变量后附加空括号（因为没有一个方法需要参数）来调用它。当然，用户可能输入了不合适的选择，所以我们在调用之前检查动作是否真的存在。
- en: Each of the various methods request user input and call appropriate methods
    on the `Notebook` object associated with it. For the `search` implementation,
    we notice that after we've filtered the notes, we need to show them to the user,
    so we make the `show_notes` function serve double duty; it accepts an optional
    `notes` parameter. If it's supplied, it displays only the filtered notes, but
    if it's not, it displays all notes. Since the `notes` parameter is optional, `show_notes`
    can still be called with no parameters as an empty menu item.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 各种方法中的每一个都请求用户输入，并调用与之关联的`Notebook`对象上的适当方法。对于`search`实现，我们注意到在过滤了笔记之后，我们需要向用户显示它们，因此我们让`show_notes`函数充当双重职责；它接受一个可选的`notes`参数。如果提供了，它只显示过滤后的笔记，但如果没有提供，它会显示所有笔记。由于`notes`参数是可选的，`show_notes`仍然可以被调用而不带参数作为空菜单项。
- en: 'If we test this code, we''ll find that it fails if we try to modify a note.
    There are two bugs, namely:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们测试这段代码，我们会发现如果我们尝试修改一个笔记，它会失败。有两个错误，即：
- en: The notebook crashes when we enter a note ID that does not exist. We should
    never trust our users to enter correct data!
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们输入一个不存在的笔记ID时，笔记本会崩溃。我们永远不应该相信用户输入正确的数据！
- en: Even if we enter a correct ID, it will crash because the note IDs are integers,
    but our menu is passing a string.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使我们输入了正确的ID，它也会崩溃，因为笔记ID是整数，但我们的菜单传递的是字符串。
- en: 'The latter bug can be solved by modifying the `Notebook` class''s `_find_note`
    method to compare the values using strings instead of the integers stored in the
    note, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 后一个错误可以通过修改`Notebook`类的`_find_note`方法，使用字符串而不是存储在笔记中的整数来比较值来解决，如下所示：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We simply convert both the input (`note_id`) and the note's ID to strings before
    comparing them. We could also convert the input to an integer, but then we'd have
    trouble if the user entered the letter `a` instead of the number `1`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较它们之前，我们只需将输入（`note_id`）和笔记的ID都转换为字符串。我们也可以将输入转换为整数，但是如果用户输入字母`a`而不是数字`1`，那么我们会遇到麻烦。
- en: 'The problem with users entering note IDs that don''t exist can be fixed by
    changing the two `modify` methods on the notebook to check whether `_find_note`
    returned a note or not, like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入不存在的笔记ID的问题可以通过更改笔记本上的两个`modify`方法来解决，检查`_find_note`是否返回了一个笔记，如下所示：
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This method has been updated to return `True` or `False`, depending on whether
    a note has been found. The menu could use this return value to display an error
    if the user entered an invalid note.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法已更新为返回`True`或`False`，取决于是否找到了一个笔记。菜单可以使用这个返回值来显示错误，如果用户输入了一个无效的笔记。
- en: This code is a bit unwieldy. It would look a bit better if it raised an exception
    instead. We'll cover those in [Chapter 18](50624d2e-4cec-4b84-89d0-5198af26590d.xhtml),
    *Expecting the Unexpected*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有点笨拙。如果它引发异常会好一些。我们将在[第18章](50624d2e-4cec-4b84-89d0-5198af26590d.xhtml)中介绍这些，*预料之外*。
- en: Exercises
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Write some object-oriented code. The goal is to use the principles and syntax
    you learned in this chapter to ensure you understand the topics we've covered.
    If you've been working on a Python project, go back over it and see whether there
    are some objects you can create and add properties or methods to. If it's large,
    try dividing it into a few modules or even packages and play with the syntax.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一些面向对象的代码。目标是使用本章学到的原则和语法，确保你理解我们所涵盖的主题。如果你一直在做一个Python项目，回过头来看看，是否有一些对象可以创建，并添加属性或方法。如果项目很大，尝试将其分成几个模块，甚至包，并玩弄语法。
- en: If you don't have such a project, try starting a new one. It doesn't have to
    be something you intend to finish; just stub out some basic design parts. You
    don't need to fully implement everything; often, just a `print("this method will
    do something")` is all you need to get the overall design in place. This is called
    **top-down design**, in which you work out the different interactions and describe
    how they should work before actually implementing what they do. The converse,
    **bottom-up design**, implements details first and then ties them all together.
    Both patterns are useful at different times, but for understanding object-oriented
    principles, a top-down workflow is more suitable.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有这样的项目，尝试开始一个新的项目。它不一定要是你打算完成的东西；只需勾勒出一些基本的设计部分。你不需要完全实现所有内容；通常，只需要`print("这个方法将做一些事情")`就足以让整体设计就位。这被称为**自顶向下设计**，在这种设计中，你先解决不同的交互，并描述它们应该如何工作，然后再实际实现它们所做的事情。相反，**自底向上设计**首先实现细节，然后将它们全部联系在一起。这两种模式在不同的时候都很有用，但对于理解面向对象的原则，自顶向下的工作流更合适。
- en: 'If you''re having trouble coming up with ideas, try writing a to-do application.
    (Hint: it would be similar to the design of the notebook application, but with
    extra date management methods.) It can keep track of things you want to do each
    day, and allow you to mark them as completed.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想法上遇到困难，可以尝试编写一个待办事项应用程序。（提示：它将类似于笔记本应用程序的设计，但具有额外的日期管理方法。）它可以跟踪你每天想做的事情，并允许你标记它们为已完成。
- en: Now try designing a bigger project. As before, it doesn't have to actually do
    anything, but make sure you experiment with the package and module-importing syntax.
    Add some functions in various modules and try importing them from other modules
    and packages. Use relative and absolute imports. See the difference, and try to
    imagine scenarios where you would want to use each one.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试设计一个更大的项目。与之前一样，它不一定要真正做任何事情，但确保你尝试使用包和模块导入语法。在各个模块中添加一些函数，并尝试从其他模块和包中导入它们。使用相对和绝对导入。看看它们之间的区别，并尝试想象你想要使用每种导入方式的场景。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how simple it is to create classes and assign properties
    and methods in Python. Unlike many languages, Python differentiates between a
    constructor and an initializer. It has a relaxed attitude toward access control.
    There are many different levels of scope, including packages, modules, classes,
    and functions. We understood the difference between relative and absolute imports,
    and how to manage third-party packages that don't come with Python.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了在Python中创建类并分配属性和方法是多么简单。与许多语言不同，Python区分构造函数和初始化程序。它对访问控制有一种放松的态度。有许多不同级别的作用域，包括包、模块、类和函数。我们理解了相对导入和绝对导入之间的区别，以及如何管理不随Python一起提供的第三方包。
- en: In the next chapter, we'll learn how to share implementation using inheritance.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用继承来共享实现。

["```py\nclass MySubClass(object): \n    pass \n```", "```py\nclass Contact:\n    all_contacts = []\n\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n        Contact.all_contacts.append(self)\n```", "```py\nclass Supplier(Contact):\n    def order(self, order):\n        print(\n            \"If this were a real system we would send \"\n            f\"'{order}' order to '{self.name}'\"\n        )\n```", "```py\n>>> c = Contact(\"Some Body\", \"somebody@example.net\")\n>>> s = Supplier(\"Sup Plier\", \"supplier@example.net\")\n>>> print(c.name, c.email, s.name, s.email)\nSome Body somebody@example.net Sup Plier supplier@example.net\n>>> c.all_contacts\n[<__main__.Contact object at 0xb7375ecc>,\n <__main__.Supplier object at 0xb7375f8c>]\n>>> c.order(\"I need pliers\")\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nAttributeError: 'Contact' object has no attribute 'order'\n>>> s.order(\"I need pliers\")\nIf this were a real system we would send 'I need pliers' order to\n'Sup Plier '  \n```", "```py\nclass ContactList(list):\n    def search(self, name):\n        \"\"\"Return all contacts that contain the search value\n        in their name.\"\"\"\n        matching_contacts = []\n        for contact in self:\n            if name in contact.name:\n                matching_contacts.append(contact)\n        return matching_contacts\n\nclass Contact:\n    all_contacts = ContactList()\n\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n        Contact.all_contacts.append(self)\n```", "```py\n>>> c1 = Contact(\"John A\", \"johna@example.net\")\n>>> c2 = Contact(\"John B\", \"johnb@example.net\")\n>>> c3 = Contact(\"Jenna C\", \"jennac@example.net\")\n>>> [c.name for c in Contact.all_contacts.search('John')]\n['John A', 'John B']  \n```", "```py\n>>> [] == list()\nTrue  \n```", "```py\n>>> isinstance([], object)\nTrue  \n```", "```py\nclass LongNameDict(dict): \n    def longest_key(self): \n        longest = None \n        for key in self: \n            if not longest or len(key) > len(longest): \n                longest = key \n        return longest \n```", "```py\n>>> longkeys = LongNameDict()\n>>> longkeys['hello'] = 1\n>>> longkeys['longest yet'] = 5\n>>> longkeys['hello2'] = 'world'\n>>> longkeys.longest_key()\n'longest yet'  \n```", "```py\nclass Friend(Contact): \n def __init__(self, name, email, phone):         self.name = name \n        self.email = email \n        self.phone = phone \n```", "```py\nclass Friend(Contact): \n    def __init__(self, name, email, phone): \n super().__init__(name, email) \n        self.phone = phone \n```", "```py\nclass MailSender: \n    def send_mail(self, message): \n        print(\"Sending mail to \" + self.email) \n        # Add e-mail logic here \n```", "```py\nclass EmailableContact(Contact, MailSender): \n    pass \n```", "```py\n>>> e = EmailableContact(\"John Smith\", \"jsmith@example.net\")\n>>> Contact.all_contacts\n[<__main__.EmailableContact object at 0xb7205fac>]\n>>> e.send_mail(\"Hello, test e-mail here\")\nSending mail to jsmith@example.net  \n```", "```py\nclass AddressHolder: \n    def __init__(self, street, city, state, code): \n        self.street = street \n        self.city = city \n        self.state = state \n        self.code = code \n```", "```py\nclass Friend(Contact, AddressHolder): \n    def __init__( \n        self, name, email, phone, street, city, state, code): \n Contact.__init__(self, name, email) \n        AddressHolder.__init__(self, street, city, state, code) \n        self.phone = phone \n```", "```py\nclass BaseClass:\n    num_base_calls = 0\n\n    def call_me(self):\n        print(\"Calling method on Base Class\")\n        self.num_base_calls += 1\n\nclass LeftSubclass(BaseClass):\n    num_left_calls = 0\n\n    def call_me(self):\n        BaseClass.call_me(self)\n        print(\"Calling method on Left Subclass\")\n        self.num_left_calls += 1\n\nclass RightSubclass(BaseClass):\n    num_right_calls = 0\n\n    def call_me(self):\n        BaseClass.call_me(self)\n        print(\"Calling method on Right Subclass\")\n        self.num_right_calls += 1\n\nclass Subclass(LeftSubclass, RightSubclass):\n    num_sub_calls = 0\n\n    def call_me(self):\n LeftSubclass.call_me(self)\n RightSubclass.call_me(self)\n        print(\"Calling method on Subclass\")\n        self.num_sub_calls += 1\n```", "```py\n>>> s = Subclass()\n>>> s.call_me()\nCalling method on Base Class\nCalling method on Left Subclass\nCalling method on Base Class\nCalling method on Right Subclass\nCalling method on Subclass\n>>> print(\n... s.num_sub_calls,\n... s.num_left_calls,\n... s.num_right_calls,\n... s.num_base_calls)\n1 1 1 2  \n```", "```py\nclass BaseClass:\n    num_base_calls = 0\n\n    def call_me(self):\n        print(\"Calling method on Base Class\")\n        self.num_base_calls += 1\n\nclass LeftSubclass(BaseClass):\n    num_left_calls = 0\n\n    def call_me(self):\n super().call_me()\n        print(\"Calling method on Left Subclass\")\n        self.num_left_calls += 1\n\nclass RightSubclass(BaseClass):\n    num_right_calls = 0\n\n    def call_me(self):\n super().call_me()\n        print(\"Calling method on Right Subclass\")\n        self.num_right_calls += 1\n\nclass Subclass(LeftSubclass, RightSubclass):\n    num_sub_calls = 0\n\n    def call_me(self):\n super().call_me()\n        print(\"Calling method on Subclass\")\n        self.num_sub_calls += 1\n```", "```py\n>>> s = Subclass()\n>>> s.call_me()\nCalling method on Base Class\nCalling method on Right Subclass\nCalling method on Left Subclass\nCalling method on Subclass\n>>> print(s.num_sub_calls, s.num_left_calls, s.num_right_calls,\ns.num_base_calls)\n1 1 1 1  \n```", "```py\nContact.__init__(self, name, email) \nAddressHolder.__init__(self, street, city, state, code) \n```", "```py\nclass Contact:\n    all_contacts = []\n\n def __init__(self, name=\"\", email=\"\", **kwargs):\n super().__init__(**kwargs)\n        self.name = name\n        self.email = email\n        self.all_contacts.append(self)\n\nclass AddressHolder:\n def __init__(self, street=\"\", city=\"\", state=\"\", code=\"\", **kwargs):\n super().__init__(**kwargs)\n        self.street = street\n        self.city = city\n        self.state = state\n        self.code = code\n\nclass Friend(Contact, AddressHolder):\n def __init__(self, phone=\"\", **kwargs):\n super().__init__(**kwargs)\n        self.phone = phone\n```", "```py\naudio_file.play() \n```", "```py\nclass AudioFile:\n    def __init__(self, filename):\n        if not filename.endswith(self.ext):\n            raise Exception(\"Invalid file format\")\n\n        self.filename = filename\n\nclass MP3File(AudioFile):\n    ext = \"mp3\"\n\n    def play(self):\n        print(\"playing {} as mp3\".format(self.filename))\n\nclass WavFile(AudioFile):\n    ext = \"wav\"\n\n    def play(self):\n        print(\"playing {} as wav\".format(self.filename))\n\nclass OggFile(AudioFile):\n    ext = \"ogg\"\n\n    def play(self):\n        print(\"playing {} as ogg\".format(self.filename))\n```", "```py\n>>> ogg = OggFile(\"myfile.ogg\")\n>>> ogg.play()\nplaying myfile.ogg as ogg\n>>> mp3 = MP3File(\"myfile.mp3\")\n>>> mp3.play()\nplaying myfile.mp3 as mp3\n>>> not_an_mp3 = MP3File(\"myfile.ogg\")\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\n File \"polymorphic_audio.py\", line 4, in __init__\n raise Exception(\"Invalid file format\")\nException: Invalid file format  \n```", "```py\nclass FlacFile: \n    def __init__(self, filename): \n        if not filename.endswith(\".flac\"): \n            raise Exception(\"Invalid file format\") \n\n        self.filename = filename \n\n    def play(self): \n        print(\"playing {} as flac\".format(self.filename)) \n```", "```py\n>>> from collections import Container \n>>> Container.__abstractmethods__ \nfrozenset(['__contains__']) \n```", "```py\nHelp on method __contains__ in module _abcoll:\n __contains__(self, x) unbound _abcoll.Container method\n```", "```py\nclass OddContainer: \n    def __contains__(self, x): \n        if not isinstance(x, int) or not x % 2: \n            return False \n        return True \n```", "```py\n>>> from collections import Container \n>>> odd_container = OddContainer() \n>>> isinstance(odd_container, Container) \nTrue \n>>> issubclass(OddContainer, Container) \nTrue \n```", "```py\n>>> 1 in odd_container \nTrue \n>>> 2 in odd_container \nFalse \n>>> 3 in odd_container \nTrue \n>>> \"a string\" in odd_container \nFalse \n```", "```py\nimport abc \n\nclass MediaLoader(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def play(self):\n        pass\n\n    @abc.abstractproperty\n    def ext(self):\n        pass\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is MediaLoader:\n            attrs = set(dir(C))\n            if set(cls.__abstractmethods__) <= attrs:\n                return True\n\n        return NotImplemented\n```", "```py\n>>> class Wav(MediaLoader): \n...     pass \n... \n>>> x = Wav() \nTraceback (most recent call last): \n  File \"<stdin>\", line 1, in <module> \nTypeError: Can't instantiate abstract class Wav with abstract methods ext, play \n>>> class Ogg(MediaLoader): \n...     ext = '.ogg' \n...     def play(self): \n...         pass \n... \n>>> o = Ogg() \n```", "```py\n    @classmethod \n```", "```py\n    def __subclasshook__(cls, C): \n```", "```py\n        if cls is MediaLoader: \n```", "```py\n            attrs = set(dir(C)) \n```", "```py\n            if set(cls.__abstractmethods__) <= attrs: \n```", "```py\n                return True \n```", "```py\nreturn NotImplemented \n```", "```py\n>>> class Ogg(): ... ext = '.ogg' ... def play(self): ... print(\"this will play an ogg file\") ... >>> issubclass(Ogg, MediaLoader) True >>> isinstance(Ogg(), MediaLoader) True\n```", "```py\nclass IntroToPython:\n    def lesson(self):\n        return f\"\"\"\n            Hello {self.student}. define two variables,\n            an integer named a with value 1\n            and a string named b with value 'hello'\n\n        \"\"\"\n\n```", "```py\n    def check(self, code):\n        return code == \"a = 1\\nb = 'hello'\"\n```", "```py\nclass Assignment(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def lesson(self, student):\n        pass\n\n    @abc.abstractmethod\n    def check(self, code):\n        pass\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Assignment:\n            attrs = set(dir(C))\n            if set(cls.__abstractmethods__) <= attrs:\n                return True\n\n        return NotImplemented\n```", "```py\nclass Statistics(Assignment):\n    def lesson(self):\n        return (\n            \"Good work so far, \"\n            + self.student\n            + \". Now calculate the average of the numbers \"\n            + \" 1, 5, 18, -3 and assign to a variable named 'avg'\"\n        )\n\n    def check(self, code):\n        import statistics\n\n        code = \"import statistics\\n\" + code\n\n        local_vars = {}\n        global_vars = {}\n        exec(code, global_vars, local_vars)\n\n        return local_vars.get(\"avg\") == statistics.mean([1, 5, 18, -3])\n```", "```py\nclass AssignmentGrader:\n    def __init__(self, student, AssignmentClass):\n        self.assignment = AssignmentClass()\n        self.assignment.student = student\n        self.attempts = 0\n        self.correct_attempts = 0\n\n    def check(self, code):\n        self.attempts += 1\n        result = self.assignment.check(code)\n        if result:\n            self.correct_attempts += 1\n\n        return result\n\n    def lesson(self):\n        return self.assignment.lesson()\n```", "```py\nimport uuid\n\nclass Grader:\n    def __init__(self):\n        self.student_graders = {}\n        self.assignment_classes = {}\n\n    def register(self, assignment_class):\n        if not issubclass(assignment_class, Assignment):\n            raise RuntimeError(\n                \"Your class does not have the right methods\"\n            )\n\n        id = uuid.uuid4()\n        self.assignment_classes[id] = assignment_class\n        return id\n```", "```py\nfrom grader import Grader\nfrom lessons import IntroToPython, Statistics\n\ngrader = Grader()\nitp_id = grader.register(IntroToPython)\n```", "```py\n    def start_assignment(self, student, id):\n        self.student_graders[student] = AssignmentGrader(\n            student, self.assignment_classes[id]\n        )\n```", "```py\n    def get_lesson(self, student):\n        assignment = self.student_graders[student]\n        return assignment.lesson()\n\n    def check_assignment(self, student, code):\n        assignment = self.student_graders[student]\n        return assignment.check(code)\n```", "```py\n\n    def assignment_summary(self, student):\n        grader = self.student_graders[student]\n        return f\"\"\"\n        {student}'s attempts at {grader.assignment.__class__.__name__}:\n\n        attempts: {grader.attempts}\n        correct: {grader.correct_attempts}\n\n        passed: {grader.correct_attempts > 0}\n        \"\"\"\n```", "```py\ngrader = Grader()\nitp_id = grader.register(IntroToPython)\nstat_id = grader.register(Statistics)\n\ngrader.start_assignment(\"Tammy\", itp_id)\nprint(\"Tammy's Lesson:\", grader.get_lesson(\"Tammy\"))\nprint(\n    \"Tammy's check:\",\n    grader.check_assignment(\"Tammy\", \"a = 1 ; b = 'hello'\"),\n)\nprint(\n    \"Tammy's other check:\",\n    grader.check_assignment(\"Tammy\", \"a = 1\\nb = 'hello'\"),\n)\n\nprint(grader.assignment_summary(\"Tammy\"))\n\ngrader.start_assignment(\"Tammy\", stat_id)\nprint(\"Tammy's Lesson:\", grader.get_lesson(\"Tammy\"))\nprint(\"Tammy's check:\", grader.check_assignment(\"Tammy\", \"avg=5.25\"))\nprint(\n    \"Tammy's other check:\",\n    grader.check_assignment(\n        \"Tammy\", \"avg = statistics.mean([1, 5, 18, -3])\"\n    ),\n)\n\nprint(grader.assignment_summary(\"Tammy\"))\n```"]
- en: Python Design Patterns I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python设计模式I
- en: In the previous chapter, we were briefly introduced to design patterns, and
    covered the iterator pattern, a pattern so useful and common that it has been
    abstracted into the core of the programming language itself. In this chapter,
    we'll be reviewing other common patterns, and how they are implemented in Python.
    As with iteration, Python often provides an alternative syntax to make working
    with such problems simpler. We will cover both the *traditional* design, and the
    Python version for these patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了设计模式，并介绍了迭代器模式，这是一个非常有用和常见的模式，以至于它已经被抽象成了编程语言本身的核心。在本章中，我们将回顾其他常见的模式，以及它们在Python中的实现方式。与迭代一样，Python通常提供另一种语法来使处理这些问题更简单。我们将涵盖这些模式的*传统*设计和Python版本。
- en: 'In summary, we''ll see:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们将看到：
- en: Numerous specific patterns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多特定的模式
- en: A canonical implementation of each pattern in Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中每种模式的典型实现
- en: Python syntax to replace certain patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Python语法替换某些模式
- en: The decorator pattern
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: The decorator pattern allows us to *wrap* an object that provides core functionality
    with other objects that alter this functionality. Any object that uses the decorated
    object will interact with it in exactly the same way as if it were undecorated
    (that is, the interface of the decorated object is identical to that of the core
    object).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式允许我们用其他对象包装提供核心功能的对象。使用装饰过的对象的任何对象将以与未装饰的对象完全相同的方式与其交互（即，装饰过的对象的接口与核心对象的接口相同）。
- en: 'There are two primary uses of the decorator pattern:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式的两个主要用途：
- en: Enhancing the response of a component as it sends data to a second component
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强组件发送数据到第二个组件的响应
- en: Supporting multiple optional behaviors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多个可选行为
- en: 'The second option is often a suitable alternative to multiple inheritance.
    We can construct a core object, and then create a decorator wrapping that core.
    Since the decorator object has the same interface as the core object, we can even
    wrap the new object in other decorators. Here''s how it looks in a UML diagram:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项通常是多重继承的一个合适的替代方案。我们可以构建一个核心对象，然后创建一个装饰器包装该核心。由于装饰器对象具有与核心对象相同的接口，我们甚至可以将新对象包装在其他装饰器中。以下是它在UML图中的样子：
- en: '![](assets/8b15b21b-6d6e-49e9-88be-d5907baa55b1.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8b15b21b-6d6e-49e9-88be-d5907baa55b1.png)'
- en: Here, **Core** and all the decorators implement a specific **Interface**. The
    decorators maintain a reference to another instance of that **Interface** via
    composition. When called, the decorator does some added processing before or after
    calling its wrapped interface. The wrapped object may be another decorator, or
    the core functionality. While multiple decorators may wrap each other, the object
    in the *center* of all those decorators provides the core functionality.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**Core**和所有的装饰器都实现了特定的**接口**。装饰器通过组合维护对**接口**的另一个实例的引用。当调用时，装饰器在调用其包装的接口之前或之后进行一些附加处理。被包装的对象可以是另一个装饰器，也可以是核心功能。虽然多个装饰器可以相互包装，但是所有这些装饰器中心的对象提供了核心功能。
- en: A decorator example
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个装饰器的例子
- en: 'Let''s look at an example from network programming. We''ll be using a TCP socket.
    The `socket.send()` method takes a string of input bytes and outputs them to the
    receiving socket at the other end. There are plenty of libraries that accept sockets
    and access this function to send data on the stream. Let''s create such an object;
    it will be an interactive shell that waits for a connection from a client and
    then prompts the user for a string response:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个来自网络编程的例子。我们将使用TCP套接字。`socket.send()`方法接受一串输入字节并将它们输出到另一端的接收套接字。有很多库可以接受套接字并访问这个函数来在流上发送数据。让我们创建这样一个对象；它将是一个交互式shell，等待客户端的连接，然后提示用户输入一个字符串响应：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `respond` function accepts a `socket` parameter and prompts for data to
    be sent as a reply, then sends it. To use it, we construct a server socket and
    tell it to listen on port `2401` (I picked the port randomly) on the local computer.
    When a client connects, it calls the `respond` function, which requests data interactively
    and responds appropriately. The important thing to notice is that the `respond`
    function only cares about two methods of the socket interface: `send` and `close`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`respond`函数接受一个`socket`参数并提示要发送的数据作为回复，然后发送它。要使用它，我们构建一个服务器套接字，并告诉它在本地计算机上的端口`2401`上进行监听（我随机选择了端口）。当客户端连接时，它调用`respond`函数，该函数交互式地请求数据并做出适当的响应。需要注意的重要事情是，`respond`函数只关心套接字接口的两种方法：`send`和`close`。'
- en: 'To test this, we can write a very simple client that connects to the same port
    and outputs the response before exiting:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们可以编写一个非常简单的客户端，连接到相同的端口并在退出之前输出响应：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To use these programs, follow these steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些程序，请按照以下步骤进行：
- en: Start the server in one Terminal.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个终端中启动服务器。
- en: Open a second Terminal window and run the client.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开第二个终端窗口并运行客户端。
- en: 'At the Enter a value: prompt in the server window, type a value and press *Enter*.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器窗口的“输入值：”提示处，输入一个值并按*Enter*键。
- en: The client will receive what you typed, print it to the console, and exit. Run
    the client a second time; the server will prompt for a second value.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端将接收您输入的内容，将其打印到控制台上，并退出。再次运行客户端；服务器将提示输入第二个值。
- en: 'The result will look something like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将看起来像这样：
- en: '![](assets/eb9bc3a4-1442-4fb6-b56c-44f9a298c86a.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/eb9bc3a4-1442-4fb6-b56c-44f9a298c86a.png)'
- en: Now, looking back at our server code, we see two sections. The `respond` function
    sends data into a `socket` object. The remaining script is responsible for creating
    that `socket` object. We'll create a pair of decorators that customize the socket
    behavior without having to extend or modify the socket itself.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回顾我们的服务器代码，我们看到了两个部分。`respond`函数将数据发送到一个`socket`对象中。剩下的脚本负责创建该`socket`对象。我们将创建一对装饰器，定制套接字的行为，而无需扩展或修改套接字本身。
- en: 'Let''s start with a *logging* decorator. This object outputs any data being
    sent to the server''s console before it sends it to the client:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个*logging*装饰器开始。这个对象在将数据发送到客户端之前，将任何数据输出到服务器的控制台上：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This class decorates a `socket` object and presents the `send` and `close` interface
    to client sockets. A better decorator would also implement (and possibly customize)
    all of the remaining `socket` methods. It should properly implement all of the
    arguments to `send`, (which actually accepts an optional flags argument) as well,
    but let's keep our example simple. Whenever `send` is called on this object, it
    logs the output to the screen before sending data to the client using the original
    socket.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类装饰了一个`socket`对象，并向客户端socket呈现`send`和`close`接口。一个更好的装饰器还应该实现（可能定制）所有剩余的`socket`方法。它还应该正确地实现`send`的所有参数（实际上还接受一个可选的flags参数），但让我们保持我们的例子简单。每当在这个对象上调用`send`时，它都会在将数据发送到客户端之前将输出记录到屏幕上，使用原始socket。
- en: 'We only have to change one line in our original code to use this decorator.
    Instead of calling `respond` with the socket, we call it with a decorated socket:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要改变原始代码中的一行，就可以使用这个装饰器。我们不再用socket调用`respond`，而是用一个装饰过的socket调用它：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While that's quite simple, we have to ask ourselves why we didn't just extend
    the `socket` class and override the `send` method. We could call `super().send`
    to do the actual sending, after we logged it. There is nothing wrong with this
    design either.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很简单，但我们必须问自己，为什么我们不只是扩展`socket`类并覆盖`send`方法。我们可以调用`super().send`在记录后进行实际发送。这种设计也没有问题。
- en: 'When faced with a choice between decorators and inheritance, we should only
    use decorators if we need to modify the object dynamically, according to some
    condition. For example, we may only want to enable the logging decorator if the
    server is currently in debugging mode. Decorators also beat multiple inheritance
    when we have more than one optional behavior. As an example, we can write a second
    decorator that compresses data using `gzip` compression whenever `send` is called:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当面临装饰器和继承之间的选择时，只有在我们需要根据某些条件动态修改对象时，才应该使用装饰器。例如，我们可能只想在服务器当前处于调试模式时启用日志装饰器。当我们有多个可选行为时，装饰器也比多重继承更胜一筹。例如，我们可以编写第二个装饰器，每当调用`send`时，就使用`gzip`压缩数据：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `send` method in this version compresses the incoming data before sending
    it on to the client.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，`send`方法在发送到客户端之前压缩传入的数据。
- en: 'Now that we have these two decorators, we can write code that dynamically switches
    between them when responding. This example is not complete, but it illustrates
    the logic we might follow to mix and match decorators:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这两个装饰器，我们可以编写代码，在响应时动态地在它们之间切换。这个例子并不完整，但它说明了我们可能遵循的逻辑来混合和匹配装饰器：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code checks a hypothetical configuration variable named `log_send`. If
    it's enabled, it wraps the socket in a `LogSocket` decorator. Similarly, it checks
    whether the client that has connected is in a list of addresses known to accept
    compressed content. If so, it wraps the client in a `GzipSocket` decorator. Notice
    that none, either, or both of the decorators may be enabled, depending on the
    configuration and connecting client. Try writing this using multiple inheritance
    and see how confused you get!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检查一个名为`log_send`的假设配置变量。如果启用了，它会将socket包装在`LogSocket`装饰器中。类似地，它检查连接的客户端是否在已知接受压缩内容的地址列表中。如果是，它会将客户端包装在`GzipSocket`装饰器中。请注意，这两个装饰器中的任何一个、两个或全部都可能被启用，这取决于配置和连接的客户端。尝试使用多重继承来编写这个，并看看你会有多困惑！
- en: Decorators in Python
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的装饰器
- en: The decorator pattern is useful in Python, but there are other options. For
    example, we may be able to use monkey-patching (for example, `socket.socket.send
    = log_send`) to get a similar effect. Single inheritance, where the *optional* calculations
    are done in one large method, could be an option, and multiple inheritance should
    not be written off just because it's not suitable for the specific example seen
    previously.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式在Python中很有用，但也有其他选择。例如，我们可以使用monkey-patching（例如，`socket.socket.send = log_send`）来获得类似的效果。单继承，其中*可选*的计算在一个大方法中完成，可能是一个选择，而多继承不应该被写入，只是因为它不适用于先前看到的特定示例。
- en: In Python, it is very common to use this pattern on functions. As we saw in
    a previous chapter, functions are objects too. In fact, function decoration is
    so common that Python provides a special syntax to make it easy to apply such
    decorators to functions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，很常见在函数上使用这种模式。正如我们在前一章中看到的，函数也是对象。事实上，函数装饰是如此常见，以至于Python提供了一种特殊的语法，使得将这种装饰器应用到函数变得容易。
- en: 'For example, we can look at the logging example in a more general way. Instead
    of logging, only send calls on sockets; we may find it helpful to log all calls
    to certain functions or methods. The following example implements a decorator
    that does just this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以更一般地看待日志示例。我们可能会发现，不仅仅是在socket上发送调用时记录，记录所有对某些函数或方法的调用可能会有所帮助。以下示例实现了一个装饰器，正是这样做的：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This decorator function is very similar to the example we explored earlier;
    in those cases, the decorator took a socket-like object and created a socket-like
    object. This time, our decorator takes a function object and returns a new function
    object. This code comprises three separate tasks:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器函数与我们之前探讨的示例非常相似；在这些情况下，装饰器接受一个类似socket的对象并创建一个类似socket的对象。这次，我们的装饰器接受一个函数对象并返回一个新的函数对象。这段代码包括三个单独的任务：
- en: A function, `log_calls`, that accepts another function
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数，`log_calls`，接受另一个函数
- en: This function defines (internally) a new function, named `wrapper`, that does
    some extra work before calling the original function
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数定义了（内部）一个名为`wrapper`的新函数，在调用原始函数之前做一些额外的工作
- en: The inner function is returned from the outer function
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部函数从外部函数返回
- en: Three sample functions demonstrate the decorator in use. The third one includes
    a `sleep` call to demonstrate the timing test. We pass each function into the
    decorator, which returns a new function. We assign this new function to the original
    variable name, effectively replacing the original function with a decorated one.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 三个示例函数演示了装饰器的使用。第三个函数包括一个`sleep`调用来演示定时测试。我们将每个函数传递给装饰器，它返回一个新函数。我们将这个新函数赋给原始变量名，有效地用装饰后的函数替换了原始函数。
- en: This syntax allows us to build up decorated function objects dynamically, just
    as we did with the socket example. If we don't replace the name, we can even keep
    decorated and non-decorated versions for different situations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法允许我们动态构建装饰函数对象，就像我们在套接字示例中所做的那样。如果我们不替换名称，我们甚至可以为不同情况保留装饰和非装饰版本。
- en: Typically, these decorators are general modifications that are applied permanently
    to different functions. In this situation, Python supports a special syntax to
    apply the decorator at the time the function is defined. We've already seen this
    syntax in a few places; now, let's understand how it works.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些装饰器是应用于不同函数的永久性通用修改。在这种情况下，Python支持一种特殊的语法，在函数定义时应用装饰器。我们已经在一些地方看到了这种语法；现在，让我们了解一下它是如何工作的。
- en: 'Instead of applying the decorator function after the method definition, we
    can use the `@decorator` syntax to do it all at once:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`@decorator`语法一次完成所有操作，而不是在方法定义之后应用装饰器函数：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The primary benefit of this syntax is that we can easily see that the function
    has been decorated whenever we read the function definition. If the decorator
    is applied later, someone reading the code may miss that the function has been
    altered at all. Answering a question like, *Why is my program logging function
    calls to the console?* can become much more difficult! However, the syntax can
    only be applied to functions we define, since we don't have access to the source
    code of other modules. If we need to decorate functions that are part of somebody
    else's third-party library, we have to use the earlier syntax.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法的主要好处是，我们可以很容易地看到在阅读函数定义时函数已经被装饰。如果装饰器是后来应用的，那么阅读代码的人可能会错过函数已经被修改的事实。回答类似“为什么我的程序将函数调用记录到控制台？”这样的问题可能会变得更加困难！但是，这种语法只能应用于我们定义的函数，因为我们无法访问其他模块的源代码。如果我们需要装饰第三方库中的函数，我们必须使用之前的语法。
- en: There is more to the decorator syntax than we've seen here. We don't have room
    to cover the advanced topics here, so check the Python reference manual or other
    tutorials for more information. Decorators can be created as callable objects,
    not just functions that return functions. Classes can also be decorated; in that
    case, the decorator returns a new class instead of a new function. Finally, decorators
    can take arguments to customize them on a per-function basis.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器语法还有更多我们在这里没有看到的内容。我们没有足够的空间来涵盖这里的高级主题，所以请查看Python参考手册或其他教程以获取更多信息。装饰器可以被创建为可调用对象，而不仅仅是返回函数的函数。类也可以被装饰；在这种情况下，装饰器返回一个新类，而不是一个新函数。最后，装饰器可以接受参数，以便根据每个函数的情况进行自定义。
- en: The observer pattern
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The observer pattern is useful for state monitoring and event handling situations.
    This pattern allows a given object to be monitored by an unknown and dynamic group
    of *observer* objects.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式对于状态监控和事件处理非常有用。这种模式允许一个给定的对象被未知和动态的*观察者*对象监视。
- en: Whenever a value on the core object changes, it lets all the observer objects
    know that a change has occurred, by calling an `update()` method. Each observer
    may be responsible for different tasks whenever the core object changes; the core
    object doesn't know or care what those tasks are, and the observers don't typically
    know or care what other observers are doing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每当核心对象上的值发生变化时，它都会通过调用`update()`方法来通知所有观察者对象发生了变化。每个观察者在核心对象发生变化时可能负责不同的任务；核心对象不知道也不关心这些任务是什么，观察者通常也不知道也不关心其他观察者在做什么。
- en: 'Here it is in UML:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它在UML中的表示：
- en: '![](assets/e85ff8d1-0a84-4509-baf1-cafe21b4f31e.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e85ff8d1-0a84-4509-baf1-cafe21b4f31e.png)'
- en: An observer example
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式示例
- en: 'The observer pattern might be useful in a redundant backup system. We can write
    a core object that maintains certain values, and then have one or more observers
    create serialized copies of that object. These copies might be stored in a database,
    on a remote host, or in a local file, for example. Let''s implement the core object
    using properties:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式可能在冗余备份系统中很有用。我们可以编写一个维护特定值的核心对象，然后有一个或多个观察者创建该对象的序列化副本。例如，这些副本可以存储在数据库中，存储在远程主机上，或者存储在本地文件中。让我们使用属性来实现核心对象：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This object has two properties that, when set, call the `_update_observers`
    method on itself. All this method does is loop over any registered observers and
    let each know that something has changed. In this case, we call the observer object
    directly; the object will have to implement `__call__` to process the update.
    This would not be possible in many object-oriented programming languages, but
    it's a useful shortcut in Python that can help make our code more readable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象有两个属性，当设置时，会调用自身的`_update_observers`方法。这个方法所做的就是循环遍历任何注册的观察者，并让每个观察者知道发生了一些变化。在这种情况下，我们直接调用观察者对象；对象将必须实现`__call__`来处理更新。这在许多面向对象的编程语言中是不可能的，但在Python中是一个有用的快捷方式，可以帮助我们使我们的代码更易读。
- en: 'Now let''s implement a simple observer object; this one will just print out
    some state to the console:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现一个简单的观察者对象；这个对象只会将一些状态打印到控制台上：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There''s nothing terribly exciting here; the observed object is set up in the
    initializer, and when the observer is called, we do *something*. We can test the
    observer in an interactive console:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别激动人心的东西；观察到的对象在初始化程序中设置，当观察者被调用时，我们会执行*某些操作*。我们可以在交互式控制台中测试观察者：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After attaching the observer to the `Inventory` object, whenever we change
    one of the two observed properties, the observer is called and its action is invoked.
    We can even add two different observer instances:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将观察者附加到`Inventory`对象后，每当我们更改两个观察属性中的一个时，观察者都会被调用并执行其操作。我们甚至可以添加两个不同的观察者实例：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This time when we change the product, there are two sets of output, one for
    each observer. The key idea here is that we can easily add totally different types
    of observers that back up the data in a file, database, or internet application
    at the same time.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这次当我们改变产品时，有两套输出，每个观察者一个。这里的关键思想是我们可以轻松地添加完全不同类型的观察者，同时备份数据到文件、数据库或互联网应用程序。
- en: The observer pattern detaches the code being observed from the code doing the
    observing. If we were not using this pattern, we would have had to put code in
    each of the properties to handle the different cases that might come up; logging
    to the console, updating a database or file, and so on. The code for each of these
    tasks would all be mixed in with the observed object. Maintaining it would be
    a nightmare, and adding new monitoring functionality at a later date would be
    painful.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式将被观察的代码与观察的代码分离。如果我们不使用这种模式，我们将不得不在每个属性中放置代码来处理可能出现的不同情况；记录到控制台、更新数据库或文件等。所有这些任务的代码都将与被观察的对象混在一起。维护它将是一场噩梦，并且在以后添加新的监视功能将是痛苦的。
- en: The strategy pattern
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式
- en: The strategy pattern is a common demonstration of abstraction in object-oriented
    programming. The pattern implements different solutions to a single problem, each
    in a different object. The client code can then choose the most appropriate implementation
    dynamically at runtime.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式是面向对象编程中抽象的常见演示。该模式实现了单个问题的不同解决方案，每个解决方案都在不同的对象中。客户端代码可以在运行时动态选择最合适的实现。
- en: 'Typically, different algorithms have different trade-offs; one might be faster
    than another, but uses a lot more memory, while a third algorithm may be most
    suitable when multiple CPUs are present or a distributed system is provided. Here
    is the strategy pattern in UML:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，不同的算法有不同的权衡；一个可能比另一个更快，但使用了更多的内存，而第三个算法可能在多个CPU存在或提供分布式系统时最合适。以下是UML中的策略模式：
- en: '![](assets/6fd266d3-d237-415d-9b9c-aec09ee33129.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6fd266d3-d237-415d-9b9c-aec09ee33129.png)'
- en: The **User** code connecting to the strategy pattern simply needs to know that
    it is dealing with the **Abstraction** interface. The actual implementation chosen
    performs the same task, but in different ways; either way, the interface is identical.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户**连接到策略模式的代码只需要知道它正在处理**抽象**接口。所选择的实际实现以不同的方式执行相同的任务；无论如何，接口都是相同的。'
- en: A strategy example
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略示例
- en: The canonical example of the strategy pattern is sort routines; over the years,
    numerous algorithms have been invented for sorting a collection of objects; quick
    sort, merge sort, and heap sort are all fast sort algorithms with different features,
    each useful in its own right, depending on the size and type of inputs, how out
    of order they are, and the requirements of the system.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式的典型示例是排序例程；多年来，已经发明了许多用于对对象集合进行排序的算法；快速排序、归并排序和堆排序都是快速排序算法，具有不同的特性，每种都有其自身的用途，取决于输入的大小和类型，它们的顺序有多乱，以及系统的要求。
- en: 'If we have client code that needs to sort a collection, we could pass it to
    an object with a `sort()` method. This object may be a `QuickSorter` or `MergeSorter`
    object, but the result will be the same in either case: a sorted list. The strategy
    used to do the sorting is abstracted from the calling code, making it modular
    and replaceable.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有需要对集合进行排序的客户端代码，我们可以将其传递给具有`sort()`方法的对象。这个对象可以是`QuickSorter`或`MergeSorter`对象，但结果在任何情况下都是相同的：一个排序好的列表。用于进行排序的策略被抽象出来，使其模块化和可替换。
- en: Of course, in Python, we typically just call the `sorted` function or `list.sort`
    method and trust that it will do the sorting in a near-optimal fashion. So, we
    really need to look at a better example.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在Python中，我们通常只是调用`sorted`函数或`list.sort`方法，并相信它会以接近最佳的方式进行排序。因此，我们确实需要看一个更好的例子。
- en: Let's consider a desktop wallpaper manager. When an image is displayed on a
    desktop background, it can be adjusted to the screen size in different ways. For
    example, assuming the image is smaller than the screen, it can be tiled across
    the screen, centered on it, or scaled to fit.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个桌面壁纸管理器。当图像显示在桌面背景上时，可以以不同的方式调整到屏幕大小。例如，假设图像比屏幕小，可以在屏幕上平铺、居中或缩放以适应。
- en: There are other, more complicated, strategies that can be used as well, such
    as scaling to the maximum height or width, combining it with a solid, semi-transparent,
    or gradient background color, or other manipulations. While we may want to add
    these strategies later, let's start with the basic ones.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他更复杂的策略可以使用，例如缩放到最大高度或宽度，将其与实心、半透明或渐变背景颜色相结合，或其他操作。虽然我们可能希望稍后添加这些策略，但让我们从基本的开始。
- en: 'Our strategy objects take two inputs; the image to be displayed, and a tuple
    of the width and height of the screen. They each return a new image the size of
    the screen, with the image manipulated to fit according to the given strategy.
    You''ll need to install the `pillow` module with `pip3 install pillow` for this
    example to work:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的策略对象需要两个输入；要显示的图像和屏幕宽度和高度的元组。它们每个都返回一个新的屏幕大小的图像，图像根据给定的策略进行调整。您需要使用`pip3
    install pillow`安装`pillow`模块才能使此示例工作：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we have three strategies, each using `PIL` to perform their task. Individual
    strategies have a `make_background` method that accepts the same set of parameters.
    Once selected, the appropriate strategy can be called to create a correctly sized
    version of the desktop image. `TiledStrategy` loops over the number of input images
    that would fit in the width and height of the image and copies it into each location,
    repeatedly. `CenteredStrategy` figures out how much space needs to be left on
    the four edges of the image to center it. `ScaledStrategy` forces the image to
    the output size (ignoring aspect ratio).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有三种策略，每种策略都使用`PIL`来执行它们的任务。各个策略都有一个`make_background`方法，接受相同的参数集。一旦选择，就可以调用适当的策略来创建正确大小的桌面图像。`TiledStrategy`循环遍历可以适应图像宽度和高度的输入图像数量，并将其重复复制到每个位置。`CenteredStrategy`计算出需要在图像的四个边缘留下多少空间来使其居中。`ScaledStrategy`将图像强制缩放到输出大小（忽略纵横比）。
- en: Consider how switching between these options would be implemented without the
    strategy pattern. We'd need to put all the code inside one great big method and
    use an awkward `if` statement to select the expected one. Every time we wanted
    to add a new strategy, we'd have to make the method even more ungainly.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下，如果没有策略模式，如何在这些选项之间进行切换的实现。我们需要把所有的代码放在一个很大的方法中，并使用一个笨拙的`if`语句来选择预期的选项。每次我们想要添加一个新的策略，我们都必须使方法变得更加笨拙。
- en: Strategy in Python
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的策略
- en: The preceding canonical implementation of the strategy pattern, while very common
    in most object-oriented libraries, is rarely seen in Python programming.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式的前面的经典实现，在大多数面向对象的库中非常常见，但在Python编程中很少见。
- en: These classes each represent objects that do nothing but provide a single function.
    We could just as easily call that function `__call__` and make the object callable
    directly. Since there is no other data associated with the object, we need do
    no more than create a set of top-level functions and pass them around as our strategies
    instead.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类分别代表什么都不做，只提供一个函数的对象。我们可以轻松地将该函数称为`__call__`，并直接使对象可调用。由于对象没有与之关联的其他数据，我们只需要创建一组顶层函数并将它们作为我们的策略传递。
- en: Opponents of design pattern philosophy will therefore say, *because Python has
    first-class functions, the strategy pattern is unnecessary*. In truth, Python's
    first-class functions allow us to implement the strategy pattern in a more straightforward
    way. Knowing the pattern exists can still help us choose a correct design for
    our program, but implement it using a more readable syntax. The strategy pattern,
    or a top-level function implementation of it, should be used when we need to allow
    client code or the end user to select from multiple implementations of the same
    interface.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，设计模式哲学的反对者会说，*因为Python具有一流函数，策略模式是不必要的*。事实上，Python的一流函数使我们能够以更直接的方式实现策略模式。知道这种模式的存在仍然可以帮助我们选择程序的正确设计，但是使用更可读的语法来实现它。当我们需要允许客户端代码或最终用户从相同接口的多个实现中进行选择时，应该使用策略模式或其顶层函数实现。
- en: The state pattern
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态模式
- en: 'The state pattern is structurally similar to the strategy pattern, but its
    intent and purpose are very different. The goal of the state pattern is to represent
    state-transition systems: systems where it is obvious that an object can be in
    a specific state, and that certain activities may drive it to a different state.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式在结构上类似于策略模式，但其意图和目的非常不同。状态模式的目标是表示状态转换系统：在这些系统中，很明显对象可以处于特定状态，并且某些活动可能会将其驱动到不同的状态。
- en: To make this work, we need a manager, or context class that provides an interface
    for switching states. Internally, this class contains a pointer to the current
    state. Each state knows what other states it is allowed to be in and will transition
    to those states depending on actions invoked upon it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，我们需要一个管理器或上下文类，提供切换状态的接口。在内部，这个类包含对当前状态的指针。每个状态都知道它被允许处于什么其他状态，并且将根据在其上调用的操作而转换到这些状态。
- en: 'So, we have two types of classes: the context class and multiple state classes.
    The context class maintains the current state, and forwards actions to the state
    classes. The state classes are typically hidden from any other objects that are
    calling the context; it acts like a black box that happens to perform state management
    internally. Here''s how it looks in UML:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有两种类型的类：上下文类和多个状态类。上下文类维护当前状态，并将操作转发给状态类。状态类通常对于调用上下文的任何其他对象都是隐藏的；它就像一个黑匣子，恰好在内部执行状态管理。在UML中的样子如下：
- en: '![](assets/fbbbb670-9479-419e-8a82-8c1a99273eba.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fbbbb670-9479-419e-8a82-8c1a99273eba.png)'
- en: A state example
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态示例
- en: 'To illustrate the state pattern, let''s build an XML parsing tool. The context
    class will be the parser itself. It will take a string as input and place the
    tool in an initial parsing state. The various parsing states will eat characters,
    looking for a specific value, and when that value is found, change to a different
    state. The goal is to create a tree of node objects for each tag and its contents.
    To keep things manageable, we''ll parse only a subset of XML – tags and tag names.
    We won''t be able to handle attributes on tags. It will parse text content of
    tags, but won''t attempt to parse *mixed* content, which has tags inside of text.
    Here is an example *simplified XML* file that we''ll be able to parse:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明状态模式，让我们构建一个XML解析工具。上下文类将是解析器本身。它将以字符串作为输入，并将工具置于初始解析状态。各种解析状态将吃掉字符，寻找特定的值，当找到该值时，转换到不同的状态。目标是为每个标签及其内容创建一个节点对象树。为了使事情更容易管理，我们只解析XML的一个子集
    - 标签和标签名称。我们将无法处理标签上的属性。它将解析标签的文本内容，但不会尝试解析*混合*内容，其中包含文本内的标签。这是一个我们将能够解析的*简化XML*文件的示例：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Before we look at the states and the parser, let''s consider the output of
    this program. We know we want a tree of `Node` objects, but what does a `Node`
    look like? It will clearly need to know the name of the tag it is parsing, and
    since it''s a tree, it should probably maintain a pointer to the parent node and
    a list of the node''s children in order. Some nodes have a text value, but not
    all of them. Let''s look at this `Node` class first:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看状态和解析器之前，让我们考虑一下这个程序的输出。我们知道我们想要一个`Node`对象的树，但`Node`是什么样子呢？它显然需要知道它正在解析的标签的名称，而且由于它是一棵树，它可能应该保持对父节点的指针和按顺序列出节点的子节点的列表。有些节点有文本值，但不是所有节点都有。让我们首先看看这个`Node`类：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This class sets default attribute values upon initialization. The `__str__`
    method is supplied to help visualize the tree structure when we're finished.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类在初始化时设置默认属性值。提供`__str__`方法来帮助在完成时可视化树结构。
- en: Now, looking at the example document, we need to consider what states our parser
    can be in. Clearly, it's going to start in a state where no nodes have yet been
    processed. We'll need a state for processing opening tags and closing tags. And
    when we're inside a tag with text contents, we'll have to process that as a separate
    state, too.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看示例文档，我们需要考虑我们的解析器可以处于哪些状态。显然，它将开始于尚未处理任何节点的状态。我们需要一个用于处理开放标签和关闭标签的状态。当我们在具有文本内容的标签内部时，我们还需要将其处理为单独的状态。
- en: 'Switching states can be tricky; how do we know if the next node is an opening
    tag, a closing tag, or a text node? We could put a little logic in each state
    to work this out, but it actually makes more sense to create a new state whose
    sole purpose is figuring out which state we''ll be switching to next. If we call
    this transition state **ChildNode**, we end up with the following states:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 状态转换可能会很棘手；我们如何知道下一个节点是开放标签、关闭标签还是文本节点？我们可以在每个状态中放入一些逻辑来解决这个问题，但实际上创建一个唯一目的是确定下一个状态的新状态更有意义。如果我们将这个过渡状态称为**ChildNode**，我们最终得到以下状态：
- en: '`FirstTag`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FirstTag`'
- en: '`ChildNode`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChildNode`'
- en: '`OpenTag`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenTag`'
- en: '`CloseTag`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CloseTag`'
- en: '`Text`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Text`'
- en: 'The **FirstTag** state will switch to **ChildNode**, which is responsible for
    deciding which of the other three states to switch to; when those states are finished,
    they''ll switch back to **ChildNode**. The following state-transition diagram
    shows the available state changes:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**FirstTag**状态将切换到**ChildNode**，它负责决定要切换到其他三个状态中的哪一个；当这些状态完成时，它们将切换回**ChildNode**。以下状态转换图显示了可用的状态变化：'
- en: '![](assets/42bbeb78-0f77-46d7-be78-a15970c6a3bd.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/42bbeb78-0f77-46d7-be78-a15970c6a3bd.png)'
- en: 'The states are responsible for taking *what''s left of the string*, processing
    as much of it as they know what to do with, and then telling the parser to take
    care of the rest of it. Let''s construct the `Parser` class first:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 状态负责获取*字符串的剩余部分*，处理尽可能多的内容，然后告诉解析器处理其余部分。让我们首先构建`Parser`类：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The initializer sets up a few variables on the class that the individual states
    will access. The `parse_string` instance variable is the text that we are trying
    to parse. The `root` node is the *top* node in the XML structure. The `current_node`
    instance variable is the one that we are currently adding children to.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化程序在类上设置了一些变量，这些变量将由各个状态访问。`parse_string`实例变量是我们试图解析的文本。`root`节点是XML结构中的*顶部*节点。`current_node`实例变量是我们当前正在向其添加子节点的节点。
- en: The important feature of this parser is the `process` method, which accepts
    the remaining string, and passes it off to the current state. The parser (the
    `self` argument) is also passed into the state's process method so that the state
    can manipulate it. The state is expected to return the remainder of the unparsed
    string when it is finished processing. The parser then recursively calls the `process`
    method on this remaining string to construct the rest of the tree.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解析器的重要特性是`process`方法，它接受剩余的字符串，并将其传递给当前状态。解析器（`self`参数）也被传递到状态的`process`方法中，以便状态可以操作它。当状态完成处理时，预期状态将返回未解析字符串的剩余部分。然后解析器递归调用这个剩余字符串上的`process`方法来构造树的其余部分。
- en: 'Now let''s have a look at the `FirstTag` state:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`FirstTag`状态：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This state finds the index (the `i_` stands for index) of the opening and closing
    angle brackets on the first tag. You may think this state is unnecessary, since
    XML requires that there be no text before an opening tag. However, there may be
    whitespace that needs to be consumed; this is why we search for the opening angle
    bracket instead of assuming it is the first character in the document.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个状态找到了第一个标签的开放和关闭尖括号的索引（`i_`代表索引）。您可能认为这个状态是多余的，因为XML要求在开放标签之前没有文本。然而，可能需要消耗空白字符；这就是为什么我们搜索开放尖括号而不是假设它是文档中的第一个字符。
- en: Note that this code is assuming a valid input file. A proper implementation
    would be rigorously testing for invalid input, and would attempt to recover or
    display an extremely descriptive error message.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此代码假定输入文件有效。一个正确的实现将严格测试无效输入，并尝试恢复或显示极具描述性的错误消息。
- en: The method extracts the name of the tag and assigns it to the root node of the
    parser. It also assigns it to `current_node`, since that's the one we'll be adding
    children to next.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法提取标签的名称并将其分配给解析器的根节点。它还将其分配给`current_node`，因为那是我们接下来要添加子节点的节点。
- en: 'Then comes the important part: the method changes the current state on the
    parser object to a `ChildNode` state. It then returns the remainder of the string
    (after the opening tag) to allow it to be processed.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是重要的部分：该方法将解析器对象上的当前状态更改为`ChildNode`状态。然后返回字符串的剩余部分（在开放标签之后）以允许其被处理。
- en: 'The `ChildNode` state, which seems quite complicated, turns out to require
    nothing but a simple conditional:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来相当复杂的`ChildNode`状态实际上只需要一个简单的条件：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `strip()` call removes whitespace from the string. Then the parser determines
    if the next item is an opening or closing tag, or a string of text. Depending
    on which possibility occurs, it sets the parser to a particular state, and then
    tells it to parse the remainder of the string.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`strip()`调用从字符串中删除空白。然后解析器确定下一个项是开放标签、关闭标签还是文本字符串。根据发生的可能性，它将解析器设置为特定状态，然后告诉它解析字符串的其余部分。'
- en: 'The `OpenTag` state is similar to the `FirstTag` state, except that it adds
    the newly created node to the previous `current_node` object''s `children` and
    sets it as the new `current_node`. It places the processor back in the `ChildNode`
    state before continuing:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenTag`状态类似于`FirstTag`状态，只是它将新创建的节点添加到先前的`current_node`对象的`children`中，并将其设置为新的`current_node`。然后继续将处理器放回`ChildNode`状态：'
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `CloseTag` state basically does the opposite; it sets the parser''s `current_node`
    back to the parent node so any further children in the outside tag can be added
    to it:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`CloseTag`状态基本上做相反的事情；它将解析器的`current_node`设置回父节点，以便在外部标签中添加任何进一步的子节点：'
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The two `assert` statements help ensure that the parse strings are consistent.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`assert`语句有助于确保解析字符串是一致的。
- en: 'Finally, the `TextNode` state very simply extracts the text before the next
    close tag and sets it as a value on the current node:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`TextNode`状态非常简单地提取下一个关闭标签之前的文本，并将其设置为当前节点的值：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we just have to set up the initial state on the parser object we created.
    The initial state is a `FirstTag` object, so just add the following to the `__init__`
    method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要在创建的解析器对象上设置初始状态。初始状态是一个`FirstTag`对象，所以只需将以下内容添加到`__init__`方法中：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To test the class, let''s add a main script that opens an file from the command
    line, parses it, and prints the nodes:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个类，让我们添加一个主脚本，从命令行打开一个文件，解析它，并打印节点：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This code opens the file, loads the contents, and parses the result. Then it
    prints each node and its children in order. The `__str__` method we originally
    added on the `node` class takes care of formatting the nodes for printing. If
    we run the script on the earlier example, it outputs the tree as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码打开文件，加载内容，并解析结果。然后按顺序打印每个节点及其子节点。我们最初在`node`类上添加的`__str__`方法负责格式化节点以供打印。如果我们在之前的示例上运行脚本，它将输出树如下：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Comparing this to the original simplified XML document tells us the parser is
    working.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将这与原始简化的XML文档进行比较告诉我们解析器正在工作。
- en: State versus strategy
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态与策略
- en: The state pattern looks very similar to the strategy pattern; indeed, the UML
    diagrams for the two are identical. The implementation, too, is identical. We
    could even have written our states as first-class functions instead of wrapping
    them in objects, as was suggested for strategy.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式看起来与策略模式非常相似；实际上，两者的UML图是相同的。实现也是相同的。我们甚至可以将我们的状态编写为一等函数，而不是将它们包装在对象中，就像为策略建议的那样。
- en: While the two patterns have identical structures, they solve completely different
    problems. The strategy pattern is used to choose an algorithm at runtime; generally,
    only one of those algorithms is going to be chosen for a particular use case.
    The state pattern, on the other hand, is designed to allow switching between different
    states dynamically, as some process evolves. In code, the primary difference is
    that the strategy pattern is not typically aware of other strategy objects. In
    the state pattern, either the state or the context needs to know which other states
    that it can switch to.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两种模式具有相同的结构，但它们解决完全不同的问题。策略模式用于在运行时选择算法；通常，只有一个算法会被选择用于特定用例。另一方面，状态模式旨在允许在某个过程发展时动态地在不同状态之间切换。在代码中，主要区别在于策略模式通常不知道其他策略对象。在状态模式中，状态或上下文需要知道它可以切换到哪些其他状态。
- en: State transition as coroutines
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态转换作为协程
- en: The state pattern is the canonical object-oriented solution to state-transition
    problems. However, you can get a similar effect by constructing your objects as
    coroutines. Remember the regular expression log file parser we built in [Chapter
    21](b9232138-1747-4f88-b7ac-002c40332e92.xhtml), *The Iterator Pattern*? That
    was a state-transition problem in disguise. The main difference between that implementation
    and one that defines all the objects (or functions) used in the state pattern
    is that the coroutine solution allows us to encode more of the boilerplate in
    language constructs. There are two implementations, but neither one is inherently
    better than the other. The state pattern is actually the only place I would consider
    using coroutines outside of `asyncio`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式是解决状态转换问题的经典面向对象解决方案。然而，您可以通过将对象构建为协程来获得类似的效果。还记得我们在[第21章](b9232138-1747-4f88-b7ac-002c40332e92.xhtml)中构建的正则表达式日志文件解析器吗？那实际上是一个伪装的状态转换问题。该实现与定义状态模式中使用的所有对象（或函数）的实现之间的主要区别在于，协程解决方案允许我们在语言构造中编码更多的样板。有两种实现，但没有一种本质上比另一种更好。状态模式实际上是我考虑在`asyncio`之外使用协程的唯一场合。
- en: The singleton pattern
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式
- en: The singleton pattern is one of the most controversial patterns; many have accused
    it of being an *anti-pattern*, a pattern that should be avoided, not promoted.
    In Python, if someone is using the singleton pattern, they're almost certainly
    doing something wrong, probably because they're coming from a more restrictive
    programming language.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式是最具争议的模式之一；许多人指责它是一种*反模式*，一种应该避免而不是推广的模式。在Python中，如果有人使用单例模式，他们几乎肯定是在做错事情，可能是因为他们来自一个更严格的编程语言。
- en: So, why discuss it at all? Singleton is one of the most famous of all design
    patterns. It is useful in overly object-oriented languages, and is a vital part
    of traditional object-oriented programming. More relevantly, the idea behind singleton
    is useful, even if we implement the concept in a totally different way in Python.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么要讨论它呢？单例是所有设计模式中最著名的之一。它在过度面向对象的语言中很有用，并且是传统面向对象编程的重要部分。更相关的是，单例背后的想法是有用的，即使我们在Python中以完全不同的方式实现了这个概念。
- en: The basic idea behind the singleton pattern is to allow exactly one instance
    of a certain object to exist. Typically, this object is a sort of manager class
    like those we discussed in [Chapter 19](e639a907-22c5-4f1d-b125-f2b9a269c9f6.xhtml),
    *When to Use Object-Oriented Programming*. Such objects often need to be referenced
    by a wide variety of other objects, and passing references to the manager object
    around to the methods and constructors that need them can make code hard to read.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式背后的基本思想是允许某个对象的确切实例只存在一个。通常，这个对象是一种类似于我们在[第19章](e639a907-22c5-4f1d-b125-f2b9a269c9f6.xhtml)中讨论的管理类。这些对象通常需要被各种其他对象引用，并且将对管理对象的引用传递给需要它们的方法和构造函数可能会使代码难以阅读。
- en: 'Instead, when a singleton is used, the separate objects request the single
    instance of the manager object from the class, so a reference to it need not to
    be passed around. The UML diagram doesn''t fully describe it, but here it is for
    completeness:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当使用单例时，独立的对象从类中请求管理对象的单个实例，因此无需传递对它的引用。UML图表并没有完全描述它，但为了完整起见，这里是它：
- en: '![](assets/7a5b6442-fc27-49e5-944f-7bc6903ed2d9.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7a5b6442-fc27-49e5-944f-7bc6903ed2d9.png)'
- en: In most programming environments, singletons are enforced by making the constructor
    private (so no one can create additional instances of it), and then providing
    a static method to retrieve the single instance. This method creates a new instance
    the first time it is called, and then returns that same instance for all subsequent
    calls.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程环境中，通过使构造函数私有（这样就没有人可以创建它的其他实例），然后提供一个静态方法来检索单个实例来强制实施单例。这个方法在第一次调用时创建一个新实例，然后对所有后续调用返回相同的实例。
- en: Singleton implementation
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例实现
- en: 'Python doesn''t have private constructors, but for this purpose, we can use
    the `__new__` class method to ensure that only one instance is ever created:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有私有构造函数，但为了这个目的，我们可以使用`__new__`类方法来确保只创建一个实例：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When `__new__` is called, it normally constructs a new instance of that class.
    When we override it, we first check whether our singleton instance has been created;
    if not, we create it using a `super` call. Thus, whenever we call the constructor
    on `OneOnly`, we always get the exact same instance:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`__new__`时，通常会构造该类的一个新实例。当我们重写它时，我们首先检查我们的单例实例是否已经创建；如果没有，我们使用`super`调用来创建它。因此，每当我们在`OneOnly`上调用构造函数时，我们总是得到完全相同的实例：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The two objects are equal and located at the same address; thus, they are the
    same object. This particular implementation isn't very transparent, since it's
    not obvious that a singleton object has been created. Whenever we call a constructor,
    we expect a new instance of that object; in this case, that contract is violated.
    Perhaps, good docstrings on the class could alleviate this problem if we really
    think we need a singleton.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个对象是相等的，并且位于相同的地址；因此，它们是同一个对象。这个特定的实现并不是很透明，因为很难看出一个单例对象已经被创建。每当我们调用一个构造函数，我们期望得到该对象的一个新实例；在这种情况下，这个约定被违反了。也许，如果我们真的认为需要一个单例，类的良好文档字符串可以缓解这个问题。
- en: But we don't need it. Python coders frown on forcing the users of their code
    into a specific mindset. We may think only one instance of a class will ever be
    required, but other programmers may have different ideas. Singletons can interfere
    with distributed computing, parallel programming, and automated testing, for example.
    In all those cases, it can be very useful to have multiple or alternative instances
    of a specific object, even though a *normal* operation may never require one.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们并不需要它。Python程序员不喜欢强迫他们的代码用户进入特定的思维方式。我们可能认为一个类只需要一个实例，但其他程序员可能有不同的想法。单例可能会干扰分布式计算、并行编程和自动化测试，例如。在所有这些情况下，拥有特定对象的多个或替代实例可能非常有用，即使*正常*操作可能永远不需要一个。
- en: Module variables can mimic singletons
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块变量可以模仿单例
- en: Normally, in Python, the singleton pattern can be sufficiently mimicked using
    module-level variables. It's not as *safe* as a singleton in that people could
    reassign those variables at any time, but as with the private variables we discussed
    in [Chapter 16](9179e7f0-fea3-4c8a-b134-a190544099b4.xhtml), *Objects in Python*,
    this is acceptable in Python. If someone has a valid reason to change those variables,
    why should we stop them? It also doesn't stop people from instantiating multiple
    instances of the object, but again, if they have a valid reason to do so, why
    interfere?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在Python中，可以使用模块级变量来充分模拟单例模式。它不像单例那样*安全*，因为人们随时可以重新分配这些变量，但就像我们在[第16章](9179e7f0-fea3-4c8a-b134-a190544099b4.xhtml)中讨论的私有变量一样，在Python中这是可以接受的。如果有人有充分的理由更改这些变量，我们为什么要阻止他们呢？它也不会阻止人们实例化对象的多个实例，但同样，如果他们有充分的理由这样做，为什么要干涉呢？
- en: Ideally, we should give them a mechanism to get access to the *default singleton* value,
    while also allowing them to create other instances if they need them. While technically
    not a singleton at all, it provides the most Pythonic mechanism for singleton-like
    behavior.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们应该给它们一个机制来访问*默认的单例*值，同时也允许它们在需要时创建其他实例。虽然从技术上讲根本不是单例，但它提供了最符合Python风格的单例行为机制。
- en: 'To use module-level variables instead of a singleton, we instantiate an instance
    of the class after we''ve defined it. We can improve our state pattern to use
    singletons. Instead of creating a new object every time we change states, we can
    create a module-level variable that is always accessible:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用模块级变量而不是单例，我们在定义类之后实例化类的实例。我们可以改进我们的状态模式以使用单例。我们可以创建一个始终可访问的模块级变量，而不是在每次更改状态时创建一个新对象：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: All we've done is create instances of the various state classes that can be
    reused. Notice how we can access these module variables inside the classes, even
    before the variables have been defined? This is because the code inside the classes
    is not executed until the method is called, and by this point, the entire module
    will have been defined.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的只是创建可以重用的各种状态类的实例。请注意，即使在变量被定义之前，我们也可以在类内部访问这些模块变量？这是因为类内部的代码直到调用方法时才会执行，而到这个时候，整个模块都已经被定义了。
- en: The difference in this example is that instead of wasting memory creating a
    bunch of new instances that must be garbage collected, we are reusing a single
    state object for each state. Even if multiple parsers are running at once, only
    these state classes need to be used.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中的不同之处在于，我们不是浪费内存创建一堆必须进行垃圾回收的新实例，而是为每个状态重用一个单一的状态对象。即使多个解析器同时运行，只需要使用这些状态类。
- en: When we originally created the state-based parser, you may have wondered why
    we didn't pass the parser object to `__init__` on each individual state, instead
    of passing it into the `process` method as we did. The state could then have been
    referenced as `self.parser`. This is a perfectly valid implementation of the state
    pattern, but it would not have allowed leveraging the singleton pattern. If the
    state objects maintain a reference to the parser, then they cannot be used simultaneously
    to reference other parsers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最初创建基于状态的解析器时，您可能会想知道为什么我们没有将解析器对象传递给每个单独状态的`__init__`，而是像我们所做的那样将其传递给`process`方法。然后状态可以被引用为`self.parser`。这是状态模式的一个完全有效的实现，但它将不允许利用单例模式。如果状态对象保持对解析器的引用，那么它们就不能同时用于引用其他解析器。
- en: Remember, these are two different patterns with different purposes; the fact
    that singleton's purpose may be useful for implementing the state pattern does
    not mean the two patterns are related.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这是两种不同目的的模式；单例模式的目的可能对实现状态模式有用，但这并不意味着这两种模式有关联。
- en: The template pattern
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板模式
- en: 'The template pattern is useful for removing duplicate code; it''s intended
    to support the **Don''t Repeat Yourself** principle we discussed in [Chapter 19](e639a907-22c5-4f1d-b125-f2b9a269c9f6.xhtml),
    *When to Use Object-Oriented Programming*. It is designed for situations where
    we have several different tasks to accomplish that have some, but not all, steps
    in common. The common steps are implemented in a base class, and the distinct
    steps are overridden in subclasses to provide custom behavior. In some ways, it''s
    like a generalized strategy pattern, except similar sections of the algorithms
    are shared using a base class. Here it is in the UML format:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 模板模式对于消除重复代码非常有用；它旨在支持我们在[第19章](e639a907-22c5-4f1d-b125-f2b9a269c9f6.xhtml)中讨论的“不要重复自己”的原则，*何时使用面向对象编程*。它设计用于我们需要完成几个不同任务，这些任务有一些但不是全部步骤相同的情况。共同的步骤在基类中实现，不同的步骤在子类中被覆盖以提供自定义行为。在某些方面，它类似于一般化的策略模式，只是使用基类共享算法的相似部分。以下是它的UML格式：
- en: '![](assets/b96f7011-23f3-410b-bafd-138cad6aaeba.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b96f7011-23f3-410b-bafd-138cad6aaeba.png)'
- en: A template example
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个模板示例
- en: Let's create a car sales reporter as an example. We can store records of sales
    in an SQLite database table. SQLite is a simple file-based database engine that
    allows us to store records using SQL syntax. Python includes SQLite in its standard
    library, so there are no extra modules required.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以创建一个汽车销售报告为例。我们可以在SQLite数据库表中存储销售记录。SQLite是一个简单的基于文件的数据库引擎，允许我们使用SQL语法存储记录。Python在其标准库中包含了SQLite，因此不需要额外的模块。
- en: 'We have two common tasks we need to perform:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个需要执行的共同任务：
- en: Select all sales of new vehicles and output them to the screen in a comma-delimited
    format
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择所有新车销售并以逗号分隔的格式输出到屏幕
- en: Output a comma-delimited list of all salespeople with their gross sales and
    save it to a file that can be imported to a spreadsheet
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出一个逗号分隔的所有销售人员及其总销售额的列表，并将其保存到可以导入电子表格的文件中
- en: 'These seem like quite different tasks, but they have some common features.
    In both cases, we need to perform the following steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些看起来是非常不同的任务，但它们有一些共同的特征。在这两种情况下，我们都需要执行以下步骤：
- en: Connect to the database.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到数据库。
- en: Construct a query for new vehicles or gross sales.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造一个新车或总销售的查询。
- en: Issue the query.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发出查询。
- en: Format the results into a comma-delimited string.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果格式化为逗号分隔的字符串。
- en: Output the data to a file or email.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据输出到文件或电子邮件。
- en: The query construction and output steps are different for the two tasks, but
    the remaining steps are identical. We can use the template pattern to put the
    common steps in a base class, and the varying steps in two subclasses.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 查询构造和输出步骤对于这两个任务是不同的，但其余步骤是相同的。我们可以使用模板模式将共同的步骤放在一个基类中，将不同的步骤放在两个子类中。
- en: 'Before we start, let''s create a database and put some sample data in it, using
    a few lines of SQL:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们创建一个数据库并放入一些示例数据，使用几行SQL：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Hopefully, you can see what's going on here even if you don't know SQL; we've
    created a table to hold the data, and used six `insert` statements to add sales
    records. The data is stored in a file named `sales.db`. Now we have a sample we
    can work with in developing our template pattern.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您能看出这里发生了什么，即使您不懂SQL；我们创建了一个用于保存数据的表，并使用了六个`insert`语句来添加销售记录。数据存储在名为`sales.db`的文件中。现在我们有一个示例可以用来开发我们的模板模式。
- en: 'Since we''ve already outlined the steps that the template has to perform, we
    can start by defining the base class that contains the steps. Each step gets its
    own method (to make it easy to selectively override any one step), and we have
    one more managerial method that calls the steps in turn. Without any method content,
    here''s how it might look:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经概述了模板必须执行的步骤，我们可以开始定义包含这些步骤的基类。每个步骤都有自己的方法（这样可以轻松地选择性地覆盖任何一个步骤），而且我们还有一个管理方法依次调用这些步骤。没有任何方法内容的话，它可能会是这样的：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `process_format` method is the primary method to be called by an outside
    client. It ensures each step is executed in order, but it does not care whether
    that step is implemented in this class or in a subclass. For our examples, we
    know that three methods are going to be identical between our two classes:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_format`方法是外部客户端调用的主要方法。它确保每个步骤按顺序执行，但它不关心该步骤是在这个类中实现的还是在子类中实现的。对于我们的示例，我们知道两个类之间会有三个方法是相同的：'
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To help with implementing subclasses, the two methods that are not specified
    raise `NotImplementedError`. This is a common way to specify abstract interfaces
    in Python when abstract base classes seem too heavyweight. The methods could have
    empty implementations (with `pass`), or could be fully unspecified. Raising `NotImplementedError`,
    however, helps the programmer understand that the class is meant to be subclassed
    and these methods overridden. Empty methods or methods that do not exist are harder
    to identify as needing to be implemented and to debug if we forget to implement
    them.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助实现子类，两个未指定的方法会引发`NotImplementedError`。这是在Python中指定抽象接口的常见方式，当抽象基类看起来太重量级时。这些方法可以有空实现（使用`pass`），或者可以完全未指定。然而，引发`NotImplementedError`有助于程序员理解该类是用于派生子类和覆盖这些方法的。空方法或不存在的方法更难以识别需要实现和调试，如果我们忘记实现它们。
- en: Now we have a template class that takes care of the boring details, but is flexible
    enough to allow the execution and formatting of a wide variety of queries. The
    best part is, if we ever want to change our database engine from SQLite to another
    database engine (such as `py-postgresql`), we only have to do it here, in this
    template class, and we don't have to touch the two (or two hundred) subclasses
    we might have written.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个模板类，它处理了繁琐的细节，但足够灵活，可以执行和格式化各种查询。最好的部分是，如果我们想要将数据库引擎从SQLite更改为另一个数据库引擎（比如`py-postgresql`），我们只需要在这个模板类中进行修改，而不需要触及我们可能编写的两个（或两百个）子类。
- en: 'Let''s have a look at the concrete classes now:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看具体的类：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'These two classes are actually pretty short, considering what they''re doing:
    connecting to a database, executing a query, formatting the results, and outputting
    them. The superclass takes care of the repetitive work, but lets us easily specify
    those steps that vary between tasks. Further, we can also easily change steps
    that are provided in the base class. For example, if we wanted to output something
    other than a comma-delimited string (for example: an HTML report to be uploaded
    to a website), we can still override `format_results`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类实际上相当简短，考虑到它们的功能：连接到数据库，执行查询，格式化结果并输出。超类处理了重复的工作，但让我们可以轻松指定在任务之间变化的步骤。此外，我们还可以轻松地更改在基类中提供的步骤。例如，如果我们想要输出除逗号分隔字符串之外的其他内容（例如：要上传到网站的HTML报告），我们仍然可以覆盖`format_results`。
- en: Exercises
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: While writing the examples for this chapter, I discovered that it can be very
    difficult, and extremely educational, to come up with good examples where specific
    design patterns should be used. Instead of going over current or old projects
    to see where you can apply these patterns, as I've suggested in previous chapters,
    think about the patterns and different situations where they might come up. Try
    to think outside your own experiences. If your current projects are in the banking
    business, consider how you'd apply these design patterns in a retail or point-of-sale
    application. If you normally write web applications, think about using design
    patterns while writing a compiler.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本章的示例时，我发现想出应该使用特定设计模式的好例子可能非常困难，但也非常有教育意义。与其去审查当前或旧项目，看看你可以在哪里应用这些模式，正如我在之前的章节中建议的那样，不如考虑这些模式以及可能出现这些模式的不同情况。试着超越你自己的经验。如果你当前的项目是银行业务，考虑一下在零售或销售点应用这些设计模式。如果你通常编写Web应用程序，考虑在编写编译器时使用设计模式。
- en: Look at the decorator pattern and come up with some good examples of when to
    apply it. Focus on the pattern itself, not the Python syntax we discussed. It's
    a bit more general than the actual pattern. The special syntax for decorators
    is, however, something you may want to look for places to apply in existing projects
    too.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 看看装饰器模式，并想出一些适用它的好例子。专注于模式本身，而不是我们讨论的Python语法。它比实际模式要更一般一些。然而，装饰器的特殊语法是你可能想要寻找现有项目中适用的地方。
- en: What are some good areas to use the observer pattern? Why? Think about not only
    how you'd apply the pattern, but how you would implement the same task without
    using observer? What do you gain, or lose, by choosing to use it?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有哪些适合使用观察者模式的领域？为什么？不仅考虑如何应用模式，还要考虑如何在不使用观察者的情况下实现相同的任务？选择使用它会得到什么，或者失去什么？
- en: Consider the difference between the strategy and state patterns. Implementation-wise,
    they look very similar, yet they have different purposes. Can you think of cases
    where the patterns could be interchanged? Would it be reasonable to redesign a
    state-based system to use strategy instead, or vice versa? How different would
    the design actually be?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑策略模式和状态模式之间的区别。在实现上，它们看起来非常相似，但它们有不同的目的。你能想到可以互换使用这些模式的情况吗？重新设计一个基于状态的系统以使用策略，或者反之，是否合理？设计实际上会有多大的不同？
- en: The template pattern is such an obvious application of inheritance to reduce
    duplicate code that you may have used it before, without knowing its name. Try
    to think of at least half a dozen different scenarios where it would be useful.
    If you can do this, you'll be finding places for it in your daily coding all the
    time.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 模板模式是继承的一个明显应用，可以减少重复的代码，你可能以前就使用过它，只是不知道它的名字。试着想出至少半打不同的场景，它在哪些情况下会有用。如果你能做到这一点，你将会在日常编码中经常找到它的用武之地。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter discussed several common design patterns in detail, with examples,
    UML diagrams, and a discussion of the differences between Python and statically
    typed object-oriented languages. The decorator pattern is often implemented using
    Python's more generic decorator syntax. The observer pattern is a useful way to
    decouple events from actions taken on those events. The strategy pattern allows
    different algorithms to be chosen to accomplish the same task. The state pattern
    looks similar, but is used instead to represent systems can move between different
    states using well-defined actions. The singleton pattern, popular in some statically
    typed languages, is almost always an anti-pattern in Python.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细讨论了几种常见的设计模式，包括示例、UML图表，以及Python和静态类型面向对象语言之间的差异讨论。装饰器模式通常使用Python的更通用的装饰器语法来实现。观察者模式是一种有用的方式，可以将事件与对这些事件采取的行动分离。策略模式允许选择不同的算法来完成相同的任务。状态模式看起来类似，但实际上是用来表示系统可以使用明确定义的操作在不同状态之间移动。单例模式在一些静态类型的语言中很受欢迎，但在Python中几乎总是反模式。
- en: In the next chapter, we'll wrap up our discussion of design patterns.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将结束对设计模式的讨论。

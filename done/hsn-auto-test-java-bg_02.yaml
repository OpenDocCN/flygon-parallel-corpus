- en: Understanding Classes, Objects, and Their Usage in Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Java中的类、对象及其用法
- en: In the previous chapter, we covered a short introduction to Java and how to
    install the editor that we will be typing our code in. We also wrote and executed
    our first code on the editor.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了Java以及如何安装我们将在其中输入代码的编辑器。我们还在编辑器上编写并执行了我们的第一行代码。
- en: In this chapter, we will go deeper into some basic concepts, such as strings
    and variables, and how they are different from each other. We will also see what
    methods are and how they are put to use with different code. We will discuss why
    objects are important in our code and how we can implement them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地了解一些基本概念，比如字符串和变量，以及它们之间的区别。我们还将看到方法是什么，以及它们如何与不同的代码一起使用。我们将讨论为什么对象在我们的代码中很重要，以及我们如何可以实现它们。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Difference between strings and variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串和变量之间的区别
- en: Using methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方法
- en: Importance of classes and objects in Java
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java中类和对象的重要性
- en: Difference between strings and variables
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串和变量之间的区别
- en: 'In [Chapter 1](89991415-42e6-424d-83e8-8009fdc38f8f.xhtml), *First Programming
    Steps in Java*, we printed a string and the variable. If we look closely, when
    we print a variable we are not using double quotes, but when we print a string,
    we are using them. This is because the value is already present in the variable,
    hence we need not use any double quotes. If we use them, Java considers it to
    be a string and the output will be printed as the letter `a` in the following
    example. If we run this and observe the output, the letter `a` will be printed
    as shown in the following screenshot:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](89991415-42e6-424d-83e8-8009fdc38f8f.xhtml)中，*Java中的第一步编程*，我们打印了一个字符串和一个变量。如果我们仔细观察，当我们打印一个变量时，我们不使用双引号，但当我们打印一个字符串时，我们使用它们。这是因为值已经存在于变量中，因此我们不需要使用任何双引号。如果我们使用它们，Java会将其视为字符串，并且输出将如下例中的字母`a`打印出来。如果我们运行这个并观察输出，将会打印出字母`a`，如下面的截图所示：
- en: '![](img/95c911f9-6b23-4f44-a268-444f52f7de93.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95c911f9-6b23-4f44-a268-444f52f7de93.png)'
- en: Output displaying the value of a as per the code
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示代码中a的值
- en: 'If we don''t use double quotes, Java will check whether there is any variable
    defined with this letter. If so, it prints the value present in that variable.
    If there is no variable defined, then it gives an error. If we comment out the
    variable declaration, what we see is an error. Hovering the mouse over the variable,
    we will get a prompt saying Create a local variable ''a'', or we can use it by
    adding double quotes:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用双引号，Java会检查是否有任何变量定义为这个字母。如果有，它会打印出该变量中的值。如果没有定义变量，则会出现错误。如果我们注释掉变量声明，我们会看到一个错误。将鼠标悬停在变量上，会得到一个提示，提示说创建一个本地变量'a'，或者我们可以通过添加双引号来使用它：
- en: '![](img/701160b8-1228-4ed6-a4ea-2c80aeadbda7.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/701160b8-1228-4ed6-a4ea-2c80aeadbda7.png)'
- en: Quick fixes drop down with suggestions to correct the code error
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 快速修复下拉菜单，提供纠正代码错误的建议
- en: In short, if we simply use double quotes, the variable will be treated as a
    string, but if we don't use double quotes, we must declare the variable somewhere.
    That is the difference between printing out strings and printing out variables.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果我们只是使用双引号，那么变量将被视为字符串，但如果我们不使用双引号，我们必须在某处声明变量。这就是打印字符串和打印变量之间的区别。
- en: Using methods
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用方法
- en: 'Basically, methods are blocks in our Java class. Let''s write one block here
    as an example, and observe where the opened and closed brackets are placed. The
    following example shows one complete block:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，方法是我们Java类中的代码块。让我们在这里写一个代码块作为示例，并观察打开和关闭的括号放在哪里。以下示例显示了一个完整的代码块：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this code, we have named the block of code `getData()` and `void` is the
    return type for this method.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们将代码块命名为`getData()`，`void`是这个方法的返回类型。
- en: If we are expecting to return a number from the method, and the number is an
    integer, then we have to write `integer` in place of `void`. The same applies
    with strings; if we are planning to return a string from the `getData()` method,
    then we have to declare it as a `string`. If we are not returning anything, that
    is, if we are simply writing a few lines of code, then we leave it as `void`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们期望从方法中返回一个数字，并且这个数字是一个整数，那么我们必须在`void`的位置写`integer`。对于字符串也是一样；如果我们计划从`getData()`方法中返回一个字符串，那么我们必须将其声明为`string`。如果我们不返回任何东西，也就是说，如果我们只是写了几行代码，那么我们将其保留为`void`。
- en: 'Take a look at the following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的截图：
- en: '![](img/f19e2e43-91e8-49bf-9df8-a86691130e56.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f19e2e43-91e8-49bf-9df8-a86691130e56.png)'
- en: Return type is given as void for getData()
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为getData()指定返回类型为void
- en: Here, we are not returning anything, so we keep it as `void`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们没有返回任何东西，所以我们将其保留为`void`。
- en: 'Let''s add a `return 2;` line below `System.out.println(" I am in method");`.
    Here, we are returning a number that is an integer. That''s why we will receive
    an error here. If we hover our mouse over the error shown over `return 2;`, you
    will see a suggestion, Change method return type to ''int'':'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`System.out.println(" I am in method");`下面添加一行`return 2;`。在这里，我们返回的是一个整数。这就是为什么我们会在这里收到一个错误。如果我们将鼠标悬停在`return
    2;`上显示的错误上，你会看到一个建议，将方法返回类型更改为'int'：
- en: '![](img/bbef302b-2ad0-4e6f-ac27-7403c44d3042.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbef302b-2ad0-4e6f-ac27-7403c44d3042.png)'
- en: Quick fixes drop down with suggestions to correct the code error
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 快速修复下拉菜单，提供纠正代码错误的建议
- en: On clicking on the suggestion, our IDE automatically modifies the return type
    to integer and the error disappears. The same is also the case with the string
    data type.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 点击建议后，我们的IDE会自动将返回类型修改为整数，错误就消失了。字符串数据类型也是一样的情况。
- en: We will discuss the `public` access modifier later on in [Chapter 10](b0ee13be-6d61-427c-9dca-99750b6fafdd.xhtml), *The
    Importance of the final Keyword, Packages, and Modifiers*. There is a lot to discuss
    since there are different access modifiers in Java, such as `public`, `private`,
    `protected`, and `default`. We will take a look at each access modifier with appropriate
    examples so that they are explained in detail. For now, let's just accept all
    access modifiers as `public`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第10章](b0ee13be-6d61-427c-9dca-99750b6fafdd.xhtml)中稍后讨论`public`访问修饰符，*final关键字、包和修饰符的重要性*。有很多要讨论的，因为Java中有不同的访问修饰符，如`public`、`private`、`protected`和`default`。我们将通过适当的示例来看看每个访问修饰符，以便详细解释它们。现在，让我们将所有访问修饰符都视为`public`。
- en: Now you must be wondering why these methods are present in Java. What is their
    use?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你一定想知道为什么Java中存在这些方法。它们有什么用途？
- en: Let's say that we are executing a 10-line block of code, for example, to add
    two integers on a page. Now every time we reach a page that requires us to add
    two integers, we have to write the 10 lines of code again. Maybe replicating the
    10 lines of code won't matter for one instance but what if we were to require
    this block of code for 10 instances throughout the entire project? So 10 pages
    and 10 lines of code makes 100 lines of code that we are replicating in a single
    Java program. So to avoid that, we write all the 10 lines of code into one block,
    and we name that block as, for example, `getData` or anything else. Thereafter,
    whenever we require the 10 lines of code that we typed, we can simply call the
    `getData` method. All the 10 lines of code will fall into that particular block,
    and it will get executed. In this case, we avoid writing the code 10 times; we
    write it only once in a method and call that method whenever it is required.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在执行一个10行的代码块，例如，在页面上添加两个整数。现在每次我们到达需要我们添加两个整数的页面时，我们都必须再次编写这10行代码。也许复制10行代码对于一个实例来说并不重要，但是如果我们需要在整个项目中的10个实例中需要这个代码块呢？因此，10页和10行代码使我们在一个Java程序中复制了100行代码。为了避免这种情况，我们将所有10行代码写入一个代码块中，并将该代码块命名为，例如`getData`或其他任何名称。此后，每当我们需要我们键入的10行代码时，我们只需调用`getData`方法。所有10行代码将进入该特定的代码块，并将被执行。在这种情况下，我们避免了10次编写代码；我们只在一个方法中编写一次，并在需要时调用该方法。
- en: 'Let''s explain this with an example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来解释这一点：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding class, we will consider `" I am in method"` as the 10 lines
    of code that we were talking about earlier. We want to call this method, but here
    the `getData()` block is outside the `main` block, which means that the code cannot
    be executed. To execute it, we must move it inside the `main` block. In most cases,
    people just copy the code inside the `main` block and then receive an error since
    no methods are allowed inside the `main` block. The method should be written outside
    the main block, but inside the class. If we write something outside the class,
    there is no point since Java does not catch it. But if we write the method outside
    the `main` block, how do we get it inside the `main` block? For that, we need
    to create an object for the class where our method is defined. Here, our methods
    are defined in the `Firstclass` class, so we create an object for this class and
    with that object we can access the methods and variables present in the class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述类中，我们将考虑“我在方法中”作为我们之前谈到的10行代码。我们想要调用这个方法，但是`getData()`块在`main`块之外，这意味着代码无法执行。为了执行它，我们必须将其移动到`main`块内。在大多数情况下，人们只是将代码复制到`main`块内，然后收到错误，因为`main`块内不允许有方法。方法应该写在`main`块外，但在类内。如果我们在类外写点东西，那就没有意义，因为Java不会捕捉到它。但是如果我们在`main`块外写方法，我们如何将其放入`main`块内呢？为此，我们需要为包含我们的方法的类创建一个对象。在这里，我们的方法是在`Firstclass`类中定义的，因此我们为这个类创建一个对象，并且通过该对象我们可以访问类中存在的方法和变量。
- en: In the next section, we'll see what the objects are, where we use them, and
    how objects are used to call the methods and variables.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到对象是什么，我们在哪里使用它们，以及如何使用对象来调用方法和变量。
- en: Importance of classes and objects in Java
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中类和对象的重要性
- en: Objects are instances or references of a class. So we can call the methods and
    variables present in this class with the help of their objects. We cannot call
    methods and objects directly, we can only use them with the help of their objects. So
    first, we need to create objects for the class, and then we can call the method
    inside the `main` class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是类的实例或引用。因此，我们可以通过它们的对象调用这个类中存在的方法和变量。我们不能直接调用方法和对象，只能使用它们的对象。因此，首先我们需要为类创建对象，然后我们可以在`main`类中调用方法。
- en: 'Let''s take a look at the previous example to explain this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过之前的例子来解释这一点：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since the `main` block is already in the class, why do we need to create an
    object again for this class and call it?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`main`块已经在类中，为什么我们需要再次为这个类创建一个对象并调用它呢？
- en: The answer is that there is no way that the `main` block will come to know about
    the method outside it until and unless we create an object to call the method.
    There is an exception for that, which is the `static` variable, saying that the
    method is static. So, in general, accessing other methods is only possible with
    objects.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是`main`块不可能知道它外部的方法，除非我们创建一个对象来调用该方法。有一个例外，即`static`变量，表示该方法是静态的。因此，一般来说，只有通过对象才能访问其他方法。
- en: Creating an object in Java
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java中创建对象
- en: 'First, we need to allocate some memory for the object in the class. Memory
    can be allocated with the help of the `new` operator followed by the class name.
    Then we define an object name for it. The return type should always be the class
    name. This is the syntax for creating a memory allocation for a class. So the
    code for memory allocation for the preceding example will look something like
    the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在类中为对象分配一些内存。可以使用`new`运算符后跟类名来分配内存。然后我们为其定义一个对象名称。返回类型应始终是类名。这是为类创建内存分配的语法。因此，上述示例的内存分配代码将如下所示：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we say `fn` is the object of the `Firstclass` class. Now that we have
    created an object, let's see how we can access it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们说`fn`是`Firstclass`类的对象。现在我们已经创建了一个对象，让我们看看如何访问它。
- en: Accessing an object in Java
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java中访问对象
- en: To access the method of the class, we write the object name and then `.` (dot).
    All the methods that qualify for the class are displayed in a drop-down—this is
    another great feature in Eclipse. We can just look for the method in the drop-down
    rather than searching for it through the code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问类的方法，我们写入对象名称，然后`.`（点）。所有符合该类的方法都显示在下拉菜单中——这是Eclipse中的另一个很棒的功能。我们只需在下拉菜单中查找方法，而不是通过代码搜索它。
- en: 'In the example, we are using the `getData()` method. The rest of the methods
    shown are all built-in Java methods. Observe how the methods are displayed:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们使用了`getData()`方法。显示的其余方法都是内置的Java方法。观察方法的显示方式：
- en: '![](img/6a444ef7-aadf-4fc7-85cc-748bcd5af95a.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a444ef7-aadf-4fc7-85cc-748bcd5af95a.png)'
- en: Drop-down showing all the class methods available to the editor to use
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下拉菜单显示编辑器可用的所有类方法
- en: 'On clicking on `getData()`, the `getData()` block will be transferred to the
    line where the object was called, and when we run the program, the code will be
    executed as it is part of the `main` block. The accessing code will finally look
    like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 单击`getData()`时，`getData()`块将被转移到调用对象的行，当我们运行程序时，代码将被执行，因为它是`main`块的一部分。访问代码最终将如下所示：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s see what the final code for this example will look like:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个例子的最终代码将是什么样子：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So if we run the class given in the example, our result will be as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们运行示例中给出的类，我们的结果将如下：
- en: '![](img/816f4740-d7ba-4ca8-a963-eede62592cc2.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/816f4740-d7ba-4ca8-a963-eede62592cc2.png)'
- en: Output displaying I am in method as per the code
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示我在方法中是代码
- en: '`I am in method` is what we see in the output; this is because control starts
    from the memory-allocation line, creates an object, and using the object we call
    the method of that class. Control goes back to the `getData()` block and completes
    the lines of code that are present in that particular block; it executes the print
    statement, and we see that it gets printed. This is why objects are powerful in
    calling a method.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在输出中看到`我在方法`；这是因为控制从内存分配行开始，创建一个对象，并使用该对象调用该类的方法。控制返回到`getData()`块，并完成该块中存在的代码行；它执行打印语句，我们看到它被打印出来。这就是为什么对象在调用方法时是强大的。
- en: 'The same technique can be used for calling integers. Let''s say we declare
    a variable in the `a` class and assign a value to it. We can print the variable
    value by adding the following line in the `main` method:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的技术可以用于调用整数。假设我们在`a`类中声明一个变量并为其赋值。我们可以通过在`main`方法中添加以下行来打印变量值：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is one way of using classes, objects, and methods in Java; basically we
    are encapsulating.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Java中使用类、对象和方法的一种方式；基本上我们是在封装。
- en: Accessing a method in a different class
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不同类中访问方法
- en: Let's say we face a situation where we are working with one class and we need
    to access an object in another class; this can be done in Java. Let's use an example
    to help explain this. Let's use two classes, `Firstclass()` (from the *Accessing
    an object in Java* section ), and we'll create a new class, called `secondclass()`.
    On creating a new class, the default code is created by the editor and we're able
    to add code in it. We add a random method, `public void setData()`, within which
    we print the `I am in second class method` statement.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们遇到这样一种情况：我们正在使用一个类，但需要访问另一个类中的对象；这在Java中是可以做到的。让我们用一个例子来帮助解释这一点。我们使用两个类，`Firstclass()`（来自*在Java中访问对象*部分），然后我们创建一个新类，叫做`secondclass()`。创建新类时，编辑器会创建默认代码，我们可以在其中添加代码。我们添加一个随机方法，`public
    void setData()`，在其中我们打印`我在第二类方法`语句。
- en: 'Now, we want the `setData()` method in the `Firstclass()` class. Basically
    we want to execute the `setData()` method in `Firstclass()`. And methods can be
    called only with the objects of that particular class. To do so, we create an
    object in the method that calls the method in the other class. We use similar
    code to what we used in the previous example to allocate memory for an object.
    The following code is added in the `main` method of `Firstclass()`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望`Firstclass()`类中有`setData()`方法。基本上我们想在`Firstclass()`中执行`setData()`方法。方法只能通过该类的对象来调用。为此，我们在调用另一个类中的方法的方法中创建一个对象。我们使用与前面示例中用于为对象分配内存的相似代码。以下代码添加到`Firstclass()`的`main`方法中：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While typing the code in the `main` class, when we type `sn.` to call the method,
    we will again get all the choices of methods that there are in Java. Since we
    want to call `setData()`, we select it from the multiple options that are shared
    with us. This will successfully bring `setData()` into in the `main` method of
    `Firstclass()` by creating an object for the class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`类中输入代码时，当我们键入`sn.`来调用方法时，我们将再次获得Java中所有方法的选择。由于我们想调用`setData()`，我们从与我们共享的多个选项中选择它。通过为该类创建一个对象，这将成功地将`setData()`带入`Firstclass()`的`main`方法中。
- en: 'If we run the code, we will get the following output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行代码，我们将得到以下输出：
- en: '![](img/5735c3cf-5d54-4ade-9e34-992f83229f8b.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5735c3cf-5d54-4ade-9e34-992f83229f8b.png)'
- en: Output displaying I am in second class method as per the code
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示我在代码中是第二类方法
- en: Summary
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started off by discussing the difference between strings and variables, and
    how they appear in a code. We then saw what methods are and how can they be used
    to write our code. After that, we discussed the importance of classes and objects,
    and how they are used to call methods that execute a class. We learned how to
    allocate memory to an object and call the method of that object while executing
    the code.Finally, we learned how to access a method that is present in another
    class using objects.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论了字符串和变量之间的区别，以及它们在代码中的出现方式。然后我们看到了方法是什么，以及如何使用它们来编写我们的代码。之后，我们讨论了类和对象的重要性，以及它们如何用于调用执行类的方法。我们学会了如何为对象分配内存并在执行代码时调用该对象的方法。最后，我们学会了如何使用对象访问另一个类中存在的方法。
- en: In the next chapter we will learn more about strings and have a look at the `String` class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更多地了解字符串，并查看`String`类。

["```py\n    class Node: \n        def __init__(self, data): \n            self.data = data \n            self.right_child = None \n            self.left_child = None \n```", "```py\n    n1 = Node(\"root node\")  \n    n2 = Node(\"left child node\") \n    n3 = Node(\"right child node\") \n    n4 = Node(\"left grandchild node\") \n```", "```py\n    n1.left_child = n2 \n    n1.right_child = n3 \n    n2.left_child = n4 \n```", "```py\n    current = n1 \n    while current: \n        print(current.data) \n        current = current.left_child \n```", "```py\nroot node \nleft child node \nleft grandchild node\n```", "```py\n    def inorder(self, root_node): \n        current = root_node \n        if current is None: \n            return \n        self.inorder(current.left_child) \n        print(current.data) \n        self.inorder(current.right_child) \n```", "```py\n    def preorder(self, root_node): \n        current = root_node \n        if current is None: \n            return \n        print(current.data) \n        self.preorder(current.left_child) \n        self.preorder(current.right_child) \n```", "```py\n    def postorder(self, root_node): \n        current = root_node \n        if current is None: \n            return \n        self.postorder(current.left_child) \n        self.postorder(current.right_child) \n\n        print(current.data)\n```", "```py\n    from collections import deque \n    class Tree: \n        def breadth_first_traversal(self): \n            list_of_nodes = [] \n            traversal_queue = deque([self.root_node]) \n```", "```py\n        while len(traversal_queue) > 0: \n            node = traversal_queue.popleft() \n            list_of_nodes.append(node.data) \n               if node.left_child: \n                traversal_queue.append(node.left_child) \n\n            if node.right_child: \n                traversal_queue.append(node.right_child) \n        return list_of_nodes\n```", "```py\n    class Tree: \n        def __init__(self): \n            self.root_node = None \n```", "```py\n    def find_min(self): \n        current = self.root_node \n        while current.left_child: \n            current = current.left_child \n\n        return current \n```", "```py\n    def find_max(self): \n        current = self.root_node \n        while current.right_child: \n            current = current.right_child \n\n        return current \n```", "```py\ndef insert(self, data):\n    node = Node(data) \n    if self.root_node is None: \n        self.root_node = node \n    else: \n        current = self.root_node \n        parent = None  \n    while True: \n        parent = current \n        if node.data < parent.data: \n            current = current.left_child \n            if current is None: \n                    parent.left_child = node \n                    return \n            else: \n                    current = current.right_child \n                    if current is None: \n                        parent.right_child = node \n                        return\n```", "```py\n    def insert(self, data):\n```", "```py\n        node = Node(data) \n```", "```py\n        if self.root_node is None: \n            self.root_node = node \n        else: \n```", "```py\n        current = self.root_node \n        parent = None \n        while True: \n            parent = current \n```", "```py\n        if node.data < current.data: \n            current = current.left_child \n            if current is None: \n                parent.left_child = node \n                return \n```", "```py\n        else: \n            current = current.right_child \n            if current is None: \n                parent.right_child = node \n                return \n```", "```py\n    def get_node_with_parent(self, data): \n        parent = None \n        current = self.root_node \n        if current is None: \n            return (parent, None) \n        while True: \n            if current.data == data: \n                return (parent, current) \n            elif current.data > data: \n                parent = current \n                current = current.left_child \n            else: \n                parent = current \n                current = current.right_child \n\n        return (parent, current) \n```", "```py\n    def remove(self, data): \n        parent, node = self.get_node_with_parent(data) \n\n        if parent is None and node is None: \n            return False \n\n        # Get children count \n        children_count = 0 \n\n        if node.left_child and node.right_child: \n            children_count = 2 \n        elif (node.left_child is None) and (node.right_child is None): \n            children_count = 0 \n        else: \n            children_count = 1 \n```", "```py\n        if children_count == 0: \n            if parent: \n                if parent.right_child is node: \n                    parent.right_child = None \n                else: \n                    parent.left_child = None \n            else: \n                self.root_node = None\n```", "```py\n        elif children_count == 1: \n            next_node = None \n            if node.left_child: \n                next_node = node.left_child \n            else: \n                next_node = node.right_child \n\n            if parent: \n                if parent.left_child is node: \n                    parent.left_child = next_node \n                else: \n                    parent.right_child = next_node \n            else: \n                self.root_node = next_node \n```", "```py\n        ... \n        else: \n            parent_of_leftmost_node = node \n            leftmost_node = node.right_child \n            while leftmost_node.left_child: \n                parent_of_leftmost_node = leftmost_node \n                leftmost_node = leftmost_node.left_child \n\n            node.data = leftmost_node.data \n```", "```py\n    if parent_of_leftmost_node.left_child == leftmost_node: \n       parent_of_leftmost_node.left_child = leftmost_node.right_child \n    else: \n       parent_of_leftmost_node.right_child = leftmost_node.right_child\n```", "```py\n  def search(self, data):\n        current = self.root_node\n        while True:\n            if current is None:\n                return None\n            elif current.data is data:\n                return data\n            elif current.data > data:\n                current = current.left_child\n            else:\n                current = current.right_child\n\n```", "```py\n    tree = Tree() \n    tree.insert(5) \n    tree.insert(2) \n    tree.insert(7) \n    tree.insert(9) \n    tree.insert(1) \n\n    for i in range(1, 10): \n        found = tree.search(i) \n        print(\"{}: {}\".format(i, found)) \n```", "```py\n    class TreeNode: \n        def __init__(self, data=None): \n            self.data = data \n            self.right = None \n            self.left = None \n```", "```py\n        expr = \"4 5 + 5 3 - *\".split() \n        stack = Stack() \n```", "```py\n    for term in expr: \n        if term in \"+-*/\": \n            node = TreeNode(term) \n            node.right = stack.pop() \n            node.left = stack.pop() \n        else: \n            node = TreeNode(int(term)) \n        stack.push(node) \n```", "```py\n    def calc(node): \n        if node.data is \"+\": \n            return calc(node.left) + calc(node.right) \n        elif node.data is \"-\": \n            return calc(node.left) - calc(node.right) \n        elif node.data is \"*\": \n            return calc(node.left) * calc(node.right) \n        elif node.data is \"/\": \n            return calc(node.left) / calc(node.right) \n        else: \n            return node.data \n```", "```py\n    root = stack.pop() \n    result = calc(root) \n    print(result) \n```"]
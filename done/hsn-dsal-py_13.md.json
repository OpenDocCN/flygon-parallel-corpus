["```py\nfunc(1) = 1\nfunc(0) = 1 \nfunc(n) = func(n-1) + func(n-2)\n```", "```py\n    1 1 2 3 5\n```", "```py\n def fib(n): \n    if n <= 2: \n       return 1 \n    else: \n       return fib(n-1) + fib(n-2) \n```", "```py\n    return fib(n-1) + fib(n-2) \n```", "```py\n    def dyna_fib(n, lookup): \n        if n <= 2: \n            lookup[n] = 1 \n\n        if lookup[n] is None: \n            lookup[n] = dyna_fib(n-1, lookup) + dyna_fib(n-2, lookup) \n\n        return lookup[n]\n```", "```py\n    map_set = [None]*(1000)\n```", "```py\n    if n <= 2: \n        lookup[n] = 1 \n```", "```py\nif lookup[n] is None:\n    lookup[n] = dyna_fib(n-1, lookup) + dyna_fib(n-2, lookup)\n```", "```py\n    def fib(n): \n\n        results = [1, 1] \n\n        for i in range(2, n): \n            results.append(results[i-1] + results[i-2]) \n\n        return results[-1]\n```", "```py\n    def merge_sort(unsorted_list): \n        if len(unsorted_list) == 1: \n            return unsorted_list \n\n        mid_point = int((len(unsorted_list))//2) \n\n        first_half = unsorted_list[:mid_point] \n        second_half = unsorted_list[mid_point:] \n\n        half_a = merge_sort(first_half) \n        half_b = merge_sort(second_half) \n\n        return merge(half_a, half_b) \n```", "```py\n    first_half = unsorted_list[:mid_point] \n    second_half = unsorted_list[mid_point:] \n```", "```py\n    half_a = merge_sort(first_half)  \n    half_b = merge_sort(second_half)\n```", "```py\n def merge(first_sublist, second_sublist): \n     i = j = 0 \n     merged_list = [] \n\n     while i < len(first_sublist) and j < len(second_sublist): \n         if first_sublist[i] < second_sublist[j]: \n             merged_list.append(first_sublist[i]) \n             i += 1 \n         else: \n             merged_list.append(second_sublist[j]) \n             j += 1 \n\n     while i < len(first_sublist): \n         merged_list.append(first_sublist[i]) \n         i += 1 \n\n     while j < len(second_sublist): \n         merged_list.append(second_sublist[j]) \n         j += 1 \n\n     return merged_list \n```", "```py\n    while i < len(first_sublist) and j < len(second_sublist): \n        if first_sublist[i] < second_sublist[j]: \n            merged_list.append(first_sublist[i]) \n            i += 1 \n        else: \n            merged_list.append(second_sublist[j]) \n            j += 1 \n```", "```py\n    def basic_small_change(denom, total_amount): \n        sorted_denominations = sorted(denom, reverse=True) \n\n        number_of_denoms = [] \n\n        for i in sorted_denominations: \n            div = total_amount // i \n            total_amount = total_amount % i \n            if div > 0: \n                number_of_denoms.append((i, div)) \n\n        return number_of_denoms\n```", "```py\n    for i in sorted_denominations: \n        div = total_amount // i \n        total_amount = total_amount % i \n        if div > 0: \n            number_of_denoms.append((i, div)) \n```", "```py\n    def optimal_small_change(denom, total_amount): \n\n        sorted_denominations = sorted(denom, reverse=True) \n\n        series = [] \n        for j in range(len(sorted_denominations)): \n            term = sorted_denominations[j:] \n\n            number_of_denoms = [] \n            local_total = total_amount \n            for i in term: \n                div = local_total // i \n                local_total = local_total % i \n                if div > 0: \n                    number_of_denoms.append((i, div)) \n\n            series.append(number_of_denoms) \n\n        return series\n```", "```py\n    for j in range(len(sorted_denominations)): \n        term = sorted_denominations[j:] \n        ...     \n```", "```py\n    graph = dict() \n    graph['A'] = {'B': 5, 'D': 9, 'E': 2} \n    graph['B'] = {'A': 5, 'C': 2} \n    graph['C'] = {'B': 2, 'D': 3} \n    graph['D'] = {'A': 9, 'F': 2, 'C': 3} \n    graph['E'] = {'A': 2, 'F': 3} \n    graph['F'] = {'E': 3, 'D': 2} \n```", "```py\n    table = dict() \n    table = { \n        'A': [0, None], \n        'B': [float(\"inf\"), None], \n        'C': [float(\"inf\"), None], \n        'D': [float(\"inf\"), None], \n        'E': [float(\"inf\"), None], \n        'F': [float(\"inf\"), None], \n    } \n```", "```py\n    DISTANCE = 0 \n    PREVIOUS_NODE = 1 \n    INFINITY = float('inf') \n```", "```py\n    def find_shortest_path(graph, table, origin): \n        visited_nodes = [] \n        current_node = origin \n        starting_node = origin \n```", "```py\n    while True: \n        adjacent_nodes = graph[current_node] \n        if set(adjacent_nodes).issubset(set(visited_nodes)): \n            # Nothing here to do. All adjacent nodes have been visited. \n            pass \n        else: \n            unvisited_nodes = \n                set(adjacent_nodes).difference(set(visited_nodes)) \n            for vertex in unvisited_nodes: \n                distance_from_starting_node = \n                    get_shortest_distance(table, vertex) \n                if distance_from_starting_node == INFINITY and \n                   current_node == starting_node: \n                    total_distance = get_distance(graph, vertex, \n                                                  current_node) \n                else: \n                    total_distance = get_shortest_distance (table, \n                    current_node) + get_distance(graph, current_node, \n                                                 vertex) \n\n                if total_distance < distance_from_starting_node: \n                    set_shortest_distance(table, vertex, \n                                          total_distance) \n                    set_previous_node(table, vertex, current_node) \n\n        visited_nodes.append(current_node) \n\n        if len(visited_nodes) == len(table.keys()): \n            break \n\n        current_node = get_next_node(table,visited_nodes) \n```", "```py\n    distance_from_starting_node = get_shortest_distance(table, vertex) \n```", "```py\n    if distance_from_starting_node == INFINITY and current_node == starting_node: \n         total_distance = get_distance(graph, vertex, current_node) \n```", "```py\n    total_distance = get_distance(graph, vertex, current_node)\n```", "```py\n    if total_distance < distance_from_starting_node: \n        set_shortest_distance(table, vertex, total_distance) \n    set_previous_node(table, vertex, current_node) \n```", "```py\n    visited_nodes.append(current_node) \n```", "```py\n shortest_distance_table = find_shortest_path(graph, table, 'A') \n for k in sorted(shortest_distance_table): \n     print(\"{} - {}\".format(k,shortest_distance_table[k])) \n```", "```py\n>>> A - [0, None] B - [5, 'A'] C - [7, 'B'] D - [7, 'F'] E - [2, 'A'] F - [5, 'E']\n```", "```py\n    def get_shortest_distance(table, vertex): \n        shortest_distance = table[vertex][DISTANCE] \n        return shortest_distance \n```", "```py\n    def set_shortest_distance(table, vertex, new_distance): \n        table[vertex][DISTANCE] = new_distance \n```", "```py\n    def set_previous_node(table, vertex, previous_node): \n        table[vertex][PREVIOUS_NODE] = previous_node \n```", "```py\n    def get_distance(graph, first_vertex, second_vertex): \n        return graph[first_vertex][second_vertex] \n```", "```py\n    def get_next_node(table, visited_nodes): \n        unvisited_nodes = \n            list(set(table.keys()).difference(set(visited_nodes))) \n        assumed_min = table[unvisited_nodes[0]][DISTANCE] \n        min_vertex = unvisited_nodes[0] \n        for node in unvisited_nodes: \n            if table[node][DISTANCE] < assumed_min: \n                assumed_min = table[node][DISTANCE] \n                min_vertex = node \n\n        return min_vertex \n```"]
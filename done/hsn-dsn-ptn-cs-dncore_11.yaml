- en: Concurrent Programming in .NET Core
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core中的并发编程
- en: In the previous chapter ([Chapter 7](232b63cb-5006-431d-8378-b7e2ba4c1119.xhtml),
    *Implementing Design Patterns for Web Applications - Part 2*), we created a sample
    web application with the help of various patterns for the web. We adapted authorization
    and authentication mechanisms to secure a web application and discussed **Test-driven
    development** (**TDD**) to make sure that our code has been tested and is working.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章（[第7章](232b63cb-5006-431d-8378-b7e2ba4c1119.xhtml)，*为Web应用程序实现设计模式 - 第2部分*）中，我们使用各种模式创建了一个示例Web应用程序。我们调整了授权和认证机制以保护Web应用程序，并讨论了**测试驱动开发**（**TDD**）以确保我们的代码已经经过测试并且可以正常工作。
- en: This chapter will discuss the best practices to adopt while performing concurrent
    programming in .NET Core. In the upcoming sections of this chapter, we will learn
    about the design patterns relevant for well-organized concurrency in C# and .NET
    Core applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论在.NET Core中执行并发编程时采用的最佳实践。在本章的后续部分中，我们将学习与C#和.NET Core应用程序中良好组织的并发相关的设计模式。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Async/Await – Why is blocking bad?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Async/Await - 为什么阻塞是不好的？
- en: Multithreading and asynchronous programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程和异步编程
- en: Concurrent collections
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发集合
- en: Patterns and practices – TDD and Parallel LINQ
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式和实践 - TDD和并行LINQ
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter contains various code examples to explain the concepts. The code
    is kept simple and is only for demonstration purposes. Most of the examples involve
    a .NET Core console application written in C#.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例来解释概念。代码保持简单，仅用于演示目的。大多数示例涉及使用C#编写的.NET Core控制台应用程序。
- en: The complete source code is available at the following link: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter8](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter8).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可在以下链接找到：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter8](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter8)。
- en: 'To run and execute the code, you will require the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行和执行代码，您需要以下内容：
- en: Visual Studio 2019 (you can also use Visual Studio 2017)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019（您也可以使用Visual Studio 2017）
- en: Setting up .NET Core
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core的设置
- en: SQL Server (the Express Edition is used in this chapter)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server（本章中使用Express Edition）
- en: Installing Visual Studio
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Visual Studio
- en: 'To run the code examples, you will need to install Visual Studio (preferred
    IDE). To do so, you can follow these instructions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码示例，您需要安装Visual Studio（首选IDE）。要做到这一点，您可以按照以下说明进行操作：
- en: Download Visual Studio from the download link mentioned with the installation
    instructions: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从安装说明中提到的下载链接下载Visual Studio：[https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio)。
- en: Follow the installation instructions mentioned.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照提到的安装说明进行操作。
- en: Multiple options are available for the Visual Studio installation. Here, we
    are using Visual Studio for Windows.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio安装有多个选项可供选择。在这里，我们使用Windows的Visual Studio。
- en: Setting up .NET Core
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置.NET Core
- en: 'If you do not have .NET Core installed, you will need to follow these instructions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有安装.NET Core，您需要按照以下说明进行操作：
- en: Download .NET Core for Windows at [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows)下载Windows的.NET
    Core。
- en: For multiple versions and a related library, visit [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有关多个版本和相关库，请访问[https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2)。
- en: Installing SQL Server
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装SQL Server
- en: 'If you do not have SQL Server  installed, you can follow these instructions:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有安装SQL Server，可以按照以下说明进行操作：
- en: Download SQL Server from the following link: [https://www.microsoft.com/en-in/download/details.aspx?id=1695](https://www.microsoft.com/en-in/download/details.aspx?id=1695).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载SQL Server：[https://www.microsoft.com/en-in/download/details.aspx?id=1695](https://www.microsoft.com/en-in/download/details.aspx?id=1695)。
- en: You can find installation instructions here: [https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017).
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在这里找到安装说明：[https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017)。
- en: For troubleshooting and for more information, refer to the following link: [https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm](https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有关故障排除和更多信息，请参考以下链接：[https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm](https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm)。
- en: Concurrency in the real world
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现实世界中的并发
- en: '**Concurrency** is a part of our life: it exists in the real world. When we
    are discussing concurrency, we are referring to multitasking.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发**是我们生活的一部分：它存在于现实世界中。当我们讨论并发时，我们指的是多任务处理。'
- en: In the real world, many of us perform multitasking frequently. For example,
    we can write a program while speaking on a mobile phone, we can watch a movie
    while having dinner, and we can sing while reading notations. There are a lot
    of examples of how we as humans can multitask. Without going into too much scientific
    detail, we can look at our brain trying to grasp new things while also commanding
    the other organs of the body to work, such as the heart or our sense of smell,
    as a form of multitasking.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，我们经常进行多任务处理。例如，我们可以在使用手机通话时编写程序，我们可以在吃饭时看电影，我们可以在阅读乐谱时唱歌。有很多例子说明我们作为人类可以进行多任务处理。不用深入科学细节，我们可以看到我们的大脑试图掌握新事物的同时，也指挥身体的其他器官工作，比如心脏或我们的嗅觉，这是一种多任务处理。
- en: The same approach applies to our systems (computers). If we think about today's
    computers, every computer that is available has a CPU of multiple cores (more
    than one core). This is to allow multiple instructions simultaneously, and let
    us perform multiple tasks at once.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的方法也适用于我们的系统（计算机）。如果我们考虑今天的计算机，每台可用的计算机都有多核CPU（多个核心）。这是为了允许同时执行多个指令，让我们能够同时执行多个任务。
- en: 'True parallelism is not possible on a single CPU machine because tasks are
    not switchable, as the CPU has a single core. It is only possible on a machine
    with multiple CPUs (multiple cores). In simple terms, concurrent programming involves
    two things:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个CPU机器上真正的并行是不可能的，因为任务是不可切换的，因为CPU只有一个核心。这只有在具有多个CPU（多个核心）的机器上才可能。简而言之，并发编程涉及两件事：
- en: '**Task management**: Managing/distributing work units to available threads.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务管理**：将工作单元分配给可用线程。'
- en: '**Communication**: This sets up the initial parameter of the task and gets
    the results.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通信**：设置任务的初始参数并获取结果。'
- en: Whenever things/tasks are happening at the same time, we call this *concurrency*.
    In our programming language, whenever any parts of our program run at the same
    time, this is called concurrent programming. You can also use **parallel programming**
    as a synonym for concurrent programming.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每当有多个事情/任务同时发生时，我们称之为*并发*。在我们的编程语言中，每当程序的任何部分同时运行时，这被称为并发编程。您也可以将**并行编程**用作并发编程的同义词。
- en: 'As an example, imagine a big conference that you need a ticket for, to gain
    entry into a specific conference hall. At the gate of a conference hall, you have
    to buy a ticket, making a payment with cash or by card. While you''re making a
    payment, the counter assistant could enter your details into the system, print
    an invoice, and provide you with the ticket. Now consider that there are more
    people who want to buy a ticket. Each person has to perform the required activities
    to collect the ticket from the ticket counter. In this case, only one person can
    be served at a time from one counter, and the rest of the people wait for their
    turn. Let''s assume that one person takes two minutes to collect their ticket
    from the counter; the next person, therefore, needs to wait for two minutes for
    their turn. Consider the wait time of the last person in line if it is a queue
    of 50 people. Things can be changed here. If there were two more ticket counters
    and every counter is performing the tasks in two minutes, this means that every
    two minutes, three people will be able to collect three tickets—or three counters
    are selling two tickets every two minutes. In other words, every ticket counter
    is performing the same task (that is, ticket selling) at the same point in time.
    This means all counters are served in parallel; therefore, they are concurrent.
    This is depicted in the following diagram:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，想象一下一个需要门票才能进入特定会议厅的大型会议。在会议厅的门口，您必须购买门票，用现金或信用卡付款。当您付款时，柜台助理可能会将您的详细信息输入系统，打印发票，并为您提供门票。现在假设还有更多人想要购买门票。每个人都必须执行必要的活动才能从售票处领取门票。在这种情况下，每次只能有一个人从一个柜台接受服务，其他人则等待他们的轮到。假设一个人从柜台领取门票需要两分钟；因此，下一个人需要等待两分钟才能轮到他们。如果排队的人数是50人，那么最后一个人的等待时间可以改变。如果有两个以上的售票柜台，每个柜台都在两分钟内执行任务，这意味着每两分钟，三个人将能够领取三张门票——或者三个柜台每两分钟卖出两张门票。换句话说，每个售票柜台都在同一时间执行相同的任务（即售票）。这意味着所有柜台都是并行服务的；因此，它们是并发的。这在下图中有所体现：
- en: '![](img/3375a9cf-5b1e-4100-bbe2-078e2b0da4a3.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3375a9cf-5b1e-4100-bbe2-078e2b0da4a3.png)'
- en: In the preceding diagram, it is clearly shown that every person who is in the
    queue is either in the wait position or is active at the counter, and there are
    three queues in which tasks are happening in a sequence. All three counters (`CounterA`,
    `CounterB`, and `CounterC`) are performing tasks at the same point in time—they
    are doing the activities in parallel.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，清楚地显示了排队的每个人都处于等待位置或者在柜台上活动，而且有三个队列，任务是按顺序进行的。所有三个柜台（`CounterA`、`CounterB`和`CounterC`）在同一时间执行任务——它们在并行进行活动。
- en: '**Concurrency** is when two or more tasks start, run, and complete in overlapping
    time periods.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发**是指两个或更多任务在重叠的时间段内开始、运行和完成。'
- en: '**Parallelism** is when two or more tasks run at the same time.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**并行性**是指两个或更多任务同时运行。'
- en: These are concurrent activities, but think of a scenario in which a huge amount
    of people are in the queue (for example, 10,000 people); there is no use in performing
    parallelism here, as this would not resolve the issue of a likely bottleneck in
    this operation. On the other hand, you can increase the number of counters to
    50\. Will they resolve this problem? These kinds of problems would occur while
    we work with any software. This is an issue that is related to blocking. In the
    upcoming sections, we will discuss concurrent programming in more detail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是并发活动，但想象一下一个巨大的人群在排队（例如，10,000人）；在这里进行并行处理是没有用的，因为这不会解决这个操作中可能出现的瓶颈问题。另一方面，您可以将柜台数量增加到50个。它们会解决这个问题吗？在我们使用任何软件时，这种问题会发生。这是一个与阻塞相关的问题。在接下来的章节中，我们将更详细地讨论并发编程。
- en: Multithreading and asynchronous programming
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程和异步编程
- en: To put it simply, we can say that multithreading means that a program is running
    parallel on multiple threads. In asynchronous programming, a unit of work runs
    separately from the main application thread, and it tells the calling thread that
    the task has completed, failed, or is in progress. The interesting issues to consider
    around asynchronous programming are when we should use it and what its benefits
    are.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们可以说多线程意味着程序在多个线程上并行运行。在异步编程中，一个工作单元与主应用程序线程分开运行，并告诉调用线程任务已完成、失败或正在进行中。在异步编程周围需要考虑的有趣问题是何时使用它以及它的好处是什么。
- en: The potential for more than one thread to access the same shared data and update
    it with unpredictable results can be referred to as a **race condition**. We have
    already discussed race condition in [Chapter 4](4f644693-85a7-4543-af8c-109d8519b2e5.xhtml),
    *Implementing Design Patterns - Basics Part 2*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 更多线程访问相同的共享数据并以不可预测的结果更新它的潜力可以称为**竞争条件**。我们已经在[第4章](4f644693-85a7-4543-af8c-109d8519b2e5.xhtml)中讨论了竞争条件，*实现设计模式
    - 基础部分2*。
- en: 'Consider the scenario we discussed in the previous section, in which people
    from a queue are collecting their tickets. Let''s try to capture this scenario
    in a multithreading program:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们在上一节讨论的场景，即排队的人们正在领取他们的票。让我们尝试在一个多线程程序中捕捉这种情况：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we have a `TicketCounter` class that represents our whole set up of ticket
    collecting counters (we discussed these in the previous section). The three methods: `CounterA()`,
    `CounterB()`, and `CounterC()` represent an individual ticket collection counter.
    These methods are simply writing a message to the console, as shown in the following
    code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个代表我们整个领取柜台设置的`TicketCounter`类（我们在上一节中讨论过这些）。三个方法：`CounterA()`，`CounterB()`和`CounterC()`代表一个单独的领取柜台。这些方法只是向控制台输出一条消息，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code is our `Program` class that is initiating the activities
    from within the `Main` method. Here, we declared and started three threads for
    all the counters. Note that we have started these threads in a sequence/order.
    As we are expect that these threads will execute in the same sequence, let''s
    run the program and see the output, as shown in the following screenshot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码是我们的`Program`类，它从`Main`方法中启动活动。在这里，我们为所有柜台声明并启动了三个线程。请注意，我们按顺序启动了这些线程。由于我们期望这些线程将按照相同的顺序执行，让我们运行程序并查看输出，如下面的屏幕截图所示：
- en: '![](img/fa77cf94-ea4a-42d7-bc79-a195f4d235f4.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa77cf94-ea4a-42d7-bc79-a195f4d235f4.png)'
- en: 'The preceding program is not executed as per the given sequence in the code.
    As per our code, the execution sequence should be as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 根据代码，上面的程序没有按照给定的顺序执行。根据我们的代码，执行顺序应该如下：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is due to threads, and these threads are working simultaneously without
    the guarantee that these should execute in the order/sequence that they have been
    declared/started in.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由于线程，这些线程在没有保证按照它们被声明/启动的顺序/序列执行的情况下同时工作。
- en: 'Once again, run the program and see whether we get the same output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行程序，看看我们是否得到相同的输出：
- en: '![](img/90eeaf02-4eb6-48ac-9280-ebae4931624c.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90eeaf02-4eb6-48ac-9280-ebae4931624c.png)'
- en: 'The preceding snapshot is showing a different output from the previous results,
    so now we have the output in sequence/order:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的快照显示了与先前结果不同的输出，所以现在我们按顺序得到了输出：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, the threads are working, but not in the sequence we defined them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，线程正在工作，但不是按照我们定义的顺序。
- en: 'You can set the priorities of threads like this: `counterC.Priority = ThreadPriority.Highest;`, `counterB.Priority
    = ThreadPriority.Normal;`, and `counterA.Priority = ThreadPriority.Lowest;`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像这样设置线程的优先级：`counterC.Priority = ThreadPriority.Highest;`，`counterB.Priority
    = ThreadPriority.Normal;`，和`counterA.Priority = ThreadPriority.Lowest;`。
- en: 'To run the threads in a synchronized way, let''s modify our code as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以同步的方式运行线程，让我们修改我们的代码如下：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We created a new `SynchronizedTicketCounter`  class with the `ShowMessage()` method;
    please note the `lock(this){...}` in the preceding code. Run the program and check
    the output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的`SynchronizedTicketCounter`类，其中包含`ShowMessage()`方法；请注意前面代码中的`lock(this){...}`。运行程序并检查输出：
- en: '![](img/485977ff-b745-40fa-9d36-b62b53858573.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/485977ff-b745-40fa-9d36-b62b53858573.png)'
- en: We have the output we expected now that our counters are serving in the right
    sequence/order.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了我们期望的输出，现在我们的柜台按照正确的顺序服务。
- en: Async/Await – why is blocking bad?
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步/等待 - 为什么阻塞是不好的？
- en: 'Asynchronous programming is very helpful in cases where we are expecting various
    activities at the same point in time. With the `async` keyword, we define our
    method/operation as asynchronous. Consider the following code snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程在我们期望在同一时间点进行各种活动的情况下非常有帮助。通过`async`关键字，我们将方法/操作定义为异步的。考虑以下代码片段：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we have a `AsyncAwait` class with an `async` method, `ShowMessage()`.
    This method is simply printing a message that would show in the console window.
    Now, whenever we call/consume this method in another code, that part of the code
    could wait/hold/block the operation until the `ShowMessage()` method executes
    and completes its task. Refer to the following snapshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个带有`async`方法`ShowMessage()`的`AsyncAwait`类。这个方法只是打印一个消息，会显示在控制台窗口中。现在，每当我们在另一个代码中调用/使用这个方法时，该部分代码可能会等待/阻塞操作，直到`ShowMessage()`方法执行并完成其任务。参考以下快照：
- en: '![](img/664b9a37-4b9d-492a-9c5c-5bf10071d809.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/664b9a37-4b9d-492a-9c5c-5bf10071d809.png)'
- en: 'Our previous screenshot says that we have set a delay of 1,000 milliseconds
    for our `ShowMessage()` method. Here, we instructed the program to complete after
    1,000 milliseconds. If we try to remove `await` from the previous code, Visual
    Studio will immediately give the warning to put `await` back in; see the following
    snapshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的屏幕截图显示，我们为我们的`ShowMessage()`方法设置了1,000毫秒的延迟。在这里，我们指示程序在1,000毫秒后完成。如果我们尝试从先前的代码中删除`await`，Visual
    Studio将立即发出警告，要求将`await`放回去；参考以下快照：
- en: '![](img/90f87239-59f6-4cac-9693-651c66c8facd.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90f87239-59f6-4cac-9693-651c66c8facd.png)'
- en: 'With the help of the `await` operator, we are using non-blocking API calls.
    Run the program and see the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`await`运算符的帮助，我们正在使用非阻塞API调用。运行程序并查看以下输出：
- en: '![](img/773d415b-b503-4812-b93d-36d7d3aeb4ed.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/773d415b-b503-4812-b93d-36d7d3aeb4ed.png)'
- en: We will get the output that is shown in the preceding snapshot.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到如前面快照中所示的输出。
- en: Concurrent collections
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发集合
- en: 'The .NET Core framework provides a variety of collections with which we can
    use LINQ queries. As a developer, there are far fewer options when looking for
    thread-safe collections. Without thread-safe collections, it can become difficult
    for developers when they have to perform multiple operations. In this case, we
    would meet the race condition that we have already discussed in [Chapter 4](4f644693-85a7-4543-af8c-109d8519b2e5.xhtml), *Implementing
    Design Patterns - Basics Part 2*. To overcome such situations, we need to use
    the `lock` statement, as we have used in the previous section. For example, we
    can write a code of a simplified implementation of the `lock` statement—refer
    to the following code snippet, where we have used the `lock` statement and collection
    class, `Dictionary`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core框架提供了各种集合，我们可以使用LINQ查询。作为开发人员，在寻找线程安全集合时，选择余地要少得多。没有线程安全的集合，开发人员在执行多个操作时可能会变得困难。在这种情况下，我们将遇到我们已经在[第4章](4f644693-85a7-4543-af8c-109d8519b2e5.xhtml)中讨论过的竞争条件。为了克服这种情况，我们需要使用`lock`语句，就像我们在前一节中使用的那样。例如，我们可以编写一个简化的`lock`语句的实现代码-参考以下代码片段，我们在其中使用了`lock`语句和集合类`Dictionary`：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code is from `InventoryContext`; in this code, we are blocking
    other threads from locking the operation in which we are trying to update the
    quantity.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码来自`InventoryContext`；在这段代码中，我们正在阻止其他线程锁定我们正在尝试更新数量的操作。
- en: The main drawback of the `Dictionary` collection class is that it is not thread-safe.
    We have to use this in the `lock` statement while we're using `Dictionary` with
    multiple threads. To make our code thread-safe, we can use the `ConcurrentDictionary`
    collection class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dictionary`集合类的主要缺点是它不是线程安全的。当我们在多个线程中使用`Dictionary`时，我们必须在`lock`语句中使用它。为了使我们的代码线程安全，我们可以使用`ConcurrentDictionary`集合类。'
- en: '`ConcurrentDictionary` is a thread-safe collection class and stores key-value
    pairs. This class has the implementation for the `lock` statement and provides
    a thread-safe class. Consider the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentDictionary`是一个线程安全的集合类，它存储键值对。这个类有`lock`语句的实现，并提供了一个线程安全的类。考虑以下代码：'
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code snippet is from the `InventoryContext` class of our FlixOne
    console application. In this code, we have the `_books` field, and it is initialized
    as a `ConcurrentDictionary` collection class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段来自我们的FlixOne控制台应用程序的`InventoryContext`类。在这段代码中，我们有`_books`字段，并且它被初始化为`ConcurrentDictionary`集合类。
- en: As we are using the `UpdateQuantity()` method of the `InventoryContext` class
    in multithreads, there is a chance that one thread adds the quantity, while the
    other thread resets the quantity to its initial level. This happens because our
    object is from a single collection, and any changes to the collection in one thread
    are not visible to the other threads. All threads are referencing the original
    unmodified collection, and, in simple terms, our method is not thread-safe, unless
    we use the `lock` statement or the `ConcurretDictionary` collection class.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在多线程中使用`InventoryContext`类的`UpdateQuantity()`方法，有一种可能性是一个线程增加数量，而另一个线程将数量重置为其初始水平。这是因为我们的对象来自单个集合，对集合的任何更改在一个线程中对其他线程不可见。所有线程都引用原始未修改的集合，简单来说，我们的方法不是线程安全的，除非我们使用`lock`语句或`ConcurretDictionary`集合类。
- en: Patterns and practices – TDD and Parallel LINQ
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式和实践- TDD和并行LINQ
- en: While we work with multithreading, we should follow best practices to write
    a **smooth code**. A smooth code is where a developer doesn't face deadlock. In
    other words, multithreading requires a lot of care during the writing process.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用多线程时，我们应该遵循最佳实践来编写**流畅的代码**。流畅的代码是指开发人员不会面临死锁的代码。换句话说，在编写过程中，多线程需要非常小心。
- en: While multiple threads are running in a class/program, deadlock occurs when
    each thread approaches the object or resource written under a `lock` statement.
    The actual deadlock occurs when each thread approaches to lock an object/resource
    that is already locked by another thread.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个线程在一个类/程序中运行时，当每个线程接近在`lock`语句下编写的对象或资源时，死锁就会发生。实际的死锁发生在每个线程都试图锁定另一个线程已经锁定的对象/资源时。
- en: A small mistake can result in developers having to tackle unknown bugs that
    occur due to threads that are blocked. In addition to this, a bad implementation
    of a few words in the code can impact 100 lines of code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小错误可能导致开发人员不得不处理由于被阻塞的线程而发生的未知错误。除此之外，代码中几个字的错误实现可能会影响100行代码。
- en: 'Let''s go back to our example of conference tickets, which we discussed at
    the beginning of this chapter. What would happen if ticket counters are unable
    to serve their purpose and distribute tickets? In this scenario, each person would
    try to reach a ticket counter and obtain a ticket, which could jam the ticket
    counter. This could cause the ticket counter to become blocked. The same logic
    applies to our program. We''d meet a deadlock situation in which multiple threads
    would try to lock our object/resource. The best practice to use to avoid such
    a condition is using a mechanism that synchronizes access to the object/resource.
    The .NET Core framework provides a `Monitor` class to achieve this. I have rewritten
    our old code to avoid a deadlock situation—see the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到本章开头讨论的会议门票的例子。如果售票处无法履行其职责并分发门票会发生什么？在这种情况下，每个人都会尝试到达售票处并获取门票，这可能会导致售票处被堵塞。这可能会导致售票处被阻塞。相同的逻辑适用于我们的程序。我们将遇到多个线程尝试锁定我们的对象/资源的死锁情况。避免这种情况的最佳做法是使用一种同步访问对象/资源的机制。.NET
    Core框架提供了`Monitor`类来实现这一点。我已经重新编写了我们的旧代码以避免死锁情况-请参阅以下代码：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we have the `ProcessTicket` method; it starts three threads (each thread
    represents each ticket counter). Every thread is reaching to `ShowMessage` of
    the `TicketCounter` class. There will be a problem of deadlock if our `ShowMessage`
    method is not written well to handle this situation. All three threads will try
    to acquire a lock for the respective object/resource related to the `ShowMessage`
    method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有`ProcessTicket`方法；它启动了三个线程（每个线程代表一个售票处）。每个线程都会到达`TicketCounter`类的`ShowMessage`。如果我们的`ShowMessage`方法没有很好地编写来处理这种情况，就会出现死锁问题。所有三个线程都将尝试为与`ShowMessage`方法相关的各自对象/资源获取锁。
- en: 'The following code is the implementation of the `ShowMessage` method, and I
    have written this code to handle a deadlock situation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`ShowMessage`方法的实现，我编写了这段代码来处理死锁情况：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding is the `ShowMessage()` method of our `TicketCounter` class. In
    this method, whenever a thread will try to lock `Object`, if `Object` is already
    locked, it tries for 300 milliseconds. The `Monitor` class handles this situation
    automatically. When using the `Monitor` class, the developer does not need to
    worry about a situation in which multiple threads are running, and each of these
    threads is trying to acquire the lock. Run the program to see the following output:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上述是我们`TicketCounter`类的`ShowMessage()`方法。在这个方法中，每当一个线程尝试锁定`Object`时，如果`Object`已经被锁定，它会尝试300毫秒。`Monitor`类会自动处理这种情况。使用`Monitor`类时，开发人员不需要担心多个线程正在运行的情况，每个线程都在尝试获取锁。运行程序以查看以下输出：
- en: '![](img/b5992517-e5e5-490e-bb0a-ef9d708e0994.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5992517-e5e5-490e-bb0a-ef9d708e0994.png)'
- en: 'In the preceding snapshot, you will notice that after `counterA`, `counterC`
    is serving and then `counter B`. This means that after `thread A`, `thread C`
    was initiated, and then `thread B`. In other words, `thread A` acquires the lock
    first, and after 300 milliseconds, `thread C` tries to lock, and then `thread
    B` tries to lock the object. If you want to set the order or priorities of the
    thread, you can add the following lines of code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的快照中，您会注意到在`counterA`之后，`counterC`正在服务，然后是`counter B`。这意味着在`thread A`之后，`thread
    C`被启动，然后是`thread B`。换句话说，`thread A`首先获取锁，然后在300毫秒后，`thread C`尝试获取锁，然后`thread B`尝试锁定对象。如果要设置线程的顺序或优先级，可以添加以下代码行：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When you add the preceding lines to the `ProcessTickets` method, all the threads
    will work: first `Thread C`, then `Thread B`, and, finally, `Thread A`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将上述行添加到`ProcessTickets`方法时，所有线程将按顺序工作：首先是`Thread C`，然后是`Thread B`，最后是`Thread
    A`。
- en: 'Thread priorities are an enum that tells us how to schedule the thread and
    `System.Threading.ThreadPriority` with the following values:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 线程优先级是一个枚举，告诉我们如何调度线程和`System.Threading.ThreadPriority`具有以下值：
- en: '**Lowest**: This is the least priority, which means threads with the `Lowest`
    priority can be scheduled after the threads of any other priority.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lowest**：这是最低的优先级，意味着具有`Lowest`优先级的线程可以在任何其他优先级的线程之后进行调度。'
- en: '**BelowNormal**: Threads with a `BelowNormal` priority can be scheduled after
    threads having a `Normal` priority, but before threads having the `Lowest` priority.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BelowNormal**：具有`BelowNormal`优先级的线程可以在具有`Normal`优先级的线程之后，但在具有`Lowest`优先级的线程之前进行调度。'
- en: '**Normal**: All threads are having the default priority as `Normal`. Threads
    with a `Normal` priority can be scheduled after threads having an `AboveNormal`
    priority, but before those threads that have a `BelowNormal` priority.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Normal**：所有线程都具有默认优先级`Normal`。具有`Normal`优先级的线程可以在具有`AboveNormal`优先级的线程之后，但在具有`BelowNormal`优先级的线程之前进行调度。'
- en: '**AboveNormal**: Threads with an `AboveNormal` priority can be scheduled before
    threads having a `Normal` priority, but after threads having the `Highest` priority.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AboveNormal**：具有`AboveNormal`优先级的线程可以在具有`Normal`优先级的线程之前，但在具有`Highest`优先级的线程之后进行调度。'
- en: '**Highest**: This is the top-most priority level of threads. Threads with the `Highest`
    priority can be scheduled before threads having any other priority.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Highest**：这是线程的最高优先级级别。具有`Highest`优先级的线程可以在具有任何其他优先级的线程之前进行调度。'
- en: 'After setting a priority level for the threads, execute the program and see
    the following output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在为线程设置优先级级别后，执行程序并查看以下输出：
- en: '![](img/ceaf2e4f-1185-4ac0-aa88-bf90055500bf.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ceaf2e4f-1185-4ac0-aa88-bf90055500bf.png)'
- en: As per the preceding snapshot, after setting the priority, the counters are
    serving in the order `C`, `B`, and `A`. With a little caution and simple implementation,
    we can handle a deadlock situation as well as schedule our threads to be served
    in a specific order/priority.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上面的快照，在设置了优先级后，计数器按顺序为`C`，`B`和`A`提供服务。通过小心和简单的实现，我们可以处理死锁情况，并安排我们的线程按特定顺序/优先级提供服务。
- en: The .Net Core framework also provides a **Task Parallel Library** (**TPL**)
    that is a set of public APIs that belong to the `System.Threading` and `System.Threading.Tasks`
    namespaces. With the help of TPL, developers can make applications concurrent
    by adapting its simplification implementation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core框架还提供了**任务并行库**（**TPL**），它是属于`System.Threading`和`System.Threading.Tasks`命名空间的一组公共API。借助TPL，开发人员可以通过简化实现使应用程序并发运行。
- en: 'Considering the following code, we can see the simplest implementation of a
    TPL:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，我们可以看到TPL的最简单实现：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding is a simple `ForEach` loop using a `Parallel` keyword. In the
    preceding code, we are just iterating a collection of `books` and processing it
    with the use of the `Process` method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上面是一个简单的使用`Parallel`关键字的`ForEach`循环。在上面的代码中，我们只是遍历了一个`books`集合，并使用`Process`方法进行处理：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code is our `Process` method (again, the simplest one), and it
    prints the details of the `books`. As per their requirement, users can perform
    as many actions as they want:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是我们的`Process`方法（再次强调，这是最简单的方法），它打印了`books`的细节。根据他们的要求，用户可以执行尽可能多的操作：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, we have the `ParallelismExample` method, and it generates the
    book list and processes the books by executing the `PallelVersion` method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有`ParallelismExample`方法，它生成书籍列表并通过执行`PallelVersion`方法处理书籍。
- en: 'Before you execute the program to see the following output, first consider
    the following code snippet of sequential implementation:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行程序以查看以下输出之前，首先考虑顺序实现的以下代码片段：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code is a `Sequential` method; it uses a simple `foreach` loop
    to process the book collections. Execute the program and see the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码是一个`Sequential`方法；它使用简单的`foreach`循环来处理书籍集合。执行程序并查看以下输出：
- en: '![](img/fcc24a14-5414-42e8-b803-a9dc83c0429f.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fcc24a14-5414-42e8-b803-a9dc83c0429f.png)'
- en: 'Take note of the preceding snapshot. First, there are four processes running
    in the system on which I am running this demo. The second iterated collection
    is in a sequence/order from 1 to 19\. The program does not divide the tasks into
    different processes running on the machine. Press any key to exit from the current
    process, execute the program for the `ParallelismVersion` method, and see the
    following output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上面的快照。首先，在我运行此演示的系统上有四个进程正在运行。第二个迭代的集合是按顺序从1到19。程序不会将任务分成在机器上运行的不同进程。按任意键退出当前进程，执行`ParallelismVersion`方法的程序，并查看以下输出：
- en: '![](img/a2119c1f-765c-4c1f-8350-971f9b585cab.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2119c1f-765c-4c1f-8350-971f9b585cab.png)'
- en: The preceding screenshot is of an output from a parallel code; you may notice
    that the code is not processed in sequence and the IDs are not coming through
    in sequence/order, as we can see `Id` `13` comes after `9` but before `10`. If
    these were running in sequence, then the order of the `Id`s would be `9`, `10`,
    and then `13`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图是并行代码的输出；您可能会注意到代码没有按顺序处理，ID也没有按顺序出现，我们可以看到`Id` `13`在`9`之后但在`10`之前。如果这些是按顺序运行的，那么`Id`的顺序将是`9`，`10`，然后是`13`。
- en: LINQ was in the .NET world a long time before the birth of .NET Core. `LINQ-to-Objects`
    allows us to perform in-memory query operations by using arbitrary sequences of
    objects. `LINQ-to-Objects` is a collection of extension methods on top of `IEnumerable<T>`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Core诞生之前，LINQ就已经存在于.NET世界中。`LINQ-to-Objects`允许我们使用任意对象序列执行内存中的查询操作。`LINQ-to-Objects`是建立在`IEnumerable<T>`之上的一组扩展方法。
- en: '**Deferred execution** means execution happens once the data is enumerated.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**延迟执行**意味着数据枚举后才执行。'
- en: 'PLINQ can be used as an alternative to TPL. It is a parallel implementation
    of LINQ. The PLINQ query operates on in-memory `IEnumerable` or `IEnumerable<T>`
    data sources. Also, it has a deferred execution. The LINQ query performs operations
    in sequence, while PLINQ executes operations in parallel and makes full use of
    all the processors on the machine. Consider the following code to see the implementation
    of PLINQ:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ可以作为TPL的替代方案。它是LINQ的并行实现。PLINQ查询操作在内存中的`IEnumerable`或`IEnumerable<T>`数据源上执行。此外，它具有延迟执行。LINQ查询按顺序执行操作，而PLINQ并行执行操作，并充分利用机器上的所有处理器。考虑以下代码以查看PLINQ的实现：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code is the process method of our PLINQ class. Here, we are using
    PLINQ to query any books in stock with a quantity of more than `12250`. Execute
    the code to see this output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码是我们的PLINQ类的处理方法。在这里，我们使用PLINQ查询库存中数量超过`12250`的任何书籍。执行代码以查看此输出：
- en: '![](img/e1c27ddb-a490-46ce-8df1-1ade2ec4f248.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1c27ddb-a490-46ce-8df1-1ade2ec4f248.png)'
- en: 'PLINQ uses all the processors of a machine, but we can limit the processors
    in PLINQ by using the `WithDegreeOfParallelism()` method. We can use the following
    code in our `Process ()` method of the `Linq` class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ使用机器的所有处理器，但我们可以通过使用`WithDegreeOfParallelism()`方法来限制PLINQ中的处理器。我们可以在`Linq`类的`Process()`方法中使用以下代码：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code will use only three processors of the machine. Execute them,
    and you'll find that you get the same output as in the case of the previous code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将只使用机器的三个处理器。执行它们，您会发现您得到与前面代码相同的输出。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed concurrent programming and concurrency in the
    real world. We looked at how we can handle various scenarios related to concurrency
    in our day-to-day life. We looked at collecting conference tickets from serving
    counters, and we understood what parallel programming and concurrent programming
    are. We have also covered multithreading, `Async`/`Await`, `Concurrent` collection,
    and PLINQ.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了并发编程和现实世界中的并发性。我们看了看如何处理与我们日常生活中的并发相关的各种情景。我们看了看如何从服务柜台收集会议门票，并了解了并行编程和并发编程是什么。我们还涵盖了多线程、`Async`/`Await`、`Concurrent`集合和PLINQ。
- en: In the upcoming chapter, we will get a taste of functional programming using
    the C# language. We will dive deeper into the concepts that show us how to use
    C# in .NET Core to perform functional programming.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将尝试使用C#语言进行函数式编程。我们将深入探讨这些概念，以展示如何在.NET Core中使用C#进行函数式编程。
- en: Questions
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题将帮助您巩固本章中包含的信息：
- en: What is concurrent programming?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是并发编程？
- en: How does true parallelism happen?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真正的并行性是如何发生的？
- en: What is the race condition?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是竞争条件？
- en: Why should we use a concurrent dictionary?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们应该使用并发字典？
- en: Further reading
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following book will help you learn more about the topics that have been
    covered in this chapter:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下书籍将帮助您更多地了解本章涉及的主题：
- en: '*Concurrent Patterns and Best Practices*, by *Atul S Khot*, published by *Packt
    Publishing*: [https://www.packtpub.com/in/application-development/concurrent-patterns-and-best-practices](https://www.packtpub.com/in/application-development/concurrent-patterns-and-best-practices)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Concurrent Patterns and Best Practices*，作者*Atul S Khot*，由*Packt Publishing*出版：[https://www.packtpub.com/in/application-development/concurrent-patterns-and-best-practices](https://www.packtpub.com/in/application-development/concurrent-patterns-and-best-practices)'

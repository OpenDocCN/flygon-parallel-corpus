- en: Creating a Set of Cooperating Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一组协作微服务
- en: In this chapter, we will build our first couple of microservices. We will learn
    how to create cooperating microservices with minimalistic functionality. In upcoming
    chapters, we will add more and more functionality to these microservices. By the
    end of this chapter, we will have a RESTful API exposed by a composite microservice.
    The composite microservice will call three other microservices using their RESTful
    API's to create an aggregated response.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建我们的第一对微服务。我们将学习如何创建具有最小功能的协作微服务。在接下来的章节中，我们将为这些微服务添加越来越多的功能。到本章结束时，我们将拥有一个由复合微服务公开的RESTful
    API。复合微服务将使用其RESTful API调用其他三个微服务，以创建一个聚合响应。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing the microservice landscape
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍微服务景观
- en: Generating skeleton microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成骨架微服务
- en: Adding RESTful APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加RESTful API
- en: Adding a composite microservice
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加复合微服务
- en: Adding error handling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加错误处理
- en: Testing the APIs manually
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动测试APIs
- en: Adding automated tests of microservices in isolation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在隔离的微服务中添加自动化测试
- en: Adding semi-automated tests to a microservice landscape
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向微服务景观添加半自动化测试
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All of the commands that are described in this book are run on a MacBook Pro
    using macOS Mojave but should be straightforward to modify so that they can be
    run on another platform such as Linux or Windows.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的所有命令都是在使用macOS Mojave的MacBook Pro上运行的，但应该很容易修改，以便在其他平台（如Linux或Windows）上运行。
- en: Tool installation
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具安装
- en: 'To be able to execute the commands that are used in this chapter, you need
    to have the following tools installed on your computer:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够执行本章中使用的命令，您需要在计算机上安装以下工具：
- en: '**Git: **Can be downloaded and installed from [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Git：**可以从[https://git-scm.com/downloads](https://git-scm.com/downloads)下载和安装。'
- en: '**Java: **Can be downloaded and installed from [https://www.oracle.com/technetwork/java/javase/downloads/index.html](https://www.oracle.com/technetwork/java/javase/downloads/index.html).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java：**可以从[https://www.oracle.com/technetwork/java/javase/downloads/index.html](https://www.oracle.com/technetwork/java/javase/downloads/index.html)下载和安装。'
- en: '`curl`: This command-line tool for testing HTTP-based APIs can be downloaded
    and installed from [https://curl.haxx.se/download.html](https://curl.haxx.se/download.html).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`curl`：这个用于测试基于HTTP的API的命令行工具可以从[https://curl.haxx.se/download.html](https://curl.haxx.se/download.html)下载和安装。'
- en: '`jq`: This command-line JSON processor can be downloaded and installed from [https://stedolan.github.io/jq/download/](https://stedolan.github.io/jq/download/).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jq`：这个命令行JSON处理器可以从[https://stedolan.github.io/jq/download/](https://stedolan.github.io/jq/download/)下载和安装。'
- en: '**Spring Boot CLI**: This command-line tool for Spring Boot applications can
    be downloaded and installed from [https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started-installing-spring-boot.html#getting-started-installing-the-cli](https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started-installing-spring-boot.html#getting-started-installing-the-cli).'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Boot CLI**：这个用于Spring Boot应用的命令行工具可以从[https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started-installing-spring-boot.html#getting-started-installing-the-cli](https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started-installing-spring-boot.html#getting-started-installing-the-cli)下载和安装。'
- en: Installing Homebrew
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Homebrew
- en: 'To install these tools on macOS, I recommend that you use Homebrew, [https://brew.sh/](https://brew.sh/).
    If you don''t have it installed, you can install it with the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要在macOS上安装这些工具，我建议您使用Homebrew，[https://brew.sh/](https://brew.sh/)。如果您尚未安装，可以使用以下命令进行安装：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Installing the command-line tools for Xcode installs Homebrew, so it might take
    a while if you don't have it installed already.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Xcode的命令行工具安装Homebrew，因此如果您尚未安装，可能需要一些时间。
- en: 'Verify the installation of Homebrew with the following commands:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '使用以下命令验证Homebrew的安装： '
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Expect a response such as the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 期望得到以下响应：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using Homebrew to install Java, curl, jq, and the Spring Boot CLI
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Homebrew安装Java、curl、jq和Spring Boot CLI
- en: 'On a macOS, `curl` is already preinstalled and `git` was installed as part
    of the installation of Homebrew. The remaining tools can be installed on a macOS
    using Homebrew with the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，`curl`已经预装，`git`是作为Homebrew的安装的一部分安装的。剩下的工具可以使用以下命令在macOS上使用Homebrew安装：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The installation of these tools can be verified by the following commands:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下命令验证这些工具的安装：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These commands will return something like the following (some extra irrelevant
    output was removed):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将返回类似以下内容（一些额外的无关输出已被删除）：
- en: '![](img/cf7decb8-42ed-41c9-a9fe-6143e7d1c0e5.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf7decb8-42ed-41c9-a9fe-6143e7d1c0e5.png)'
- en: Using an IDE
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IDE
- en: I recommend that you work with your Java code using an IDE that supports the
    development of Spring Boot applications such as Spring Tool Suite or IntelliJ
    IDEA Ultimate Edition. See the *Testing APIs manually* section to learn how to
    use the Spring Boot Dashboard. However, you don't need an IDE to be able to follow
    the instructions in this book.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您使用支持Spring Boot应用开发的IDE（如Spring Tool Suite或IntelliJ IDEA Ultimate Edition）来处理Java代码。请参阅*手动测试API*部分，了解如何使用Spring
    Boot Dashboard。但是，您不需要IDE就能按照本书中的说明进行操作。
- en: Accessing the source code
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问源代码
- en: 'The source code for this chapter can be found in this book''s GitHub repository:
    [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter03).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在本书的GitHub存储库中找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter03)。
- en: 'To be able to run the commands that are described in this book, download the
    source code to a folder and set up an environment variable, `$BOOK_HOME`, that
    points to that folder. Some sample commands are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行本书中描述的命令，下载源代码到一个文件夹并设置一个环境变量`$BOOK_HOME`，指向该文件夹。一些示例命令如下：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Java source code is written for Java 8 and tested to run on Java 12\. To
    avoid some problems with Spring Boot 2.0 (and Spring 5.0), this chapter uses Spring
    Boot 2.1.0 RC1 (and Spring 5.1.1), the latest available version of Spring Boot
    at the time of writing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Java源代码是为Java 8编写的，并经过测试可以在Java 12上运行。为了避免一些与Spring Boot 2.0（和Spring 5.0）相关的问题，本章使用了Spring
    Boot 2.1.0 RC1（和Spring 5.1.1），这是写作时可用的最新版本的Spring Boot。
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter03`
    but are in many cases edited to remove irrelevant parts of the source code, such
    as comments, imports, and log statements.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例都来自`$BOOK_HOME/Chapter03`中的源代码，但在许多情况下被编辑以删除源代码的无关部分，如注释、导入和日志语句。
- en: With this, we have the required tools installed and the source code for the
    chapter downloaded. In the next section, we will learn about the system landscape
    of cooperating microservices that we will create in this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经安装了所需的工具，并下载了本章的源代码。在下一节中，我们将了解本章中将创建的合作微服务的系统景观。
- en: Introducing the microservice landscape
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍微服务景观
- en: 'In [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml), *Introduction to
    Microservices*, we were briefly introduced to the microservice-based system landscape
    that we will use throughout this book:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml)中，*微服务简介*，我们简要介绍了本书中将使用的基于微服务的系统景观：
- en: '![](img/cf74f5f6-c0f7-471c-8eae-a2566ecee996.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf74f5f6-c0f7-471c-8eae-a2566ecee996.png)'
- en: It consists of three core microservices, the **Product**, **Review**, and **Recommendation**
    services, all of which deal with one type of resource, and a composite microservice
    called the **Product Composite** service, which aggregates information from the
    three core services.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 它由三个核心微服务组成，**产品**，**评论**和**推荐**服务，它们都处理一种类型的资源，以及一个名为**产品组合**服务的组合微服务，它从三个核心服务中聚合信息。
- en: Temporarily replacing a discovery service
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 临时替换发现服务
- en: 'Since, at this stage, we don''t have any service discovery mechanism in place,
    we will use hardcoded port numbers for each microservice. We will use the following
    ports:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在这个阶段，我们还没有任何服务发现机制，我们将为每个微服务使用硬编码端口号。我们将使用以下端口：
- en: 'Product composite service: `7000`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品组合服务：`7000`
- en: 'Product service: `7001`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品服务：`7001`
- en: 'Review service: `7002`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评论服务：`7002`
- en: Recommendation service: `7003`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐服务：`7003`
- en: We will get rid of the hardcoded ports later when we start using Docker and
    Kubernetes!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始使用Docker和Kubernetes时，我们将摆脱硬编码端口！
- en: In this section, we have been introduced to the microservices we are going to
    create and the information that they will handle. In the next section, we will
    use Spring Initializr to create skeleton code for the microservices.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经介绍了我们将要创建的微服务以及它们将处理的信息。在下一节中，我们将使用Spring Initializr为微服务创建骨架代码。
- en: Information handled by microservices
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务处理的信息
- en: To keep the source code examples in this book easy to understand, they have
    a minimal amount of business logic. The information model for the business objects
    they process is kept minimal for the same reason. In this section, we will go
    through the information that's handled by each microservice, plus infrastructure-related
    information that microservices handle.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本书中的源代码示例易于理解，它们具有最少的业务逻辑。它们处理的业务对象的信息模型也保持最小。在本节中，我们将介绍每个微服务处理的信息，以及微服务处理的基础设施相关信息。
- en: Product service
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品服务
- en: 'The `product` service manages product information and describes each product
    with the following attributes:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`product`服务管理产品信息，并使用以下属性描述每个产品：'
- en: Product ID
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品ID
- en: Name
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称
- en: Weight
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重量
- en: Review service
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评论服务
- en: 'The `review` service manages product reviews and stores the following information
    about each review:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`review`服务管理产品评论，并存储有关每个评论的以下信息：'
- en: Product ID
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品ID
- en: Review ID
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评论ID
- en: Author
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者
- en: Subject
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题
- en: Content
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容
- en: Recommendation service
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐服务
- en: 'The `recommendation` service manages product recommendations and stores the
    following information about each recommendation:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`recommendation`服务管理产品推荐，并存储有关每个推荐的以下信息：'
- en: Product ID
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品ID
- en: Recommendation ID
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐ID
- en: Author
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者
- en: Rate
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 费率
- en: Content
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容
- en: Product composite service
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品组合服务
- en: 'The product composite service aggregates information from the three core services
    and presents information about a product as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 产品组合服务从三个核心服务中聚合信息，并按以下方式呈现有关产品的信息：
- en: Product information, as described in the `product` service
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品信息，如`product`服务中所述
- en: A list of product reviews for the specified product, as described in the `review`
    service
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定产品的产品评论列表，如`review`服务中所述
- en: A list of product recommendations for the specified product, as described in
    the `recommendation` service
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定产品的产品推荐列表，如`recommendation`服务中所述
- en: Infrastructure-related information
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施相关信息
- en: Once we start to run our microservices as containers that are managed by the
    infrastructure (first Docker and later on Kubernetes), it will be of interest
    to track which container actually responded to our requests. To simplify this
    tracking, we have also added a `serviceAddress` attribute to all our responses, formatted
    as `hostname/ip-address:port`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始将我们的微服务作为由基础设施管理的容器运行（首先是Docker，以后是Kubernetes），跟踪哪个容器实际上响应了我们的请求将成为一个感兴趣的问题。为了简化这种跟踪，我们还在所有响应中添加了一个`serviceAddress`属性，格式为`hostname/ip-address:port`。
- en: Generating skeleton microservices
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成骨架微服务
- en: Now it's time to see how we can create projects for our microservices. The final
    result for this topic can be found in the `$BOOK_HOME/Chapter03/1-spring-init`folder.
    To simplify setting up the projects, we will use Spring Initializr to generate
    a skeleton project for each microservice. A skeleton project contains the necessary
    files for building the project, along with an empty `main` class and test class
    for the microservice. After that, we will see how we can build all our microservices
    with one command using multi-project builds in the build tool that we will use,
    Gradle.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看我们如何为我们的微服务创建项目了。本主题的最终结果可以在`$BOOK_HOME/Chapter03/1-spring-init`文件夹中找到。为了简化项目的设置，我们将使用Spring
    Initializr为每个微服务生成一个骨架项目。骨架项目包含构建项目所需的必要文件，以及一个空的`main`类和微服务的测试类。之后，我们将看到如何使用我们将使用的构建工具Gradle中的多项目构建来使用一个命令构建所有的微服务。
- en: Using Spring Initializr to generate skeleton code
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Initializr生成骨架代码
- en: To get started with developing our microservices, we will use a tool called
    **Spring Initializr** to generate skeleton code for us. It can either be invoked
    from a web browser using the [https://start.spring.io/](https://start.spring.io/) URL
    or by a command-line tool, `spring init`. To make it easier to reproduce the creation
    of the microservices, we will use the command-line tool.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始开发我们的微服务，我们将使用一个名为**Spring Initializr**的工具为我们生成骨架代码。它可以通过[https://start.spring.io/](https://start.spring.io/)网址从Web浏览器中调用，也可以通过命令行工具`spring
    init`调用。为了更容易地重现微服务的创建，我们将使用命令行工具。
- en: 'For each microservice, we will create a Spring Boot project which does the
    following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个微服务，我们将创建一个Spring Boot项目，该项目将执行以下操作：
- en: Uses Gradle as a build tool
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gradle作为构建工具
- en: Generates code for Java 8
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成了Java 8的代码
- en: Packages the project as a fat JAR file
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目打包为一个fat JAR文件
- en: Brings in dependencies for the `Actuator` and `WebFlux` Spring modules
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入了`Actuator`和`WebFlux` Spring模块的依赖项
- en: Is based on Spring Boot v2.1.0 RC1 (which depends on Spring Framework v5.1.1)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Spring Boot v2.1.0 RC1（依赖于Spring Framework v5.1.1）
- en: Spring Boot Actuator enables a number of valuable endpoints for management and
    monitoring. We will see them in action later on. Spring WebFlux will be used here
    to create our RESTful APIs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot Actuator为管理和监控启用了许多有价值的端点。我们稍后将看到它们的作用。Spring WebFlux将在这里用于创建我们的RESTful
    API。
- en: 'To create skeleton code for our microservices, we need to run the following
    command for `product-service`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的微服务创建骨架代码，我们需要运行以下命令来为`product-service`创建：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you want to learn more about the `spring init` CLI, you can run the `spring
    help init` command. To see what dependencies you can add, run the `spring init
    --list` command.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于`spring init` CLI的信息，可以运行`spring help init`命令。要查看可以添加的依赖项，运行`spring
    init --list`命令。
- en: 'If you want to create the four projects on your own instead of using the source
    code in this book''s GitHub repository, try out `$BOOK_HOME/Chapter03/1-spring-init/create-projects.bash`,
    as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想自己创建这四个项目，而不是使用本书GitHub存储库中的源代码，请尝试`$BOOK_HOME/Chapter03/1-spring-init/create-projects.bash`，如下所示：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After creating our four projects using `create-projects.bash`, we will have
    the following file structure:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`create-projects.bash`创建我们的四个项目后，我们将拥有以下文件结构：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For each project, we can list the created files. Let''s do this for the `product-service`
    project:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个项目，我们可以列出创建的文件。让我们为`product-service`项目做这个：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will receive the following output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收到以下输出：
- en: '![](img/21a0ab5c-8c4c-4898-9cab-598833bd976f.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21a0ab5c-8c4c-4898-9cab-598833bd976f.png)'
- en: 'Spring Initializr created a number of files for Gradle, including a `.gitignore`
    file and three Spring Boot files:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Initializr为Gradle创建了许多文件，包括一个`.gitignore`文件和三个Spring Boot文件：
- en: '`ProductServiceApplication.java`, our main application class'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductServiceApplication.java`，我们的主应用程序类'
- en: '`application.properties`, an empty property file'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application.properties`，一个空的属性文件'
- en: '`ProductServiceApplicationTests.java`, a test class that''s been configured
    to run tests on our Spring Boot application using JUnit'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductServiceApplicationTests.java`，一个已配置为使用JUnit在我们的Spring Boot应用程序上运行测试的测试类'
- en: 'The `main` application class, `ProductServiceApplication.java`, looks as we''d
    expect based on the previous chapter:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`应用程序类`ProductServiceApplication.java`，根据前一章的预期，看起来如下：'
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The test class looks as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类如下所示：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `@RunWith(SpringRunner.class)` and `@SpringBootTest` annotations will initialize
    our application in the same way as `@SpringBootApplication` does when running
    the application; that is, the Spring application context will be set up before
    the tests are executed using component scanning and auto-configuration, as described
    in the previous chapter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RunWith(SpringRunner.class)`和`@SpringBootTest`注解将以与运行应用程序时`@SpringBootApplication`相同的方式初始化我们的应用程序；也就是说，在执行测试之前，将使用组件扫描和自动配置设置Spring应用程序上下文，如前一章所述。'
- en: 'Let''s also look at the most important Gradle file, `build.gradle`. The content
    of this file describes how to build the project, for example, compile, test, and
    package the source code. The Gradle file starts by setting up the conditions for
    the rest of the build file by declaring the `buildscript` element and listing
    what plugins to apply:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也看看最重要的Gradle文件`build.gradle`。该文件的内容描述了如何构建项目，例如编译、测试和打包源代码。Gradle文件通过声明`buildscript`元素并列出要应用的插件来设置构建文件的其余条件：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s explain the preceding source code in more detail:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释前面的源代码：
- en: The Spring Boot version is set to what we specified when we ran the `spring
    init` command, `2.1.0.RC1`.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot版本设置为我们在运行`spring init`命令时指定的版本`2.1.0.RC1`。
- en: A number of Gradle plugins are declared. The most important ones are the `org.springframework.boot` and `io.spring.dependency-management` plugins,
    which together ensure that Gradle will build a fat JAR file and that we don't
    need to specify any explicit version numbers on our Spring Boot starter dependencies.
    Instead, they are implied by the `springBootVersion` property.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明了许多Gradle插件。最重要的是`org.springframework.boot`和`io.spring.dependency-management`插件，它们一起确保Gradle将构建一个fat
    JAR文件，并且我们不需要在Spring Boot starter依赖项上指定任何显式版本号。相反，它们由`springBootVersion`属性隐含。
- en: Plugins are fetched from the central Maven repository and from Spring's snapshot
    and milestone repositories since we have specified a release candidate of Spring
    Boot, v2.1.0 RC1, and not a version that's been released and is available in the
    central Maven repository.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件是从中央Maven仓库和Spring的快照和里程碑仓库中获取的，因为我们指定了Spring Boot的一个候选版本v2.1.0 RC1，而不是已发布并在中央Maven仓库中可用的版本。
- en: 'In the rest of the build file, we basically declare a group name and version
    for our project, Java version, and its dependencies:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建文件的其余部分，我们基本上声明了项目的组名和版本，Java版本以及它的依赖项：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s explain the preceding source code in more detail as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释前面的源代码如下：
- en: Dependencies are, as with the preceding plugins, fetched from the central Maven
    repository and from Spring's snapshot and milestone repositories.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与前面的插件一样，依赖项是从中央Maven仓库和Spring的快照和里程碑仓库中获取的。
- en: Dependencies are set up as specified in the `Actuator` and `WebFlux` modules,
    along with a couple of useful test dependencies.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项设置如`Actuator`和`WebFlux`模块中所指定的，以及一些有用的测试依赖项。
- en: 'We can build each microservice separately with the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令分别构建每个微服务：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note how we use the `gradlew` executables that are created by Spring Initializr;
    that is, we don't need to have Gradle installed!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们如何使用由Spring Initializr创建的`gradlew`可执行文件；也就是说，我们不需要安装Gradle！
- en: The first time we run a command with `gradlew`, it will download Gradle automatically.
    The Gradle version that's used is determined by the `distributionUrl` property
    in the `gradle/wrapper/gradle-wrapper.properties` file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次使用`gradlew`运行命令时，它将自动下载Gradle。使用的Gradle版本由`gradle/wrapper/gradle-wrapper.properties`文件中的`distributionUrl`属性确定。
- en: Setting up multi-project builds in Gradle
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Gradle中设置多项目构建
- en: 'To make it a bit simpler to build all the microservices with one command, we
    can set up a multi-project build in Gradle. The steps are as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更简单地用一个命令构建所有的微服务，我们可以在Gradle中设置多项目构建。步骤如下：
- en: 'First, we create the `settings.gradle` file, which describes what projects
    that Gradle should build:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建`settings.gradle`文件，描述了Gradle应该构建哪些项目：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we copy the Gradle executable files that were generated from one of the
    projects so that we can reuse them for the multi-project builds:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将复制从一个项目生成的Gradle可执行文件，以便我们可以重用它们进行多项目构建：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We no longer need the generated Gradle executable files in each project, so
    we can remove them with the following commands:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不再需要在每个项目中生成的Gradle可执行文件，因此可以使用以下命令将它们删除：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The result should be similar to the code you can find in the folder `$BOOK_HOME/Chapter03/1-spring-init`**.**
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该类似于您可以在文件夹`$BOOK_HOME/Chapter03/1-spring-init`中找到的代码**。**
- en: 'Now, we can build all the microservices with one command:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以用一个命令构建所有的微服务：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you haven''t run the preceding commands, you can simply go to the book''s
    source code and build it from there:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有运行前面的命令，您可以简单地转到书籍的源代码并从那里构建它：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This should result in the following output:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该会产生以下输出：
- en: '![](img/efd0c892-cbca-4962-8248-b17da6fe8cd0.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/efd0c892-cbca-4962-8248-b17da6fe8cd0.png)'
- en: With skeleton projects for the microservices created using Spring Initializr
    and successfully built using Gradle, we are ready to add some code to the microservices
    in the next section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Initializr创建的微服务骨架项目，并成功使用Gradle构建后，我们准备在下一节为微服务添加一些代码。
- en: From a DevOps perspective, a multi-project setup might not be preferred. Instead,
    setting up a separate build pipeline for each microservice project would probably
    be preferred. However, for the purposes of this book, we will use the multi-project
    setup to make it easier to build and deploy the whole system landscape with a
    single command.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从DevOps的角度来看，多项目设置可能不是首选。相反，为每个微服务项目设置单独的构建流水线可能更好。然而，为了本书的目的，我们将使用多项目设置，以便更容易地用单个命令构建和部署整个系统景观。
- en: Adding RESTful APIs
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加RESTful API
- en: Now that we have projects set up for our microservices, let's add some RESTful
    APIs to our three core microservices!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的微服务设置了项目，让我们为我们的三个核心微服务添加一些RESTful API！
- en: The final result of this and the remaining topics in this chapter can be found
    in the `$BOOK_HOME/Chapter03/2-basic-rest-services`folder.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最终结果和其余主题可以在`$BOOK_HOME/Chapter03/2-basic-rest-services`文件夹中找到。
- en: First, we will add two projects (`api` and `util`) that will contain code that
    is shared by the microservice projects, and then we will implement the RESTful
    APIs.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加两个项目（`api`和`util`），这些项目将包含微服务项目共享的代码，然后我们将实现RESTful API。
- en: Adding an API and a util project
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加API和util项目
- en: 'To add an API, we need to do the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个API，我们需要执行以下操作：
- en: First, we will set up a separate Gradle project where we can place our API definitions.
    We will use Java interfaces in order to describe our RESTful APIs and model classes
    to describe the data that the API uses in its requests and responses. Describing
    a RESTful API in a Java interface instead of directly in the Java class is, to
    me, a good way of separating the API definition from its implementation. We will
    further extend this pattern later in this book when we add more API information
    in the Java interfaces to be exposed in the Swagger/OpenAPI definition. See [Chapter 5](ba24a656-10a1-4a3e-879e-6589621ef125.xhtml),
    *Adding an API Description Using OpenAPI/Swagger*, for more information.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将设置一个单独的Gradle项目，用于放置我们的API定义。我们将使用Java接口来描述我们的RESTful API，并使用模型类来描述API在其请求和响应中使用的数据。在Java接口中描述RESTful
    API，而不是直接在Java类中描述，对我来说是一种很好的将API定义与其实现分离的方式。在本书的后面，当我们在Java接口中添加更多API信息以在Swagger/OpenAPI定义中公开时，我们将进一步扩展这种模式。详情请参见[第5章](ba24a656-10a1-4a3e-879e-6589621ef125.xhtml)，*使用OpenAPI/Swagger添加API描述*。
- en: Describing RESTful APIs in Java interfaces wasn't fully supported until Spring
    Framework v5.1.0\. See [https://jira.spring.io/browse/SPR-11055](https://jira.spring.io/browse/SPR-11055)
    for details.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 直到Spring Framework v5.1.0，才完全支持在Java接口中描述RESTful API。详情请参见[https://jira.spring.io/browse/SPR-11055](https://jira.spring.io/browse/SPR-11055)。
- en: It is debatable whether it is good practice to store API definitions for a group
    of microservices in a common API module. To me, it is a good choice for microservices
    that are part of the same delivery organization, that is, whose releases are governed
    by one and the same organization (compare to a *Bounded Context* in *Domain-Driven
    Design*, where our microservices are placed in one and the same bounded context).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 是否将一组微服务的API定义存储在公共API模块中是一个有争议的问题。对我来说，对于属于同一交付组织的微服务来说，这是一个不错的选择，即其发布受同一组织的管理（与*领域驱动设计*中的*有界上下文*相比，在那里我们的微服务放置在同一个有界上下文中）。
- en: Next, we will create a `util` project that can hold some helper classes that
    are shared by our microservices, for example, for handling errors in a uniform
    way.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`util`项目，可以保存一些辅助类，这些类可以被我们的微服务共享，例如，以统一的方式处理错误。
- en: Again, from a DevOps perspective, it would be preferable to build all the projects
    in their own build pipeline and have version-controlled dependencies for the `api`
    and `util` projects in the microservice projects; that is, so that each microservice
    can choose what versions of the `api` and `util` projects to use. But to keep
    the build and deployment steps simple in the context of this book, we will make
    the `api` and `util` projects part of the multi-project build.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从DevOps的角度来看，最好在各自的构建流水线中构建所有项目，并在微服务项目中使用版本控制的`api`和`util`项目的依赖关系；即，每个微服务可以选择使用`api`和`util`项目的哪个版本。但为了保持本书的上下文中构建和部署步骤的简单性，我们将使`api`和`util`项目成为多项目构建的一部分。
- en: The api project
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`api`项目'
- en: The `api` project will be packaged as a library; that is, it won't have its
    own `main` application class. Unfortunately, Spring Initializr doesn't support
    the creation of library projects. Instead, a library project has to be created
    manually from scratch. The source code for the API project is available at `$BOOK_HOME/Chapter03/2-basic-rest-services/api`**.**
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`api`项目将被打包为库；即，它不会有自己的`main`应用程序类。不幸的是，Spring Initializr不支持创建库项目。库项目必须手动从头开始创建。API项目的源代码位于`$BOOK_HOME/Chapter03/2-basic-rest-services/api`。'
- en: 'The structure of a library project is the same as for an application project,
    except that we no longer have the `main` application class, as well as some minor
    differences in the `build.gradle` file. The Gradle `org.springframework.boot`
    and `io.spring.dependency-management` plugins are replaced with a `dependencyManagement`
    section:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 库项目的结构与应用程序项目相同，只是我们不再有`main`应用程序类，以及`build.gradle`文件中一些细微的差异。Gradle的`org.springframework.boot`和`io.spring.dependency-management`插件被`dependencyManagement`部分替换：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This allows us to retain Spring Boot dependency management while we are replacing
    the construction of a fat JAR in the build step with the creation of normal JAR
    files; that is, they only contain the library project's own class and property
    files.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以在替换构建步骤中的构建fat JAR的同时保留Spring Boot的依赖管理，改为创建普通的JAR文件；即，它们只包含库项目自己的类和属性文件。
- en: 'The Java files in the `api` project for our three core microservices are as
    follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们三个核心微服务的`api`项目中的Java文件如下：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The structure of the Java classes looks very similar for the three core microservices,
    so we will only go through the source code for the `product` service.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 三个核心微服务的Java类结构非常相似，因此我们只会查看`product`服务的源代码。
- en: 'First, we will look at the `ProductService.java` Java interface, as shown in
    the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看`ProductService.java`的Java接口，如下所示：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s explain the preceding source code in more detail:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释前面的源代码：
- en: The `product` service only exposes one API method, `getProduct()` (we will extend
    the API later in this book).
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product`服务只公开一个API方法`getProduct()`（我们将在本书后面扩展API）。'
- en: To map the method to an HTTP `GET` request, we use the `@GetMapping` Spring
    annotation, where we specify what URL path the method will be mapped to (`/product/{productId}`)
    and what format the response will be, in this case, JSON.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将方法映射到HTTP `GET`请求，我们使用`@GetMapping` Spring注解，在其中指定方法将映射到的URL路径(`/product/{productId}`)以及响应的格式，本例中为JSON。
- en: The `{productId}` part of the path maps to a `path` variable named `productId`.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径中的`{productId}`部分映射到名为`productId`的`path`变量。
- en: The `productId` method parameter is annotated with `@PathVariable`, which will
    map the value that's passed in the HTTP request to the parameter. For example,
    an HTTP `GET` request to `/product/123` will result in the `getProduct()` method
    being called with the `productId` parameter set to `123`.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`productId`方法参数带有`@PathVariable`注解，它将把传递的值映射到参数。例如，对`/product/123`的HTTP `GET`请求将导致`getProduct()`方法被调用，`productId`参数设置为`123`。'
- en: 'The method returns a `Product` object, a plain POJO-based model class with
    the member variables corresponding to attributes for `Product`, as described at
    the start of this chapter. `Product.java` looks as follows (with constructors
    and getter methods excluded):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回一个`Product`对象，这是一个基于普通POJO的模型类，其成员变量对应于本章开头描述的`Product`的属性。`Product.java`如下（构造函数和getter方法已排除）：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This type of POJO class is also known as a **Data Transfer Object** (**DTO**)
    as it is used to transfer data between the API implementation and the caller of
    the API. When we get to [Chapter 6](6c495e97-f473-4cb1-a404-11fd938f5478.xhtml),
    *Adding Persistence*, we will look at another type of POJO that can be used to
    describe how data is stored in the databases, also known as entity objects.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这种POJO类也被称为**数据传输对象**（**DTO**），因为它用于在API实现和API调用者之间传输数据。当我们到达[第6章](6c495e97-f473-4cb1-a404-11fd938f5478.xhtml)时，*添加持久性*，我们将看到另一种POJO类型，它用于描述数据在数据库中的存储方式，也被称为实体对象。
- en: The util project
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: util项目
- en: 'The `util` project will be packaged as a library in the same way as the `api`
    project. The source code for the `util` project is available at `$BOOK_HOME/Chapter03/2-basic-rest-services/util`.
    The project contains the following Java files:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`util`项目将与`api`项目一样被打包为库。`util`项目的源代码位于`$BOOK_HOME/Chapter03/2-basic-rest-services/util`。该项目包含以下Java文件：'
- en: The `InvalidInputException` and `NotFoundException` exception classes
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvalidInputException`和`NotFoundException`异常类'
- en: The `GlobalControllerExceptionHandler`, `HttpErrorInfo`, and `ServiceUtil` utility
    classes
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GlobalControllerExceptionHandler`，`HttpErrorInfo`和`ServiceUtil`实用类'
- en: Except for the code in `ServiceUtil.java`, these classes are reusable utility
    classes that we can use to map Java exceptions to proper HTTP status codes, as
    described in the *Adding error handling* section. The main purpose of `ServiceUtil.java`
    is to find out the hostname, IP address, and port used by the microservice. The
    class exposes a method, `getServiceAddress()`, that can be used by the microservices
    to find their hostname, IP address, and port.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`ServiceUtil.java`中的代码外，这些类都是可重用的实用程序类，我们可以使用它们将Java异常映射到适当的HTTP状态码，如*添加错误处理*部分所述。`ServiceUtil.java`的主要目的是找出微服务使用的主机名、IP地址和端口。该类公开了一个`getServiceAddress()`方法，可以被微服务用来找到它们的主机名、IP地址和端口。
- en: Implementing our API
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现我们的API
- en: Now we can start to implement our APIs in the core microservices!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始在核心微服务中实现我们的API了！
- en: 'The implementation looks very similar for the three core microservices, so
    we will only go through the source code for the `product` service. You can find
    the other files in `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices`.
    Let''s see how we go about this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个核心微服务的实现看起来非常相似，因此我们只会讨论`product`服务的源代码。您可以在`$BOOK_HOME/Chapter03/2-basic-rest-services/microservices`中找到其他文件。让我们看看我们如何做到这一点：
- en: 'We need to add the `api` and `util` projects as dependencies in our `build.gradle`
    file, that is, `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-service/build.gradle`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在我们的`build.gradle`文件中将`api`和`util`项目作为依赖项添加，即`$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-service/build.gradle`：
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To enable Spring Boot''s autoconfiguration feature to detect Spring beans in
    the `api` and `util` projects, we also need to add a `@ComponentScan` annotation
    to the `main` application class, which includes the packages of the `api` and
    `util` projects:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使Spring Boot的自动配置功能能够检测到`api`和`util`项目中的Spring bean，我们还需要在`main`应用程序类中添加`@ComponentScan`注解，其中包括`api`和`util`项目的包：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we create our service implementation file, `ProductServiceImpl.java`,
    in order to implement the Java interface, `ProductService`, from the `api` project
    and annotate the class with `@RestController` so that Spring will call the methods
    in this class according to the mappings specified in the `Interface` class:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的服务实现文件`ProductServiceImpl.java`，以实现`api`项目中的Java接口`ProductService`，并用`@RestController`注解该类，以便Spring根据`Interface`类中指定的映射调用该类中的方法：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To be able to use the `ServiceUtil` class from the `util` project, we will
    inject it into the constructor, as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够使用`util`项目中的`ServiceUtil`类，我们将它注入到构造函数中，如下所示：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we can implement the API by overriding the `getProduct()` method from
    the interface in the `api` project:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过覆盖`api`项目中接口的`getProduct()`方法来实现API：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since we aren't currently using a database, we simply return a hardcoded response
    based on the input of `productId`, along with the service address supplied by
    the `ServiceUtil` class.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们目前没有使用数据库，我们只是根据`productId`的输入返回一个硬编码的响应，以及`ServiceUtil`类提供的服务地址。
- en: For the final result, including logging and error handling, see `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-service/src/main/java/se/magnus/microservices/core/product/services/ProductServiceImpl.java`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果，包括日志记录和错误处理，请参阅`$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-service/src/main/java/se/magnus/microservices/core/product/services/ProductServiceImpl.java`。
- en: 'Finally, we also need to set up some runtime properties – what port to use
    and the desired level of logging. This is added to the `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-service/src/main/resources/application.yml`
    property file:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还需要设置一些运行时属性 - 使用的端口和所需的日志级别。这将添加到`$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-service/src/main/resources/application.yml`属性文件中：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can try out the `product` service on its own. Build and start the microservice
    with the following commands:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以单独尝试`product`服务。使用以下命令构建和启动微服务：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Wait until the following is printed in the Terminal:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待终端打印以下内容：
- en: '![](img/41540310-c226-4100-ae87-35de5d722d65.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41540310-c226-4100-ae87-35de5d722d65.png)'
- en: 'Make a test call to the `product` service:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`product`服务进行测试调用：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It should respond with something similar to the following:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它应该会返回类似以下的内容：
- en: '![](img/99d66466-5aec-4506-b7ea-c12540ad6ce5.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99d66466-5aec-4506-b7ea-c12540ad6ce5.png)'
- en: 'Finally, stop the `product` service:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，停止`product`服务：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have now built, run, and tested our first single microservice. In the next
    section, we will implement the composite microservice that will use the three
    core microservices that we've created so far.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建、运行并测试了我们的第一个单一微服务。在下一节中，我们将实现复合微服务，该微服务将使用到目前为止我们创建的三个核心微服务。
- en: Adding a composite microservice
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加复合微服务
- en: Now, it's time to tie things together by adding the composite service that will
    call the three core services!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候通过添加将调用三个核心服务的复合服务来将一切联系在一起了！
- en: 'The implementation of the composite services is divided into two parts: an integration
    component that handles the outgoing HTTP requests to the core services and the
    composite service implementation itself. The main reason for this division of
    responsibility is that it simplifies automated unit and integration testing; that
    is, we can test the service implementation in isolation by replacing the integration
    component with a mock.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 复合服务的实现分为两部分：一个处理向核心服务的出站HTTP请求的集成组件和复合服务实现本身。这种责任划分的主要原因是简化自动化单元和集成测试；也就是说，我们可以通过用模拟替换集成组件来独立测试服务实现。
- en: As we will see later on in this book, this division of responsibility will also
    make it easier to introduce a Circuit Breaker!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本书的后面看到的那样，这种责任划分也将使引入断路器更容易！
- en: Before we look into the source code of the two components, we need to take a
    look at the API classes that the composite microservices will use and also learn
    about how runtime properties are used to hold address information for the core
    microservices.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看两个组件的源代码之前，我们需要看一下复合微服务将使用的API类，并了解运行时属性如何用于保存核心微服务的地址信息。
- en: The full implementation of both the integration component and the implementation
    of the composite service can be found in the `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/main/java/se/magnus/microservices/composite/product/services` folder.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 集成组件和复合服务实现的完整实现可以在`$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/main/java/se/magnus/microservices/composite/product/services`文件夹中找到。
- en: API classes
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API类
- en: 'In this section, we will take a look at the classes that describes the API
    of the composite component. They can be found in `$BOOK_HOME/Chapter03/2-basic-rest-services/api`.
    The following are the API classes:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下描述复合组件API的类。它们可以在`$BOOK_HOME/Chapter03/2-basic-rest-services/api`中找到。以下是API类：
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The Java interface class, `ProductCompositeService.java`, follows the same
    pattern that''s used by the core services and looks as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Java接口类`ProductCompositeService.java`遵循核心服务使用的相同模式，如下所示：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The model class, `ProductAggregate.java`, is a bit more complex than the core
    models since it contains fields for lists of recommendations and reviews:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 模型类`ProductAggregate.java`比核心模型复杂一些，因为它包含推荐和评论列表的字段：
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Properties
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'To avoid hardcoding the address information for the core services into the
    source code of the composite microservice, the latter uses a property file where
    information on how to find the core services is stored. The property file can
    be found in `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/main/resources/application.yml`
    and looks as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免将核心服务的地址信息硬编码到复合微服务的源代码中，后者使用一个属性文件来存储如何找到核心服务的信息。属性文件可以在`$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/main/resources/application.yml`中找到，如下所示：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This configuration will, as already noted, be replaced by a service discovery
    mechanism later on in this book.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这种配置将在本书的后面被服务发现机制替换。
- en: Integration component
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成组件
- en: 'Let''s look at the integration component, `ProductCompositeIntegration.java`.
    It is declared as a Spring Bean using the `@Component` annotation and implements
    the three core services'' API interfaces:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看集成组件`ProductCompositeIntegration.java`。它被声明为一个Spring Bean，使用`@Component`注解，并实现了三个核心服务的API接口：
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The integration component uses a helper class in Spring Framework, `RestTemplate.java`,
    to perform the actual HTTP requests to the core microservices. Before we can inject
    it into the integration component, we need to configure it. We do that in the
    `main` application class, `ProductCompositeServiceApplication.java`, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 集成组件使用Spring Framework中的一个辅助类`RestTemplate.java`来执行对核心微服务的实际HTTP请求。在我们可以将其注入到集成组件之前，我们需要对其进行配置。我们在`main`应用程序类`ProductCompositeServiceApplication.java`中进行配置，如下所示：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`RestTemplate` is highly configurable, but we leave it with its default values
    for now.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestTemplate`是高度可配置的，但我们现在将其保留为默认值。'
- en: 'We can now inject `RestTemplate`, along with a JSON mapper that''s used for
    error handling and the configuration values that we set up in the property file
    in the constructor of the integration component. Let''s see how this is done:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在集成组件的构造函数中注入`RestTemplate`，以及用于错误处理的JSON映射器和我们在属性文件中设置的配置值。让我们看看这是如何实现的：
- en: 'The configuration values we use to set up the URLs for the three core services
    are injected into the constructor as follows:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用来设置三个核心服务的URL的配置值被注入到构造函数中，如下所示：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The body of the constructor builds the URLs based on the injected values, as
    follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的主体根据注入的值构建URL，如下所示：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, the integration component implements the API methods for the three
    core services by using `RestTemplate` to make the actual outgoing calls:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，集成组件通过使用`RestTemplate`实现三个核心服务的API方法来进行实际的出站调用：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s explain the preceding source code in more detail:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释前面的源代码：
- en: For the `getProduct()` implementation, the `getForObject()` method can be used
    in `RestTemplate`. The expected response is a `Product` object, and it can be
    expressed in the call to `getForObject()` by specifying the `Product.class` class that
    `RestTemplate` will map the JSON response to.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`getProduct()`的实现，可以在`RestTemplate`中使用`getForObject()`方法。预期的响应是一个`Product`对象，可以通过在`getForObject()`调用中指定`Product.class`类来表达，`RestTemplate`将把JSON响应映射到该类。
- en: For the calls to `getRecommendations()` and `getReviews()`, a more advanced
    method, `exchange()`, has to be used. The reason for this is the automatic mapping
    from a JSON response to a model class that `RestTemplate` performs.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`getRecommendations()`和`getReviews()`的调用，需要使用更高级的`exchange()`方法。原因是`RestTemplate`执行从JSON响应到模型类的自动映射。
- en: The `getRecommendations()` and `getReviews()` methods expect a generic list
    in the responses, that is, `List<Recommendation>` and `List<Review>`. Since generics
    don't hold any type of information at runtime, we can't specify that the methods
    expect a generic list in their responses. Instead, we can use a helper class from
    the Spring Framework, `ParameterizedTypeReference`, that is designed to resolve
    this problem by holding the type information at runtime. This means that `RestTemplate`
    can figure out what class to map the JSON responses to. To utilize this helper
    class, we have to use the more involved `exchange()` method instead of the simpler `getForObject()` method
    on `RestTemplate`.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRecommendations()`和`getReviews()`方法在响应中期望一个通用列表，即`List<Recommendation>`和`List<Review>`。由于泛型在运行时不包含任何类型信息，我们无法指定这些方法在响应中期望一个通用列表。相反，我们可以使用Spring
    Framework的一个辅助类`ParameterizedTypeReference`，它设计用于解决这个问题，通过在运行时保存类型信息。这意味着`RestTemplate`可以确定将JSON响应映射到哪个类。为了利用这个辅助类，我们必须在`RestTemplate`上使用更复杂的`exchange()`方法，而不是更简单的`getForObject()`方法。'
- en: Composite API implementation
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合API实现
- en: 'Finally, we will look at the last piece of the implementation of the composite
    microservice: the `ProductCompositeServiceImpl.java`. implementation class. Let''s
    go through it step-by-step:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看一下复合微服务的最后一部分实现：`ProductCompositeServiceImpl.java`。实现类。让我们一步一步地进行：
- en: 'In the same way that we did for the core services, the composite service implements
    its API interface, `ProductCompositeService`, and is annotated with `@RestController` to
    mark it as a REST service:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与核心服务一样，复合服务实现了其API接口`ProductCompositeService`，并使用`@RestController`进行注解，标记为REST服务：
- en: '[PRE42]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The implementation class requires the `ServiceUtil` bean and its own integration
    component, so they are injected in its constructor:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类需要`ServiceUtil` bean和自己的集成组件，因此它们在构造函数中被注入：
- en: '[PRE43]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, the API method is implemented as follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，API方法的实现如下：
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The integration component is used to call the three core services, and a helper
    method, `createProductAggregate()`, is used to create a response object of the `ProductAggregate` type
    based on the responses from the calls to the integration component.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 集成组件用于调用三个核心服务，并使用一个辅助方法`createProductAggregate()`来基于对集成组件的调用响应创建`ProductAggregate`类型的响应对象。
- en: The implementation of the helper method, `createProductAggregate()`, is quite
    lengthy and not very important and so has been omitted from this chapter; however,
    it can be found in this book's source code.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助方法`createProductAggregate()`的实现非常冗长且不太重要，因此在本章中被省略；但是，它可以在本书的源代码中找到。
- en: The full implementation of both the integration component and the composite
    service can be found in the `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/main/java/se/magnus/microservices/composite/product/services` folder.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 集成组件和复合服务的完整实现可以在`$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/main/java/se/magnus/microservices/composite/product/services`文件夹中找到。
- en: That completes the implementation of the composite microservice from a functional
    point of view. In the next section, we will see how we can add source code so
    that we can handle errors.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了从功能角度看复合微服务的实现。在下一节中，我们将看到如何添加源代码以处理错误。
- en: Adding error handling
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加错误处理
- en: Handling errors in a structured and well thought-out way is essential in a microservice
    landscape where a large number of microservices communicate with each other using
    synchronous APIs, for example, using HTTP and JSON. It is also important to separate
    protocol-specific handling of errors, such as HTTP status codes, from the business
    logic.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务景观中，以同步API（例如使用HTTP和JSON）进行大量微服务之间的通信时，以结构化和深思熟虑的方式处理错误是至关重要的。将协议特定的错误处理（例如HTTP状态码）与业务逻辑分离也很重要。
- en: It could be argued that a separate layer for the business logic should be added
    when implementing of the microservices. This should ensure that business logic
    is separated from the protocol-specific code, making it easier both to test and
    reuse. To avoid unnecessary complexity in the examples provided in this book,
    we have left out a separate layer for business logic, that is, the microservices
    implement their business logic directly in the `@RestController` components.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，在实现微服务时应该添加一个单独的业务逻辑层。这应该确保业务逻辑与特定协议的代码分离，使得测试和重用更容易。为了避免在本书提供的示例中出现不必要的复杂性，我们没有为业务逻辑添加单独的层，也就是说，微服务直接在`@RestController`组件中实现它们的业务逻辑。
- en: I have created a set of Java exceptions in the `util` project that are used
    by both the API implementations and the API clients, initially `InvalidInputException`
    and `NotFoundException`. See `$BOOK_HOME/Chapter03/2-basic-rest-services/util/src/main/java/se/magnus/util/exceptions`
    for details.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`util`项目中创建了一组Java异常，这些异常被API实现和API客户端使用，最初是`InvalidInputException`和`NotFoundException`。有关详细信息，请参阅`$BOOK_HOME/Chapter03/2-basic-rest-services/util/src/main/java/se/magnus/util/exceptions`。
- en: The global REST controller exception handler
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局REST控制器异常处理程序
- en: To separate protocol-specific error handling from the business logic in the
    REST controllers, that is, the API implementations, I have created a utility class,
    `GlobalControllerExceptionHandler.java`, in the `util` project that's annotated
    as `@RestControllerAdvice`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将REST控制器中的协议特定的错误处理与业务逻辑分离，也就是API实现，我创建了一个名为`GlobalControllerExceptionHandler.java`的实用类，在`util`项目中标注为`@RestControllerAdvice`。
- en: For each Java exception that the API implementations throws, the utility class
    has an exception handler method that maps the Java exception to a proper HTTP
    response, that is, with a proper HTTP status and HTTP response body.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于API实现抛出的每个Java异常，实用类都有一个异常处理程序方法，将Java异常映射到适当的HTTP响应，即适当的HTTP状态和HTTP响应主体。
- en: 'For example, if an API implementation class throws `InvalidInputException`,
    the utility class will map it to an HTTP response with the status code set to
    `422` (`UNPROCESSABLE_ENTITY`). The following code shows this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果API实现类抛出`InvalidInputException`，实用类将将其映射为状态码设置为`422`（`UNPROCESSABLE_ENTITY`）的HTTP响应。以下代码显示了这一点：
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the same way, `NotFoundException` is mapped to a `404` (`NOT_FOUND`) HTTP
    status code.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，`NotFoundException`被映射为`404`（`NOT_FOUND`）HTTP状态码。
- en: Whenever a REST controller throws any of these exceptions, Spring will use the
    utility class to create an HTTP response.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 每当REST控制器抛出这些异常时，Spring将使用实用类创建HTTP响应。
- en: Note that Spring itself returns the HTTP status code `400` ( `BAD_REQUEST`)
    when it detects an invalid request, for example, if the request contains a non-numeric
    product ID (`productId` is specified as an integer in the API declaration).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当Spring检测到无效请求时，例如，如果请求包含非数字产品ID（API声明中指定`productId`为整数），Spring本身将返回HTTP状态码`400`（`BAD_REQUEST`）。
- en: For the full source code of the utility class, see `$BOOK_HOME/Chapter03/2-basic-rest-services/util/src/main/java/se/magnus/util/http/GlobalControllerExceptionHandler.java`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 有关实用类的完整源代码，请参见`$BOOK_HOME/Chapter03/2-basic-rest-services/util/src/main/java/se/magnus/util/http/GlobalControllerExceptionHandler.java`。
- en: Error-handling in API implementations
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API实现中的错误处理
- en: 'API implementations use the exceptions in the `util` project to signal errors.
    They will be reported back to the REST client as HTTPS status codes indicating
    what went wrong. For example, the `Product` microservice implementation class, `ProductServiceImpl.java`,
    uses the `InvalidInputException` exception to return an error that indicates invalid
    input, as well as the `NotFoundException` exception to tell us that the product
    that was asked for does not exist. The code looks as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: API实现使用`util`项目中的异常来表示错误。它们将作为HTTPS状态码报告回传给REST客户端，指示出了什么出错了。例如，`Product`微服务的实现类`ProductServiceImpl.java`使用`InvalidInputException`异常来返回指示无效输入的错误，以及`NotFoundException`异常来告诉我们所请求的产品不存在。代码如下：
- en: '[PRE46]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Since we currently aren't using a database, we have to simulate when to throw `NotFoundException`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们目前没有使用数据库，我们必须模拟何时抛出`NotFoundException`。
- en: Error-handling in the API client
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API客户端中的错误处理
- en: 'The API client, that is, the integration component of the `Composite` microservice,
    does the reverse; that is, it maps the `422` (`UNPROCESSABLE_ENTITY`) HTTP status
    code to `InvalidInputException` and the `404` (`NOT_FOUND`) HTTP status code to `NotFoundException`.
    See the `getProduct()` method in `ProductCompositeIntegration.java` for the implementation
    of this error handling logic. The source code looks as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: API客户端，也就是`Composite`微服务的集成组件，执行相反的操作；也就是，它将`422`（`UNPROCESSABLE_ENTITY`）HTTP状态码映射为`InvalidInputException`，将`404`（`NOT_FOUND`）HTTP状态码映射为`NotFoundException`。查看`ProductCompositeIntegration.java`中的`getProduct()`方法，了解此错误处理逻辑的实现。源代码如下：
- en: '[PRE47]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The error handling for `getRecommendations()` and `getReviews()` in the integration
    component is a bit more relaxed – classed as best-effort, meaning that, if it
    succeeds in getting product information but fails to get either recommendations
    or reviews, it is still considered to be okay. However, a warning is written to
    the log.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`getRecommendations()`和`getReviews()`在集成组件中的错误处理更加宽松 - 被归类为尽力而为，这意味着，如果它成功获取产品信息但未能获取推荐或评论，仍然被认为是可以的。但是，警告会被写入日志。'
- en: For more details, see `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/main/java/se/magnus/microservices/composite/product/services/ProductCompositeIntegration.java`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请参见`$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/main/java/se/magnus/microservices/composite/product/services/ProductCompositeIntegration.java`。
- en: That completes the implementation of both the code and composite microservices.
    In the next section, we will test the microservices and the API that they expose.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了代码和复合微服务的实现。在下一节中，我们将测试这些微服务以及它们暴露的API。
- en: Testing APIs manually
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动测试API
- en: 'That concludes the implementation of our microservices. Let''s try them out
    by performing the following steps:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们微服务的实现。让我们通过执行以下步骤来尝试它们：
- en: Build and start them up as background processes.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并启动它们作为后台进程。
- en: Use `curl` to call the composite API.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`调用复合API。
- en: Stop them.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止它们。
- en: 'First, build and start-up each microservice as a background process, as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，构建并启动每个微服务作为后台进程，如下所示：
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Once the build completes, we can launch our microservices as background processes
    to the Terminal process with the following code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，我们可以将我们的微服务作为后台进程启动到终端进程中，使用以下代码：
- en: '[PRE49]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'A lot of log messages will be written to the Terminal, but after a few seconds,
    things will calm down and we will find the following messages written to the log:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 大量的日志消息将被写入终端，但几秒钟后，情况将平息下来，我们将在日志中找到以下消息：
- en: '![](img/7437d6fb-99f1-4fa9-957b-be6257567694.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7437d6fb-99f1-4fa9-957b-be6257567694.png)'
- en: 'This means that they all are ready to receive requests. Try this out with the
    following code:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它们都准备好接收请求。使用以下代码尝试一下：
- en: '[PRE50]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After some log output, we will get a JSON response that looks something like
    the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些日志输出后，我们将得到一个类似以下的JSON响应：
- en: '![](img/4cf8525d-ea4f-4c59-99f9-a076421e41dd.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4cf8525d-ea4f-4c59-99f9-a076421e41dd.png)'
- en: 'To get the JSON response pretty-printed, you can use the `jq` tool:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要使JSON响应格式化漂亮，您可以使用`jq`工具：
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This results in the following output (some details have been replaced by `...` for
    increased readability):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出（为了增加可读性，一些细节已被替换为`...`）：
- en: '![](img/771fc141-de97-432e-af16-a3f1d0f03b70.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/771fc141-de97-432e-af16-a3f1d0f03b70.png)'
- en: 'If you want to, you can also try out the following commands to verify that
    the error handling works as expected:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您也可以尝试以下命令来验证错误处理是否按预期工作：
- en: '[PRE52]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, you can shut down the microservices with the following command:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用以下命令关闭微服务：
- en: '[PRE53]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If you are using either Spring Tool Suite or IntelliJ IDEA Ultimate Edition
    as your IDE, you can use their Spring Boot Dashboard to start and stop your microservices
    with one click.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Spring Tool Suite或IntelliJ IDEA Ultimate Edition作为您的IDE，您可以使用它们的Spring
    Boot Dashboard一键启动和停止您的微服务。
- en: 'The following screenshot shows the use of Spring Tool Suite:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了Spring Tool Suite的使用：
- en: '![](img/5017f9b2-a124-4c5a-95fa-cc52247a15e6.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5017f9b2-a124-4c5a-95fa-cc52247a15e6.png)'
- en: 'The following screenshot shows the use of IntelliJ IDEA Ultimate Edition:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了IntelliJ IDEA Ultimate Edition的使用：
- en: '![](img/871261b3-dbde-4c1d-afde-61ca65c7bdca.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](img/871261b3-dbde-4c1d-afde-61ca65c7bdca.png)'
- en: In this section, we have learned how to manually start, test, and stop the system
    landscape of cooperating microservices. These types of test are time-consuming,
    so they clearly need to be automated. In the next two sections, we will take our
    first steps toward learning how to automate testing, testing both a single microservice
    in isolation and a whole system landscape of cooperating microservices. Throughout
    this book, we will improve how we test our microservices.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何手动启动、测试和停止合作微服务系统架构。这些类型的测试非常耗时，因此它们显然需要自动化。在接下来的两节中，我们将迈出迈向学习如何自动化测试的第一步，测试单个独立的微服务以及合作微服务系统架构。在本书中，我们将改进我们测试微服务的方式。
- en: Preventing slow lookup of the localhost hostname
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止本地主机名的慢查找
- en: With effect from macOS Sierra, looking up the hostname that's used by the localhost
    in a Java program on a macOS can take a very long time, that is, 5 seconds, making
    tests very slow. The problem seems to be fixed when using macOS Mojave, but if
    you are using an older version of macOS, this can easily be fixed.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 从macOS Sierra开始，在macOS上的Java程序中查找本地主机名可能需要很长时间，即5秒，使测试非常缓慢。在使用macOS Mojave时，这个问题似乎已经解决，但如果您使用的是较旧版本的macOS，这很容易解决。
- en: 'First, you need to verify whether the problem affects you by downloading a
    small tool from GitHub and running it:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要验证问题是否影响您，方法是从GitHub下载一个小工具并运行它：
- en: '[PRE54]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s say the program responds with something like the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 假设程序响应如下：
- en: '![](img/c41f046a-ac2c-4f77-a856-2131fef48987.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c41f046a-ac2c-4f77-a856-2131fef48987.png)'
- en: If you have a response time of 5 seconds, then you have a problem!
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的响应时间为5秒，那么您就有问题了！
- en: 'The solution is to edit the `/etc/hosts` file and add your local hostname,
    which is `Magnuss-Mac.local` in the preceding example, after `localhost`; for
    example:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是编辑`/etc/hosts`文件，并在`localhost`后添加您的本地主机名，例如在前面的示例中是`Magnuss-Mac.local`；例如：
- en: '[PRE55]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Rerun the test. It should respond with a response time of a few milliseconds, for
    example:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行测试。它应该以几毫秒的响应时间响应，例如：
- en: '![](img/d1ba5f11-22f1-4ce4-a3fd-03e8486b5e13.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1ba5f11-22f1-4ce4-a3fd-03e8486b5e13.png)'
- en: Now lets see how to add automated tests in isolation for microservices.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何为微服务单独添加自动化测试。
- en: Adding automated microservice tests in isolation
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在隔离中添加自动化微服务测试
- en: Before we wrap up the implementation, we also need to write some automated tests.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成实现之前，我们还需要编写一些自动化测试。
- en: We don't have much business logic to test at this time, so we don't need to
    write any unit tests. Instead, we will focus on testing the APIs that our microservices
    expose; that is, we will start them up in integration tests with their embedded
    web server and then use a test client to perform HTTP requests and validate the
    responses. With Spring WebFlux came a new test client, `WebTestClient`, that provides
    a fluent API for making a request and then applying assertions on its result.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前没有太多的业务逻辑需要测试，因此我们不需要编写任何单元测试。相反，我们将专注于测试我们的微服务公开的API；也就是说，我们将在集成测试中启动它们的嵌入式Web服务器，然后使用测试客户端执行HTTP请求并验证响应。随着Spring
    WebFlux的推出，出现了一个新的测试客户端`WebTestClient`，它提供了一个流畅的API来发出请求，然后对其结果应用断言。
- en: 'The following is an example where we test the composite product API by doing
    the following:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，我们通过以下方式测试复合产品API：
- en: Sending in `productId` for an existing product and asserting that we get back
    200 as an HTTP response code and a JSON response that contains the requested `productId`
    along with one recommendation and one review
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送一个现有产品的`productId`并断言我们得到200作为HTTP响应代码和包含请求的`productId`以及一个推荐和一个评论的JSON响应
- en: Sending in a missing `productId` and asserting that we get back 404 as an HTTP
    response code and a JSON response that contains relevant error information
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送一个缺少的`productId`并断言我们得到404作为HTTP响应代码和包含相关错误信息的JSON响应
- en: 'The implementation for these two tests is shown in the following code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个测试的实现如下所示：
- en: '[PRE56]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let''s explain the preceding source code in more detail:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释前面的源代码：
- en: The test uses the fluent `WebTestClient` API to set up the URL to call `"/product-composite/"
    + PRODUCT_ID_OK` and specify the accepted response format, JSON.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该测试使用流畅的`WebTestClient` API来设置要调用的URL `"/product-composite/" + PRODUCT_ID_OK`，并指定接受的响应格式为JSON。
- en: After executing the request using the `exchange()` method, the test verifies
    that the response status is OK (200) and that the response format actually is
    JSON (as requested).
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用`exchange()`方法执行请求后，测试验证响应状态是否为OK（200），并且响应格式实际上是JSON（如所请求的）。
- en: Finally, the test inspects the response body and verifies that it contains the
    expected information in terms of `productId` and the number of recommendations
    and reviews.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，测试检查响应体，并验证其中包含关于`productId`和推荐和评论数量的预期信息。
- en: 'The second test looks as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试如下：
- en: '[PRE57]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s explain the preceding source code in more detail:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释前面的源代码：
- en: This negative test is very similar to the preceding test in terms of its structure;
    the main difference is that it verifies that it got an error status code back,
    Not Found (404), and that the response body contains the expected error message.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个负面测试在结构上与前面的测试非常相似；主要区别在于它验证了是否收到了错误状态码，即未找到（404），以及响应体是否包含了预期的错误消息。
- en: 'To test the composite product API in isolation, we need to mock its dependencies,
    that is, the requests to the other three microservices that were performed by
    the integration component, `ProductCompositeIntegration`. We use Mockito to do
    this, as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要单独测试复合产品API，我们需要模拟其依赖关系，即集成组件`ProductCompositeIntegration`对其他三个微服务的请求。我们使用Mockito来实现这一点，如下所示：
- en: '[PRE58]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s explain the preceding source code in more detail:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释前面的源代码：
- en: First, we declare three constants that are used in the test class: `PRODUCT_ID_OK`,
    `PRODUCT_ID_NOT_FOUND`, and `PRODUCT_ID_INVALID`.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们声明了在测试类中使用的三个常量：`PRODUCT_ID_OK`，`PRODUCT_ID_NOT_FOUND`和`PRODUCT_ID_INVALID`。
- en: If the `getProduct()`, `getRecommendations()`, and `getReviews()` methods are
    called on the integration component, and `productId` is set to `PRODUCT_ID_OK`,
    the mock will return a normal response.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在集成组件上调用`getProduct()`，`getRecommendations()`和`getReviews()`方法，并且`productId`设置为`PRODUCT_ID_OK`，模拟将返回正常响应。
- en: If the `getProduct()` method is called with `productId` set to `PRODUCT_ID_NOT_FOUND`,
    the mock will throw `NotFoundException`.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`getProduct()`方法以`PRODUCT_ID_NOT_FOUND`设置为`productId`调用，模拟将抛出`NotFoundException`。
- en: If the `getProduct()` method is called with `productId` set to `PRODUCT_ID_INVALID`,
    the mock will throw `InvalidInputException`.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`getProduct()`方法以`PRODUCT_ID_INVALID`设置为`productId`调用，模拟将抛出`InvalidInputException`。
- en: The full source code for the automated integration tests on the composite product
    API can be found in `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/test/java/se/magnus/microservices/composite/product/ProductCompositeServiceApplicationTests.java`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化集成测试的完整源代码可以在`$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/test/java/se/magnus/microservices/composite/product/ProductCompositeServiceApplicationTests.java`中找到。
- en: The automated integration tests on the API exposed by the three core microservices
    are similar, but simpler since they don't need to mock anything! The source code
    for the tests can be found in each microservice's `test` folder.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 对三个核心微服务暴露的API进行的自动化集成测试非常相似，但更简单，因为它们不需要模拟任何东西！测试的源代码可以在每个微服务的`test`文件夹中找到。
- en: 'The tests are run automatically by Gradle when performing a build:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行构建时，Gradle会自动运行这些测试：
- en: '[PRE59]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can, however, specify that you only want to run the tests (and not the
    rest of the build):'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可以指定只运行测试（而不是构建的其余部分）：
- en: '[PRE60]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This was an introduction to how to write automated tests for microservices in
    isolation. In the next section, we will learn how to write tests that automatically
    test a microservice landscape. In this chapter, these tests will only be semi-automated.
    In upcoming chapters, the tests will be fully automated, a significant improvement.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何编写自动化测试以隔离微服务的介绍。在下一节中，我们将学习如何编写自动测试微服务架构。在本章中，这些测试只是半自动化的。在接下来的章节中，这些测试将完全自动化，这是一个重大的改进。
- en: Adding semi-automated tests of a microservice landscape
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加微服务架构的半自动化测试
- en: Being able to automatically test each microservice in isolation is, of course,
    very useful, but insufficient!
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 能够自动测试每个微服务是非常有用的，但还不够！
- en: We need a way to automatically test all of our microservices to ensure that
    they deliver what we expect!
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种自动测试所有微服务以确保它们提供我们期望的内容的方法！
- en: For this reason, I have written a simple bash script that can perform calls
    to a RESTful API using `curl` and verify its return code and parts of its JSON
    response using `jq`. The script contains two helper functions, `assertCurl()`
    and `assertEqual()`, to make the test code compact and easier to read.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我编写了一个简单的bash脚本，可以使用`curl`对RESTful API进行调用，并使用`jq`验证其返回代码和部分JSON响应。该脚本包含两个辅助函数`assertCurl()`和`assertEqual()`，以使测试代码更加简洁和易于阅读。
- en: 'For example, making a normal request and expecting 200 as the status code,
    as well as asserting that we get back a JSON response that returns the requested
    `productId` along with three recommendations and three reviews, looks like the
    following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，进行正常请求并期望状态码为200，以及断言我们得到一个返回所请求的`productId`以及三个推荐和三个评论的JSON响应，如下所示：
- en: '[PRE61]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Verifying that we get `404 (Not Found)` back as an HTTP response code (when
    we try to look up a product that doesn''t exist) looks as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 验证我们得到`404（未找到）`作为HTTP响应代码（当我们尝试查找一个不存在的产品时）的过程如下：
- en: '[PRE62]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The test script implements the manual tests that were described in the *Testing
    APIs manually* section and can be found in `$BOOK_HOME/Chapter03/2-basic-rest-services/test-em-all.bash`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本实现了“手动测试API”部分中描述的手动测试，并可以在`$BOOK_HOME/Chapter03/2-basic-rest-services/test-em-all.bash`中找到。
- en: Trying out the test script
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试测试脚本
- en: 'To try out the test script, perform the following steps:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试测试脚本，请执行以下步骤：
- en: 'First, start the microservices, as we did previously:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，像之前一样启动微服务：
- en: '[PRE63]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Once they''ve all started up, run the test script:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦它们全部启动，运行测试脚本：
- en: '[PRE64]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Expect the output to look similar to the following:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 期望输出看起来类似于以下内容：
- en: '![](img/34c2f31c-8138-4f03-9414-cfb4c0779f29.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34c2f31c-8138-4f03-9414-cfb4c0779f29.png)'
- en: 'Wrap this up by shutting down the microservices with the following command:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下命令关闭微服务：
- en: '[PRE65]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this section, we have taken the first steps toward automating testing a system
    landscape of cooperating microservices, all of which will be improved in upcoming
    chapters.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经迈出了自动化测试合作微服务系统架构的第一步，所有这些都将在即将到来的章节中得到改进。
- en: Summary
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have now built our first few microservices using Spring Boot. After being
    introduced to the microservice landscape, which we will use throughout this book,
    we learned how to use Spring Initializr to create skeleton projects for each microservice.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经使用Spring Boot构建了我们的前几个微服务。在介绍了微服务的基本概念后，我们学会了如何使用Spring Initializr为每个微服务创建骨架项目。
- en: Next, we learned how to add APIs using Spring WebFlux for the three core services
    and implemented a composite service that uses the three core services APIs to
    create an aggregated view of the information in them. The composite service uses
    the `RestTemplate` class in Spring Framework to perform HTTP requests to APIs
    that are exposed by the core services. After adding logic for error handling in
    the services, we ran some manual tests on the microservice landscape.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们学会了如何使用Spring WebFlux添加API，用于三个核心服务，并实现了一个复合服务，该服务使用三个核心服务的API来创建它们信息的聚合视图。复合服务使用Spring
    Framework中的`RestTemplate`类来执行对核心服务暴露的API的HTTP请求。在服务中添加错误处理逻辑后，我们对微服务进行了一些手动测试。
- en: We wrapped this chapter up by learning how to add tests for microservices in
    isolation and when they work together as a system landscape. To provide controlled
    isolation for the composite service, we mocked its dependencies to the core services
    using Mockito. Testing the whole system landscape is performed by a bash script
    that uses `curl` to perform calls to the API of the composite service.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过学习如何为孤立的微服务和作为系统架构一部分一起工作的微服务添加测试来结束了本章。为了为复合服务提供受控的隔离，我们使用Mockito模拟了它对核心服务的依赖关系。通过使用`curl`执行对复合服务API的调用的bash脚本来执行整个系统架构的测试。
- en: With these skills in place, we are ready to take the next step, entering the
    world of Docker and containers, in the next chapter! Among other things, we will
    learn how to use Docker to fully automate testing of a system landscape of cooperating
    microservices.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些技能，我们已经准备好迈出下一步，进入Docker和容器的世界，在下一章！除其他外，我们还将学习如何使用Docker来完全自动化测试一组合作微服务的系统架构。
- en: Questions
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the command that lists available dependencies when you create a new
    Spring Boot project using the `spring init` Spring Initializr CLI tool?
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用`spring init` Spring Initializr CLI工具创建新的Spring Boot项目时，列出可用依赖项的命令是什么？
- en: How can you set up Gradle to build multiple related projects with one command?
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何设置Gradle以一条命令构建多个相关项目？
- en: What are the `@PathVariable` and `@RequestParam` annotations used for?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@PathVariable`和`@RequestParam`注解分别用于什么？'
- en: How can you separate protocol-specific error handling from the business logic
    in an API implementation class?
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将协议特定的错误处理与API实现类中的业务逻辑分离？
- en: What is Mockito used for?
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mockito用于什么？

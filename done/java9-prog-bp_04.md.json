["```java\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?> \n    <project \n\n      xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n      http://maven.apache.org/xsd/maven-4.0.0.xsd\"> \n      <modelVersion>4.0.0</modelVersion> \n\n      <artifactId>datecalc-master</artifactId> \n      <version>1.0-SNAPSHOT</version> \n      <packaging>pom</packaging> \n      <modules> \n        <module>datecalc-lib</module> \n        <module>datecalc-cli</module> \n      </modules> \n    </project> \n\n```", "```java\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?> \n    <project \n\n      xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n      http://maven.apache.org/xsd/maven-4.0.0.xsd\"> \n      <modelVersion>4.0.0</modelVersion> \n      <parent> \n        <groupId>com.steeplesoft</groupId> \n          <artifactId>datecalc-master</artifactId> \n          <version>1.0-SNAPSHOT</version> \n      </parent> \n      <artifactId>datecalc-lib</artifactId> \n      <packaging>jar</packaging> \n      <dependencies> \n        <dependency> \n          <groupId>org.testng</groupId> \n          <artifactId>testng</artifactId> \n          <version>6.9.9</version> \n          <scope>test</scope> \n        </dependency> \n      </dependencies> \n    </project> \n\n```", "```java\n    module datecalc.lib { \n      exports com.steeplesoft.datecalc; \n    } \n\n```", "```java\n    public abstract class Token<T> {\n      protected T value;\n      public interface Info {\n        String getRegex();\n        Token getToken(String text);\n      }\n      public T getValue() {\n        return value;\n      }\n    }\n\n```", "```java\n    public class DateToken extends Token<LocalDate> { \n      private static final String TODAY = \"today\"; \n      public static String REGEX = \n        \"\\\\d{4}[-/][01]\\\\d[-/][0123]\\\\d|today\"; \n\n```", "```java\n    \"\\\\d{4}[-/][01]\\\\d[-/][0123]\\\\d|today\" \n\n```", "```java\n    public static DateToken of(String text) { \n      try { \n        return TODAY.equals(text.toLowerCase()) ? \n          new DateToken(LocalDate.now()) : \n          new DateToken( \n            LocalDate.parse(text.replace(\"/\", \"-\"))); \n      } catch (DateTimeParseException ex) { \n          throw new DateCalcException( \n            \"Invalid date format: \" + text); \n        } \n    } \n\n```", "```java\n    public class IntegerToken extends Token<Integer> { \n      public static final String REGEX = \"\\\\d+\"; \n\n```", "```java\n    public class OperatorToken extends Token<String> { \n      public static final String REGEX = \"\\\\+|-|to\"; \n\n```", "```java\n    public class TimeToken extends Token<LocalTime> { \n      private static final String NOW = \"now\"; \n      public static final String REGEX = \n        \"(?:[01]?\\\\d|2[0-3]):[0-5]\\\\d *(?:[AaPp][Mm])?|now\"; \n\n```", "```java\n    public static TimeToken of(final String text) { \n      String time = text.toLowerCase(); \n      if (NOW.equals(time)) { \n        return new TimeToken(LocalTime.now()); \n      } else { \n          try { \n            if (time.length() <5) { \n                time = \"0\" + time; \n            } \n            if (time.contains(\"am\") || time.contains(\"pm\")) { \n              final DateTimeFormatter formatter = \n                new DateTimeFormatterBuilder() \n                .parseCaseInsensitive() \n                .appendPattern(\"hh:mma\") \n                .toFormatter(); \n                return new \n                TimeToken(LocalTime.parse( \n                  time.replaceAll(\" \", \"\"), formatter)); \n            } else { \n                return new TimeToken(LocalTime.parse(time)); \n            } \n          } catch (DateTimeParseException ex) { \n              throw new DateCalcException( \n              \"Invalid time format: \" + text); \n            } \n        }\n    } \n\n```", "```java\n    public class UnitOfMeasureToken extends Token<ChronoUnit> { \n      public static final String REGEX =\n        \"years|year|y|months|month|weeks|week|w|days|\n         day|d|hours|hour|h|minutes|minute|m|seconds|second|s\"; \n      private static final Map<String, ChronoUnit> VALID_UNITS = \n        new HashMap<>(); \n\n```", "```java\n    static { \n      VALID_UNITS.put(\"year\", ChronoUnit.YEARS); \n      VALID_UNITS.put(\"years\", ChronoUnit.YEARS); \n      VALID_UNITS.put(\"months\", ChronoUnit.MONTHS); \n      VALID_UNITS.put(\"month\", ChronoUnit.MONTHS); \n\n```", "```java\n    public class DateCalcExpressionParser { \n      private final List<InfoWrapper> infos = new ArrayList<>(); \n\n      public DateCalcExpressionParser() { \n        addTokenInfo(new DateToken.Info()); \n        addTokenInfo(new TimeToken.Info()); \n        addTokenInfo(new IntegerToken.Info()); \n        addTokenInfo(new OperatorToken.Info()); \n        addTokenInfo(new UnitOfMeasureToken.Info()); \n      } \n      private void addTokenInfo(Token.Info info) { \n        infos.add(new InfoWrapper(info)); \n      } \n\n```", "```java\n    public interface Info { \n      String getRegex(); \n      Token getToken(String text); \n    } \n\n```", "```java\n    public static class Info implements Token.Info { \n      @Override \n      public String getRegex() { \n        return REGEX; \n      } \n\n      @Override \n      public DateToken getToken(String text) { \n        return of(text); \n      } \n    } \n\n```", "```java\n    private class InfoWrapper { \n      Token.Info info; \n      Pattern pattern; \n\n      InfoWrapper(Token.Info info) { \n        this.info = info; \n        pattern = Pattern.compile(\"^(\" + info.getRegex() + \")\"); \n      } \n    } \n\n```", "```java\n    public List<Token> parse(String text) { \n      final Queue<Token> tokens = new ArrayDeque<>(); \n\n      if (text != null) { \n        text = text.trim(); \n        if (!text.isEmpty()) { \n          boolean matchFound = false; \n          for (InfoWrapper iw : infos) { \n            final Matcher matcher = iw.pattern.matcher(text); \n            if (matcher.find()) { \n              matchFound = true; \n              String match = matcher.group().trim(); \n              tokens.add(iw.info.getToken(match)); \n              tokens.addAll( \n                parse(text.substring(match.length()))); \n                break; \n            } \n          } \n          if (!matchFound) { \n            throw new DateCalcException( \n              \"Could not parse the expression: \" + text); \n          } \n        } \n      } \n\n      return tokens; \n    } \n\n```", "```java\n    public class DateCalculator { \n      public DateCalculatorResult calculate(String text) { \n        final DateCalcExpressionParser parser = \n          new DateCalcExpressionParser(); \n        final Queue<Token> tokens = parser.parse(text); \n\n        if (tokens.size() > 0) { \n          if (tokens.peek() instanceof DateToken) { \n            return handleDateExpression(tokens); \n          } else if (tokens.peek() instanceof TimeToken) { \n              return handleTimeExpression(tokens); \n            } \n        } \n        throw new DateCalcException(\"An invalid expression\n          was given: \" + text); \n    } \n\n```", "```java\n    private DateCalculatorResult handleDateExpression( \n      final Queue<Token> tokens) { \n        DateToken startDateToken = (DateToken) tokens.poll(); \n        validateToken(tokens.peek(), OperatorToken.class); \n        OperatorToken operatorToken = (OperatorToken) tokens.poll(); \n        Token thirdToken = tokens.peek(); \n\n        if (thirdToken instanceof IntegerToken) { \n          return performDateMath(startDateToken, operatorToken,\n            tokens); \n        } else if (thirdToken instanceof DateToken) { \n            return getDateDiff(startDateToken, tokens.poll()); \n          } else { \n              throw new DateCalcException(\"Invalid expression\"); \n            } \n    } \n\n```", "```java\n    private void validateToken(final Token token,\n      final Class<? extends Token> expected) { \n        if (token == null || ! \n          token.getClass().isAssignableFrom(expected)) { \n            throw new DateCalcException(String.format( \n              \"Invalid format: Expected %s, found %s\", \n               expected, token != null ? \n               token.getClass().getSimpleName() : \"null\")); \n        } \n    } \n\n```", "```java\n    private DateCalculatorResult performDateMath( \n      final DateToken startDateToken, \n      final OperatorToken operatorToken, \n      final Queue<Token> tokens) { \n        LocalDate result = startDateToken.getValue(); \n        int negate = operatorToken.isAddition() ? 1 : -1; \n\n        while (!tokens.isEmpty()) { \n          validateToken(tokens.peek(), IntegerToken.class); \n          int amount = ((IntegerToken) tokens.poll()).getValue() *\n            negate; \n          validateToken(tokens.peek(), UnitOfMeasureToken.class); \n          result = result.plus(amount, \n          ((UnitOfMeasureToken) tokens.poll()).getValue()); \n        } \n\n        return new DateCalculatorResult(result); \n    } \n\n```", "```java\n    private DateCalculatorResult getDateDiff( \n      final DateToken startDateToken, final Token thirdToken) { \n        LocalDate one = startDateToken.getValue(); \n        LocalDate two = ((DateToken) thirdToken).getValue(); \n        return (one.isBefore(two)) ? new\n          DateCalculatorResult(Period.between(one, two)) : new\n            DateCalculatorResult(Period.between(two, one)); \n    } \n\n```", "```java\n    private DateCalculatorResult getTimeDiff( \n      final OperatorToken operatorToken, \n      final TimeToken startTimeToken, \n      final Token thirdToken) throws DateCalcException { \n        LocalTime startTime = startTimeToken.getValue(); \n        LocalTime endTime = ((TimeToken) thirdToken).getValue(); \n        return new DateCalculatorResult( \n          Duration.between(startTime, endTime).abs()); \n    } \n\n```", "```java\n    <properties>\n      <testng.version>6.9.9</testng.version>\n    </properties>\n    <dependencies> \n      <dependency> \n        <groupId>org.testng</groupId>   \n        <artifactId>testng</artifactId>   \n        <version>${testng.version}</version>   \n        <scope>test</scope> \n      </dependency>   \n    </dependencies> \n\n```", "```java\n    public class RegexTest { \n      @Test \n      public void dateTokenRegex() { \n        testPattern(DateToken.REGEX, \"2016-01-01\"); \n        testPattern(DateToken.REGEX, \"today\"); \n      } \n      private void testPattern(String pattern, String text) { \n        testPattern(pattern, text, false); \n      } \n\n      private void testPattern(String pattern, String text, \n        boolean exact) { \n          Pattern p = Pattern.compile(\"(\" + pattern + \")\"); \n          final Matcher matcher = p.matcher(text); \n\n          Assert.assertTrue(matcher.find()); \n          if (exact) { \n            Assert.assertEquals(matcher.group(), text); \n          } \n      } \n\n```", "```java\n    @Test \n    public void invalidStringsShouldFail() { \n      try { \n        parser.parse(\"2016/12/25 this is nonsense\"); \n        Assert.fail(\"A DateCalcException should have been\n          thrown (Unable to identify token)\"); \n      } catch (DateCalcException dce) { \n      } \n    } \n\n```", "```java\n    @Test(expectedExceptions = {DateCalcException.class}) \n    public void shouldRejectBadTimes() { \n      parser.parse(\"22:89\"); \n    } \n\n```", "```java\n    <dependency> \n      <groupId>org.tomitribe</groupId> \n      <artifactId>tomitribe-crest</artifactId> \n      <version>0.8</version> \n    </dependency> \n\n```", "```java\n    module datecalc.cli { \n      requires datecalc.lib; \n      requires tomitribe.crest; \n      requires tomitribe.crest.api; \n\n      exports com.steeplesoft.datecalc.cli; \n    } \n\n```", "```java\n    public class DateCalc { \n      @Command \n      public void dateCalc(String... args) { \n        final String expression = String.join(\" \", args); \n        final DateCalculator dc = new DateCalculator(); \n        final DateCalculatorResult dcr = dc.calculate(expression); \n\n```", "```java\n    String result = \"\"; \n    if (dcr.getDate().isPresent()) { \n      result = dcr.getDate().get().toString(); \n    } else if (dcr.getTime().isPresent()) { \n      result = dcr.getTime().get().toString(); \n    } else if (dcr.getDuration().isPresent()) { \n      result = processDuration(dcr.getDuration().get()); \n    } else if (dcr.getPeriod().isPresent()) { \n      result = processPeriod(dcr.getPeriod().get()); \n    } \n    System.out.println(String.format(\"'%s' equals '%s'\", \n      expression, result)); \n\n```", "```java\n    private String processDuration(Duration d) { \n      long hours = d.toHoursPart(); \n      long minutes = d.toMinutesPart(); \n      long seconds = d.toSecondsPart(); \n      String result = \"\"; \n\n      if (hours > 0) { \n        result += hours + \" hours, \"; \n      } \n      result += minutes + \" minutes, \"; \n      if (seconds > 0) { \n        result += seconds + \" seconds\"; \n      } \n\n      return result; \n    } \n\n```", "```java\n    private String processPeriod(Period p) { \n      long years = p.getYears(); \n      long months = p.getMonths(); \n      long days = p.getDays(); \n      String result = \"\"; \n\n      if (years > 0) { \n        result += years + \" years, \"; \n      } \n      if (months > 0) { \n        result += months + \" months, \"; \n      } \n      if (days > 0) { \n        result += days + \" days\"; \n      } \n      return result; \n    } \n\n```"]
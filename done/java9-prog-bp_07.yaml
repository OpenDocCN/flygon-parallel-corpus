- en: Email and Spam Management with MailFilter
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MailFilter进行电子邮件和垃圾邮件管理
- en: In computer science, we have a number of **laws**, the most famous of which
    is, perhaps, Moore's Law, which addresses the rate at which the computer processing
    power increases. Another law, although not as well known, and certainly not as
    serious, is one known as **Zawinski's Law**. Jamie Zawinski, best known for his
    role at Netscape and Mozilla, once noted that "Every program attempts to expand
    until it can read mail. Those programs which cannot so expand are replaced by
    ones which can." While Zawinski's Law hasn't been quite as accurate as Moore's
    Law, there does seem to be a ring of truth to it, doesn't there?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，我们有许多**定律**，其中最著名的可能是摩尔定律，它涉及计算机处理能力增加的速度。另一条定律，虽然不那么著名，当然也不那么严肃，被称为**Zawinski定律**。杰米·扎温斯基，以其在网景和Mozilla的角色而闻名，曾指出“每个程序都试图扩展到可以读取邮件的程度。那些无法扩展到这一程度的程序将被可以的程序所取代。”尽管Zawinski定律并不像摩尔定律那样准确，但似乎确实有一定的真实性，不是吗？
- en: 'In the spirit of Zawinski''s Law, even if not quite the letter, we will turn
    our attention to email in this chapter and see if we can address something that
    plagues us all: email clutter. Ranging from spam to mailing list postings, those
    messages just keep coming, and they keep piling up.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将关注电子邮件，看看我们是否能解决困扰我们所有人的问题：电子邮件杂乱。从垃圾邮件到邮件列表的帖子，这些消息不断涌现，不断堆积。
- en: I have several email accounts. As the head--and head geek--of my household,
    I'm often tasked with managing, whether they realize it or not, our digital assets,
    and while one little piece of spam might seem like nothing, over time, it can
    become a real problem. At a certain point, it almost seems too daunting to handle.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我有几个电子邮件账户。作为家里的负责人和极客，我经常被委托管理我们的数字资产，即使他们没有意识到，而一小部分垃圾邮件可能看起来微不足道，但随着时间的推移，它可能成为一个真正的问题。在某个时候，处理起来似乎几乎不可能。
- en: In this chapter, we'll take this very real, if perhaps somewhat overstated problem,
    and try to address it. That will give us the perfect excuse to use the standard
    Java email API, appropriately called JavaMail.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解决这个非常真实的问题，尽管可能有些夸张。这将给我们一个完美的借口来使用标准的Java电子邮件API，适当地称为JavaMail。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The JavaMail API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- JavaMail API'
- en: Email protocols
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 电子邮件协议'
- en: Some more JavaFX work (of course)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 一些更多的JavaFX工作（当然）'
- en: Creating job schedules in Java with Quartz
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 使用Quartz在Java中创建作业计划'
- en: Installing OS-specific services written in Java
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Java编写的特定于操作系统的服务
- en: It may be that you have your email inboxes well under control, in which case,
    congratulations! However, despite how tidy or overwhelming your mail client may
    be, we should have fun in this chapter while exploring the small but capable JavaMail
    API and the wonderful world of electronic mail.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你已经很好地控制了你的电子邮件收件箱，如果是这样，恭喜你！然而，无论你的邮件客户端是多么整洁或令人不知所措，我们在本章中应该在探索小而强大的JavaMail
    API和电子邮件的美妙世界时玩得开心。
- en: Getting started
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Before we get too far into the application, let's stop and take a quick look
    at what is involved in email. For being such a ubiquitous tool, it seems that
    it's a fairly opaque topic for most people, even the technically minded who might
    be inclined to read a book such as this. If we're going to work with it, it will
    be extremely helpful to understand it, even if just a bit. If you are not interested
    in the details of the protocols themselves, then feel free to skip ahead to the
    next section.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解应用程序之前，让我们停下来快速看一下电子邮件涉及的内容。尽管电子邮件是如此普遍的工具，似乎对大多数人来说，甚至是技术上有心的人来说，它似乎是一个相当不透明的话题。如果我们要使用它，了解它将非常有帮助，即使只是一点点。如果你对协议的细节不感兴趣，那么可以跳到下一节。
- en: A brief look at the history of email protocols
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '- 电子邮件协议的简要历史'
- en: Like many great computing concepts, **email**--**electronic mail**--was first
    introduced in the 1960s, though it looked much different then. A thorough history
    of email, while certainly a great technical curiosity, is beyond the scope of
    our purposes here, but I think it would be helpful to take a look at a few of
    the email protocols still relevant today, those being SMTP for sending mail, and
    POP3 and IMAP for (from your email client's perspective) receiving mail. (Technically,
    the email is received by the server via SMTP as that is the on-the-wire protocol
    used by **Mail Transfer Agents** (**MTAs**), to transfer mail from one server
    to another. We non-MTA authors never think of it in those terms, so we need not
    be overly concerned by that distinction).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多伟大的计算概念一样，**电子邮件**--**电子邮件**--最早是在1960年代引入的，尽管当时看起来大不相同。电子邮件的详细历史，虽然当然是一个很大的技术好奇心，但超出了我们在这里的目的范围，但我认为看一看今天仍然相关的一些电子邮件协议会很有帮助，其中包括用于发送邮件的SMTP，以及用于（从您的电子邮件客户端的角度）接收邮件的POP3和IMAP。（从技术上讲，电子邮件是通过SMTP由**邮件传输代理**（**MTA**）接收的，以将邮件从一个服务器传输到另一个服务器。我们非MTA作者从不以这种方式考虑，因此我们不需要过分担心这种区别）。
- en: 'We''ll start with sending an email, as our focus in this chapter will be more
    on folder management. **SMTP** (**Simple Mail Transport Protocol**), created in
    1982 and last updated in 1998, is the dominant protocol to send an email. Typically,
    in the days of SSL and TLS-secured connections, clients connected to the SMTP
    server via port 587\. The conversation between the server and a client, often
    referred to as a dialog, may look like this (as taken from the SMTP RFC at [https://tools.ietf.org/html/rfc5321](https://tools.ietf.org/html/rfc5321)):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从发送电子邮件开始，因为本章的重点将更多地放在文件夹管理上。SMTP（简单邮件传输协议）于1982年创建，最后更新于1998年，是发送电子邮件的主要协议。通常，在SSL和TLS安全连接的时代，客户端通过端口587连接到SMTP服务器。服务器和客户端之间的对话，通常称为对话，可能看起来像这样（摘自SMTP
    RFC [https://tools.ietf.org/html/rfc5321](https://tools.ietf.org/html/rfc5321)）：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this simple example, the client shakes hands with the server, then says who
    the email is from and who it's going to. Note that the email addresses are listed
    twice, but it is only these first instances (`MAIL FROM` and `RCPT TO`, the latter
    of which is repeated for each recipient) that matter. The second set is simply
    for the formatting and display of the email. That peculiarity noted, the actual
    email comes after the `DATA` line, which should be fairly self-explanatory. The
    lone period on a line marks the end of the message, at which point, the server
    confirms receipt of the message, and we sign off by saying `QUIT`. This example
    looks very simple, and it is, but things get much more complicated when the message
    has an attachment, such as an image or office document, or if the email is formatted
    in HTML.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，客户端与服务器握手，然后告诉邮件是从谁那里来的，发给谁。请注意，电子邮件地址列出了两次，但只有这些第一次出现的地方（`MAIL FROM`和`RCPT
    TO`，后者为每个收件人重复）才重要。第二组只是用于电子邮件的格式和显示。注意到这个特殊之处，实际的电子邮件在`DATA`行之后，这应该是相当容易理解的。一行上的孤立句号标志着消息的结束，此时服务器确认收到消息，我们通过说`QUIT`来结束。这个例子看起来非常简单，而且确实如此，但当消息有附件（如图像或办公文档）或者电子邮件以HTML格式进行格式化时，情况会变得更加复杂。
- en: While SMTP is used to send mail, the POP3 protocol is used to retrieve it. POP,
    or Post Office Protocol, was first introduced in 1984\. The bulk of the current
    standard, POP3, was introduced in 1988 with an update released in 1996\. POP3
    servers are meant to receive or download mail by a client such as Mozilla Thunderbird.
    If the server allows, the client can make an unsecured connection on port 110,
    with secure connections typically being made on port 995.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: SMTP用于发送邮件，而POP3协议用于检索邮件。POP，或者说是邮局协议，最早是在1984年引入的。当前标准的大部分POP3是在1988年引入的，并在1996年发布了更新。POP3服务器旨在接收或下载客户端（如Mozilla
    Thunderbird）的邮件。如果服务器允许，客户端可以在端口110上进行未加密连接，通常在端口995上进行安全连接。
- en: 'POP3 at one point was the dominant protocol by which users downloaded their
    mail. It was quick and efficient, and, for a while, our only option. Folder management
    was something that had to be done on the client side, as POP3 sees the mailbox
    as one big store, with no notion of folders (POP4 was intended to add some notion
    of folders, among other things, but there has not been any progress on the proposed
    RFC for several years). The POP3 (RC 1939, found at [https://tools.ietf.org/html/rfc1939](https://tools.ietf.org/html/rfc1939))
    gives this example dialog:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: POP3曾经是用户下载邮件的主要协议。它快速高效，一度是我们唯一的选择。文件夹管理是必须在客户端上完成的，因为POP3将邮箱视为一个大存储区，没有文件夹的概念（POP4旨在添加一些文件夹的概念，但在几年内没有对拟议的RFC取得任何进展）。POP3（RC
    1939，位于[https://tools.ietf.org/html/rfc1939](https://tools.ietf.org/html/rfc1939)）给出了这个示例对话：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that the client sends a `RETR` command to retrieve the message, followed
    by a `DELE` command to remove it from the server. This seems to be the standard/default
    configuration for most POP3 clients.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，客户端发送`RETR`命令来检索消息，然后发送`DELE`命令来从服务器中删除它。这似乎是大多数POP3客户端的标准/默认配置。
- en: Although, many clients can be configured to leave the mail on the server either
    for a certain number of days, or forever, possibly deleting the message from the
    server when it is deleted locally. If you've ever managed your mail this way,
    you've seen firsthand how this can complicate email management.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，许多客户端可以配置为在服务器上保留邮件一定数量的天数，或者永久保留，可能在本地删除邮件时从服务器中删除邮件。如果你以这种方式管理你的邮件，你会亲眼看到这如何使电子邮件管理变得复杂。
- en: For example, back in the days before laptops, imagine you have one desktop computer
    at the office and one at the house. You'd like to be able to read your email in
    both locations, so you set up your POP3 client on both machines. You spend your
    work day reading, deleting, and maybe sorting email. When you get home, those,
    say, 40 messages you managed at work are now sitting in your inbox, in big bold
    letters to indicate an unread message. You now have to repeat your email management
    tasks at home if you have any hope of keeping the two clients in similar states.
    It was tedious and error prone, and that led us to the creation of IMAP.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在没有笔记本电脑的时代，想象一下你在办公室有一台台式电脑，在家里也有一台。你希望能够在两个地方都阅读你的电子邮件，所以你在两台机器上都设置了POP3客户端。你在工作日里阅读、删除，也许还分类邮件。当你回家时，那些在工作中处理的40封邮件现在都在你的收件箱里，用粗体字标记为未读邮件。如果你希望保持两个客户端的状态相似，你现在必须在家里重复你的电子邮件管理任务。这是繁琐且容易出错的，这导致我们创建了IMAP。
- en: '**IMAP** or **Internet Access Message Protocol**, was created in 1986, with
    one of its design goals being permitting the complete management of a mailbox,
    folders, and all, by multiple clients. It has seen several revisions over the
    years, with IMAP 4 revision 1 being the current standard. Clients connect to an
    IMAP server on port 143 for unsecured connections, and 993 for SSL to TLS-based
    connections.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**IMAP**或**Internet Access Message Protocol**，创建于1986年，其设计目标之一是允许多个客户端完全管理邮箱、文件夹等。多年来，它经历了几次修订，IMAP
    4修订1是当前的标准。客户端通过端口143连接到IMAP服务器进行未加密连接，通过端口993连接到SSL到TLS的连接。'
- en: 'IMAP, since it offers much more robust functionality than POP, is a more complicated
    protocol. From the RFC ([https://tools.ietf.org/html/rfc3501](https://tools.ietf.org/html/rfc3501)),
    we can look at the following sample dialog:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: IMAP，因为它提供比POP更强大的功能，所以是一个更复杂的协议。从RFC（[https://tools.ietf.org/html/rfc3501](https://tools.ietf.org/html/rfc3501)）中，我们可以看到以下示例对话：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, there's much more detail there than in our example POP3 dialog.
    This should also highlight why we're using an API like JavaMail rather than opening
    a socket and talking directly to the server ourselves. Speaking of JavaMail, let's
    turn our attention to this standard API and see what it can do for us.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这里比我们的示例POP3对话中有更多的细节。这也应该突显出为什么我们使用像JavaMail这样的API，而不是直接打开套接字并直接与服务器通信。说到JavaMail，让我们把注意力转向这个标准API，看看它能为我们做些什么。
- en: JavaMail, the Standard Java API for Email
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaMail，用于电子邮件的标准Java API
- en: The JavaMail API is a set of abstractions that provide a protocol and platform-independent
    way of working with email. While it is a required part of **Java Enterprise Edition**
    (**Java EE**), it is an add-on library for Java SE, meaning you'll have to download
    it separately, which we'll handle via our POM file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: JavaMail API是一组抽象，提供了一种与电子邮件一起工作的协议和平台无关的方式。虽然它是**Java企业版**（**Java EE**）的必需部分，但它是Java
    SE的附加库，这意味着你需要单独下载它，我们将通过我们的POM文件处理。
- en: Our primary interest with this chapter's application is message management,
    but we'll take a bit of time to look at sending email using the API, so you'll
    have something to work with should you ever find yourself needing to do so.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的应用程序主要关注消息管理，但我们将花一点时间来看看如何使用API发送电子邮件，这样你以后如果需要的话就有东西可以使用。
- en: 'To start sending mails, we need to get a JavaMail `Session`. To do that, we''ll
    need to set up some properties as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始发送邮件，我们需要获取JavaMail `Session`。为此，我们需要设置一些属性如下：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We''ll send email through Gmail''s server, and we''ll use SMTP over SSL. With
    this `Properties` instance, we can create our `Session` instance as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过Gmail的服务器发送电子邮件，并且我们将使用SMTP over SSL。有了这个`Properties`实例，我们可以创建我们的`Session`实例如下：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To log in to the server, we need to specify credentials, which we do via the
    anonymous `PasswordAuthentication` instance. Once we have our `Session` instance,
    we need to create a `Transport` as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要登录服务器，我们需要指定凭据，我们通过匿名的`PasswordAuthentication`实例来实现。一旦我们有了`Session`实例，我们需要创建一个`Transport`如下：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that for the protocol parameter, we specify `smtps`, which tells the JavaMail
    implementation that we want SMTP over SSL/TLS. We''re now ready to build our message
    using the following block of code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于协议参数，我们指定了`smtps`，这告诉JavaMail实现我们希望使用SMTP over SSL/TLS。现在我们准备使用以下代码块构建我们的消息：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'An email message is modeled using the `MimeMessage` class, so we create an
    instance of that using our `Session` instance. We set the from and to addresses,
    as well as the subject. To make things more interesting, we''ll attach a file
    using a `MimeBodyPart`, as we see here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件消息使用`MimeMessage`类建模，所以我们使用我们的`Session`实例创建一个实例。我们设置了发件人和收件人地址，以及主题。为了使事情更有趣，我们将使用`MimeBodyPart`附加一个文件，如下所示：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our message will have two parts, modeled using `MimeBodyPart`, one is the body
    of the message, which is simple text, and the other is an attachment. In this
    case, we''re simply attaching a data file from our tests, which we''ll see later.
    Once we''ve defined the parts, we combine them using `MimeMultipart`, then set
    it as the content on our message, which we can now using the `transport.sendMessage()`
    method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的消息将有两个部分，使用`MimeBodyPart`建模，一个是消息的正文，是简单的文本，另一个是附件。在这种情况下，我们只是附加了一个数据文件，我们稍后会看到。一旦我们定义了这些部分，我们使用`MimeMultipart`将它们组合起来，然后将其设置为我们的消息的内容，现在我们可以使用`transport.sendMessage()`方法：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Within just a few seconds, you should see the following email show up in your
    inbox:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅几秒钟内，你应该会在收件箱中看到以下电子邮件出现：
- en: '![](img/4dd554f8-c9ec-4b1a-8d9f-b0c28215ea48.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4dd554f8-c9ec-4b1a-8d9f-b0c28215ea48.png)'
- en: 'If you want to send an HTML email with a text alternative, you can do this
    using the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想发送带有文本替代的HTML电子邮件，可以使用以下代码：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that we set the content on each `MimeBodyPart`, specifying the mime type,
    and when we create the `Multipart`, we pass alternative as the `subtype` parameter.
    Failure to do so will result in an email that shows both parts, one after the
    other, which is certainly not what we want. If we''ve written our application
    correctly, we should see something like the following in our email client:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在每个`MimeBodyPart`上设置了内容，指定了mime类型，当我们创建`Multipart`时，我们将alternative作为`subtype`参数传递。如果不这样做，将会导致电子邮件显示两个部分，一个接一个，这显然不是我们想要的。如果我们正确编写了应用程序，我们应该在我们的电子邮件客户端中看到以下内容：
- en: '![](img/a6a7a1c4-d024-48ea-8a82-d24e1dbfb7b7.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6a7a1c4-d024-48ea-8a82-d24e1dbfb7b7.png)'
- en: You can't see the red text, of course, in black and white print, but you can
    see the bold and italicized text, which means the HTML version was shown, rather
    than the text version. Mission accomplished!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然看不到红色文本，在黑白打印中，但你可以看到粗体和斜体文本，这意味着显示的是HTML版本，而不是文本版本。任务完成！
- en: Sending emails is pretty fun, but we're here to learn about folder and message
    management, so let's turn our attention to that, and we'll start by setting up
    our project.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 发送电子邮件非常有趣，但我们在这里是为了学习文件夹和消息管理，所以让我们把注意力转向那里，并且我们将从设置我们的项目开始。
- en: Building the CLI
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建CLI
- en: This project, like the others, will be a multi-module Maven project. We'll have
    one module for all of the core code, and we'll have another for the GUI we'll
    write to help manage the rules.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目，就像其他项目一样，将是一个多模块的Maven项目。我们将有一个模块用于所有核心代码，另一个模块用于我们将编写的GUI来帮助管理规则。
- en: 'To create the project, we''ll do something a little different this time. Rather
    than creating the project using NetBeans, we''ll create it from the command line
    using Maven archetypes, which can be thought of roughly as project templates,
    so you can see how it''s done that way:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建项目，这次我们将做一些不同的事情。我们将使用Maven原型从命令行创建项目，可以将其粗略地视为项目模板，这样你就可以看到如何以这种方式完成：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once Maven has finished processing, change directory into the new project''s
    directory, `mailfilter-master`. From here, we can create the first of our projects,
    the CLI:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Maven处理完成，就切换到新项目的目录`mailfilter-master`。从这里，我们可以创建我们的第一个项目，CLI：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will create a new project under `mailfilter-master` called `mailfilter-cli`.
    We can now open `mailfilter-cli` in NetBeans and get to work.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`mailfilter-master`下创建一个名为`mailfilter-cli`的新项目。我们现在可以在NetBeans中打开`mailfilter-cli`并开始工作。
- en: The first thing we need to do is spec out how we want this tool to work. At
    a high level, we want to be able to specify an arbitrary number of rules for an
    account. These rules will allow us to move or delete emails based on certain criteria,
    such as the sender or the email's age. To keep things simple, we'll scope all
    of the rules to a specific account, and limit the operations to move and delete.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是规定我们希望这个工具如何工作。在高层次上，我们希望能够为一个帐户指定任意数量的规则。这些规则将允许我们根据某些标准移动或删除电子邮件，例如发件人或电子邮件的年龄。为了保持简单，我们将所有规则范围限定为特定帐户，并将操作限制为移动和删除。
- en: 'Let''s start by taking a look at what the account may look like:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下帐户可能是什么样子：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is basically a very simple **POJO** (**Plain Old Java Object**) with six
    properties: `serverName`, `serverPort`, `useSsl`, `userName`, `password`, and
    `rules`. What are those annotations, though? Those come from a library called
    Bean Validation that provides some annotations and supporting code that allows
    us to express, declaratively, constraints on the values , which the variable can
    hold. Here are the annotations we''re using, and what they mean:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是一个非常简单的**POJO**（**Plain Old Java Object**），有六个属性：`serverName`，`serverPort`，`useSsl`，`userName`，`password`和`rules`。那些注释是什么呢？那些来自一个名为Bean
    Validation的库，它提供了一些注释和支持代码，允许我们以声明方式表达对值的约束，变量可以保存。这里是我们正在使用的注释及其含义：
- en: '`@NotBlank`: This tells the system that the value can''t be null, nor can it
    be an empty string (effectively, `string != null && !string.trim() .equals("")`)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NotBlank`：这告诉系统该值不能为空，也不能是空字符串（实际上，`string != null && !string.trim() .equals("")`）'
- en: '`@NotNull`: This tells the system that the value can''t be null'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NotNull`：这告诉系统该值不能为空'
- en: '`@Min`: This describes a minimum valid value'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Min`：描述最小有效值'
- en: 'There are, of course, many, many others, and the system defines a means for
    you to define your own, so it''s a very simple, yet very powerful framework to
    validate input, which brings up an important point: these constraints are only
    validated when the Bean Validation framework is asked to do so. We could easily
    build up a large collection of these `Account` instances with every field holding
    invalid data, and the JVM would be perfectly happy with that. The only way to
    apply the Bean Validation constraints is to ask it to check the instances we provide
    it with. In a nutshell, it''s the API and not the JVM that enforces these constraints.
    That may seem obvious, but, sometimes, it pays to be explicit.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有许多其他的方法，系统定义了一种方法让您定义自己的方法，因此这是一个非常简单但非常强大的框架，用于验证输入，这带来了一个重要的观点：这些约束只有在要求Bean
    Validation框架进行验证时才会被验证。我们可以轻松地构建一个大量的`Account`实例集合，其中每个字段都保存着无效数据，JVM对此也会非常满意。应用Bean
    Validation约束的唯一方法是要求它检查我们提供的实例。简而言之，是API而不是JVM强制执行这些约束。这似乎是显而易见的，但有时明确说明是值得的。
- en: 'Before we go any further, we need to add Bean Validation to our project. We''ll
    use the reference implementation: `Hibernate Validator`. We''ll also need the
    Expression Language API and an implementation in our project. We get all of those
    by adding the following dependencies to `pom.xml`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步进行之前，我们需要将Bean Validation添加到我们的项目中。我们将使用参考实现：`Hibernate Validator`。我们还需要在我们的项目中添加表达式语言API和一个实现。我们通过将以下依赖项添加到`pom.xml`中来获得所有这些依赖项：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Getting back to our model, there are some getters and setters, of course, but
    those are not very interesting. What is interesting, though, is the implementation
    of `equals()` and `hashCode()`. Josh Bloch, in his seminal work, Effective Java,
    says this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的模型，当然有一些getter和setter，但这些并不是很有趣。但有趣的是`equals()`和`hashCode()`的实现。Josh Bloch在他的重要作品《Effective
    Java》中说：
- en: Always override `hashCode` when you override `equals`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重写`equals`时，总是要重写`hashCode`。
- en: 'The main point of his assertion is that failure to do so violates the `equals()`
    contract, which states that equals objects must have equals hashes, which can
    result in incorrect and/or unpredictable behavior if your class is used in any
    hash-based collection, such as `HashMap`. Bloch then lists some rules to create
    a good `hashCode` implementation, as well as a good `equals` implementation, but
    here''s my advice: let the IDE do the work for you, which is what we''ve done
    in the following code block for `equals()`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 他的主要观点是，不这样做违反了`equals()`合同，该合同规定相等的对象必须具有相等的哈希值，这可能导致类在任何基于哈希的集合中使用时出现不正确和/或不可预测的行为，例如`HashMap`。
    Bloch然后列出了一些创建良好的`hashCode`实现以及良好的`equals`实现的规则，但这是我的建议：让IDE为您完成这项工作，这就是我们在以下代码块中为`equals()`所做的。
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have done the same for `hashCode()` here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里也对`hashCode()`做了同样的事情：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that every method tested in `equals()` is also used in `hashCode()`. It's
    absolutely vital that your implementations follow this rule, or you'll end up
    with methods that don't really work as they should. It's possible that your IDE
    can help with this as you are generating the methods, but you must make sure that
    you are indeed using the same list of fields, and certainly, should you ever modify
    one of the methods, the other method must be updated accordingly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`equals()`中测试的每个方法也在`hashCode()`中使用。您的实现必须遵循这个规则，否则您最终会得到不像应该那样工作的方法。您的IDE可能会在生成方法时帮助您，但您必须确保您确实使用相同的字段列表，当然，如果您修改了其中一个方法，另一个方法必须相应地更新。
- en: 'We now have `Account`, so what does `Rule` look like? Let''s take a look at
    the following piece of code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`Account`，那么`Rule`是什么样子呢？让我们看一下以下代码片段：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The validation on this class is two-fold. First, we can see the same field-level
    constraints we saw on `Account`: `type` cannot be null, `sourceFolder` cannot
    be blank, and `olderThan` must be at least 1\. While you may not recognize it
    for what it is, we also have a class-level constraint in `@ValidRule`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的验证是双重的。首先，我们可以看到与`Account`上看到的相同的字段级约束：`type`不能为空，`sourceFolder`不能为空，`olderThan`必须至少为1。虽然您可能不会认识它是什么，但我们在`@ValidRule`中也有一个类级别的约束。
- en: 'Field-level constraints can see only the field to which they have been applied.
    This means that if the valid values for a field are dependent on the value of
    some other field, these types of constraints are not appropriate. Class-level
    rules, though, allow us to look at the whole object when doing validation, so
    we can look to see what the value of one field is when validating another. This
    also means a bit more code for us, so we''ll start with the following annotation:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 字段级别的约束只能看到它们所应用的字段。这意味着如果字段的有效值取决于某个其他字段的值，这种类型的约束是不合适的。然而，类级别的规则允许我们在验证时查看整个对象，因此我们可以在验证另一个字段时查看一个字段的值。这也意味着我们需要更多的代码，所以我们将从以下注解开始：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In case you've never seen the source for an annotation before, this is a fairly
    typical example. Rather than declaring the type of the object to be `class` or
    `interface`, we used `@interface`, a subtle but important difference. The fields
    of the annotation are also a bit different, as there are no visibility modifiers,
    and the types cannot be primitives. Note the use of the `default` keyword.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前从未见过注解的源代码，这是一个相当典型的例子。与其声明对象的类型为`class`或`interface`，我们使用了`@interface`，这是一个细微但重要的区别。注解的字段也有点不同，因为没有可见性修饰符，类型也不能是原始类型。注意使用了`default`关键字。
- en: 'The annotation itself also has annotations, which are as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注解本身也有注解，如下所示：
- en: '`@Target`: This restricts the types of elements this annotation can be applied
    to; in this case, types and other annotations.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Target`：这限制了这个注解可以应用的元素类型；在这种情况下，是类型和其他注解。'
- en: '`@Retention`: This instructs the compiler whether or not it should write the
    annotation to the class file, and making it available at runtime.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Retention`：这指示编译器是否应该将注解写入类文件，并在运行时可用。'
- en: '`@Constraint`: This is a Bean Validation annotation that identifies our annotation
    as a new constraint type. The value of this annotation tells the system what `ConstraintValidator`
    processes the validation logic for this constraint.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Constraint`：这是一个Bean验证注解，标识我们的注解作为一个新的约束类型。这个注解的值告诉系统哪个`ConstraintValidator`处理这个约束的验证逻辑。'
- en: '`@Documented`: This indicates that the presence of this annotation on any type
    should be considered a part of that type''s public API.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Documented`：这表明在任何类型上存在这个注解应该被视为该类型的公共API的一部分。'
- en: 'Our `ConstraintValidator` implementation to handle this new constraint is a
    bit more complicated. We declared the class like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ConstraintValidator`实现来处理这个新的约束有点复杂。我们声明了这个类如下：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Bean Validation provides a parameterized interface for constraint validation
    that takes the type of the constraint and the object type to which the logic in
    the validator applies. This allows you to write different validators of a given
    constraint for different object types. In our case, we could specify `Rule` rather
    than `Object`. If we were to do that, any time something other than `Rule` is
    annotated with `@ValidRule` and the instance is validated, the calling code will
    see an exception thrown. What we've done instead, as you will see, is validate
    the annotated type, specifically adding a constraint violation if needed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Bean验证为约束验证提供了一个参数化接口，该接口接受约束的类型和验证逻辑适用的对象类型。这允许您为不同的对象类型编写给定约束的不同验证器。在我们的情况下，我们可以指定`Rule`而不是`Object`。如果我们这样做，任何时候除了`Rule`之外的东西被注解为`@ValidRule`并且实例被验证，调用代码将看到一个异常被抛出。相反，我们所做的是验证被注解的类型，特别是在需要时添加约束违规。
- en: 'The interface requires that we implement this method as well, but we have no
    work to be done here, so it has an empty method body, as shown here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接口要求我们也实现这个方法，但是我们这里没有工作要做，所以它有一个空的方法体，如下所示：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The interesting method is called `isValid()`. It''s a bit long, so let''s step
    through it piece by piece:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的方法叫做`isValid()`。它有点长，所以让我们一步一步地来看：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The first step is to make sure `value` is not null. We have two choices: return
    `true` if it''s null, indicating there''s no problem, or return `false`, indicating
    that there is a problem. Our choice depends on how we want the application to
    behave. Reasonable arguments can be made for either approach, but it seems that
    it would make sense for a null `Rule` to be considered invalid, so let''s change
    the body of that for it to look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是确保`value`不为空。我们有两种选择：如果它是空的，返回`true`，表示没有问题，或者返回`false`，表示有问题。我们的选择取决于我们希望应用程序的行为。对于任何一种方法都可以提出合理的论点，但似乎认为将空的`Rule`视为无效是有道理的，所以让我们将这个部分的主体改为这样：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We build `ConstraintViolation` using the specified message, add that to `ConstraintValidatorContext`,
    `ctx`, and return false to indicate a failure.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用指定的消息构建`ConstraintViolation`，将其添加到`ConstraintValidatorContext`，`ctx`，并返回`false`以指示失败。
- en: 'Next, we want to make sure we''re dealing with an instance of `Rule`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要确保我们正在处理一个`Rule`的实例：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once we''re sure we have a non-null instance of `Rule`, we can get to the heart
    of our validation logic:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定我们有一个非空的`Rule`实例，我们就可以进入我们的验证逻辑的核心：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''d like to be able to gather all of the violations, so we create a `boolean`
    variable to hold the current state, then we cast the value as `Rule` to make dealing
    with the instance a bit more natural. In our first test, we make sure that, if
    the type of `Rule` is `RuleType. MOVE`, it has a destination folder specified.
    We do so using this private method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要能够收集所有的违规行为，所以我们创建一个`boolean`变量来保存当前状态，然后我们将值转换为`Rule`，以使处理实例更加自然。在我们的第一个测试中，我们确保，如果`Rule`的类型是`RuleType.
    MOVE`，它有一个指定的目标文件夹。我们使用这个私有方法来做到这一点：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If `value` is blank, we add `ConstraintViolation`, as we've already seen, using
    the specified message, and return `false`. If it is not blank, we return `true`.
    This value is then ANDed with `valid` to update the current state of the `Rule`
    validation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`value`为空，我们添加`ConstraintViolation`，就像我们已经看到的那样，使用指定的消息，并返回`false`。如果不为空，我们返回`true`。然后这个值与`valid`进行AND运算，以更新`Rule`验证的当前状态。
- en: 'The `isBlank()` method is very simple:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`isBlank()`方法非常简单：'
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is a very common check, and is actually logically identical to the validator
    behind Bean Validation's `@NotBlank`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常常见的检查，实际上在逻辑上与Bean Validation的`@NotBlank`背后的验证器是相同的。
- en: 'Our next two tests are related. The logic is this: the rule must specify either
    text to match, or a maximum age in days. The test for that looks like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下两个测试是相关的。逻辑是这样的：规则必须指定要匹配的文本，或者最大的天数。测试看起来像这样：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If `Rule` specifies `matchingText`, then we validate that `fields` has been
    set properly. If neither `matchingText` nor `olderThan` were set, then we add
    `ConstraintViolation` with a message to that effect and set `valid` to false.
    Our `fields` validation looks like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Rule`指定了`matchingText`，那么我们验证`fields`是否已正确设置。如果既没有设置`matchingText`也没有设置`olderThan`，那么我们会添加一个`ConstraintViolation`，并设置`valid`为false。我们的`fields`验证如下：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We make sure that `fields` is neither null nor empty. We do not do any validation
    here on the actual contents of the field `Set`, though we certainly could.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保`fields`既不是null也不是空。我们在这里不对`Set`字段的实际内容进行任何验证，尽管我们当然可以。
- en: 'We have now written, possibly, our very first custom validation. Your reaction
    is likely something like, "Wow! That''s a lot of code for a ''simple'' validation",
    and you''re right. Before you throw the baby out with the bath water, think about
    this: the value of Bean Validation is that you can take potentially complex validation
    logic and hide it behind a very small annotation. You can then reuse this logic
    wherever you want simply by placing your constraint annotation in the appropriate
    places. The logic is expressed in one place, maintained in one place, but used
    in many, all very neatly and concisely.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能已经编写了我们的第一个自定义验证。你的反应可能是：“哇！这对于一个‘简单’的验证来说是相当多的代码”，你是对的。在你把孩子和洗澡水一起扔掉之前，想一想：Bean
    Validation的价值在于你可以将潜在复杂的验证逻辑隐藏在一个非常小的注解后面。然后，你可以通过在适当的位置放置你的约束注解来简单地重用这个逻辑。逻辑在一个地方表达，一个地方维护，但在许多地方使用，非常整洁和简洁。
- en: So, yes, that's a good deal of code, but you only have to write it once, and
    the consumers of the constraints never need to see it. There's not really much
    extra work over and above what you'd normally write, but it's up to you to decide
    if this extra bit of work is worth the time.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，是的，这是相当多的代码，但你只需要写一次，约束的使用者永远不需要看到它。实际上，与通常写的代码相比，这并没有太多额外的工作，但这取决于你是否认为这额外的工作值得一试。
- en: 'Now that we''ve taken a quick look at custom Bean Validation constraints, let''s
    return to our data model. The final piece to show is the `RuleType` enum:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经快速浏览了自定义Bean Validation约束，让我们回到我们的数据模型。最后要展示的是`RuleType`枚举：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is a basic Java `enum` with two possible values, `DELETE` and `MOVE`, but
    we've also added a helper method to return the appropriate `RuleType` instance
    for a given String representation. This will help us when we're unmarshaling a
    `Rule` from JSON, for example.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的Java `enum`，有两个可能的值，`DELETE`和`MOVE`，但我们还添加了一个辅助方法，以返回给定字符串表示的适当的`RuleType`实例。这将在我们从JSON中解组`Rule`时帮助我们。
- en: With our data model defined, we're ready to start writing the code for the utility
    itself. While the Maven module is called `mailfilter-cli`, we will not concern
    ourselves here with a robust command-line interface, like we saw in previous chapters.
    Instead, we'll provide a very basic interaction with the command line, leaving
    an OS service, which we'll look at later, as the preferred means of usage.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们定义的数据模型，我们准备开始编写实用程序本身的代码。虽然Maven模块被称为`mailfilter-cli`，但我们在这里不会关心一个健壮的命令行界面，就像我们在前几章中看到的那样。相反，我们将提供一个与命令行的非常基本的交互，将OS服务留作首选的使用方式，我们稍后会看到。
- en: 'It is at this point that we will begin using the JavaMail API, so we need to
    make sure we have our project set up correctly, so we add the following lines
    of code to `pom.xml`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将开始使用JavaMail API，所以我们需要确保我们的项目设置正确，因此我们在`pom.xml`中添加以下代码：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In our IDE, we create a new class, `MailFilter`, and create the familiar `public
    static void main` method as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的IDE中，我们创建一个新的类`MailFilter`，并创建如下的熟悉的`public static void main`方法：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: NetBeans supports a number of code templates. The template of interest here
    is `psvm`, which will create a `public static void main` method. To use it, make
    sure you are on an empty line inside the class definition (to avoid odd formatting
    issues), then type `psvm` and press tab. NetBeans creates the method for you and
    places the cursor on the first line of the empty method, ready for you to start
    coding. You can find dozens of other helpful code templates by navigating to Tools
    | Options | Editor | Code Templates. You can even define your own.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans支持许多代码模板。这里感兴趣的模板是`psvm`，它将创建一个`public static void main`方法。要使用它，请确保你在类定义的空行上（以避免奇怪的格式问题），然后输入`psvm`并按tab键。NetBeans会为你创建方法，并将光标放在空方法的第一行上，准备让你开始编码。你可以通过导航到工具
    | 选项 | 编辑器 | 代码模板找到其他几十个有用的代码模板。你甚至可以定义自己的模板。
- en: 'In our `main()` method, we create an instance of `MainFilter`, passing in any
    rule definition file that may have been specified on the command line, and calling
    `run()`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main()`方法中，我们创建一个`MainFilter`的实例，传入可能在命令行中指定的任何规则定义文件，并调用`run()`：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We start by creating an instance of `AccountService`, which wraps up the details
    of reading and writing the `Rules` file. For each account in the specified file,
    we create `AccountProcessor`, which encapsulates the rule processing logic.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个`AccountService`的实例，它封装了读取和写入`Rules`文件的细节。对于指定文件中的每个帐户，我们创建一个`AccountProcessor`，它封装了规则处理逻辑。
- en: 'The `AccountService` instance may not sound very exciting, but there are some
    pretty interesting technical bits hidden away behind that public interface. We
    see where the Bean Validation constraints are actually checked, and we also see
    the use of the Jackson JSON library to read and write the `Rules` file. Before
    we can start using Jackson, we need to add it to our project, which we do by adding
    this `pom.xml`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccountService`实例可能听起来并不令人兴奋，但在这个公共接口的背后隐藏着一些非常有趣的技术细节。我们看到了Bean Validation约束是如何实际检查的，我们还看到了使用Jackson
    JSON库来读取和写入`Rules`文件。在我们可以开始使用Jackson之前，我们需要将其添加到我们的项目中，我们通过添加这个`pom.xml`来实现：'
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You should, as always, make sure that you are on the latest version of the library.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终确保您使用的是库的最新版本。
- en: 'This is not a big class to start with, but only three methods are of any interest
    here. We''ll start with the most basic one, which is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个很大的类，但这里只有三种方法是有趣的。我们将从最基本的方法开始，如下所示：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The only reason I include this here is that reading a file from the user's home
    directory is something I find myself doing fairly frequently, and you might too.
    This example shows you how to do just that, attempting to find the rule file at
    `~/.mailfilter/rules.json` if the user does not specify a file explicitly. Generated
    or specified, if the rule file can't be found, we throw an exception.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里包含的唯一原因是，从用户的主目录中读取文件是我发现自己经常做的事情，您可能也是如此。这个示例向您展示了如何做到这一点，如果用户没有明确指定文件，则尝试在`~/.mailfilter/rules.json`中找到规则文件。生成或指定，如果找不到规则文件，我们会抛出异常。
- en: 'Perhaps the most interesting method is the `getAccounts()` method. We''ll step
    through this one slowly:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最有趣的方法是`getAccounts()`方法。我们将慢慢地逐步进行：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: These three statements are setting up some objects required to process the accounts.
    The first is `Validator`, which is the Bean Validation class that is our entry
    point to apply and check the constraints we've described on our data models. The
    next, `ObjectMapper`, is a Jackson class that will map a JSON data structure onto
    our Java data model. We need to specify `ACCEPT_SINGLE_VALUE_AS_ARRAY` to make
    sure that Jackson properly handles any lists in our model. Finally, we create
    `List` to hold our `Account` instances.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个语句正在设置一些处理账户所需的对象。首先是`Validator`，它是Bean Validation类，是我们应用和检查我们在数据模型上描述的约束的入口点。接下来是`ObjectMapper`，这是一个Jackson类，它将把JSON数据结构映射到我们的Java数据模型上。我们需要指定`ACCEPT_SINGLE_VALUE_AS_ARRAY`以确保Jackson正确处理我们模型中的任何列表。最后，我们创建`List`来保存我们的`Account`实例。
- en: 'Reading the rules file into memory and getting that as instances of our data
    model is extremely easy with Jackson:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jackson将规则文件读入内存并将其作为我们数据模型的实例非常容易：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Since the property names in our Java classes match the keys used in our JSON
    file, `ObjectMapper` can easily read the data from the JSON file and build our
    in-memory model with just this one line. Note the `TypeReference` instance. We
    want Jackson to return a `List<Account>` instance, but due to some design decisions
    in the JVM, direct access to parameterized types at runtime is not possible. The
    `TypeReference` class, however, helps capture this information, which Jackson
    then uses in creating the data model. If we passed `List.class`, we would get
    a type cast failure at runtime.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们Java类中的属性名称与我们的JSON文件中使用的键匹配，`ObjectMapper`可以轻松地从JSON文件中读取数据，并仅使用这一行构建我们的内存模型。请注意`TypeReference`实例。我们希望Jackson返回一个`List<Account>`实例，但由于JVM中的一些设计决策，直接访问运行时参数化类型是不可能的。然而，`TypeReference`类有助于捕获这些信息，Jackson然后使用它来创建数据模型。如果我们传递`List.class`，我们将在运行时获得类型转换失败。
- en: 'Now that we have our `Account` instances, we''re ready to start validation:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的`Account`实例，我们准备开始验证：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Using `List.forEach()`, we iterate over each account in `List` (the null check
    was not shown here). For each `Account`, we call `validator.validate()`, which
    is when the constraints are actually validated. Up to this point, they were just
    annotations stored in the class, with the JVM happily carrying them along, but
    not doing anything else with them. Bean Validation, as we discussed earlier, is
    the enforcer of the constraints described by the annotations, and here we see
    that manual API call.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`List.forEach()`，我们遍历`List`中的每个账户（这里没有显示空值检查）。对于每个`Account`，我们调用`validator.validate()`，这是实际验证约束的时候。到目前为止，它们只是存储在类中的注释，JVM很高兴地将它们一起携带，但不做其他任何事情。正如我们之前讨论的那样，Bean
    Validation是注释描述的约束的执行者，在这里我们看到了手动API调用。
- en: When the call to the `validator` returns, we need to see if there were any `ConstraintViolations`.
    If there were, we fairly naively print a message to standard out detailing each
    of the failures. If the rule has multiple violations, thanks to how we wrote our
    validator, we'll see them all at once, so the user can fix them without having
    to attempt to process the rules multiple times. Printing these to the console
    is not necessarily the best approach, as we can't process them programmatically,
    but it is sufficient for our needs at the moment.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当对“验证器”进行调用时返回，我们需要查看是否有任何“ConstraintViolations”。如果有，我们会相当天真地将每个失败的详细信息打印到标准输出。如果规则有多个违规行为，由于我们编写的验证器，我们将一次看到它们所有，因此用户可以在不必多次尝试处理规则的情况下修复它们。将这些打印到控制台并不一定是最佳方法，因为我们无法以编程方式处理它们，但目前对我们的需求来说已经足够了。
- en: 'Where Bean Validation really shines is in frameworks that integrate it on your
    behalf. For example, JAX-RS, the standard Java API to build REST resources, offers
    this type of integration. We see a usage of the functionality in this sample REST
    resource method:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Bean Validation真正闪耀的是在代表您集成它的框架中。例如，JAX-RS，用于构建REST资源的标准Java API，提供了这种类型的集成。我们在此示例REST资源方法中看到了功能的使用：
- en: '`@GET`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`@GET`'
- en: '`public Response getSomething (`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`public Response getSomething (`'
- en: '`@QueryParam("foo") @NotNull Integer bar) {`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`@QueryParam("foo") @NotNull Integer bar) {`'
- en: When a request is routed to this method, JAX-RS ensures that the query parameter
    `foo` is converted, if possible, to an `Integer`, and that it is not `null`, so
    in your code, you can assume that you have a valid `Integer` reference.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个请求被路由到这个方法时，JAX-RS确保查询参数`foo`被转换为`Integer`（如果可能的话），并且它不是`null`，所以在你的代码中，你可以假设你有一个有效的`Integer`引用。
- en: 'The final method we want to look at in this class is `saveAccounts()`, which,
    as crazy as it may sound, saves the `Account` instances to the rules file specified:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中我们要看的最后一个方法是`saveAccounts()`，这个方法保存了指定的`Account`实例到规则文件中。
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Much like reading the file, writing to it is extremely simple, so long as your
    Java classes and your JSON structures match. If you do have differing names (for
    example, the Java class may have the `accountName` property, while the JSON file
    uses `account_name`), Jackson offers some annotations that can be applied to the
    POJO to explain how to map the fields correctly. You can find complete details
    for those on Jackson's website ([https://github.com/FasterXML/jackson](https://github.com/FasterXML/jackson)).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 就像读取文件一样，写入文件也非常简单，只要你的Java类和JSON结构匹配。如果名称不同（例如，Java类可能具有`accountName`属性，而JSON文件使用`account_name`），Jackson提供了一些注解，可以应用于POJO，以解释如何正确映射字段。你可以在Jackson的网站上找到这些完整的细节（[https://github.com/FasterXML/jackson](https://github.com/FasterXML/jackson)）。
- en: 'With our `Account` instances loaded into memory and validated for correctness,
    we now need to process them. The entry point is the `process()` method:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的`Account`实例加载到内存中并验证正确后，我们现在需要处理它们。入口点是`process()`方法：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The three lines to pay attention to are the calls to `getImapSession()`, `getRulesByFolder()`,
    and `processFolder()`, which we''ll look at in detail now:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的三行是对`getImapSession()`、`getRulesByFolder()`和`processFolder()`的调用，我们现在将详细讨论它们：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To get an IMAP `Session`, as we saw earlier in this chapter, we create a `Properties`
    instance and set a few important properties. We get a `Store` reference using
    the protocol specified by the user in the rule file: `imap` for non-SSL-based
    connections and `imaps` for SSL-based connections.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得IMAP`Session`，就像我们在本章前面看到的那样，我们创建一个`Properties`实例并设置一些重要的属性。我们使用用户在规则文件中指定的协议来获取`Store`引用：对于非SSL连接使用`imap`，对于SSL连接使用`imaps`。
- en: 'Once we have our session, we then iterate over our rules, grouping them by
    source folder:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了我们的会话，我们就会遍历我们的规则，按源文件夹对它们进行分组：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can now process the folder as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以按照以下方式处理文件夹：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Using `Stream`, we iterate over each message in the source folder, filtering
    for only those that match `SearchTerm`, but what is that, and where did it come
    from?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Stream`，我们遍历源文件夹中的每条消息，过滤出只匹配`SearchTerm`的消息，但那是什么，它从哪里来？
- en: 'There are a couple of extra items on the `Rule` class that we haven''t looked
    at yet:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rule`类上还有一些我们还没有看过的额外项目：'
- en: '[PRE42]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We add a private field to cache `SearchTerm` so we don't have to create it more
    than once. It's a minor optimization, but we want to avoid unnecessary performance
    hits from recreating `SearchTerm` for every message on a large folder. If the
    rule has a `matchingText` set, we create a `List<SearchTerm>` based on the fields
    specified. Once we have that list, we wrap it in `OrTerm`, which will instruct
    JavaMail to match the message if *any* of the specified fields match the text.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个私有字段来缓存`SearchTerm`，这样我们就不必多次创建它。这是一个小的优化，但我们希望避免在大型文件夹上为每条消息重新创建`SearchTerm`而导致不必要的性能损失。如果规则设置了`matchingText`，我们将根据指定的字段创建一个`List<SearchTerm>`。一旦我们有了这个列表，我们就将它包装在`OrTerm`中，这将指示JavaMail在*任何*指定的字段与文本匹配时匹配消息。
- en: If `olderThan` is set, then we create `SentDateTerm` to match any messages that
    were sent at least `olderThan` days ago. We save the `SearchTerm` reference in
    our private instance variable then return it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了`olderThan`，那么我们创建`SentDateTerm`来匹配至少`olderThan`天前发送的任何消息。我们将`SearchTerm`引用保存在我们的私有实例变量中，然后返回它。
- en: Notice that the method has the `@JsonIgnore` annotation. We use this to make
    sure that Jackson doesn't try to marshall the value returned by this getter to
    the JSON file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，该方法具有`@JsonIgnore`注解。我们使用这个注解来确保Jackson不会尝试将此getter返回的值编组到JSON文件中。
- en: 'For the curious, `createFieldSearchTerm()` looks like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于好奇的人，`createFieldSearchTerm()`看起来像这样：
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'So, how are the messages actually moved or deleted? There is, of course, a
    JavaMail API for that, whose usage might look something like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，消息实际上是如何移动或删除的呢？当然，JavaMail API有一个用于此目的的API，其使用可能看起来像这样：
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We do a quick null check, then we get a reference to the messages `Folder`.
    With that, we instruct JavaMail to set a flag, `FLAGS_DELETED`, on the messages
    in the folder. The JavaMail API more often than not works on arrays of `Message`
    (`Message[]`), so we need to wrap `Message` in an array as we pass it to `setFlags()`.
    As we finish up, we increment our deleted message counter so we can print our
    report when we're finished.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行了一个快速的空值检查，然后我们获取了消息`Folder`的引用。有了这个引用，我们指示JavaMail在文件夹中的消息上设置一个`FLAGS_DELETED`标志。JavaMail
    API更多地使用`Message`（`Message[]`）数组，所以我们需要将`Message`包装在数组中，然后将其传递给`setFlags()`。在完成时，我们增加了我们的已删除消息计数器，这样我们就可以在完成时打印我们的报告。
- en: 'Moving a `Message` is very similar:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 移动`Message`非常类似：
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The bulk of this method looks just like `deleteMessage()`, but there is a subtle
    difference. JavaMail doesn't have a `moveMessages()` API. What we have to do instead
    is call `copyMessages()` to create a copy of the message in the destination folder,
    then delete the message from the source folder. We increment the moved counter
    and return.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的大部分看起来就像`deleteMessage()`，但有一个细微的区别。JavaMail没有`moveMessages()`API。相反，我们需要调用`copyMessages()`来在目标文件夹中创建消息的副本，然后从源文件夹中删除消息。我们增加了移动计数器并返回。
- en: 'The final two methods of interest deal with folders. First, we need to get
    the folder, which we do here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 感兴趣的最后两个方法处理文件夹。首先，我们需要获取文件夹，我们在这里这样做：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: For performance reasons, we cache each `Folder` instance in `Map`, keyed by
    the folder name. If we find `Folder` in `Map`, we use that. If we do not, then
    we ask the IMAP `Store` for a reference to the desired `Folder`, and cache it
    in `Map`. Finally, we make sure `Folder` is open, or our move and delete commands
    will throw `Exception`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 出于性能原因，我们将每个“文件夹”实例缓存在`Map`中，以文件夹名称为键。如果我们在`Map`中找到“文件夹”，我们就使用它。如果没有，那么我们向IMAP“存储”请求对所需的“文件夹”的引用，并将其缓存在`Map`中。最后，我们确保“文件夹”是打开的，否则我们的移动和删除命令将抛出异常。
- en: 'We also need to make sure we close the `Folder` when we''re finished:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成时，我们还需要确保关闭“文件夹”：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We filter our stream of `Folder` for only those that are open, then call `folder.close()`,
    swallowing any failure that might occur. At this point in the processing, there's
    not much that can be done.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们过滤我们的`Folder`流，只选择那些是打开的，然后调用`folder.close()`，忽略可能发生的任何失败。在处理的这一点上，没有太多可以做的。
- en: Our mail filter is now technically complete, but it's not as usable as it could
    be. We need some way to run this on a schedule, and being able to view and edit
    the rules in a GUI would be really nice, so we'll build both of those. Since it
    doesn't make sense to schedule something if we have nothing to run, we'll start
    with the GUI.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的邮件过滤现在在技术上已经完成，但它并不像它本应该的那样可用。我们需要一种定期运行的方式，并且能够在GUI中查看和编辑规则将会非常好，所以我们将构建这两者。由于如果我们没有要运行的内容，安排某事就没有意义，所以我们将从GUI开始。
- en: Building the GUI
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建GUI
- en: 'Since we want to make this as easy to use as possible, we''ll now build a GUI
    to help manage these rules. To create the project, we''ll use the same Maven archetype
    we used in creating the CLI:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望尽可能地使其易于使用，我们现在将构建一个GUI来帮助管理这些规则。为了创建项目，我们将使用与创建CLI时相同的Maven原型：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Once the POM has been created, we need to edit it a bit. We need to set the
    parent by adding this element to `pom.xml`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦POM被创建，我们需要稍微编辑它。我们需要通过向`pom.xml`添加此元素来设置父级：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We will also add a dependency on the CLI module as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加对CLI模块的依赖，如下所示：
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Since we''re not depending on NetBeans to generate the JavaFX project for us,
    we''ll also need to create a few basic artifacts by hand. Let''s start with the
    application''s entry point:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不依赖NetBeans为我们生成JavaFX项目，我们还需要手动创建一些基本工件。让我们从应用程序的入口点开始：
- en: '[PRE51]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This is a very typical JavaFX main class, so we''ll skip right to the FXML
    file. For now, we''ll just create a stub using the following piece of code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常典型的JavaFX主类，所以我们将直接跳到FXML文件。现在，我们将使用以下代码创建一个存根：
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'And finally, we create the controller:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建控制器：
- en: '[PRE53]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This gives us a working JavaFX application that starts and runs, but doesn't
    do much else. In previous chapters, we've walked through building a JavaFX application
    in painstaking detail, so we won't do that again here, but there are some interesting
    challenges in this one that are worth taking a look at.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们一个可以启动和运行的JavaFX应用程序，但没有做其他太多事情。在之前的章节中，我们已经详细介绍了构建JavaFX应用程序，所以我们不会在这里再次重复，但是在这个应用程序中有一些有趣的挑战值得一看。
- en: 'To give you a sense of what we''re working toward, here''s a screenshot of
    the final user interface:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解我们正在努力的方向，这是最终用户界面的屏幕截图：
- en: '![](img/e6217bcf-fb27-4bc2-b84c-dbba3296e5d9.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6217bcf-fb27-4bc2-b84c-dbba3296e5d9.png)'
- en: On the left, we have `ListView` to display the `Account` configured in our rules
    file. Below `ListView`, we have a few controls to edit the currently selected
    `Account`. On the right, we have `TableView` to display the `Rule`, and a similar
    area below it for editing a `Rule`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，我们有`ListView`来显示规则文件中配置的`Account`。在`ListView`下方，我们有一些控件来编辑当前选定的`Account`。在右侧，我们有`TableView`来显示`Rule`，以及其下方类似的区域来编辑`Rule`。
- en: When the user clicks on `Account` or `Rule`, we want the form area below to
    be populated with the relevant information. As the user modifies the data, `Account`/`Rule`
    as well as `ListView`/`TableView` should be updated.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击“Account”或“Rule”时，我们希望下方的表单区域填充相关信息。当用户修改数据时，`Account`/`Rule`以及`ListView`/`TableView`应该被更新。
- en: 'Ordinarily, this is one of the areas in which JavaFX really shines, that of
    property binding. We''ve already seen a small part of that with `ObservableList`:
    we can add an item to `List`, and it is automatically added to the UI component
    to which it has been bound. The situation we find ourselves in now is a little
    different though, in that our model is a POJO, one that doesn''t use any JavaFX
    APIs, so we don''t get that functionality quite so easily. Let''s look at what
    it will take to wire these things together.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这是JavaFX真正擅长的领域之一，即属性绑定。我们已经在`ObservableList`中看到了一小部分：我们可以向`List`中添加项目，它会自动添加到已绑定的UI组件中。但是，我们现在所处的情况有点不同，因为我们的模型是一个POJO，它不使用任何JavaFX
    API，所以我们不会轻易获得该功能。让我们看看将这些东西连接在一起需要做些什么。
- en: 'First, let''s look at the `Account` list. We have `ObservableList`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下“Account”列表。我们有`ObservableList`：
- en: '[PRE54]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We add our accounts to this `ObservableList` as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的账户添加到这个`ObservableList`中，如下所示：
- en: '[PRE55]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, we bind `List` and `ListView`, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们绑定`List`和`ListView`，如下所示：
- en: '[PRE56]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here is where things change a little bit. To encapsulate our POJO binding setup,
    we''ll create a new class called `AccountProperty`, which we''ll look at shortly.
    Although, let''s first add the following code snippet to handle the `ListView`
    clicks:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一点变化。为了封装我们的POJO绑定设置，我们将创建一个名为`AccountProperty`的新类，我们很快会看到。尽管，让我们首先添加以下代码片段来处理`ListView`的点击：
- en: '[PRE57]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'When the user clicks on `ListView`, we set `Account` on the `AccountProperty`
    instance. Before we leave this method and look at `AccountProperty`, we need to
    set up one last item:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击`ListView`时，我们在`AccountProperty`实例上设置`Account`。在离开这个方法并查看`AccountProperty`之前，我们需要设置最后一个项目：
- en: '[PRE58]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We define `ChangeListener`, which simply calls `accountsListView.refresh()`,
    which instructs `ListView` to redraw itself. We'll want it to do this when the
    model itself is updated, a change that `ObservableList` doesn't bubble up to `ListView`.
    The next two lines add `Listener` to `serverName` and `userName``TextField`. These
    two controls edit the properties by the same name on `Account`, and are the only
    two used to generate the display String for `ListView`, which we don't show here.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`ChangeListener`，它简单地调用`accountsListView.refresh()`，这指示`ListView`重新绘制自身。当模型本身更新时，我们希望它这样做，这是`ObservableList`不会向`ListView`冒泡的变化。接下来的两行将`Listener`添加到`serverName`和`userName`的`TextField`。这两个控件编辑`Account`上同名的属性，并且是用于生成`ListView`显示字符串的唯一两个控件，这里我们不展示。
- en: '`AccountProperty` is a custom JavaFX property, so we extend `ObjectPropertyBase`
    as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccountProperty`是一个自定义的JavaFX属性，所以我们扩展`ObjectPropertyBase`如下：'
- en: '[PRE59]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This offers part of the binding solution, but the heavy lifting is handled
    by a class from the excellent JFXtras project, `BeanPathAdapter`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了绑定解决方案的一部分，但繁重的工作由JFXtras项目的一个类`BeanPathAdapter`处理：
- en: '[PRE60]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The JFXtras library is not, as of the writing of this book, Java 9 compatible.
    All we need from the library is this one class, so I have copied the source of
    class from the JFXtras repository into this project for the time being. Once JFXtras
    runs under Java 9, we can remove this copy.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 截至撰写本书时，JFXtras库尚不兼容Java 9。我们只需要这个库的一个类，所以我暂时将该类的源代码从JFXtras存储库复制到了这个项目中。一旦JFXtras在Java
    9下运行，我们就可以删除这个副本。
- en: 'The documentation describes this class as an "adapter that takes a POJO bean
    and internally and recursively binds/unbinds its fields to other `Property` components".
    This is an extremely powerful class that we can''t cover in its entirety here,
    so we''ll just jump to our particular usage, which is as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 文档将这个类描述为一个“适配器，它接受一个POJO bean，并在内部和递归地将其字段绑定/解绑到其他`Property`组件”。这是一个非常强大的类，我们无法在这里完全覆盖它，所以我们将直接跳到我们的特定用法，如下所示：
- en: '[PRE61]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`BeanPathAdapter` allows us to bind a JavaFX `Property` to a property on a
    POJO, which could be nested to an arbitrary depth and referenced using a dot-separated
    path notation. In our case, the properties are top-level properties on the `Account`
    object, so the path is short and simple. After we''ve bound our controls to the
    properties, we add a `Listener` to update the `ObservableList` rules with `Rule`
    for the current account.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeanPathAdapter`允许我们将JavaFX`Property`绑定到POJO上的属性，这些属性可以嵌套到任意深度，并使用点分隔路径表示。在我们的情况下，这些属性是`Account`对象上的顶级属性，因此路径是简短而简单的。在我们将控件绑定到属性之后，我们添加了一个`Listener`来使用`Rule`更新`ObservableList`规则。'
- en: 'The `set()` method that is called in the preceding code when the `Account`
    selection changes in `ListView` is very straightforward:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，当`ListView`中的`Account`选择发生变化时调用的`set()`方法非常简单：
- en: '[PRE62]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: With these pieces in place, the `Account` object is updated as we type in the
    various controls, and the `ListView` label is updated as the `serverName` and/or
    `userName` fields are edited.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些部分，`Account`对象在我们在各种控件中输入时得到更新，`ListView`标签在编辑`serverName`和/或`userName`字段时得到更新。
- en: 'Now we need to do the same for the `TableView` that will display each `Rule`
    the user has configured. The setup is almost identical:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为将显示用户配置的每个`Rule`的`TableView`做同样的事情。设置几乎相同：
- en: '[PRE63]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here, we see the same basic structure: instantiate `RuleProperty`, create `ChangeListener`
    to request that `TableView` refresh itself, and add that listener to the relevant
    form fields.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了相同的基本结构：实例化`RuleProperty`，创建`ChangeListener`来请求`TableView`刷新自身，并将该监听器添加到相关的表单字段。
- en: '`RuleProperty` is also similar to `AccountProperty`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`RuleProperty`也类似于`AccountProperty`：'
- en: '[PRE64]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The biggest difference here is `Listener` that is created. Given the use of
    `CheckListView`, a custom control from the great ControlsFX project, it''s worth
    noting the logic: we get `IndexedCheckModel`, which we clear, then we iterate
    over each field, finding its index in `CheckModel` and checking it.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最大的区别是创建的`Listener`。考虑到使用了来自ControlsFX项目的自定义控件`CheckListView`，值得注意的是逻辑：我们获取`IndexedCheckModel`，然后清除它，然后我们遍历每个字段，在`CheckModel`中找到其索引并进行检查。
- en: 'We control updating the value of the fields set on `Rule` via `RuleFieldChangeListener`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`RuleFieldChangeListener`控制更新`Rule`上设置的字段值：
- en: '[PRE65]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`ListChangeListener` tells us what was removed and what was added, so we processed
    those accordingly.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListChangeListener`告诉我们移除了什么和添加了什么，所以我们相应地进行了处理。'
- en: 'There are several other moving parts to the GUI, but we''ve seen them in one
    for another in previous chapters, so we''ll not cover them here. If you''re curious
    about these details, you can find them in this book''s source code repository.
    Let''s turn our attention to the final part of our project: the OS-specific service.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: GUI还有其他几个移动部分，但我们在之前的章节中已经看到了它们的一个或另一个，所以我们在这里不再介绍它们。如果您对这些细节感兴趣，可以在本书的源代码存储库中找到它们。让我们把注意力转向我们项目的最后一部分：特定于操作系统的服务。
- en: Building the service
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建服务
- en: One of the stated goals of this project is to be able to define rules to manage
    and filter email, and to have it run more or less all the time, not just when
    the email client is running. (There is, of course, not much we can do about the
    machine running this being turned off, so we can't promise constant coverage).
    To fulfill this part of the promise, we'll need a few extra parts. We already
    have the part of the system that does the actual work, but we also need a way
    to run that part on a schedule, and we also need a part that will start the scheduled
    job.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的一个明确目标是能够定义规则来管理和过滤电子邮件，并且在大多数时间内运行，而不仅仅是在电子邮件客户端运行时。 （当然，我们无法控制运行此项目的机器被关闭，所以我们不能保证持续覆盖）。为了实现这一承诺的一部分，我们需要一些额外的部分。我们已经有了执行实际工作的系统部分，但我们还需要一种在计划中运行该部分的方法，还需要一个启动计划作业的部分。
- en: 'For the scheduling aspect, we have many options, but we''ll use a library called
    Quartz. The Quartz Job Scheduling Library is an open source library that can be
    used in Java SE as well as Java EE applications. It provides a clean and simple
    API that is perfect for use here. To add Quartz to our project, we need to do
    this to `pom.xml`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于调度方面，我们有许多选择，但我们将使用一个名为Quartz的库。Quartz作业调度库是一个开源库，可以在Java SE和Java EE应用程序中使用。它提供了一个干净简单的API，非常适合在这里使用。要将Quartz添加到我们的项目中，我们需要在`pom.xml`中进行如下操作：
- en: '[PRE66]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'How simple is the API? Here''s our `Job` definition:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: API有多简单呢？这是我们的`Job`定义：
- en: '[PRE67]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We extend `org.quartz.Job` overriding `execute()`, in which we simply instantiate
    `MailFilter` and call `run()`. That''s really all there is to it. With our job
    defined, we just need to schedule it, which we''ll do in `MailFilterService`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展了`org.quartz.Job`，重写了`execute()`方法，在其中我们只是实例化了`MailFilter`并调用了`run()`。就是这么简单。定义了我们的任务之后，我们只需要安排它的执行，这将在`MailFilterService`中完成：
- en: '[PRE68]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We begin by getting a reference to the default `Scheduler` and starting it.
    Next, we create a new job using `JobBuilder`, then build `Trigger` using `TriggerBuilder`.
    We tell `Trigger` to start executing now, but note that it won't start until it
    is actually built and assigned to `Scheduler`. Once that happens, `Job` will execute
    immediately. Finally, we define `Schedule` for `Trigger` using the `SimpleScheduleBuilder`
    helper class, specifying a fifteen minute interval, which will run forever. We
    want this to run until the computer is shut down or the service is stopped.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取对默认`Scheduler`的引用并启动它。接下来，我们使用`JobBuilder`创建一个新的任务，然后使用`TriggerBuilder`构建`Trigger`。我们告诉`Trigger`立即开始执行，但请注意，直到它实际构建并分配给`Scheduler`之前，它不会开始执行。一旦发生这种情况，`Job`将立即执行。最后，我们使用`SimpleScheduleBuilder`辅助类为`Trigger`定义`Schedule`，指定每15分钟运行一次，将永远运行。我们希望它在计算机关闭或服务停止之前一直运行。
- en: If we run/debug `MailFilterService` now, we can watch `MailFilter` run. If you
    do this, and you're not extremely patient, I would suggest that you lower the
    interval to something more reasonable.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行/调试`MailFilterService`，我们可以观察`MailFilter`的运行。如果你这样做，而且你不是非常有耐心的话，我建议你将间隔时间降低到更合理的水平。
- en: 'This leaves us with one final piece: the OS integration. In a nutshell, what
    we want to be able to do is run `MailFilterService` when the operating system
    boots up. Ideally, we''d prefer not to have ad hoc scripts cobble together to
    make this happen. Fortunately, we are again presented with a number of options.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们还有最后一件事：操作系统集成。简而言之，我们希望能够在操作系统启动时运行`MailFilterService`。理想情况下，我们希望不需要临时脚本来实现这一点。幸运的是，我们又有了许多选择。
- en: 'We will be using the excellent Java Service Wrapper library from Tanuki Software
    (details of which can be found at [https://wrapper.tanukisoftware.com](https://wrapper.tanukisoftware.com/)).
    While we can manually build the service artifacts, we''d much rather let our build
    do the work for us, and, of course, there''s a Maven plugin, called `appassembler-maven-plugin`,
    to do just that. To integrate them both into our project, we need to modify the
    `build` section of our POM by adding the following code snippet:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Tanuki Software的出色的Java Service Wrapper库（详情请参阅[https://wrapper.tanukisoftware.com](https://wrapper.tanukisoftware.com/)）。虽然我们可以手动构建服务工件，但我们更愿意让我们的构建工具为我们完成这项工作，当然，有一个名为`appassembler-maven-plugin`的Maven插件可以做到这一点。为了将它们整合到我们的项目中，我们需要修改POM文件的`build`部分，添加以下代码片段：
- en: '[PRE69]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The transitive dependencies of this plugin will pull in everything we need
    for the Java Service Wrapper, so all we need to do is configure our usage .We
    start by adding an execution, telling Maven to run the `generate-daemons` goal
    when packaging the project:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件的传递依赖项将引入我们需要的一切Java Service Wrapper，所以我们只需要配置我们的使用方式。我们首先添加一个执行，告诉Maven在打包项目时运行`generate-daemons`目标：
- en: '[PRE70]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next we need to configure the plugin, which we do with the `configuration`
    element:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置插件，这可以通过`configuration`元素来实现：
- en: '[PRE71]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `repositoryLayout` option tells the plugin to build a **lib** style repository,
    as opposed to the Maven 2 style layout, which is a number of nested directories.
    This is largely a style concern, at least for our purposes here, but I find it
    helpful to be able to scan the generated directory and see what is included at
    a glance.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`repositoryLayout`选项告诉插件构建一个**lib**风格的存储库，而不是Maven 2风格的布局，后者是一些嵌套目录。至少对于我们在这里的目的来说，这主要是一个样式问题，但我发现能够扫描生成的目录并一目了然地看到包含了什么是很有帮助的。'
- en: 'Next, we need to define the **daemons** (another term for OS service that comes
    from the Unix world and which stands for **Disk And Execution Monitor**) as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要按照以下方式定义**守护进程**（来自Unix世界的另一个表示操作系统服务的术语，代表**磁盘和执行监视器**）：
- en: '[PRE72]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The Java Service Wrapper is a very flexible system, providing a number of ways
    to wrap your Java project. Our needs are simple, so we instruct it to use `WrapperSimpleApp`
    and point it to the main class, `MailFilterService`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Java Service Wrapper是一个非常灵活的系统，提供了多种包装Java项目的方式。我们的需求很简单，所以我们指示它使用`WrapperSimpleApp`，并指向主类`MailFilterService`。
- en: 'The plugin supports a couple of other service wrapper methods, but we''re interested
    in the Java Service Wrapper, so we specify that here, with the `platform` element:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件支持其他几种服务包装方法，但我们对Java Service Wrapper感兴趣，因此在这里我们使用`platform`元素来指定：
- en: '[PRE73]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Finally, we need to configure the generator, telling it which OS to support:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要配置生成器，告诉它支持哪个操作系统：
- en: '[PRE74]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Each of those OS definitions offers a 32-bit option that you can add if needed,
    but, for the sake of brevity, I've omitted them here.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统定义都提供了一个32位选项，如果需要的话可以添加，但为了简洁起见，我在这里省略了它们。
- en: 'When we build the app now, either via `mvn package` or `mvn install`, this
    plugin will generate a wrapper for our service, complete with binaries appropriate
    for the configured operating systems. The nice thing is that it will build wrappers
    for each OS, regardless of what OS the build is actually run under. For example,
    here''s the output of building this on a Windows machine (note the Linux and Mac
    binaries):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建应用程序，无论是通过`mvn package`还是`mvn install`，这个插件都会为我们的服务生成一个包装器，其中包含适用于配置的操作系统的二进制文件。好处是，它将为每个操作系统构建包装器，而不管实际运行构建的操作系统是什么。例如，这是在Windows机器上构建的输出（请注意Linux和Mac的二进制文件）：
- en: '![](img/fa36d256-0b22-4cf4-bf7f-7356b2448c3d.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa36d256-0b22-4cf4-bf7f-7356b2448c3d.png)'
- en: The wrapper is capable of much, much more, so if you're interested, you can
    read all the details on Tanuki Software's website.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器还可以做得更多，所以如果你感兴趣，可以在Tanuki Software的网站上阅读所有细节。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Just like that, once again, our application is **finished**. We've covered quite
    a bit in this chapter. We started by learning a little bit about the history and
    technical details of several email protocols (SMTP, POP3, and IMAP4), then learned
    how to interact with services based on those using the JavaMail API. In the process
    of doing so, we discovered the Jackson JSON Parser and used it to marshal and
    unmarshal POJOs to and from the disk. We used the ControlsFX class, `BeanPathAdapter`,
    to bind non-JavaFX-aware POJOs to JavaFX controls, and the Quartz Job Scheduling
    Library to execute code on a schedule. Finally, we wrapped up our application
    using the Java Service Wrapper to create installation artifacts.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 就像这样，我们的应用程序又**完成**了。在本章中，我们涵盖了相当多的内容。我们首先学习了一些关于几种电子邮件协议（SMTP、POP3和IMAP4）的历史和技术细节，然后学习了如何使用JavaMail
    API与基于这些协议的服务进行交互。在这个过程中，我们发现了Jackson JSON解析器，并使用它来将POJO从磁盘转换为POJO，并从磁盘转换为POJO。我们使用了ControlsFX类`BeanPathAdapter`，将非JavaFX感知的POJO绑定到JavaFX控件，以及Quartz作业调度库来按计划执行代码。最后，我们使用Java
    Service Wrapper来创建安装工件，完成了我们的应用程序。
- en: We're left with what I hope is an application that is both interesting and helpful.
    There are several ways to improve on it, of course, if you feel so motivated.
    The account/rule data structure could be extended to allow defining global rules
    that are shared across accounts. The GUI could support viewing email in the folders
    on the account and generating rules based on live data. The build could be extended
    to create an installer for the application. You can probably think of many more.
    Always feel free to check out the code and hack away. If you come up with something
    interesting, be sure to share it, as I'd love to see what you've done.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望我们留下的应用程序既有趣又有帮助。当然，如果你感到有动力，还有几种方法可以改进它。账户/规则数据结构可以扩展，以允许定义跨账户共享的全局规则。GUI可以支持在账户的文件夹中查看电子邮件，并根据实时数据生成规则。构建可以扩展为创建应用程序的安装程序。你可能还能想到更多。随时随地查看代码并进行修改。如果你想到了有趣的东西，一定要分享出来，因为我很想看看你做了什么。
- en: With another project wrapped up (no pun intended), we're ready to turn our attention
    to another. In the next chapter, we'll spend our entire time in a GUI and build
    a photo management system. This will give us the opportunity to look at some of
    JDK's imaging handling capabilities, including the newly added TIFF support, a
    feature that should make image aficionados quite happy. Turn the page and let's
    get started!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 完成另一个项目（不是故意的），我们准备把注意力转向另一个项目。在下一章中，我们将在GUI中花费全部时间，构建一个照片管理系统。这将让我们有机会了解一些JDK的图像处理能力，包括新增的TIFF支持，这个功能应该会让图像爱好者非常高兴。翻页，让我们开始吧！

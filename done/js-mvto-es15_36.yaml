- en: Chapter 8. Building an Advanced Profile Search Widget
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。构建高级个人资料搜索小部件
- en: The best way to master FRP using Bacon.js is by building a real world application,
    which is what we will do in this chapter. We will build an advanced profile search
    widget, just like the ones you would usually find on social networking or dating
    sites. To keep the chapter short and to the point, we will work with some sample
    data instead of building registration functionality. We will also learn some more
    advanced concepts of functional programming and Bacon.js.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Bacon.js掌握FRP的最佳方法是构建一个真实的应用程序，这正是我们将在本章中做的事情。我们将构建一个高级的个人资料搜索小部件，就像您通常在社交网络或约会网站上找到的那种。为了让本章简短而直接，我们将使用一些示例数据而不是构建注册功能。我们还将学习一些更高级的函数式编程和Bacon.js的概念。
- en: 'In this chapter, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Error events in Bacon.js
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bacon.js中的错误事件
- en: Handling exceptions in FRP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在FRP中处理异常
- en: Lazy evaluation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性求值
- en: Buses in Bacon.js
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bacon.js中的总线
- en: Join patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接模式
- en: Finally, we will build an advanced profile search widget
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将构建一个高级的个人资料搜索小部件
- en: Errors in Bacon.js
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bacon.js中的错误
- en: Bacon provides the `Bacon.Error` constructor to explicitly mark events or values
    of EventStreams or properties respectively as errors so that Bacon can identify
    them and open up a wide variety of other APIs to work with those errors specifically.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon提供了`Bacon.Error`构造函数，用于明确标记EventStreams或属性的事件或值为错误，以便Bacon可以识别它们并打开各种其他API来处理这些错误。
- en: Depending on how we create a stream, Bacon.js can sometimes identify whether
    an event is a success or error event, and if it's an error event, then it can
    convert it to `Bacon.Error`. For example, if we use `Bacon.fromPromise` to create
    an EventStream, then Bacon can identify an error easily, since when an error occurs
    in a promise pattern, the second callback of the `then()` method or the callback
    passed to the `catch()` method is executed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们创建流的方式，Bacon.js有时可以识别事件是成功事件还是错误事件，如果是错误事件，它可以将其转换为`Bacon.Error`。例如，如果我们使用`Bacon.fromPromise`来创建一个EventStream，那么Bacon可以很容易地识别错误，因为在promise模式中发生错误时，`then()`方法的第二个回调或传递给`catch()`方法的回调会被执行。
- en: In case Bacon cannot identify whether an event is an error or success event
    while creating a stream, then we need to explicitly create instances of `Bacon.Error`
    and replace the error events with them. For example, when using `Bacon.fromCallback`,
    there is no way for Bacon.js to know whether an event is a success or error event,
    so we need to explicitly convert error events to instances of `Bacon.Error`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Bacon在创建流时无法确定事件是错误事件还是成功事件，那么我们需要显式创建`Bacon.Error`实例，并用它们替换错误事件。例如，当使用`Bacon.fromCallback`时，Bacon.js无法知道事件是成功事件还是错误事件，因此我们需要显式将错误事件转换为`Bacon.Error`实例。
- en: Subscribing to errors
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订阅错误
- en: A callback passed to `onValue` is not invoked for `Bacon.Error` events or values;
    instead, we need to use `onError`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`onValue`的回调不会对`Bacon.Error`事件或值进行调用；相反，我们需要使用`onError`。
- en: 'To see it in action, open the `index.js` file that we created in our previous
    chapter, and add this code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看它的实际效果，请打开我们在上一章中创建的`index.js`文件，并添加以下代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, if you enter an URL that cannot be fetched, a custom error message is displayed
    on the console.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果输入无法获取的URL，控制台上会显示自定义错误消息。
- en: Mapping errors
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射错误
- en: The `map()` function doesn't map `Bacon.Error` instances; therefore, Bacon provides
    us with `mapError ()`, which works the same way as `map` but maps only `Bacon.Error`
    instances.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`函数不会映射`Bacon.Error`实例；因此，Bacon为我们提供了`mapError()`，它的工作方式与`map`相同，但只映射`Bacon.Error`实例。'
- en: Similarly, `flapMap()` doesn't map `Bacon.Error` instances. Therefore, Bacon
    provides us with `flatMapError()`, which works the same way as `flatMap` but maps
    only `Bacon.Error` instances.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`flapMap()`不会映射`Bacon.Error`实例。因此，Bacon为我们提供了`flatMapError()`，它的工作方式与`flatMap`相同，但只映射`Bacon.Error`实例。
- en: Aside from `flatMap` and `map`, `Bacon.Error` instances can pass through everything.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`flatMap`和`map`之外，`Bacon.Error`实例可以通过一切。
- en: Retrying a function call
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重试函数调用
- en: Sometimes, we might want to retry an operation if it fails. For example, if
    we fail to retrieve a web page using AJAX due to a server timeout error, then
    we might want to try retrieving it again after some time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果操作失败，我们可能希望重试。例如，如果我们由于服务器超时错误而无法使用AJAX检索网页，那么我们可能希望在一段时间后再次尝试检索它。
- en: Bacon provides the `Bacon.retry` function, using which we can make a function
    call again and again as long as we want to.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon提供了`Bacon.retry`函数，使用它我们可以反复调用一个函数，只要我们想要。
- en: '`Bacon.retry` returns an EventStream, and it takes an object with four properties,
    as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bacon.retry`返回一个EventStream，并且它接受一个具有四个属性的对象，如下所示：'
- en: '`source`: This is a function that is to be reinvoked. This function must return
    a property or EventStream.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source`: 这是一个要重新调用的函数。该函数必须返回一个属性或EventStream。'
- en: '`retries`: This is a number representing the total number of times to retry
    the source function for in addition to the initial attempt. When a `Bacon.Error`
    instance is pushed to the property or stream returned by the source function,
    then an attempt to retry is made.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retries`: 这是一个表示除了初始尝试之外要重试源函数的总次数的数字。当`Bacon.Error`实例被推送到源函数返回的属性或流时，就会尝试重试。'
- en: '`isRetryable`: This is an optional property. It needs to be assigned to a function.
    The function should return either `true` or `false`. When something is pushed
    into the property or EventStream returned by the source function, then `isRetryable`
    is invoked to find our whether an attempt to retry should be made.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isRetryable`: 这是一个可选属性。它需要被分配给一个函数。该函数应该返回`true`或`false`。当某些东西被推送到属性或源函数返回的EventStream时，`isRetryable`被调用以确定是否应该尝试重试。'
- en: '`delay`: This is an optional property. It''s assigned to a function that returns
    the time in milliseconds to wait for before retrying. The default value is `0`.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay`: 这是一个可选属性。它分配给一个返回重试前等待的毫秒数的函数。默认值为`0`。'
- en: The EventStream returned by `Bacon.retry` has the event or value that was present
    in the last EventStream or property returned by the last call to the source function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bacon.retry`返回的EventStream具有上次调用源函数返回的最后一个EventStream或属性中存在的事件或值。'
- en: 'Let''s see the `Bacon.retry` function in action. Find this code in the `index.js`
    file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Bacon.retry`函数的作用。在`index.js`文件中找到这段代码：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Replace it with this code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换它：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are retrying the AJAX request `5` times after every `2` seconds for
    any error other than `404`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在除`404`之外的任何错误后，每`2`秒重试`5`次AJAX请求。
- en: Ending an EventStream or property on error
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在错误时结束EventStream或属性
- en: An EventStream or property is said to have ended when you cannot push anything
    to it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当无法向EventStream或属性推送任何内容时，就说EventStream或属性已经结束。
- en: If you want to end an EventStream or property when a `Bacon.Error` instance
    is pushed, then you need to call the `endOnError` method of the EventStream or
    property. The `endOnError` method returns a new EventStream or property, which
    is ended when a `Bacon.Error` instance is pushed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在推送`Bacon.Error`实例时结束EventStream或属性，则需要调用EventStream或属性的`endOnError`方法。`endOnError`方法返回一个新的EventStream或属性，在推送`Bacon.Error`实例时结束。
- en: Handling exceptions
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常
- en: If an exception is encountered inside a callback passed to a Bacon helper function,
    then it's not caught automatically; rather, we have to use a `try…catch` statement
    to handle it. A common practice is to return a `Bacon.Error` instance after catching
    an exception so that we can handle it just like an error.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在传递给Bacon辅助函数的回调中遇到异常，则不会自动捕获；相反，我们必须使用`try…catch`语句来处理它。一个常见的做法是在捕获异常后返回一个`Bacon.Error`实例，这样我们就可以像处理错误一样处理它。
- en: 'Here is an example of how to handle exceptions. In the `index.js` file, find
    the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何处理异常的示例。在`index.js`文件中找到以下代码：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Replace it with this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换它：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we are catching exceptions and creating a new `Bacon.Error` instance with
    the exception as the details of the error, that is, we are passing the exception
    as an argument to the constructor.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们捕获异常并使用异常作为错误的详细信息创建一个新的`Bacon.Error`实例，也就是说，我们将异常作为参数传递给构造函数。
- en: Constant properties
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量属性
- en: Bacon also provides us ways to create constant properties. Constant properties
    are initialized at the time of creation and cannot be reinitialized, that is,
    new values cannot be pushed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon还提供了创建常量属性的方法。常量属性在创建时初始化，不能重新初始化，也就是说，不能推送新值。
- en: A constant property is created using the `Bacon.constant()` constructer. We
    need to pass the value of the property to the constructor. A constant property
    can be merged, concatenated, combined, zipped, sampled, filtered, and transformed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Bacon.constant()`构造函数创建一个常量属性。我们需要将属性的值传递给构造函数。常量属性可以合并、连接、组合、压缩、取样、过滤和转换。
- en: 'Here is an example of how to create a constant property. Place this code in
    the `index.js` file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个创建常量属性的示例。将这段代码放在`index.js`文件中：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, the `constant` property stores the time at which the script was started
    and prints the time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`constant`属性存储了脚本启动的时间并打印出时间。
- en: An overview of buses
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总线概述
- en: A **bus** is just like an EventStream, but it lets us push values into the stream
    manually instead of attaching it to a source, and it also allows plugging other
    EventStreams and properties into the bus on the fly.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**总线**就像一个EventStream，但它允许我们手动将值推送到流中，而不是将其附加到源上，并且还允许在运行时将其他EventStreams和属性插入总线中。'
- en: 'Here is an example that demonstrates how to create a bus and various methods
    provided by a `Bacon.Bus` instance. Place this code in the `index.js` file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，演示了如何创建一个总线以及`Bacon.Bus`实例提供的各种方法。将这段代码放在`index.js`文件中：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The code is self explanatory. The output of the above code is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是不言自明的。上述代码的输出如下：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Subscribing to the end of EventStreams and properties
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅EventStreams和属性的结束
- en: Bacon provides the `onEnd` method to subscribe to callbacks that will be executed
    when an EventStream or property ends.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon提供了`onEnd`方法来订阅在EventStream或属性结束时执行的回调。
- en: 'Here is some example code, which shows you how to use the `onEnd` callback.
    Place it in the `index.js` file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例代码，演示了如何使用`onEnd`回调。将其放在`index.js`文件中：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we are attaching an `onEnd` callback to the constant property, which we
    created previously. After initialization, the property is ended; therefore, the
    `onEnd` callback is invoked. We can register multiple subscribers as well.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`onEnd`回调附加到之前创建的常量属性上。初始化后，属性结束；因此，调用了`onEnd`回调。我们也可以注册多个订阅者。
- en: Actually, to end an EventStream or property, Bacon internally pushes an instance
    of the `Bacon.End` constructor. So, we can also use the `Bacon.End` constructor
    to end an EventStream or property.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，为了结束EventStream或属性，Bacon在内部推送`Bacon.End`构造函数的实例。因此，我们也可以使用`Bacon.End`构造函数来结束EventStream或属性。
- en: 'Let''s look at an example of how to use `Bacon.End`. Place this code in the
    `index.js` file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个如何使用`Bacon.End`的例子。将这段代码放在`index.js`文件中：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output of the code is this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出是这样的：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A `Bacon.End` instance doesn't pass through helper functions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bacon.End`实例不会通过辅助函数。'
- en: Unplugging subscribers
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拔掉订阅者
- en: We saw how to subscribe to an EventStream and property using `onValue`, `onError`,
    and `onEnd`. We can also unsubscribe the subscribers if we don't need them anymore.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到如何使用`onValue`、`onError`和`onEnd`订阅EventStream和属性。如果不再需要订阅者，我们也可以取消订阅。
- en: These functions return a function for unsubscribing. To unsubscribe, we need
    to call the function returned by the subscriber function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数返回一个取消订阅的函数。要取消订阅，我们需要调用订阅函数返回的函数。
- en: Combining and zipping
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合和压缩
- en: Bacon provides certain methods to combine and zip properties and EventStreams.
    There is a significant difference between combining and zipping.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon提供了一些方法来组合和压缩属性和EventStreams。组合和压缩之间有显著的区别。
- en: When we combine properties, we always get a property, which will have an array
    of all source properties as its value. If we try to combine EventStreams, then
    they are first converted to properties before combining takes place. When there
    is a push in any one of the source properties, a new value is pushed into the
    resultant property. **Combining** starts after each of the source properties has
    a value pushed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们组合属性时，我们总是得到一个属性，它将具有所有源属性的数组作为其值。如果我们尝试组合EventStreams，那么它们在组合之前首先被转换为属性。当任何一个源属性中有推送时，新值将被推送到结果属性中。**组合**在每个源属性都有值被推送后开始。
- en: Here is an example to demonstrate combining. Place this code in the `index.js`
    file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个演示组合的例子。把这段代码放在`index.js`文件中。
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is the output of the code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的输出：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Zipping is different from combining. **Zipping** means that events from each
    source are combined pairwise so that the first event from each source is published
    first, then the second event, and so on. The results will be published as soon
    as there is a value from each source. When we zip properties and EventStreams,
    we always get an EventStream.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Zipping与组合不同。**Zipping**意味着每个源的事件成对组合，以便首先发布每个源的第一个事件，然后是第二个事件，依此类推。结果将在每个源都有值时立即发布。当我们压缩属性和EventStreams时，我们总是得到一个EventStream。
- en: 'Here is an example to demonstrate zipping. Place this code in the `index.js`
    file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个演示压缩的例子。把这段代码放在`index.js`文件中：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is the output of the code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的输出：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Lazy evaluation
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 惰性评估
- en: In programming, **lazy evaluation** is a strategy that delays the evaluation
    of values until they're needed. There are two means by which lazy evaluation is
    implemented by Bacon.js.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，**惰性评估**是一种延迟值评估的策略，直到需要它们为止。Bacon.js实现惰性评估的两种方法。
- en: Type 1
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型1
- en: 'A stream or property will not be attached to its data source until it has subscribers.
    Let''s look at an example to understand this. Place this code in the `index.js`
    file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 直到有订阅者，流或属性才会连接到其数据源。让我们看一个例子来理解这一点。把这段代码放在`index.js`文件中：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, when you click on the `myButton` button, nothing will be logged. Now,
    place this code in the `index.js` file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当你点击`myButton`按钮时，不会有任何日志记录。现在，把这段代码放在`index.js`文件中：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now when you click on the button, the event will be logged.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你点击按钮时，事件将被记录。
- en: The `log` method is also considered as a subscriber.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`log`方法也被视为一个订阅者。'
- en: Type 2
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型2
- en: Methods such as `map` and `combine*` use lazy evaluation to avoid evaluating
    events and values that aren't actually needed. Lazy evaluation results in huge
    performance benefits in some cases.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`map`和`combine*`之类的方法使用惰性评估来避免评估实际上不需要的事件和值。在某些情况下，惰性评估会带来巨大的性能优势。
- en: But how do `map` and `combine*` know whether an event or value is not needed?
    Well, there are a few methods that give a hint about this to `map` and `combine*`,
    for example, `sampledBy`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`map`和`combine*`如何知道事件或值是否不需要呢？嗯，有一些方法可以向`map`和`combine*`提供关于这一点的提示，例如`sampledBy`。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: What is the `sampledBy` method?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`sampledBy`方法是什么？'
- en: The`sampledBy` method is used for sampling a property based on a property or
    EventStream. It returns a property or EventStream, respectively, by sampling the
    property value at each event from the given property or EventStream. The returned
    property or EventStream will contain the property value at each push in the source
    property or EventStream.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`sampledBy`方法用于基于属性或EventStream对属性进行采样。它分别通过从给定属性或EventStream的每个事件中对属性值进行采样来返回属性或EventStream。返回的属性或EventStream将包含源属性或EventStream中每次推送的属性值。'
- en: 'Let''s look at an example of how `map` implements lazy evaluation. Place this
    code in the `index.js` file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个`map`如何实现惰性评估的例子。把这段代码放在`index.js`文件中：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is what we are doing in the previous code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在之前的代码中所做的事情：
- en: We first create two buses.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建两个总线。
- en: Then, we map events in the first bus using the `map` method, and it is then
    transformed into a property.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`map`方法映射第一个总线中的事件，然后将其转换为属性。
- en: We then create an EventStream by sampling the property value at each event in
    the second bus.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过在第二个总线中对属性值进行采样来创建一个EventStream。
- en: We then add a subscriber to the EventStream.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们向EventStream添加一个订阅者。
- en: Finally, we push a value to the first bus.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们向第一个总线推送一个值。
- en: 'The previous code looks like it should log the following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码看起来应该记录以下输出：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Unfortunately, it doesn''t log anything. That''s because lazy evaluation is
    taking place here. The `sampledBy` function takes the current value of the property,
    not the ones that were generated from previous events. Therefore, `map` decides
    to generate the property value when an event occurs in the second bus, therefore
    preventing unnecessary calls to the callback passed to the `map` function. In
    short, here, `map` simply prevents calculating property values until it''s actually
    needed. Now, add this code to the `index.js` file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，它没有记录任何东西。这是因为这里正在进行惰性评估。`sampledBy`函数获取属性的当前值，而不是从先前事件生成的值。因此，`map`决定在第二个总线中发生事件时生成属性值，从而防止不必要地调用传递给`map`函数的回调。简而言之，在这里，`map`只是在实际需要时阻止计算属性值。现在，把这段代码添加到`index.js`文件中：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, when you run the code, you will get this output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行代码时，你会得到这个输出：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, you can see that `map` prevented calculating for the first event pushed
    inside the first bus. It calculated the property value for second event because
    sampling was done after that.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到`map`阻止了对第一个总线内推送的第一个事件的计算。它计算了第二个事件的属性值，因为在那之后进行了采样。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to prevent lazy evaluation when using the `map()` method, then use
    `flatMap` instead of `map`. The `flatMap` method doesn't use lazy evaluation.
    There is no way to prevent lazy evaluation when using `combine*` methods, but
    if you need it badly, then you can try to rewrite the code using other methods,
    which may or may not be possible depending on what you are trying to achieve.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在使用`map()`方法时阻止惰性求值，那么请使用`flatMap`而不是`map`。`flatMap`方法不使用惰性求值。在使用`combine*`方法时，没有办法阻止惰性求值，但是如果您非常需要它，那么可以尝试使用其他方法重写代码，具体取决于您尝试实现的目标是否可能。
- en: Building the profile search widget
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建个人资料搜索小部件
- en: We've covered almost all the important APIs and concepts of Bacon.js. Now, it's
    time to build the profile search widget. We will also learn some more APIs and
    concepts in the process.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了Bacon.js的几乎所有重要API和概念。现在，是时候构建个人资料搜索小部件了。在这个过程中，我们还将学习更多的API和概念。
- en: We will build the profile search widget to learn how to write reactive code
    using Bacon for both the frontend and backend in real-world projects. Let's get
    started.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建个人资料搜索小部件，以学习如何使用Bacon编写前端和后端的响应式代码在实际项目中。让我们开始吧。
- en: Understanding project directories and files
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解项目目录和文件
- en: In the exercise files of this chapter, you will find a directory named `profile-search`-`widget`.
    Inside that directory, you will find two other directories named `final` and `initial`.
    The `final` directory contains the final code for the profile search widget whereas
    the `initial` directory contains the files and code for you to quickly get started
    with building the profile search widget. You will now work with the `initial`
    directory.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的练习文件中，您将找到一个名为`profile-search`-`widget`的目录。在该目录中，您将找到另外两个名为`final`和`initial`的目录。`final`目录包含个人资料搜索小部件的最终代码，而`initial`目录包含了文件和代码，让您快速开始构建个人资料搜索小部件。您现在将使用`initial`目录。
- en: You are supposed to put the server-side code inside the `app.js` file and the
    frontend code inside the `public/js/index.js` file. Currently, the `app.js` file
    imports Bacon, Express, and filesystem modules and also has basic code to run
    the web server and serve static files.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该将服务器端代码放在`app.js`文件中，将前端代码放在`public/js/index.js`文件中。目前，`app.js`文件导入了Bacon、Express和文件系统模块，并且还有运行Web服务器和提供静态文件的基本代码。
- en: Inside the `public/html/index.html` file, you will find HTML code. We will not
    be writing any HTML or CSS.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`public/html/index.html`文件中，您将找到HTML代码。我们不会编写任何HTML或CSS。
- en: Let's first build the backend and then the frontend.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先构建后端，然后再构建前端。
- en: Converting Express.js routes to a functional reactive pattern
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Express.js路由转换为函数式响应式模式
- en: '**Express.js** routes are written using a callback pattern. We need a wrapper
    to convert the callback pattern to a functional reactive pattern.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**Express.js**路由是使用回调模式编写的。我们需要一个包装器将回调模式转换为函数式响应式模式。'
- en: 'Bacon doesn''t provide any direct method for doing this—there are various other
    custom methods. The easiest and shortest way to do this is by creating a bus for
    every route, and whenever a request to a route is made, pushing an event into
    its respective bus. Let''s create a route this way for serving the `index.html`
    file for requests to the root URL. Place this code in the `app.js` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon没有提供任何直接的方法来做到这一点——有各种其他自定义方法。最简单和最快的方法是为每个路由创建一个总线，每当对路由进行请求时，就将事件推送到其相应的总线中。让我们以这种方式创建一个路由，以便为根URL的请求提供`index.html`文件。将此代码放在`app.js`文件中：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is how the code works:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的工作原理如下：
- en: At first, we define a function named `route_eventstream`, which acts as a wrapper
    to convert callback patterns to EventStream patterns. It takes a path and returns
    a bus. Whenever a request is made to the route, an event is pushed into the bus.
    The event is a connection object, that is, it holds the request and response objects
    for that client request.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个名为`route_eventstream`的函数，它充当一个包装器，将回调模式转换为EventStream模式。它接受一个路径并返回一个总线。每当对路由进行请求时，事件就会被推送到总线中。事件是一个连接对象，即它保存了该客户端请求的请求和响应对象。
- en: Then, we create an EventStream for root path requests.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为根路径请求创建一个EventStream。
- en: Finally, we register a subscriber that returns the `index.html` file whenever
    an event is pushed into the root EventStream.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们注册一个订阅者，每当事件被推送到根EventStream时，就返回`index.html`文件。
- en: 'Now, run the `node app.js` command and visit `localhost:8080` in your browser.
    This is the output you will see:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行`node app.js`命令，并在浏览器中访问`localhost:8080`。您将看到以下输出：
- en: '![Converting Express.js routes to a functional reactive pattern](img/00118.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![将Express.js路由转换为函数式响应式模式](img/00118.jpeg)'
- en: Making the user experience better
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改善用户体验
- en: In the previous screenshot, you can see that there are eight fields based on
    which a user can perform a search.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的截图中，您可以看到有八个字段，用户可以根据这些字段进行搜索。
- en: 'Instead of a user just filling some of the fields and clicking on the **Search**
    button to get the result, we can add some more features to make the user experience
    better. Here are the extra things we are going to add:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加一些功能来改善用户体验，而不仅仅是用户填写一些字段并单击**搜索**按钮来获取结果。以下是我们将要添加的额外功能：
- en: Whenever a user uses the *Enter* key in any of the fields, we need fetch the
    search result
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在任何字段中使用*Enter*键时，我们需要获取搜索结果
- en: While a user types the company name, we will show a drop-down menu with suggestions
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户输入公司名称时，我们将显示一个带有建议的下拉菜单
- en: At least one of the fields except the gender field should have some value in
    order for us to fetch a search result.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了性别字段之外，至少有一个字段应该有一些值，以便我们获取搜索结果。
- en: If the entered e-mail is of invalid format, then we should display an error
    message.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入的电子邮件格式无效，则应显示错误消息。
- en: These features will make the frontend code more complex, which will give us
    a chance to explore how to write complex logic using Bacon.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能将使前端代码更加复杂，这将让我们有机会探索如何使用Bacon编写复杂的逻辑。
- en: The company suggestions route
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公司建议路由
- en: Let's create a route that responds with an array of company name suggestions
    based on a given value. Later on, to populate the company name text field drop-down
    menu, we will make a request to this route.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个路由，根据给定的值响应一个公司名称建议数组。稍后，为了填充公司名称文本字段的下拉菜单，我们将向这个路由发出请求。
- en: We will not build functionality to add profiles; instead, we will simply retrieve
    profiles from a JSON file that has some random profiles. In the `initial` directory,
    you will find a file named `data.json`, which has some profiles in it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会构建添加配置文件的功能；相反，我们将简单地从一个包含一些随机配置文件的JSON文件中检索配置文件。在`initial`目录中，您会找到一个名为`data.json`的文件，其中包含一些配置文件。
- en: Let's first read the data from the `data.json` file. Here is the code for this.
    Place it in the `app.js` file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先从`data.json`文件中读取数据。以下是此操作的代码。将其放在`app.js`文件中。
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we are reading the data in functional reactive style and then converting
    the EventStream to a property, which represents the data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们以函数响应式风格读取数据，然后将EventStream转换为表示数据的属性。
- en: 'Here is the code for the company suggestion route. Place it in the `app.js`
    file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是公司建议路由的代码。将其放在`app.js`文件中：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is how the code works:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的工作原理如下：
- en: At first, we define a method that takes an array of profiles and a company name.
    It checks for the profiles that have the same company and returns the filtered
    list. We are using the ES6 filter method, as Bacon doesn't provide any filter
    method for arrays. If the company name string is empty, then it returns an empty
    array.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个方法，它接受一个配置文件数组和一个公司名称。它检查具有相同公司的配置文件，并返回过滤后的列表。我们使用ES6的filter方法，因为Bacon不提供数组的filter方法。如果公司名称字符串为空，则返回一个空数组。
- en: Then, we create an EventStream for `/company/dropdown` path requests.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为`/company/dropdown`路径请求创建一个EventStream。
- en: Then, we combine `company_dropdown_list_stream` and the `data` property. The
    resultant property is then mapped, and the filtered result is the transformed
    value.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`company_dropdown_list_stream`和`data`属性组合起来。然后将结果属性映射，并过滤结果为转换后的值。
- en: We cannot simply use a subscriber here for `company_dropdown_list_stream` to
    respond to, as we have lost the reference to the connection object. Therefore,
    we zip `company_dropdown_list_stream` and `company_dropdown_list_data_stream`
    so that we get the reference to the connection object as well as the final result.
    We then attach a subscriber to the zipped EventStream, which sends the response.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不能简单地使用一个订阅者来响应`company_dropdown_list_stream`，因为我们已经失去了连接对象的引用。因此，我们将`company_dropdown_list_stream`和`company_dropdown_list_data_stream`进行压缩，以便我们既获得连接对象的引用，又获得最终结果。然后，我们将订阅者附加到压缩的EventStream上，发送响应。
- en: One more thing to notice here is that we are using `onValues` instead of `onValue`.
    The difference between them is that `onValues` splits the value (assuming it's
    an array) as function arguments.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里需要注意的另一件事是，我们使用`onValues`而不是`onValue`。它们之间的区别在于`onValues`将值（假设它是一个数组）拆分为函数参数。
- en: The search result route
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索结果路由
- en: Let's create a route that responds with an array of profiles based on a given
    parameter. This will be used to find the search result. Later on, from the frontend,
    we will make a request to this route.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个路由，根据给定的参数响应一个配置文件数组。这将用于查找搜索结果。稍后，从前端，我们将向这个路由发出请求。
- en: 'Here is the code for this route. Place it in the `app.js` file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此路由的代码。将其放在`app.js`文件中：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is how the code works:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的工作原理如下：
- en: At first, we define two methods, which take a list of profiles and search data
    and filter based on the data. The first one only filters based on e-mail whereas
    the second one filters based on other search data. We have done it this way because
    e-mail is unique for every profile, and if a user provides an e-mail ID, then
    we don't need to use other data and waste computation. When there is a lot of
    data, you will get a big performance advantage this way.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义了两种方法，它们接受一个配置文件列表和搜索数据，并根据数据进行过滤。第一种方法仅基于电子邮件进行过滤，而第二种方法基于其他搜索数据进行过滤。我们之所以这样做是因为电子邮件对于每个配置文件都是唯一的，如果用户提供了电子邮件ID，那么我们就不需要使用其他数据和浪费计算。当数据量很大时，这种方式将获得很大的性能优势。
- en: Then, we create an EventStream for the `/search` path.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为`/search`路径创建一个EventStream。
- en: After that, we create two streams, namely, `profile_search_data_stream_form_email`
    and `profile_search_data_stream_form_others`. The `profile_search_data_stream_form_email`
    stream is the final result if an e-mail is provided, and `profile_search_data_stream_form_others`
    is the final result if an e-mail is not provided.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们创建了两个流，即`profile_search_data_stream_form_email`和`profile_search_data_stream_form_others`。如果提供了电子邮件，则`profile_search_data_stream_form_email`流是最终结果，如果没有提供电子邮件，则`profile_search_data_stream_form_others`是最终结果。
- en: Finally, we merge `profile_search_data_stream_form_email` and `profile_search_data_stream_form_others`,
    zip that with `profile_search_stream`, and return the response.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们合并`profile_search_data_stream_form_email`和`profile_search_data_stream_form_others`，将其与`profile_search_stream`进行压缩，并返回响应。
- en: Building the frontend
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建前端
- en: We are done building the backend part of our profile search widget. Now, we
    need to write the frontend part.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了构建配置文件搜索小部件的后端部分。现在，我们需要编写前端部分。
- en: 'Before we get into it, it''s worth looking at the code in the `index.html`
    file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解之前，值得看一下`index.html`文件中的代码：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Most of the code is self-explanatory. Here are a few things you need to pay
    special attention to:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码都是不言自明的。以下是一些需要特别注意的事项：
- en: Here, every input element has an `id` value attached to it. We will use the
    `id` value to create an EventStream.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，每个输入元素都附有一个`id`值。我们将使用`id`值来创建一个EventStream。
- en: We have displayed an error message below the e-mail field. It has a class `hide`,
    which hides it. Removing the class will unhide it.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在电子邮件字段下方显示了一个错误消息。它有一个`hide`类，用于隐藏它。移除类将使其显示出来。
- en: We also have a `datalist` element, which is the drop-down menu for the `company`
    field. We just need to add `option` tags to the `datalist` element to show the
    drop-down menu.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还有一个`datalist`元素，它是`company`字段的下拉菜单。我们只需要向`datalist`元素添加`option`标签，就可以显示下拉菜单。
- en: Finally, we have a section to display the search result.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有一个部分来显示搜索结果。
- en: 'Now, let''s create EventStreams for `keyup` events on the input fields and
    store the current value of the fields in properties. Here is the code for this.
    Place it in the `index.js` file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为输入字段上的`keyup`事件创建EventStreams，并将字段的当前值存储在属性中。以下是此代码。将其放在`index.js`文件中：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Most of the above code is self-explanatory. The only thing that you need to
    understand is that instead of directly assign the e-mail field value to the e-mail
    property, we first validate whether the e-mail is valid. If the e-mail is invalid,
    then we display the error message and don't assign anything to the e-mail property.
    If the e-mail is valid, then we hide the error message and assign the current
    value of the e-mail field to the e-mail property.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上面大部分代码都是不言自明的。您需要理解的唯一一件事是，我们不直接将电子邮件字段的值分配给电子邮件属性，而是首先验证电子邮件是否有效。如果电子邮件无效，则我们显示错误消息并不将任何内容分配给电子邮件属性。如果电子邮件有效，则我们隐藏错误消息并将电子邮件字段的当前值分配给电子邮件属性。
- en: 'Now, let''s write code to display the suggestions drop-down menu for the company
    field. Here is the code for this. Place it in the `index.js` file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写代码来显示公司字段的建议下拉菜单。以下是此代码。将其放在`index.js`文件中：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, whenever the value of company property changes, we make a request to the
    `/company/dropdown` path, retrieve the suggestions, and append them to the `datalist`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每当公司属性的值发生变化时，我们都会向`/company/dropdown`路径发出请求，检索建议，并将它们附加到`datalist`。
- en: 'Finally, we need to make a `search` request whenever a user clicks on the **Search**
    button or hits *Enter* while in any of the input fields. Here is the code for
    this. Place it in the `index.js` file:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每当用户单击**搜索**按钮或在任何输入字段中按*Enter*时，我们都需要发出`search`请求。以下是此代码。将其放在`index.js`文件中：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here is how the code works:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的工作原理：
- en: At first, we create a click stream for the **Search** button.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们为**搜索**按钮创建一个点击流。
- en: Then, we create the `search_result_request_stream` stream, in which an event
    is pushed whenever we click on the **Search** button or press the *Enter* key
    inside any of the fields.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建`search_result_request_stream`流，在其中，每当我们单击**搜索**按钮或在任何字段中按*Enter*键时，都会推送一个事件。
- en: Then, we make a request to the `/search` path if any of the fields along with
    the gender field has a value; otherwise, we display an alert message asking the
    user to enter some data.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，如果任何字段以及性别字段中有值，我们会向`/search`路径发出请求；否则，我们会显示一个警报消息，要求用户输入一些数据。
- en: And then, if the we get an AJAX error, then we display an alert with the error
    message; if the AJAX response isn't empty, then we display the result; and finally,
    if the AJAX request is empty, we displaying an alert with a message stating that
    nothing was found.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，如果我们遇到AJAX错误，我们会显示带有错误消息的警报；如果AJAX响应不为空，我们会显示结果；最后，如果AJAX请求为空，我们会显示带有消息的警报，说明未找到任何内容。
- en: Testing the widget
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试小部件
- en: To test the widget, rerun the `node app.js` command. Now, refresh the `localhost:8080`
    URL.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试小部件，请重新运行`node app.js`命令。现在，刷新`localhost:8080` URL。
- en: 'To test whether the search widget is working, enter `Robert` in the **First**
    **Name** field and press *Enter*. You will see this output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试搜索小部件是否有效，请在**名字**字段中输入`Robert`并按*Enter*。您将看到以下输出：
- en: '![Testing the widget](img/00119.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![测试小部件](img/00119.jpeg)'
- en: 'To test the company suggestions drop-down menu, enter `a` in the **Company**
    field, and you will see this output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试公司建议下拉菜单，请在**公司**字段中输入`a`，您将看到以下输出：
- en: '![Testing the widget](img/00120.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![测试小部件](img/00120.jpeg)'
- en: So now, we have finished building and testing our advanced profile search widget.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经完成了构建和测试我们的高级个人资料搜索小部件。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the advanced APIs and concepts of Bacon.js and
    built a real-world project using them. You should now be comfortable with writing
    reactive code in a functional manner using Bacon.js and should try integrating
    Bacon.js into your existing and future projects.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Bacon.js的高级API和概念，并使用它们构建了一个真实世界的项目。您现在应该可以舒适地使用Bacon.js以函数方式编写反应式代码，并应该尝试将Bacon.js集成到您现有和未来的项目中。
- en: You can also learn more about Bacon.js APIs at [https://baconjs.github.io/api.html](https://baconjs.github.io/api.html).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://baconjs.github.io/api.html](https://baconjs.github.io/api.html)了解有关Bacon.js
    API的更多信息。

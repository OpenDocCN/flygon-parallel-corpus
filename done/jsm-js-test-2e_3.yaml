- en: Chapter 3. Testing Frontend Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。测试前端代码
- en: Testing JavaScript browser code has been notoriously considered hard, and although
    there are many complications while dealing with cross-browser testing, the most
    common problem is not with the testing process but rather that the application
    code itself is not testable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试JavaScript浏览器代码一直被认为是困难的，尽管在处理跨浏览器测试时会遇到许多复杂问题，但最常见的问题不在于测试过程，而是应用程序代码本身不可测试。
- en: Since every element in the browser's document is accessible globally, it is
    easy to write a monolithic piece of JavaScript code, which deals with the whole
    page. This leads to a number of problems, and the biggest one is that it is pretty
    hard to test.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器文档中的每个元素都可以全局访问，因此很容易编写一个整体的JavaScript代码块，它处理整个页面。这会导致一些问题，其中最大的问题是很难进行测试。
- en: In this chapter, we are going to get the best practices on how to write maintainable
    and testable browser code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何编写可维护和可测试的浏览器代码的最佳实践。
- en: To implement the user interface, we are going to use jQuery, a well-known JavaScript
    library that abstracts the browser's DOM in a clean and simple API that works
    across different browsers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现用户界面，我们将使用jQuery，这是一个众所周知的JavaScript库，它通过一个干净简单的API抽象了浏览器的DOM，可以在不同的浏览器上运行。
- en: 'To make the writing of the specs easier, we''re going to use Jasmine jQuery,
    a Jasmine extension that adds new matchers to perform assertions on jQuery objects.
    To install it and its jQuery dependency, download the following files:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使规范的编写更容易，我们将使用Jasmine jQuery，这是一个Jasmine扩展，它添加了新的匹配器来对jQuery对象执行断言。要安装它及其jQuery依赖项，请下载以下文件：
- en: '[https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/lib/jasmine-jquery.js](https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/lib/jasmine-jquery.js)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/lib/jasmine-jquery.js](https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/lib/jasmine-jquery.js)'
- en: '[https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/vendor/jquery/jquery.js](https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/vendor/jquery/jquery.js)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/vendor/jquery/jquery.js](https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/vendor/jquery/jquery.js)'
- en: 'Save these files as `jasmine-jquery.js` and `jquery.js` respectively inside
    the `lib` folder, and add them to `SpecRunner.html`, as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些文件保存为`jasmine-jquery.js`和`jquery.js`，分别放在`lib`文件夹中，并将它们添加到`SpecRunner.html`中，如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As seen until now, we have already created separate abstractions to handle both
    an investment and its associated stock. Now, it is time to develop this application's
    user interface and achieve a good result, which is all a matter of organization
    and good practices.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了单独的抽象来处理投资及其相关的股票。现在，是时候开发这个应用程序的用户界面并取得良好的结果了，这完全取决于组织和良好的实践。
- en: The same principles of software engineering that we apply on the server-side
    code must not be left behind when writing frontend JavaScript code. It is still
    important to think about components and proper separation of concerns.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在服务器端代码上应用的软件工程原则在编写前端JavaScript代码时也不容忽视。考虑组件和关注点的适当分离仍然很重要。
- en: Thinking in terms of components (Views)
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以组件（视图）的方式思考
- en: We've talked about the monolithic JavaScript code bases that plague most of
    the Web, which that are code bases that are impossible to test. And the best way
    not to fall into this trap is by coding the application driven by tests.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了困扰大部分网络的单片JavaScript代码库，这些代码库是不可能进行测试的。不陷入这个陷阱的最好方法是通过编写应用程序驱动的测试。
- en: 'Consider the mockup interface of our Investment Tracker application:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下我们的投资跟踪应用程序的模拟界面：
- en: '![Thinking in terms of components (Views)](graphics/B04138_03_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![以组件（视图）的方式思考](graphics/B04138_03_01.jpg)'
- en: This shows the Investment Tracker application's mockup interface
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了投资跟踪应用程序的模拟界面
- en: 'How would we go about implementing it? It is easy to see that this application
    has two different responsibilities:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何实施它？很容易看出，这个应用程序有两个不同的责任：
- en: One responsibility is to add an investment
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个责任是添加一个投资
- en: Another responsibility is to list the added investments
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个责任是列出添加的投资
- en: So, we could start by breaking this interface into two different components.
    To better describe them, we are going to borrow a concept from **MVC frameworks**,
    such as `Backbone.js`, and call them **Views**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以开始将此界面分解为两个不同的组件。为了更好地描述它们，我们将借鉴**MVC框架**（如`Backbone.js`）的概念，并称它们为**视图**。
- en: 'So, here it is, at the top level of the interface, with two base components:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在界面的顶层，有两个基本组件：
- en: '`NewInvestmentView`: This will be responsible for creating new investments'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView`：这将负责创建新的投资'
- en: '`InvestmentListView`: This is going to be a list of all added investments'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvestmentListView`：这将是所有添加的投资的列表'
- en: The module pattern
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块模式
- en: So, we understand how we must break up the code, but how do we organize it?
    Until now, we have created a file for each new function. This is a good practice,
    and we are going to see how we can improve on that.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们了解了如何分解代码，但是如何组织它呢？到目前为止，我们为每个新功能创建了一个文件。这是一个很好的做法，我们将看到如何改进它。
- en: 'Let''s start by thinking about our `NewInvestmentView` component. We can follow
    the pattern we''ve used until now and create a new file, `NewInvestmentView.js`,
    and place it in the `src` folder, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从思考我们的`NewInvestmentView`组件开始。我们可以按照我们到目前为止使用的模式创建一个新文件`NewInvestmentView.js`，并将其放在`src`文件夹中，如下所示：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see that this JavaScript file is more robust than the examples shown
    until now. We have wrapped all the `NewInvestmentView` code inside an **immediately
    invoked function expression** (**IIFE**).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，这个JavaScript文件比到目前为止显示的示例更健壮。我们已经将所有的`NewInvestmentView`代码包装在一个**立即调用的函数表达式**（**IIFE**）中。
- en: It is called an IIFE because it declares a function and immediately invokes
    it, effectively creating new scope to declare local variables in.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为IIFE，因为它声明一个函数并立即调用它，有效地创建了新的作用域来声明局部变量。
- en: 'A good practice is to use only local variables inside the IIFE. If it needs
    to use a global dependency, pass it through as a parameter. In this example, it
    is already passing three dependencies to the `NewInvestmentView` code: `jQuery`,
    `Investment`, and `Stock`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的做法是在IIFE中只使用局部变量。如果需要使用全局依赖项，将其作为参数传递。在这个例子中，它已经将三个依赖项传递给`NewInvestmentView`代码：`jQuery`，`Investment`和`Stock`。
- en: 'You can see this at the function declaration:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在函数声明中看到这一点：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And immediate invocation:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 并立即调用：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The biggest advantage of this practice is that we no longer need to worry about
    polluting the global namespace since everything we declare inside the IIFE will
    be local. This makes it much harder to mess with the global scope.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法的最大优点是，我们不再需要担心污染全局命名空间，因为我们在IIFE中声明的一切都将是局部的。这使得很难干扰全局范围。
- en: 'If we need to make anything global, we do that explicitly by attaching it with
    the global object, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要使任何东西全局化，我们通过将其附加到全局对象来明确地执行，如下所示：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Another advantage is the explicit dependency declaration. We know all about
    a file's external dependencies by glancing at its first line.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是明确的依赖声明。通过查看文件的第一行，我们就知道了文件的外部依赖。
- en: Although this practice does not have a great advantage right now (since all
    of the components are being exposed globally), we are going to see how to benefit
    from it in [Chapter 8](ch08.html "Chapter 8. Build Automation"), *Build Automation*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种做法现在并没有太大的优势（因为所有的组件都是全局暴露的），但我们将看到如何从中受益在[第8章](ch08.html "第8章. 构建自动化")，*构建自动化*。
- en: This pattern is also known as the **module pattern**, and we will use it throughout
    the rest of the book (even though sometimes it is omitted for simplification purposes).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式也被称为**模块模式**，我们将在本书的其余部分中使用它（即使有时为了简化目的而省略）。
- en: Using HTML fixtures
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTML fixtures
- en: 'Continuing with the development of the `NewInvestmentView` component, we can
    write some basic acceptance criteria, such as the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 继续开发`NewInvestmentView`组件，我们可以编写一些基本的验收标准，如下所示：
- en: '`NewInvestmentView` should allow the input of the stock symbol'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView`应该允许输入股票符号'
- en: '`NewInvestmentView` should allow the input of shares'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView`应该允许输入股票'
- en: '`NewInvestmentView` should allow the input of the share price'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView`应该允许输入股价'
- en: There are many more, but this is a good start.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多，但这是一个很好的开始。
- en: 'Create a new spec file for this component in the new file `NewInvestmentViewSpec.js`
    inside the `spec` folder, and we can start to translate those specs, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`spec`文件夹中创建一个名为`NewInvestmentViewSpec.js`的新组件的新规范文件，我们可以开始翻译这些规范，如下所示：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, before we can start to implement these, we must first understand the
    concept of **HTML fixtures**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们开始实现这些之前，我们必须首先了解**HTML fixtures**的概念。
- en: Test fixtures provide the base state in which the tests run. It could be a class
    instantiation, the definition of an object, or a piece of HTML. In other words,
    to test JavaScript code that handles a form submission, we need to have the form
    available when running the tests. The HTML code containing the form is an HTML
    fixture.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 测试fixtures提供了测试运行的基本状态。它可以是类的实例化，对象的定义，或者一段HTML。换句话说，为了测试处理表单提交的JavaScript代码，我们需要在运行测试时有表单可用。包含表单的HTML代码就是HTML
    fixture。
- en: 'One way to handle this requirement is to manually append the required DOM element
    inside a setup function, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个要求的一种方法是在设置函数中手动附加所需的DOM元素，如下所示：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, remove it during teardown, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在拆卸期间将其删除，如下所示：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Otherwise, the spec would append a lot of garbage inside the document, and it
    could interfere with the results of other specs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，规范将在文档中附加大量垃圾，并且可能会干扰其他规范的结果。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is important to know that specs should be independent, and that they can
    be run in any particular order. So, as a rule, treat specs completely in isolation
    from each other.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道规范应该是独立的，并且可以以任何特定顺序运行。因此，作为一个规则，完全独立地处理规范。
- en: 'A better approach is to have a container in the document where we always put
    the HTML fixtures, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是在文档中有一个容器，我们总是把HTML fixtures放在那里，如下所示：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Change the code to the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码更改为以下内容：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That way, the next time a spec runs, it automatically overwrites the previous
    fixture with its own.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，下次规范运行时，它会自动用自己的fixture覆盖上一个fixture。
- en: 'But, this can soon escalate into an incomprehensible mess as the fixtures get
    more complex:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，随着fixtures变得更加复杂，这很快就会升级为一个难以理解的混乱：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Wouldn't it be great if this fixture could be loaded from an external file?
    That is exactly what the Jasmine jQuery extension does with its **HTML fixture**
    module.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个装置可以从外部文件加载，那不是很好吗？这正是Jasmine jQuery扩展的**HTML fixture**模块所做的。
- en: 'We can place that HTML code in an external file and load it in the document
    with a simple call to `loadFixtures`, passing the fixture file path, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将HTML代码放在外部文件中，并通过简单调用`loadFixtures`来加载它到文档中，传递fixture文件路径，如下所示：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'By default, the extension looks for files inside the `spec/javascripts/fixtures`
    folder (for the previous example, it would be `spec/javascripts/fixtures/MyFixture.html`)
    and loads its content inside a container, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，扩展程序会在`spec/javascripts/fixtures`文件夹中查找文件（对于上一个示例，它将是`spec/javascripts/fixtures/MyFixture.html`），并将其内容加载到容器中，如下所示：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can also use another of the extension''s global functions to recreate the
    first example. The `setFixtures(html)` function accepts a parameter with the content
    to be placed in the container:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用扩展的另一个全局函数来重新创建第一个示例。`setFixtures(html)`函数接受一个参数，其中包含要放置在容器中的内容：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The other available functions are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可用的函数如下：
- en: '`appendLoadFixtures(fixtureUrl[, fixtureUrl, …])`: Instead of overwriting the
    content of the fixture container, this appends it'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appendLoadFixtures(fixtureUrl[, fixtureUrl, …])`：而不是覆盖fixture容器的内容，这会将其附加上'
- en: '`readFixtures(fixtureUrl[, fixtureUrl, …])`: This reads a fixture container''s
    content, but instead of appending it to the document, it returns a string with
    its contents'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readFixtures(fixtureUrl[, fixtureUrl, …])`：这读取一个fixture容器的内容，但不是将其附加到文档中，而是返回一个包含其内容的字符串'
- en: '`appendSetFixtures(html)`: This is the same as `appendLoadFixtures` but with
    an HTML string instead of a file'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appendSetFixtures(html)`: 这与`appendLoadFixtures`相同，但使用HTML字符串而不是文件'
- en: The Jasmine jQuery fixture module caches each file, so we can load the same
    fixture multiple times without penalty at the test suite's speed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine jQuery fixture模块缓存每个文件，因此我们可以多次加载相同的fixture而不会对测试套件的速度造成任何惩罚。
- en: It loads the fixtures using AJAX, and sometimes, a test might want to modify
    the inner workings of JavaScript or jQuery AJAX, as we will see in [Chapter 6](ch06.html
    "Chapter 6. Light Speed Unit Testing"), *Light Speed Unit Testing*, which would
    break the loading of a fixture. A workaround for this issue is to preload the
    required fixtures on the cache using the `preloadFixtures()` function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用AJAX加载fixtures，有时，测试可能希望修改JavaScript或jQuery AJAX的内部工作方式，就像我们将在[第6章](ch06.html
    "第6章。轻速单元测试")中看到的那样，*轻速单元测试*，这可能会破坏fixture的加载。解决这个问题的方法是使用`preloadFixtures()`函数将所需的fixtures预加载到缓存中。
- en: The `preloadFixtures(fixtureUrl[, fixtureUrl, …])` function loads one or more
    files in the cache without appending them to the document.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`preloadFixtures(fixtureUrl[, fixtureUrl, …])`函数在不将其附加到文档中的情况下加载一个或多个文件到缓存中。'
- en: There is an issue, though, while using HTML. Jasmine jQuery loads the HTML fixtures
    using AJAX, but because of the **same origin policy** (**SOP**), modern browsers
    will block all AJAX requests when opening the `SpecRunner.html` with a `file://`
    protocol.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用HTML时存在一个问题。Jasmine jQuery使用AJAX加载HTML fixtures，但由于**同源策略**（**SOP**），现代浏览器在使用`file://`协议打开`SpecRunner.html`时将阻止所有AJAX请求。
- en: A solution to this problem is to serve the spec runner through an HTTP server,
    as described in [Chapter 4](ch04.html "Chapter 4. Asynchronous Testing – AJAX"),
    *Asynchronous Testing – AJAX*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是通过HTTP服务器提供规范运行器，如[第4章](ch04.html "第4章。异步测试 - AJAX")中所述，*异步测试 - AJAX*。
- en: For now, there is a workaround available in Chrome through the **command-line
    interface** (**CLI**) argument `--allow-file-access-from-files`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在Chrome中有一个可用的解决方法，通过**命令行界面**（**CLI**）参数`--allow-file-access-from-files`。
- en: 'As an example, in Mac OS X, it would require the following command in bash
    to open Chrome with this flag:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Mac OS X中，需要在bash中使用以下命令以带有此标志的方式打开Chrome：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: More details on this issue can be seen at the GitHub ticket [https://github.com/velesin/jasmine-jquery/issues/4](https://github.com/velesin/jasmine-jquery/issues/4).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此问题的更多细节，请参见GitHub票证[https://github.com/velesin/jasmine-jquery/issues/4](https://github.com/velesin/jasmine-jquery/issues/4)。
- en: Coming back to the `NewInvestmentView` component, we can start the development
    of the spec with the help of this HTML fixture plugin.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`NewInvestmentView`组件，我们可以借助这个HTML fixture插件开始编写规范的开发。
- en: 'Create a folder named `fixtures` inside the `spec` folder. Based on the mockup
    interface, we can create a new HTML fixture called `NewInvestmentView.html` inside
    the `fixtures` folder, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在`spec`文件夹内创建一个名为`fixtures`的文件夹。根据模拟界面，我们可以在`fixtures`文件夹内创建一个名为`NewInvestmentView.html`的新HTML
    fixture，如下所示：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is an HTML fixture because it would otherwise be rendered by a server and
    the JavaScript code would simply attach to it and add behavior.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个HTML fixture，因为它否则将由服务器呈现，而JavaScript代码只是附加到它并添加行为。
- en: 'Because we are not saving this fixture at the plugin''s default path, we need
    to add a new configuration at the end of the `SpecHelper.js` file, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有将这个fixture保存在插件的默认路径下，所以我们需要在`SpecHelper.js`文件的末尾添加一个新的配置，如下所示：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the `NewInvestmentSpec.js` file, add a call to load the fixture:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NewInvestmentSpec.js`文件中，添加一个调用来加载fixture：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And finally, add both the spec and the source to the runner after the `Stock.js`
    and `Investment.js` files are added, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在添加`Stock.js`和`Investment.js`文件之后，将规范和源添加到runner中，如下所示：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Basic View coding rules
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的View编码规则
- en: 'Now, it is time to start coding the first View component. To help us through
    the process, we are going to lay two basic rules for View coding happiness:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候开始编写第一个View组件了。为了帮助我们完成这个过程，我们将为View编码幸福制定两条基本规则：
- en: The View should encapsulate a DOM element
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图应该封装一个DOM元素
- en: Integrate Views with observers
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将View与观察者集成
- en: So, let's see how they work individually.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们看看它们如何单独工作。
- en: The View should encapsulate a DOM element
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图应该封装一个DOM元素
- en: 'As mentioned earlier, a View is the behavior associated with a DOM element,
    so it makes sense to have this element related to the View. A good pattern is
    to pass a CSS `selector` in the View instantiation that indicates the element
    to which it should refer. Here is the spec for the `NewInvestmentView` component:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，View是与DOM元素相关联的行为，因此将此元素与View相关联是有意义的。一个很好的模式是在View实例化时传递一个CSS `selector`，指示它应该引用的元素。以下是`NewInvestmentView`组件的规范：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the constructor function at the NewInvestmentView.js file, it uses jQuery
    to get the element for this selector and to store it in an instance variable `$element`
    (source), as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在NewInvestmentView.js文件的构造函数中，它使用jQuery来获取此选择器的元素并将其存储在一个实例变量`$element`中（源代码），如下所示：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To make sure this code works, we should write the following test for it in
    the `NewInvestmentViewSpec.js` file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这段代码有效，我们应该在`NewInvestmentViewSpec.js`文件中为其编写以下测试：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `toExist` matcher is a custom matcher provided by the Jasmine jQuery extension
    to check whether an element exists in the document. It validates the existence
    of the property on the JavaScript object and also the successful association with
    the DOM element.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`toExist`匹配器是Jasmine jQuery扩展提供的自定义匹配器，用于检查文档中是否存在元素。它验证JavaScript对象上的属性的存在以及与DOM元素的成功关联。'
- en: Passing the `selector` pattern to the View allows it to be instantiated multiple
    times to different elements on the document.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将`selector`模式传递给View允许它在文档上的不同元素上实例化多次。
- en: Another advantage of having an explicit association is knowing that this View
    is not changing anything else on the document, as we will see next.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有明确关联的另一个优势是知道这个视图不会改变文档中的其他任何东西，我们将在下面看到。
- en: A View is the behavior associated with a DOM element, so it shouldn't be messing
    around everywhere on the page. It should only change or access the element associated
    with it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是与DOM元素相关联的行为，因此不应该在页面的任何地方乱动。它应该只改变或访问与其关联的元素。
- en: 'To demonstrate this concept, let''s implement another acceptance criterion
    regarding the default state of the View, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个概念，让我们实现另一个关于视图默认状态的验收标准，如下所示：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A naive implementation of the `getSymbolInput` method might use a global jQuery
    lookup to find the input and return its value:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSymbolInput`方法的一个天真的实现可能会使用全局jQuery查找来查找输入并返回其值：'
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: However, that could lead to a problem; if there is another input with that class
    name somewhere else in the document, it might get the wrong result.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这可能会导致一个问题；如果文档中的其他地方有另一个具有相同类名的输入，它可能会得到错误的结果。
- en: 'A better approach is to use the View''s associated element to perform a scoped
    lookup, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用视图的关联元素来执行范围查找，如下所示：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `find` function will only look for elements that are children of `this.$element`.
    It is as if `this.$element` represents the entire document for the View.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`函数只会查找`this.$element`的子元素。就好像`this.$element`代表了整个视图的文档。'
- en: 'Since we will use this pattern everywhere inside the View code, we can create
    a function and use it instead, as shown in the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在视图代码的各个地方使用这种模式，因此我们可以创建一个函数并使用它，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now let''s suppose that from somewhere else in the application, we want to
    change the value of a `NewInvestmentView` form input. We know its class name,
    so it could be as simple as this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设从应用程序的其他地方，我们想要更改`NewInvestmentView`表单输入的值。我们知道它的类名，所以可能就像这样简单：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: However, that simplicity hides a serious problem of encapsulation. This one
    line of code is creating a coupling with what should be an implementation detail
    of `NewInvestmentView`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种简单性隐藏了一个严重的封装问题。这一行代码正在与`NewInvestmentView`的实现细节产生耦合。
- en: If another developer changes `NewInvestmentView`, renaming the input class name
    from `.new-investment-stock-symbol` to `.new-investment-symbol`, that one line
    would be broken.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果另一个开发人员更改了`NewInvestmentView`，将输入类名从`.new-investment-stock-symbol`更改为`.new-investment-symbol`，那么这一行代码将会出错。
- en: To fix this, the developer would need to look at the entire code base for references
    to that class name.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，开发人员需要查看整个代码库中对该类名的引用。
- en: 'A much safer approach is to respect the View and use its APIs, as shown in
    the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更安全的方法是尊重视图并使用其API，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When implemented, that would look like the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当实施时，会看起来像下面这样：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That way, when the code gets refactored, there is only one point to perform
    the change—inside the `NewInvestmentView` implementation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当代码被重构时，只需要在`NewInvestmentView`的实现内执行一次更改。
- en: Since there is no sandboxing in the browser's document, which means that from
    anywhere in the JavaScript code, we can make a change anywhere in the document,
    there is not much that we can do, besides good practice, to prevent these mistakes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器的文档中没有沙箱，这意味着从JavaScript代码的任何地方，我们都可以在文档的任何地方进行更改，除了良好的实践外，我们无法做太多事情来防止这些错误。
- en: Integrating Views with observers
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用观察者集成视图
- en: Following the development of the Investment Tracker application, we would eventually
    need to implement the list of investments. But how would you go about integrating
    `NewInvestmentView` and `InvestmentListView`?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 随着投资跟踪应用程序的开发，我们最终需要实现投资列表。但是，您将如何集成`NewInvestmentView`和`InvestmentListView`？
- en: 'You could write an acceptance criterion for `NewInvestmentView`, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为`NewInvestmentView`编写一个验收标准，如下所示：
- en: Given the new investment View, when its add button is clicked, then it should
    add an investment to the list of investments.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 给定新的投资视图，当点击其添加按钮时，它应该将投资添加到投资列表中。
- en: 'This is very straightforward thinking, and you can see by the writing that
    we are creating a direct relationship between the two Views. Translating this
    into a spec clarifies this perception, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常直接的思维方式，通过写作可以看出我们在两个视图之间创建了直接关系。将这个转化为规范可以澄清这种感知，如下所示：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This solution creates a dependency between the two Views. The `NewInvestmentView`
    constructor now receives an instance of `InvestmentListView` as its `listView`
    parameter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案在两个视图之间创建了一个依赖关系。`NewInvestmentView`构造函数现在接收`InvestmentListView`的实例作为其`listView`参数。
- en: 'On its implementation, `NewInvestmentView` calls the `addInvestment` method
    of the `listView` object when its form is submitted:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在其实现中，`NewInvestmentView`在其表单提交时调用`listView`对象的`addInvestment`方法：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To better clarify how this code works, here is a diagram of how the integration
    is done:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地澄清这段代码的工作原理，这里是集成是如何完成的图表：
- en: '![Integrating Views with observers](graphics/B04138_03_02.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![使用观察者集成视图](graphics/B04138_03_02.jpg)'
- en: This shows a direct relationship between the two Views
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了两个视图之间的直接关系
- en: Although very simple, this solution introduces a number of architectural problems.
    The first, and most obvious, is the increased complexity of the `NewInvestmentView`
    specs.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管非常简单，但这个解决方案引入了许多架构问题。首先，最明显的是`NewInvestmentView`规范的复杂性增加了。
- en: Secondly, it makes evolving these components even more difficult due to the
    tight coupling.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，由于紧密耦合，使这些组件的演变变得更加困难。
- en: 'To better clarify this last problem, imagine that in the future, we want to
    list investments in a table too. This would impose a change in `NewInvestmentView`
    to support both the list and table Views, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地澄清这个问题，想象一下，将来我们也想在表格中列出投资。这将要求对`NewInvestmentView`进行更改，以支持列表和表视图，如下所示：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Rethinking on the acceptance criterion, we can get into a much better, future-proof
    solution. Let''s rewrite it as:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 重新思考验收标准，我们可以得到一个更好的、未来可靠的解决方案。让我们重写它：
- en: Given the Investment Tracker application, when a new investment is created,
    then it should add the investment to the list of investments.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 给定投资跟踪应用程序，当创建新的投资时，它应该将投资添加到投资列表中。
- en: 'We can see by the acceptance criterion that it has introduced a new subject
    to be tested: Investment Tracker. This implies a new source and spec file. After
    creating both the files accordingly and adding them to the runner, we can write
    this acceptance criterion as a spec, as shown in the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到验收标准引入了一个新的被测试的主题：投资跟踪。这意味着一个新的源文件和规范文件。在创建这两个文件并将它们添加到运行器后，我们可以将这个验收标准写成一个规范，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can see the same setup code that once was inside the `NewInvestmentView`
    spec. It loads the fixtures required by both Views, instantiates both `InvestmentListView`
    and `NewInvestmentView`, and creates a new instance of `InvestmentTracker`, passing
    both Views as parameters.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到曾经在`NewInvestmentView`规范内部的相同设置代码。它加载了两个视图所需的固定装置，实例化了`InvestmentListView`和`NewInvestmentView`，并创建了一个`InvestmentTracker`的新实例，将两个视图作为参数传递。
- en: Later on, while describing the behavior `when a new investment is created`,
    we can see the function call to the `newView.create` function to create a new
    investment.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，在描述`创建新的投资`的行为时，我们可以看到对`newView.create`函数的调用来创建一个新的投资。
- en: Later, it checks that a new item was added to the `listView` object by checking
    that `listView.count()` is equal to `1`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，它检查`listView`对象是否添加了一个新项目，通过检查`listView.count()`是否等于`1`。
- en: 'But how does the integration happen? We can see that by looking at the `InvestmentTracker`
    implementation:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 但是集成是如何发生的呢？我们可以通过查看`InvestmentTracker`的实现来看到：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It uses the `onCreate` function to register an observer function as a callback
    at `newView`. This observer function will be invoked later when a new investment
    is created.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用`onCreate`函数在`newView`上注册一个观察者函数作为回调。这个观察者函数将在以后创建新的投资时被调用。
- en: 'The implementation inside `NewInvestmentView` is quite simple. The `onCreate`
    method stores the `callback` parameter as an attribute of the object, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewInvestmentView`内部的实现非常简单。`onCreate`方法将`callback`参数存储为对象的属性，如下所示：'
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The naming convention of the `_callback` attribute might sound strange, but
    it is a good convention to indicate it as a private member.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`_callback`属性的命名约定可能听起来奇怪，但这是一个很好的约定，表明它是一个私有成员。'
- en: Although the prepended underline character won't actually change the visibility
    of the attribute, it at least informs a user of this object that the `_callback`
    attribute might change or even be removed in the future.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前置下划线字符实际上不会改变属性的可见性，但它至少会通知对象的用户，`_callback`属性可能会在将来发生变化，甚至被移除。
- en: 'Later, when the `create` method is invoked, it invokes `_callback`, passing
    the new investment as a parameter, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，当调用`create`方法时，它会调用`_callback`，并将新的投资作为参数传递，如下所示：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A more complete implementation would need to allow multiple calls to `onCreate`,
    storing every passed callback.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 更完整的实现需要允许多次调用`onCreate`，存储每个传递的回调。
- en: 'Here is the solution illustrated for better understanding:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是更好理解的解决方案：
- en: '![Integrating Views with observers](graphics/B04138_03_03.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![使用观察者集成视图](graphics/B04138_03_03.jpg)'
- en: Using callbacks to integrate the two Views
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回调函数集成两个视图
- en: Later, in [Chapter 7](ch07.html "Chapter 7. Testing React Applications"), *Testing
    React.js Applications*, we will see how the implementation of this `NewInvestmentView`
    spec turned out to be.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，在[第7章](ch07.html "第7章。测试React应用程序")，“测试React.js应用程序”中，我们将看到`NewInvestmentView`规范的实现结果。
- en: Testing Views with jQuery matchers
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jQuery匹配器测试视图
- en: Besides its HTML fixture module, the Jasmine jQuery extension comes with a set
    of custom matchers, which help in writing expectations with the DOM elements.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其HTML装置模块外，Jasmine jQuery扩展还带有一组自定义匹配器，这些匹配器有助于编写对DOM元素的期望。
- en: The biggest advantage of using these custom matchers, as demonstrated, is that
    they generate better error messages. So, although we can write all specs without
    using any of these matchers, it would get us much more useful information when
    an error happens if we used the matchers.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些自定义匹配器的最大优势，正如所示，是它们生成更好的错误消息。因此，尽管我们可以在不使用任何这些匹配器的情况下编写所有规范，但如果我们使用了这些匹配器，当发生错误时，它们会为我们提供更有用的信息。
- en: 'To better understand this advantage, we can revisit the example of the `should
    expose a property with its DOM element` spec. There, it uses the `toExist` matcher:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个优势，我们可以回顾一下`应该公开具有其DOM元素的属性`规范的例子。在那里，它使用了`toExist`匹配器：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If this spec fails, we get a nice error message, as shown in the following
    screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个规范失败，我们会得到一个很好的错误消息，如下面的截图所示：
- en: '![Testing Views with jQuery matchers](graphics/B04138_03_04.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![使用jQuery匹配器测试视图](graphics/B04138_03_04.jpg)'
- en: This shows a nice custom matcher error message
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了一个很好的自定义匹配器错误消息
- en: 'Now, we rewrite this spec without the custom matcher (still making the same
    validation):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们重新编写这个规范，不使用自定义匹配器（仍然进行相同的验证）：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This time, the error message gets less informative:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，错误消息变得不太具体：
- en: '![Testing Views with jQuery matchers](graphics/B04138_03_05.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![使用jQuery匹配器测试视图](graphics/B04138_03_05.jpg)'
- en: Upon reading the error, we can't understand what it is truly testing
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读错误时，我们无法理解它真正在测试什么
- en: 'So, use these matchers whenever you can to get better error messages. Let''s
    go over some of the available custom matchers, demonstrated by example, with these
    acceptance criteria of the `NewInvestmentView` class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽可能使用这些匹配器以获得更好的错误消息。让我们回顾一些可用的自定义匹配器，通过`NewInvestmentView`类的这些验收标准进行示例演示：
- en: '`NewInvestmentView` should allow the input of the stock symbol'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView`应该允许输入股票符号'
- en: '`NewInvestmentView` should allow the input of shares'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView`应该允许输入股票份额'
- en: '`NewInvestmentView` should allow the input of the share price'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView` 应该允许输入股价'
- en: '`NewInvestmentView` should have an empty stock symbol'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView` 应该有一个空的股票符号'
- en: '`NewInvestmentView` should have its shares'' value at zero'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView` 应该将其股票价值设为零'
- en: '`NewInvestmentView` should have its share price value at zero'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView` 应该将其股价值设为零'
- en: '`NewInvestmentView` should have its stock symbol input on focus'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView` 应该将其股票符号输入设为焦点'
- en: '`NewInvestmentView` should not allow to add'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView` 不应允许添加'
- en: It is important that you understand that these next examples, although useful
    to demonstrate how the Jasmine jQuery matchers work, are not really testing any
    JavaScript code but only the HTML elements that were loaded by the HTML fixture
    module.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是您要理解，尽管下面的示例对于演示Jasmine jQuery匹配器的工作方式非常有用，但实际上并没有测试任何JavaScript代码，而只是测试了由HTML
    fixture模块加载的HTML元素。
- en: The toBeMatchedBy jQuery matcher
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: toBeMatchedBy jQuery匹配器
- en: 'This matcher checks whether the element matches the passed CSS selector, as
    follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此匹配器检查元素是否与传递的CSS选择器匹配，如下所示：
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The toContainHtml jQuery matcher
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: toContainHtml jQuery匹配器
- en: 'This matcher checks whether the content of the element matches the passed HTML,
    as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此匹配器检查元素的内容是否与传递的HTML匹配，如下所示：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The toContainElement jQuery matcher
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: toContainElement jQuery匹配器
- en: This matcher checks whether the element contains any child element matching
    the passed CSS selector, as follows
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此匹配器检查元素是否包含与传递的CSS选择器匹配的任何子元素，如下所示
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The toHaveValue jQuery matcher
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: toHaveValue jQuery匹配器
- en: 'Only valid for inputs, this validates the expected value against the element''s
    value attribute with the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 仅适用于输入，此代码验证预期值与元素的值属性是否匹配：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The toHaveAttr jQuery matcher
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: toHaveAttr jQuery匹配器
- en: 'This matcher tests whether the element has any attribute with the name and
    value specified. The following example shows how to use this matcher to test an
    input for its value attribute, an expectation that could have been written with
    the `toHaveValue` matcher:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此匹配器测试元素是否具有指定名称和值的任何属性。以下示例显示了如何使用此匹配器测试输入的值属性，这是可以使用`toHaveValue`匹配器编写的预期：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The toBeFocused jQuery matcher
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: toBeFocused jQuery匹配器
- en: 'The following code illustrates how the matcher checks whether the input element
    is focused:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码说明了匹配器如何检查输入元素是否聚焦：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The toBeDisabled jQuery matcher
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: toBeDisabled jQuery匹配器
- en: 'This matcher checks whether the element is disabled with the following code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此匹配器检查元素是否使用以下代码禁用：
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: More matchers
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多匹配器
- en: The extension has many more available matchers; make sure to check the documentation
    of the project at [https://github.com/velesin/jasmine-jquery#jquery-matchers](https://github.com/velesin/jasmine-jquery#jquery-matchers).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 该扩展有许多其他可用的匹配器；请确保查看项目文档 [https://github.com/velesin/jasmine-jquery#jquery-matchers](https://github.com/velesin/jasmine-jquery#jquery-matchers)。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how testing can become so much easier once you
    drive the application development by tests. You saw how to use the module pattern
    to better organize the project code and how the View pattern can help create a
    more maintainable browser code.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何通过测试驱动应用程序开发可以变得更加容易。您看到了如何使用模块模式更好地组织项目代码，以及View模式如何帮助创建更易于维护的浏览器代码。
- en: You learned how to use HTML fixtures, making your specs much more readable and
    understandable. I also showed you how to test code that interacts with the browser's
    DOM by the use of custom jQuery matchers.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您学会了如何使用HTML fixture，使您的规范更加易读和易懂。我还向您展示了如何通过自定义jQuery匹配器测试与浏览器DOM交互的代码。
- en: In the next chapter, we will go a step further and start testing server integration
    and asynchronous code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步开始测试服务器集成和异步代码。

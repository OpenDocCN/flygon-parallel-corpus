- en: Chapter 7. Testing React Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。测试React应用程序
- en: As a web developer, you are familiar with the way most websites are built today.
    There is usually a web server (in languages such as Java, Ruby, or PHP) that processes
    user requests and responds with markup (HTML).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Web开发人员，您熟悉今天构建大多数网站的方式。通常有一个Web服务器（使用Java、Ruby或PHP等语言），它处理用户请求并响应标记（HTML）。
- en: This means that on every request, the web server interprets the user action
    through the URL and renders the entire page.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在每个请求上，Web服务器通过URL解释用户操作并呈现整个页面。
- en: In an attempt to improve the user experience, more and more functionality started
    to get pushed from the server side to the client side, and JavaScript was no longer
    simply adding behavior to the page but was rendering it entirely. The biggest
    advantage was that a user action was no longer triggering a whole page refresh;
    the JavaScript code could deal with the entire browser document and mutate it
    accordingly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改善用户体验，越来越多的功能开始从服务器端推送到客户端，并且JavaScript不再仅仅是为页面添加行为，而是完全渲染页面。最大的优势是用户操作不再触发整个页面刷新；JavaScript代码可以处理整个浏览器文档并相应地进行变异。
- en: Although this did improve the user experience, it started to add a lot of complexity
    to the application code, which led to increased maintenance costs and the worst—bugs
    in the form of inconsistencies between different parts of the screen.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这确实改善了用户体验，但它开始给应用程序代码增加了很多复杂性，导致维护成本增加，最糟糕的是——在屏幕不同部分之间存在不一致的错误形式。
- en: In an attempt to bring sanity to this scenario, a number of libraries and frameworks
    were built, but they all failed in the sense that they didn't tackle the root
    cause of the entire problem—mutability.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这种情况变得理智，建立了许多库和框架，但它们都失败了，因为它们没有解决整个问题的根本原因——可变性。
- en: Server-side rendering was easy because there was no mutation to deal with. Given
    a new application state, the server would simply render everything again. What
    if we could get benefits from this approach in our client-side JavaScript code?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染很容易，因为没有变异要处理。给定一个新的应用程序状态，服务器将简单地重新渲染所有内容。如果我们能从这种方法中在客户端JavaScript代码中获益会怎样呢？
- en: That is exactly what **React** proposes to do. You declaratively write the interface
    code in the form of components and tell React to render. On any change of the
    application state, you can simply tell React to re-render again; it will then
    calculate the mutations required to move the DOM to the required state and apply
    them for you.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是**React**提出的。您可以通过组件声明性地编写接口代码，并告诉React进行渲染。在应用程序状态发生任何变化时，您可以简单地告诉React再次进行重新渲染；然后它将计算移动DOM到所需状态所需的变异，并为您应用它们。
- en: During this chapter, we are going to understand how React works by refactoring
    the code we've built so far into an SPA.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过将到目前为止构建的代码重构为SPA来了解React的工作原理。
- en: Project setup
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: However, before we can dive into React, first we need a small setup in our project
    to allow us to create React components.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在我们可以深入了解React之前，首先我们需要在我们的项目中进行一些小的设置，以便我们可以创建React组件。
- en: Go to [http://facebook.github.io/react/downloads.html](http://facebook.github.io/react/downloads.html)
    and download the React Starter Kit Version 0.12.2 or higher.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 转到[http://facebook.github.io/react/downloads.html](http://facebook.github.io/react/downloads.html)并下载React
    Starter Kit版本0.12.2或更高版本。
- en: After the download, you can unpack its contents and move all the files from
    within the build folder to our application's lib folder. Then, just load the React
    library onto the `SpecRunner.html` file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，您可以解压其内容，并将构建文件夹中的所有文件移动到我们应用程序的lib文件夹中。然后，只需将React库加载到`SpecRunner.html`文件中。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With the setup complete, we can move on to writing our very first component.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，我们可以继续编写我们的第一个组件。
- en: Our first React component
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个React组件
- en: As stated in the introduction of this chapter, with React, you declaratively
    write the interface code through components.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章的介绍所述，使用React，您可以通过组件声明性地编写接口代码。
- en: The concept of a React component is analogous to the component concept presented
    in [Chapter 3](ch03.html "Chapter 3. Testing Frontend Code"), *Testing Frontend
    Code*, so expect to see some similarities next.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: React组件的概念类似于[第3章](ch03.html "第3章。测试前端代码")中介绍的组件概念，因此可以期待看到一些相似之处。
- en: With that in mind, let's create our very first component. To better understand
    what a React component is, we are going to use a very simple acceptance criterion
    and as usual start from the spec.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，让我们创建我们的第一个组件。为了更好地理解React组件是什么，我们将使用一个非常简单的验收标准，并像往常一样从规范开始。
- en: Let's implement "InvestmentListItem should render". It's very simple and not
    really *feature oriented* but is a good example to get us started.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现"InvestmentListItem应该呈现"。这很简单，不是真正*面向特性*，但是是一个很好的例子，让我们开始。
- en: 'With what we learned in [Chapter 3](ch03.html "Chapter 3. Testing Frontend
    Code"), *Testing Frontend Code*, we could start coding this spec by creating a
    new file called `InvestmentListItemSpec.js` and save it in the `components` folder
    inside the `spec` folder:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在[第3章](ch03.html "第3章。测试前端代码")中学到的知识，我们可以通过创建一个名为`InvestmentListItemSpec.js`的新文件并将其保存在`spec`文件夹内的`components`文件夹中来开始编写这个规范：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Add the new file to the `SpecRunner.html` file, as already demonstrated in previous
    chapters.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将新文件添加到`SpecRunner.html`文件中，就像在之前的章节中已经演示的那样。
- en: At the spec, we are basically using the `jasmine-jquery` plugin to expect that
    the encapsulated DOM element of our component is equal to a specific CSS selector.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在规范中，我们基本上使用`jasmine-jquery`插件来期望我们组件的封装DOM元素等于特定的CSS选择器。
- en: How would we change this example to be a test of a React component? The only
    difference is the API to get the DOM node. Instead of `$element` with a jQuery
    object, React exposes a function called `getDOMNode()` that returns what it states—a
    DOM node.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将这个示例更改为React组件的测试？唯一的区别是获取DOM节点的API。React暴露了一个名为`getDOMNode()`的函数，它返回它所声明的DOM节点。
- en: 'With that, we can use the same assertion as before and have our test ready,
    as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以使用与之前相同的断言，并准备好我们的测试，如下所示：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That was easy! So, the next step is to create the component, render it, and
    attach it to the document. That is simple as well; take a look at the following
    gist:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 那很容易！所以下一步是创建组件，渲染它，并将其附加到文档中。这也很简单；看一下以下要点：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It might seem like a lot of code, but half of it is just boilerplate to set
    up a document element fixture that we can render the React component in:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能看起来像是很多代码，但其中一半只是样板文件，用于设置我们可以在其中渲染React组件的文档元素装置：
- en: 'First, we use the `setFixtures` function from `jasmine-jquery` to create an
    element in the document with the `application-container` ID. Then, using the `getElementById`
    API, we query for this element and save it in the `container` variable. The next
    two steps are the ones specific to React:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用`jasmine-jquery`中的`setFixtures`函数在文档中创建一个带有`application-container`ID的元素。然后，使用`getElementById`
    API，我们查询此元素并将其保存在`container`变量中。接下来的两个步骤是特定于React的步骤：
- en: 'First, in order to use a component, we must first create an element from its
    class; this is done through the `React.createElement` function, as follows:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为了使用组件，我们必须首先从其类创建一个元素；这是通过`React.createElement`函数完成的，如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, with the element instance, we can finally tell React to render it through
    the `React.render` function, as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用元素实例，我们最终可以通过`React.render`函数告诉React渲染它，如下所示：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `render` function accepts the following two parameters:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`render`函数接受以下两个参数：'
- en: The React element
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React元素
- en: A DOM node to render the element in
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要渲染元素的DOM节点
- en: 'As of now, the spec is complete. You can run it and see it fail, showing the
    following error:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，规范已经完成。您可以运行它并查看它失败，显示以下错误：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The next step is to code the component. So, let's feed the spec, create a new
    file in the `src` folder, name it `InvestmentListItem.js`, and add it to the spec
    runner. This file should follow the module pattern we've been using until now.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是编写组件。因此，让我们满足规范，在`src`文件夹中创建一个新文件，命名为`InvestmentListItem.js`，并将其添加到规范运行程序。此文件应遵循我们到目前为止一直在使用的模块模式。
- en: 'Then, create a new class of component using the `React.createClass` method:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`React.createClass`方法创建一个新的组件类：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At the least, the `React.createClass` method expects a single `render` function
    that should return a tree of React elements.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少，`React.createClass`方法期望一个应该返回React元素树的`render`函数。
- en: 'We use again the `React.createElement` method to create the element that is
    going to be the root of the rendering tree, as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次使用`React.createElement`方法来创建将成为渲染树根的元素，如下所示：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The difference from its previous usage in the `beforeEach` block is that here,
    it is also passing a list of **props** (with `className`) and a single child containing
    the text `Investment`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与在`beforeEach`块中以前的用法的不同之处在于，这里还传递了一个**props**列表（带有`className`）和包含文本`Investment`的单个子元素。
- en: We will get deeper into the meaning of the props parameter, but you can think
    of it as analogous to the attributes of an HTML DOM element. The `className` prop
    will turn into the class HTML attribute of the `li` element.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更深入地了解props参数的含义，但您可以将其视为类似于HTML DOM元素的属性。`className` prop将变成`li`元素的class
    HTML属性。
- en: 'The `React.createElement` method signature accepts three arguments:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`React.createElement`方法签名接受三个参数：'
- en: The type of the component that can be either a string representing a real DOM
    element (such as `div`, `h1`, `p`) or a React component class
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的类型可以是表示真实DOM元素的字符串（例如`div`，`h1`，`p`）或React组件类
- en: An object containing the props values
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含props值的对象
- en: And a variable number of children components, which in this case, is just the
    `Investment` string
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及可变数量的子组件，在这种情况下，只是`Investment`字符串
- en: 'On rendering this component (by invoking the `React.render()` method), the
    result will be:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染此组件（通过调用`React.render()`方法）时，结果将是：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is a direct representation of the JavaScript code that generated it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成它的JavaScript代码的直接表示：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Congratulations! You've built your first fully tested React component.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经构建了您的第一个完全测试的React组件。
- en: The Virtual DOM
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟DOM
- en: When you define a component's render method and invoke the `React.createElement`
    method, you are not actually rendering anything in the document (you are not even
    creating DOM elements).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当您定义组件的渲染方法并调用`React.createElement`方法时，您实际上并没有在文档中渲染任何内容（甚至没有创建DOM元素）。
- en: It is only through the `React.render` function that the representation created
    by invoking these `React.createElement` calls are effectively converted into real
    DOM elements and attached to the document.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 只有通过调用这些`React.createElement`调用创建的表示才能有效地转换为真实的DOM元素并附加到文档中。
- en: This representation, defined by `ReactElements`, is what React calls the Virtual
    DOM. And `ReactElement` must not be confused with DOM elements; it is instead
    a light, stateless, immutable, virtual representation of a DOM element.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由`ReactElements`定义的这种表示是React称之为虚拟DOM。`ReactElement`不应与DOM元素混淆；它实际上是DOM元素的轻量、无状态、不可变的虚拟表示。
- en: So why did React get into the trouble of creating a new way of representing
    the DOM? The answer here is *performance*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么React要费力地创建一种新的表示DOM的方式呢？答案在于*性能*。
- en: As browsers evolved, JavaScript performance kept getting better and better,
    and today's application bottlenecks aren't actually JavaScript. You've probably
    heard that you should try touching the DOM as little as possible, and React allows
    you to do that by letting you interact with its own version of the DOM.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 随着浏览器的发展，JavaScript的性能不断提高，如今的应用程序瓶颈实际上并不是JavaScript。您可能听说过应该尽量少地触及DOM，而React允许您通过让您与其自己的DOM版本交互来做到这一点。
- en: However, that is not the only reason. React has built a very powerful diffing
    algorithm that can compare two distinct representations of the Virtual DOM, compute
    their differences, and with that information, create mutations that then get applied
    to the real DOM.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是唯一的原因。React构建了一个非常强大的差异算法，可以比较虚拟DOM的两个不同表示，计算它们的差异，并根据这些信息创建变化，然后应用于真实DOM。
- en: It allows us to get back to the flow we used to have with server-side rendering.
    We can basically, on any change of the application state, ask React to re-render
    everything, and it will then compute the minimal number of changes required and
    apply only that to the real DOM.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它使我们能够回到以前在服务器端渲染中使用的流程。基本上，我们可以在应用程序状态的任何更改时要求React重新渲染所有内容，然后它将计算所需的最小更改数量，并仅将其应用于真实DOM。
- en: It frees us developers from worrying about mutating the DOM and empowers us
    to write our user interfaces in a declarative way, while reducing bugs and improving
    productivity.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它使我们开发人员不必担心改变DOM，并赋予我们以声明方式编写用户界面的能力，同时减少错误并提高生产力。
- en: JSX
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX
- en: If you have any experience writing frontend JavaScript applications, you might
    be familiar with a few template languages. At this moment, you might be wondering
    where can you use your favorite template language (such as Handlebars) with React.
    And the answer is that you can't.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有编写前端JavaScript应用程序的经验，您可能熟悉一些模板语言。此时，您可能想知道在哪里可以使用您喜欢的模板语言（如Handlebars）与React一起使用。答案是不能。
- en: React doesn't make any distinction between markup and logic; in a React component,
    they are effectively the same.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: React不会区分标记和逻辑；在React组件中，它们实际上是相同的。
- en: However, what happens when we start crafting more complicated components? How
    would the form we built in [Chapter 3](ch03.html "Chapter 3. Testing Frontend
    Code"), *Testing Frontend Code*, translate into a React component?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们开始创建更复杂的组件时会发生什么？我们在[第3章](ch03.html "第3章。测试前端代码")中构建的表单会如何转换为React组件？
- en: 'To just render it without any other logic, it would take a bunch of `React.createElement`
    calls, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅呈现它而没有其他逻辑，需要进行一系列的`React.createElement`调用，如下所示：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is very verbose and hard to read. So, given that a React component is
    both markup and logic, wouldn''t it be better if we could write it as a mixture
    of HTML and JavaScript? Here''s how:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常冗长且难以阅读。因此，考虑到React组件既是标记又是逻辑，如果我们能够将其编写为HTML和JavaScript的混合，那不是更好吗？下面是方法：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That is **JSX**, a JavaScript syntax extension that looks like XML and was built
    to be used with React.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**JSX**，一种看起来像XML的JavaScript语法扩展，专为与React一起使用而构建。
- en: It transforms into JavaScript, so given the latter example, it would compile
    directly to the plain JavaScript code presented before.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它会转换为JavaScript，因此，根据后面的示例，它将直接编译为之前呈现的普通JavaScript代码。
- en: An important feature of the transformation process is that it doesn't change
    the line numbers; so, *line 10* in the JSX will translate into *line 10* in the
    transformed JavaScript file. This helps while debugging the code and doing static
    code analysis.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 转换过程的一个重要特性是它不会改变行号；因此，在JSX中的*第10行*将转换为转换后的JavaScript文件中的*第10行*。这有助于调试代码和进行静态代码分析。
- en: For more information about the language, you can check the official specification
    at [http://facebook.github.io/jsx/](http://facebook.github.io/jsx/), but for now,
    you can just follow the next examples as we dive into the features of this language.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '有关该语言的更多信息，您可以在[http://facebook.github.io/jsx/](http://facebook.github.io/jsx/)上查看官方规范，但现在，您可以随着我们深入了解该语言的特性，跟随下面的示例。 '
- en: It is important to know that it is not a requirement to use JSX while implementing
    React components, but it makes the process a lot easier. With that in mind, we
    are going to keep using it for now.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，在实现React组件时并不要求使用JSX，但它会让这个过程变得更容易。考虑到这一点，我们暂时会继续使用它。
- en: Using JSX with Jasmine
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JSX与Jasmine
- en: In order for us to use JSX with our Jasmine runner, there are a few changes
    we need to make.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们能够在Jasmine运行器中使用JSX，我们需要做一些更改。
- en: First, we need to rename the files with which we want to use the JSX syntax
    to `.jsx`. Although this is not a requirement, it allows us to easily identify
    when a file is using this special syntax.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将要使用JSX语法的文件重命名为`.jsx`。虽然这不是必需的，但它可以让我们轻松地识别出文件是否使用了这种特殊语法。
- en: 'Next, on the `SpecRunner.html` file, we need to change the script tags to indicate
    that these are not regular JavaScript files, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`SpecRunner.html`文件中，我们需要更改脚本标签，以指示这些不是常规的JavaScript文件，如下所示：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Unfortunately, these are not the only changes we need to make. The browser doesn't
    understand JSX syntax, so we need to load a special transformer that will first
    transform these files into regular JavaScript.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这些不是我们需要做的唯一更改。浏览器无法理解JSX语法，因此我们需要加载一个特殊的转换器，首先将这些文件转换为常规的JavaScript。
- en: 'This transformer comes bundled in the React starter kit, so just load it right
    after loading React, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个转换器已经捆绑在React起始套件中，所以只需在加载React后立即加载它，如下所示：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this setup done, we should be able to run the tests, shouldn't we? Unfortunately,
    there is one more step.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此设置后，我们应该能够运行测试，不是吗？不幸的是，还有一步。
- en: If you try to open the `SpecRunner.html` file in the browser, you will see that
    the tests of `InvestmentListItem` are not being executed. That is because the
    transformer works by loading the script files through AJAX, transforming them
    and finally attaching them to the DOM. By the time this process is complete, Jasmine
    has already run the tests.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试在浏览器中打开`SpecRunner.html`文件，您会发现`InvestmentListItem`的测试没有被执行。这是因为转换器通过AJAX加载脚本文件，对其进行转换，最后将其附加到DOM。在此过程完成时，Jasmine已经运行了测试。
- en: We need a way to inform Jasmine to wait for these files to load and be transformed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来告诉Jasmine等待这些文件加载和转换。
- en: The simplest way to do that is to change Jasmine's `boot.js` file placed in
    the `jasmine-2.1.3` folder, inside the `lib` folder.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是更改`jasmine-2.1.3`文件夹中`lib`文件夹内的`jasmine`的`boot.js`文件。
- en: 'In the original file, you are going to need to find the line that contains
    the `env.execute();` method and comment it out. It should be something like the
    following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始文件中，你需要找到包含`env.execute();`方法的行并将其注释掉。它应该类似于以下代码：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Everything else in the file should remain the same. After this change, you will
    see that the tests are no longer running—none of them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的其他内容应该保持不变。在这个更改之后，你会发现测试不再运行——一个都没有。
- en: 'The only missing piece is invoking this `execute` method once the JSX files
    are loaded. To do so, we are going to create a new file called `boot-exec.js`
    inside the `jasmine.2.1.3` folder with the following content:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一缺失的部分是一旦加载了JSX文件就调用这个`execute`方法。为此，我们将在`jasmine.2.1.3`文件夹中创建一个名为`boot-exec.js`的新文件，内容如下：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you see, it is only executing the previously commented code from the original
    boot file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它只是执行原始引导文件中以前注释的代码。
- en: 'To run this custom boot is very simple. We add it to the last line of the `<head>`
    tag of `SpecRunner.html` as a JSX type:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个自定义引导非常简单。我们将它作为JSX类型添加到`SpecRunner.html`的`<head>`标签的最后一行：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `JSXTransformer` library guarantees that the scripts are loaded in the order
    they are declared. So, by the time the `boot-exec.js` file is loaded, the source
    and test files are already loaded.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSXTransformer`库保证脚本按声明的顺序加载。因此，当`boot-exec.js`文件加载时，源文件和测试文件已经加载完毕。'
- en: With that, our test runner now supports JSX.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的测试运行器现在支持JSX了。
- en: Component attributes (props)
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件属性（props）
- en: Props are the way to pass down data from a parent to a child component in React.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Props是在React中从父组件传递数据到子组件的方式。
- en: For this next example, we want to change the `InvestmentListItem` component
    to render the value of the `roi` variable formatted in percentage.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个示例，我们想要更改`InvestmentListItem`组件，以便以百分比格式呈现`roi`变量的值。
- en: 'To implement the next specs, we are going to use a few helper methods that
    React offers through the `React.addons.TestUtils` object, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现下一个规范，我们将使用React通过`React.addons.TestUtils`对象提供的一些辅助方法，如下所示：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we are no longer using the `setFixture` method from the `jasmine-jquery`
    matcher. Instead, we are using the `TestUtils` module to render the component.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们不再使用`jasmine-jquery`匹配器中的`setFixture`方法。相反，我们使用`TestUtils`模块来渲染组件。
- en: The biggest difference here is that `TestUtils.renderIntoDocument` doesn't actually
    render in the document, but it renders into a detached node.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最大的区别是`TestUtils.renderIntoDocument`实际上并没有在文档中渲染，而是渲染到一个分离的节点中。
- en: The next thing you will notice is that the `InvestmentListItem` component has
    an attribute (actually called **prop**) where we pass down `investment`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你将注意到的下一件事是`InvestmentListItem`组件有一个属性（实际上称为**prop**），我们通过它传递`investment`。
- en: Then, at the spec, we are using another helper method called `findRenderedDOMComponentWithClass`
    to look for a DOM element in our `component` variable.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在规范中，我们使用另一个名为`findRenderedDOMComponentWithClass`的辅助方法来查找`component`变量中的DOM元素。
- en: 'This method returns `ReactElement`. And again, we will use the `getDOMNode`
    method to get the actual DOM element and then use the `jasmine-jquery` matcher
    to check for its text value, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法返回`ReactElement`。然后，我们将使用`getDOMNode`方法获取实际的DOM元素，然后使用`jasmine-jquery`匹配器来检查其文本值，如下所示：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Implementing this behavior in the component is actually very simple:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件中实现这种行为实际上非常简单：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can access any props passed to a component through the `this.props` object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`this.props`对象访问传递给组件的任何props。
- en: Expanding the original implementation, we've added a `span` element with the
    expected class from the spec.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展原始实现，我们添加了一个带有规范中预期类的`span`元素。
- en: 'To allow the return on investment to be dynamic, JSX has a special syntax.
    Using `{}`, you can invoke any JavaScript code in the middle of the XML. We are
    invoking the `formatPercentage` function while passing the `investment.roi()`
    value, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使投资回报率动态化，JSX有一种特殊的语法。使用`{}`，你可以在XML中间调用任何JavaScript代码。我们在传递`investment.roi()`值时调用`formatPercentage`函数，如下所示：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Again, just to make this clear, this JSX transformed into JavaScript would
    be:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调一下，这个JSX转换成JavaScript将是：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is important to know that a prop should be immutable. It is not the responsibility
    of a component to change its own prop values. You can consider a React component
    that has only props as a pure function, in that it always returns the same result
    value given the same argument values.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，prop应该是不可变的。改变自己的prop值不是组件的责任。你可以将只有props的React组件视为纯函数，因为它总是在给定相同参数值的情况下返回相同的结果值。
- en: This makes testing very simple as there are no mutations or changes in the state
    to test a component.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得测试非常简单，因为没有变异或更改状态来测试组件。
- en: Component events
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件事件
- en: UI applications have user events; in the web, they came in the form of DOM events.
    As React wraps each DOM element into React elements, handling them will be a little
    different yet very familiar.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: UI应用程序有用户事件；在Web中，它们以DOM事件的形式出现。由于React将每个DOM元素包装成React元素，处理它们会有一点不同，但非常熟悉。
- en: 'For this next example, let''s suppose that our application will allow users
    to delete an investment. We could write this requirement through the following
    acceptance criterion:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个示例，假设我们的应用程序允许用户删除一个投资。我们可以通过以下验收标准来表达这个要求：
- en: Given an investment, InvestmentListItem should notify an observer onClickDelete
    when the delete button is clicked on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个投资，当单击删除按钮时，InvestmentListItem应该通知观察者onClickDelete。
- en: The idea here is the same as presented in the *Integrate Views with observers*
    section of [Chapter 3](ch03.html "Chapter 3. Testing Frontend Code"), *Testing
    Frontend Code*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法与[第3章](ch03.html "第3章。测试前端代码")中的*将视图与观察者集成*部分中提出的想法是一样的，*测试前端代码*。
- en: 'So, how should we set the observer in a component? As we''ve already seen previously,
    **props** are the way to pass attributes to our component, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们应该如何在组件中设置观察者？正如我们之前已经看到的，**props**是将属性传递给我们的组件的方式，如下所示：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, we passed down another prop to the `onClickDelete` component,
    and as its value, we set a Jasmine spy, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们将另一个prop传递给`onClickDelete`组件，并将其值设置为Jasmine spy，如下所示：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Then, we found the delete button through its tag and used the `TestUtils`
    module to simulate a click, expecting the previously created spy to be called,
    as follows:**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过其标签找到了删除按钮，并使用`TestUtils`模块模拟了一个点击，期望之前创建的间谍被调用，如下所示：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**The `TestUtils.Simulate` module contains helper methods to simulate all types
    of DOM events, as follows:**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestUtils.Simulate`模块包含了模拟所有类型的DOM事件的辅助方法，如下所示：'
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Then, we got back to the implementation:**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们回到了实现：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**As you can see, it was as simple as nesting another `button` component and
    passing down the `onClickDelete` prop value as its `onClick` prop.**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它就像嵌套另一个`button`组件并将`onClickDelete`属性值作为其`onClick`属性传递一样简单。
- en: '**React normalizes events so that they have consistent properties across different
    browsers, but its naming conventions and syntax is similar to inline JavaScript
    code in HTML. To get a comprehensive list of the supported events, you can check
    the official documentation at [http://facebook.github.io/react/docs/events.html](http://facebook.github.io/react/docs/events.html).**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: React标准化事件，以便它们在不同浏览器中具有一致的属性，但其命名约定和语法类似于HTML中的内联JavaScript代码。要获取支持的事件的全面列表，可以在官方文档中查看[http://facebook.github.io/react/docs/events.html](http://facebook.github.io/react/docs/events.html)。
- en: '**# Component state'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '#组件状态'
- en: Until now, we've dealt with React as a stateless rendering engine, but as we
    know, applications have state, especially when using forms. So, how would we implement
    the `NewInvestment` component in order for it to keep hold of the values of the
    investment being created and then notify an observer once the user completed the
    form?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将React视为一个无状态的渲染引擎，但是我们知道，应用程序有状态，特别是在使用表单时。那么，我们应该如何实现`NewInvestment`组件，以便它保持正在创建的投资的值，然后在用户完成表单后通知观察者？
- en: To help us implement this behavior, we are going to use another component internal
    API—its **state**.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们实现这种行为，我们将使用另一个组件内部API——它的**state**。
- en: 'Let''s take the following acceptance criterion:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下验收标准：
- en: 'Given that the inputs of the `NewInvestment` component are correctly filled,
    when the form is submitted, it should notify the `onCreate` observer with the
    investment attributes:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于`NewInvestment`组件的输入已正确填写，当提交表单时，它应该使用投资属性通知`onCreate`观察者：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This spec is basically using every trick we've learned until now, so without
    getting into the details, let's dive directly into the component implementation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范基本上使用了我们到目前为止学到的所有技巧，所以不要深入细节，让我们直接进入组件实现。
- en: 'The first thing that any component with state must declare is its initial state
    by defining a `getInitialState` method, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有状态的组件必须声明的第一件事是通过定义`getInitialState`方法来定义其初始状态，如下所示：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As illustrated in the preceding code, we are clearly defining the initial state
    of our form, and at the render method, we pass the state as `value` props to the
    input components.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的代码所示，我们清楚地定义了表单的初始状态，并在渲染方法中将状态作为`value`属性传递给输入组件。
- en: If you run this example in a browser, you will notice that you won't be able
    to change the values of the inputs. You can focus on the inputs, but trying to
    type won't change its values, and that is because of the way React works.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中运行此示例，您会注意到您无法更改输入的值。您可以聚焦在输入上，但尝试输入不会更改其值，这是因为React的工作方式。
- en: Unlike HTML, React components must represent the state of the view at any point
    in time and not only at initialization time. If we want to change the value of
    an input, we need to listen for the `onChange` events of the inputs and, with
    that information, update the state. The change in the state will then trigger
    a render that will update the value on screen.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与HTML不同，React组件必须在任何时间点表示视图的状态，而不仅仅是在初始化时。如果我们想要更改输入的值，我们需要监听输入的`onChange`事件，并根据该信息更新状态。状态的更改将触发渲染，从而更新屏幕上的值。
- en: To demonstrate how this works, let's implement this behavior at the `stockSymbol`
    input.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这是如何工作的，让我们在`stockSymbol`输入中实现这种行为。
- en: 'First, we need to change the render method, adding a handler to the `onChange`
    event:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要更改渲染方法，为`onChange`事件添加一个处理程序：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once the event is triggered, it will invoke the `_handleStockSymbolChange`
    method. Its implementation should update the state by invoking the `this.setState`
    method with the new value of the input, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦触发事件，它将调用`_handleStockSymbolChange`方法。它的实现应该通过调用`this.setState`方法来更新状态，新的输入值如下所示：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The event handler is a good place to perform simple validation or transformation
    in the input data before passing it to the state.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序是在将输入数据传递给状态之前执行简单验证或转换的好地方。
- en: As you can see, this is a lot of boilerplate code just to handle a single input.
    Since we are not implementing any custom behavior into our event handlers, we
    can use a special React feature that implements this "linked state" for us.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这是大量样板代码，只是为了处理单个输入。由于我们没有在事件处理程序中实现任何自定义行为，我们可以使用特殊的React功能来为我们实现这个“链接状态”。
- en: 'We are going to use a **Mixin** called `LinkedStateMixin`; but first, what
    is a Mixin? It is a way to share common functionality between components, which,
    in this case, is the "linked state". Take a look at the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为`LinkedStateMixin`的**Mixin**；但首先，什么是Mixin？它是在组件之间共享常见功能的一种方式，这种情况下是“链接状态”。看一下以下代码：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`LinkedStateMixin` works by adding the `linkState` function to the component,
    and instead of setting the `value` of the input, we set a special prop called
    `valueLink` with the link object returned by the function `this.linkState`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedStateMixin`通过向组件添加`linkState`函数工作，而不是设置输入的`value`，我们使用由函数`this.linkState`返回的链接对象设置一个名为`valueLink`的特殊属性。'
- en: The `linkState` function expects the name of the attribute of the **state**
    that it should link to the value of the input.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`linkState`函数期望**state**的属性名称，它应该将其链接到输入的值。'
- en: Component life cycle
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件生命周期
- en: As you might have noticed, React has an opinionated view on a component's API.
    But it also has a very strong opinion on its life cycle, allowing us developers
    to add hooks to create custom behavior and perform cleanup tasks as we develop
    our components.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，React对组件的API有自己的看法。但它对组件的生命周期也有非常强烈的看法，允许我们开发人员添加钩子来创建自定义行为并在开发组件时执行清理任务。
- en: This is one of React's greatest triumphs because it is through this standardization
    that we can create bigger and better components by composition; through that,
    we can use not only our components, but other people's components.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是React的最大胜利之一，因为通过这种标准化，我们可以通过组合创建更大更好的组件；通过这样，我们不仅可以使用我们自己的组件，还可以使用其他人的组件。
- en: 'To demonstrate one use case, we are going to implement a very simple behavior:
    on page load, we want the new investment form stock symbol input to be focused
    so that a user can start typing right away.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示一个用例，我们将实现一个非常简单的行为：在页面加载时，我们希望新的投资表单股票符号输入获得焦点，以便用户可以立即开始输入。
- en: But, before we can start writing the test, there is just one thing that we will
    need to do. As mentioned earlier, `TestUtils.renderIntoDocument` doesn't actually
    render anything in the document, but instead on a detached node. So, if we use
    it to render our component, we won't be able to make the assertion regarding the
    input's focus.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在我们开始编写测试之前，有一件事情我们需要做。如前所述，`TestUtils.renderIntoDocument`实际上并不在文档中呈现任何内容，而是在一个分离的节点上呈现。因此，如果我们使用它来呈现我们的组件，我们将无法对输入的焦点进行断言。
- en: 'So, yet again, we have to use the `setFixtures` method to actually render the
    React component in the document, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须再次使用`setFixtures`方法来实际在文档中呈现React组件，如下所示：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With this small change completed, and the spec written, we can get back to the
    implementation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了这个小改变，并编写了规范，我们可以回到实现中。
- en: 'React gives a few hooks that we can implement custom code in our component
    during its life cycle; they are as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: React提供了一些钩子，我们可以在组件的生命周期中实现自定义代码；它们如下：
- en: '`componentWillMount`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillMount`'
- en: '`componentDidMount`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentDidMount`'
- en: '`componentWillReceiveProps`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillReceiveProps`'
- en: '`shouldComponentUpdate`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shouldComponentUpdate`'
- en: '`componentWillUpdate`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillUpdate`'
- en: '`componentDidUpdate`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentDidUpdate`'
- en: '`componentWillUnmount`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentWillUnmount`'
- en: To implement our custom behavior, we are going to use the `componentDidMount`
    hook that is called only once, right after the component was rendered and attached
    into a DOM element.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的自定义行为，我们将使用`componentDidMount`钩子，该钩子仅在组件被呈现并附加到DOM元素后调用一次。
- en: So, what we want to do is somehow inside this hook, get access to the input
    DOM element and trigger its focus. We already know how to get a DOM node; it is
    through the `getDOMNode` API. But, how do we get the input's React element?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们想要在这个钩子内部以某种方式访问输入DOM元素并触发其焦点。我们已经知道如何获取DOM节点；通过`getDOMNode` API。但是，我们如何获取输入的React元素呢？
- en: React's other feature for this problem is called **ref**. It is basically a
    way to give names to a component's children to allow later access.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: React针对这个问题的另一个特性称为**ref**。基本上，它是一种为组件的子元素命名的方法，以允许以后访问。
- en: 'Since we want the stock symbol input, we need to add a `ref` attribute to it,
    as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要股票符号输入，我们需要向其添加一个`ref`属性，如下所示：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, at the `componentDidMount` hook, we can get the input by its `ref` name
    and then its DOM element and trigger the focus, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`componentDidMount`钩子中，我们可以通过其`ref`名称获取输入，然后获取其DOM元素并触发焦点，如下所示：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The other hooks are setup in the same way, by simply defining them on the class
    definition object as properties. But each is called on different occasions, and
    has different rules. The official documentation is a great resource on their definition
    and possible use-cases which can be found at [http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods](http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 其他钩子以相同的方式设置，只需在类定义对象上定义它们作为属性。但是每个钩子在不同的场合被调用，并且有不同的规则。官方文档是关于它们定义和可能用例的很好资源，可以在[http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods](http://facebook.github.io/react/docs/component-specs.html#lifecycle-methods)找到。
- en: Composing components
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合组件
- en: We've talked a lot about **composability** in the way of creating components
    by composing React's default components. However, we haven't showed how to compose
    custom components into bigger components.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经谈了很多关于通过组合React的默认组件来创建组件的**可组合性**。然而，我们还没有展示如何将自定义组件组合到更大的组件中。
- en: 'As you might have guessed, this should be a pretty simple exercise, and to
    demonstrate how this works, we are going to implement a component to list investments,
    as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到，这应该是一个非常简单的练习，为了演示这个工作原理，我们将实现一个列出投资的组件，如下所示：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It is as simple as using the already available `InvestmentListItem` global variable
    as the root element of the `InvestmentList` component.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 只需使用已经可用的`InvestmentListItem`全局变量作为`InvestmentList`组件的根元素即可。
- en: The component expects an `investments` prop to be an array of investments. It
    then maps it through creating an `InvestmentListItem` element for each investment
    in the array.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件期望`investments`属性是一个投资数组。然后，它通过为数组中的每个投资创建一个`InvestmentListItem`元素来映射它。
- en: Finally, it uses the `listItems` array as the children of an `ul` element, effectively
    defining how to render the list of investments.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它使用`listItems`数组作为`ul`元素的子元素，有效地定义了如何呈现投资列表。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: React is a rapidly evolving library that is getting a lot of traction by the
    JavaScript community; it introduced some interesting patterns and questioned some
    well-established dogmas as it is continually improving the development of rich
    web applications.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: React是一个快速发展的库，受到JavaScript社区的广泛关注；它引入了一些有趣的模式，并质疑了一些既定的教条，不断改进了丰富的Web应用程序的开发。
- en: This chapter's goal was not to give an in-depth look into the library but an
    overview of its primary features and philosophies. It demonstrated that it is
    possible to do test-driven development while coding your interface with React.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标不是深入了解这个库，而是概述其主要特性和理念。它证明了在使用React编写界面时可以进行测试驱动开发。
- en: 'You learned about **prop** and **state** and their differences: A **prop**
    is not owned by the component, and should, if needed, be changed by its parent.
    The **state** is the data that the component owns. It can be changed by the component,
    and by doing so, a new render is triggered.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你学到了**prop**和**state**以及它们的区别：**prop**不是组件所拥有的，如果需要，应该由其父组件进行更改。**state**是组件拥有的数据。它可以被组件更改，这样就会触发新的渲染。
- en: The fewer components with state you have in your application, the easier it
    is going to be to reason about it and test it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中，拥有状态的组件越少，就越容易理解和测试。
- en: It is through React's opinionated API and life cycle that we can get the maximum
    benefit of composability and code reuse.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过React的有主见的API和生命周期，我们可以最大程度地实现组合性和代码重用的好处。
- en: As you move into application development with React, it is recommended that
    you learn about Flux, the recommended architecture to build applications by Facebook,
    at [http://facebook.github.io/flux/](http://facebook.github.io/flux/).**
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始使用React进行应用程序开发时，建议你了解Flux，这是Facebook推荐的构建应用程序的架构，网址是[http://facebook.github.io/flux/](http://facebook.github.io/flux/)。

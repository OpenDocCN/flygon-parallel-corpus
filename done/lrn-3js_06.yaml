- en: Chapter 6. Advanced Geometries and Binary Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 高级几何形状和二进制操作
- en: 'In the previous chapter, we showed you all the basic geometries provided by
    Three.js. Besides these basic geometries, Three.js also offers a set of more advanced
    and specialized objects. In this chapter, we''ll show you these advanced geometries
    and cover the following subjects:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们向你展示了Three.js提供的所有基本几何形状。除了这些基本几何形状，Three.js还提供了一组更高级和专业化的对象。在本章中，我们将向你展示这些高级几何形状，并涵盖以下主题：
- en: How to use advanced geometries such as `THREE.ConvexGeometry`, `THREE.LatheGeometry`,
    and `THREE.TubeGeometry`.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用高级几何形状，比如`THREE.ConvexGeometry`，`THREE.LatheGeometry`和`THREE.TubeGeometry`。
- en: How to create 3D shapes from 2D shapes using `THREE.ExtrudeGeometry`. We'll
    do this based on a 2D shape drawn using functionality provided by Three.js, and
    we'll show an example where we create a 3D shape based on an externally loaded
    SVG image.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`THREE.ExtrudeGeometry`从2D形状创建3D形状。我们将根据使用Three.js提供的功能绘制的2D形状来做这个，我们将展示一个例子，其中我们基于外部加载的SVG图像创建3D形状。
- en: If you want to create custom shapes yourself, you can easily amend the ones
    we've discussed in the previous chapters. Three.js, however, also offers a `THREE.ParamtericGeometry`
    object. With this object, you can create a geometry based on a set of equations.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想自己创建自定义形状，你可以很容易地修改我们在前几章中讨论的形状。然而，Three.js还提供了一个`THREE.ParamtericGeometry`对象。使用这个对象，你可以基于一组方程创建几何形状。
- en: Finally, we'll look at how you can create 3D text effects using `THREE.TextGeometry`.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将看看如何使用`THREE.TextGeometry`创建3D文本效果。
- en: Additionally, we'll also show you how you can create new geometries from existing
    ones using binary operations provided by the Three.js extension, ThreeBSP.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们还将向你展示如何使用Three.js扩展ThreeBSP提供的二进制操作从现有的几何形状创建新的几何形状。
- en: We'll start with the first one from this list, `THREE.ConvexGeometry`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从列表中的第一个开始，`THREE.ConvexGeometry`。
- en: THREE.ConvexGeometry
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: THREE.ConvexGeometry
- en: 'With `THREE.ConvexGeometry`, we can create a convex hull around a set of points.
    A convex hull is the minimal shape that encompasses all these points. The easiest
    way to understand this is by looking at an example. If you open up the `01-advanced-3d-geometries-convex.html`
    example, you''ll see the convex hull for a random set of points. The following
    screenshot shows this geometry:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`THREE.ConvexGeometry`，我们可以围绕一组点创建凸包。凸包是包围所有这些点的最小形状。最容易理解的方法是通过一个例子来看。如果你打开`01-advanced-3d-geometries-convex.html`的例子，你会看到一个随机点集的凸包。以下截图显示了这个几何形状：
- en: '![THREE.ConvexGeometry](graphics/2215OS_06_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.ConvexGeometry](graphics/2215OS_06_01.jpg)'
- en: 'In this example, we generate a random set of points and based on these points
    we create `THREE.ConvexGeometry`. In the example, you can click on **redraw**,
    which will generate 20 new points and draw the convex hull. We also add each of
    these points as a small `THREE.SphereGeometry` object to clearly show how a convex
    hull works. `THREE.ConvexGeometry` isn''t included in the standard Three.js distribution,
    so you have to include an additional JavaScript file to use this geometry. At
    the top of your HTML page, add the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们生成一组随机点，并基于这些点创建`THREE.ConvexGeometry`。在例子中，你可以点击**redraw**，这将生成20个新点并绘制凸包。我们还将每个点添加为一个小的`THREE.SphereGeometry`对象，以清楚地展示凸包的工作原理。`THREE.ConvexGeometry`没有包含在标准的Three.js发行版中，所以你必须包含一个额外的JavaScript文件来使用这个几何形状。在你的HTML页面顶部，添加以下内容：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following piece of code shows how these points were created and added to
    the scene:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了这些点是如何创建并添加到场景中的：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see in this snippet of code, we create 20 random points (`THREE.Vector3`),
    which we push into an array. Next, we iterate this array and create `THREE.SphereGeometry`,
    whose position we set to one of these points (`position.clone(point)`). All the
    points are added to a group (more on this in [Chapter 7](ch07.html "Chapter 7. Particles,
    Sprites, and the Point Cloud"), *Particles, Sprites, and the Point Cloud*), so
    we can rotate them easily by just rotating the group.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这段代码片段中看到的，我们创建了20个随机点（`THREE.Vector3`），并将它们推入一个数组中。接下来，我们遍历这个数组，并创建`THREE.SphereGeometry`，其位置设置为这些点之一（`position.clone(point)`）。所有点都被添加到一个组中（更多内容请参阅[第7章](ch07.html
    "第7章. 粒子、精灵和点云")），所以我们可以通过旋转组来轻松旋转它们。
- en: 'Once you have this set of points, creating `THREE.ConvexGeometry` is very easy,
    as shown in the following code snippet:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了这组点，创建`THREE.ConvexGeometry`就非常容易，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: An array containing vertices (of the `THREE.Vector3` type) is the only argument
    `THREE.ConvexGeometry` takes. Here's one final note on the `createMesh()` function
    (which is a function we created ourselves in [Chapter 5](ch05.html "Chapter 5. Learning
    to Work with Geometries"), *Learning to Work with Geometries*) we call here. In
    the previous chapter, we used this method to create a mesh using `THREE.MeshNormalMaterial`.
    For this example, we changed this to a translucent green `THREE.MeshBasicMaterial`
    to better show the convex hull we created and the individual points that make
    up this geometry.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 包含顶点（`THREE.Vector3`类型）的数组是`THREE.ConvexGeometry`的唯一参数。关于`createMesh()`函数（这是我们在[第5章](ch05.html
    "第5章. 学习使用几何形状")中自己创建的函数）我们在这里调用。在上一章中，我们使用这种方法使用`THREE.MeshNormalMaterial`创建网格。对于这个例子，我们将其更改为半透明的绿色`THREE.MeshBasicMaterial`，以更好地显示我们创建的凸包和构成这个几何形状的单个点。
- en: The next complex geometry is `THREE.LatheGeometry`, which can be used to create
    vase-like shapes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个复杂的几何形状是`THREE.LatheGeometry`，它可以用来创建类似花瓶的形状。
- en: THREE.LatheGeometry
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: THREE.LatheGeometry
- en: '`THREE.LatheGeometry` allows you to create shapes from a smooth curve. This
    curve is defined by a number of points (also called knots) and is most often called
    a spline. This spline is rotated around the central *z* axis of the object and
    results in vase-like and bell-like shapes. Once again, the easiest way to understand
    what `THREE.LatheGeometry` looks like is by looking at an example. This geometry
    is shown in `02-advanced-3d-geometries-lathe.html`. The following screenshot taken
    from the example shows this geometry:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.LatheGeometry`允许您从平滑曲线创建形状。这条曲线由许多点（也称为节点）定义，通常称为样条。这个样条围绕对象的中心*z*轴旋转，产生类似花瓶和钟形的形状。再次，理解`THREE.LatheGeometry`的最简单方法是看一个例子。这个几何图形显示在`02-advanced-3d-geometries-lathe.html`中。以下来自示例的截图显示了这个几何图形：'
- en: '![THREE.LatheGeometry](graphics/2215OS_06_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.LatheGeometry](graphics/2215OS_06_02.jpg)'
- en: 'In the preceding screenshot, you can see the spline as the set of small red
    spheres. The positions of these spheres are passed in to `THREE.LatheGeometry`,
    together with a couple of other arguments. In this example, we rotate this spline
    for half a circle, and based on this spline, we extract the shape you can see.
    Before we look at all the arguments, let''s look at the code used to create the
    spline and how `THREE.LatheGeometry` uses this spline:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，您可以看到样条作为一组小红色球体。这些球体的位置与其他参数一起传递给`THREE.LatheGeometry`。在这个例子中，我们将这个样条旋转了半圈，基于这个样条，我们提取了您可以看到的形状。在我们查看所有参数之前，让我们看一下用于创建样条的代码以及`THREE.LatheGeometry`如何使用这个样条：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this piece of JavaScript, you can see that we generate 30 points whose *x*
    coordinate is based on a combination of sine and cosine functions while the *z*
    coordinate is based on the `i` and `count` variables. This creates the spline
    visualized by the red dots in the preceding screenshot.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段JavaScript中，您可以看到我们生成了30个点，它们的*x*坐标是基于正弦和余弦函数的组合，而*z*坐标是基于`i`和`count`变量的。这创建了在前面截图中以红点可视化的样条。
- en: 'Based on these points, we can create `THREE.LatheGeometry`. Besides the array
    of vertices, `THREE.LatheGeometry` takes a couple of other arguments. The following
    table lists all the arguments:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些要点，我们可以创建`THREE.LatheGeometry`。除了顶点数组之外，`THREE.LatheGeometry`还需要一些其他参数。以下表格列出了所有的参数：
- en: '| Property | Mandatory | Description |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 强制 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `points` | Yes | These are the points that make up the spline used to generate
    the bell/vase shape. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `points` | 是 | 这些是用于生成钟形/花瓶形状的样条的点。 |'
- en: '| `segments` | No | These are the number of segments used when creating the
    shape. The higher this number, the more *round* the resulting shape will be. The
    default value for this is `12`. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `segments` | 否 | 这是在创建形状时使用的段数。这个数字越高，结果形状就越*圆润*。这个默认值是`12`。 |'
- en: '| `phiStart` | No | This determines where to start on a circle when generating
    the shape. This can range from `0` to `2*PI`. The default value is `0`. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `phiStart` | 否 | 这确定在生成形状时在圆上从哪里开始。这可以从`0`到`2*PI`。默认值是`0`。 |'
- en: '| `phiLength` | No | This defines how fully generated the shape is. For instance,
    a quarter shape will be `0.5*PI`. The default value is the full `360` degrees
    or `2*PI`. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `phiLength` | 否 | 这定义了形状生成的完整程度。例如，一个四分之一的形状将是`0.5*PI`。默认值是完整的`360`度或`2*PI`。
    |'
- en: In the next section, we'll look at an alternative way of creating geometries
    by extracting a 3D geometry from a 2D shape.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一种通过从2D形状中提取3D几何图形的替代方法。
- en: Creating a geometry by extruding
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过挤出创建几何图形
- en: Three.js provides a couple of ways in which we can extrude a 2D shape to a 3D
    shape. By extruding, we mean stretching out a 2D shape along its *z* axis to convert
    it to 3D. For instance, if we extrude `THREE.CircleGeometry`, we get a shape that
    looks like a cylinder, and if we extrude `THREE.PlaneGeometry`, we get a cube-like
    shape.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js提供了几种方法，可以将2D形状挤出为3D形状。通过挤出，我们指的是沿着它的*z*轴拉伸2D形状以将其转换为3D。例如，如果我们挤出`THREE.CircleGeometry`，我们得到一个看起来像圆柱体的形状，如果我们挤出`THREE.PlaneGeometry`，我们得到一个类似立方体的形状。
- en: The most versatile way of extruding a shape is using the `THREE.ExtrudeGeometry`
    object.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 挤出形状的最通用方法是使用`THREE.ExtrudeGeometry`对象。
- en: THREE.ExtrudeGeometry
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: THREE.ExtrudeGeometry
- en: 'With `THREE.ExtrudeGeometry`, you can create a 3D object from a 2D shape. Before
    we dive into the details of this geometry, let''s first look at an example: `03-extrude-geometry.html`.
    The following screenshot taken from the example shows this geometry:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`THREE.ExtrudeGeometry`，您可以从2D形状创建3D对象。在我们深入了解这个几何图形的细节之前，让我们先看一个例子：`03-extrude-geometry.html`。以下来自示例的截图显示了这个几何图形：
- en: '![THREE.ExtrudeGeometry](graphics/2215OS_06_03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.ExtrudeGeometry](graphics/2215OS_06_03.jpg)'
- en: 'In this example, we took the 2D shape we created in the previous chapter and
    used `THREE.ExtrudeGeometry` to convert it to 3D. As you can see in this screenshot,
    the shape is extruded along the *z* axis, which results in a 3D shape. The code
    to create `THREE.ExtrudeGeometry` is very easy:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们取出了在上一章中创建的2D形状，并使用`THREE.ExtrudeGeometry`将其转换为3D。正如您在这个截图中所看到的，形状沿着*z*轴被挤出，从而得到一个3D形状。创建`THREE.ExtrudeGeometry`的代码非常简单：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this code, we created the shape with the `drawShape()` function just as we
    did in the previous chapter. This shape is passed on to the `THREE.ExtrudeGeometry`
    constructor together with an `options` object. With the `options` object, you
    can define exactly how the shape should be extruded. The following table explains
    the options you can pass in to `THREE.ExtrudeGeometry`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们使用`drawShape()`函数创建了形状，就像在上一章中所做的那样。这个形状与一个`options`对象一起传递给`THREE.ExtrudeGeometry`构造函数。使用`options`对象，您可以精确地定义形状应该如何被挤出。以下表格解释了您可以传递给`THREE.ExtrudeGeometry`的选项。
- en: '| Property | Mandatory | Description |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 强制 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `shapes` | Yes | One or more shapes (`THREE.Shape` objects) are required
    to extrude the geometry from. See the preceding chapter on how to create such
    a shape. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `shapes` | 是 | 需要一个或多个形状（`THREE.Shape`对象）来从中挤出几何图形。请参阅前一章关于如何创建这样的形状。 |'
- en: '| `amount` | No | This determines how far (the depth) the shape should be extruded.
    The default value is `100`. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `amount` | 否 | 这确定形状应该被挤出的距离（深度）。默认值为`100`。 |'
- en: '| `bevelThickness` | No | This determines the depth of the bevel. The bevel
    is the rounded corner between the front and back faces and the extrusion. This
    value defines how deep into the shape the bevel goes. The default value is `6`.
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `bevelThickness` | 否 | 这确定倒角的深度。倒角是前后面和挤出之间的圆角。该值定义了倒角进入形状的深度。默认值为`6`。 |'
- en: '| `bevelSize` | No | This determines the height of the bevel. This is added
    to the normal height of the shape. The default value is `bevelThickness - 2`.
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `bevelSize` | 否 | 这确定倒角的高度。这加到形状的正常高度上。默认值为`bevelThickness - 2`。 |'
- en: '| `bevelSegments` | No | This defines the number of segments that will be used
    by the bevel. The more the number of segments used, the smoother the bevel will
    look. The default value is `3`. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `bevelSegments` | 否 | 这定义了用于倒角的段数。使用的段数越多，倒角看起来就越平滑。默认值为`3`。 |'
- en: '| `bevelEnabled` | No | If this is set to `true`, a bevel is added. The default
    value is `true`. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `bevelEnabled` | 否 | 如果设置为`true`，则添加倒角。默认值为`true`。 |'
- en: '| `curveSegments` | No | This determines how many segments will be used when
    extruding the curves of shapes. The more the number of segments used, the smoother
    the curves will look. The default value is `12`. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `curveSegments` | 否 | 这确定在挤出形状的曲线时将使用多少段。使用的段数越多，曲线看起来就越平滑。默认值为`12`。 |'
- en: '| `steps` | No | This defines the number of segments into the extrusion will
    be divided along its depth. The default value is `1`. A higher value will result
    in more individual faces. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `steps` | 否 | 这定义了沿着深度将挤出分成多少段。默认值为`1`。较高的值将导致更多的单独面。 |'
- en: '| `extrudePath` | No | This is the path (`THREE.CurvePath`) along which the
    shape should be extruded. If this isn''t specified, the shape is extruded along
    the *z* axis. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `extrudePath` | 否 | 这是沿着形状应该被挤出的路径（`THREE.CurvePath`）。如果未指定，则形状沿着 *z* 轴被挤出。
    |'
- en: '| `material` | No | This is the index of the material to use for the front
    and the back faces. Use the `THREE.SceneUtils.createMultiMaterialObject` function
    to create the mesh if you want separate materials for the front and back faces.
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `material` | 否 | 这是用于正面和背面的材质的索引。如果要为正面和背面使用不同的材料，可以使用`THREE.SceneUtils.createMultiMaterialObject`函数创建网格。
    |'
- en: '| `extrudeMaterial` | No | This is the index of the materials to use for the
    bevel and the extrusion. Use the `THREE.SceneUtils.createMultiMaterialObject`
    function to create the mesh if you want separate materials for the front and back
    faces. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `extrudeMaterial` | 否 | 这是用于倒角和挤出的材料的索引。如果要为正面和背面使用不同的材料，可以使用`THREE.SceneUtils.createMultiMaterialObject`函数创建网格。
    |'
- en: '| `uvGenerator` | No | When you use a texture with your material, the UV mapping
    determines what part of a texture is used for a specific face. With the `uvGenerator`
    property, you can pass in your own object that will create the UV settings for
    the faces that are created for the shapes that are passed in. More information
    on UV settings can be found in [Chapter 10](ch10.html "Chapter 10. Loading and
    Working with Textures"), *Loading and Working with Textures*. If none are specified,
    `THREE.ExtrudeGeometry.WorldUVGenerator` is used. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `uvGenerator` | 否 | 当您在材质中使用纹理时，UV映射确定了纹理的哪一部分用于特定的面。使用`uvGenerator`属性，您可以传入自己的对象，为传入的形状创建UV设置。有关UV设置的更多信息，请参阅[第10章](ch10.html
    "第10章。加载和使用纹理")*加载和使用纹理*。如果未指定，将使用`THREE.ExtrudeGeometry.WorldUVGenerator`。 |'
- en: '| `frames` | No | A frenet frame is used to calculate the tangents, normal,
    and binormals of a spline. This is used when extruding along `extrudePath`. You
    don''t need to specify this since Three.js provides its own implementation, `THREE.TubeGeometry.FrenetFrames`,
    which is also used as default. More information on frenet frames can be found
    at [http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame](http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame).
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `frames` | 否 | 弗雷内框架用于计算样条的切线、法线和副法线。这在沿着`extrudePath`挤出时使用。您不需要指定这个，因为Three.js提供了自己的实现，`THREE.TubeGeometry.FrenetFrames`，这也是默认值。有关弗雷内框架的更多信息，请参阅[http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame](http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame)。
    |'
- en: You can experiment with these options using the menu from the `03-extrude-geometry.html`
    example.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`03-extrude-geometry.html`示例中的菜单来尝试这些选项。
- en: In this example, we extruded the shape along its *z* axis. As you would have
    seen in the options, you can also extrude a shape along a path with the `extrudePath`
    option. In the following geometry, `THREE.TubeGeometry`, we'll do just that.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们沿着 *z* 轴挤出了形状。正如您在选项中所看到的，您还可以使用`extrudePath`选项沿着路径挤出形状。在下面的几何图形`THREE.TubeGeometry`中，我们将这样做。
- en: THREE.TubeGeometry
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: THREE.TubeGeometry
- en: '`THREE.TubeGeometry` creates a tube that extrudes along a 3D spline. You specify
    the path using a number of vertices, and `THREE.TubeGeometry` will create the
    tube. An example which you can experiment with can be found in the sources for
    this chapter (`04-extrude-tube.html`). The following screenshot shows this example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.TubeGeometry`创建沿着3D样条线挤出的管道。您可以使用一些顶点指定路径，`THREE.TubeGeometry`将创建管道。您可以在本章的源代码中找到一个可以尝试的示例（`04-extrude-tube.html`）。以下屏幕截图显示了这个示例：'
- en: '![THREE.TubeGeometry](graphics/2215OS_06_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.TubeGeometry](graphics/2215OS_06_04.jpg)'
- en: 'As you can see in this example, we generate a number of random points and use
    those points to draw the tube. With the controls in the upper-right corner, we
    can define how the tube looks or generate a new tube by clicking on the **newPoints**
    button. The code needed to create a tube is very simple, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这个例子中所看到的，我们生成了一些随机点，并使用这些点来绘制管道。通过右上角的控件，我们可以定义管道的外观，或者通过单击**newPoints**按钮生成新的管道。创建管道所需的代码非常简单，如下所示：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What we need to do first is get a set of vertices of the `THREE.Vector3` type
    just like we did for `THREE.ConvexGeometry` and `THREE.LatheGeometry`. Before
    we can use these points, however, to create the tube, we first need to convert
    these points to `THREE.SplineCurve3`. In other words, we need to define a smooth
    curve through the points we defined. We can do this simply by passing in the array
    of vertices to the constructor of `THREE.SplineCurve3`. With this spline and the
    other arguments (which we'll explain in a bit), we can create the tube and add
    it to the scene.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要获取一组`THREE.Vector3`类型的顶点，就像我们为`THREE.ConvexGeometry`和`THREE.LatheGeometry`所做的那样。然而，在我们可以使用这些点来创建管道之前，我们首先需要将这些点转换为`THREE.SplineCurve3`。换句话说，我们需要通过我们定义的点定义一个平滑的曲线。我们可以通过将顶点数组简单地传递给`THREE.SplineCurve3`的构造函数来实现这一点。有了这个样条和其他参数（我们稍后会解释），我们就可以创建管道并将其添加到场景中。
- en: '`THREE.TubeGeometry` takes some other arguments besides `THREE.SplineCurve3`.
    The following table lists all the arguments for `THREE.TubeGeometry`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.TubeGeometry`除了`THREE.SplineCurve3`之外还需要一些其他参数。下表列出了`THREE.TubeGeometry`的所有参数：'
- en: '| Property | Mandatory | Description |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 强制性 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `path` | Yes | This is `THREE.SplineCurve3` that describes the path this
    tube should follow. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `path` | 是 | 这是描述管道应该遵循的路径的`THREE.SplineCurve3`。|'
- en: '| `segments` | No | These are the segments used to build up the tube. The default
    value is `64`. The longer the path, the more segments you should specify. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `segments` | 否 | 这些是用于构建管道的段。默认值为`64`。路径越长，您应该指定的段数就越多。|'
- en: '| `radius` | No | This is the radius of the tube. The default value is `1`.
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `radius` | 否 | 这是管道的半径。默认值为`1`。|'
- en: '| `radiusSegments` | No | This is the number of segments to be used along the
    length of the tube. The default value is `8`. The more you use, the more *round*
    the tube will look. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `radiusSegments` | 否 | 这是沿着管道长度使用的段数。默认值为`8`。使用的越多，管道看起来就越*圆*。|'
- en: '| `closed` | No | If this is set to `true`, the start of the tube and the end
    will be connected together. The default value is `false`. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `closed` | 否 | 如果设置为`true`，管道的起点和终点将连接在一起。默认值为`false`。|'
- en: The last extrude example we'll show in this chapter isn't really a different
    geometry. In the next section, we'll show you how you can use `THREE.ExtrudeGeometry`
    to create extrusions from existing SVG paths.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中展示的最后一个挤出示例并不是真正不同的几何形状。在下一节中，我们将向您展示如何使用`THREE.ExtrudeGeometry`从现有的SVG路径创建挤出。
- en: Extrude from SVG
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从SVG挤出
- en: When we discussed `THREE.ShapeGeometry`, we mentioned that SVG follows pretty
    much the same approach of drawing shapes. SVG has a very close match with how
    Three.js handles shapes. In this section, we'll look at how you can use a small
    library from [https://github.com/asutherland/d3-threeD](https://github.com/asutherland/d3-threeD)
    to convert SVG paths to a Three.js shape.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论`THREE.ShapeGeometry`时，我们提到SVG基本上遵循绘制形状的相同方法。SVG与Three.js处理形状的方式非常接近。在本节中，我们将看看如何使用来自[https://github.com/asutherland/d3-threeD](https://github.com/asutherland/d3-threeD)的一个小库，将SVG路径转换为Three.js形状。
- en: 'For the `05-extrude-svg.html` example, I''ve taken an SVG drawing of the Batman
    logo and used `ExtrudeGeometry` to convert it to 3D, as shown in the following
    screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`05-extrude-svg.html`示例，我使用了蝙蝠侠标志的SVG图形，并使用`ExtrudeGeometry`将其转换为3D，如下面的屏幕截图所示：
- en: '![Extrude from SVG](graphics/2215OS_06_05.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![从SVG挤出](graphics/2215OS_06_05.jpg)'
- en: 'First, let''s look at what the original SVG code looks like (you can also see
    this for yourself when looking at the source code for this example):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看原始的SVG代码是什么样的（当您查看此示例的源代码时，也可以自行查看）：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Unless you're an SVG guru, this will probably mean nothing to you. Basically
    though, what you see here are a set of drawing instructions. For instance, `C
    277.987 119.348 279.673 116.786 279.673 115.867` tells the browser to draw a cubic
    Bezier curve, and `L 489.242 111.787` tells us that we should draw a line to that
    specific position. Luckily though, we won't have to write the code to interpret
    this ourselves. With the d3-threeD library, we can convert this automatically.
    This library was originally created to be used together with the excellent **D3.js**
    library, but with some small adaptions, we can also use this specific functionality
    standalone.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你是SVG大师，否则这对你来说可能毫无意义。但基本上，你在这里看到的是一组绘图指令。例如，`C 277.987 119.348 279.673 116.786
    279.673 115.867`告诉浏览器绘制三次贝塞尔曲线，而`L 489.242 111.787`告诉我们应该画一条线到特定位置。幸运的是，我们不必自己编写代码来解释这些。使用d3-threeD库，我们可以自动转换这些。这个库最初是为了与优秀的**D3.js**库一起使用而创建的，但通过一些小的调整，我们也可以单独使用这个特定的功能。
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**SVG** stands for **Scalable Vector Graphics**. This is an XML-based standard
    that can be used to create vector-based 2D images for the Web. This is an open
    standard that is supported by all of the modern browsers. Directly working with
    SVG and manipulating it from JavaScript, however, isn''t very straightforward.
    Luckily, there are a couple of open source JavaScript libraries that make working
    with SVG a lot easier. **Paper.js**, **Snap.js**, **D3.js**, and **Raphael.js**
    are some of the best.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**SVG**代表**可缩放矢量图形**。这是一种基于XML的标准，可用于创建Web的基于矢量的2D图像。这是一种开放标准，受到所有现代浏览器的支持。然而，直接使用SVG并从JavaScript进行操作并不是非常直接的。幸运的是，有几个开源的JavaScript库可以使处理SVG变得更加容易。**Paper.js**、**Snap.js**、**D3.js**和**Raphael.js**是其中一些最好的。'
- en: 'The following code fragment shows how we can load in the SVG you saw earlier,
    convert it to `THREE.ExtrudeGeometry`, and show it on screen:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了我们如何加载之前看到的SVG，将其转换为`THREE.ExtrudeGeometry`，并显示在屏幕上：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this code fragment, you''ll see a call to the `transformSVGPathExposed`
    function. This function is provided by the d3-threeD library and takes an SVG
    string as an argument. We get this SVG string directly from the SVG element with
    the following expression: `document.querySelector("#batman-path").getAttribute("d")`.
    In SVG, the `d` attribute contains the path statements used to draw a shape. Add
    a nice-looking shiny material and a spotlight and you''ve recreated this example.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，您将看到对`transformSVGPathExposed`函数的调用。此函数由d3-threeD库提供，并将SVG字符串作为参数。我们直接从SVG元素获取此SVG字符串，方法是使用以下表达式：`document.querySelector("#batman-path").getAttribute("d")`。在SVG中，`d`属性包含用于绘制形状的路径语句。添加一个漂亮的闪亮材质和聚光灯，您就重新创建了此示例。
- en: The last geometry we'll discuss in this section is `THREE.ParametricGeometry`.
    With this geometry, you can specify a couple of functions that are used to programmatically
    create geometries.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 本节我们将讨论的最后一个几何图形是`THREE.ParametricGeometry`。使用此几何图形，您可以指定一些用于以编程方式创建几何图形的函数。
- en: THREE.ParametricGeometry
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: THREE.ParametricGeometry
- en: 'With `THREE.ParametricGeometry`, you can create a geometry based on an equation.
    Before we dive into our own example, a good thing to start with is to look at
    the examples already provided by Three.js. When you download the Three.js distribution,
    you get the `examples/js/ParametricGeometries.js` file. In this file, you can
    find a couple of examples of equations you can use together with `THREE.ParametricGeometry`.
    The most basic example is the function to create a plane:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`THREE.ParametricGeometry`，您可以基于方程创建几何图形。在深入研究我们自己的示例之前，一个好的开始是查看Three.js已经提供的示例。下载Three.js分发时，您会得到`examples/js/ParametricGeometries.js`文件。在此文件中，您可以找到几个示例方程，您可以与`THREE.ParametricGeometry`一起使用。最基本的示例是创建平面的函数：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function is called by `THREE.ParametricGeometry`. The `u` and `v` values
    will range from `0` to `1` and will be called a large number of times for all
    the values from `0` to `1`. In this example, the `u` value is used to determine
    the *x* coordinate of the vector and the `v` value is used to determine the *z*
    coordinate. When this is run, you'll have a basic plane with a width of `width`
    and a depth of `depth`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数由`THREE.ParametricGeometry`调用。`u`和`v`值将从`0`到`1`范围，并且将针对从`0`到`1`的所有值调用大量次数。在此示例中，`u`值用于确定向量的*x*坐标，而`v`值用于确定*z*坐标。运行时，您将获得宽度为`width`和深度为`depth`的基本平面。
- en: 'In our example, we do something similar. However, instead of creating a flat
    plane, we create a wave-like pattern, as you can see in the `06-parametric-geometries.html`
    example. The following screenshot shows this example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们做了类似的事情。但是，我们不是创建一个平面，而是创建了一种波浪般的图案，就像您在`06-parametric-geometries.html`示例中看到的那样。以下屏幕截图显示了此示例：
- en: '![THREE.ParametricGeometry](graphics/2215OS_06_06.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![THREE.ParametricGeometry](graphics/2215OS_06_06.jpg)'
- en: 'To create this shape, we passed in the following function to `THREE.ParametricGeometry`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建此形状，我们将以下函数传递给`THREE.ParametricGeometry`：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see in this example, with a few lines of code, we can create really
    interesting geometries. In this example, you can also see the arguments we can
    pass in to `THREE.ParametricGeometry`. These are explained in the following table:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在此示例中所看到的，只需几行代码，我们就可以创建非常有趣的几何图形。在此示例中，您还可以看到我们可以传递给`THREE.ParametricGeometry`的参数。这些参数在下表中有解释：
- en: '| Property | Mandatory | Description |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 强制 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `function` | Yes | This is the function that defines the position of each
    vertex based on the `u` and `v` values provided |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `function` | 是 | 这是根据提供的`u`和`v`值定义每个顶点位置的函数 |'
- en: '| `slices` | Yes | This defines the number of parts the `u` value should be
    divided into |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `slices` | 是 | 这定义了应将`u`值分成的部分数 |'
- en: '| `stacks` | Yes | This defines the number of parts the `v` value should be
    divided into |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `stacks` | 是 | 这定义了应将`v`值分成的部分数 |'
- en: 'I''d like to make a final note on how to use the `slices` and `stacks` properties
    before moving on to the final part of this chapter. We mentioned that the `u`
    and `v` properties are passed in to the `function` argument provided, and that
    the values of these two properties range from `0` to `1`. With the `slices` and
    `stacks` properties, we can define how often the passed-in function is called.
    If, for instance, we set `slices` to `5` and `stacks` to `4`, the function will
    be called with the following values:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在转到本章的最后一部分之前，我想最后说明一下如何使用`slices`和`stacks`属性。我们提到`u`和`v`属性被传递给提供的`function`参数，并且这两个属性的值范围从`0`到`1`。使用`slices`和`stacks`属性，我们可以定义传入函数的调用频率。例如，如果我们将`slices`设置为`5`，`stacks`设置为`4`，则函数将使用以下值进行调用：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, the higher this value, the more vertices you get to specify and the smoother
    your created geometry will be. You can use the menu in the top-right corner of
    the `06-parametric-geometries.html` example to see this effect.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，此值越高，您就可以指定更多的顶点，并且创建的几何图形将更加平滑。您可以使用`06-parametric-geometries.html`示例右上角的菜单来查看此效果。
- en: 'For more examples, you can look at the `examples/js/ParametricGeometries.js`
    file in the Three.js distribution. This file contains functions to create the
    following geometries:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看更多示例，您可以查看Three.js分发中的`examples/js/ParametricGeometries.js`文件。该文件包含创建以下几何图形的函数：
- en: Klein bottle
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克莱因瓶
- en: Plane
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平面
- en: Flat mobius strip
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平坦的莫比乌斯带
- en: 3d mobius strip
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D莫比乌斯带
- en: Tube
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管
- en: Torus knot
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Torus knot
- en: Sphere
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球体
- en: The last part of this chapter deals with creating 3D text objects.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一部分涉及创建3D文本对象。
- en: Creating 3D text
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建3D文本
- en: In the last part of this chapter, we'll have a quick look at how you can create
    3D text effects. First, we'll look at how to render text using the fonts provided
    by Three.js, and after that, we'll have a quick look at how you can use your own
    fonts for this.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一部分，我们将快速了解如何创建3D文本效果。首先，我们将看看如何使用Three.js提供的字体来渲染文本，然后我们将快速了解如何使用自己的字体来实现这一点。
- en: Rendering text
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染文本
- en: 'Rendering text in Three.js is very easy. All you have to do is define the font
    you want to use and the basic extrude properties we saw when we discussed `THREE.ExtrudeGeometry`.
    The following screenshot shows the `07-text-geometry.html` example on how to render
    text in Three.js:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中渲染文本非常容易。你所要做的就是定义你想要使用的字体和我们在讨论`THREE.ExtrudeGeometry`时看到的基本挤出属性。以下截图显示了在Three.js中渲染文本的`07-text-geometry.html`示例：
- en: '![Rendering text](graphics/2215OS_06_07.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![渲染文本](graphics/2215OS_06_07.jpg)'
- en: 'The code required to create this 3D text is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这个3D文本所需的代码如下：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s look at all the options we can specify for `THREE.TextGeometry`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以为`THREE.TextGeometry`指定的所有选项：
- en: '| Property | Mandatory | Description |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 强制性 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `size` | No | This is the size of the text. The default value is `100`. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `size` | No | 这是文本的大小。默认值为`100`。'
- en: '| `height` | No | This is the length (depth) of the extrusion. The default
    value is `50`. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `height` | No | 这是挤出的长度（深度）。默认值为`50`。'
- en: '| `weight` | No | This is the weight of the font. The possible values are `normal`
    and `bold`. The default value is `normal`. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `weight` | No | 这是字体的粗细。可能的值是`normal`和`bold`。默认值是`normal`。'
- en: '| `font` | No | This is the name of the font to be used. The default value
    is `helvetiker`. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `font` | No | 这是要使用的字体的名称。默认值是`helvetiker`。'
- en: '| `style` | No | This is the weight of the font. The possible values are `normal`
    and `italic`. The default value is `normal`. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `style` | No | 这是字体的粗细。可能的值是`normal`和`italic`。默认值是`normal`。'
- en: '| `bevelThickness` | No | This is the depth of the bevel. The bevel is the
    rounded corner between the front and back faces and the extrusion. The default
    value is `10`. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `bevelThickness` | No | 这是斜角的深度。斜角是正面和背面以及挤出之间的圆角。默认值为`10`。'
- en: '| `bevelSize` | No | This is the height of the bevel. The default value is
    `8`. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `bevelSize` | No | 这是斜角的高度。默认值为`8`。'
- en: '| `bevelSegments` | No | This defines the number of segments that will be used
    by the bevel. The more segments there are, the smoother the bevel will look. The
    default value is `3`. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `bevelSegments` | No | 这定义了斜角使用的段数。段数越多，斜角看起来越平滑。默认值为`3`。'
- en: '| `bevelEnabled` | No | If this is set to `true`, a bevel is added. The default
    value is `false`. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `bevelEnabled` | No | 如果设置为`true`，则添加斜角。默认值为`false`。'
- en: '| `curveSegments` | No | This defines the number segments used when extruding
    the curves of shapes. The more segments there are, the smoother the curves will
    look. The default value is `4`. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `curveSegments` | No | 这定义了在挤出形状的曲线时使用的段数。段数越多，曲线看起来越平滑。默认值为`4`。'
- en: '| `steps` | No | This defines the number of segments the extrusion will be
    divided into. The default value is `1`. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '`steps` | No | 这定义了挤出物将被分成的段数。默认值为`1`。'
- en: '| `extrudePath` | No | This is the path along which the shape should be extruded.
    If this isn''t specified, the shape is extruded along the *z* axis. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `extrudePath` | No | 这是形状应该沿着的路径。如果没有指定，形状将沿着*z*轴挤出。'
- en: '| `material` | No | This is the index of the material to be used for the front
    and back faces. Use the `THREE.SceneUtils.createMultiMaterialObject` function
    to create the mesh. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `material` | No | 这是要用于正面和背面的材质的索引。使用`THREE.SceneUtils.createMultiMaterialObject`函数来创建网格。'
- en: '| `extrudeMaterial` | No | This is the index of the material to be used for
    the bevel and the extrusion. Use the `THREE.SceneUtils.createMultiMaterialObject`
    function to create the mesh. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `extrudeMaterial` | No | 这是用于斜角和挤出的材质的索引。使用`THREE.SceneUtils.createMultiMaterialObject`函数来创建网格。'
- en: '| `uvGenerator` | No | When you use a texture with your material, the UV mapping
    determines what part of a texture is used for a specific face. With the `UVGenerator`
    property, you can pass in your own object that will create the UV settings for
    the faces that are created for the passed-in shapes. More information on UV settings
    can be found in [Chapter 10](ch10.html "Chapter 10. Loading and Working with Textures"),
    *Loading and Working with Textures*. If none are specified, `THREE.ExtrudeGeometry.WorldUVGenerator`
    is used. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `uvGenerator` | No | 当你在材质中使用纹理时，UV映射决定了纹理的哪一部分用于特定的面。使用`UVGenerator`属性，你可以传入自己的对象，用于为传入的形状创建面的UV设置。有关UV设置的更多信息可以在[第10章](ch10.html
    "第10章。加载和使用纹理")中找到，*加载和使用纹理*。如果没有指定，将使用`THREE.ExtrudeGeometry.WorldUVGenerator`。'
- en: '| `frames` | No | A frenet frame is used to calculate the tangents, normal,
    and binormals of a spline. This is used when extruding along `extrudePath`. You
    don''t need to specify this because Three.js provides its own implementation,
    `THREE.TubeGeometry.FrenetFrames`, which is also used as default. More information
    on frenet frames can be found at [http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame](http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame).
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `frames` | No | 弗雷内框架用于计算样条的切线、法线和副法线。这在沿着`extrudePath`挤出时使用。你不需要指定这个，因为Three.js提供了自己的实现，`THREE.TubeGeometry.FrenetFrames`，它也被用作默认值。有关弗雷内框架的更多信息可以在[http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame](http://en.wikipedia.org/wiki/Differential_geometry_of_curves#Frenet_frame)找到。'
- en: The fonts that are included in Three.js are also added to the sources for this
    book. You can find them in the `assets/fonts` folder.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js中包含的字体也被添加到了本书的资源中。你可以在`assets/fonts`文件夹中找到它们。
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to render fonts in 2D, for instance, to use them as a texture for
    a material, you shouldn't use `THREE.TextGeometry`. `THREE.TextGeometry`, which
    internally uses `THREE.ExtrudeGeometry` to build the 3D text, and the JavaScript
    fonts introduce a lot of overhead. Rendering a simple 2D font is better than just
    using the HTML5 canvas. With `context.font`, you can set the font to be used,
    and with `context.fillText`, you can output text to the canvas. You can then use
    this canvas as input for your texture. We will show you how to do this in [Chapter
    10](ch10.html "Chapter 10. Loading and Working with Textures"), *Loading and Working
    with Textures*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在2D中渲染字体，例如将它们用作材质的纹理，你不应该使用`THREE.TextGeometry`。`THREE.TextGeometry`内部使用`THREE.ExtrudeGeometry`来构建3D文本，而JavaScript字体引入了很多开销。渲染简单的2D字体比仅仅使用HTML5画布更好。使用`context.font`，你可以设置要使用的字体，使用`context.fillText`，你可以将文本输出到画布上。然后你可以使用这个画布作为纹理的输入。我们将在[第10章](ch10.html
    "第10章。加载和使用纹理")*加载和使用纹理*中向你展示如何做到这一点。
- en: It's also possible to use other fonts with this geometry, but you first need
    to convert them to JavaScript. How to do this is shown in the next section.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用其他字体与这个几何图形，但是你首先需要将它们转换为JavaScript。如何做到这一点将在下一节中展示。
- en: Adding custom fonts
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加自定义字体
- en: There are a couple of fonts provided by Three.js that you can use in your scenes.
    These fonts are based on the fonts provided by **typeface.js** ([http://typeface.neocracy.org:81/](http://typeface.neocracy.org:81/)).
    Typeface.js is a library that can convert TrueType and OpenType fonts to JavaScript.
    The resulting JavaScript file can be included in your page, and the font can then
    be used in Three.js.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js提供了一些字体，你可以在场景中使用。这些字体基于**typeface.js**提供的字体（[http://typeface.neocracy.org:81/](http://typeface.neocracy.org:81/)）。Typeface.js是一个可以将TrueType和OpenType字体转换为JavaScript的库。生成的JavaScript文件可以包含在你的页面中，然后可以在Three.js中使用该字体。
- en: To convert an existing OpenType or TrueType font, you can use the web page at
    [http://typeface.neocracy.org:81/fonts.html](http://typeface.neocracy.org:81/fonts.html).
    On this page, you can upload a font, and it will be converted to JavaScript for
    you. Note that this doesn't work for all types of fonts. The simpler the font
    (more straight lines), the better the chance is that it will be rendered correctly
    when used in Three.js.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要转换现有的OpenType或TrueType字体，可以使用[http://typeface.neocracy.org:81/fonts.html](http://typeface.neocracy.org:81/fonts.html)上的网页。在这个页面上，你可以上传一个字体，它将被转换为JavaScript。请注意，这并不适用于所有类型的字体。字体越简单（更直线），在Three.js中使用时渲染正确的机会就越大。
- en: 'To include that font, just add the following line at the top of your HTML page:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含该字体，只需在你的HTML页面顶部添加以下行：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will load the font and make it available to Three.js. If you want to know
    the name of the font (to use with the `font` property), you can print out the
    font cache to the console using the following line of JavaScript:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载字体并使其可用于Three.js。如果你想知道字体的名称（用于`font`属性），你可以使用以下一行JavaScript代码将字体缓存打印到控制台上：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will print out something like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出类似以下的内容：
- en: '![Adding custom fonts](graphics/2215OS_06_08.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![添加自定义字体](graphics/2215OS_06_08.jpg)'
- en: 'Here, you can see that we can use the `helvetiker` font with `weight` as `either
    bold` or `normal`, and the `bitstream vera sans mono` font with `weight` as `normal`.
    Note that each font weight comes in its separate JavaScript file and needs to
    be loaded separately. An alternative way of determining the font name is by looking
    at the JavaScript source file for the font. At the end of the file, you''ll find
    a property with the name `familyName` as shown in the following code. This property
    also contains the name of the font:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们可以使用`helvetiker`字体，`weight`为`bold`或`normal`，以及`bitstream vera sans
    mono`字体，`weight`为`normal`。请注意，每种字体重量都有单独的JavaScript文件，并且需要单独加载。确定字体名称的另一种方法是查看字体的JavaScript源文件。在文件的末尾，你会找到一个名为`familyName`的属性，如下面的代码所示。这个属性也包含了字体的名称：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the next part of this chapter, we''ll introduce the ThreeBSP library to
    create very interesting-looking geometries using the binary operations: `intersect`,
    `subtract`, and `union`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一部分中，我们将介绍ThreeBSP库，使用二进制操作`intersect`、`subtract`和`union`创建非常有趣的几何图形。
- en: Using binary operations to combine meshes
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用二进制操作来合并网格
- en: 'In this section, we''ll look at a different way of creating geometries. In
    this chapter, so far, and in the previous chapter, we used the default geometries
    provided by Three.js to create interesting-looking geometries. With the default
    set of properties, you can create beautiful models, but you are limited to what
    Three.js provides. In this section, we''ll show you how you can combine these
    standard geometries to create new ones—a technique known as **Constructive Solid
    Geometry** (**CSG**) To do this, we use the Three.js extension ThreeBSP, which
    you can find online at [https://github.com/skalnik/ThreeBSP](https://github.com/skalnik/ThreeBSP).
    This additional library provides the following three functions:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一种不同的创建几何图形的方法。到目前为止，在本章和上一章中，我们使用了Three.js提供的默认几何图形来创建有趣的几何图形。使用默认属性集，你可以创建美丽的模型，但是你受限于Three.js提供的内容。在本节中，我们将向你展示如何组合这些标准几何图形来创建新的几何图形——一种称为**构造实体几何**（**CSG**）的技术。为此，我们使用了Three.js扩展ThreeBSP，你可以在[https://github.com/skalnik/ThreeBSP](https://github.com/skalnik/ThreeBSP)上找到。这个额外的库提供了以下三个函数：
- en: '| Name | Description |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `intersect` | This function allows you to create a new geometry based on
    the intersection of two existing geometries. The area where both geometries overlap
    will define the shape of this new geometry. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `intersect` | 此函数允许你基于两个现有几何图形的交集创建一个新的几何图形。两个几何图形重叠的区域将定义这个新几何图形的形状。 |'
- en: '| `union` | The union function can be used to combine two geometries and create
    a new one. You can compare this with the `mergeGeometry` functionality we''ll
    look at in [Chapter 8](ch08.html "Chapter 8. Creating and Loading Advanced Meshes
    and Geometries"), *Creating and Loading Advanced Meshes and Geometries*. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `union` | union函数可用于合并两个几何体并创建一个新的几何体。您可以将其与我们将在[第8章](ch08.html "第8章。创建和加载高级网格和几何体")中查看的`mergeGeometry`功能进行比较，*创建和加载高级网格和几何体*。'
- en: '| `subtract` | The subtract function is the opposite of the union function.
    You can create a new geometry by removing the overlapping area from the first
    geometry. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `subtract` | 减法函数是union函数的相反。您可以通过从第一个几何体中去除重叠区域来创建一个新的几何体。'
- en: In the following sections, we'll look at each of these functions in more detail.
    The following screenshot shows an example of what you can create by just using
    the `union` and `subtract` functionalities one after the other.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将更详细地查看每个函数。以下截图显示了仅使用`union`和`subtract`功能后可以创建的示例。
- en: '![Using binary operations to combine meshes](graphics/2215OS_06_09.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![使用二进制操作合并网格](graphics/2215OS_06_09.jpg)'
- en: 'To use this library, we need to include it in our page. This library is written
    in CoffeeScript, a more user-friendly variant of JavaScript. To get this working,
    we have two options. We can add the CoffeeScript file and compile it on the fly,
    or we can precompile it to JavaScript and include it directly. For the first approach,
    we need to do the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个库，我们需要在页面中包含它。这个库是用CoffeeScript编写的，这是JavaScript的一个更用户友好的变体。要使其工作，我们有两个选项。我们可以添加CoffeeScript文件并即时编译它，或者我们可以预编译为JavaScript并直接包含它。对于第一种方法，我们需要执行以下操作：
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `ThreeBSP.coffee` file contains the functionality we need for this example,
    and `coffee-script.js` can interpret the Coffee language used for ThreeBSP. A
    final step we need to take is make sure the `ThreeBSP.coffee` file has been parsed
    completely before we start using the ThreeBSP functionality. For this, we add
    the following to the bottom of the file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreeBSP.coffee`文件包含了我们在这个示例中需要的功能，`coffee-script.js`可以解释用于ThreeBSP的Coffee语言。我们需要采取的最后一步是确保`ThreeBSP.coffee`文件在我们开始使用ThreeBSP功能之前已经被完全解析。为此，我们在文件底部添加以下内容：'
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We rename our initial `onload` function to `onReady` like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将初始的`onload`函数重命名为`onReady`，如下所示：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we precompile CoffeeScript to JavaScript using the CoffeeScript command-line
    tool, we can include the resulting JavaScript file directly. Before we can do
    this, though, we need to install CoffeeScript. You can follow the installation
    instructions on the CoffeeScript website at [http://coffeescript.org/](http://coffeescript.org/).
    Once you''ve installed CoffeeScript, you can use the following command line to
    convert the CoffeeScript ThreeBSP file to JavaScript:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用CoffeeScript命令行工具将CoffeeScript预编译为JavaScript，我们可以直接包含生成的JavaScript文件。不过，在这之前，我们需要安装CoffeeScript。您可以在CoffeeScript网站上按照安装说明进行安装[http://coffeescript.org/](http://coffeescript.org/)。安装完CoffeeScript后，您可以使用以下命令行将CoffeeScript
    ThreeBSP文件转换为JavaScript：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This command creates a `ThreeBSP.js` file that we can include in our example
    just as we do with the other JavaScript file. In our examples, we use this second
    approach because it''ll load quicker than compiling the CoffeeScript each time
    we load the page. For this, all we need to do is add the following to the top
    of our HTML page:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令创建了一个`ThreeBSP.js`文件，我们可以像其他JavaScript文件一样在我们的示例中包含它。在我们的示例中，我们使用了第二种方法，因为它比每次加载页面时编译CoffeeScript要快。为此，我们只需要在我们的HTML页面顶部添加以下内容：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that the ThreeBSP library is loaded, we can use the functions it provides.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在ThreeBSP库已加载，我们可以使用它提供的功能。
- en: The subtract function
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减法函数
- en: Before we start with the `subtract` function, there is one important step you
    need to keep in mind. These three functions use the absolute position of the mesh
    for calculations. So, if you group meshes together or use multiple materials before
    applying these functions, you'll probably get strange results. For the best and
    most predictable result, make sure you're working with ungrouped meshes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用`subtract`函数之前，有一个重要的步骤需要记住。这三个函数使用网格的绝对位置进行计算。因此，如果您在应用这些函数之前将网格分组在一起或使用多个材质，可能会得到奇怪的结果。为了获得最佳和最可预测的结果，请确保您正在使用未分组的网格。
- en: 'Let''s start by demonstrating the `subtract` functionality. For this, we''ve
    provided an example, `08-binary-operations.html`. With this example, you can experiment
    with the three operations. When you first open the example on binary operations,
    you''ll see something like the following start screen:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先演示“减法”功能。为此，我们提供了一个示例“08-binary-operations.html”。通过这个示例，您可以尝试这三种操作。当您首次打开二进制操作示例时，您会看到以下启动屏幕：
- en: '![The subtract function](graphics/2215OS_06_10.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![减法功能](graphics/2215OS_06_10.jpg)'
- en: 'There are three wireframes: a cube and two spheres. **Sphere1**, the center
    sphere, is the object on which all operations are executed, **Sphere2** is on
    the right-hand side, and **Cube** is on the left-hand side. On **Sphere2** and
    **Cube**, you can define one of four actions: **subtract**, **union**, **intersect**,
    and **none**. These actions are applied from the point of view of **Sphere1**.
    When we set **Sphere2** to subtract and select **showResult** (and hide the wireframes),
    the result will show **Sphere1** minus the area where **Sphere1** and **Sphere2**
    overlap. Note that a few of these operations might take a couple of seconds to
    complete after you''ve pushed the **showResult** button, so be patient while the
    *busy* indicator is visible.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个线框：一个立方体和两个球体。**Sphere1**，中心球体，是执行所有操作的对象，**Sphere2**位于右侧，**Cube**位于左侧。在**Sphere2**和**Cube**上，您可以定义四种操作之一：**subtract**，**union**，**intersect**和**none**。这些操作是从**Sphere1**的视角应用的。当我们将**Sphere2**设置为subtract并选择**showResult**（并隐藏线框）时，结果将显示**Sphere1**减去**Sphere1**和**Sphere2**重叠的区域。请注意，这些操作中的一些可能需要几秒钟才能在您按下**showResult**按钮后完成，因此在*busy*指示器可见时请耐心等待。
- en: 'The following screenshot shows the result action of a sphere after subtracting
    another sphere:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了减去另一个球体后的球体的结果动作：
- en: '![The subtract function](graphics/2215OS_06_11.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![减去函数](graphics/2215OS_06_11.jpg)'
- en: 'In this example, first the action defined for **Sphere2** is executed, and
    next, the action for **Cube** is executed. So, if we subtract both **Sphere2**
    and **Cube** (which we scale a bit along the *x* axis), we get the following result:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，首先执行了“Sphere2”定义的操作，然后执行了“Cube”的操作。因此，如果我们减去“Sphere2”和“Cube”（我们沿着x轴稍微缩放），我们会得到以下结果：
- en: '![The subtract function](graphics/2215OS_06_12.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![减去函数](graphics/2215OS_06_12.jpg)'
- en: 'The best way to understand the `subtract` functionality is to just play around
    with the example. The ThreeBSP code to accomplish this is very simple and, in
    this example, is implemented in the `redrawResult` function, which we call whenever
    the **showResult** button from the example is clicked on:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 理解“减去”功能的最佳方法就是玩弄一下示例。在这个示例中，ThreeBSP代码非常简单，并且在“redrawResult”函数中实现，我们在示例中点击“showResult”按钮时调用该函数：
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first thing we do in this code is wrap our meshes (the wireframes you can
    see) in a `ThreeBSP` object. This allows us to apply the `subtract`, `intersect`,
    and `union` functions on these objects. Now, we can just call the specific function
    we want on the `ThreeBSP` object wrapped around the center sphere (`sphere1BSP`),
    and the result from this function will contain all the information we need to
    create a new mesh. To create this mesh, we just call the `toMesh()` function on
    the `sphere1BSP` object. On the resulting object, we have to make sure that all
    the normals are computed correctly by first calling `computeFaceNormals` and then
    calling `computeVertexNormals()`. These compute functions need to be called since
    by running one of the binary operations, the vertices and faces of the geometry
    are changed and this affects the normals of the faces. Explicitly recalculating
    them will make sure your new object is shaded smoothly (when shading on the material
    has been set to `THREE.SmoothShading`) and rendered correctly. Finally, we add
    the result to the scene.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们首先将我们的网格（你可以看到的线框）包装在一个“ThreeBSP”对象中。这使我们能够在这些对象上应用“减去”、“交集”和“联合”功能。现在，我们可以在包装在中心球体周围的“ThreeBSP”对象上调用我们想要的特定功能，这个函数的结果将包含我们创建新网格所需的所有信息。要创建这个网格，我们只需在“sphere1BSP”对象上调用“toMesh()”函数。在结果对象上，我们必须确保所有的法线都通过首先调用“computeFaceNormals”然后调用“computeVertexNormals()”来正确计算。这些计算函数需要被调用，因为通过运行二进制操作之一，几何体的顶点和面会发生变化，这会影响面的法线。显式地重新计算它们将确保你的新对象被平滑地着色（当材质上的着色设置为“THREE.SmoothShading”时）并正确渲染。最后，我们将结果添加到场景中。
- en: For `intersect` and `union`, we use exactly the same approach.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“交集”和“联合”，我们使用完全相同的方法。
- en: The intersect function
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交集函数
- en: 'With everything we explained in the previous section, there isn''t much left
    to explain for the `intersect` function. With this function, only the part of
    the meshes that overlap is left. The following screenshot is an example where
    both the sphere and the cube are set to intersect:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中我们解释的一切，对于“交集”功能来说并没有太多需要解释的了。使用这个功能，只有重叠的部分是留下来的网格。下面的截图是一个示例，其中球体和立方体都设置为相交：
- en: '![The intersect function](graphics/2215OS_06_13.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![交集函数](graphics/2215OS_06_13.jpg)'
- en: If you look at the example and play around with the settings, you'll see that
    it's very easy to create these kinds of objects. And remember, this can be applied
    to every mesh you can create, even the complex ones we saw in this chapter, such
    as `THREE.ParametricGeometry` and `THREE.TextGeometry`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下示例并玩弄一下设置，你会发现很容易创建这些类型的对象。记住，这可以应用于你可以创建的每一个网格，甚至是我们在本章中看到的复杂网格，比如“THREE.ParametricGeometry”和“THREE.TextGeometry”。
- en: 'The `subtract` and `intersect` functions work great together. The example we
    showed at the beginning of this section was created by first subtracting a smaller
    sphere to create a hollow sphere. After that, we used the cube to intersect with
    this hollow sphere to get the following result (a hollow cube with rounded corners):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: “减去”和“交集”功能一起运行得很好。我们在本节开头展示的示例是通过首先减去一个较小的球体来创建一个空心球体。之后，我们使用立方体与这个空心球体相交，得到以下结果（带有圆角的空心立方体）：
- en: '![The intersect function](graphics/2215OS_06_14.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![交集函数](graphics/2215OS_06_14.jpg)'
- en: The last function provided by ThreeBSP is the `union` function.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ThreeBSP提供的最后一个功能是“联合”功能。
- en: The union function
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联合函数
- en: 'The final function is the least interesting one of those offered by ThreeBSP.
    With this function, we can combine two meshes together to create a new one. So,
    when we apply this to the two spheres and the cube, we''ll get a single object—a
    result of the union function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ThreeBSP提供的最后一个功能是最不有趣的。使用这个功能，我们可以将两个网格组合在一起创建一个新的网格。因此，当我们将这个应用于两个球体和立方体时，我们将得到一个单一的对象——联合函数的结果：
- en: '![The union function](graphics/2215OS_06_15.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![联合函数](graphics/2215OS_06_15.jpg)'
- en: This is not really that useful because this functionality is also provided by
    Three.js (see [Chapter 8](ch08.html "Chapter 8. Creating and Loading Advanced
    Meshes and Geometries"), *Creating and Loading Advanced Meshes and Geometries*,
    where we explain how to use `THREE.Geometry.merge`), which also offers slightly
    better performance. If you enable rotation, you can see that this union is applied
    from the perspective of the center sphere since it is rotating around the center
    of that sphere. The same applies to the other two operations.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是真的很有用，因为Three.js也提供了这个功能（参见[第8章](ch08.html "第8章。创建和加载高级网格和几何体")，“创建和加载高级网格和几何体”，在那里我们解释了如何使用“THREE.Geometry.merge”），而且性能稍微更好。如果启用旋转，你会发现这个联合是从中心球体的角度应用的，因为它是围绕那个球体的中心旋转的。其他两个操作也是一样的。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We saw a lot in this chapter. We introduced a couple of advanced geometries
    and even showed you how you can create interesting-looking geometries using a
    couple of simple binary operations. We showed you how you can create really beautiful
    shapes using advanced geometries such as `THREE.ConvexGeometry`, `THREE.TubeGeometry`,
    and `THREE.LatheGeometry` and experiment with these geometries to get the results
    you're looking for. A very nice feature is that we can also convert existing SVG
    paths to Three.js. Remember, though, that you still might need to fine-tune the
    paths using tools such as GIMP, Adobe Illustrator, or Inkscape.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了很多内容。我们介绍了一些高级几何图形，甚至向你展示了如何使用一些简单的二进制操作来创建有趣的几何图形。我们向你展示了如何使用高级几何图形，比如`THREE.ConvexGeometry`、`THREE.TubeGeometry`和`THREE.LatheGeometry`来创建非常漂亮的形状，并且可以尝试这些几何图形来获得你想要的结果。一个非常好的特性是，我们还可以将现有的SVG路径转换为Three.js。不过，请记住，你可能仍然需要使用诸如GIMP、Adobe
    Illustrator或Inkscape等工具来微调路径。
- en: 'If you want to create 3D text, you need to specify the font to use. Three.js
    comes with a couple of fonts you can use, but you can also create your own fonts.
    However, remember that complex fonts often won''t convert correctly. And finally,
    with ThreeBSP, you have access to three binary operations you can apply to your
    mesh: union, subtract, and intersect. With union, you combine two meshes together;
    with subtract, you remove the overlapping part of the meshes from the source mesh;
    and with intersect, only the overlapping part is kept.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建3D文本，你需要指定要使用的字体。Three.js自带了一些你可以使用的字体，但你也可以创建自己的字体。然而，请记住，复杂的字体通常不会正确转换。最后，使用ThreeBSP，你可以访问三种二进制操作，可以应用到你的网格上：联合、减去和相交。使用联合，你可以将两个网格组合在一起；使用减去，你可以从源网格中移除重叠部分的网格；使用相交，只有重叠部分被保留。
- en: Until now, we looked at solid (or wireframe) geometries, where vertices are
    connected to each other to form faces. In the following chapter, we'll look at
    an alternative way of visualizing geometries using something called particles.
    With particles, we don't render complete geometries—we just render the vertices
    as points in space. This allows you to create great-looking 3D effects that perform
    well.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到了实体（或线框）几何图形，其中顶点相互连接形成面。在接下来的章节中，我们将看一种用称为粒子的东西来可视化几何图形的替代方法。使用粒子，我们不渲染完整的几何图形——我们只将顶点渲染为空间中的点。这使你能够创建外观出色且性能良好的3D效果。

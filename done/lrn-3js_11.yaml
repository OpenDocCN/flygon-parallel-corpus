- en: Chapter 11. Custom Shaders and Render Postprocessing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章. 自定义着色器和渲染后期处理
- en: 'We''re getting to the end of the book, and in this chapter, we''ll look at
    the one main feature of Three.js we haven''t touched upon: render postprocessing.
    Besides that, in this chapter, we''ll also introduce you to how you can create
    custom shaders. The main points we''ll discuss in this chapter are the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将结束这本书，在本章中，我们将看一下我们尚未涉及的Three.js的主要特性：渲染后期处理。除此之外，在本章中，我们还将介绍如何创建自定义着色器。本章我们将讨论的主要内容如下：
- en: Setting up Three.js for postprocessing
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为后期处理设置Three.js
- en: Discussing the basic postprocessing passes provided by Three.js, such as `THREE.BloomPass`
    and `THREE.FilmPass`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论Three.js提供的基本后期处理通道，比如`THREE.BloomPass`和`THREE.FilmPass`
- en: Applying effects to part of the scene using masks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用蒙版将效果应用于场景的一部分
- en: Using `THREE.TexturePass` to store rendering results
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`THREE.TexturePass`来存储渲染结果
- en: Using `THREE.ShaderPass` to add even more basic postprocessing effects, such
    as sepia filters, mirror effects, and color adjustments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`THREE.ShaderPass`添加更基本的后期处理效果，比如棕褐色滤镜，镜像效果和颜色调整
- en: Using `THREE.ShaderPass` for various blurring effects and more advanced filters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`THREE.ShaderPass`进行各种模糊效果和更高级的滤镜
- en: Creating a custom postprocessing effect by writing a simple shader
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过编写一个简单的着色器创建自定义后期处理效果
- en: In the *Introducing requestAnimationFrame* section of [Chapter 1](ch01.html
    "Chapter 1. Creating Your First 3D Scene with Three.js"), *Creating Your First
    3D Scene with Three.js*, we set up a rendering loop that we've used throughout
    the book to render and animate our scene. For postprocessing, we need to make
    a couple of changes to this setup to allow Three.js to postprocess the final rendering.
    In the first section, we'll look at how to do this.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 使用Three.js创建您的第一个3D场景")的*介绍requestAnimationFrame*部分，*使用Three.js创建您的第一个3D场景*，我们设置了一个渲染循环，我们在整本书中都用来渲染和动画我们的场景。对于后期处理，我们需要对这个设置进行一些更改，以允许Three.js对最终渲染进行后期处理。在第一部分中，我们将看看如何做到这一点。
- en: Setting up Three.js for postprocessing
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为后期处理设置Three.js
- en: 'To set up Three.js for postprocessing, we need to make a couple of changes
    in our current setup. We need to take the following steps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为后期处理设置Three.js，我们需要对我们当前的设置进行一些更改。我们需要采取以下步骤：
- en: Create `THREE.EffectComposer`, which we can use to add postprocessing passes.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`THREE.EffectComposer`，我们可以用来添加后期处理通道。
- en: Configure `THREE.EffectComposer` so that it renders our scene and applies any
    additional postprocessing steps.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`THREE.EffectComposer`，使其渲染我们的场景并应用任何额外的后期处理步骤。
- en: In the render loop, use `THREE.EffectComposer` to render the scene, apply the
    passes, and show the output.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染循环中，使用`THREE.EffectComposer`来渲染场景，应用通道，并显示输出。
- en: 'As always, we have an example that you can use to experiment with and adopt
    for your own uses. The first example for this chapter can be accessed from `01-basic-effect-composer.html`.
    You can use the menu in the top-right corner to modify the properties of the postprocessing
    step used in this example. In this example, we render a simple globe and add an
    old-television-like effect to it. This television effect is added after the scene
    is rendered using `THREE.EffectComposer`. The following screenshot shows this
    example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们有一个可以用来实验并用于自己用途的例子。本章的第一个例子可以从`01-basic-effect-composer.html`中访问。您可以使用右上角的菜单修改此示例中使用的后期处理步骤的属性。在这个例子中，我们渲染了一个简单的地球，并为其添加了类似旧电视的效果。这个电视效果是在使用`THREE.EffectComposer`渲染场景之后添加的。以下截图显示了这个例子：
- en: '![Setting up Three.js for postprocessing](graphics/2215OS_11_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![为后期处理设置Three.js](graphics/2215OS_11_01.jpg)'
- en: Creating THREE.EffectComposer
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建THREE.EffectComposer
- en: Let's first look at the additional JavaScript files you need to include. These
    files can be found in the Three.js distribution in the `examples/js/postprocessing`
    and `examples/js/shaders` directories.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下您需要包含的额外JavaScript文件。这些文件可以在Three.js分发的`examples/js/postprocessing`和`examples/js/shaders`目录中找到。
- en: 'The minimal setup you need to get `THREE.EffectComposer` working is the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使`THREE.EffectComposer`工作所需的最小设置如下：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `EffectComposer.js` file provides the `THREE.EffectComposer` object that
    allows us to add postprocessing steps. `MaskPass.js`, `ShaderPass.js`, and `CopyShader.js`
    are used internally by `THREE.EffectComposer`, and `RenderPass.js` allows us to
    add a rendering pass to `THREE.EffectComposer`. Without that pass, our scene won't
    be rendered at all.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`EffectComposer.js`文件提供了`THREE.EffectComposer`对象，允许我们添加后期处理步骤。`MaskPass.js`，`ShaderPass.js`和`CopyShader.js`在`THREE.EffectComposer`内部使用，`RenderPass.js`允许我们向`THREE.EffectComposer`添加渲染通道。没有这个通道，我们的场景将根本不会被渲染。'
- en: 'For this example, we add two additional JavaScript files to add a film-like
    effect to our scene:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们添加了两个额外的JavaScript文件，为我们的场景添加了类似电影的效果：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first thing we need to do is create `THREE.EffectComposer`. You can do
    this by passing in `THREE.WebGLRenderer` to its constructor:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建`THREE.EffectComposer`。您可以通过将`THREE.WebGLRenderer`传递给它的构造函数来实现：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we add various *passes* to this composer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们向这个合成器添加各种*通道*。
- en: Configuring THREE.EffectComposer for postprocessing
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为后期处理配置THREE.EffectComposer
- en: 'Each pass is executed in the sequence it is added to `THREE.EffectComposer`.
    The first pass we add is `THREE.RenderPass`. The following pass renders our scene
    but doesn''t output it to the screen yet:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个通道按照添加到`THREE.EffectComposer`的顺序执行。我们添加的第一个通道是`THREE.RenderPass`。接下来的通道渲染了我们的场景，但还没有输出到屏幕上：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To create `THREE.RenderPass`, we pass in the scene we want to render and the
    camera that we want to use. With the `addPass` function, we add `THREE.RenderPass`
    to `THREE.EffectComposer`. The next step is to add another pass that will output
    its result to the screen. Not all the available passes allow this—more on that
    later—but `THREE.FilmPass`, which is used in this example, allows us to output
    the result of its pass to the screen. To add `THREE.FilmPass`, we first need to
    create it and add it to the composer. The resulting code looks like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`THREE.RenderPass`，我们传入要渲染的场景和要使用的相机。使用`addPass`函数，我们将`THREE.RenderPass`添加到`THREE.EffectComposer`中。下一步是添加另一个通行证，将其结果输出到屏幕上。并非所有可用的通行证都允许这样做——稍后会详细介绍——但是在这个例子中使用的`THREE.FilmPass`允许我们将其通行证的结果输出到屏幕上。要添加`THREE.FilmPass`，我们首先需要创建它并将其添加到composer中。生成的代码如下：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, we created `THREE.FilmPass` and set the `renderToScreen` property
    to `true`. This pass is added to `THREE.EffectComposer` after `renderPass,` so
    when this composer is used, first the scene is rendered, and through `THREE.FilmPass`,
    we can also see the output on screen.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们创建了`THREE.FilmPass`并将`renderToScreen`属性设置为`true`。这个通行证被添加到`THREE.EffectComposer`之后的`renderPass`之后，所以当使用这个composer时，首先渲染场景，通过`THREE.FilmPass`，我们也可以在屏幕上看到输出。
- en: Updating the render loop
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新渲染循环
- en: 'Now we just need to make a small modification to our render loop to use the
    composer instead of `THREE.WebGLRenderer`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要对渲染循环进行一点修改，以使用composer而不是`THREE.WebGLRenderer`：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The only modification we made is we removed `webGLRenderer.render(scene, camera)`
    and replaced it with `composer.render(delta)`. This will call the render function
    on `EffectComposer`, which in turn uses the passed-in `THREE. WebGLRenderer`,
    and since we set `renderToScreen` of `FilmPass` to `true`, the result from `FilmPass`
    is shown on screen.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一的修改是删除了`webGLRenderer.render(scene, camera)`，并用`composer.render(delta)`替换它。这将在`EffectComposer`上调用渲染函数，而`EffectComposer`又使用传入的`THREE.WebGLRenderer`，由于我们将`FilmPass`的`renderToScreen`设置为`true`，因此`FilmPass`的结果显示在屏幕上。
- en: With this basic setup, we'll look at the available postprocessing passes in
    the next couple of sections.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个基本设置，我们将在接下来的几节中看看可用的后期处理通行证。
- en: Postprocessing passes
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后期处理通行证
- en: 'Three.js comes with a number of postprocessing passes you can use directly
    with `THREE.EffectComposer`. Note that it''s best to play around with the examples
    in this chapter to see the result of these passes and understand what is happening.
    The following table gives an overview of the passes that are available:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js提供了许多后期处理通行证，您可以直接在`THREE.EffectComposer`中使用。请注意，最好尝试本章中的示例，以查看这些通行证的结果并理解发生了什么。以下表格概述了可用的通行证：
- en: '| Pass name | Description |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 通行证名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `THREE.BloomPass` | This is an effect that makes light areas bleed into darker
    areas. This simulates an effect where the camera is overwhelmed by extremely bright
    light. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.BloomPass` | 这是一种效果，使光亮区域渗入较暗区域。这模拟了相机被极其明亮的光所淹没的效果。 |'
- en: '| `THREE.DotScreenPass` | This applies a layer of black dots representing the
    original image across the screen. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.DotScreenPass` | 这在屏幕上应用了一层代表原始图像的黑点。 |'
- en: '| `THREE.FilmPass` | This simulates a TV screen by applying scanlines and distortions.
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.FilmPass` | 这通过应用扫描线和失真来模拟电视屏幕。 |'
- en: '| `THREE.GlitchPass` | This shows an electronic glitch on the screen at a random
    time interval. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.GlitchPass` | 这在屏幕上显示一个电子故障，以随机时间间隔。 |'
- en: '| `THREE.MaskPass` | This allows you to apply a mask to the current image.
    Subsequent passes are only applied to the masked area. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.MaskPass` | 这允许您对当前图像应用蒙版。后续通行证仅应用于蒙版区域。 |'
- en: '| `THREE.RenderPass` | This renders a scene based on the supplied scene and
    camera. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.RenderPass` | 这根据提供的场景和相机渲染场景。 |'
- en: '| `THREE.SavePass` | When this pass is executed, it makes a copy of the current
    rendering step that you can use later. This pass isn''t that useful in practice,
    and we won''t use it in any of our examples. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.SavePass` | 当执行此通行证时，它会复制当前的渲染步骤，以便以后使用。这个通行证在实践中并不那么有用，我们不会在任何示例中使用它。
    |'
- en: '| `THREE.ShaderPass` | This allows you to pass in custom shaders for advanced
    or custom postprocessing passes. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.ShaderPass` | 这允许您为高级或自定义后期处理通行证传递自定义着色器。 |'
- en: '| `THREE.TexturePass` | This stores the current state of the composer in a
    texture that you can use as input for other `EffectComposer` instance. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.TexturePass` | 这将当前composer的状态存储在一个纹理中，您可以将其用作其他`EffectComposer`实例的输入。
    |'
- en: Let's start with a number of simple passes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些简单的通行证开始。
- en: Simple postprocessing passes
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的后期处理通行证
- en: 'For simple passes, we''ll look at what we can do with `THREE.FilmPass`, `THREE.BloomPass`,
    and `THREE.DotScreenPass`. For these passes, an example is available, `02-post-processing-simple`,
    that allows you to experiment with these passes and see how they affect the original
    output differently. The following screenshot shows this example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的通行证，我们将看看我们可以用`THREE.FilmPass`，`THREE.BloomPass`和`THREE.DotScreenPass`做些什么。对于这些通行证，有一个例子可用，`02-post-processing-simple`，允许您尝试这些通行证，并查看它们如何以不同的方式影响原始输出。以下屏幕截图显示了这个例子：
- en: '![Simple postprocessing passes](graphics/2215OS_11_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Simple postprocessing passes](graphics/2215OS_11_02.jpg)'
- en: In this example, we show four scenes at the same time, and on each scene, a
    different postprocessing pass is added. The one in the top-left corner shows `THREE.BloomPass`,
    the one in the top-right corner shows `THREE.FilmPass`, the one in the bottom-left
    corner shows `THREE.DotScreenPass`, and the one in the bottom-right corner shows
    the original render.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们同时显示了四个场景，并且在每个场景中，添加了不同的后期处理通行证。左上角的一个显示了`THREE.BloomPass`，右上角的一个显示了`THREE.FilmPass`，左下角的一个显示了`THREE.DotScreenPass`，右下角的一个显示了原始渲染。
- en: 'In this example, we also use `THREE.ShaderPass` and `THREE.TexturePass` to
    reuse the output from the original rendering as input for the other three scenes.
    So, before we look at the individual passes, let''s look at these two passes first:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们还使用`THREE.ShaderPass`和`THREE.TexturePass`来重用原始渲染的输出作为其他三个场景的输入。因此，在我们查看各个pass之前，让我们先看看这两个pass：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this piece of code, we set up `THREE.EffectComposer`, which will output the
    default scene (the one in the bottom-right corner). This composer has two passes.
    `THREE.RenderPass` renders the scene, and `THREE.ShaderPass`, when configured
    with `THREE.CopyShader`, renders the output, without any further postprocessing
    to the screen if we set the `renderToScreen` property to `true`. If you look at
    the example, you can see that we show the same scene four times but with a different
    effect applied each time. We could render the scene from scratch using `THREE.RenderPass`
    four times, but that would be a bit of a waste since we can just reuse the output
    from this first composer. To do this, we create `THREE.TexturePass` and pass in
    the `composer.renderTarget2` value. We can now use the `renderScene` variable
    as input for our other composers without having to render the scene from scratch.
    Let's revisit `THREE.FilmPass` first and see how we can use `THREE.TexturePass`
    as input.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们设置了`THREE.EffectComposer`，它将输出默认场景（右下角的场景）。这个composer有两个passes。`THREE.RenderPass`渲染场景，而`THREE.ShaderPass`在配置为`THREE.CopyShader`时，如果将`renderToScreen`属性设置为`true`，则将输出渲染到屏幕上。如果你看例子，你会发现我们展示了同一个场景四次，但每次都应用了不同的效果。我们可以使用`THREE.RenderPass`从头开始渲染场景四次，但这样有点浪费，因为我们可以重用第一个composer的输出。为此，我们创建了`THREE.TexturePass`并传入了`composer.renderTarget2`的值。现在我们可以使用`renderScene`变量作为其他composer的输入，而无需从头开始渲染场景。让我们首先重新审视`THREE.FilmPass`，看看我们如何使用`THREE.TexturePass`作为输入。
- en: Using THREE.FilmPass to create a TV-like effect
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用THREE.FilmPass创建类似电视的效果
- en: 'We already looked at how to create `THREE.FilmPass` in the first section of
    this chapter, so let''s see how to use this effect together with `THREE.TexturePass`
    from the previous section:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们已经看过如何创建`THREE.FilmPass`，现在让我们看看如何将这个效果与上一节的`THREE.TexturePass`一起使用：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The only step you need to take to use `THREE.TexturePass` is to add it as the
    first pass in your composer. Next, we can just add `THREE.FilmPass`, and the effect
    is applied. `THREE.FilmPass` itself takes four parameters:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`THREE.TexturePass`的唯一步骤是将它作为你的composer中的第一个pass添加。接下来，我们只需添加`THREE.FilmPass`，效果就会应用上。`THREE.FilmPass`本身有四个参数：
- en: '| Property | Description |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `noiseIntensity` | This property allows you to control how grainy the scene
    looks. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `noiseIntensity` | 这个属性允许你控制场景看起来有多粗糙。 |'
- en: '| `scanlinesIntensity` | `THREE.FilmPass` adds a number of scanlines to the
    scene. With this property, you can define how prominently these scanlines are
    shown. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `scanlinesIntensity` | `THREE.FilmPass`向场景添加了一些扫描线。使用这个属性，你可以定义这些扫描线的显示程度。
    |'
- en: '| `scanLinesCount` | The number of scanlines that are shown can be controlled
    with this property. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `scanLinesCount` | 可以使用这个属性控制显示的扫描线数量。 |'
- en: '| `grayscale` | If this is set to `true`, the output will be converted to grayscale.
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `grayscale` | 如果设置为`true`，输出将被转换为灰度。 |'
- en: 'There are actually two ways you can pass in these parameters. In this example,
    we passed them in as arguments to the constructor, but you can also set them directly,
    as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以有两种方式传入这些参数。在这个例子中，我们将它们作为构造函数的参数传入，但你也可以直接设置它们，如下所示：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this approach, we use the `uniforms` property, which is used to communicate
    directly with WebGL. In the section where we talk about creating a custom shader
    later in this chapter, we'll go a bit deeper into `uniforms`; for now, all you
    need to know is that this way, you can directly update the configuration of postprocessing
    passes and shaders and directly see the results.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们使用了`uniforms`属性，它用于直接与WebGL通信。在本章稍后讨论创建自定义着色器时，我们将更深入地了解`uniforms`；现在你只需要知道，通过这种方式，你可以直接更新后处理passes和着色器的配置，并直接看到结果。
- en: Adding a bloom effect to the scene with THREE.BloomPass
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用THREE.BloomPass向场景添加泛光效果
- en: 'The effect you see in the upper-left corner is called the bloom effect. When
    you apply the bloom effect, the bright areas of a scene will be made more prominent
    and *bleed* into the darker areas. The code to create `THREE.BloomPass` is shown
    here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你在左上角看到的效果称为泛光效果。当应用泛光效果时，场景的亮区域会更加突出，并且“渗透”到暗区域。创建`THREE.BloomPass`的代码如下所示：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you compare this with `THREE.EffectComposer`, which we used with `THREE.FilmPass`,
    you'll notice that we add an additional pass, `effectCopy`. This step, which we
    also used for the normal output, doesn't add any special effect but just copies
    the output from the last pass to the screen. We need to add this step since `THREE.BloomPass`
    can't render directly to the screen.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个与我们用`THREE.FilmPass`使用的`THREE.EffectComposer`进行比较，你会注意到我们添加了一个额外的pass，`effectCopy`。这一步，我们也用于正常的输出，不会添加任何特殊效果，只是将最后一个pass的输出复制到屏幕上。我们需要添加这一步，因为`THREE.BloomPass`不能直接渲染到屏幕上。
- en: 'The following table lists the properties you can set on `THREE.BloomPass`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了你可以在`THREE.BloomPass`上设置的属性：
- en: '| Property | Description |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Strength` | This is the strength of the bloom effect. The higher this is,
    the more bright the brighter areas are and the more they "bleed" to the darker
    areas. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `Strength` | 这是泛光效果的强度。数值越高，亮区域就会更亮，而且会“渗透”到暗区域。 |'
- en: '| `kernelSize` | This property controls the offset of the bloom effect. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `kernelSize` | 这个属性控制泛光效果的偏移量。 |'
- en: '| `sigma` | With the `sigma` property, you can control the sharpness of the
    bloom effect. The higher the value, the more blurred the bloom effect looks. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `sigma` | 使用`sigma`属性，你可以控制泛光效果的锐度。数值越高，泛光效果看起来就越模糊。 |'
- en: '| `Resolution` | The `Resolution` property defines how precisely the bloom
    effect is created. If you make this too low, the result will look blocky. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `分辨率` | `分辨率` 属性定义了绽放效果的创建精度。如果设置得太低，结果会显得有点方块。 |'
- en: 'A better way to understand these properties is to just experiment with them
    using the previously mentioned example, `02-post-processing-simple`. The following
    screenshot shows the bloom effect with a high kernel and sigma size and low strength:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 更好地理解这些属性的方法就是使用之前提到的例子`02-post-processing-simple`进行实验。以下截图显示了具有高内核和sigma大小以及低强度的绽放效果：
- en: '![Adding a bloom effect to the scene with THREE.BloomPass](graphics/2215OS_11_03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![使用THREE.BloomPass为场景添加绽放效果](graphics/2215OS_11_03.jpg)'
- en: The last of the simple effects we'll have a look at is `THREE.DotScreenPass`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的最后一个简单效果是 `THREE.DotScreenPass`。
- en: Output the scene as a set of dots
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将场景输出为一组点
- en: 'Using `THREE.DotScreenPass` is very similar to using `THREE.BloomPass`. We
    just saw `THREE.BloomPass` in action. Now let''s see the code for `THREE.DotScreenPass`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `THREE.DotScreenPass` 与使用 `THREE.BloomPass` 非常相似。我们刚刚看到了 `THREE.BloomPass`
    的效果。现在让我们看看 `THREE.DotScreenPass` 的代码：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With this effect, we once again have to add `effectCopy` to output the result
    to the screen. `THREE.DotScreenPass` can also be configured with a number of properties,
    as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种效果，我们再次必须添加 `effectCopy` 将结果输出到屏幕。`THREE.DotScreenPass` 也可以通过一些属性进行配置，如下所示：
- en: '| Property | Description |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `center` | With the `center` property, you can fine-tune the way the dots
    are offset. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `中心` | 通过 `中心` 属性，你可以微调点的偏移方式。 |'
- en: '| `angle` | The dots are aligned in a certain manner. With the `angle` properties,
    you can change this alignment. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `角度` | 点是以一定的方式对齐的。通过 `角度` 属性，你可以改变这种对齐方式。 |'
- en: '| `Scale` | With this, we can set the size of the dots to use. The lower the
    `scale`, the larger the dots. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `缩放` | 通过这个，我们可以设置要使用的点的大小。`缩放`越低，点就越大。 |'
- en: What applies to the other shaders also applies to this shader. It's much easier
    to get the right settings with experimentation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对其他着色器适用于这个着色器。通过实验，更容易找到正确的设置。
- en: '![Output the scene as a set of dots](graphics/2215OS_11_04.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![将场景输出为一组点](graphics/2215OS_11_04.jpg)'
- en: Showing the output of multiple renderers on the same screen
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在同一屏幕上显示多个渲染器的输出
- en: 'This section doesn''t go into the details of how to use postprocessing effects,
    but explains how to get the output of all four `THREE.EffectComposer` instances
    on the same screen. First, let''s look at the render loop used for this example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本节不涉及如何使用后期处理效果的细节，而是解释如何在同一屏幕上获取所有四个 `THREE.EffectComposer` 实例的输出。首先，让我们看看用于此示例的渲染循环：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first thing to notice here is that we set the `webGLRenderer.autoClear`
    property to `false` and then explicitly call the `clear()` function. If we don't
    do this each time we call the `render()` function on a composer, the previously
    rendered scenes will be cleared. With this approach, we only clear everything
    at the beginning of our render loop.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要注意的第一件事是，我们将 `webGLRenderer.autoClear` 属性设置为 `false`，然后显式调用 `clear()` 函数。如果我们不在每次在composer上调用
    `render()` 函数时这样做，之前渲染的场景将被清除。通过这种方法，我们只在渲染循环的开始清除一切。
- en: 'To avoid all our composers rendering in the same space, we set the viewport
    of `webGLRenderer`, which is used by our composers, to a different part of the
    screen. This function takes four arguments: `x`, `y`, `width`, and `height`. As
    you can see in the code sample, we use this function to divide the screen into
    four areas and make the composers render to their individual area. Note that you
    can also use this approach with multiple scenes, cameras, and `WebGLRenderer`
    if you want.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免所有的composer在同一空间渲染，我们将`webGLRenderer`的视口设置为屏幕的不同部分。这个函数接受四个参数：`x`、`y`、`宽度`和`高度`。正如你在代码示例中看到的，我们使用这个函数将屏幕分成四个区域，并让composer分别渲染到它们的个别区域。请注意，如果需要，你也可以在多个场景、相机和`WebGLRenderer`上使用这种方法。
- en: 'In the table at the beginning of this section, we also mentioned `THREE.GlitchPass`.
    With this render pass, you can add a kind of electronic glitch effect to your
    scenes. This effect is just as easy to use as the other ones you''ve seen until
    now. To use it, first include the following two files in your HTML page:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节开始的表格中，我们还提到了 `THREE.GlitchPass`。使用这个渲染通道，你可以为你的场景添加一种电子故障效果。这种效果和你之前看到的其他效果一样容易使用。要使用它，首先在你的HTML页面中包含以下两个文件：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, create the `THREE.GlitchPass` object, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建 `THREE.GlitchPass` 对象，如下所示：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result is a scene where the result is rendered normally except that at
    random intervals, a glitch occurs, as shown in the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个场景，其中结果被正常渲染，只是在随机间隔发生故障，如下截图所示：
- en: '![Showing the output of multiple renderers on the same screen](graphics/2215OS_11_19.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![在同一屏幕上显示多个渲染器的输出](graphics/2215OS_11_19.jpg)'
- en: Until now, we've only chained a couple of simple passes. In the next example,
    we'll configure a more complex `THREE.EffectComposer` and use masks to apply effects
    to a part of the screen.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只链接了一些简单的通道。在下一个例子中，我们将配置一个更复杂的 `THREE.EffectComposer` 并使用蒙版将效果应用到屏幕的一部分。
- en: Advanced EffectComposer flows using masks
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用蒙版创建高级EffectComposer流
- en: 'In the previous examples, we applied the postprocessing pass to the complete
    screen. Three.js, however, also has the ability to only apply passes to a specific
    area. In this section, we''re going to perform the following steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们将后期处理通道应用到了整个屏幕上。然而，Three.js 也有能力只将通道应用到特定区域。在本节中，我们将执行以下步骤：
- en: Create a scene to serve as a background image.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用作背景图像的场景。
- en: Create a scene containing a sphere that looks like Earth.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个看起来像地球的球体的场景。
- en: Create a scene containing a sphere that looks like Mars.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个看起来像火星的球体的场景。
- en: Create `EffectComposer`, which renders these three scenes into a single image.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `EffectComposer`，将这三个场景渲染成一个单一的图像。
- en: Apply a *colorify* effect to the sphere rendered as Mars.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *colorify* 效果应用到渲染为火星的球体上。
- en: Apply a sepia effect to the sphere rendered as Earth.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对渲染为地球的球体应用棕褐色效果。
- en: 'This might sound complex, but is actually surprisingly easy to accomplish.
    First, let''s look at the result we''re aiming for in the `03-post-processing-masks.html`
    example. The following screenshot shows the result of these steps:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来很复杂，但实际上实现起来非常容易。首先，让我们来看看我们在`03-post-processing-masks.html`示例中的目标结果。以下截图显示了这些步骤的结果：
- en: '![Advanced EffectComposer flows using masks](graphics/2215OS_11_05.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![使用蒙版的高级EffectComposer流程](graphics/2215OS_11_05.jpg)'
- en: 'The first thing we need to do is set up the various scenes we''ll be rendering,
    as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要做的是设置我们将渲染的各种场景，如下所示：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To create the Earth and Mars spheres, we just create the spheres with the correct
    material and textures and add them to their specific scenes, as shown in the following
    code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建地球和火星球体，我们只需使用正确的材质和纹理创建球体，并将它们添加到各自的场景中，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We also need to add some lights to the scene just as we would for a normal scene,
    but we won't show that here (see [Chapter 3](ch03.html "Chapter 3. Working with
    the Different Light Sources Available in Three.js"), *Working with the Different
    Light Sources Available in Three.js*, for more details). The only thing to remember
    is that a light cannot be added to different scenes, so you need to create separate
    lights for both scenes. That's all the setting up we need to do for these two
    scenes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要像对待普通场景一样向场景中添加一些灯光，但我们不会在这里展示（有关更多详细信息，请参见[第3章](ch03.html "第3章。Three.js中可用的不同光源")，“Three.js中可用的不同光源”，）。唯一需要记住的是，灯光不能添加到不同的场景，因此您需要为两个场景创建单独的灯光。这就是我们需要为这两个场景做的所有设置。
- en: 'For the background image, we create `THREE.OrthoGraphicCamera`. Remember from
    [Chapter 2](ch02.html "Chapter 2. Basic Components That Make Up a Three.js Scene"),
    *Basic Components That Make Up a Three.js Scene*, that the size of objects in
    the orthographic projection doesn''t depend on the distance from the camera, so
    this also provides a good way to create fixed backgrounds. Here''s how we create
    `THREE.OrthoGraphicCamera`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于背景图像，我们创建`THREE.OrthoGraphicCamera`。请记住，从[第2章](ch02.html "第2章。Three.js场景的基本组件")，“Three.js场景的基本组件”中，正交投影中对象的大小不取决于距离，因此这也是创建固定背景的好方法。以下是我们创建`THREE.OrthoGraphicCamera`的方法：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We won't go into too much detail for this part, but we have to take a couple
    of steps to create a background image. First, we create a material from our background
    image, and we apply this material to a simple plane. Next, we add this plane to
    the scene and scale it to exactly fill the complete screen. So, when we render
    this scene with this camera, our background image is shown stretched to the width
    of the screen.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会对这部分详细说明，但我们必须采取一些步骤来创建背景图像。首先，我们从背景图像创建材质，并将此材质应用于简单的平面。接下来，我们将此平面添加到场景中，并将其缩放以完全填满整个屏幕。因此，当我们使用这个相机渲染这个场景时，我们的背景图像会被拉伸到屏幕的宽度。
- en: 'We''ve now got our three scenes, and we can start to set up our passes and
    `THREE.EffectComposer`. Let''s start by looking at the complete chain of passes,
    after which we''ll look at the individual passes:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了三个场景，我们可以开始设置我们的通道和`THREE.EffectComposer`。让我们首先看一下完整的通道链，之后我们再看看各个通道：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To work with masks, we need to create `THREE.EffectComposer` in a different
    manner. In this case, we need to create a new `THREE.WebGLRenderTarget` and set
    the `stencilBuffer` property of the internally used render targets to `true`.
    A stencil buffer is a special type of buffer and is used to limit the area of
    rendering. So, by enabling the stencil buffer, we can use our masks. First, let''s
    look at the first three passes that are added. These three passes render the background,
    the Earth scene, and the Mars scene, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用蒙版，我们需要以不同的方式创建`THREE.EffectComposer`。在这种情况下，我们需要创建一个新的`THREE.WebGLRenderTarget`，并将内部使用的渲染目标的`stencilBuffer`属性设置为`true`。模板缓冲区是一种特殊类型的缓冲区，用于限制渲染区域。因此，通过启用模板缓冲区，我们可以使用我们的蒙版。首先，让我们来看一下添加的前三个通道。这三个通道分别渲染背景、地球场景和火星场景，如下所示：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There''s nothing new here except that we set the `clear` property of two of
    these passes to `false`. If we don''t do this, we''ll only see the output from
    `renderPass2` since it will clear everything before it starts rendering. If you
    look back at the code for `THREE.EffectComposer`, the next three passes are `marsMask`,
    `effectColorify`, and `clearMask`. First, we''ll look at how these three passes
    are defined:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新的，除了我们将两个通道的`clear`属性设置为`false`。如果我们不这样做，我们只会看到`renderPass2`的输出，因为它会在开始渲染之前清除一切。如果你回顾一下`THREE.EffectComposer`的代码，接下来的三个通道是`marsMask`，`effectColorify`和`clearMask`。首先，我们来看一下这三个通道是如何定义的：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first of these three passes is `THREE.MaskPass`. When creating `THREE.MaskPass`,
    you pass in a scene and a camera just as you did for `THREE.RenderPass`. `THREE.MaskPass`
    will render this scene internally, but instead of showing this on screen, it uses
    this information to create a mask. When `THREE.MaskPass` is added to `THREE.EffectComposer`,
    all the subsequent passes will only be applied to the mask defined by `THREE.MaskPass`,
    until `THREE.ClearMaskPass` is encountered. In this example, this means that the
    `effectColorify` pass, which adds a blue glow, is only applied to the objects
    rendered in `sceneMars`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个通道中的第一个是`THREE.MaskPass`。创建`THREE.MaskPass`时，您需要像为`THREE.RenderPass`一样传入一个场景和一个相机。`THREE.MaskPass`将在内部渲染此场景，但不会在屏幕上显示，而是使用此信息创建蒙版。当`THREE.MaskPass`添加到`THREE.EffectComposer`时，所有后续通道将仅应用于`THREE.MaskPass`定义的蒙版，直到遇到`THREE.ClearMaskPass`。在这个例子中，这意味着`effectColorify`通道，它添加了蓝色的发光效果，仅应用于`sceneMars`中渲染的对象。
- en: We use the same approach to apply a sepia filter on the Earth object. We first
    create a mask based on the Earth scene and use this mask in `THREE.EffectComposer`.
    After `THREE.MaskPass`, we add the effect we want to apply (`effectSepia` in this
    case), and once we're done with that, we add `THREE.ClearMaskPass` to remove the
    mask. The last step for this specific `THREE.EffectComposer` is one we've already
    seen. We need to copy the final result to the screen, and we once again use the
    `effectCopy` pass for that.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的方法在地球对象上应用了一个棕褐色滤镜。我们首先基于地球场景创建一个蒙版，并在`THREE.EffectComposer`中使用这个蒙版。在`THREE.MaskPass`之后，我们添加我们想要应用的效果（在这种情况下是`effectSepia`），一旦完成，我们添加`THREE.ClearMaskPass`来移除蒙版。对于这个特定的`THREE.EffectComposer`的最后一步是我们已经看到的。我们需要将最终结果复制到屏幕上，我们再次使用`effectCopy`通道来实现。
- en: 'There is one additional property that''s interesting when working with `THREE.MaskPass,`
    and that''s the `inverse` property. If this property is set to `true`, the mask
    is inversed. In other words, the effect is applied to everything but the scene
    passed into `THREE.MaskPass`. This is shown in the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`THREE.MaskPass`时还有一个有趣的额外属性，那就是`inverse`属性。如果将此属性设置为`true`，则蒙版将被反转。换句话说，效果将应用于除传入`THREE.MaskPass`的场景之外的所有内容。这在下面的截图中显示出来：
- en: '![Advanced EffectComposer flows using masks](graphics/2215OS_11_06.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![使用蒙版的高级EffectComposer流程](graphics/2215OS_11_06.jpg)'
- en: Until now, we've used standard passes provided by Three.js for our effects.
    Three.js also provides `THREE.ShaderPass`, which can be used for custom effects
    and comes with a large number of shaders you can use and experiment with.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '到目前为止，我们已经使用了Three.js提供的标准通道来实现我们的效果。Three.js还提供了`THREE.ShaderPass`，可以用于自定义效果，并带有大量可以使用和实验的着色器。 '
- en: Using THREE.ShaderPass for custom effects
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用THREE.ShaderPass进行自定义效果
- en: 'With `THREE.ShaderPass`, we can apply a large number of additional effects
    to our scene by passing in a custom shader. This section is divided into three
    parts. First, we''ll look at the following set of simple shaders:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`THREE.ShaderPass`，我们可以通过传入自定义着色器为我们的场景应用大量额外的效果。这一部分分为三个部分。首先，我们将看一下以下一组简单着色器：
- en: '| Name | Description |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `THREE.MirrorShader` | This creates a mirror effect for part of the screen.
    |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.MirrorShader` | 这会为屏幕的一部分创建一个镜像效果。 |'
- en: '| `THREE.HueSaturationShader` | This allows you to change the *hue* and *saturation*
    of the colors. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.HueSaturationShader` | 这允许你改变颜色的*色调*和*饱和度*。 |'
- en: '| `THREE.VignetteShader` | This applies a vignette effect. This effect shows
    dark borders around the center of the image. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.VignetteShader` | 这应用了一个晕影效果。这个效果在图像中心周围显示出暗色边框。 |'
- en: '| `THREE.ColorCorrectionShader` | With this shader, you can change the color
    distribution. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.ColorCorrectionShader` | 使用这个着色器，你可以改变颜色分布。 |'
- en: '| `THREE.RGBShiftShader` | This shader separates the red, green, and blue components
    of a color. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.RGBShiftShader` | 这个着色器分离了颜色的红色、绿色和蓝色分量。 |'
- en: '| `THREE.BrightnessContrastShader` | This changes the brightness and contrast
    of an image. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.BrightnessContrastShader` | 这改变了图像的亮度和对比度。 |'
- en: '| `THREE.ColorifyShader` | This applies a color overlay to the screen. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.ColorifyShader` | 这将在屏幕上应用颜色叠加。 |'
- en: '| `THREE.SepiaShader` | This creates a sepia-like effect on the screen. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.SepiaShader` | 这在屏幕上创建了一个棕褐色的效果。 |'
- en: '| `THREE.KaleidoShader` | This adds a kaleidoscope effect to the scene that
    provides radial reflection around the center of the scene. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.KaleidoShader` | 这为场景添加了一个万花筒效果，围绕场景中心提供了径向反射。 |'
- en: '| `THREE.LuminosityShader` | This provides a luminosity effect where the luminosity
    of the scene is shown. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.LuminosityShader` | 这提供了一个亮度效果，显示了场景的亮度。 |'
- en: '| `THREE.TechnicolorShader` | This simulates the effect of two-strip technicolor
    that can be seen in older movies. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.TechnicolorShader` | 这模拟了旧电影中可以看到的双色技术色彩效果。 |'
- en: 'Next, we''ll look at shaders that provide a couple of blur-related effects:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一些提供一些模糊相关效果的着色器：
- en: '| Name | Description |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `THREE.HorizontalBlurShader` and `THREE.VerticalBlurShader` | These apply
    a blur effect to the complete scene. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.HorizontalBlurShader` 和 `THREE.VerticalBlurShader` | 这些将模糊效果应用到整个场景。
    |'
- en: '| `THREE.HorizontalTiltShiftShader` and `THREE.VerticalTiltShiftShader` | These
    recreate the *tilt shift* effect. With the tilt shift effect, it is possible to
    create scenes that look like a miniature by making sure only part of the image
    is sharp. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.HorizontalTiltShiftShader` 和 `THREE.VerticalTiltShiftShader` | 这些重新创建了*移轴*效果。使用移轴效果，可以确保只有图像的一部分是清晰的，从而创建看起来像微缩的场景。
    |'
- en: '| `THREE.TriangleBlurShader` | This applies a blur effect using a triangle-based
    approach. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.TriangleBlurShader` | 这使用基于三角形的方法应用了模糊效果。 |'
- en: 'And finally, we''ll look at a few shaders that provide advanced effects:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看一些提供高级效果的着色器：
- en: '| Name | Description |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `THREE.BleachBypassShader` | This creates a *bleach bypass* effect. With
    this effect, a silver-like overlay will be applied to the image. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.BleachBypassShader` | 这会创建一个*漂白副本*效果。使用这个效果，图像上会应用一个类似银色的叠加。 |'
- en: '| `THREE.EdgeShader` | This shader can be used to detect the sharp edges in
    an image and highlight them. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.EdgeShader` | 这个着色器可以用来检测图像中的锐利边缘并突出显示它们。 |'
- en: '| `THREE.FXAAShader` | This shader applies an anti-aliasing effect during the
    postprocessing phase. Use this if applying anti-aliasing during rendering is too
    expensive. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.FXAAShader` | 这个着色器在后期处理阶段应用了抗锯齿效果。如果在渲染过程中应用抗锯齿效果太昂贵，可以使用这个。 |'
- en: '| `THREE.FocusShader` | This is a simple shader that results in a sharply rendered
    center area and blurring along its borders. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.FocusShader` | 这是一个简单的着色器，可以使中心区域清晰渲染，边缘模糊。 |'
- en: We won't go into the details of all the shaders since if you've seen how one
    works, you pretty much know how the others work. In the following sections, we'll
    highlight a couple of interesting ones. You can experiment with the others using
    the interactive examples provided for each section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍所有的着色器，因为如果您了解了一个着色器的工作原理，您基本上就知道了其他着色器的工作原理。在接下来的章节中，我们将重点介绍一些有趣的着色器。您可以使用每个章节提供的交互式示例来尝试其他着色器。
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Three.js also provides two advanced postprocessing effects that allow you to
    apply a *bokeh* effect to your scene. A bokeh effect provides a blur effect to
    part of the scene while rendering your main subject very sharply. Three.js provides
    `THREE.BrokerPass`, which you can use for this, or `THREE.BokehShader2` and `THREE.DOFMipMapShader`,
    which you can use together with `THREE.ShaderPass`. An example of these shaders
    in action can be found on the Three.js website at [http://threejs.org/examples/webgl_postprocessing_dof2.html](http://threejs.org/examples/webgl_postprocessing_dof2.html)
    and [http://threejs.org/examples/webgl_postprocessing_dof.html](http://threejs.org/examples/webgl_postprocessing_dof.html).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js还提供了两种高级的后期处理效果，允许您在场景中应用*bokeh*效果。Bokeh效果可以使场景的一部分产生模糊效果，同时使主要主题非常清晰。Three.js提供了`THREE.BrokerPass`，您可以使用它来实现这一点，或者使用`THREE.BokehShader2`和`THREE.DOFMipMapShader`，您可以与`THREE.ShaderPass`一起使用。这些着色器的示例可以在Three.js网站上找到，网址为[http://threejs.org/examples/webgl_postprocessing_dof2.html](http://threejs.org/examples/webgl_postprocessing_dof2.html)和[http://threejs.org/examples/webgl_postprocessing_dof.html](http://threejs.org/examples/webgl_postprocessing_dof.html)。
- en: We start with a couple of the simple shaders.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先从一些简单的着色器开始。
- en: Simple shaders
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单着色器
- en: 'To experiment with the basic shaders, we''ve created an example where you can
    play around with the shaders and see the effect directly in the scene. You can
    find this example in `04-shaderpass-simple.html`. The following screenshot shows
    this example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试基本的着色器，我们创建了一个示例，您可以在其中玩耍着色器，并直接在场景中看到效果。您可以在`04-shaderpass-simple.html`中找到这个示例。以下截图显示了这个示例：
- en: '![Simple shaders](graphics/2215OS_11_07.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![简单着色器](graphics/2215OS_11_07.jpg)'
- en: 'With the menu in the top-right corner, you can select the specific shader you
    want to apply, and with the various drop-down menus, you can set the properties
    of the shader you''ve selected. For instance, the following screenshot shows `RGBShiftShader`
    in action:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过右上角的菜单，您可以选择要应用的特定着色器，并通过各种下拉菜单设置所选着色器的属性。例如，下面的截图显示了`RGBShiftShader`的效果：
- en: '![Simple shaders](graphics/2215OS_11_08.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![简单着色器](graphics/2215OS_11_08.jpg)'
- en: 'When you change one of the properties of a shader, the result is updated directly.
    For this example, we set the changed value directly on the shader. For instance,
    when values for `RGBShiftShader` have changed, we update the shader like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当您改变着色器的属性之一时，结果会直接更新。对于这个例子，我们直接在着色器上设置了改变的值。例如，当`RGBShiftShader`的值发生变化时，我们会像这样更新着色器：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s look at a couple of other shaders. The following image shows the result
    of `VignetteShader`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看其他一些着色器。以下图像显示了`VignetteShader`的结果：
- en: '![Simple shaders](graphics/2215OS_11_09.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![简单着色器](graphics/2215OS_11_09.jpg)'
- en: '`MirrorShader` has the following effect:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`MirrorShader`有以下效果：'
- en: '![Simple shaders](graphics/2215OS_11_10.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![简单着色器](graphics/2215OS_11_10.jpg)'
- en: 'With postprocessing, we can also apply extreme effects. A good example of this
    is `THREE.KaleidoShader`. If you select this shader from the menu in the top-right
    corner, you''ll see the following effect:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过后期处理，我们还可以应用极端的效果。`THREE.KaleidoShader`就是一个很好的例子。如果您从右上角的菜单中选择这个着色器，您会看到以下效果：
- en: '![Simple shaders](graphics/2215OS_11_11.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![简单着色器](graphics/2215OS_11_11.jpg)'
- en: That's enough for the simple shaders. As you can see, they are very versatile
    and can create very interesting-looking effects. In this example, we applied a
    single shader each time, but you can add as many `THREE.ShaderPass` steps to `THREE.EffectComposer`
    as you like.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 简单着色器就介绍到这里。正如您所看到的，它们非常多才多艺，可以创造出非常有趣的效果。在这个例子中，我们每次应用了一个着色器，但您可以向`THREE.EffectComposer`添加尽可能多的`THREE.ShaderPass`步骤。
- en: Blurring shaders
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模糊着色器
- en: 'In this section, we won''t dive into the code; we''ll just show you the results
    from the various blur shaders. You can experiment with these using the `05-shaderpass-blur.html`
    example. The following scene is blurred with `HorizontalBlurShader` and `VerticalBlurShader`,
    both of which you will learn about in the following paragraphs:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们不会深入代码；我们只会展示各种模糊着色器的结果。您可以使用`05-shaderpass-blur.html`示例来进行实验。以下场景使用`HorizontalBlurShader`和`VerticalBlurShader`进行了模糊处理，您将在接下来的段落中了解到这两种着色器：
- en: '![Blurring shaders](graphics/2215OS_11_12.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![模糊着色器](graphics/2215OS_11_12.jpg)'
- en: 'The preceding image shows `THREE.HorizontalBlurShader` and `THREE.VerticalBlurShader`.
    You can see the effect is a blurred scene. Besides these two blur effects, Three.js
    provides an additional shader that blurs an image, `THREE.TriangleShader`, which
    is shown here. For instance, you could use this shader to depict motion blur,
    as shown in the following screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像显示了`THREE.HorizontalBlurShader`和`THREE.VerticalBlurShader`。您可以看到效果是一个模糊的场景。除了这两种模糊效果，Three.js还提供了另一个着色器来模糊图像，即`THREE.TriangleShader`，如下所示。例如，您可以使用这个着色器来描绘运动模糊，就像下面的截图所示：
- en: '![Blurring shaders](graphics/2215OS_11_13.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![模糊着色器](graphics/2215OS_11_13.jpg)'
- en: 'The last blur-like effect is provided by `THREE.HorizontalTiltShiftShader`
    and `THREE.VerticalTiltShiftShader`. This shader doesn''t blur the complete scene,
    but only a small area. This provides an effect called *tilt shift*. This is often
    used to create miniature-like scenes from normal photographs. The following image
    shows this effect:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个类似模糊的效果是由`THREE.HorizontalTiltShiftShader`和`THREE.VerticalTiltShiftShader`提供的。这个着色器不会使整个场景模糊，而只会模糊一个小区域。这提供了一种称为*tilt
    shift*的效果。这经常用于从普通照片中创建微缩场景。以下图像显示了这种效果：
- en: '![Blurring shaders](graphics/2215OS_11_14.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![模糊着色器](graphics/2215OS_11_14.jpg)'
- en: Advanced shaders
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级着色器
- en: 'For the advanced shaders, we''ll do what we did for the previous blur-shaders.
    We''ll just show you the output of the shaders. For details on how to configure
    them, look at the `06-shaderpass-advanced.html` example. The following screenshot
    shows this example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高级着色器，我们将做与之前的模糊着色器相同的事情。我们只会展示着色器的输出。有关如何配置它们的详细信息，请查看`06-shaderpass-advanced.html`示例。以下截图显示了这个示例：
- en: '![Advanced shaders](graphics/2215OS_11_15.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![高级着色器](graphics/2215OS_11_15.jpg)'
- en: The preceding example shows `THREE.EdgeShader`. With this shader, you can detect
    the edges of objects in your scene.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子展示了`THREE.EdgeShader`。使用这个着色器，您可以检测场景中物体的边缘。
- en: 'The next shader is `THREE.FocusShader`. This shader only renders the center
    of the screen in focus, as shown in the following screenshot:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个着色器是`THREE.FocusShader`。这个着色器只在屏幕中心呈现焦点，如下截图所示：
- en: '![Advanced shaders](graphics/2215OS_11_16.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![高级着色器](graphics/2215OS_11_16.jpg)'
- en: Until now, we've only used shaders that are provided by Three.js. However, it's
    also very easy to create shaders yourself.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了Three.js提供的着色器。但是，自己创建着色器也非常容易。
- en: Creating custom postprocessing shaders
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义后期处理着色器
- en: In this section, you'll learn how to create a custom shader that you can use
    in postprocessing. We'll create two different shaders. The first one will convert
    the current image into a grayscale image, and the second one will convert the
    image into an 8-bit image by reducing the number of colors that are available.
    Note that creating vertex and fragment shaders is a very broad subject. In this
    section, we only touch the surface of what can be done by these shaders and how
    they work. For more in-depth information, you can find the WebGL specification
    at [http://www.khronos.org/webgl/](http://www.khronos.org/webgl/). An additional
    good resource full of examples is Shadertoy at [https://www.shadertoy.com/](https://www.shadertoy.com/).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何创建一个自定义着色器，可以在后期处理中使用。我们将创建两种不同的着色器。第一个将把当前图像转换为灰度图像，第二个将通过减少可用颜色的数量将图像转换为8位图像。请注意，创建顶点和片段着色器是一个非常广泛的主题。在本节中，我们只是触及了这些着色器可以做什么以及它们是如何工作的表面。有关更深入的信息，您可以在[http://www.khronos.org/webgl/](http://www.khronos.org/webgl/)找到WebGL规范。一个充满示例的额外好资源是Shadertoy，网址为[https://www.shadertoy.com/](https://www.shadertoy.com/)。
- en: Custom grayscale shader
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义灰度着色器
- en: 'To create a custom shader for Three.js (and also for other WebGL libraries),
    you need to implement two components: a vertex shader and a fragment shader. The
    vertex shader can be used to change the position of individual vertices, and the
    fragment shader is used to determine the color of individual pixels. For a postprocessing
    shader, we only need to implement a fragment shader, and we can keep the default
    vertex shader provided by Three.js. An important point to make before looking
    at the code is that GPUs usually support multiple shader pipelines. This means
    that in the vertex shaders step, multiple shaders can run in parallel—something
    that goes for the fragment shaders step as well.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要为Three.js（以及其他WebGL库）创建自定义着色器，您需要实现两个组件：顶点着色器和片段着色器。顶点着色器可用于更改单个顶点的位置，片段着色器用于确定单个像素的颜色。对于后期处理着色器，我们只需要实现片段着色器，并且可以保留Three.js提供的默认顶点着色器。在查看代码之前要强调的一个重要点是，GPU通常支持多个着色器管线。这意味着在顶点着色器步骤中，多个着色器可以并行运行，这也适用于片段着色器步骤。
- en: 'Let''s start by looking at the complete source code for the shader that applies
    a grayscale effect to our image (`custom-shader.js`):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下应用灰度效果到我们的图像的着色器的完整源代码（`custom-shader.js`）：
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see from the code, this isn't JavaScript. When you write shaders,
    you write them in the **OpenGL Shading Language** (**GLSL**), which looks a lot
    like the C programming language. More information on GLSL can be found at [http://www.khronos.org/opengles/sdk/docs/manglsl/](http://www.khronos.org/opengles/sdk/docs/manglsl/).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中可以看出，这不是JavaScript。当您编写着色器时，您会用**OpenGL着色语言**（**GLSL**）编写它们，它看起来很像C编程语言。有关GLSL的更多信息，请访问[http://www.khronos.org/opengles/sdk/docs/manglsl/](http://www.khronos.org/opengles/sdk/docs/manglsl/)。
- en: 'Let''s first look at this vertex shader:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下这个顶点着色器：
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For postprocessing, this shader doesn't really need to do anything. The code
    you see above is the standard way Three.js implements a vertex shader. It uses
    `projectionMatrix`, which is the projection from the camera, together with `modelViewMatrix`,
    which maps an object's position into the world position, to determine where to
    render an object on screen.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后期处理，这个着色器实际上不需要做任何事情。您在上面看到的代码是Three.js实现顶点着色器的标准方式。它使用`projectionMatrix`，这是从相机的投影，以及`modelViewMatrix`，它将对象的位置映射到世界位置，来确定在屏幕上渲染对象的位置。
- en: 'For postprocessing, the only interesting thing in this piece of code is that
    the `uv` value, which indicates which texel to read from a texture, is passed
    on to the fragment shader using the "`varying` `vec2` `vUv`" variable. We will
    use the `vUV` value to get the correct pixel to work on in the fragment shader.
    Let''s look at the fragment shader and see what the code is doing. We start with
    the following variable declaration:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后期处理，这段代码中唯一有趣的事情是`uv`值，它指示从纹理中读取的texel，通过"`varying` `vec2` `vUv`"变量传递到片段着色器。我们将使用`vUV`值在片段着色器中获取正确的像素进行处理。让我们看看片段着色器并了解代码在做什么。我们从以下变量声明开始：
- en: '[PRE23]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we see four instances of the `uniforms` property. The instances of the
    `uniforms` property have values that are passed in from JavaScript to the shader
    and which are the same for each fragment that is processed. In this case, we pass
    in three floats, identified by type `f` (which are used to determine the ratio
    of a color to include in the final grayscale image), and a texture (`tDiffuse`)
    is passed in, identified by type `t`. This texture contains the image from the
    previous pass from `THREE.EffectComposer`. Three.js makes sure it gets passed
    correctly to this shader, and we can set the other instances of the uniforms property
    ourselves from JavaScript. Before we can use these uniforms from JavaScript, we
    have to define which `uniforms` property is available for this shader. This is
    done like this, at the top of the shader file:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到`uniforms`属性的四个实例。`uniforms`属性的实例具有从JavaScript传递到着色器的值，并且对于处理的每个片段都是相同的。在这种情况下，我们传递了三个浮点数，由`f`类型标识（用于确定要包含在最终灰度图像中的颜色的比例），以及一个纹理（`tDiffuse`），由`t`类型标识。此纹理包含来自`THREE.EffectComposer`的上一次传递的图像。Three.js确保它正确地传递给此着色器，我们可以从JavaScript自己设置`uniforms`属性的其他实例。在我们可以从JavaScript使用这些uniforms之前，我们必须定义此着色器可用的`uniforms`属性。这是在着色器文件的顶部完成的：
- en: '[PRE24]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'At this point, we can receive configuration parameters from Three.js and have
    received the image we want to modify. Let''s look at the code that will convert
    each pixel to a gray pixel:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以从Three.js接收配置参数，并已经接收到我们想要修改的图像。让我们来看一下将每个像素转换为灰色像素的代码：
- en: '[PRE25]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What happens here is that we get the correct pixel from the passed-in texture.
    We do this by using the `texture2D` function, where we pass in our current image
    (`tDiffuse`) and the location of the pixel (`vUv`) we want to analyze. The result
    is a texel (a pixel from a texture) that contains a color and an opacity (`texel.w`).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的是，我们从传入的纹理中获取正确的像素。我们通过使用`texture2D`函数来实现这一点，其中我们传入我们当前的图像（`tDiffuse`）和我们想要分析的像素（`vUv`）的位置。结果是一个包含颜色和不透明度（`texel.w`）的纹素（纹理中的像素）。
- en: 'Next, we use the `r`, `g`, and `b` properties of this texel to calculate a
    gray value. This gray value is set to the `gl_FragColor` variable, which is eventually
    shown on screen. And with that, we''ve got our own custom shader. Using this shader
    is just like the other shaders. First, we just need to set up `THREE.EffectComposer`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用此`texel`的`r`、`g`和`b`属性来计算灰度值。此灰度值设置为`gl_FragColor`变量，最终显示在屏幕上。有了这个，我们就有了自己的自定义着色器。使用此着色器就像使用其他着色器一样。首先，我们只需要设置`THREE.EffectComposer`：
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Call `composer.render(delta)` in the render loop. If we want to change the
    properties of this shader at runtime, we can just update the `uniforms` property
    we''ve defined:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染循环中调用`composer.render(delta)`。如果我们想在运行时更改此着色器的属性，我们只需更新我们定义的`uniforms`属性：
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The result can be seen in `07-shaderpass-custom.html`. The following screenshot
    shows this example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以在`07-shaderpass-custom.html`中看到。以下屏幕截图显示了此示例：
- en: '![Custom grayscale shader](graphics/2215OS_11_17.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![自定义灰度着色器](graphics/2215OS_11_17.jpg)'
- en: Let's create another custom shader. This time, we'll reduce the 24-bit output
    to a lower bit count.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个自定义着色器。这次，我们将把24位输出减少到较低的位数。
- en: Creating a custom bit shader
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义位着色器
- en: Normally, colors are represented as a 24-bit value, which gives us about 16
    million different colors. In the early days of computing, this wasn't possible,
    and colors where often represented as 8- or 16-bit colors. With this shader, we'll
    automatically transform our 24-bit output to a color depth of 8 bits (or anything
    you want).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，颜色表示为24位值，给我们大约1600万种不同的颜色。在计算机的早期，这是不可能的，颜色通常表示为8位或16位颜色。使用此着色器，我们将自动将我们的24位输出转换为8位的颜色深度（或任何您想要的）。
- en: 'Since it hasn''t changed with regard to our previous example, we''ll skip the
    vertex shader and directly list the instances of the `uniforms` property:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它与我们之前的示例没有变化，我们将跳过顶点着色器，直接列出`uniforms`属性的实例：
- en: '[PRE28]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here''s the fragment shader itself:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是片段着色器本身：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We define two instances of the `uniforms` property that can be used to configure
    this shader. The first one is the one Three.js uses to pass in the current screen,
    and the second one is defined by us as an integer (`type:` `"i"`) and serves as
    the color depth we want to render the result in. The code itself is very straightforward:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个`uniforms`属性的实例，用于配置此着色器。第一个是Three.js用于传递当前屏幕的实例，第二个是我们自己定义的整数（`type:`
    `"i"`），用作我们希望以颜色深度渲染结果的实例。代码本身非常简单：
- en: We first get `texel` from the texture and `tDiffuse` based on the passed-in
    `vUv` location of the pixel.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先从纹理和基于传入的`vUv`像素位置的`tDiffuse`中获取`texel`。
- en: We calculate the number of colors we can have based on the `bitSize` property
    by calculating 2 to the power of `bitSize` (`pow(float(bitSize),2.0))`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过计算`bitSize`属性的2的`bitSize`次幂（`pow(float(bitSize),2.0))`来计算我们可以拥有的颜色数量。
- en: Next, we calculate the new value of the color of `texel` by multiplying the
    value with `n`, rounding it off, `(floor(texel.r*n))`, and dividing it again by
    `n`.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们通过将值乘以`n`，四舍五入，`(floor(texel.r*n))`，然后再除以`n`，来计算`texel`的颜色的新值。
- en: The result is set to `gl_FragColor` (red, green, and blue values and the opacity)
    and shown on screen.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果设置为`gl_FragColor`（红色、绿色和蓝色值以及不透明度），并显示在屏幕上。
- en: 'You can view the result for this custom shader in the same example as our previous
    custom shader, `07-shaderpass-custom.html`. The following screenshot shows this
    example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在与我们之前的自定义着色器相同的示例中查看此自定义着色器的结果，即`07-shaderpass-custom.html`。以下屏幕截图显示了此示例：
- en: '![Creating a custom bit shader](graphics/2215OS_11_18.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义位着色器](graphics/2215OS_11_18.jpg)'
- en: That's it for this chapter on postprocessing.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于后期处理的章节。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We talked about a lot of different postprocessing options in this chapter. As
    you saw, creating `THREE.EffectComposer` and chaining passes together is actually
    very easy. You just have to keep in mind a few things. Not all passes output to
    the screen. If you want to output to the screen, you can always use `THREE.ShaderPass`
    with `THREE.CopyShader`. The sequence in which you add passes to a composer is
    important. Effects are applied in that sequence. If you want to reuse the result
    from a specific `THREE.EffectComposer` instance, you can do this by using `THREE.TexturePass`.
    When you have more than one `THREE.RenderPass` in your `THREE.EffectComposer`,
    make sure to set the `clear` property to `false`. If not, you'll only see the
    output from the last `THREE.RenderPass` step. If you only want to apply an effect
    to a specific object, you can use `THREE.MaskPass`. When you're done with the
    mask, clear the mask with `THREE.ClearMaskPass`. Besides the standard passes provided
    by Three.js, there are also a large number of standard shaders available. You
    can use these together with `THREE.ShaderPass`. Creating custom shaders for postprocessing
    is very easy using the standard approach from Three.js. You only need to create
    a fragment shader.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了许多不同的后期处理选项。正如你所看到的，创建`THREE.EffectComposer`并将通道链接在一起实际上非常容易。你只需要记住一些事情。并非所有的通道都会输出到屏幕上。如果你想要输出到屏幕，你可以始终使用`THREE.ShaderPass`和`THREE.CopyShader`。向composer添加通道的顺序很重要。效果是按照这个顺序应用的。如果你想要重用来自特定`THREE.EffectComposer`实例的结果，你可以使用`THREE.TexturePass`。当你的`THREE.EffectComposer`中有多个`THREE.RenderPass`时，确保将`clear`属性设置为`false`。如果不这样做，你只会看到最后一个`THREE.RenderPass`步骤的输出。如果你只想对特定对象应用效果，你可以使用`THREE.MaskPass`。当你完成遮罩后，用`THREE.ClearMaskPass`清除遮罩。除了Three.js提供的标准通道之外，还有大量的标准着色器可用。你可以将这些与`THREE.ShaderPass`一起使用。使用Three.js的标准方法非常容易创建用于后期处理的自定义着色器。你只需要创建一个片段着色器。
- en: Until now, we pretty much covered everything there is to know about Three.js.
    For the next chapter, the last one, we'll look at a library called **Physijs**
    that you can use to extend Three.js with physics and apply collisions, gravity,
    and constraints.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们基本上涵盖了关于Three.js的所有知识。在下一章，也就是最后一章，我们将看一看一个名为**Physijs**的库，你可以用它来扩展Three.js的物理功能，并应用碰撞、重力和约束。

- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Basic AI and Enemy Behavior
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本AI和敌人行为
- en: Virtual scenarios need conflicts, consequences, and potential rewards to feel
    real. Without these three things, there's no incentive for the player to care
    about what happens to their in-game character, much less continue to play the
    game. And while there are plenty of game mechanics that deliver on one or more
    of these conditions, nothing beats an enemy that will seek you out and try to
    end your session.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟场景需要冲突、后果和潜在奖励才能感觉真实。没有这三样东西，玩家就没有动力去关心他们游戏中的角色发生了什么，更不用说继续玩游戏了。虽然有很多游戏机制可以满足这些条件中的一个或多个，但没有什么能比得上一个会寻找你并试图结束你游戏的敌人。
- en: Programming an intelligent enemy is no easy task, and often goes hand in hand
    with long working hours and frustration. However, Unity has built-in features,
    components, and classes we can use to design and implement AI systems in a more
    user-friendly way. These tools will push the first playable iteration of *Hero
    Born* over the finish line and provide a springboard for more advanced C# topics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个智能敌人并不容易，并且通常需要长时间的工作和挫折。然而，Unity内置了我们可以使用的功能、组件和类，以更用户友好的方式设计和实现AI系统。这些工具将推动*Hero
    Born*的第一个可玩版本完成，并为更高级的C#主题提供一个跳板。
- en: 'In this chapter, we''ll focus on the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注以下主题：
- en: The Unity navigation system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity导航系统
- en: Static objects and navigation meshes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态对象和导航网格
- en: Navigation agents
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航代理
- en: Procedural programming and logic
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序化编程和逻辑
- en: Taking and dealing damage
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承受和造成伤害
- en: Adding a loss condition
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加失败条件
- en: Refactoring and keeping it DRY
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构和保持DRY
- en: Let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Navigating 3D space in Unity
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Unity中导航3D空间
- en: When we talk about navigation in real life, it's usually a conversation about
    how to get from point A to point B. Navigating around virtual 3D space is largely
    the same, but how do we account for the experiential knowledge we humans have
    accumulated since the day we first started crawling? Everything from walking on
    a flat surface to climbing stairs and jumping off of curbs is a skill we learned
    by doing; how can we possibly program all that into a game without going insane?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论现实生活中的导航时，通常是关于如何从A点到B点的对话。在虚拟3D空间中导航基本上是一样的，但我们如何考虑自从我们第一次开始爬行以来积累的经验知识呢？从在平坦表面行走到爬楼梯和跳台阶，这些都是我们通过实践学会的技能；我们怎么可能在游戏中编程所有这些而不发疯呢？
- en: Before you can answer any of these questions, you'll need to know what navigation
    components Unity has to offer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在回答这些问题之前，您需要了解Unity提供了哪些导航组件。
- en: Navigation components
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航组件
- en: 'The short answer is that Unity has spent a lot of time perfecting its navigation
    system and delivering components that we can use to govern how playable and non-playable
    characters can get around. Each of the following components comes as standard
    with Unity and has complex features already built in:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的答案是，Unity花了很多时间完善其导航系统，并提供了我们可以用来控制可玩和不可玩角色如何移动的组件。以下每个组件都是Unity的标准组件，并且已经内置了复杂的功能：
- en: A **NavMesh** is essentially a map of the walkable surfaces in a given level;
    the NavMesh component itself is created from the level geometry in a process called
    baking. Baking a NavMesh into your level creates a unique project asset that holds
    the navigation data.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NavMesh**本质上是给定级别中可行走表面的地图；NavMesh组件本身是从级别几何中创建的，在一个称为烘焙的过程中。将NavMesh烘焙到您的级别中会创建一个持有导航数据的独特项目资产。'
- en: If a **NavMesh** is the level map, then a **NavMeshAgent** is the moving piece
    on the board. Any object with a NavMeshAgent component attached will automatically
    avoid other agents or obstacles it comes into contact with.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果**NavMesh**是级别地图，那么**NavMeshAgent**就是棋盘上的移动棋子。任何附有NavMeshAgent组件的对象都会自动避开其接触到的其他代理或障碍物。
- en: The navigation system needs to be aware of any moving or stationary objects
    in the level that could cause a NavMeshAgent to alter their route. Adding NavMeshObstacle
    components to those objects lets the system know that they need to be avoided.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航系统需要意识到级别中任何可能导致NavMeshAgent改变其路线的移动或静止对象。将NavMeshObstacle组件添加到这些对象可以让系统知道它们需要避开。
- en: While this description of the Unity navigation system is far from complete,
    it's enough for us to move forward with our enemy behavior. For this chapter,
    we'll be focusing on adding a NavMesh to our level, setting up the Enemy Prefab
    as a NavMeshAgent, and getting the Enemy Prefab to move along a predefined route
    in a seemingly intelligent way.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这对Unity导航系统的描述远非完整，但对于我们继续进行敌人行为已经足够了。在本章中，我们将专注于向我们的级别添加NavMesh，将敌人预制件设置为NavMeshAgent，并让敌人预制件以看似智能的方式沿着预定义路线移动。
- en: 'We''ll only be using the NavMesh and NavMeshAgent components in this chapter,
    but if you want to spice up your level, take a look at how to create obstacles
    here: [https://docs.unity3d.com/Manual/nav-CreateNavMeshObstacle.html](https://docs.unity3d.com/Manual/nav-CreateNavMeshObstacle.html).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只会使用NavMesh和NavMeshAgent组件，但如果您想为您的级别增添一些趣味，可以查看如何在这里创建障碍物：[https://docs.unity3d.com/Manual/nav-CreateNavMeshObstacle.html](https://docs.unity3d.com/Manual/nav-CreateNavMeshObstacle.html)。
- en: 'Your first task in setting up an "intelligent" enemy is to create a NavMesh
    over the arena''s walkable areas. Let''s set up and configure our level''s NavMesh:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置“智能”敌人的第一个任务是在竞技场的可行走区域上创建一个NavMesh。让我们设置和配置我们级别的NavMesh：
- en: Select the **Environment** GameObject, click on the arrow icon next to **Static**
    in the **Inspector** window, and choose **Navigation Static**:![](img/B17573_09_01.png)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**环境**游戏对象，单击**检视器**窗口中**静态**旁边的箭头图标，并选择**导航静态**：![](img/B17573_09_01.png)
- en: 'Figure 9.1: Setting objects to Navigation Static'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：将对象设置为导航静态
- en: Click **Yes, change children** when the dialog window pops up to set all the
    **Environment** child objects to **Navigation Static**:![](img/B17573_09_02.png)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**是，更改子对象**当对话框弹出时，将所有**环境**子对象设置为**导航静态**：![](img/B17573_09_02.png)
- en: 'Figure 9.2: Changing all child objects'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：更改所有子对象
- en: Go to **Window** | **AI** | **Navigation** and select the **Bake** tab. Leave
    everything set to their default values and click **Bake**. Once baking is finished,
    you'll see a new folder inside the **Scenes** folder with lighting, navigation
    mesh, and reflection probe data:![](img/B17573_09_03.png)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**窗口** | **AI** | **导航**，并选择**烘焙**选项卡。将所有设置保持为默认值，然后单击**烘焙**。烘焙完成后，你将在**场景**文件夹内看到一个新文件夹，其中包含照明、导航网格和反射探针数据：![](img/B17573_09_03.png)
- en: 'Figure 9.3: Baking navigation mesh'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：烘焙导航网格
- en: Every object in our level is now marked as **Navigation Static**, which means
    that our newly baked NavMesh has evaluated their accessibility based on its default
    NavMeshAgent settings. Everywhere you can see a light blue overlay in the preceding
    screenshot is a walkable surface for any object with a NavMeshAgent component
    attached, which is your next task.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们级别中的每个对象现在都标记为**导航静态**，这意味着我们新烘焙的NavMesh已根据其默认NavMeshAgent设置评估了它们的可访问性。在前面的屏幕截图中，你可以看到浅蓝色覆盖的地方是任何附有NavMeshAgent组件的对象的可行走表面，这是你的下一个任务。
- en: Setting up enemy agents
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置敌人代理
- en: 'Let''s register the Enemy Prefab as a NavMeshAgent:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将敌人预制件注册为NavMeshAgent：
- en: Select the Enemy Prefab in the **Prefabs** folder, click **Add Component** in
    the **Inspector** window, and search for **NavMesh Agent**:![](img/B17573_09_04.png)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**预制件**文件夹中选择敌人预制件，在**检视器**窗口中单击**添加组件**，并搜索**NavMesh Agent**：![](img/B17573_09_04.png)
- en: 'Figure 9.4: Adding a NavMeshAgent component'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：添加NavMeshAgent组件
- en: 'Click **+** **|** **Create Empty** from the **Hierarchy** window and name the
    GameObject `Patrol_Route`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**窗口中单击**+** **|** **创建空对象**，并将游戏对象命名为`Patrol_Route`：
- en: Select `Patrol_Route`, click **+** **|** **Create Empty** to add a child GameObject,
    and name it `Location_1`. Position `Location_1` in one of the corners of the level:![](img/B17573_09_05.png)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择`Patrol_Route`，单击**+** **|** **创建空对象**以添加一个子游戏对象，并将其命名为`Location_1`。将`Location_1`放置在级别的一个角落中：![](img/B17573_09_05.png)
- en: 'Figure 9.5: Creating an empty patrol route object'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：创建一个空的巡逻路线对象
- en: Create three more empty child objects in `Patrol_Route`, name them `Location_2`,
    `Location_3`, and `Location_4`, respectively, and position them in the remaining
    corners of the level to form a square:![](img/B17573_09_06.png)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Patrol_Route`中创建三个空的子对象，分别命名为`Location_2`，`Location_3`和`Location_4`，并将它们放置在级别的剩余角落，形成一个正方形：![](img/B17573_09_06.png)
- en: 'Figure 9.6: Creating all empty patrol route objects'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：创建所有空的巡逻路线对象
- en: Adding a NavMeshAgent component to the Enemy tells the NavMesh component to
    take notice and register it as an object that has access to its autonomous navigation
    features. Creating the four empty game objects in each corner of the level lays
    out the simple route we want our enemies to eventually patrol; grouping them in
    an empty parent object makes it easier to reference them in code and makes for
    a more organized Hierarchy window. All that's left is the code to make the enemy
    walk the patrol route, which you'll add in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 向敌人添加NavMeshAgent组件告诉NavMesh组件注意并将其注册为具有访问其自主导航功能的对象。在每个级别角落创建四个空游戏对象，布置我们希望敌人最终巡逻的简单路线；将它们分组在一个空的父对象中，使得在代码中更容易引用它们，并使得层次结构窗口更加有组织。现在剩下的就是编写代码让敌人走巡逻路线，这将在下一节中添加。
- en: Moving enemy agents
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动敌人代理
- en: 'Our patrol locations are set and the Enemy Prefab has a NavMeshAgent component,
    but now we need to figure out how to reference those locations and get the enemy
    moving on its own. To do that, we''ll first need to talk about an important concept
    in the world of software development: procedural programming.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的巡逻地点已经设置好，敌人预制件有一个NavMeshAgent组件，但现在我们需要找出如何引用这些地点并让敌人自行移动。为此，我们首先需要谈论软件开发世界中的一个重要概念：程序化编程。
- en: Procedural programming
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序化编程
- en: Even though it's in the name, the idea behind procedural programming can be
    elusive until you get your head around it; once you do, you'll never see a code
    challenge the same way.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在名称中有，但程序化编程的概念可能难以理解，直到你完全掌握它；一旦你掌握了，你就永远不会以相同的方式看待代码挑战。
- en: Any task that executes the same logic on one or more sequential objects is the
    perfect candidate for procedural programming. You already did a little procedural
    programming when you debugged arrays, lists, and dictionaries with `for` and `foreach`
    loops. Each time those looping statements were executed, you performed the same
    call to `Debug.Log()`, iterating over each item sequentially. The idea now is
    to use that skill to get a more useful outcome.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在一个或多个连续对象上执行相同逻辑的任务都是程序化编程的完美候选者。当你调试数组、列表和字典时，已经做了一些程序化编程，使用`for`和`foreach`循环。每次执行这些循环语句时，都会对每个项目进行相同的`Debug.Log()`调用，依次迭代每个项目。现在的想法是利用这种技能获得更有用的结果。
- en: One of the most common uses of procedural programming is adding items from one
    collection to another, often modifying them along the way. This works great for
    our purposes since we want to reference each child object in the `Patrol_Route`
    parent and store them in a list.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 程序化编程的最常见用途之一是将一个集合中的项目添加到另一个集合中，并在此过程中经常对其进行修改。这对我们的目的非常有效，因为我们希望引用`Patrol_Route`父对象中的每个子对象，并将它们存储在一个列表中。
- en: Referencing the patrol locations
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考巡逻地点
- en: 'Now that we understand the basics of procedural programming, it''s time to
    get a reference to our patrol locations and assign them to a usable list:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了程序化编程的基础知识，是时候获取对我们巡逻地点的引用，并将它们分配到一个可用的列表中了：
- en: 'Add the following code to `EnemyBehavior`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`EnemyBehavior`中：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Select `Enemy` and drag the `Patrol_Route` object from the **Hierarchy** window
    onto the **Patrol Route** variable in `EnemyBehavior`:![](img/B17573_09_07.png)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Enemy`，并将`Patrol_Route`对象从**层次结构**窗口拖放到`EnemyBehavior`中的**Patrol Route**变量上：![](img/B17573_09_07.png)
- en: 'Figure 9.7: Dragging Patrol_Route to the enemy script'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：将Patrol_Route拖到敌人脚本中
- en: Hit the arrow icon next to the **Locations** variable in the **Inspector** window
    and run the game to see the list populate:![](img/B17573_09_08.png)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**检视器**窗口中**位置**变量旁边的箭头图标，并运行游戏以查看列表填充：![](img/B17573_09_08.png)
- en: 'Figure 9.8: Testing procedural programming'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8：测试过程式编程
- en: 'Let''s break down the code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下代码：
- en: First, it declares a variable for storing the `PatrolRoute` empty parent GameObject.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，声明一个变量来存储`PatrolRoute`空父级GameObject。
- en: Then, it declares a `List` variable to hold all the child `Transform` components
    in `PatrolRoute`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，声明一个`List`变量来保存`PatrolRoute`中所有子`Transform`组件。
- en: After that, it uses `Start()` to call the `InitializePatrolRoute()` method when
    the game begins.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，它使用`Start()`在游戏开始时调用`InitializePatrolRoute()`方法。
- en: 'Next, it creates `InitializePatrolRoute()` as a private utility method to procedurally
    fill `Locations` with `Transform` values:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建`InitializePatrolRoute()`作为一个私有的实用方法，以过程化地填充`Locations`与`Transform`值：
- en: Remember that not including an access modifier makes variables and methods `private`
    by default.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，不包括访问修饰符会使变量和方法默认为`private`。
- en: 'Then, we use a `foreach` statement to loop through each child GameObject in
    `PatrolRoute` and reference its Transform component:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`foreach`语句循环遍历`PatrolRoute`中的每个子GameObject并引用其Transform组件：
- en: Each Transform component is captured in the local `child` variable declared
    in the `foreach` loop.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个Transform组件都在`foreach`循环中声明的本地`child`变量中捕获。
- en: 'Finally, we add each sequential `child` `Transform` component to the list of
    locations using the `Add()` method as we loop through the child objects in `PatrolRoute`:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过使用`Add()`方法将每个顺序的`child` `Transform`组件添加到位置列表中，以便在`PatrolRoute`中循环遍历子对象时使用。
- en: This way, no matter what changes we make in the **Hierarchy** window, `Locations`
    will always be filled in with all the `child` objects under the `PatrolRoute`
    parent.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这样，无论我们在**Hierarchy**窗口中做出什么更改，`Locations`都将始终填充所有`PatrolRoute`父级下的`child`对象。
- en: While we could have assigned each location GameObject to `Locations` by dragging
    and dropping them directly from the **Hierarchy** window into the **Inspector**
    window, it's easy to lose or break these connections; making changes to the location
    object names, object additions or deletions, or project updates can all throw
    a wrench into a class's initialization. It's much safer, and more readable, to
    procedurally fill GameObject lists or arrays in the `Start()` method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以通过直接从**Hierarchy**窗口将每个位置GameObject分配给`Locations`，通过拖放的方式，但是很容易丢失或破坏这些连接；对位置对象名称进行更改、对象的添加或删除，或项目的更新都可能导致类的初始化出现问题。通过在`Start()`方法中以过程化的方式填充GameObject列表或数组，更加安全和可读。
- en: Due to that reasoning, I also tend to use `GetComponent()` in the `Start()`
    method to find and store component references attached to a given class instead
    of assigning them in the **Inspector** window.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，我也倾向于在`Start()`方法中使用`GetComponent()`来查找并存储附加到给定类的组件引用，而不是在**Inspector**窗口中分配它们。
- en: Now, we need the enemy object to follow the patrol route we laid out, which
    is your next task.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要让敌人对象按照我们制定的巡逻路线移动，这是你的下一个任务。
- en: Moving the enemy
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动敌人
- en: With a list of patrol locations initialized on `Start()`, we can grab the enemy
    NavMeshAgent component and set its first destination.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Start()`中初始化了一个巡逻位置列表后，我们可以获取敌人NavMeshAgent组件并设置它的第一个目的地。
- en: 'Update `EnemyBehavior` with the following code and hit play:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`EnemyBehavior`使用以下代码并点击播放：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s break down the code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下代码：
- en: First, it adds the `UnityEngine.AI` `using` directive so that `EnemyBehavior`
    has access to Unity's navigation classes, in this case, `NavMeshAgent`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，添加`UnityEngine.AI`的`using`指令，以便`EnemyBehavior`可以访问Unity的导航类，这种情况下是`NavMeshAgent`。
- en: Then, it declares a variable to keep track of which patrol location the enemy
    is currently walking toward. Since `List` items are zero-indexed, we can have
    the Enemy Prefab move between patrol points in the order they are stored in `Locations`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，声明一个变量来跟踪敌人当前正在向其行走的巡逻位置。由于`List`项是从零开始索引的，我们可以让Enemy Prefab在`Locations`中存储的顺序中移动巡逻点之间移动。
- en: Next, it declares a variable to store the NavMeshAgent component attached to
    the Enemy GameObject. This is `private` because no other classes should be able
    to access or modify it.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明一个变量来存储附加到Enemy GameObject的NavMeshAgent组件。这是`private`的，因为没有其他类应该能够访问或修改它。
- en: After that, it uses `GetComponent()` to find and return the attached NavMeshAgent
    component to the agent.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，它使用`GetComponent()`来查找并返回附加的NavMeshAgent组件给代理。
- en: Then, it calls the `MoveToNextPatrolLocation()` method on `Start()`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`Start()`方法中调用`MoveToNextPatrolLocation()`方法。
- en: 'Finally, it declares `MoveToNextPatrolLocation()` as a private method and sets
    `_agent.destinat``ion`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，声明`MoveToNextPatrolLocation()`为一个私有方法并设置`_agent.destinat``ion`：
- en: '`destination` is a `Vector3` position in 3D space.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destination`是3D空间中的`Vector3`位置。'
- en: '`Locations[_locationIndex]` grabs the Transform item in `Locations` at a given
    index.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Locations[_locationIndex]`获取`Locations`中给定索引处的Transform项。'
- en: Adding `.position` references the Transform component's `Vector3` position.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`.position`引用了Transform组件的`Vector3`位置。
- en: Now, when our scene starts, locations are filled with patrol points and `MoveToNextPatrolLocation()`
    is called to set the destination position of the NavMeshAgent component to the
    first item at `_locationIndex 0` in the list of locations. The next step is to
    have the enemy object move from the first patrol location to all the other locations
    in sequence.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们的场景开始时，位置被填充了巡逻点，并且`MoveToNextPatrolLocation()`被调用以将NavMeshAgent组件的目标位置设置为位置列表中的第一个项目`_locationIndex
    0`。下一步是让敌人对象从第一个巡逻位置移动到所有其他位置。
- en: Our enemy moves to the first patrol point just fine, but then it stops. What
    we want is for it to continually move between each sequential location, which
    will require additional logic in `Update()` and `MoveToNextPatrolLocation()`.
    Let's create this behavior.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的敌人移动到第一个巡逻点没问题，但然后停下了。我们希望它能够在每个顺序位置之间持续移动，这将需要在`Update()`和`MoveToNextPatrolLocation()`中添加额外的逻辑。让我们创建这个行为。
- en: 'Add the following code to `EnemyBehavior` and hit play:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码到`EnemyBehavior`并点击播放：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s break down the code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下代码：
- en: 'First, it declares the `Update()` method and adds an `if` statement to check
    whether two different conditions are true:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它声明`Update()`方法，并添加一个`if`语句来检查两个不同条件是否为真：
- en: '`remainingDistance` returns how far the NavMeshAgent component currently is
    from its set destination`,` so we''re checking if that is less than 0.2.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remainingDistance`返回NavMeshAgent组件当前距离其设定目的地的距离，所以我们检查是否小于0.2。'
- en: '`pathPending` returns a `true` or `false` Boolean, depending on whether Unity
    is computing a path for the NavMeshAgent component.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pathPending`根据Unity是否为NavMeshAgent组件计算路径返回`true`或`false`布尔值。'
- en: If _`agent` is very close to its destination, and no other path is being computed,
    the `if` statement returns `true` and calls `MoveToNextPatrolLocation()`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`_agent`非常接近目的地，并且没有其他路径正在计算，`if`语句将返回`true`并调用`MoveToNextPatrolLocation()`。
- en: 'Here, we added an `if` statement to make sure that `Locations` isn''t empty
    before the rest of the code in `MoveToNextPatrolLocation()` is executed:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个`if`语句来确保在执行`MoveToNextPatrolLocation()`中的其余代码之前，`Locations`不为空：
- en: If `Locations` is empty, we use the `return` keyword to exit the method without
    continuing.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Locations`为空，我们使用`return`关键字退出方法而不继续执行。
- en: This is referred to as defensive programming, and, coupled with refactoring,
    it is an essential skill to have in your arsenal as you move toward more intermediate
    C# topics. We will consider refactoring at the end of the chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为防御性编程，结合重构，这是在向更中级的C#主题迈进时必不可少的技能。我们将在本章末考虑重构。
- en: 'Then, we set `_locationIndex` to its current value, `+1`, followed by the modulo
    (`%`) of `Locations.Count`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`_locationIndex`设置为它的当前值，`+1`，然后取`Locations.Count`的模(`%`)：
- en: This will increment the index from 0 to 4 and then restart it at 0 so that our
    Enemy Prefab moves in a continuous path.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将使索引从0增加到4，然后重新从0开始，这样我们的敌人预制就会沿着连续的路径移动。
- en: The modulo operator returns the remainder of two values being divided—2 divided
    by 4 has a remainder of 2 when the result is an integer, so 2 % 4 = 2\. Likewise,
    4 divided by 4 has no remainder, so 4 % 4 = 0.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模运算符返回两个值相除的余数——当结果为整数时，2除以4的余数为2，所以2 % 4 = 2。同样，4除以4没有余数，所以4 % 4 = 0。
- en: Dividing an index by the maximum number of items in a collection is a quick
    way to always find the next item. If you're rusty on the modulo operator, revisit
    *Chapter 2*, *The Building Blocks of Programming*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将索引除以集合中的最大项目数是一种快速找到下一个项目的方法。如果你对模运算符不熟悉，请回顾*第2章*，*编程的基本组成部分*。
- en: We now need to check that the enemy is moving toward its set patrol location
    every frame in `Update()`; when it gets close, `MoveToNextPatrolLocation()` is
    fired, which increments `_locationIndex` and sets the next patrol point as the
    destination.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在`Update()`中每帧检查敌人是否朝着设定的巡逻位置移动；当它靠近时，将触发`MoveToNextPatrolLocation()`，这会增加`_locationIndex`并将下一个巡逻点设置为目的地。
- en: 'If you drag the **Scene** view down next to the **Console** window, as shown
    in the following screenshot, and hit play, you can watch the Enemy Prefab walk
    around the corners of the level in a continuous loop:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将**Scene**视图拖到**Console**窗口旁边，如下截图所示，然后点击播放，你可以看到敌人预制在关卡的拐角处连续循环行走：
- en: '![](img/B17573_09_09.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_09_09.png)'
- en: 'Figure 9.9: Testing the enemy patrol route'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：测试敌人巡逻路线
- en: The enemy now follows the patrol route around the outside of the map, but it
    doesn't seek out the player and attack when it's within a preset range. You'll
    use the NavAgent component to do just that in the next section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人现在沿着地图外围巡逻路线，但当它在预设范围内时，它不会寻找玩家并发动攻击。在下一节中，您将使用NavAgent组件来做到这一点。
- en: Enemy game mechanics
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人游戏机制
- en: Now that our enemy is on a continuous patrol circuit, it's time to give it some
    interaction mechanics of its own; there wouldn't be much risk or reward if we
    left it walking around with no way to act against us.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的敌人正在持续巡逻，是时候给它一些互动机制了；如果我们让它一直在走动而没有对抗我们的方式，那就没有太多的风险或回报了。
- en: 'Seek and destroy: changing the agent''s destination'
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找并摧毁：改变代理的目的地
- en: In this section, we'll be focusing on switching the target of the enemies' NavMeshAgent
    component when the player gets too close and dealing damage if a collision occurs.
    When the enemy successfully lowers the player's health, it will return to its
    patrol route until its next run-in with the player.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于在玩家靠近时切换敌人NavMeshAgent组件的目标，并在发生碰撞时造成伤害。当敌人成功降低玩家的健康时，它将返回到巡逻路线，直到下一次与玩家相遇。
- en: However, we're not going to leave our player helpless; we'll also add in code
    to track enemy health, detect when an enemy is successfully hit with one of the
    player's bullets, and when an enemy needs to be destroyed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会让我们的玩家束手无策；我们还将添加代码来跟踪敌人的健康状况，检测敌人是否成功被玩家的子弹击中，以及何时需要摧毁敌人。
- en: Now that the Enemy Prefab is moving around on patrol, we need to get a reference
    to the player's position and change the destination of NavMeshAgent if it gets
    too close.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在敌人预制正在巡逻移动，我们需要获取玩家位置的引用，并在它靠近时改变NavMeshAgent的目的地。
- en: 'Add the following code to `EnemyBehavior`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`EnemyBehavior`中：
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s break down the code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解这段代码：
- en: First, it declares a `public` variable to hold the `Player` capsule's `Transform`
    value.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它声明一个`public`变量来保存`Player`胶囊体的`Transform`值。
- en: 'Then, we use `GameObject.Find("Player")` to return a reference to the player
    object in the scene:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`GameObject.Find("Player")`来返回场景中玩家对象的引用：
- en: Adding `.transform` directly references the object's `Transform` value in the
    same line.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接添加`.transform`引用了同一行中对象的`Transform`值。
- en: Finally, we set `_agent.destination` to the player's `Vector3` position in `OnTriggerEnter()`
    whenever the player enters the enemies' attack zone that we set up earlier with
    a Collider component.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`OnTriggerEnter()`中，当玩家进入我们之前设置的敌人攻击区域时，我们将`_agent.destination`设置为玩家的`Vector3`位置。
- en: If you play the game now and get too close to the patrolling enemy, you'll see
    that it breaks from its path and comes straight for you. Once it reaches the player,
    the code in the `Update()` method takes over again and the Enemy Prefab resumes
    its patrol.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在玩游戏并离巡逻的敌人太近，你会发现它会中断原来的路径直接向你走来。一旦它到达玩家，`Update()`方法中的代码将再次接管，敌人预制件将恢复巡逻。
- en: We still need the enemy to be able to hurt the player in some way, which we'll
    learn how to do in the next section.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要让敌人以某种方式伤害玩家，我们将在下一节中学习如何做到这一点。
- en: Lowering player health
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 降低玩家生命值
- en: While our enemy mechanic has come a long way, it's still anti-climactic to have
    nothing happen when the Enemy Prefab collides with the player Prefab. To fix this,
    we'll tie in the new enemy mechanics with the game manager.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的敌人机制已经取得了长足的进步，但当敌人预制件与玩家预制件发生碰撞时什么都不发生仍然让人失望。为了解决这个问题，我们将新的敌人机制与游戏管理器联系起来。
- en: 'Update `PlayerBehavior` with the following code and hit play:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码更新`PlayerBehavior`并点击播放：
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s break down the code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下代码：
- en: First, it declares a `private` variable to hold the reference to the instance
    of `GameBehavior` we have in the scene.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它声明一个`private`变量来保存我们在场景中拥有的`GameBehavior`实例的引用。
- en: 'Then, it finds and returns the `GameBehavior` script that''s attached to the
    `Game Manager` object in the scene:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它找到并返回附加到场景中的`Game Manager`对象的`GameBehavior`脚本：
- en: Using `GetComponent()` on the same line as `GameObject.Find()` is a common way
    to cut down on unnecessary lines of code.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一行上使用`GetComponent()`和`GameObject.Find()`是减少不必要的代码行的常见方法。
- en: Since our player is the object being collided with, it makes sense to declare
    `OnCollisionEnter()` in `PlayerBehavior`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的玩家是发生碰撞的对象，因此在`PlayerBehavior`中声明`OnCollisionEnter()`是有道理的。
- en: Next, we check for the name of the colliding object; if it's the Enemy Prefab,
    we execute the body of the `if` statement.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们检查碰撞对象的名称；如果是敌人预制件，我们执行`if`语句的主体。
- en: Finally, we subtract `1` from the public `HP` variable using the `_gameManager`
    instance.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`_gameManager`实例从公共`HP`变量中减去`1`。
- en: Whenever the enemy now tracks and collides with the player, the game manager
    will fire the set property on HP. The UI will update with a new value for player
    health, which means we have an opportunity to put in some additional logic for
    the loss condition later on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每当敌人跟踪并与玩家发生碰撞时，游戏管理器将触发HP的设置属性。UI将使用新的玩家生命值更新，这意味着我们有机会为失败条件后期添加一些额外的逻辑。
- en: Detecting bullet collisions
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测子弹碰撞
- en: Now that we have our loss condition, it's time to add in a way for our player
    to fight back and survive enemy attacks.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了失败条件，是时候为我们的玩家添加一种反击敌人攻击并幸存下来的方式了。
- en: 'Open up `EnemyBehavior` and modify it with the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`EnemyBehavior`并使用以下代码进行修改：
- en: '[PRE5]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s break down the code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下代码：
- en: First, it declares a `private int` variable called `_lives` with a `public`
    backing variable called `EnemyLives`. This will let us control how `EnemyLives`
    is referenced and set, just like in `GameBehavior`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它声明了一个名为`_lives`的`private int`变量，并声明了一个名为`EnemyLives`的`public`后备变量。这将使我们能够控制`EnemyLives`的引用和设置方式，就像在`GameBehavior`中一样。
- en: Then, we set the `get` property to always return `_lives`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`get`属性设置为始终返回`_lives`。
- en: Next, we use `private set` to assign the new value of `EnemyLives` to `_lives`
    to keep them both in sync.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`private set`将`EnemyLives`的新值分配给`_lives`，以保持它们两者同步。
- en: We haven't seen `private get` or `set` before, but they can have their access
    modifiers, just like any other executable code. Declaring `get` or `set` as `private`
    means that only the parent class has access to their functionality.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前没有见过`private get`或`set`，但它们可以像任何其他可执行代码一样具有访问修饰符。将`get`或`set`声明为`private`意味着只有父类才能访问它们的功能。
- en: 'Then, we add an `if` statement to check whether `_lives` is less than or equal
    to 0, meaning that the enemy should be dead:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个`if`语句来检查`_lives`是否小于或等于0，这意味着敌人应该死了：
- en: When that's the case, we destroy the `Enemy` GameObject and print out a message
    to the console.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们销毁`Enemy`游戏对象并在控制台上打印一条消息。
- en: Because `Enemy` is the object getting hit with bullets, it's sensible to include
    a check for those collisions in `EnemyBehavior` with `OnCollisionEnter()`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为`Enemy`是被子弹击中的对象，所以在`EnemyBehavior`中包含对这些碰撞的检查是合理的，使用`OnCollisionEnter()`。
- en: Finally, if the name of the colliding object matches a bullet clone object,
    we decrement `EnemyLives` by `1` and print out another message.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果碰撞对象的名称与子弹克隆对象匹配，我们将`EnemyLives`减少`1`并打印出另一条消息。
- en: Notice that the name we're checking for is `Bullet(Clone)`, even though our
    bullet Prefab is named `Bullet`. This is because Unity adds the `(Clone)` suffix
    to any object created with the `Instantiate()` method, which is how we made them
    in our shooting logic.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们检查的名称是`Bullet(Clone)`，即使我们的子弹预制件的名称是`Bullet`。这是因为Unity会在使用`Instantiate()`方法创建的任何对象后添加`(Clone)`后缀，而我们的射击逻辑就是这样创建的。
- en: You can also check for the GameObjects' tag, but since that's a Unity-specific
    feature, we're going to leave the code as-is and do things with pure C#.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以检查游戏对象的标签，但由于这是Unity特有的功能，我们将保持代码不变，只用纯C#来处理事情。
- en: Now, the player can fight back when the enemy tries to take one of its lives
    by shooting it three times and destroying it. Again, our use of the `get` and
    `set` properties to handle additional logic proves to be a flexible and scalable
    solution. With that done, your final task is to update the game manager with a
    loss condition.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，玩家可以在敌人试图夺取其生命时进行反击，射击三次并摧毁敌人。再次，我们使用`get`和`set`属性来处理额外的逻辑，证明这是一个灵活且可扩展的解决方案。完成这些后，你的最后任务是更新游戏管理器的失败条件。
- en: Updating the game manager
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新游戏管理器
- en: 'To fully implement the loss condition, we need to update the manager class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全实现失败条件，我们需要更新管理器类：
- en: 'Open up `GameBehavior` and add the following code:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GameBehavior`并添加以下代码：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the **Hierarchy** window, right-click on **Win Condition**, choose **Duplicate**,
    and name it **Loss Condition**:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**窗口中，右键单击**Win Condition**，选择**Duplicate**，并将其命名为**Loss Condition**：
- en: Click the arrow to the left of **Loss Condition** to expand it, select the **Text**
    object, and change the text to **You lose...**
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击**Loss Condition**左侧的箭头以展开它，选择**Text**对象，并将文本更改为**You lose...**
- en: Select **Game_Manager** in the **Hierarchy** window and drag **Loss Condition**
    into the **Loss Button** slot in the **Game Behavior (Script)** component:![](img/B17573_09_11.png)
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**窗口中选择**Game_Manager**，并将**Loss Condition**拖放到**Game Behavior（Script）**组件中的**Loss
    Button**插槽中：![](img/B17573_09_11.png)
- en: 'Figure 9.10: Game behavior script with text and button variables completed
    in the Inspector pane'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：在检查器窗格中完成了带有文本和按钮变量的游戏行为脚本
- en: 'Let''s break down the code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: First, we declare a new button that we want to show when the player loses the
    game.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们声明了一个新的按钮，当玩家输掉游戏时我们想要显示它。
- en: 'Then, we add in an `if` statement to check when `_playerHP` drops below `0`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个`if`语句来检查`_playerHP`何时下降到`0`以下：
- en: If it's `true`, `ProgessText` and `Time.timeScale` are updated and the loss
    button is activated.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果为`true`，则更新`ProgessText`和`Time.timeScale`，并激活失败按钮。
- en: 'If the player is still alive following an enemy collision, `ProgessText` shows
    a different message: "Ouch… that''s got to hurt.".'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家在敌人碰撞后仍然存活，`ProgessText`会显示不同的消息：“哎呀...那一定很疼。”。
- en: Now, change _`playerHP` to 1 in `GameBehavior.cs` and get the Enemy Prefab to
    collide with you and observe what happens.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`GameBehavior.cs`中将`_playerHP`更改为1，并让敌人预制件与您发生碰撞，观察发生了什么。
- en: That's a wrap! You've successfully added a "smart" enemy that can damage the
    player and be damaged right back, as well as a loss screen through the game manager.
    Before we finish this chapter, there's one more important topic that we need to
    discuss, and that's how to avoid repeating code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！您已成功添加了一个可以对玩家造成伤害并受到反击的“智能”敌人，以及通过游戏管理器的失败界面。在我们完成本章之前，还有一个重要的主题需要讨论，那就是如何避免重复的代码。
- en: Repeated code is the bane of all programmers, so it makes sense that you learn
    how to keep it out of your projects early on!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 重复的代码是所有程序员的梦魇，因此学会如何在项目中尽早避免它是有意义的！
- en: Refactoring and keeping it DRY
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构和保持DRY
- en: 'The **Don''t Repeat Yourself** (**DRY**) acronym is the software developer''s
    conscience: it tells you when you''re in danger of making a bad or questionable
    decision, and gives you a feeling of satisfaction after a job well done.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要重复自己**（DRY）首字母缩写是软件开发者的良心：它告诉您何时有可能做出糟糕或可疑的决定，并在工作完成后给您一种满足感。'
- en: In practice, repeated code is part of programming life. Trying to avoid it by
    constantly thinking ahead will put up so many roadblocks in your project that
    it won't seem worthwhile carrying on. A more efficient—and sane—approach to dealing
    with repeating code is to quickly identify it when and where it occurs and then
    look for the best way to remove it. This task is called refactoring, and our `GameBehavior`
    class could use a little of its magic right now.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，重复的代码是编程生活的一部分。试图通过不断思考未来来避免它会在项目中设置许多障碍，这似乎不值得继续。处理重复代码的更有效和理智的方法是快速识别它何时何地发生，然后寻找最佳的移除方法。这个任务被称为重构，我们的`GameBehavior`类现在可以使用一些它的魔力。
- en: You may have noticed that we set the progress text and timescale in two separate
    places, but we could easily make ourselves a utility method to do this for us
    in a single place.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们在两个不同的地方设置了进度文本和时间刻度，但我们可以很容易地在一个地方为自己创建一个实用方法来完成这些工作。
- en: 'To refactor the existing code, you''ll need to update `GameBehavior.cs` as
    follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要重构现有的代码，您需要按照以下步骤更新`GameBehavior.cs`：
- en: '[PRE7]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s break down the code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: We declared a new method called `UpdateScene`, which takes in a string parameter
    that we want to assign to `ProgressText` and sets `Time.timeScale` to `0`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明了一个名为`UpdateScene`的新方法，它接受一个字符串参数，我们想要将其分配给`ProgressText`，并将`Time.timeScale`设置为`0`。
- en: We deleted our first instance of duplicated code and used our new method to
    update our scene when the game is won.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们删除了重复代码的第一个实例，并使用我们的新方法在游戏获胜时更新了场景。
- en: We deleted our second instance of duplicated code and update the scene when
    the game is lost.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们删除了重复代码的第二个实例，并在游戏失败时更新了场景。
- en: There's always more to refactor if you look in the right places.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在正确的地方寻找，总是有更多的重构工作可以做。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With that, our enemy and player interactions are complete. We can dish out damage
    as well as take it, lose lives, and fight back, all while updating the on-screen
    GUI. Our enemies use Unity's navigation system to walk around the arena and change
    to attack mode when within a specified range of the player. Each GameObject is
    responsible for its behavior, internal logic, and object collisions, while the
    game manager keeps track of the variables that govern the game's state. Lastly,
    we learned about simple procedural programming and how much cleaner code can be
    when repeated instructions are abstracted out into their methods.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们的敌人和玩家互动就完成了。我们可以造成伤害，也可以承受伤害，失去生命，并进行反击，同时更新屏幕上的GUI。我们的敌人使用Unity的导航系统在竞技场周围行走，并在玩家指定范围内时切换到攻击模式。每个GameObject负责其行为、内部逻辑和对象碰撞，而游戏管理器则跟踪管理游戏状态的变量。最后，我们学习了简单的过程式编程，以及当重复指令被抽象成它们的方法时，代码可以变得更加清晰。
- en: You should feel a sense of accomplishment at this point, especially if you started
    this book as a total beginner. Getting up to speed with a new programming language
    while building a working game is no easy trick. In the next chapter, you'll be
    introduced to some intermediate topics in C#, including new type modifiers, method
    overloading, interfaces, and class extensions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您应该感到有所成就，特别是如果您作为一个完全的初学者开始阅读本书。在构建一个可工作的游戏的同时熟悉一种新的编程语言并不容易。在下一章中，您将被介绍一些C#中级主题，包括新的类型修饰符、方法重载、接口和类扩展。
- en: Pop quiz – AI and navigation
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小测验-人工智能和导航
- en: How is a NavMesh component created in a Unity scene?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity场景中如何创建NavMesh组件？
- en: What component identifies a GameObject to a NavMesh?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么组件将GameObject标识为NavMesh？
- en: Executing the same logic on one or more sequential objects is an example of
    which programming technique?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个或多个连续对象上执行相同的逻辑是哪种编程技术的例子？
- en: What does the DRY acronym stand for?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DRY首字母缩写代表什么？
- en: JOIN us on Discord!
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户一起阅读这本书，与Unity/C#专家和Harrison Ferrone一起阅读。提出问题，为其他读者提供解决方案，通过*问我任何事*与作者交流，以及更多内容。
- en: Join Now!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 立即加入！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code_9781801813945.png)'

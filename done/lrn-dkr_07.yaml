- en: Data Volumes and Configuration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据卷和配置
- en: In the last chapter, we learned how to build and share our own container images.
    Particular focus was placed on how to build images that are as small as possible
    by only containing artifacts that are really needed by the containerized application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何构建和共享我们自己的容器镜像。特别关注了如何通过只包含容器化应用程序真正需要的构件来尽可能地减小镜像的大小。
- en: In this chapter, we are going to learn how we can work with stateful containers—that
    is, containers that consume and produce data. We will also learn how to configure
    our containers at runtime and at image build time, using environment variables
    and config files.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何处理有状态的容器，即消耗和产生数据的容器。我们还将学习如何使用环境变量和配置文件在运行时和构建时配置容器。
- en: 'Here is a list of the topics we''re going to discuss:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将讨论的主题列表：
- en: Creating and mounting data volumes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和挂载数据卷
- en: Sharing data between containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器之间共享数据
- en: Using host volumes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用主机卷
- en: Defining volumes in images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在镜像中定义卷
- en: Configuring containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置容器
- en: 'After working through this chapter, you will be able to do the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将能够做到以下事项：
- en: Create, delete, and list data volumes.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、删除和列出数据卷。
- en: Mount an existing data volume into a container.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有的数据卷挂载到容器中。
- en: Create durable data from within a container using a data volume.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器内部使用数据卷创建持久化数据。
- en: Share data between multiple containers using data volumes.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据卷在多个容器之间共享数据。
- en: Mount any host folder into a container using data volumes.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据卷将任何主机文件夹挂载到容器中。
- en: Define the access mode (read/write or read-only) for a container when accessing
    data in a data volume.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义容器访问数据卷中数据的访问模式（读/写或只读）。
- en: Configure environment variables for applications running in a container.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为在容器中运行的应用程序配置环境变量。
- en: Parametrize a `Dockerfile` by using build arguments.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用构建参数对`Dockerfile`进行参数化。
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you need either Docker Toolbox installed on your machine or
    access to a Linux **virtual machine** (**VM**) running Docker on your laptop or
    in the cloud. Furthermore, it is advantageous to have Docker for Desktop installed
    on your machine. There is no code accompanying this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您需要在您的机器上安装Docker Toolbox或者访问在您的笔记本电脑或云中运行Docker的Linux虚拟机（VM）。此外，最好在您的机器上安装Docker
    for Desktop。本章没有附带任何代码。
- en: Creating and mounting data volumes
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和挂载数据卷
- en: All meaningful applications consume or produce data. Yet containers are, preferably,
    meant to be stateless. How are we going to deal with this? One way is to use Docker
    volumes. Volumes allow containers to consume, produce, and modify a state. Volumes
    have a life cycle that goes beyond the life cycle of containers. When a container
    that uses a volume dies, the volume continues to exist. This is great for the
    durability of the state.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有有意义的应用程序都会消耗或产生数据。然而，容器最好是无状态的。我们该如何处理这个问题呢？一种方法是使用Docker卷。卷允许容器消耗、产生和修改状态。卷的生命周期超出了容器的生命周期。当使用卷的容器死亡时，卷仍然存在。这对状态的持久性非常有利。
- en: Modifying the container layer
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改容器层
- en: 'Before we dive into volumes, let''s first discuss what happens if an application
    in a container changes something in the filesystem of the container. In this case,
    the changes are all happening in the writable container layer that we introduced
    in [Chapter 3](d9bb597d-2b32-4144-b068-564d85bcdf68.xhtml), *Mastering Containers*.
    Let''s quickly demonstrate this by running a container, and execute a script in
    it that is creating a new file, like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论卷之前，让我们首先讨论一下如果容器中的应用程序更改了容器文件系统中的内容会发生什么。在这种情况下，更改都发生在我们在《精通容器》[第3章](d9bb597d-2b32-4144-b068-564d85bcdf68.xhtml)中介绍的可写容器层中。我们可以通过运行一个容器并在其中执行一个创建新文件的脚本来快速演示这一点，就像这样：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding command creates a container named `demo`, and, inside this container,
    creates a file called `sample.txt` with the content `This is a test`. The container
    exits after running the `echo` command but remains in memory, available for us
    to do our investigations. Let''s use the `diff` command to find out what has changed
    in the container''s filesystem in relation to the filesystem of the original image,
    as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令创建了一个名为`demo`的容器，并在该容器内创建了一个名为`sample.txt`的文件，内容为`This is a test`。运行`echo`命令后容器退出，但仍保留在内存中，供我们进行调查。让我们使用`diff`命令来查找容器文件系统中与原始镜像文件系统相关的更改，如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output should look like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Evidently, a new file, as indicated by the `A`, has been added to the filesystem of
    the container, as expected. Since all layers that stem from the underlying image
    (`alpine`, in this case) are immutable, the change could only happen in the writeable
    container layer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如`A`所示，容器的文件系统中已经添加了一个新文件，这是预期的。由于所有源自基础镜像（在本例中为`alpine`）的层都是不可变的，更改只能发生在可写容器层中。
- en: Files that have changed compared to the original image will be marked with a
    `C`, and those that have been deleted, with a `D`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始镜像相比发生了变化的文件将用`C`标记，而已删除的文件将用`D`标记。
- en: If we now remove the container from memory, its container layer will also be
    removed, and with it, all the changes will be irreversibly deleted. If we need
    our changes to persist even beyond the lifetime of the container, this is not
    a solution. Luckily, we have better options, in the form of Docker volumes. Let's
    get to know them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在从内存中删除容器，它的容器层也将被删除，所有更改将被不可逆转地删除。如果我们需要我们的更改持久存在，甚至超出容器的生命周期，这不是一个解决方案。幸运的是，我们有更好的选择，即Docker卷。让我们来了解一下它们。
- en: Creating volumes
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建卷
- en: 'Since at this time, when using Docker for Desktop on a macOS or Windows computer,
    containers are not running natively on macOS or Windows but rather in a (hidden)
    VM created by Docker for Desktop, for illustrative purposes it is best we use `docker-machine` to
    create and use an explicit VM running Docker. At this point, we assume that you
    have Docker Toolbox installed on your system. If not, then please go back to [Chapter
    2](99a92fe1-4652-4934-9c33-f3e19483afcd.xhtml), *Setting up a Working Environment,* where
    we provide detailed instructions on how to install Toolbox:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在这个时候，在macOS或Windows计算机上使用Docker for Desktop时，容器并不是在macOS或Windows上本地运行，而是在Docker
    for Desktop创建的（隐藏的）VM中运行，为了说明问题，最好使用`docker-machine`来创建和使用运行Docker的显式VM。在这一点上，我们假设您已经在系统上安装了Docker
    Toolbox。如果没有，请返回到[第2章](99a92fe1-4652-4934-9c33-f3e19483afcd.xhtml)《设置工作环境》中，我们提供了如何安装Toolbox的详细说明：
- en: 'Use `docker-machine` to list all VMs currently running in VirtualBox, as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker-machine`列出当前在VirtualBox中运行的所有虚拟机，如下所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you do not have a VM called `node-1` listed, then please create one with
    the following command:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的列表中没有名为`node-1`的VM，请使用以下命令创建一个：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Refer back to [Chapter 2](99a92fe1-4652-4934-9c33-f3e19483afcd.xhtml), *Setting
    up a Working Environment*, on how to create a Hyper-V-based VM with `docker-machine`
    if you are running on Windows with Hyper-V enabled.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在启用了Hyper-V的Windows上运行，可以参考[第2章](99a92fe1-4652-4934-9c33-f3e19483afcd.xhtml)
    *设置工作环境*中的内容，了解如何使用`docker-machine`创建基于Hyper-V的VM。
- en: 'If, on the other hand, you have a VM called `node-1` but it is not running,
    then please start it, as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，如果您有一个名为`node-1`的VM，但它没有运行，请按以下方式启动它：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that everything is ready, use `docker-machine` to SSH into this VM, like
    this:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，使用`docker-machine`以这种方式SSH到这个VM：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should be greeted by this welcome image:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该会看到这个欢迎图片：
- en: '![](assets/223cb246-5c36-42aa-8905-22913d6642ba.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/223cb246-5c36-42aa-8905-22913d6642ba.png)'
- en: docker-machine VM welcome message
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: docker-machine VM欢迎消息
- en: 'To create a new data volume, we can use the `docker volume create` command.
    This will create a named volume that can then be mounted into a container and
    used for persistent data access or storage. The following command creates a volume
    called `sample`, using the default volume driver:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新的数据卷，我们可以使用`docker volume create`命令。这将创建一个命名卷，然后可以将其挂载到容器中，用于持久数据访问或存储。以下命令创建一个名为`sample`的卷，使用默认卷驱动程序：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The default volume driver is the so-called local driver, which stores the data
    locally in the host filesystem.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的卷驱动程序是所谓的本地驱动程序，它将数据存储在主机文件系统中。
- en: 'The easiest way to find out where the data is stored on the host is by using
    the `docker volume inspect` command on the volume we just created. The actual
    location can differ from system to system, and so, this is the safest way to find
    the target folder. You can see this command in the following code block:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出主机上存储数据的最简单方法是使用`docker volume inspect`命令查看我们刚刚创建的卷。实际位置可能因系统而异，因此这是找到目标文件夹的最安全方法。您可以在以下代码块中看到这个命令：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The host folder can be found in the output under `Mountpoint`. In our case,
    when using `docker-machine` with a LinuxKit-based VM running in VirtualBox, the
    folder is `/mnt/sda1/var/lib/docker/volumes/sample/_data`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 主机文件夹可以在输出中的`Mountpoint`下找到。在我们的情况下，当使用基于LinuxKit的VM在VirtualBox中运行`docker-machine`时，文件夹是`/mnt/sda1/var/lib/docker/volumes/sample/_data`。
- en: The target folder is often a protected folder, and we thus might need to use `sudo` to
    navigate to this folder and execute any operations in it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 目标文件夹通常是受保护的文件夹，因此我们可能需要使用`sudo`来导航到这个文件夹并在其中执行任何操作。
- en: On our LinuxKit-based VM in Docker Toolbox, access is also denied, yet we don't
    have `sudo` available either. Is that the end of our exploration?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们基于LinuxKit的VM中，Docker Toolbox中，访问也被拒绝，但我们也没有`sudo`。我们的探索到此为止了吗？
- en: Luckily not; I have prepared a `fundamentalsofdocker/nsenter` utility container that
    allows us to access the backing folder of our `sample` volume we created earlier.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我已经准备了一个`fundamentalsofdocker/nsenter`实用程序容器，允许我们访问我们之前创建的`sample`卷的后备文件夹。
- en: 'We need to run this container in `privileged` mode to get access to this protected
    part of the filesystem, like this:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要以`privileged`模式运行此容器，以访问文件系统的受保护部分，就像这样：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We are running the container with the `--privileged` flag. This means that any
    app running in the container gets access to the devices of the host. The `--pid=host` flag
    signifies that the container is allowed to access the process tree of the host
    (the hidden VM in which the Docker daemon is running). Now, the preceding container
    runs the Linux `nsenter` tool to enter the Linux namespace of the host and then
    runs a shell within there. From this shell, we are thus granted access to all
    resources managed by the host.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`--privileged`标志运行容器。这意味着在容器中运行的任何应用程序都可以访问主机的设备。`--pid=host`标志表示容器被允许访问主机的进程树（Docker守护程序运行的隐藏VM）。现在，前面的容器运行Linux
    `nsenter`工具以进入主机的Linux命名空间，然后在其中运行一个shell。通过这个shell，我们因此被授予对主机管理的所有资源的访问权限。
- en: 'When running the container, we basically execute the following command inside
    the container:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行容器时，我们基本上在容器内执行以下命令：
- en: '`nsenter -t 1 -m -u -n -i sh`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`nsenter -t 1 -m -u -n -i sh`'
- en: If that sounds complicated to you, don't worry; you will understand more as
    we proceed through this book. If there is one takeaway for you out of this, then
    it is to realize how powerful the right use of containers can be.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对你来说听起来很复杂，不用担心；随着我们在本书中的学习，你会更多地理解。如果有一件事可以让你受益，那就是意识到正确使用容器可以有多强大。
- en: 'From within this container, we can now navigate to the folder representing
    the mount point of the volume, and then list its content, as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器内部，我们现在可以导航到代表卷挂载点的文件夹，然后列出其内容，如下所示：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The folder is currently empty since we have not yet stored any data in the volume.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未在卷中存储任何数据，该文件夹目前为空。
- en: Exit the tool container by pressing *Ctrl* + *D*.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按下*Ctrl* + *D*退出工具容器。
- en: There are other volume drivers available from third parties, in the form of
    plugins. We can use the `--driver` parameter in the `create` command to select
    a different volume driver. Other volume drivers use different types of storage
    systems to back a volume, such as cloud storage, **Network File System** (**NFS**)
    drives, software-defined storage, and more. The discussion of the correct usage
    of other volume drivers is beyond the scope of this book, though.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他来自第三方的卷驱动程序，以插件的形式提供。我们可以在`create`命令中使用`--driver`参数来选择不同的卷驱动程序。其他卷驱动程序使用不同类型的存储系统来支持卷，例如云存储、网络文件系统（NFS）驱动、软件定义存储等。然而，正确使用其他卷驱动程序的讨论超出了本书的范围。
- en: Mounting a volume
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂载卷
- en: 'Once we have created a named volume, we can mount it into a container by following
    these steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了一个命名卷，我们可以按照以下步骤将其挂载到容器中：
- en: 'For this, we can use the `-v` parameter in the `docker container run` command,
    like this:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，我们可以在`docker container run`命令中使用`-v`参数，如下所示：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding command mounts the `sample` volume to the `/data` folder inside
    the container.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将`sample`卷挂载到容器内的`/data`文件夹。
- en: 'Inside the container, we can now create files in the `/data` folder and then
    exit, as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器内，我们现在可以在`/data`文件夹中创建文件，然后退出，如下所示：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we navigate to the host folder that contains the data of the volume and
    list its content, we should see the two files we just created inside the container
    (remember: we need to use the `fundamentalsofdocker/nsenter` tool container to
    do so), as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们导航到包含卷数据的主机文件夹并列出其内容，我们应该看到我们刚刚在容器内创建的两个文件（记住：我们需要使用`fundamentalsofdocker/nsenter`工具容器来这样做），如下所示：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can even try to output the content of, say, the second file, like this:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们甚至可以尝试输出，比如说，第二个文件的内容，如下所示：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s try to create a file in this folder from the host, and then use the
    volume with another container, like this:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试从主机在这个文件夹中创建一个文件，然后像这样使用另一个容器的卷：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Exit the tool container by pressing *Ctrl* + *D*.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按下*Ctrl* + *D*退出工具容器。
- en: 'Now, let''s delete the `test` container, and run another one based on CentOS.
    This time, we are even mounting our volume to a different container folder, `/app/data`,
    like this:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们删除`test`容器，并基于CentOS运行另一个容器。这次，我们甚至将我们的卷挂载到不同的容器文件夹`/app/data`中，就像这样：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once inside the `centos` container, we can navigate to the `/app/data` folder
    to which we have mounted the volume, and list its content, as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入`centos`容器，我们可以导航到我们已经挂载卷的`/app/data`文件夹，并列出其内容，如下所示：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As expected, we should see these three files:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们应该看到这三个文件：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is the definitive proof that data in a Docker volume persists beyond the
    lifetime of a container, and also, that volumes can be reused by other, even different,
    containers from the one that used it first.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据在Docker卷中持久存在超出容器生命周期的明确证据，也就是说，卷可以被其他甚至不同的容器重复使用，而不仅仅是最初使用它的容器。
- en: It is important to note that the folder inside the container to which we mount
    a Docker volume is excluded from the Union filesystem. That is, each change inside
    this folder and any of its subfolders will not be part of the container layer,
    but will be persisted in the backing storage provided by the volume driver. This
    fact is really important since the container layer is deleted when the corresponding
    container is stopped and removed from the system.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在容器内部挂载Docker卷的文件夹被排除在Union文件系统之外。也就是说，该文件夹及其任何子文件夹内的每个更改都不会成为容器层的一部分，而是将持久保存在卷驱动程序提供的后备存储中。这一事实非常重要，因为当相应的容器停止并从系统中删除时，容器层将被删除。
- en: Exit the `centos` container with *Ctrl* + *D*. Now, exit the `node-1` VM by
    pressing *Ctrl* + *D* again.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *D*退出`centos`容器。现在，再次按*Ctrl* + *D*退出`node-1`虚拟机。
- en: Removing volumes
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除卷
- en: 'Volumes can be removed using the `docker volume rm` command. It is important
    to remember that removing a volume destroys the containing data irreversibly,
    and thus is to be considered a dangerous command. Docker helps us a bit in this
    regard, as it does not allow us to delete a volume that is still in use by a container.
    Always make sure before you remove or delete a volume that you either have a backup
    of its data or you really don''t need this data anymore. Let''s see how to remove
    volumes by following these steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`docker volume rm`命令删除卷。重要的是要记住，删除卷会不可逆地销毁包含的数据，因此应该被视为危险命令。在这方面，Docker在一定程度上帮助了我们，因为它不允许我们删除仍然被容器使用的卷。在删除卷之前，一定要确保要么有数据的备份，要么确实不再需要这些数据。让我们看看如何按照以下步骤删除卷：
- en: 'The following command deletes our `sample` volume that we created earlier:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令删除了我们之前创建的`sample`卷：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After executing the preceding command, double-check that the folder on the host
    has been deleted.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行上述命令后，仔细检查主机上的文件夹是否已被删除。
- en: 'To remove all running containers in order to clean up the system, run the following
    command:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了清理系统，删除所有正在运行的容器，运行以下命令：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that by using the `-v` or `--volume` flag in the command you use to remove
    a container, you can ask the system to also remove any volume associated with
    that particular container. Of course, that will only work if the particular volume
    is only used by this container.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在用于删除容器的命令中使用`-v`或`--volume`标志，您可以要求系统同时删除与该特定容器关联的任何卷。当然，这只有在特定卷只被该容器使用时才有效。
- en: In the next section, we will show how we can access the backing folder of a
    volume when working with Docker for Desktop.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示在使用Docker for Desktop时如何访问卷的后备文件夹。
- en: Accessing volumes created with Docker for Desktop
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问使用Docker for Desktop创建的卷
- en: 'Follow these steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤：
- en: 'Let''s create a `sample` volume and inspect it using Docker for Desktop on
    our macOS or Windows machine, like this:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个`sample`卷并使用我们的macOS或Windows机器上的Docker for Desktop进行检查，就像这样：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Mountpoint` is shown as `/var/lib/docker/volumes/sample/_data`, but you
    will discover that there is no such folder on your macOS or Windows machine. The
    reason is that the path shown is in relation to the hidden VM that Docker for
    Windows uses to run containers. At this time, Linux containers cannot run natively
    on macOS, nor on Windows.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mountpoint`显示为`/var/lib/docker/volumes/sample/_data`，但您会发现在您的macOS或Windows机器上没有这样的文件夹。原因是显示的路径是与Docker
    for Windows用于运行容器的隐藏VM相关的。此时，Linux容器无法在macOS或Windows上本地运行。'
- en: 'Next, let''s generate two files with data in the volume from within an `alpine`
    container. To run the container and mount the sample `volume` to the `/data` folder
    of the container, use the following code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们从`alpine`容器内部生成两个带有卷数据的文件。要运行容器并将示例`volume`挂载到容器的`/data`文件夹，请使用以下代码：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Generate two files in the `/data` folder inside the container, like this:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器内的`/data`文件夹中生成两个文件，就像这样：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Exit the `alpine` container by pressing *Ctrl + D*.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*Ctrl + D*退出`alpine`容器。
- en: As mentioned earlier, we cannot directly access the backing folder of the `sample`
    volume from our macOS or from Windows. This is because the volume is in the hidden
    VM running on macOS or Windows that is used to run the Linux container in Docker
    for Desktop.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们无法直接从我们的macOS或Windows访问`sample`卷的支持文件夹。这是因为该卷位于macOS或Windows上运行的隐藏VM中，该VM用于在Docker
    for Desktop中运行Linux容器。
- en: To access that hidden VM from our macOS, we have two options. We can either
    use a special container and run it in privileged mode, or we can use the `screen`
    utility to screen into the Docker driver. The first method is also applicable
    to Docker for Windows.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的macOS访问隐藏的VM，我们有两个选项。我们可以使用特殊容器并以特权模式运行它，或者我们可以使用`screen`实用程序来筛选Docker驱动程序。第一种方法也适用于Windows的Docker。
- en: 'Let''s start with the first method mentioned, by running a container from the `fundamentalsofdocker/nsenter` image.
    We have been using this container already in the previous section. Run the following
    code:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从运行容器的`fundamentalsofdocker/nsenter`镜像开始尝试提到的第一种方法。我们在上一节中已经在使用这个容器。运行以下代码：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can now navigate to the folder backing our `sample` volume, like this:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以导航到支持我们`sample`卷的文件夹，就像这样：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s see what is in this folder by running this code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行此代码来查看此文件夹中有什么：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s try to create a file from within this special container, and then list
    the content of the folder, as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试从这个特殊容器内创建一个文件，然后列出文件夹的内容，如下所示：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: And now, we have the files in the backing folder of the `sample` volume.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在`sample`卷的支持文件夹中有了文件。
- en: To exit our special privileged container, we can just press *Ctrl* + *D*.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要退出我们的特权容器，只需按*Ctrl* + *D*。
- en: 'Now that we have explored the first option, and if you''re using macOS, let''s
    try the `screen` tool, as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经探索了第一种选项，如果您使用的是macOS，让我们尝试`screen`工具，如下所示：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'By doing so, we will be greeted by an empty screen. Hit *Enter*, and a `docker-desktop:~#` command-line
    prompt will be displayed. We can now navigate to the volume folder, like this:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样做，我们将会看到一个空屏幕。按*Enter*，将显示一个`docker-desktop:~#`命令行提示符。现在我们可以导航到卷文件夹，就像这样：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s create another file with some data in it, and then list the content
    of the folder, as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建另一个带有一些数据的文件，然后列出文件夹的内容，如下所示：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To exit this session with the Docker VM, press *Ctrl* + *A* + *K*.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要退出Docker VM的会话，请按*Ctrl* + *A* + *K*。
- en: 'We have now created data using three different methods, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经使用三种不同的方法创建了数据，如下所示：
- en: From within a container that has a `sample` volume mounted.
  id: totrans-128
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从已挂载`sample`卷的容器内部。
- en: Using a special privileged folder to access the hidden VM used by Docker for
    Desktop, and directly writing into the backing folder of the `sample` volume.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特权文件夹来访问Docker for Desktop使用的隐藏虚拟机，并直接写入`sample`卷的后备文件夹。
- en: Only on macOS, using the `screen` utility to enter into the hidden VM, and also directly
    writing into the backing folder of the `sample` volume.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在macOS上，使用`screen`实用程序进入隐藏的虚拟机，并直接写入`sample`卷的后备文件夹。
- en: Sharing data between containers
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器之间共享数据
- en: Containers are like sandboxes for the applications running inside them. This
    is mostly beneficial and wanted, in order to protect applications running in different
    containers from each other. It also means that the whole filesystem visible to
    an application running inside a container is private to this application, and
    no other application running in a different container can interfere with it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 容器就像应用程序在其中运行的沙盒。这在很大程度上是有益的和需要的，以保护运行在不同容器中的应用程序。这也意味着对于在容器内运行的应用程序可见的整个文件系统对于这个应用程序是私有的，其他在不同容器中运行的应用程序不能干扰它。
- en: At times, though, we want to share data between containers. Say an application
    running in container A produces some data that will be consumed by another application
    running in container B. *How can we achieve this?* Well, I'm sure you've already
    guessed it—we can use Docker volumes for this purpose. We can create a volume
    and mount it to container A, as well as to container B. In this way, both applications
    A and B have access to the same data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们想要在容器之间共享数据。假设在容器A中运行的应用程序生成了一些数据，将被在容器B中运行的另一个应用程序使用。*我们该如何实现这一点？*好吧，我相信你已经猜到了——我们可以使用Docker卷来实现这一目的。我们可以创建一个卷，并将其挂载到容器A，以及容器B。这样，应用程序A和B都可以访问相同的数据。
- en: 'Now, as always when multiple applications or processes concurrently access
    data, we have to be very careful to avoid inconsistencies. To avoid concurrency
    problems such as race conditions, we ideally have only one application or process
    that is creating or modifying data, while all other processes concurrently accessing
    this data only read it. We can enforce a process running in a container to only
    be able to read the data in a volume by mounting this volume as read-only. Have
    a look at the following command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当多个应用程序或进程同时访问数据时，我们必须非常小心以避免不一致。为了避免并发问题，如竞争条件，理想情况下只有一个应用程序或进程创建或修改数据，而所有其他进程同时访问这些数据只读取它。我们可以通过将卷作为只读挂载来强制在容器中运行的进程只能读取卷中的数据。看一下以下命令：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, we create a container called `writer` that has a volume, `shared-data`,
    mounted in default read/write mode:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`writer`的容器，它有一个卷`shared-data`，以默认的读/写模式挂载：
- en: 'Try to create a file inside this container, like this:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在这个容器内创建一个文件，就像这样：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It should succeed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该成功。
- en: 'Exit this container, and then execute the following command:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出这个容器，然后执行以下命令：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: And we have a container called `reader` that has the same volume mounted as **read-only** (`ro`).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`reader`的容器，它有相同的卷挂载为**只读**(`ro`)。
- en: 'Firstly, make sure you can see the file created in the first container, like
    this:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确保你能看到在第一个容器中创建的文件，就像这样：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, try to create a file, like this:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，尝试创建一个文件，就像这样：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It will fail with the following message:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 它将失败，并显示以下消息：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s exit the container by typing `exit` at the Command Prompt. Back on the
    host, let''s clean up all containers and volumes, as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在命令提示符处输入`exit`来退出容器。回到主机上，让我们清理所有容器和卷，如下所示：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once this is done, exit the `docker-machine` VM by also typing `exit` at the
    Command Prompt. You should be back on your Docker for Desktop. Use `docker-machine` to
    stop the VM, like this:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，通过在命令提示符处输入 exit 退出 docker-machine VM。您应该回到您的 Docker for Desktop。使用 docker-machine
    停止 VM，就像这样：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Next, we will show how to mount arbitrary folders from the Docker host into
    a container.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将展示如何将 Docker 主机中的任意文件夹挂载到容器中。
- en: Using host volumes
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用主机卷
- en: 'In certain scenarios, such as when developing new containerized applications
    or when a containerized application needs to consume data from a certain folder
    produced—say—by a legacy application, it is very useful to use volumes that mount
    a specific host folder. Let''s look at the following example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，比如开发新的容器化应用程序或者容器化应用程序需要从某个文件夹中消耗数据——比如说——由传统应用程序产生，使用挂载特定主机文件夹的卷非常有用。让我们看下面的例子：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding expression interactively starts an `alpine` container with a shell
    and mounts the `src` subfolder of the current directory into the container at `/app/src`.
    We need to use `$(pwd)` (or ``pwd``, for that matter), which is the current directory,
    as when working with volumes, we always need to use absolute paths.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式交互式地启动一个带有 shell 的 alpine 容器，并将当前目录的 src 子文件夹挂载到容器的 /app/src。我们需要使用 $(pwd)（或者
    ``pwd``，无论哪种方式），即当前目录，因为在使用卷时，我们总是需要使用绝对路径。
- en: Developers use these techniques all the time when they are working on their
    application that runs in a container, and want to make sure that the container
    always contains the latest changes they make to the code, without the need to
    rebuild the image and rerun the container after each change.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员在他们在容器中运行的应用程序上工作时，经常使用这些技术，并希望确保容器始终包含他们对代码所做的最新更改，而无需在每次更改后重新构建镜像和重新运行容器。
- en: 'Let''s make a sample to demonstrate how that works. Let''s say we want to create
    a simple static website using nginx as our web server as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个示例来演示它是如何工作的。假设我们想要使用 nginx 创建一个简单的静态网站作为我们的 web 服务器，如下所示：
- en: 'First, let''s create a new folder on the host, where we will put our web assets—such
    as HTML, CSS, and JavaScript files—and navigate to it, like this:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在主机上创建一个新的文件夹，我们将把我们的网页资产—如 HTML、CSS 和 JavaScript 文件—放在其中，并导航到它，就像这样：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we create a simple web page, like this:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个简单的网页，就像这样：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, we add a `Dockerfile` that will contain instructions on how to build the
    image containing our sample website.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们添加一个 `Dockerfile`，其中包含构建包含我们示例网站的镜像的说明。
- en: 'Add a file called `Dockerfile` to the folder, with this content:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件夹中添加一个名为 `Dockerfile` 的文件，内容如下：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `Dockerfile` starts with the latest Alpine version of nginx, and then copies
    all files from the current host directory into the `/usr/share/nginx/html` containers
    folder. This is where nginx expects web assets to be located.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 以最新的 Alpine 版本的 nginx 开始，然后将当前主机目录中的所有文件复制到 /usr/share/nginx/html
    容器文件夹中。这是 nginx 期望网页资产位于的位置。
- en: 'Now, let''s build the image with the following command:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们用以下命令构建镜像：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And finally, we run a container from this image. We will run the container
    in detached mode, like this:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们从这个镜像中运行一个容器。我们将以分离模式运行容器，就像这样：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note the `-p 8080:80` parameter. We haven't discussed this yet, but we will
    do it in detail in [Chapter 10](f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml), *Single-Host
    Networking*. At the moment, just know that this maps the container port `80` on
    which nginx is listening for incoming requests to port `8080` of your laptop,
    where you can then access the application.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `-p 8080:80` 参数。我们还没有讨论这个，但我们将在第10章《单主机网络》中详细讨论。目前，只需知道这将把 nginx 监听传入请求的容器端口
    80 映射到您的笔记本电脑的端口 8080，然后您可以访问应用程序。
- en: Now, open a browser tab and navigate to `http://localhost:8080/index.html`,
    and you should see your website, which currently consists only of a title, `Personal
    Website`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开一个浏览器标签，导航到`http://localhost:8080/index.html`，你应该看到你的网站，目前只包括一个标题，`个人网站`。
- en: 'Now, edit the `index.html` file in your favorite editor, to look like this:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在你喜欢的编辑器中编辑`index.html`文件，使其看起来像这样：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, save it, and then refresh the browser. Oh! That didn''t work. The browser
    still displays the previous version of the `index.html` file, which consists only
    of the title. So, let''s stop and remove the current container, then rebuild the
    image, and rerun the container, as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在保存它，然后刷新浏览器。哦！那没用。浏览器仍然显示`index.html`文件的先前版本，只包括标题。所以，让我们停止并删除当前容器，然后重建镜像，并重新运行容器，如下所示：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This time, when you refresh the browser, the new content should be shown. Well,
    it worked, but there is way too much friction involved. Imagine you have to do
    this each and every time that you make a simple change to your website. That's
    not sustainable.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当你刷新浏览器时，新内容应该显示出来。好吧，它起作用了，但涉及的摩擦太多了。想象一下，每次对网站进行简单更改时都要这样做。这是不可持续的。
- en: 'Now is the time to use host-mounted volumes. Once again, remove the current
    container and rerun it with the volume mount, like this:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是使用主机挂载卷的时候了。再次删除当前容器，并使用卷挂载重新运行它，就像这样：
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, append some more content to the `index.html` file, and save it. Then, refresh
    your browser. You should see the changes. And this is exactly what we wanted to
    achieve; we also call this an *edit-and-continue* experience. You can make as
    many changes in your web files and always immediately see the result in the browser,
    without having to rebuild the image and restart the container containing your
    website.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向`index.html`文件追加一些内容，并保存。然后，刷新你的浏览器。你应该看到变化。这正是我们想要实现的；我们也称之为*编辑和继续*体验。你可以对网页文件进行任意更改，并立即在浏览器中看到结果，而无需重建镜像和重新启动包含你的网站的容器。
- en: It is important to note that the updates are now propagated bi-directionally.
    If you make changes on the host, they will be propagated to the container, and
    vice versa. Also important is the fact that when you mount the current folder
    into the container target folder, `/usr/share/nginx/html`, the content that is
    already there is replaced by the content of the host folder.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，更新现在是双向传播的。如果你在主机上进行更改，它们将传播到容器，反之亦然。同样重要的是，当你将当前文件夹挂载到容器目标文件夹`/usr/share/nginx/html`时，已经存在的内容将被主机文件夹的内容替换。
- en: Defining volumes in images
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在镜像中定义卷
- en: 'If we go for a moment back to what we have learned about containers in [Chapter
    3](d9bb597d-2b32-4144-b068-564d85bcdf68.xhtml), *Mastering Containers,* then we
    have this: the filesystem of each container, when started, is made up of the immutable
    layers of the underlying image, plus a writable container layer specific to this
    very container. All changes that the processes running inside the container make
    to the filesystem will be persisted in this container layer. Once the container
    is stopped and removed from the system, the corresponding container layer is deleted
    from the system and irreversibly lost.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下我们在[第3章](d9bb597d-2b32-4144-b068-564d85bcdf68.xhtml)中学到的关于容器的知识，*掌握容器*，那么我们有这样的情况：每个容器的文件系统在启动时由底层镜像的不可变层和特定于该容器的可写容器层组成。容器内运行的进程对文件系统所做的所有更改都将持久保存在该容器层中。一旦容器停止并从系统中删除，相应的容器层将从系统中删除并且不可逆地丢失。
- en: Some applications, such as databases running in containers, need to persist
    their data beyond the lifetime of the container. In this case, they can use volumes.
    To make things a bit more explicit, let's look at a concrete example. MongoDB
    is a popular open source document database. Many developers use MongoDB as a storage
    service for their applications. The maintainers of MongoDB have created an image
    and published it on Docker Hub, which can be used to run an instance of the database
    in a container. This database will be producing data that needs to be persisted
    long term, but the MongoDB maintainers do not know who uses this image and how
    it is used. So, they have no influence over the `docker container run` command
    with which the users of the database will start this container. *How can they
    now define volumes?*
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序，比如在容器中运行的数据库，需要将它们的数据持久保存超出容器的生命周期。在这种情况下，它们可以使用卷。为了更加明确，让我们看一个具体的例子。MongoDB是一个流行的开源文档数据库。许多开发人员使用MongoDB作为他们应用程序的存储服务。MongoDB的维护者已经创建了一个镜像，并将其发布到Docker
    Hub，可以用来在容器中运行数据库的实例。这个数据库将产生需要长期持久保存的数据，但MongoDB的维护者不知道谁使用这个镜像以及它是如何被使用的。因此，他们对于用户启动这个容器的`docker
    container run`命令没有影响。*他们现在如何定义卷呢？*
- en: 'Luckily, there is a way of defining volumes in the `Dockerfile`. The keyword
    to do so is `VOLUME`, and we can either add the absolute path to a single folder
    or a comma-separated list of paths. These paths represent folders of the container''s
    filesystem. Let''s look at a few samples of such volume definitions, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在`Dockerfile`中有一种定义卷的方法。这样做的关键字是`VOLUME`，我们可以添加单个文件夹的绝对路径或逗号分隔的路径列表。这些路径代表容器文件系统的文件夹。让我们看一些这样的卷定义示例，如下：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first line in the preceding snippet defines a single volume to be mounted
    at `/app/data`. The second line defines three volumes as a comma-separated list.
    The last one defines the same as the second line, but this time, the value is
    formatted as a JSON array.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前面片段中的第一行定义了一个要挂载到`/app/data`的单个卷。第二行定义了三个卷作为逗号分隔的列表。最后一个与第二行定义相同，但这次值被格式化为JSON数组。
- en: When a container is started, Docker automatically creates a volume and mounts
    it to the corresponding target folder of the container for each path defined in
    the `Dockerfile`. Since each volume is created automatically by Docker, it will
    have an SHA-256 as its ID.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器启动时，Docker会自动创建一个卷，并将其挂载到`Dockerfile`中定义的每个路径对应的容器目标文件夹。由于每个卷都是由Docker自动创建的，它将有一个SHA-256作为其ID。
- en: At container runtime, the folders defined as volumes in the `Dockerfile` are
    excluded from the Union filesystem, and thus any changes in those folders do not
    change the container layer but are persisted to the respective volume. It is now
    the responsibility of the operations engineers to make sure that the backing storage
    of the volumes is properly backed up.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器运行时，在`Dockerfile`中定义为卷的文件夹被排除在联合文件系统之外，因此这些文件夹中的任何更改都不会改变容器层，而是持久保存到相应的卷中。现在，运维工程师有责任确保卷的后备存储得到适当备份。
- en: 'We can use the `docker image inspect` command to get information about the
    volumes defined in the `Dockerfile`. Let''s see what MongoDB gives us by following
    these steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`docker image inspect`命令来获取关于`Dockerfile`中定义的卷的信息。让我们按照以下步骤来看看MongoDB给我们的信息：
- en: 'First, we pull the image with the following command:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用以下命令拉取镜像：
- en: '[PRE49]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we inspect this image, and use the `--format` parameter to only extract
    the essential part from the massive amount of data, as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们检查这个镜像，并使用`--format`参数来从大量数据中提取必要的部分，如下：
- en: '[PRE50]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note the `| jq .` at the end of the command. We are piping the output of `docker
    image inspect` into the `jq` tool, which nicely formats the output. If you haven't
    installed `jq` yet on your system, you can do so with `brew install jq` on your
    macOS, or with `choco install jq` on Windows.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意命令末尾的`| jq .`。我们正在将`docker image inspect`的输出导入`jq`工具，它会很好地格式化输出。如果您尚未在系统上安装`jq`，您可以在macOS上使用`brew
    install jq`，或在Windows上使用`choco install jq`来安装。
- en: 'The preceding command will return the following result:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将返回以下结果：
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Evidently, the `Dockerfile` for MongoDB defines two volumes at `/data/configdb` and `/data/db`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，MongoDB的`Dockerfile`在`/data/configdb`和`/data/db`定义了两个卷。
- en: 'Now, let''s run an instance of MongoDB in the background as a daemon, as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们作为后台守护进程运行一个MongoDB实例，如下所示：
- en: '[PRE52]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We can now use the `docker container inspect` command to get information about
    the volumes that have been created, among other things.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用`docker container inspect`命令获取有关已创建的卷等信息。
- en: 'Use this command to just get the volume information:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令只获取卷信息：
- en: '[PRE53]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The preceding command should output something like this (shortened):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令应该输出类似这样的内容（缩短）：
- en: '[PRE54]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that the values of the `Name` and `Source` fields have been trimmed for
    readability. The `Source` field gives us the path to the host directory, where
    the data produced by the MongoDB inside the container will be stored.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了便于阅读，`Name`和`Source`字段的值已被修剪。`Source`字段为我们提供了主机目录的路径，MongoDB在容器内生成的数据将存储在其中。
- en: That's it for the moment about volumes. In the next section, we will explore
    how we can configure applications running in containers, and the container image
    build process itself.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 目前关于卷的内容就是这些。在下一节中，我们将探讨如何配置在容器中运行的应用程序，以及容器镜像构建过程本身。
- en: Configuring containers
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置容器
- en: More often than not, we need to provide some configuration to the application
    running inside a container. The configuration is often used to allow one and the
    same container to run in very different environments, such as in development,
    test, staging, or production environments.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 往往我们需要为容器内运行的应用程序提供一些配置。配置通常用于允许同一个容器在非常不同的环境中运行，例如开发、测试、暂存或生产环境。
- en: In Linux, configuration values are often provided via environment variables.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，通常通过环境变量提供配置值。
- en: We have learned that an application running inside a container is completely
    shielded from its host environment. Thus, the environment variables that we see
    on the host are different from the ones that we see from within a container.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，在容器内运行的应用程序与其主机环境完全隔离。因此，在主机上看到的环境变量与在容器内看到的环境变量是不同的。
- en: 'Let''s prove that by first looking at what is defined on our host:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下在我们的主机上定义了什么：
- en: 'Use this command:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此命令：
- en: '[PRE55]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'On my macOS, I see something like this (shortened):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的macOS上，我看到类似这样的东西（缩短）：
- en: '[PRE56]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, let''s run a shell inside an `alpine` container, and list the environment
    variables we see there, as follows:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在`alpine`容器内运行一个shell，并列出我们在那里看到的环境变量，如下所示：
- en: '[PRE57]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The preceding output we see from the `export` command is evidently totally different
    than what we saw directly on the host.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`export`命令看到的前面的输出显然与我们直接在主机上看到的完全不同。
- en: Hit *Ctrl* + *D* to leave the `alpine` container.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *D*离开`alpine`容器。
- en: Next, let's define environment variables for containers.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为容器定义环境变量。
- en: Defining environment variables for containers
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为容器定义环境变量
- en: 'Now, the good thing is that we can actually pass some configuration values
    into the container at start time. We can use the `--env` (or the short form, `-e`)
    parameter in the form `--env <key>=<value>` to do so, where `<key>` is the name
    of the environment variable and `<value>` represents the value to be associated
    with that variable. Let''s assume we want the app that is to be run in our container
    to have access to an environment variable called `LOG_DIR`, with the value `/var/log/my-log`.
    We can do so with this command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，好处是我们实际上可以在启动时将一些配置值传递到容器中。我们可以使用`--env`（或简写形式`-e`）参数以`--env <key>=<value>`的形式这样做，其中`<key>`是环境变量的名称，`<value>`表示与该变量关联的值。假设我们希望在容器中运行的应用程序能够访问名为`LOG_DIR`的环境变量，其值为`/var/log/my-log`。我们可以使用以下命令来实现：
- en: '[PRE58]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The preceding code starts a shell in an `alpine` container and defines the
    requested environment inside the running container. To prove that this is true,
    we can execute this command inside the `alpine` container:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在`alpine`容器中启动了一个shell，并在运行的容器内定义了所请求的环境。为了证明这是真的，我们可以在`alpine`容器内执行这个命令：
- en: '[PRE59]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The output looks as expected. We now indeed have the requested environment variable
    with the correct value available inside the container.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来如预期的那样。我们现在确实在容器内有了所请求的环境变量和正确的值。
- en: 'We can, of course, define more than just one environment variable when we run
    a container. We just need to repeat the `--env` (or `-e`) parameter. Have a look
    at this sample:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当我们运行容器时，我们可以定义多个环境变量。我们只需要重复`--env`（或`-e`）参数。看一下这个示例：
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If we do a list of the environment variables now, we see the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在列出环境变量，我们会看到以下内容：
- en: '[PRE61]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Let's now look at situations where we have many environment variables to configure.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看一下我们有许多环境变量需要配置的情况。
- en: Using configuration files
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用配置文件
- en: Complex applications can have many environment variables to configure, and thus
    our command to run the corresponding container can quickly become unwieldy. For
    this purpose, Docker allows us to pass a collection of environment variable definitions
    as a file, and we have the `--env-file` parameter in the `docker container run` command.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的应用程序可能有许多环境变量需要配置，因此我们运行相应容器的命令可能会变得难以控制。为此，Docker允许我们将环境变量定义作为文件传递，并且我们在`docker
    container run`命令中有`--env-file`参数。
- en: 'Let''s try this out, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一下，如下所示：
- en: 'Create a `fod/05` folder and navigate to it, like this:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`fod/05`文件夹并导航到它，就像这样：
- en: '[PRE62]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Use your favorite editor to create a file called `development.config` in this
    folder. Add the following content to the file, and save it, as follows:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的编辑器在此文件夹中创建一个名为`development.config`的文件。将以下内容添加到文件中，并保存如下：
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Notice how we have the definition of a single environment variable per line
    in the format `<key>=<value>`, where, once again, `<key>` is the name of the environment
    variable, and `<value>` represents the value to be associated with that variable.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们每行定义一个环境变量的格式是`<key>=<value>`，其中，再次，`<key>`是环境变量的名称，`<value>`表示与该变量关联的值。
- en: 'Now, from within the `fod/05` folder, let''s run an `alpine` container, pass
    the file as an environment file, and run the `export` command inside the container
    to verify that the variables listed inside the file have indeed been created as
    environment variables inside the container, like this:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从`fod/05`文件夹中，让我们运行一个`alpine`容器，将文件作为环境文件传递，并在容器内运行`export`命令，以验证文件中列出的变量确实已经在容器内部创建为环境变量，就像这样：
- en: '[PRE64]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'And indeed, the variables are defined, as we can see in the output generated:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，变量已经被定义，正如我们在生成的输出中所看到的：
- en: '[PRE65]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Next, let's look at how to define default values for environment variables that
    are valid for all container instances of a given Docker image.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何为给定Docker镜像的所有容器实例定义环境变量的默认值。
- en: Defining environment variables in container images
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器镜像中定义环境变量
- en: 'Sometimes, we want to define some default value for an environment variable
    that must be present in each container instance of a given container image. We
    can do so in the `Dockerfile` that is used to create that image by following these
    steps:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望为必须存在于给定容器镜像的所有容器实例中的环境变量定义一些默认值。我们可以在用于创建该镜像的`Dockerfile`中这样做，按照以下步骤：
- en: 'Use your favorite editor to create a file called `Dockerfile` in the `~/fod/05` folder.
    Add the following content to the file, and save it:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的编辑器在`~/fod/05`文件夹中创建一个名为`Dockerfile`的文件。将以下内容添加到文件中，并保存：
- en: '[PRE66]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Create a container image called `my-alpine` using the preceding `Dockerfile`,
    as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前述`Dockerfile`创建一个名为`my-alpine`的容器镜像，如下所示：
- en: '[PRE67]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Run a container instance from this image that outputs the environment variables
    defined inside the container, like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 从该镜像运行一个容器实例，输出容器内定义的环境变量，就像这样：
- en: '[PRE68]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This is exactly what we would have expected.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们所期望的。
- en: 'The good thing, though, is that we are not stuck with those variable values
    at all. We can override one or many of them, using the `--env` parameter in the
    `docker container run` command. Have a look at the following command and its output:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，好消息是，我们并不完全受困于这些变量值。我们可以使用`docker container run`命令中的`--env`参数覆盖其中一个或多个变量。看一下以下命令及其输出：
- en: '[PRE69]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We can also override default values, using environment files together with the
    `--env-file` parameter in the `docker container run` command. Please try it out
    for yourself.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用环境文件和`docker container run`命令中的`--env-file`参数来覆盖默认值。请自行尝试。
- en: Environment variables at build time
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建时的环境变量
- en: 'Sometimes, we would want to have the possibility to define some environment
    variables that are valid at the time when we build a container image. Imagine
    that you want to define a `BASE_IMAGE_VERSION` environment variable that shall
    then be used as a parameter in your `Dockerfile`. Imagine the following `Dockerfile`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望在构建容器镜像时定义一些环境变量，这些变量在构建时是有效的。想象一下，你想定义一个`BASE_IMAGE_VERSION`环境变量，然后在你的`Dockerfile`中将其用作参数。想象一下以下的`Dockerfile`：
- en: '[PRE70]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We are using the `ARG` keyword to define a default value that is used each time
    we build an image from the preceding `Dockerfile`. In this case, that means that
    our image uses the `node:12.7-stretch` base image.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ARG`关键字来定义一个默认值，每次从前述`Dockerfile`构建镜像时都会使用这个默认值。在这种情况下，这意味着我们的镜像使用`node:12.7-stretch`基础镜像。
- en: 'Now, if we want to create a special image for—say—testing purposes, we can
    override this variable at image build time using the `--build-arg` parameter,
    as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想为—比如—测试目的创建一个特殊的镜像，我们可以使用`--build-arg`参数在构建镜像时覆盖这个变量，如下所示：
- en: '[PRE71]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In this case, the resulting `my-node-test:latest` image will be built from the `node:12.7-alpine` base
    image and not from the `node:12.7-stretch` default image.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，生成的`my-node-test:latest`镜像将从`node:12.7-alpine`基础镜像构建，而不是从`node:12.7-stretch`默认镜像构建。
- en: To summarize, environment variables defined via `--env` or `--env-file` are
    valid at container runtime. Variables defined with `ARG` in the `Dockerfile` or
    `--build-arg` in the `docker container build` command are valid at container image
    build time. The former are used to configure an application running inside a container,
    while the latter are used to parametrize the container image build process.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，通过`--env`或`--env-file`定义的环境变量在容器运行时有效。在`Dockerfile`中使用`ARG`或在`docker container
    build`命令中使用`--build-arg`定义的变量在容器镜像构建时有效。前者用于配置容器内运行的应用程序，而后者用于参数化容器镜像构建过程。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have introduced Docker volumes that can be used to persist
    states produced by containers and make them durable. We can also use volumes to
    provide containers with data originating from various sources. We have learned
    how to create, mount, and use volumes. We have learned various techniques of defining
    volumes such as by name, by mounting a host directory, or by defining volumes
    in a container image.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Docker卷，可以用来持久保存容器产生的状态并使其持久。我们还可以使用卷来为容器提供来自各种来源的数据。我们已经学会了如何创建、挂载和使用卷。我们已经学会了各种定义卷的技术，例如按名称、通过挂载主机目录或在容器镜像中定义卷。
- en: In this chapter, we have also discussed how we can configure environment variables
    that can be used by applications running inside a container. We have shown how
    to define those variables in the `docker container run` command, either explicitly,
    one by one, or as a collection in a configuration file. We have also shown how
    to parametrize the build process of container images by using build arguments.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们还讨论了如何配置环境变量，这些变量可以被容器内运行的应用程序使用。我们已经展示了如何在`docker container run`命令中定义这些变量，可以明确地一个一个地定义，也可以作为配置文件中的集合。我们还展示了如何通过使用构建参数来参数化容器镜像的构建过程。
- en: In the next chapter, we are going to introduce techniques commonly used to allow
    a developer to evolve, modify, debug, and test their code while running in a container.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍常用的技术，允许开发人员在容器中运行代码时进行演变、修改、调试和测试。
- en: Questions
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Please try to answer the following questions to assess your learning progress:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 请尝试回答以下问题，以评估您的学习进度：
- en: How would you create a named data volume with a name—for example, `my-products`—using
    the default driver?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建一个名为`my-products`的命名数据卷，使用默认驱动程序？
- en: How would you run a container using the `alpine` image and mount the `my-products` volume
    in read-only mode into the `/data` container folder?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用`alpine`镜像运行一个容器，并将`my-products`卷以只读模式挂载到`/data`容器文件夹中？
- en: How would you locate the folder that is associated with the `my-products` volume and
    navigate to it? Also, how will you create a file, `sample.txt`, with some content?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何找到与`my-products`卷关联的文件夹并导航到它？另外，您将如何创建一个带有一些内容的文件`sample.txt`？
- en: How would you run another `alpine` container in to which you mount the `my-products` volume
    to the `/app-data` folder, in read/write mode? Inside this container, navigate
    to the `/app-data` folder and create a `hello.txt` file with some content.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在另一个`alpine`容器中运行，并将`my-products`卷挂载到`/app-data`文件夹中，以读/写模式？在此容器内，导航到`/app-data`文件夹并创建一个带有一些内容的`hello.txt`文件。
- en: How would you mount a host volume—for example, `~/my-project`—into a container?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将主机卷（例如`~/my-project`）挂载到容器中？
- en: How would you remove all unused volumes from your system?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从系统中删除所有未使用的卷？
- en: The list of environment variables that an application running in a container
    sees is the same as if the application were to run directly on the host.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器中运行的应用程序看到的环境变量列表与应用程序直接在主机上运行时看到的相同。
- en: A. True
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: A. 真
- en: B. False
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: B. 假
- en: Your application that shall run in a container needs a huge list of environment
    variables for configuration. What is the simplest method to run a container with
    your application and provide all this information to it?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的应用程序需要在容器中运行，并为其配置提供大量环境变量。运行一个包含您的应用程序并向其提供所有这些信息的容器的最简单方法是什么？
- en: Further reading
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following articles provide more in-depth information:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文章提供更深入的信息：
- en: Use volumes, at [http://dockr.ly/2EUjTml](http://dockr.ly/2EUjTml)
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用卷，在[http://dockr.ly/2EUjTml](http://dockr.ly/2EUjTml)
- en: Manage data in Docker, at [http://dockr.ly/2EhBpzD](http://dockr.ly/2EhBpzD)
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker中管理数据，在[http://dockr.ly/2EhBpzD](http://dockr.ly/2EhBpzD)
- en: Docker volumes on **Play with Docker** (**PWD**), at [http://bit.ly/2sjIfDj](http://bit.ly/2sjIfDj)
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Play with Docker** (**PWD**)上的Docker卷，在[http://bit.ly/2sjIfDj](http://bit.ly/2sjIfDj)'
- en: '`nsenter` —Linux man page, at [https://bit.ly/2MEPG0n](https://bit.ly/2MEPG0n)'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nsenter`—Linux man页面，在[https://bit.ly/2MEPG0n](https://bit.ly/2MEPG0n)'
- en: Set environment variables, at [https://dockr.ly/2HxMCjS](https://dockr.ly/2HxMCjS)
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置环境变量，在[https://dockr.ly/2HxMCjS](https://dockr.ly/2HxMCjS)
- en: Understanding how `ARG` and `FROM` interact, at [https://dockr.ly/2OrhZgx](https://dockr.ly/2OrhZgx)
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解`ARG`和`FROM`如何交互，在[https://dockr.ly/2OrhZgx](https://dockr.ly/2OrhZgx)

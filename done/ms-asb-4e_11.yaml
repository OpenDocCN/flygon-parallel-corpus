- en: '*Chapter 9*: Troubleshooting Ansible'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第九章*：故障排除 Ansible'
- en: Ansible is beautifully simple, yet incredibly powerful. The simplicity of Ansible
    means that its operation is easy to understand and follow. However, even with
    the simplest and most user-friendly of systems, things do go wrong from time to
    time—perhaps as we are learning to write our own code (playbooks, roles, modules,
    or otherwise) and need to debug it, or, more rarely, when we might have found
    a bug in a released version of a collection or `ansible-core`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 简单而强大。Ansible 的简单意味着它的操作易于理解和遵循。然而，即使是最简单和最用户友好的系统，有时也会出现问题——也许是因为我们正在学习编写自己的代码（playbooks、roles、modules
    或其他）并需要调试它，或者更少见的是，当我们可能在已发布版本的集合或 `ansible-core` 中发现了错误时。
- en: Being able to understand and follow the operation of Ansible is critically important
    when debugging unexpected behavior, wherever it may arise. Ansible provides a
    number of options and tools to help you troubleshoot the operation of its core
    components, as well as your own playbook code. We will explore these in detail
    in this chapter, with the goal of empowering you to troubleshoot your own Ansible
    work with confidence.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试意外行为时，能够理解和遵循 Ansible 的操作至关重要。Ansible 提供了许多选项和工具，帮助您调试其核心组件的操作，以及您自己的 playbook
    代码。我们将在本章中详细探讨这些内容，目标是让您有信心调试自己的 Ansible 工作。
- en: 'Specifically, in this chapter, we will look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中，我们将讨论以下主题：
- en: Playbook logging and verbosity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Playbook 日志记录和详细程度
- en: Variable introspection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量内省
- en: Debugging code execution
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试代码执行
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the examples presented in this chapter, you will need a Linux machine
    running **Ansible 4.3** or a newer version. Almost any flavor of Linux should
    do—for those interested in specifics, all the code presented in this chapter was
    tested on Ubuntu Server 20.04 **Long-Term Support** (**LTS**) unless stated otherwise,
    and on Ansible 4.3\. The example code that accompanies this chapter can be downloaded
    from GitHub at this link: [https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter09).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中提出的示例，您需要运行 **Ansible 4.3** 或更新版本的 Linux 机器。几乎任何 Linux 版本都可以——对于那些感兴趣的人，本章中提出的所有代码都是在
    Ubuntu Server 20.04 **长期支持**（**LTS**）上测试的，除非另有说明，并且在 Ansible 4.3 上测试。本章附带的示例代码可以从
    GitHub 下载：[https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter09)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2Xx46Ym](https://bit.ly/2Xx46Ym)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[https://bit.ly/2Xx46Ym](https://bit.ly/2Xx46Ym)
- en: Playbook logging and verbosity
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Playbook 日志记录和详细程度
- en: Increasing the verbosity of Ansible output can solve many problems. From invalid module arguments
    to incorrect connection commands, increased verbosity can be critical in pinpointing
    the source of an error. Playbook logging and verbosity were briefly discussed
    in [*Chapter 3*](B17462_03_Final_JC_ePub.xhtml#_idTextAnchor061), *Protecting
    Your Secrets with Ansible*, with regard to protecting secret values while executing
    playbooks. This section will cover verbosity and logging in further detail.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 增加 Ansible 输出的详细程度可以解决许多问题。从无效的模块参数到不正确的连接命令，增加详细程度在准确定位错误源头方面至关重要。在 *第三章* 中简要讨论了
    playbook 日志记录和详细程度，关于在执行 playbook 时保护秘密值。本节将更详细地介绍详细程度和日志记录。
- en: Verbosity
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 详细程度
- en: 'When executing playbooks with `ansible-playbook`, the output is displayed on
    **standard output** (**stdout**). With the default level of verbosity, very little
    information is displayed. As a play is executed, `ansible-playbook` will print
    a **play** header with the name of the play. Then, for each task, a **task** header
    is printed with the name of the task. As each host executes the task, the name
    of the host is displayed along with the task state, which can be `ok`, `fatal`,
    or `changed`. No further information about the task is displayed—such as the module being
    executed, the arguments provided to the module, or the return data from the execution.
    While this is fine for well-established playbooks, I tend to want a little more
    information about my plays. In a few of the earlier examples in this book, we
    used higher levels of verbosity, up to a level of two (`-vv`), so that we could
    see the location of the task and return data. There are five total levels of verbosity,
    as outlined here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `ansible-playbook` 执行 playbook 时，输出显示在 **标准输出**（**stdout**）上。在默认详细程度下，几乎没有显示任何信息。当执行
    play 时，`ansible-playbook` 将打印一个带有 play 名称的 **play** 标头。然后，对于每个任务，将打印一个带有任务名称的
    **task** 标头。当每个主机执行任务时，将显示主机的名称以及任务状态，可以是 `ok`、`fatal` 或 `changed`。不会显示有关任务的进一步信息——例如正在执行的模块、提供给模块的参数或执行的返回数据。虽然这对于已经建立的
    playbook 来说是可以的，但我倾向于想要更多关于我的 play 的信息。在本书的早期示例中，我们使用了更高级别的详细程度，最高达到二级 (`-vv`)，以便我们可以看到任务的位置和返回数据。总共有五个详细程度级别，如下所述：
- en: '**None**: The default level'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无**：默认级别'
- en: '**One** (`-v`): Where the return data and conditional information is displayed'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一** (`-v`)：显示返回数据和条件信息的位置'
- en: '**Two** (`-vv`): For task location and handler notification information'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二** (`-vv`)：用于任务位置和处理程序通知信息'
- en: '**Three** (`-vvv`): Provides details of the connection attempts and task invocation
    information'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三** (`-vvv`)：提供连接尝试和任务调用信息的详细信息'
- en: '**Four** (`-vvvv`): Passes along extra verbosity options to the connection
    plugins (such as passing `-vvv` to the `ssh` commands)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**四** (`-vvvv`)：将额外的详细选项传递给连接插件（例如将 `-vvv` 传递给 `ssh` 命令）'
- en: Increasing the verbosity can help pinpoint where errors might be occurring,
    as well as providing extra insight into how Ansible is performing its operations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 增加详细程度可以帮助准确定位错误发生的位置，以及提供额外的洞察力，了解 Ansible 如何执行其操作。
- en: As we mentioned in [*Chapter 3*](B17462_03_Final_JC_ePub.xhtml#_idTextAnchor061), *Protecting
    Your Secrets with Ansible*, verbosity beyond level one can leak sensitive data
    to standard out and log files, so care should be taken when using increased verbosity
    in a potentially shared environment.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第3章*](B17462_03_Final_JC_ePub.xhtml#_idTextAnchor061)中提到的，*使用Ansible保护您的机密信息*，超过一级的冗余度可能会将敏感数据泄露到标准输出和日志文件中，因此在可能共享的环境中增加冗余度时应谨慎使用。
- en: Logging
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志记录
- en: While the default is for `ansible-playbook` to log to stdout, the amount of
    output may be greater than the buffer of the terminal emulator being used; therefore,
    it may be necessary to save all the output to a file. While various shells provide
    some mechanism to redirect output, a more elegant solution is to direct `ansible-playbook` to
    log to a file. This is accomplished by way of either a `log_path` definition in
    the `ansible.cfg` file or by setting `ANSIBLE_LOG_PATH` as an environment variable.
    The value of either should be the path to a file. If the path does not exist,
    Ansible will attempt to create a file. If the file does exist, Ansible will append
    to the file, allowing consolidation of multiple `ansible-playbook` execution logs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`ansible-playbook`的默认日志记录到标准输出，但输出量可能大于所使用的终端仿真器的缓冲区；因此，可能需要将所有输出保存到文件中。虽然各种shell提供了一些重定向输出的机制，但更优雅的解决方案是将`ansible-playbook`指向日志记录到文件。这可以通过在`ansible.cfg`文件中定义`log_path`或者将`ANSIBLE_LOG_PATH`设置为环境变量来实现。任何一个的值都应该是文件的路径。如果路径不存在，Ansible将尝试创建一个文件。如果文件已经存在，Ansible将追加到文件，允许合并多个`ansible-playbook`执行日志。
- en: The use of a log file is not mutually exclusive with logging to stdout. Both
    can happen at the same time, and the verbosity level that's provided has an effect
    on both, simultaneously. Logging is of course helpful, but it doesn't necessarily
    tell us what's going on in our code, and what our variables might contain. We'll
    look at how to perform variable introspection in the next section to help you
    with this very task.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下命令以一级冗余度运行此播放：
- en: Variable introspection
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量内省
- en: A common set of problems that are encountered when developing Ansible playbooks is
    the improper use, or invalid assumption, of the value of variables. This is particularly
    common when registering the results of one task in a variable, and later using
    that variable in a task or template. If the desired element of the result is not
    accessed properly, the end result will be unexpected, or perhaps even harmful.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发Ansible playbook时遇到的常见问题是变量的值的不正确使用或无效假设。当在变量中注册一个任务的结果，然后在另一个任务或模板中使用该变量时，这种情况特别常见。如果没有正确访问结果的所需元素，最终结果将是意外的，甚至可能是有害的。
- en: 'To troubleshoot improper variable usage, an inspection of the variable value
    is the key. The easiest way to inspect a variable''s value is with the `ansible.builtin.debug`
    module. The `ansible.builtin.debug` module allows the display of freeform text
    on screen, and as with other tasks, the arguments to the module can take advantage
    of the Jinja2 template syntax as well. Let''s demonstrate this usage by creating
    a sample play that executes a task, registers the result, and then shows the result
    in an `ansible.builtin.debug` statement using Jinja2 syntax to render the variable,
    as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 - 使用调试模块的var参数检查变量子元素'
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will run this play with level one verbosity using the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 - 使用一级冗余度检查注册变量的值'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Assuming the website we''re testing against is accessible, we''ll see a displayed
    value for `derpops`, as shown in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在测试的网站是可访问的，我们将看到`derpops`的显示值，如下面的屏幕截图所示：
- en: '![Figure 9.1 – Using level one verbosity to examine registered variable values'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_01.jpg)'
- en: '](Images/B17462_09_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 - 使用一级冗余度检查注册变量的值
- en: Figure 9.1 – Using level one verbosity to examine registered variable values
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同冗余度运行此修改后的播放将只显示`derpops`变量的`server`部分，如下面的屏幕截图所示：
- en: 'The `ansible.builtin.debug` module has a different option that may be useful
    as well. Instead of printing a freeform string to debug template usage, the module
    can simply print the value of any variable. This is done using the `var` argument
    instead of the `msg` argument. Let''s repeat our example, but this time we''ll
    use the `var` argument, and we''ll access just the `server` subelement of the `derpops` variable,
    as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible.builtin.debug`模块还有一个不同的选项，可能也很有用。该模块不是将自由格式的字符串打印到调试模板中，而是可以简单地打印任何变量的值。这是通过使用`var`参数而不是`msg`参数来完成的。让我们重复我们的例子，但这次我们将使用`var`参数，并且我们将仅访问`derpops`变量的`server`子元素，如下所示：'
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running this modified play with the same level of verbosity as before will
    show just the `server` portion of the `derpops` variable, as demonstrated in the
    following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要排除变量使用不当的问题，检查变量值是关键。检查变量值的最简单方法是使用`ansible.builtin.debug`模块。`ansible.builtin.debug`模块允许在屏幕上显示自由格式的文本，并且与其他任务一样，模块的参数也可以利用Jinja2模板语法。让我们通过创建一个执行任务的示例播放来演示这种用法，注册结果，然后使用Jinja2语法在`ansible.builtin.debug`语句中显示结果，如下所示：
- en: '![Figure 9.2 – Using the var parameter of the debug module to inspect variable
    subelements'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_02.jpg)'
- en: '](Images/B17462_09_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日志文件并不意味着与记录到标准输出互斥。两者可以同时发生，并且所提供的冗余级别对两者都有影响。日志记录当然是有帮助的，但它并不一定告诉我们代码中发生了什么，以及我们的变量可能包含什么。我们将在下一节中看看如何执行变量内省，以帮助您完成这个任务。
- en: Figure 9.2 – Using the var parameter of the debug module to inspect variable
    subelements
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 - 使用调试模块的var参数来检查变量子元素
- en: In our example that used the `msg` argument to `ansible.builtin.debug`, the
    variable needed to be expressed inside curly brackets, but when using `var`, it
    did not. This is because `msg` expects a string, and so Ansible needs to render
    the variable as a string via the template engine. However, `var` expects a single
    unrendered variable.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用`ansible.builtin.debug`的例子中，需要使用`msg`参数将变量表达为花括号内，但是在使用`var`时不需要。这是因为`msg`期望一个字符串，因此Ansible需要通过模板引擎将变量呈现为字符串。然而，`var`期望一个单个未呈现的变量。
- en: Variable subelements
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量子元素
- en: Another frequent mistake in playbooks is to improperly reference a subelement
    of a complex variable. A complex variable is more than simply a string—it is either
    a list or a hash. Often, the wrong subelement will be referenced, or the element
    will be improperly referenced, expecting a different type.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: playbook中经常出现的一个错误是错误地引用复杂变量的子元素。复杂变量不仅仅是一个字符串，它可以是一个列表或一个哈希表。经常会引用错误的子元素，或者错误地引用元素，期望得到不同的类型。
- en: While lists are fairly easy to work with, hashes present some unique challenges.
    A hash is an unordered key-value set of potentially mixed types, which could also
    be nested. A hash can have one element that is a single string, while another
    element can be a list of strings, and a third element can be another hash with
    further elements inside it. Knowing how to properly access the right subelement
    is critical to success.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然列表相当容易处理，但哈希表提出了一些独特的挑战。哈希表是一个无序的键-值集合，可能包含不同类型的元素，也可能是嵌套的。一个哈希表可以有一个元素是单个字符串，而另一个元素可以是一个字符串列表，第三个元素可以是另一个哈希表，其中包含更多的元素。知道如何正确访问正确的子元素对于成功至关重要。
- en: 'For example, let''s modify our previous play a bit more. This time, we''ll
    allow Ansible to gather facts, and then we''ll show the value of `ansible_python`.
    Here''s the code we''ll need:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们稍微修改我们之前的play。这一次，我们将允许Ansible收集事实，然后显示`ansible_python`的值。这是我们需要的代码：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run this code with level one verbosity, and you should see the following output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以一级详细程度运行此代码，您应该看到以下输出：
- en: '![Figure 9.3 – Inspecting the ansible_python fact subelement using ansible.builtin.debug'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3 – 使用ansible.builtin.debug检查ansible_python事实子元素'
- en: '](Images/B17462_09_03.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_03.jpg)'
- en: Figure 9.3 – Inspecting the ansible_python fact subelement using ansible.builtin.debug
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 使用ansible.builtin.debug检查ansible_python事实子元素
- en: Using `ansible.builtin.debug` to display an entire complex variable is a great
    way to learn all the names of the subelements.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ansible.builtin.debug`来显示整个复杂变量是学习所有子元素名称的好方法。
- en: 'This variable has elements that are strings, along with elements that are lists
    of strings. Let''s access the last item in the list of flags, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量有一些元素是字符串，还有一些元素是字符串列表。让我们访问标志列表中的最后一个项目，如下所示：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is shown here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 9.4 – Inspecting the ansible_python fact subelement further'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4 – 进一步检查ansible_python事实子元素'
- en: '](Images/B17462_09_04.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_04.jpg)'
- en: Figure 9.4 – Inspecting the ansible_python fact subelement further
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 进一步检查ansible_python事实子元素
- en: Because `ansible_python.version_info` is a list, we can use the **list index
    method** to select a specific item from the list. In this case, `-1` will give
    us the very last item in the list.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`ansible_python.version_info`是一个列表，我们可以使用**列表索引方法**来从列表中选择特定的项目。在这种情况下，`-1`将给我们列表中的最后一个项目。
- en: Subelements versus the Python object method
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子元素与Python对象方法
- en: 'A less common but confusing gotcha comes from a quirk of the Jinja2 syntax.
    Complex variables within Ansible playbooks and templates can be referenced in
    two ways. The first style is to reference the base element by the name, followed
    by a bracket, and the subelement within quotes inside the brackets. This is the **standard
    subscript syntax**. For example, to access the `herp` subelement of the `derp`
    variable, we will use the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不太常见但令人困惑的坑来自Jinja2语法的一个怪癖。在Ansible playbook和模板中，复杂变量可以以两种方式引用。第一种样式是通过名称引用基本元素，后跟括号，括号内用引号括起来的子元素。这是**标准下标语法**。例如，要访问`derp`变量的`herp`子元素，我们将使用以下代码：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The second style is a convenience method that Jinja2 provides, which is to
    use a period to separate the elements. This is called **dot notation**, and it
    looks like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种样式是Jinja2提供的一种便利方法，即使用句点来**分隔**元素。这被称为**点表示法**，看起来像这样：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There is a subtle difference in how these styles work, and it has to do with
    Python objects and object methods. As Jinja2 is, at its heart, a Python utility,
    variables in Jinja2 have access to their native Python methods. A string variable
    has access to Python string methods, a list has access to list methods, and a
    dictionary has access to dictionary methods. When using the first style, Jinja2
    will first search the element for a subelement of the provided name. If no subelements
    are found, Jinja2 will then attempt to access a Python method of the provided
    name. However, the order is reversed when using the second style; first, a Python
    object method is searched for, and if not found, then a subelement is searched
    for. This difference matters when there is a name collision between a subelement
    and a method. Imagine a variable named `derp`, which is a complex variable. This
    variable has a subelement named `keys`. Using each style to access the `keys` element
    will result in different values. Let''s build a playbook to demonstrate this,
    as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些样式的工作方式有微妙的差异，这与Python对象和对象方法有关。由于Jinja2在本质上是一个Python实用程序，Jinja2中的变量可以访问其本机Python方法。字符串变量可以访问Python字符串方法，列表可以访问列表方法，字典可以访问字典方法。使用第一种样式时，Jinja2首先会搜索提供的名称的元素以查找子元素。如果找不到子元素，则Jinja2将尝试访问提供的名称的Python方法。然而，当使用第二种样式时，顺序是相反的；首先搜索Python对象方法，如果找不到，然后搜索子元素。当子元素和方法之间存在名称冲突时，这种差异很重要。想象一个名为`derp`的变量，它是一个复杂的变量。这个变量有一个名为`keys`的子元素。使用每种样式来访问`keys`元素将得到不同的值。让我们构建一个playbook来演示这一点，如下所示：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When running this play, we can clearly see the difference between the two styles.
    The first style successfully references the `keys` subelement, while the second
    style references the `keys` method of Python dictionaries, as the following screenshot
    illustrates:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行这个剧本时，我们可以清楚地看到两种风格之间的区别。第一种风格成功地引用了`keys`子元素，而第二种风格引用了Python字典的`keys`方法，如下面的屏幕截图所示：
- en: '![Figure 9.5 – Demonstrating the difference between standard subscript syntax
    and dot notation when name collision occurs'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5 - 演示标准下标语法和点符号在名称冲突发生时的区别'
- en: '](Images/B17462_09_05.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_05.jpg)'
- en: Figure 9.5 – Demonstrating the difference between standard subscript syntax
    and dot notation when name collision occurs
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 - 演示标准下标语法和点符号在名称冲突发生时的区别
- en: Generally, it's best to avoid using subelement names that conflict with Python
    object methods. However, if that's not possible, the next best thing to do is
    to be aware of the difference in subelement reference styles and choose the appropriate
    one.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好避免使用与Python对象方法冲突的子元素名称。但是，如果不可能的话，下一件最好的事情就是意识到子元素引用风格的差异，并选择适当的风格。
- en: Of course, variables are only one aspect of playbook behavior—sometimes, we
    need to actually get into debugging the code itself, and we'll look at just that
    in the next section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，变量只是剧本行为的一方面 - 有时，我们需要实际进入调试代码本身，我们将在下一节中仔细研究这一点。
- en: Debugging code execution
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试代码执行
- en: 'Sometimes, the logging and inspection of variable data are not enough to troubleshoot
    a problem. When this happens, it can be necessary to interactively debug the playbook,
    or to dig deeper into the internals of Ansible code. There are two main sets of
    Ansible code: code that runs locally on the Ansible host, and module code that
    runs remotely on the target host.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，记录和检查变量数据并不足以解决问题。当这种情况发生时，有必要交互式地调试剧本，或者深入研究Ansible代码的内部。Ansible代码有两个主要集：在Ansible主机上本地运行的代码，以及在目标主机上远程运行的模块代码。
- en: Playbook debugging
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 剧本调试
- en: Playbooks can be interactively debugged by using an execution strategy that
    was introduced in Ansible 2.1, **the debug strategy**. If a play uses this strategy
    when an error state is encountered, an interactive debugging session starts. This
    interactive session can be used to display variable data, display task arguments,
    update task arguments, update variables, redo task execution, continue execution,
    or exit the debugger.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用在Ansible 2.1中引入的执行策略**调试策略**来交互式地调试剧本。如果一个剧本在遇到错误状态时使用了这个策略，将开始一个交互式调试会话。这个交互式会话可以用于显示变量数据，显示任务参数，更新任务参数，更新变量，重新执行任务，继续执行或退出调试器。
- en: 'Let''s demonstrate this with a play that has a successful task, followed by
    a task with an error, followed by a final successful task. We''ll reuse the playbook
    we''ve been using, but update it a bit, as shown in the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个成功的任务，然后是一个出错的任务，最后是一个成功的任务来演示这一点。我们将重用我们一直在使用的剧本，但稍微更新一下，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Upon execution, Ansible will encounter an error in our failing task and present
    the (debug) prompt, as shown in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，Ansible将在我们失败的任务中遇到错误，并显示(debug)提示，如下面的屏幕截图所示：
- en: '![Figure 9.6 – The Ansible debugger starting during a failed task execution
    (when execution strategy is debug)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6 - Ansible调试器在执行失败任务时启动（执行策略为debug）时'
- en: '](Images/B17462_09_06.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_06.jpg)'
- en: Figure 9.6 – The Ansible debugger starting during a failed task execution (when
    execution strategy is debug)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 - Ansible调试器在执行失败任务时启动（执行策略为debug）时
- en: 'From this prompt, we can display the task and the arguments to the task by
    using the `p` command, as the following screenshot shows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个提示中，我们可以使用`p`命令显示任务和任务参数，如下面的屏幕截图所示：
- en: '![Figure 9.7 – Using the p command to inspect details of the failed play task'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7 - 使用p命令检查失败剧本任务的详细信息'
- en: '](Images/B17462_09_07.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_07.jpg)'
- en: Figure 9.7 – Using the p command to inspect details of the failed play task
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 - 使用p命令检查失败剧本任务的详细信息
- en: 'We can also change the playbook on the fly to try different arguments or variable
    values. Let''s define the missing key of the `derp` variable, and then retry the
    execution. All of the variables are within the top-level `vars` dictionary. We
    can directly set the variable data using Python syntax and the `task_vars` command,
    and then retry with the `r` command, as illustrated in the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以即时更改剧本以尝试不同的参数或变量值。让我们定义`derp`变量的缺失键，然后重试执行。所有变量都在顶层`vars`字典中。我们可以使用Python语法和`task_vars`命令直接设置变量数据，然后使用`r`命令重试，如下面的屏幕截图所示：
- en: '![Figure 9.8 – Adding previously undefined variable values and retrying the
    play from the debugger'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8 - 添加先前未定义的变量值并从调试器中重试剧本'
- en: '](Images/B17462_09_08.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_08.jpg)'
- en: Figure 9.8 – Adding previously undefined variable values and retrying the play
    from the debugger
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 - 添加先前未定义的变量值并从调试器中重试剧本
- en: The debug execution strategy is a handy tool for quickly iterating through different
    task arguments and variable combinations to figure out the correct path forward.
    However, because errors result in interactive consoles, the debug strategy is
    inappropriate for automated executions of playbooks, as there is no human on the
    console to manipulate the debugger.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 调试执行策略是一个方便的工具，可以快速迭代不同的任务参数和变量组合，以找出正确的前进路径。然而，由于错误导致交互式控制台，调试策略不适用于剧本的自动执行，因为控制台上没有人来操作调试器。
- en: Important Point
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 重要观点
- en: Changing data within the debugger will not save the changes to backing files.
    Always remember to update playbook files to reflect discoveries that are made
    during debugging.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 更改调试器中的数据不会保存更改到后备文件中。始终记得更新剧本文件以反映在调试过程中发现的内容。
- en: Debugging local code
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试本地代码
- en: The local Ansible code is the lion's share of the code that comes with Ansible.
    All the playbook, play, role, and task parsing code lives locally. All of the
    task result processing code and transport code lives locally. All of the code,
    except for the assembled module code that is transported to the remote host, lives
    locally.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本地Ansible代码是随Ansible一起提供的大部分代码。所有的playbook、play、role和task解析代码都存储在本地。所有的任务结果处理代码和传输代码都存储在本地。除了传输到远程主机的组装模块代码之外，所有代码都存储在本地。
- en: 'Local Ansible code can still be broken down into three major sections: **inventory**,
    **playbook**, and **executor**. Inventory code deals with parsing inventory data
    from host files, dynamic inventory scripts, or combinations of the two, in directory
    trees. Playbook code is used to parse the playbook **YAML Ain''t Markup Language**
    (**YAML**) code into Python objects within Ansible. Executor code is the core
    **application programming interface** (**API**) and deals with forking processes,
    connecting to hosts, executing modules, handling results, and most other things.
    Learning the general area to start debugging comes with practice, but the general
    areas that are described here are a starting point.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本地Ansible代码仍然可以分为三个主要部分：**清单**，**playbook**和**执行器**。清单代码处理来自主机文件，动态清单脚本或两者组合在目录树中的清单数据的解析。Playbook代码用于将playbook
    **YAML Ain't Markup Language** (**YAML**)代码解析为Ansible内的Python对象。执行器代码是核心**应用程序编程接口**
    (**API**)，处理分叉进程，连接到主机，执行模块，处理结果以及大多数其他事情。学习开始调试的一般区域需要实践，但这里描述的一般区域是一个起点。
- en: 'As Ansible is written in Python, the tool for debugging local code execution
    is the `pdb` Python debugger. This tool allows us to insert breakpoints inside
    the Ansible code and interactively walk through the execution of the code, line
    by line. This is very useful for examining the internal state of Ansible as the
    local code executes. Many books and websites cover the usage of `pdb`, and these can
    be found with a simple web search for an introduction to Python `pdb`, so we will
    not repeat them here. If you are looking for a hands-on introduction to using
    `pdb`, there are lots of great examples in the book *Django 1.1 Testing and Debugging*,
    *Karen M. Tracey*, *Packt Publishing*, which will enable you to practice real-world
    debugging techniques with `pdb` in Django (which is written in Python). The official
    Python documentation also offers much in the way of information on using the debugger.
    You can view this here: https://docs.python.org/3/library/pdb.html. The basics
    are to edit the source file to be debugged, insert a new line of code to create
    a breakpoint, and then execute the code. Code execution will stop where the breakpoint
    was created, and a prompt will be provided to explore the code state.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ansible是用Python编写的，因此用于调试本地代码执行的工具是`pdb` Python调试器。这个工具允许我们在Ansible代码内部插入断点，并逐行交互式地执行代码。这对于检查Ansible在本地代码执行时的内部状态非常有用。许多书籍和网站涵盖了`pdb`的使用方法，可以通过简单的网络搜索找到Python
    `pdb`的介绍，因此我们在这里不再重复。如果您正在寻找使用`pdb`的实践介绍，那么在书籍*Django 1.1 Testing and Debugging*，*Karen
    M. Tracey*，*Packt Publishing*中有许多很好的例子，这将使您能够在Django（用Python编写）中使用`pdb`进行实际调试技术的练习。官方的Python文档也提供了大量关于使用调试器的信息。您可以在这里查看：https://docs.python.org/3/library/pdb.html。基本的方法是编辑要调试的源文件，插入新的代码行以创建断点，然后执行代码。代码执行将在创建断点的地方停止，并提供一个提示来探索代码状态。
- en: Of course, Ansible has lots of different components that come together to build
    up its functionality, from inventory handling code to the actual playbook execution
    engine itself. It is possible to add breakpoints and debugging to all of these
    places to help resolve issues you might be facing, though the files you need to
    edit are slightly different in each case. We'll look at the details of the most
    common aspects of the Ansible code you might need to debug in the following subsections
    of this chapter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Ansible有许多不同的组件，这些组件共同构建了其功能，从清单处理代码到实际的playbook执行引擎本身。可以在所有这些地方添加断点和调试，以帮助解决可能遇到的问题，尽管您需要编辑的文件在每种情况下略有不同。我们将在本章的以下小节中详细讨论您可能需要调试的Ansible代码的最常见方面。
- en: Debugging inventory code
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试清单代码
- en: Inventory code deals with finding inventory sources, reading or executing the
    discovered files, parsing the inventory data into inventory objects, and loading
    variable data for the inventory. To debug how Ansible will deal with an inventory,
    a breakpoint must be added inside `inventory/__init__.py` or one of the other
    files within the `inventory/` subdirectory. This directory will be located on
    the local filesystem wherever Ansible has been installed. As most installations
    of Ansible 4.0 will have been performed via `pip` at this time, the exact path
    of your installation will vary greatly, depending on factors such as whether you
    used a virtual environment, whether you installed Ansible in your user directory,
    or whether you used `sudo` to install Ansible system-wide. As an example, on my
    Ubuntu 20.04 test system, this file may be found in the `/usr/local/lib/python3.8/dist-packages/ansible/inventory`
    path. To help you discover where Ansible is installed, simply type `which ansible` from
    the command line. This command will show you where the Ansible executable is installed
    and may indicate a Python virtual environment. For this book, Ansible has been
    installed as root using the operating system Python distribution, with the Ansible
    binaries located in `/usr/local/bin/`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Inventory 代码处理查找清单来源、读取或执行已发现的文件、将清单数据解析为清单对象，并加载清单的变量数据。要调试 Ansible 如何处理清单，必须在
    `inventory/__init__.py` 或 `inventory/` 子目录中的其他文件中添加断点。此目录将位于安装了 Ansible 的本地文件系统上。由于大多数
    Ansible 4.0 的安装都是通过 `pip` 进行的，因此您的安装路径将根据诸如是否使用了虚拟环境、是否在用户目录中安装了 Ansible，或者是否使用
    `sudo` 来系统范围安装 Ansible等因素而有很大不同。例如，在我的 Ubuntu 20.04 测试系统上，此文件可能位于 `/usr/local/lib/python3.8/dist-packages/ansible/inventory`
    路径下。要帮助您发现 Ansible 的安装位置，只需在命令行中输入 `which ansible`。此命令将显示 Ansible 可执行文件的安装位置，并可能指示
    Python 虚拟环境。对于本书来说，Ansible 已经作为 root 用户使用操作系统 Python 发行版进行了安装，Ansible 二进制文件位于
    `/usr/local/bin/` 中。
- en: To discover the path to the Ansible Python code, simply type `python3 -c "import
    ansible; print(ansible)"`. Note that, like me, you might have both Python 2 and
    Python 3 installed—if you are unsure of which version of Python Ansible is running
    under, you will need to execute both the version 2 and 3 binaries in order to
    discover your module locations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要发现 Ansible Python 代码的路径，只需输入 `python3 -c "import ansible; print(ansible)"`。请注意，就像我一样，您可能已经安装了
    Python 2 和 Python 3 —— 如果您不确定 Ansible 运行在哪个版本的 Python 下，您需要执行版本 2 和 3 的二进制文件，以便发现您的模块位置。
- en: On my system, this shows `<module 'ansible' from '/usr/local/lib/python3.8/dist-packages/ansible/__init__.py'>`,
    from which we can deduce that the inventory subdirectory is located at `/usr/local/lib/python3.8/dist-packages/ansible/inventory/`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统上，这显示 `<module 'ansible' from '/usr/local/lib/python3.8/dist-packages/ansible/__init__.py'>`，从中我们可以推断出清单子目录位于
    `/usr/local/lib/python3.8/dist-packages/ansible/inventory/`。
- en: The inventory directory was restructured in later releases of Ansible, and in
    version 4.0, we need to look in `inventory/manager.py`. Note that this file comes
    from the `ansible-core` package and not the `ansible` package that depends upon
    it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 清单目录在后续版本的 Ansible 中进行了重组，在 4.0 版本中，我们需要查看 `inventory/manager.py`。请注意，此文件来自
    `ansible-core` 软件包，而不是依赖于它的 `ansible` 软件包。
- en: Within this file, there is a class definition for the `Inventory` class. This
    is the inventory object that will be used throughout a playbook run, and it is
    created when `ansible-playbook` parses the options provided to it for an inventory
    source. The `__init__` method of the `Inventory` class does all the inventory
    discovery, parsing, and variable loading. To troubleshoot an issue in those three
    areas, a breakpoint should be added within the `__init__()` method. A good place
    to start would be after all of the class variables are given an initial value,
    and just before any data is processed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，有一个 `Inventory` 类的定义。这是在整个 playbook 运行期间将使用的清单对象，当 `ansible-playbook`
    解析为清单来源提供的选项时，它就会被创建。`Inventory` 类的 `__init__` 方法执行所有的清单发现、解析和变量加载。要排除这三个领域的问题，应该在
    `__init__()` 方法中添加断点。一个好的起点是在所有类变量都被赋予初始值之后，以及在处理任何数据之前。
- en: In version 2.11.1 of `ansible-core`, this would be line *167* of `inventory/manager.py`,
    where the `parse_sources` function is called.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ansible-core` 的 2.11.1 版本中，这将是 `inventory/manager.py` 的第 *167* 行，其中调用了 `parse_sources`
    函数。
- en: 'We can skip down to the `parse_sources` function definition on line *215* to
    insert our breakpoint. To insert a breakpoint, we must first import the `pdb` module
    and then call the `set_trace()` function, as shown in the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以跳到第 *215* 行的 `parse_sources` 函数定义处插入我们的断点。要插入断点，我们必须首先导入 `pdb` 模块，然后调用 `set_trace()`
    函数，如下面的截图所示：
- en: '![Figure 9.9 – Adding a pdb breakpoint into the ansible-core inventory manager
    code'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.9 – 在 ansible-core inventory manager 代码中添加 pdb 断点'
- en: '](Images/B17462_09_09.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_09.jpg)'
- en: Figure 9.9 – Adding a pdb breakpoint into the ansible-core inventory manager
    code
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 在 ansible-core inventory manager 代码中添加 pdb 断点
- en: 'To start debugging, save the source file and then execute `ansible-playbook` as
    normal. When the breakpoint is reached, the execution will stop and a `pdb` prompt will be
    displayed, as shown in the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始调试，保存源文件，然后像平常一样执行 `ansible-playbook`。当达到断点时，执行将停止，并显示 `pdb` 提示，如下面的截图所示：
- en: '![Figure 9.10 – Ansible reaching a pdb breakpoint as it starts to set up the
    inventory for our play'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.10 – Ansible 在开始为我们的 play 设置清单时达到 pdb 断点'
- en: '](Images/B17462_09_10.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_10.jpg)'
- en: Figure 9.10 – Ansible reaching a pdb breakpoint as it starts to set up the inventory
    for our play
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – Ansible 在开始为我们的 play 设置清单时达到 pdb 断点
- en: 'From here, we can issue any number of debugger commands, such as the `help` command,
    as the following screenshot shows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以发出任意数量的调试器命令，比如 `help` 命令，如下面的截图所示：
- en: '![Figure 9.11 – Demonstrating the help command of the pdb debugger'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.11 – 演示 pdb 调试器的 help 命令'
- en: '](Images/B17462_09_11.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_11.jpg)'
- en: Figure 9.11 – Demonstrating the help command of the pdb debugger
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 – 演示pdb调试器的帮助命令
- en: 'The `where` and `list` commands can help us determine where we are in the stack
    and where we are in the code, as illustrated in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`where`和`list`命令可以帮助我们确定我们在堆栈中的位置和代码中的位置，如下面的屏幕截图所示：'
- en: '![Figure 9.12 – Demonstrating the where and list pdb commands'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.12 – 演示where和list pdb命令'
- en: '](Images/B17462_09_12.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_12.jpg)'
- en: Figure 9.12 – Demonstrating the where and list pdb commands
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 – 演示where和list pdb命令
- en: The `where` command shows us that we're in `inventory/manager.py` in the `parse_sources()`
    method. The next frame up is the same file—the `__init__()` function. Before that
    is a different file, the `playbook.py` file, and the function in that file is
    `run()`. This line calls `ansible.inventory.InventoryManager` to create an inventory
    object. Before that is the original file, `ansible-playbook`, calling `cli.run()`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`where`命令显示我们在`inventory/manager.py`中的`parse_sources()`方法中。下一个框架是相同的文件——`__init__()`函数。在此之前是另一个文件，`playbook.py`文件，该文件中的函数是`run()`。这一行调用`ansible.inventory.InventoryManager`来创建一个清单对象。在此之前是原始文件`ansible-playbook`，调用`cli.run()`。'
- en: The `list` command shows the source code around our current point of execution,
    five lines before and five lines after.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`命令显示我们当前执行点周围的源代码，前后各五行。'
- en: 'From here, we can guide `pdb` through the function line by line with the `next` command,
    and if we choose to, we can trace into other function calls with the `step` command.
    We can also print variable data to inspect values, as shown in the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以使用`next`命令逐行引导`pdb`通过函数，如果选择，我们可以使用`step`命令跟踪其他函数调用。我们还可以使用`print`命令打印变量数据以检查值，如下面的屏幕截图所示：
- en: '![Figure 9.13 – Demonstrating the print command to analyze variable values
    during execution'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.13 – 演示打印命令在执行过程中分析变量值'
- en: '](Images/B17462_09_13.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_13.jpg)'
- en: Figure 9.13 – Demonstrating the print command to analyze variable values during
    execution
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 – 演示打印命令在执行过程中分析变量值
- en: We can see that the `self._sources` variable has a full path of our `mastery-hosts` inventory
    file, which is the string we gave `ansible-playbook` for our inventory data. We
    can continue to walk through or jump around, or just use the `continue` command
    to run until the next breakpoint or the completion of the code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`self._sources`变量具有我们的`mastery-hosts`清单文件的完整路径，这是我们为清单数据提供给`ansible-playbook`的字符串。我们可以继续逐步进行或跳转，或者只需使用`continue`命令运行直到下一个断点或代码完成。
- en: Debugging playbook code
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试playbook代码
- en: 'Playbook code is responsible for loading, parsing, and executing playbooks.
    The main entry point for playbook handling is found by locating the Ansible path,
    just as we did in the *Debugging inventory code* section, and then locating the `playbook/__init__.py`
    file. Inside this file lives the `PlayBook` class. A good starting point for debugging
    playbook handling is around line *68* (for `ansible-core` 2.11.1), though this
    will vary depending upon the version you have installed. The following screenshot
    shows the adjacent code to help you locate the correct lines for your version:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Playbook代码负责加载、解析和执行playbooks。调试playbook处理的主要入口点是通过定位Ansible路径找到的，就像我们在*调试清单代码*部分中所做的那样，然后找到`playbook/__init__.py`文件。在这个文件中有`PlayBook`类。调试playbook处理的一个很好的起点是大约第*68*行（对于`ansible-core`
    2.11.1），尽管这将根据您安装的版本而有所不同。以下屏幕截图显示了相邻的代码，以帮助您找到您版本的正确行：
- en: '![Figure 9.14 – Adding the pdb debugger for debugging playbook loading and
    execution'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.14 – 添加pdb调试器以调试playbook加载和执行'
- en: '](Images/B17462_09_14.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_14.jpg)'
- en: Figure 9.14 – Adding the pdb debugger for debugging playbook loading and execution
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – 添加pdb调试器以调试playbook加载和执行
- en: Putting a breakpoint here will allow us to trace through finding the playbook
    file and parsing it. Specifically, by stepping into the `self._loader.load_from_file()` function
    call, we will be able to follow the parsing in action.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里设置断点将允许我们跟踪查找playbook文件并解析它。具体来说，通过步入`self._loader.load_from_file()`函数调用，我们将能够跟踪解析过程。
- en: The `PlayBook` class `_load_playbook_data()` function just does the initial
    parsing. Other classes within other directories are used for the execution of
    plays and tasks. A particularly interesting directory is the `executor/` directory,
    which holds files with classes to execute playbooks, plays, and tasks. The `run()` function
    within the `PlaybookExecutor` class that's defined in the `executor/playbook_executor.py`
    file will loop through all of the plays in the playbook and execute the plays,
    which will, in turn, execute the individual tasks. This is the function to walk
    through if facing an issue related to play parsing, play or task callbacks, tags,
    play host selection, serial operation, handler running, or anything in between.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayBook`类的`_load_playbook_data()`函数只是进行初始解析。其他目录中的其他类用于执行plays和tasks。一个特别有趣的目录是`executor/`目录，其中包含用于执行playbooks、plays和tasks的类文件。`executor/playbook_executor.py`文件中`PlaybookExecutor`类中的`run()`函数将循环遍历playbook中的所有plays并执行这些plays，这将依次执行各个tasks。如果遇到与play解析、play或task回调、标签、play主机选择、串行操作、处理程序运行或其他任何问题相关的问题，这就是要遍历的函数。'
- en: Debugging executor code
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试执行器代码
- en: Executor code in Ansible is the connector code that binds together inventory
    data, playbooks, plays, tasks, and connection methods. While each of those other
    code bits can be individually debugged, how they interact can be examined within
    executor code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible中，执行器代码是连接清单数据、playbooks、plays、tasks和连接方法的连接器代码。虽然这些其他代码片段可以分别进行调试，但它们的交互方式可以在执行器代码中进行检查。
- en: The executor classes are defined in various files within `executor/` and the
    `PlaybookExecutor` class. This class handles the execution of all of the plays
    and tasks within a given playbook. The `__init__()` class creation function creates
    a series of placeholder attributes as well as setting some default values, while
    the `run()` function is where most of the fun happens.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器类在`executor/`中的各个文件中定义，`PlaybookExecutor`类。这个类处理给定playbook中所有plays和tasks的执行。`__init__()`类创建函数创建一系列占位符属性，并设置一些默认值，而`run()`函数是大部分有趣的地方。
- en: 'Debugging can often take you from one file to another, jumping around the code
    base. For example, in the `__init__()` function of the `PlaybookExecutor` class,
    there is code to cache whether or not the default **Secure Shell** (**SSH**) executable
    supports `ControlPersist`. You can find that by locating the `executor/playbook_executor.py`
    file within your Ansible installation path (just as we have done in the preceding
    sections) and looking for the line that states `set_default_transport()`. This
    is on line *76* in `ansible-core` 2.11.1, to give you an idea of where to look.
    Once you locate the appropriate place in the code, put a breakpoint here to allow
    you to follow the code, as shown in the following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 调试通常会将您从一个文件带到另一个文件，跳转到代码库中的其他位置。例如，在`PlaybookExecutor`类的`__init__()`函数中，有一段代码来缓存默认的**Secure
    Shell**（**SSH**）可执行文件是否支持`ControlPersist`。您可以通过定位`ansible`安装路径中的`executor/playbook_executor.py`文件（就像我们在前面的部分中所做的那样），并查找声明`set_default_transport()`的行来找到它。这在`ansible-core`
    2.11.1中是第76行，以便您知道要查找的位置。一旦找到代码中的适当位置，请在此处设置断点，以便您可以跟踪代码，如下面的屏幕截图所示：
- en: '![Figure 9.15 – Inserting the Python debugger into the Ansible playbook executor
    code'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.15-将Python调试器插入到Ansible playbook执行器代码中'
- en: '](Images/B17462_09_15.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_15.jpg)'
- en: Figure 9.15 – Inserting the Python debugger into the Ansible playbook executor
    code
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15-将Python调试器插入到Ansible playbook执行器代码中
- en: 'We can now run our `objmethod.yml` playbook again to get into a debugging state,
    as illustrated in the following screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以再次运行我们的`objmethod.yml` playbook以进入调试状态，如下面的屏幕截图所示：
- en: '![Figure 9.16 – Executing an example playbook to trigger the debugger'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.16-执行示例playbook以触发调试器'
- en: '](Images/B17462_09_16.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_16.jpg)'
- en: Figure 9.16 – Executing an example playbook to trigger the debugger
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16-执行示例playbook以触发调试器
- en: 'We''ll need to step into the function to follow the execution. Stepping into
    the function will take us to a different file, as shown here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要步入函数以跟踪执行。步入函数将带我们到另一个文件，如下所示：
- en: '![Figure 9.17 – Stepping into the code to follow the execution'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.17-步入代码以跟踪执行'
- en: '](Images/B17462_09_17.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_17.jpg)'
- en: Figure 9.17 – Stepping into the code to follow the execution
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17-步入代码以跟踪执行
- en: 'From here, we can use `list` to see the code in our new file, as illustrated
    in the following screenshot:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以使用`list`来查看我们新文件中的代码，如下面的屏幕截图所示：
- en: '![Figure 9.18 – Listing the adjacent code to our current position in the debugger'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.18-列出调试器中我们当前位置附近的代码'
- en: '](Images/B17462_09_18.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_18.jpg)'
- en: Figure 9.18 – Listing the adjacent code to our current position in the debugger
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18-列出调试器中我们当前位置附近的代码
- en: 'Walking a few more lines down, we come to a block of code that will execute
    an `ssh` command and check the output to determine whether `ControlPersist` is
    supported, as illustrated in the following screenshot:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 再走几行，我们来到一段代码块，将执行一个`ssh`命令并检查输出以确定`ControlPersist`是否受支持，如下面的屏幕截图所示：
- en: '![Figure 9.19 – Locating the code to establish whether ControlPersist is supported'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.19-定位代码以确定是否支持ControlPersist'
- en: '](Images/B17462_09_19.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_19.jpg)'
- en: Figure 9.19 – Locating the code to establish whether ControlPersist is supported
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19-定位代码以确定是否支持ControlPersist
- en: 'Let''s walk through the next couple of lines and then print out what the value
    of `err` is. This will show us the result of the `ssh` execution and the whole
    string that Ansible will be searching within, as illustrated in the following
    screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们走过接下来的几行，然后打印出`err`的值。这将向我们展示`ssh`执行的结果以及`Ansible`将在其中搜索的整个字符串，如下面的屏幕截图所示：
- en: '![Figure 9.20 – Analyzing the SSH connection results using the pdb debugger'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.20-使用pdb调试器分析SSH连接结果'
- en: '](Images/B17462_09_20.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_20.jpg)'
- en: Figure 9.20 – Analyzing the SSH connection results using the pdb debugger
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20-使用pdb调试器分析SSH连接结果
- en: As we can see, the search string is not within the `err` variable, so the value
    of `has_cp` remains as the default of `True`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，搜索字符串不在`err`变量中，因此`has_cp`的值仍然保持为`True`的默认值。
- en: A Quick Note on Forks and Debugging
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有关分叉和调试的快速说明
- en: When Ansible uses multiprocessing for multiple forks, debugging becomes difficult.
    A debugger may be attached to one fork and not another, which will make it very
    difficult to debug the code. Unless specifically debugging the multiprocessing
    code, it's a best practice to stick to a single fork.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Ansible`使用多进程进行多个分叉时，调试变得困难。调试器可能连接到一个分叉而不是另一个分叉，这将使调试代码变得非常困难。除非专门调试多进程代码，最好还是坚持使用单个分叉。
- en: Debugging remote code
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试远程代码
- en: Remote code is code that Ansible transports to a remote host to execute it.
    This is typically module code, or in the case of action plugins, other snippets
    of code. Using the debugging method we discussed in the previous section to debug
    module execution will not work, as Ansible simply copies the code over and then
    executes it. There is no terminal attached to remote code execution, and thus
    there is no way to attach it to a debugging prompt—that is, without editing the
    module code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 远程代码是`Ansible`传输到远程主机以执行的代码。这通常是模块代码，或者在动作插件的情况下，是其他代码片段。使用我们在前一节讨论的调试方法来调试模块执行将不起作用，因为`Ansible`只是复制代码然后执行它。远程代码执行没有连接到终端，因此没有办法将其连接到调试提示符，即在不编辑模块代码的情况下是不可能的。
- en: To debug module code, we need to edit the module code itself to insert a debugger
    breakpoint. Instead of directly editing the installed module file, create a copy
    of the file in a `library/` directory relative to the playbooks. This copy of
    the module code will be used instead of the installed file, which makes it easy
    to temporarily edit a module without disrupting other users of modules on the
    system.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试模块代码，我们需要编辑模块代码本身以插入调试器断点。不要直接编辑已安装的模块文件，而是在与playbooks相关的`library/`目录中创建文件的副本。这个模块代码的副本将被用来代替已安装的文件，这样就可以在不影响系统上模块的其他用户的情况下临时编辑模块。
- en: Unlike other Ansible code, module code cannot be directly debugged with `pdb`
    because the module code is assembled and then transported to a remote host. Thankfully,
    there is a solution in the form of a slightly different debugger named `rpdb`—the
    remote Python debugger. This debugger has the ability to start a listening service
    on a provided port to allow remote connections into the Python process. Connecting
    to the process remotely will allow the code to be debugged line by line, just
    as we did with other Ansible code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他Ansible代码不同，模块代码不能直接使用`pdb`进行调试，因为模块代码是组装然后传输到远程主机的。幸运的是，有一个解决方案，即一个稍微不同的调试器，名为`rpdb`
    - 远程Python调试器。这个调试器有能力在提供的端口上启动一个监听服务，以允许远程连接到Python进程。远程连接到进程将允许逐行调试代码，就像我们对其他Ansible代码所做的那样。
- en: 'To demonstrate how this debugger works, we''re first going to need a remote
    host. For this example, we''re using a remote host by the name of `debug.example.com`
    (though feel free to use your own example with the appropriate adjustments to
    hostnames). Next, we need a playbook to execute a module that we''d like to debug.
    The code is illustrated in the following snippet:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个调试器是如何工作的，我们首先需要一个远程主机。在这个例子中，我们使用一个名为`debug.example.com`的远程主机（当然，你可以根据需要使用你自己的示例进行相应的调整）。接下来，我们需要一个playbook来执行我们想要调试的模块。代码如下所示：
- en: '[PRE9]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Important Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The eagle-eyed among you will have noticed that, for the first time in this
    book, we have not used the **fully qualified class name** (**FQCN**) for the module
    reference. This is because the FQCN tells Ansible to use its own built-in module
    from the location it expects, where we actually want to load the local copy we
    will place in our local `library/` directory. As a result, we must use just the
    short-form name of the module in this one instance.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你们中敏锐的人可能已经注意到，在本书中，我们第一次没有使用**完全限定类名**（**FQCN**）来引用模块。这是因为FQCN告诉Ansible使用它自己期望的位置的内置模块，而我们实际上想要加载我们将放置在本地`library/`目录中的本地副本。因此，在这个特定情况下，我们必须只使用模块的简称。
- en: 'We will also need a new inventory file to reference our new test host. As I
    don''t have the **Domain Name System** (**DNS**) entry set up for this host, I''m
    using the special `ansible_host` variable in the inventory to tell Ansible which
    **Internet Protocol** (**IP**) address to connect to `debug.example.com` on, as
    illustrated in the following code snippet:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个新的清单文件来引用我们的新测试主机。由于我没有为这个主机设置**域名系统**（**DNS**）条目，我在清单中使用特殊的`ansible_host`变量，告诉Ansible连接到`debug.example.com`上的**互联网协议**（**IP**）地址，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Important Note
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Don't forget to set up SSH authentication between your two hosts—I'm using an
    SSH key so that I don't need to type in a password every time I run `ansible-playbook`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在两个主机之间设置SSH身份验证 - 我使用SSH密钥，这样我就不需要每次运行`ansible-playbook`时都输入密码。
- en: 'This play simply calls the `ansible.builtin.systemd` module to ensure that
    the `nginx` service is stopped and will not start up on boot. As we stated previously,
    we need to make a copy of the service module and place it in `library/`. The location
    of the service module to copy from will vary based on the way Ansible is installed.
    On my demo system for this book, it is located in `/usr/local/lib/python3.8/dist-packages/ansible/modules/systemd.py`.
    Then, we can edit it to put in our breakpoint. I am inserting this at line *358*
    on my system—this is correct for `ansible-core` 2.11.1 but may change as newer
    versions are released. However, the following screenshot should give you an idea
    of where to insert the code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个play只是调用`ansible.builtin.systemd`模块来确保`nginx`服务被停止，并且不会在启动时启动。正如我们之前所述，我们需要复制服务模块并将其放置在`library/`中。要复制的服务模块的位置将根据Ansible的安装方式而变化。在我为本书演示的演示系统上，它位于`/usr/local/lib/python3.8/dist-packages/ansible/modules/systemd.py`。然后，我们可以编辑它以插入我们的断点。我在我的系统上将其插入到第*358*行
    - 这对于`ansible-core` 2.11.1是正确的，但随着新版本的发布可能会发生变化。然而，下面的屏幕截图应该给你一个插入代码的想法：
- en: '![Figure 9.21 – Inserting the remote Python debugger into Ansible module code'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.21 - 将远程Python调试器插入到Ansible模块代码中'
- en: '](Images/B17462_09_21.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_21.jpg)'
- en: Figure 9.21 – Inserting the remote Python debugger into Ansible module code
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.21 - 将远程Python调试器插入到Ansible模块代码中
- en: We'll put the breakpoint just before the `systemctl` variable value gets created.
    First, the `rpdb` module must be imported (meaning that the `rpdb` Python library
    needs to exist on the remote host), and then the breakpoint needs to be created
    with `set_trace()`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在创建`systemctl`变量值之前设置断点。首先，必须导入`rpdb`模块（这意味着远程主机上必须存在`rpdb` Python库），然后需要使用`set_trace()`创建断点。
- en: Important Note
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: On Ubuntu Server 20.04 (as with the host that was used in the demo), `rpdb` can
    be installed with `pip` using the following command: `sudo pip3 install rpdb`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu Server 20.04上（就像演示中使用的主机一样），可以使用以下命令使用`pip`安装`rpdb`：`sudo pip3 install
    rpdb`。
- en: Unlike the regular debugger, this function will open a port and listen for external
    connections. By default, the function will listen for connections to port `4444` on
    the address `127.0.0.1`. However, that address is not exposed over the network,
    so in my example, I've instructed `rpdb` to listen on address `0.0.0.0`, which
    is effectively every address on the host (though as I'm sure you'll understand,
    this has security implications you need to be careful of!).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规调试器不同，此函数将打开一个端口并监听外部连接。默认情况下，该函数将在地址`127.0.0.1`上监听端口`4444`的连接。但是，该地址不会在网络上公开，因此在我的示例中，我已经指示`rpdb`在地址`0.0.0.0`上监听，这实际上是主机上的每个地址（尽管我相信您会理解，这会带来您需要小心的安全隐患！）。
- en: Important Note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If the host on which you are running `rpdb` has a firewall (for example, `firewalld`
    or `ufw`), you will need to open port `4444` for the example given here to work.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行`rpdb`的主机有防火墙（例如`firewalld`或`ufw`），则需要为本例中的端口`4444`打开端口。
- en: 'We can now run this playbook to set up the server that will wait for a client
    connection, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行这个playbook来设置等待客户端连接的服务器，如下所示：
- en: '![Figure 9.22 – Running a test playbook for remote module debugging'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.22 - 运行远程模块调试的测试playbook'
- en: '](Images/B17462_09_22.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_22.jpg)'
- en: Figure 9.22 – Running a test playbook for remote module debugging
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.22 - 运行远程模块调试的测试playbook
- en: 'Now that the server is running, we can connect to it from another terminal.
    Connecting to the running process can be accomplished with the `telnet` program,
    as illustrated in the following screenshot:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务器正在运行，我们可以从另一个终端连接到它。可以使用`telnet`程序连接到正在运行的进程，如下面的截图所示：
- en: '![Figure 9.23 – Using telnet to connect to a remote Python debugger session
    for module debugging'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.23 - 使用telnet连接到远程Python调试器会话进行模块调试'
- en: '](Images/B17462_09_23.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_23.jpg)'
- en: Figure 9.23 – Using telnet to connect to a remote Python debugger session for
    module debugging
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.23 - 使用telnet连接到远程Python调试器会话进行模块调试
- en: 'From this point on, we can debug as normal. The commands we used before still
    exist, such as `list` to show where in the code the current frame is, as illustrated
    in the following screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，我们可以像平常一样进行调试。我们之前使用的命令仍然存在，比如`list`用来显示当前帧在代码中的位置，如下面的截图所示：
- en: '![Figure 9.24 – Using the now-familiar Python debugger commands in a remote
    debugging session'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.24 - 在远程调试会话中使用现熟悉的Python调试器命令'
- en: '](Images/B17462_09_24.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_24.jpg)'
- en: Figure 9.24 – Using the now-familiar Python debugger commands in a remote debugging
    session
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.24 - 在远程调试会话中使用现熟悉的Python调试器命令
- en: Using the debugger, we can walk through the `systemd` module to track how it
    determines the path to the underlying tool, trace which commands are executed
    on the host, determine how a change is computed, and so on. The entire file can
    be stepped through, including any other external libraries the module may make
    use of, allowing the debugging of other non-module code on the remote host as
    well.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试器，我们可以逐步跟踪`systemd`模块，以跟踪它如何确定底层工具的路径，跟踪在主机上执行了哪些命令，确定如何计算更改等。整个文件都可以逐步执行，包括模块可能使用的任何其他外部库，从而允许调试远程主机上的其他非模块代码。
- en: 'If the debugging session allows the module to exit cleanly, the playbook''s
    execution will return to normal. However, if the debugging session is disconnected
    before the module completes, the playbook will produce an error, as shown in the
    following screenshot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调试会话允许模块干净地退出，playbook的执行将恢复正常。但是，如果在模块完成之前断开调试会话，playbook将产生错误，如下面的截图所示：
- en: '![Figure 9.25 – An example of an error produced when terminating the remote
    debugging session early'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.25 - 在提前终止远程调试会话时产生错误的示例'
- en: '](Images/B17462_09_25.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_09_25.jpg)'
- en: Figure 9.25 – An example of an error produced when terminating the remote debugging
    session early
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.25 - 在提前终止远程调试会话时产生错误的示例
- en: Because of this side effect, it is best to not exit the debugger early, and
    instead issue a `continue` command when your debugging is finished.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种副作用，最好不要提前退出调试器，而是在调试完成后发出`continue`命令。
- en: Debugging action plugins
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试动作插件
- en: Some modules are actually action plugins. These are tasks that will execute
    some code locally before transporting code to the remote host. Some example action
    plugins include `copy`, `fetch`, `script`, and `template`. The source to these
    plugins can be found in `plugins/action/`. Each plugin will have its own file
    in this directory that can be edited to have breakpoints inserted in order to
    debug the code that's executed, prior to (or in lieu of) sending code to the remote
    host. Debugging these is typically done with `pdb` since most of the code is executed
    locally.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有些模块实际上是动作插件。这些是在将代码传输到远程主机之前在本地执行一些代码的任务。一些示例动作插件包括`copy`、`fetch`、`script`和`template`。这些插件的源代码可以在`plugins/action/`中找到。该目录中的每个插件都有自己的文件，可以在其中插入断点，以便调试执行的代码，而不是将代码发送到远程主机。调试这些通常使用`pdb`来完成，因为大多数代码是在本地执行的。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Ansible is a piece of software, and software breaks; it's not a matter of if,
    but when. Invalid input, improper assumptions, and unexpected environments are
    all things that can lead to a frustrating situation when tasks and plays are not
    performing as expected. Introspection and debugging are troubleshooting techniques
    that can quickly turn frustration into elation when a root cause is discovered.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是一款软件，软件会出现故障；这不是一个“如果”，而是一个“何时”的问题。无效的输入、不正确的假设和意外的环境都可能导致任务和操作表现不如预期时产生令人沮丧的情况。内省和调试是可以快速将沮丧转化为喜悦的故障排除技术，当发现根本原因时。
- en: In this chapter, we learned about how to get Ansible to log its actions to a
    file, and how to change the verbosity level of Ansible's output. We then learned
    how to inspect variables to ensure their values are in line with your expectations
    before we moved on to debugging Ansible code in detail. Furthermore, we walked
    through the process of inserting breakpoints into core Ansible code and executed
    both local and remote Python debugging sessions using standard Python tools.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何让Ansible将其操作记录到文件中，以及如何更改Ansible输出的详细程度。然后，我们学习了如何检查变量，以确保它们的值符合您的期望，然后再详细调试Ansible代码。此外，我们演示了如何在核心Ansible代码中插入断点，并使用标准Python工具执行本地和远程Python调试会话。
- en: In the next chapter, we will learn how to extend the functionality of Ansible
    by writing our own modules, plugins, and inventory sources.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过编写自己的模块、插件和清单来源来扩展Ansible的功能。
- en: Questions
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What level of verbosity would you need to launch Ansible with to see details
    such as connection attempts?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看连接尝试等详细信息，您需要以哪个详细程度启动Ansible？
- en: a) Level 3 or above
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: a）级别为3或以上
- en: b) Level 2 or above
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: b）级别为2或以上
- en: c) Level 1 or above
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: c）级别为1或以上
- en: d) Level 4
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: d）级别为4
- en: Why should you be careful with verbosity levels above level one if you are using
    sensitive data in your playbook?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在playbook中使用敏感数据，为什么应该小心使用高于一级的详细程度？
- en: a) Higher verbosity levels don't support the use of vaults.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: a）更高的详细程度不支持使用vaults。
- en: b) Higher verbosity levels may log sensitive data to the console and/or log
    file.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: b）更高的详细程度可能会将敏感数据记录到控制台和/或日志文件中。
- en: c) Higher verbosity levels will print SSH passwords.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: c）更高的详细程度将打印SSH密码。
- en: 'Ansible can be centrally configured to log its output to a file by:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过集中配置Ansible将其输出记录到文件：
- en: a) Using the `ANSIBLE_LOG_PATH` environment variable
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: a）使用`ANSIBLE_LOG_PATH`环境变量
- en: b) Using the `log_path` directive in `ansible.cfg`
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: b）在`ansible.cfg`中使用`log_path`指令
- en: c) Redirecting the output of each playbook run to a file
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: c）将每个playbook运行的输出重定向到文件
- en: d) All of these
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: d）所有这些
- en: 'The name of the module used for variable introspection is:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于变量内省的模块的名称是：
- en: a) `ansible.builtin.analyze`
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: a）`ansible.builtin.analyze`
- en: b) `ansible.builtin.introspect`
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: b）`ansible.builtin.introspect`
- en: c) `ansible.builtin.debug`
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: c）`ansible.builtin.debug`
- en: d) `ansible.builtin.print`
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: d）`ansible.builtin.print`
- en: When referencing subelements in Ansible variables, which syntax is the safest
    to prevent clashes with reserved Python names?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在引用Ansible变量中的子元素时，哪种语法最安全，以防止与保留的Python名称冲突？
- en: a) Dot notation
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: a）点表示法
- en: b) Standard subscript syntax
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: b）标准下标语法
- en: c) Ansible subelement notation
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: c）Ansible子元素表示法
- en: d) Standard dot notation
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: d）标准点表示法
- en: 'Unless you need to perform low-level code debugging, you can debug the flow
    of a playbook using:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除非您需要执行低级别的代码调试，否则可以使用以下方法调试playbook的流程：
- en: a) The debug strategy
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: a）调试策略
- en: b) Debug execution
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: b）调试执行
- en: c) Debug task planner
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: c）调试任务计划程序
- en: d) None of these
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: d）这些都不是
- en: 'The name of the Python local debugger as demonstrated in this book is:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本书中演示的Python本地调试器的名称是：
- en: a) `PyDebug`
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: a）`PyDebug`
- en: b) `python-debug`
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: b）`python-debug`
- en: c) `pdb`
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: c）`pdb`
- en: d) `pdebug`
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: d）`pdebug`
- en: 'You can also debug the execution of modules on remote hosts:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以调试远程主机上模块的执行：
- en: a) Using the Python `rpdb` module.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: a）使用Python的`rpdb`模块。
- en: b) By copying the playbook to the host and using `pdb`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: b）通过将playbook复制到主机并使用`pdb`。
- en: c) Via a packet tracer such as `tcpdump`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: c）通过数据包跟踪器，如`tcpdump`。
- en: d) This is not possible.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: d）这是不可能的。
- en: 'Unless configured otherwise, the remote Python debugger listens for connections
    on:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除非另有配置，远程Python调试器会在哪里接收连接？
- en: a) `127.0.0.1:4433`
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: a）`127.0.0.1:4433`
- en: b) `0.0.0.0:4444`
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: b）`0.0.0.0:4444`
- en: c) `127.0.0.1:4444`
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: c）`127.0.0.1:4444`
- en: d) `0.0.0.0:4433`
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: d）`0.0.0.0:4433`
- en: Why should you not end your remote Python debugging session without letting
    the code run to completion?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么不应该在不让代码运行完成的情况下结束远程Python调试会话？
- en: a) It results in an error in your playbook run.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: a）这会导致在您的playbook运行中出现错误。
- en: b) It will result in loss of files.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: b）这将导致文件丢失。
- en: c) It might corrupt your Ansible installation.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: c）这可能会损坏您的Ansible安装。
- en: d) It will result in a hung debug session.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: d）这将导致挂起的调试会话。

- en: Low-Level Network Device Interactions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低级网络设备交互
- en: In [Chapter 1](2bb48797-d649-4704-85fc-0f5244ed34fb.xhtml), *Review of TCP/IP
    Protocol Suite and Python*, we looked at the theories and specifications behind
    network communication protocols. We also took a quick tour of the Python language.
    In this chapter, we will start to dive deeper into the management of network devices
    using Python. In particular, we will examine the different ways in which we can
    use Python to programmatically communicate with legacy network routers and switches.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](2bb48797-d649-4704-85fc-0f5244ed34fb.xhtml)中，*TCP/IP协议套件和Python概述*，我们研究了网络通信协议背后的理论和规范。我们还快速浏览了Python语言。在本章中，我们将开始深入探讨使用Python管理网络设备的不同方式，特别是我们如何使用Python与传统网络路由器和交换机进行程序通信。
- en: What do I mean by legacy network routers and switches? While it is hard to imagine
    any networking device coming out today without an **Application Program Interface**
    (**API**) for programmatic communication, it is a known fact that many of the
    network devices deployed in previous years did not contain API interfaces. The
    intended method of management for those devices was through **Command Line Interfaces**
    (**CLIs**) using terminal programs, which were originally developed with a human
    engineer in mind. The management relied on the engineer's interpretation of the
    data returned from the device for appropriate action. As the number of network
    devices and the complexity of the network grew, it became increasingly difficult
    to manually manage them one by one.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的传统网络路由器和交换机是什么意思？虽然很难想象今天出现的任何网络设备都没有用于程序通信的**应用程序接口**（**API**），但众所周知，许多在以前部署的网络设备中并不包含API接口。这些设备的管理方式是通过使用终端程序的**命令行接口**（**CLI**），最初是为了人类工程师而开发的。管理依赖于工程师对设备返回的数据的解释以采取适当的行动。随着网络设备数量和网络复杂性的增加，手动逐个管理它们变得越来越困难。
- en: 'Python has two great libraries that can help with these tasks, Pexpect and
    Paramiko, as well as other libraries derived from them. This chapter will cover
    Pexpect first, then move on with examples from Paramiko. Once you understand the
    basics of Paramiko, it is easy to branch out to expanded libraries such as Netmiko.
    It is also worth mentioning that Ansible (covered in [Chapters 4](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml),
    *The Python Automation Framework – Ansible Basics*, and [Chapter 5](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml), *The
    Python Automation Framework – Beyond Basics*) relies heavily on Paramiko for its
    network modules. In this chapter, we will take a look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python有两个很棒的库可以帮助完成这些任务，Pexpect和Paramiko，以及从它们衍生出的其他库。本章将首先介绍Pexpect，然后以Paramiko的示例进行讲解。一旦你了解了Paramiko的基础知识，就很容易扩展到Netmiko等更多的库。值得一提的是，Ansible（在[第4章](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml)中介绍，*Python自动化框架-
    Ansible基础*，以及[第5章](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml)中介绍，*Python自动化框架-进阶*）在其网络模块中大量依赖Paramiko。在本章中，我们将讨论以下主题：
- en: The challenges of the CLI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行界面的挑战
- en: Constructing a virtual lab
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建虚拟实验室
- en: The Python Pexpect library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python Pexpect库
- en: The Python Paramiko library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python Paramiko库
- en: The downsides of Pexpect and Paramiko
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pexpect和Paramiko的缺点
- en: Let's get started!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: The challenges of the CLI
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行界面的挑战
- en: 'At the Interop expo in Las Vegas in 2014, *BigSwitch Networks''* CEO Douglas
    Murray displayed the following slide to illustrate what had changed in **Data
    Center Networking** (**DCN**) in the 20 years between 1993 to 2013:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在2014年的Interop博览会上，*BigSwitch Networks*的首席执行官道格拉斯·默里展示了以下幻灯片，以说明在1993年至2013年间**数据中心网络**（**DCN**）发生了什么变化：
- en: '![](assets/2b428760-cc25-4349-a112-3ec3dd5e2f71.png)Data center networking
    changes (source: [https://www.bigswitch.com/sites/default/files/presentations/murraydouglasstartuphotseatpanel.pdf](https://www.bigswitch.com/sites/default/files/presentations/murraydouglasstartuphotseatpanel.pdf))'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: 数据中心网络变化（来源：[https://www.bigswitch.com/sites/default/files/presentations/murraydouglasstartuphotseatpanel.pdf](https://www.bigswitch.com/sites/default/files/presentations/murraydouglasstartuphotseatpanel.pdf)）
- en: 'His point was apparent: not much had changed in those 20 years in the way we
    manage network devices. While he might have been negatively biased toward the
    incumbent vendors when displaying this slide, his point is well taken. In his
    opinion, the only thing that had changed about managing routers and switches in
    20 years was the protocol changing from the less secure Telnet to the more secure SSH.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 他的观点很明显：在这20年里，我们管理网络设备的方式几乎没有什么变化。虽然他在展示这张幻灯片时可能对现任供应商持有负面偏见，但他的观点是很有道理的。在他看来，20年来管理路由器和交换机唯一改变的是协议从不太安全的Telnet变为更安全的SSH。
- en: It was right around the same time in 2014 that we started to see the industry
    coming to a consensus about the clear need to move away from manual, human-driven
    CLI toward an automatic, computer-centric automation API. Make no mistake, we
    still need to directly communicate with the device when making network designs,
    bringing up initial proof of concepts, and deploying the topology for the first
    time. However, once we have moved beyond the initial deployment, the requirement
    is to consistently make the same changes reliably, to make them error-free, and
    to repeat them over and over again without the engineer being distracted or feeling
    tired. This requirement sounds like an ideal job for computers and our favorite
    language, Python.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正是在2014年左右，我们开始看到行业达成共识，即远离手动、人为驱动的CLI，转向自动化、以计算机为中心的API。毫无疑问，当我们进行网络设计、启动初步概念验证和首次部署拓扑时，我们仍需要直接与设备进行通信。然而，一旦我们超越了初始部署，要求是要始终可靠地进行相同的更改，使其无误，并且一遍又一遍地重复，而不让工程师分心或感到疲倦。这个要求听起来就像是计算机和我们最喜爱的语言Python的理想工作。
- en: Referring back to the slide, the main challenge is the interaction between the
    router and the administrator. The router will output a series of information and
    will expect the administrator to enter a series of manual commands from the engineer's
    interpretation of the output. For example, you have to type in `enable` to get
    into a privileged mode, and upon receiving the returned prompt with the `#` sign,
    you then type in `configure terminal` in order to go into the configuration mode.
    The same process can further be expanded into the interface configuration mode
    and routing protocol configuration mode. This is in sharp contrast to a computer-driven,
    programmatic mindset. When the computer wants to accomplish a single task, say,
    put an IP address on an interface, it wants to structurally give all the information
    to the router at once, and it would expect a single `yes` or `no` answer from
    the router to indicate the success or failure of the task.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 回到幻灯片，主要挑战在于路由器和管理员之间的交互。路由器将输出一系列信息，并期望管理员根据工程师对输出的解释输入一系列手动命令。例如，你必须输入`enable`才能进入特权模式，并在收到带有`#`符号的返回提示后，你再输入`configure
    terminal`以进入配置模式。同样的过程可以进一步扩展到接口配置模式和路由协议配置模式。这与计算机驱动的程序思维形成鲜明对比。当计算机想要完成单个任务时，比如在接口上放置IP地址，它希望一次性将所有信息结构化地提供给路由器，并且期望路由器给出一个`yes`或`no`的答复来指示任务的成功或失败。
- en: The solution, as implemented by both Pexpect and Paramiko, is to treat the interactive
    process as a child process and watch over the interaction between the process
    and the destination device. Based on the returned value, the parent process will
    decide the subsequent action, if any.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Pexpect和Paramiko都实现了这个解决方案，即将交互过程视为子进程，并监视进程与目标设备之间的交互。根据返回的值，父进程将决定随后的操作（如果有的话）。
- en: Constructing a virtual lab
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建虚拟实验室
- en: 'Before we dive into the packages, let''s examine the options of putting together
    a lab for the benefit of learning. As the old saying goes, *practice makes perfect*:
    we need an isolated sandbox to safely make mistakes, try out new ways of doing
    things, and repeat some of the steps to reinforce concepts that were not clear
    in the first try. It is easy enough to install Python and the necessary packages
    for the management host, but what about those routers and switches that we want
    to simulate?'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究这些软件包之前，让我们来看看组建一个实验室以便学习的选项。正如古语所说，“熟能生巧”：我们需要一个隔离的沙盒来安全地犯错误，尝试新的做事方式，并重复一些步骤以加强在第一次尝试时不清楚的概念。安装Python和管理主机所需的软件包很容易，但那些我们想要模拟的路由器和交换机呢？
- en: 'To put together a network lab, we basically have two options, each with its
    advantages and disadvantages:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要组建一个网络实验室，我们基本上有两个选项，每个选项都有其优势和劣势：
- en: '**Physical device**: This option consists of physical devices that you can
    see and touch. If you are lucky enough, you might be able to put together a lab
    that is an exact replication of your production environment:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理设备**：这个选项包括可以看到和触摸的物理设备。如果你足够幸运，你可能能够组建一个与你的生产环境完全相同的实验室。'
- en: '**Advantages**: It is an easy transition from lab to production, easier to
    understand by managers and fellow engineers who can look at and touch the devices.
    In short, the comfort level with physical devices is extremely high because of
    familiarity.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优势**：从实验室到生产的过渡更容易，易于经理和同事理解并触摸设备。简而言之，由于熟悉度高，对物理设备的舒适度非常高。'
- en: '**Disadvantages**: It is relatively expensive to pay for a device that is only
    used in the lab. Devices require engineering hours to rack and stack and are not
    very flexible once constructed.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**劣势**：为实验室使用而支付设备相对昂贵。设备需要工程师花费时间来安装，并且一旦构建完成后就不太灵活。'
- en: '**Virtual devices**: These are emulations or simulations of actual network
    devices. They are either provided by the vendors or by the open source community:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟设备**：这些是实际网络设备的仿真或模拟。它们可以是供应商提供的，也可以是开源社区提供的。'
- en: '**Advantages**: Virtual devices are easier to set up, relatively cheap, and
    can make changes to the topology quickly.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优势**：虚拟设备更容易设置，成本相对较低，并且可以快速更改拓扑结构。'
- en: '**Disadvantages**: They are usually a scaled-down version of their physical
    counterpart. Sometimes there are feature gaps between the virtual and the physical
    device.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**劣势**：它们通常是其物理对应物的缩减版本。有时虚拟设备和物理设备之间存在功能差距。'
- en: Of course, deciding on a virtual or physical lab is a personal decision derived
    from a trade-off between the cost, ease of implementation, and the risk of having
    a gap between lab and production. In some of the environments I have worked on,
    the virtual lab is used when doing an initial proof-of-concept while the physical
    lab is used when we move closer to the final design.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，决定使用虚拟实验室还是物理实验室是一个个人决定，需要在成本、实施的便利性和实验室与生产之间的差距之间进行权衡。在我工作过的一些环境中，当进行初步概念验证时使用虚拟实验室，而在接近最终设计时使用物理实验室。
- en: In my opinion, as more and more vendors decide to produce virtual appliances,
    the virtual lab is the way to proceed in a learning environment. The feature gap
    of the virtual appliance is relatively small and specifically documented, especially
    when the virtual instance is provided by the vendor. The cost of the virtual appliance
    is relatively small compared to buying physical devices. The time-to-build using
    virtual devices is quicker because they are usually just software programs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，随着越来越多的供应商决定生产虚拟设备，虚拟实验室是学习环境中的正确选择。虚拟设备的功能差距相对较小，并且有专门的文档，特别是当虚拟实例由供应商提供时。与购买物理设备相比，虚拟设备的成本相对较低。使用虚拟设备构建的时间更快，因为它们通常只是软件程序。
- en: For this book, I will use a combination of physical and virtual devices for
    concept demonstration with a preference for virtual devices. For the examples
    we will see, the differences should be transparent. If there are any known differences
    between the virtual and physical devices pertaining to our objectives, I will
    make sure to list them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这本书，我将使用物理和虚拟设备的组合来进行概念演示，更偏向于虚拟设备。对于我们将看到的示例，差异应该是透明的。如果虚拟和物理设备在我们的目标方面有任何已知的差异，我会确保列出它们。
- en: On the virtual lab front, besides images from various vendors, I am using a
    program from Cisco called **Virtual Internet Routing Lab** (**VIRL**), [https://learningnetworkstore.cisco.com/virtual-internet-routing-lab-virl/cisco-personal-edition-pe-20-nodes-virl-20](https://learningnetworkstore.cisco.com/virtual-internet-routing-lab-virl/cisco-personal-edition-pe-20-nodes-virl-20).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟实验室方面，除了来自各种供应商的镜像，我还在使用一款来自Cisco的程序**Virtual Internet Routing Lab**（**VIRL**）[https://learningnetworkstore.cisco.com/virtual-internet-routing-lab-virl/cisco-personal-edition-pe-20-nodes-virl-20](https://learningnetworkstore.cisco.com/virtual-internet-routing-lab-virl/cisco-personal-edition-pe-20-nodes-virl-20)。
- en: I want to point out that the use of this program is entirely optional for the
    reader. But it is strongly recommended that the reader have some lab equipment
    to follow along with the examples in this book.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我想指出，读者完全可以选择是否使用这个程序。但强烈建议读者有一些实验室设备来跟随本书中的示例。
- en: Cisco VIRL
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思科VIRL
- en: I remember when I first started to study for my **Cisco Certified Internetwork
    Expert** (**CCIE**) lab exam, I purchased some used Cisco equipment from eBay
    to study with. Even at a discount, each router and switch cost hundreds of US
    dollars, so to save money, I purchased some really outdated Cisco routers from
    the 1980s (search for Cisco AGS routers in your favorite search engine for a good
    chuckle), which significantly lacked features and horsepower, even for lab standards.
    As much as it made for an interesting conversation with family members when I
    turned them on (they were really loud), putting the physical devices together
    was not fun. They were heavy and clunky, it was a pain to connect all the cables,
    and to introduce link failure, I would literally unplug a cable.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得当我第一次开始准备我的**思科认证网络专家**（**CCIE**）实验考试时，我从eBay购买了一些二手思科设备来学习。即使打折，每台路由器和交换机也要花费数百美元，所以为了省钱，我购买了一些上世纪80年代的非常过时的思科路由器（在您喜欢的搜索引擎中搜索思科AGS路由器，会让您大笑一番），它们明显缺乏功能和性能，即使是对实验室标准来说。尽管当我打开它们时（它们的声音很大），它们给家人带来了有趣的对话，但组装物理设备并不好玩。它们又重又笨重，连接所有的电缆很麻烦，为了引入链路故障，我会直接拔掉一根电缆。
- en: Fast-forward a few years. **Dynamip** was created and I fell in love with how
    easy it was to create different network scenarios. This was especially important
    when I tried to learn a new concept. All you need is the IOS images from Cisco,
    a few carefully constructed topology files, and you can easily construct a virtual
    network that you can test your knowledge on. I had a whole folder of network topologies,
    pre-saved configurations, and different version of images, as called for by the
    scenario. The addition of a GNS3 frontend gives the whole setup a beautiful GUI
    facelift. With GNS3, you can just click and drop your links and devices; you can
    even just print out the network topology for your manager right out of the GNS3
    design panel. The only thing that was lacking was the tool not being officially
    blessed by the vendor and the perceived lack of credibility because of it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 快进几年。**Dynamip**被创建，我爱上了它创建不同网络场景的简易性。当我尝试学习一个新概念时，这尤其重要。您只需要来自Cisco的IOS镜像，一些精心构建的拓扑文件，就可以轻松构建一个虚拟网络，以便测试您的知识。我有一个完整的网络拓扑文件夹，预先保存的配置和不同版本的镜像，根据场景的需要。GNS3前端的添加使整个设置具有美丽的GUI外观。使用GNS3，您可以轻松地点击和拖放您的链接和设备；您甚至可以直接从GNS3设计面板打印出网络拓扑图给您的经理。唯一缺少的是该工具没有得到供应商的官方认可，因此缺乏可信度。
- en: In 2015, the Cisco community decided to fulfill this need by releasing the Cisco
    VIRL. If you have a server that meets the requirements and you are willing to
    pay for the required annual license, this is my preferred method of developing
    and trying out much of the Python code, both for this book and my own production
    use.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，Cisco社区决定通过发布Cisco VIRL来满足这一需求。如果您有一台符合要求的服务器，并且愿意支付所需的年度许可证费用，这是我首选的开发和尝试大部分Python代码的方法，无论是为这本书还是我的自己的生产使用。
- en: As of January 1 2017, only the personal edition 20-Node license is available
    for purchase for USD $199.99 per year.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2017年1月1日，只有20节点个人版许可证可供购买，价格为每年199.99美元。
- en: 'Even at a monetary cost, in my opinion, the VIRL platform offers a few advantages
    over other alternatives:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，即使需要花费一些金钱，VIRL平台相对于其他替代方案有一些优势：
- en: '**Ease of use**: All the images for IOSv, IOS-XRv, CSR100v, NX-OSv, and ASAv
    are included in a single download.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易用性**：所有IOSv、IOS-XRv、CSR100v、NX-OSv和ASAv的镜像都包含在一个单独的下载中。'
- en: '**Official** (**kind of**): Although support is community-driven, it is a widely
    used tool internally at Cisco. Because of its popularity, the bugs get fixed quickly,
    new features are carefully documented, and useful knowledge is widely shared among
    its users.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**官方**（**有点**）：尽管支持是由社区驱动的，但它在Cisco内部被广泛使用。由于其受欢迎程度，错误得到快速修复，新功能得到仔细记录，并且有用的知识在其用户之间广泛分享。'
- en: '**The cloud migration path**: The project offers a logical migration path when
    your emulation grows out of the hardware power you have, such as Cisco dCloud
    ([https://dcloud.cisco.com/](https://dcloud.cisco.com/)), VIRL on Packet ([http://virl.cisco.com/cloud/](http://virl.cisco.com/cloud/)),
    and Cisco DevNet ([https://developer.cisco.com/](https://developer.cisco.com/)).
    This is an important feature that sometimes gets overlooked.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云迁移路径：当您的仿真超出您拥有的硬件能力时，比如Cisco dCloud（[https://dcloud.cisco.com/](https://dcloud.cisco.com/)）、Packet上的VIRL（[http://virl.cisco.com/cloud/](http://virl.cisco.com/cloud/)）和Cisco
    DevNet（[https://developer.cisco.com/](https://developer.cisco.com/)）时，该项目提供了一个逻辑的迁移路径。这是一个有时被忽视的重要特性。
- en: '**The link and control-plane simulation**: The tool can simulate latency, jitter,
    and packet loss on a per-link basis for real-world link characteristics. There
    is also a control-plane traffic generator for external route injection.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接和控制平面模拟：该工具可以模拟真实世界链路特性的每个链路的延迟、抖动和数据包丢失。还有一个用于外部路由注入的控制平面流量生成器。
- en: '**Others**: The tool offers some nice features, such as VM Maestro topology
    design and simulation control, AutoNetkit for automatic config generation, and
    user workspace management if the server is shared. There are also open source
    projects such as virlutils ([https://github.com/CiscoDevNet/virlutils](https://github.com/CiscoDevNet/virlutils)),
    which are actively worked on by the community to enhance the workability of the
    tool.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他**：该工具提供了一些不错的功能，比如VM Maestro拓扑设计和模拟控制，AutoNetkit用于自动生成配置，以及用户工作空间管理（如果服务器是共享的）。还有一些开源项目，比如virlutils（[https://github.com/CiscoDevNet/virlutils](https://github.com/CiscoDevNet/virlutils)），由社区积极开发，以增强该工具的可用性。'
- en: We will not use all of the features in VIRL in this book. But since this is
    a relatively new tool that is worth your consideration, if you do decide this
    is the tool you would like to use, I want to offer some of the setups I used.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们不会使用VIRL中的所有功能。但由于这是一个相对较新的工具，值得您考虑，如果您决定使用这个工具，我想提供一些我使用过的设置。
- en: Again, I want to stress the importance of having a lab, but it does not need
    to be the Cisco VIRL lab. The code examples provided in this book should work
    across any lab device, as long as they run the same software type and version.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调拥有一个实验室的重要性，但不一定需要是思科VIRL实验室。本书中提供的代码示例应该适用于任何实验室设备，只要它们运行相同的软件类型和版本。
- en: VIRL tips
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VIRL提示
- en: 'The VIRL website ([http://virl.cisco.com/](http://virl.cisco.com/)) offers
    lots of guidance, preparation, and documentation. I also find that the VIRL user
    community generally offers quick and accurate help. I will not repeat information
    already offered in those two places; however, here are some of the setups I use
    for the lab in this book:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: VIRL网站（[http://virl.cisco.com/](http://virl.cisco.com/)）提供了大量的指导、准备和文档。我还发现VIRL用户社区通常能够提供快速准确的帮助。我不会重复这两个地方已经提供的信息；然而，这里是我在本书中用于实验室的一些设置：
- en: 'VIRL uses two virtual Ethernet interfaces for connections. The first interface
    is set up as NAT for the host machine''s internet connection, and the second is
    used for local management interface connectivity (VMnet2 in the following example).
    I use a separate virtual machine with a similar network setup in order to run
    my Python code, with the first primary Ethernet used for internet connectivity
    and the second Ethernet connection to Vmnet2 for lab device management network:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: VIRL使用两个虚拟以太网接口进行连接。第一个接口设置为主机机器的互联网连接的NAT，第二个用于本地管理接口的连接（在下面的示例中为VMnet2）。我使用一个具有类似网络设置的单独的虚拟机来运行我的Python代码，第一个主要以太网用于互联网连接，第二个以太网连接到Vmnet2，用于实验室设备管理网络：
- en: '![](assets/c82cd2d1-cdde-4f81-bc77-ae9d8fa0975c.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c82cd2d1-cdde-4f81-bc77-ae9d8fa0975c.png)'
- en: 'VMnet2 is a custom network created to connect the Ubuntu host with the VIRL
    virtual machine:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: VMnet2是一个自定义网络，用于将Ubuntu主机与VIRL虚拟机连接：
- en: '![](assets/85f2152f-11e7-4be2-918e-d6153657d2be.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/85f2152f-11e7-4be2-918e-d6153657d2be.png)'
- en: 'In the Topology Design option, I set the Management Network option to Shared
    flat network in order to use VMnet2 as the management network on the virtual routers:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在拓扑设计选项中，我将管理网络选项设置为共享平面网络，以便在虚拟路由器上使用VMnet2作为管理网络：
- en: '![](assets/02656522-3921-4e03-a513-4d10675cd081.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/02656522-3921-4e03-a513-4d10675cd081.png)'
- en: 'Under the node configuration, you have the option to statically configure the
    management IP. I try to statically set the management IP addresses instead of
    having them dynamically assigned by the software. This allows for more deterministic
    accessibility:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在节点配置下，您可以选择静态配置管理IP的选项。我尝试静态设置管理IP地址，而不是让软件动态分配它们。这可以更确定地访问： '
- en: '![](assets/ef2611d4-2e65-4fde-93d2-89b164515c8c.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ef2611d4-2e65-4fde-93d2-89b164515c8c.png)'
- en: Cisco DevNet and dCloud
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思科DevNet和dCloud
- en: Cisco provides two other excellent, and, at the time of writing, free, methods
    for practicing network automation with various Cisco gears. Both of the tools
    require a **Cisco Connection Online (CCO)** login. They are both really good,
    especially for the price point (they are free!). It is hard for me to imagine
    that these online tools will remain free for long; it is my belief that, at some
    point, these tools will need to charge money for their usage or be rolled into
    a bigger initiative that requires a fee. However, we can take advantage of them
    while they are available at no charge.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 思科提供了另外两种非常好的、并且在撰写本文时是免费的方法，用于使用各种思科设备进行网络自动化实践。这两种工具都需要**思科连接在线（CCO）**登录。它们都非常好，尤其是价格方面（它们是免费的！）。我很难想象这些在线工具会长时间保持免费；我相信，这些工具在某个时候将需要收费或者被纳入需要收费的更大计划中。然而，在它们免费提供的时候我们可以利用它们。
- en: 'The first tool is the Cisco DevNet ([https://developer.cisco.com/](https://developer.cisco.com/))
    sandbox, which includes guided learning tracks, complete documentation, and sandbox
    remote labs, among other benefits. Some of the labs are always on, while others
    you need to reserve. The lab availability will depend on usage. It is a great
    alternative if you do not already have a lab at your own disposal. In my experience
    with DevNet, some of the documentation and links were outdated, but they can be
    easily retrieved for the most updated version. In a rapidly changing field such
    as software development, this is somewhat expected. DevNet is certainly a tool
    that you should take full advantage of, regardless of whether you have a locally
    run VIRL host or not:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个工具是思科DevNet ([https://developer.cisco.com/](https://developer.cisco.com/))
    实验室，其中包括引导式学习轨迹、完整文档和远程实验室等多种好处。一些实验室是一直开放的，而另一些需要预订。实验室的可用性将取决于使用情况。如果你没有自己的实验室，这是一个很好的选择。在我使用DevNet的经验中，一些文档和链接已经过时，但可以很容易地获取到最新版本。在软件开发这样一个快速变化的领域，这是可以预料的。无论你是否有一个本地运行的VIRL主机，DevNet都是一个你应该充分利用的工具：
- en: '![](assets/687289f1-0881-4d40-a9f9-b46cb69a31bb.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/687289f1-0881-4d40-a9f9-b46cb69a31bb.png)'
- en: 'Another online lab option for Cisco is [https://dcloud.cisco.com/](https://dcloud.cisco.com/).
    You can think of dCloud as running VIRL on other people''s servers without having
    to manage or pay for those resources. It seems that Cisco is treating dCloud as
    both a standalone product as well as an extension to VIRL. For example, in the
    use case of when you are unable to run more than a few IOX-XR or NX-OS instances
    locally, you can use dCloud to extend your local lab. It is a relatively new tool,
    but it is definitely worth a look:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 思科的另一个在线实验室选择是[https://dcloud.cisco.com/](https://dcloud.cisco.com/)。你可以把dCloud看作是在其他人的服务器上运行VIRL，而不必管理或支付这些资源。看起来思科把dCloud既当作一个独立的产品，又当作VIRL的扩展。例如，在你无法在本地运行超过几个IOX-XR或NX-OS实例的情况下，你可以使用dCloud来扩展你的本地实验室。这是一个相对较新的工具，但绝对值得一试：
- en: '![](assets/9013d0ba-57bd-48e0-8d65-8278953469b5.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9013d0ba-57bd-48e0-8d65-8278953469b5.png)'
- en: GNS3
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GNS3
- en: 'There are a few other virtual labs that I use for this book and other purposes.
    The [GNS3](https://gns3.com/) tool is one of them:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书和其他用途我使用了一些其他虚拟实验室。其中一个是[GNS3](https://gns3.com/)工具：
- en: '![](assets/90c418fe-1abc-4b39-9bc3-38e5104ea653.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/90c418fe-1abc-4b39-9bc3-38e5104ea653.png)'
- en: As mentioned previously in this chapter, GNS3 is what a lot of us used to study
    for certification tests and to practice for labs. The tool has really grown up
    from the early days of the simple frontend for Dynamips into a viable commercial
    product. Cisco-made tools, such as VIRL, DevNet, and dCloud, only contain Cisco
    technologies. Even though they provide ways for virtual lab devices to communicate
    with the outside world, they are not as easy as just having multi-vendor virtualized
    appliances living directly in the simulation environment. GNS3 is vendor-neutral
    and can include a multi-vendor virtualized platform directly in the lab. This
    is typically done either by making a clone of the image (such as Arista vEOS) or
    by directly launching the network device image via other hypervisors (such as
    Juniper Olive emulation). Some might argue that GNS3 does not have the breadth
    and depth of the Cisco VIRL project, but since they can run different variation
    Cisco technologies, I often use it when I need to incorporate other vendor technologies
    into the lab.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面提到的，GNS3是我们很多人用来准备认证考试和实验练习的工具。这个工具从最初的Dynamips的简单前端发展成了一个可行的商业产品。思科制造的工具，比如VIRL、DevNet和dCloud，只包含思科技术。尽管它们提供了虚拟实验室设备与外部世界通信的方式，但并不像直接在模拟环境中拥有多供应商虚拟化设备那样简单。GNS3是供应商中立的，可以在实验室中直接包含多供应商虚拟化平台。这通常是通过克隆镜像（比如Arista
    vEOS）或者通过其他虚拟化程序直接启动网络设备镜像（比如Juniper Olive仿真）来实现的。有人可能会认为GNS3没有思科VIRL项目那样的广度和深度，但由于它可以运行不同版本的思科技术，所以在需要将其他供应商技术纳入实验室时，我经常使用它。
- en: Another multi-vendor network emulation environment that has gotten a lot of
    great reviews is the **Emulated Virtual Environment Next Generation (EVE-NG)**,
    [http://www.eve-ng.net/](http://www.eve-ng.net/). I personally do not have much
    experience with the tool, but many of my colleagues and friends in the industry
    use it for their network labs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个得到很多好评的多供应商网络仿真环境是**Emulated Virtual Environment Next Generation (EVE-NG)**，[http://www.eve-ng.net/](http://www.eve-ng.net/)。我个人对这个工具没有太多经验，但我在这个行业的许多同事和朋友都在他们的网络实验室中使用它。
- en: There are also other virtualized platforms, such as Arista vEOS ([https://eos.arista.com/tag/veos/](https://eos.arista.com/tag/veos/)),
    Juniper vMX ([http://www.juniper.net/us/en/products-services/routing/mx-series/vmx/](http://www.juniper.net/us/en/products-services/routing/mx-series/vmx/)),
    and vSRX ([http://www.juniper.net/us/en/products-services/security/srx-series/vsrx/](http://www.juniper.net/us/en/products-services/security/srx-series/vsrx/)),
    which you can use as a standalone virtual appliance during testing. They are great
    complementary tools for testing platform-specific features, such as the differences
    between the API versions on the platform. Many of them are offered as paid products
    on public cloud provider marketplaces for easier access. They are often offered
    the identical feature as their physical counterpart.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他虚拟化平台，比如Arista vEOS ([https://eos.arista.com/tag/veos/](https://eos.arista.com/tag/veos/))、Juniper
    vMX ([http://www.juniper.net/us/en/products-services/routing/mx-series/vmx/](http://www.juniper.net/us/en/products-services/routing/mx-series/vmx/))和vSRX
    ([http://www.juniper.net/us/en/products-services/security/srx-series/vsrx/](http://www.juniper.net/us/en/products-services/security/srx-series/vsrx/))，你可以在测试中作为独立的虚拟设备使用。它们是测试特定平台功能的绝佳补充工具，比如平台上API版本的差异。它们通常作为付费产品在公共云提供商市场上提供，以便更容易地访问。它们通常提供与它们的物理对应产品相同的功能。
- en: Python Pexpect library
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python Pexpect库
- en: Pexpect is a pure Python module for spawning child applications, controlling
    them, and responding to expected patterns in their output. Pexpect works like
    Don Libes' Expect. Pexpct allows your script to spawn a child application and
    control it as if a human were typing commands. Pexpect, Read the Docs: [https://pexpect.readthedocs.io/en/stable/index.html](https://pexpect.readthedocs.io/en/stable/index.html)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 'Pexpect是一个纯Python模块，用于生成子应用程序、控制它们并响应其输出中的预期模式。Pexpect的工作原理类似于Don Libes的Expect。Pexpect允许您的脚本生成一个子应用程序并控制它，就像一个人在键入命令一样。Pexpect，Read
    the Docs: [https://pexpect.readthedocs.io/en/stable/index.html](https://pexpect.readthedocs.io/en/stable/index.html)'
- en: Let's take a look at the Python Pexpect library. Similar to the original Tcl
    Expect module by Don Libe, Pexpect launches or spawns another process and watches
    over it in order to control the interaction. The Expect tool was originally developed
    to automate interactive processes such as FTP, Telnet, and rlogin, and was later
    expanded to include network automation. Unlike the original Expect, Pexpect is
    entirely written in Python, which does not require TCL or C extensions to be compiled.
    This allows us to use the familiar Python syntax and its rich standard library
    in our code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Python Pexpect库。与Don Libe的原始Tcl Expect模块类似，Pexpect启动或生成另一个进程并监视它以控制交互。Expect工具最初是为了自动化诸如FTP、Telnet和rlogin之类的交互式进程而开发的，后来扩展到包括网络自动化。与原始Expect不同，Pexpect完全由Python编写，不需要编译TCL或C扩展。这使我们能够在我们的代码中使用熟悉的Python语法和其丰富的标准库。
- en: Pexpect installation
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pexpect安装
- en: 'Since this is the first package we will install, we will install both the `pip`
    tool with the `pexpect` package. The process is pretty straightforward:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们要安装的第一个软件包，我们将同时安装`pip`工具和`pexpect`软件包。该过程非常简单：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I am using `pip3` to install Python 3 packages, while using `pip` to install
    packages in the Python 2 environment.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用`pip3`来安装Python 3包，同时使用`pip`在Python 2环境中安装包。
- en: 'Do a quick to test to make sure the package is usable:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 快速测试一下确保软件包可用：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Pexpect overview
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pexpect概述
- en: 'For our first lab, we will construct a simple network with two IOSv devices
    connected back to back:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个实验，我们将构建一个简单的网络，其中有两个相连的IOSv设备：
- en: '![](assets/8ae3d89a-e435-42d3-bab2-6835055f9cae.png)Lab topology'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](assets/8ae3d89a-e435-42d3-bab2-6835055f9cae.png)实验拓扑
- en: 'The devices will each have a loopback address in the `192.16.0.x/24` range
    and the management IP will be in the `172.16.1.x/24` range. The VIRL topology
    file is included in the accommodated book downloadable files. You can import the
    topology to your own VIRL software. If you do not have VIRL, you can also view
    the necessary information by opening the topology file with a text editor. The
    file is simply an XML file with each node''s information under the `node` element:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备都将在`192.16.0.x/24`范围内拥有一个环回地址，管理IP将在`172.16.1.x/24`范围内。VIRL拓扑文件包含在适应书籍可下载文件中。您可以将拓扑导入到您自己的VIRL软件中。如果您没有VIRL，您也可以通过使用文本编辑器打开拓扑文件来查看必要的信息。该文件只是一个XML文件，每个节点的信息都在`node`元素下：
- en: '![](assets/15ca7c31-52f3-4c40-a953-ea2b7a79cb45.png)Lab node information'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](assets/15ca7c31-52f3-4c40-a953-ea2b7a79cb45.png)实验节点信息
- en: 'With the devices ready, let''s take a look at how you would interact with the
    router if you were to Telnet into the device:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 设备准备就绪后，让我们看看如果您要Telnet到设备中，您将如何与路由器进行交互：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'I used VIRL AutoNetkit to automatically generate the initial configuration
    of the routers, which generated the default username `cisco`, and the password
    `cisco`. Notice that the user is already in privileged mode because of the privilege
    assigned in the configuration:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用VIRL AutoNetkit自动生成路由器的初始配置，生成了默认用户名`cisco`和密码`cisco`。请注意，由于配置中分配的特权，用户已经处于特权模式下：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The auto-config also generated `vty` access for both Telnet and SSH:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 自动配置还为Telnet和SSH生成了`vty`访问：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s see a Pexpect example using the Python interactive shell:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用Python交互式shell的Pexpect示例：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Starting from Pexpect version 4.0, you can run Pexpect on a Windows platform.
    But, as noted in the Pexpect documentation, running Pexpect on Windows should
    be considered experimental for now.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从Pexpect版本4.0开始，您可以在Windows平台上运行Pexpect。但是，正如Pexpect文档中所指出的，目前应该将在Windows上运行Pexpect视为实验性的。
- en: In the previous interactive example, Pexpect spawns off a child process and
    watches over it in an interactive fashion. There are two important methods shown
    in the example, `expect()` and `sendline()`. The `expect()` line indicates that
    the string the Pexpect process looks for as an indicator for when the returned
    string is considered done. This is the expected pattern. In our example, we knew
    the router had sent us all the information when the hostname prompt (`iosv-1#`) was
    returned. The `sendline()` method indicates which words should be sent to the
    remote device as the command. There is also a method called `send()` but `sendline()`
    includes a linefeed, which is similar to pressing the *Enter* key at the end of
    the words you sent in your previous telnet session. From the router's perspective,
    it is just as if someone typed in the text from a Terminal. In other words, we
    are tricking the routers into thinking they are interfacing with a human being
    when they are actually communicating with a computer.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个交互式示例中，Pexpect生成了一个子进程并以交互方式监视它。示例中显示了两个重要的方法，`expect()`和`sendline()`。`expect()`行指示Pexpect进程寻找的字符串，作为返回的字符串被视为完成的指示器。这是预期的模式。在我们的示例中，当返回主机名提示（`iosv-1#`）时，我们知道路由器已经向我们发送了所有信息。`sendline()`方法指示应将哪些单词作为命令发送到远程设备。还有一个名为`send()`的方法，但`sendline()`包括一个换行符，类似于在上一个telnet会话中按下*Enter*键。从路由器的角度来看，这就像有人从终端键入文本一样。换句话说，我们正在欺骗路由器，让它们认为它们正在与人类进行交互，而实际上它们正在与计算机进行通信。
- en: 'The `before` and `after` properties will be set to the text printed by the
    child application. The `before` properties will be set to the text printed by
    the child application up to the expected pattern. The `after` string will contain
    the text that was matched by the expected pattern. In our case, the `before` text
    will be set to the output between the two expected matches (`iosv-1#`), including
    the `show version` command. The `after` text is the router hostname prompt:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`before`和`after`属性将设置为子应用程序打印的文本。`before`属性将设置为子应用程序打印的文本，直到预期的模式。`after`字符串将包含由预期模式匹配的文本。在我们的情况下，`before`文本将设置为两个预期匹配（`iosv-1#`）之间的输出，包括`show
    version`命令。`after`文本是路由器主机名提示符：'
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What would happen if you expected the wrong term? For example, if you typed
    in `username` instead of `Username` after spawning the child application, then
    the Pexpect process would look for a string of `username` from the child process.
    In that case, the Pexpect process would just hang because the word `username`
    would never be returned by the router. The session would eventually timeout, or
    you could manually exit out via *Ctrl* + *C*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您期望错误的术语会发生什么？例如，如果在生成子应用程序后输入`username`而不是`Username`，那么Pexpect进程将从子进程中寻找一个`username`字符串。在这种情况下，Pexpect进程将会挂起，因为路由器永远不会返回`username`这个词。会话最终会超时，或者您可以通过*Ctrl*
    + *C*手动退出。
- en: 'The `expect()` method waits for the child application to return a given string,
    so in the previous example, if you wanted to accommodate both lowercase and uppercase
    `u`, you could use the following term:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect()`方法等待子应用程序返回给定的字符串，因此在前面的示例中，如果您想要适应小写和大写的`u`，您可以使用以下术语：'
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The square bracket serves as an `or` operation that tells the child application
    to expect a lowercase or uppercase `u` followed by `sername` as the string. What
    we are telling the process is that we will accept either `Username` or `username` as
    the expected string.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号作为`or`操作，告诉子应用程序期望小写或大写的`u`后跟字符串`sername`。我们告诉进程的是我们将接受`Username`或`username`作为预期字符串。
- en: For more information on Python regular expressions, go to [https://docs.python.org/3.5/library/re.html](https://docs.python.org/3.5/library/re.html).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Python正则表达式的更多信息，请访问[https://docs.python.org/3.5/library/re.html](https://docs.python.org/3.5/library/re.html)。
- en: 'The `expect()` method can also contain a list of options instead of just a
    single string; these options can also be regular expression themselves. Going
    back to the previous example, you can use the following list of options to accommodate
    the two different possible strings:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect()`方法也可以包含一个选项列表，而不仅仅是一个单独的字符串；这些选项本身也可以是正则表达式。回到前面的示例，您可以使用以下选项列表来适应两种不同的可能字符串：'
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Generally speaking, use the regular expression for a single `expect` string
    when you can fit the different hostname in a regular expression, whereas use the
    possible options if you need to catch completely different responses from the
    router, such as a password rejection. For example, if you use several different
    passwords for your login, you want to catch `% Login invalid` as well as the device
    prompt.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当您可以在正则表达式中适应不同的主机名时，使用单个`expect`字符串的正则表达式，而如果您需要捕获路由器完全不同的响应，例如密码拒绝，那么使用可能的选项。例如，如果您对登录使用了几个不同的密码，您希望捕获`％Login
    invalid`以及设备提示。
- en: One important difference between Pexpect regular expressions and Python regular
    expressions is that the Pexpect matching is non-greedy, which means they will
    match as little as possible when using special characters. Because Pexpect performs
    regular expression on a stream, you cannot look ahead, as the child process generating
    the stream may not be finished. This means the special dollar sign character `$` typically
    matching the end of the line is useless because `.+` will always return no characters,
    and the `.*` pattern will match as little as possible. In general, just keep this
    in mind and be as specific as you can be on the `expect` match strings.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Pexpect正则表达式和Python正则表达式之间的一个重要区别是，Pexpect匹配是非贪婪的，这意味着在使用特殊字符时，它们将尽可能少地匹配。因为Pexpect在流上执行正则表达式，所以您不能向前查看，因为生成流的子进程可能尚未完成。这意味着特殊的美元符号字符`$`通常匹配行尾是无用的，因为`.+`总是不会返回任何字符，而`.*`模式将尽可能少地匹配。一般来说，记住这一点，并尽可能具体地匹配`expect`字符串。
- en: 'Let''s consider the following scenario:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下情景：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Hmm... Something is not quite right here. Compare it to the Terminal output
    before; the output you expect would be `hostname iosv-1`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯...这里有点不对劲。与之前的终端输出进行比较；您期望的输出应该是`hostname iosv-1`：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Taking a closer look at the expected string will reveal the mistake. In this
    case, we were missing the hash (`#`) sign behind the `iosv-1` hostname. Therefore,
    the child application treated the second part of the return string as the expected
    string:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看预期的字符串将会揭示错误。在这种情况下，我们忘记了在`iosv-1`主机名后面加上`#`号。因此，子应用程序将返回字符串的第二部分视为预期字符串：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can see a pattern emerging from the usage of Pexpect after a few examples.
    The user maps out the sequence of interactions between the Pexpect process and
    the child application. With some Python variables and loops, we can start to construct
    a useful program that will help us gather information and make changes to network
    devices.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过几个示例后，您可以看到Pexpect的使用模式。用户可以规划Pexpect进程和子应用程序之间的交互序列。通过一些Python变量和循环，我们可以开始构建一个有用的程序，帮助我们收集信息并对网络设备进行更改。
- en: Our first Pexpect program
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个Pexpect程序
- en: 'Our first program, `chapter2_1.py`, extends what we did in the last section
    with some additional code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个程序`chapter2_1.py`扩展了上一节的内容，并添加了一些额外的代码：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We use a nested dictionary in line 5:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第5行使用了嵌套字典：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The nested dictionary allows us to refer to the same device (such as `iosv-1`)
    with the appropriate IP address and prompt symbol. We can then use those values
    for the `expect()` method later on in the loop.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套字典允许我们使用适当的IP地址和提示符号引用相同的设备（例如`iosv-1`）。然后我们可以在循环后面使用这些值进行`expect()`方法。
- en: 'The output prints out the `show version | i V` output on the screen for each
    of the devices:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 输出在屏幕上打印出每个设备的`show version | i V`输出：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: More Pexpect features
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多Pexpect功能
- en: In this section, we will look at more Pexpect features that might come in handy
    when certain situations arise.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看更多Pexpect功能，这些功能在某些情况下可能会派上用场。
- en: 'If you have a slow or fast link to your remote device, the default `expect()`
    method timeout is 30 seconds, which can be increased or decreased via the `timeout`
    argument:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的远程设备链接速度慢或快，默认的`expect()`方法超时时间为30秒，可以通过`timeout`参数增加或减少：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can choose to pass the command back to the user using the `interact()`
    method. This is useful when you just want to automate certain parts of the initial
    task:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择使用`interact()`方法将命令传递回用户。当您只想自动化初始任务的某些部分时，这是很有用的：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can get a lot of information about the `child.spawn` object by printing
    it out in string format:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以字符串格式打印`child.spawn`对象，您可以获得有关该对象的大量信息：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The most useful debug tool for Pexpect is to log the output in a file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Pexpect最有用的调试工具是将输出记录在文件中：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Use `child.logfile = open('debug', 'w')` for Python 2\. Python 3 uses byte strings
    by default. For more information on Pexpect features, check out [https://pexpect.readthedocs.io/en/stable/api/index.html](https://pexpect.readthedocs.io/en/stable/api/index.html).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`child.logfile = open('debug', 'w')`来代替Python 2。Python 3默认使用字节字符串。有关Pexpect功能的更多信息，请查看[https://pexpect.readthedocs.io/en/stable/api/index.html](https://pexpect.readthedocs.io/en/stable/api/index.html)。
- en: Pexpect and SSH
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pexpect和SSH
- en: 'If you try to use the previous Telnet example and plug it into an SSH session
    instead, you might find yourself pretty frustrated with the experience. You always
    have to include the username in the session, answering the `ssh` new key question,
    and much more mundane tasks. There are many ways to make SSH sessions work, but
    luckily, Pexpect has a subclass called `pxssh`, which specializes in setting up
    SSH connections. The class adds methods for login, log out, and various tricky
    things to handle the different situations in the `ssh` login process. The procedures
    are mostly the same, with the exception of `login()` and `logout()`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试使用先前的Telnet示例并将其插入SSH会话，您可能会对体验感到非常沮丧。您始终必须在会话中包含用户名，回答`ssh`新密钥问题，以及更多琐碎的任务。有许多方法可以使SSH会话工作，但幸运的是，Pexpect有一个名为`pxssh`的子类，专门用于建立SSH连接。该类添加了登录、注销和处理`ssh`登录过程中不同情况的各种棘手事务的方法。这些过程大多数情况下是相同的，除了`login()`和`logout()`：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice the `auto_prompt_reset=False` argument in the `login()` method. By default,
    `pxssh` uses the Shell prompt to synchronize the output. But since it uses the
    PS1 option for most of bash or CSH, they will error out on Cisco or other network
    devices.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`login()`方法中的`auto_prompt_reset=False`参数。默认情况下，`pxssh`使用Shell提示来同步输出。但由于它在大多数bash或CSH中使用PS1选项，它们将在Cisco或其他网络设备上出错。
- en: Putting things together for Pexpect
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Pexpect整合各种功能
- en: As the final step, let's put everything you have learned so far about Pexpect
    into a script. Putting code into a script makes it easier to use in a production
    environment, as well as easier to share with your colleagues. We will write our
    second script, `chapter2_2.py`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，让我们将到目前为止学到的关于Pexpect的一切放入脚本中。将代码放入脚本中可以更容易地在生产环境中使用，并且更容易与同事共享。我们将编写第二个脚本`chapter2_2.py`。
- en: 'You can download the script from the book GitHub repository, [https://github.com/PacktPublishing/Mastering-Python-Networking-second-edition](https://github.com/PacktPublishing/Mastering-Python-Networking-second-edition),
    as well as looking at the output generated from the script as a result of the
    commands.Refer to the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从书的GitHub存储库[https://github.com/PacktPublishing/Mastering-Python-Networking-second-edition](https://github.com/PacktPublishing/Mastering-Python-Networking-second-edition)下载脚本，以及查看由脚本生成的输出作为命令的结果。参考以下代码：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The script further expands from our first Pexpect program with the following
    additional features:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本从我们的第一个Pexpect程序进一步扩展，具有以下附加功能：
- en: It uses SSH instead of Telnet
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用SSH而不是Telnet
- en: It supports multiple commands instead of just one by making the commands into
    a list (line 8) and loops through the commands (starting at line 20)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将命令转换为列表（第8行）并循环执行命令（从第20行开始），它支持多个命令而不仅仅是一个命令
- en: It prompts the user for their username and password instead of hardcoding them
    in the script
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提示用户输入用户名和密码，而不是在脚本中硬编码它们
- en: It writes the output in two files, `iosv-1_output.txt`, and `ios-2_output.txt`,
    to be further analyzed
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将输出写入两个文件，`iosv-1_output.txt`和`ios-2_output.txt`，以便进一步分析
- en: For Python 2, use `raw_input()` instead of `input()` for the username prompt.
    Also, use `w` for the file mode instead of `wb`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python 2，使用`raw_input()`而不是`input()`来进行用户名提示。此外，使用`w`而不是`wb`作为文件模式。
- en: The Python Paramiko library
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python Paramiko库
- en: Paramiko is a Python implementation of the SSHv2 protocol. Just like the `pxssh`
    subclass of Pexpect, Paramiko simplifies the SSHv2 interaction between the host
    and the remote device. Unlike `pxssh`, Paramiko focuses only on SSHv2 with no
    Telnet support. It also provides both client and server operations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Paramiko是SSHv2协议的Python实现。就像Pexpect的`pxssh`子类一样，Paramiko简化了主机和远程设备之间的SSHv2交互。与`pxssh`不同，Paramiko仅专注于SSHv2，不支持Telnet。它还提供客户端和服务器操作。
- en: Paramiko is the low-level SSH client behind the high-level automation framework
    Ansible for its network modules. We will cover Ansible in later chapters. Let's
    take a look at the Paramiko library.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Paramiko是高级自动化框架Ansible用于其网络模块的低级SSH客户端。我们将在后面的章节中介绍Ansible。让我们来看看Paramiko库。
- en: Installation of Paramiko
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Paramiko的安装
- en: Installing Paramiko is pretty straightforward with Python `pip`. However, there
    is a hard dependency on the cryptography library. The library provides low-level,
    C-based encryption algorithms for the SSH protocol.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python `pip`安装Paramiko非常简单。但是，它对cryptography库有严格的依赖。该库为SSH协议提供了基于C的低级加密算法。
- en: The installation instruction for Windows, Mac, and other flavors of Linux can
    be found at [https://cryptography.io/en/latest/installation/](https://cryptography.io/en/latest/installation/).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Windows、Mac和其他Linux版本的安装说明可以在[https://cryptography.io/en/latest/installation/](https://cryptography.io/en/latest/installation/)找到。
- en: We will show the Paramiko installation of our Ubuntu 16.04 virtual machine in
    the following output. The following output shows the installation steps, as well
    as Paramiko successfully imported into the Python interactive prompt.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的输出中展示Ubuntu 16.04虚拟机上Paramiko的安装。以下输出显示了安装步骤，以及Paramiko成功导入Python交互提示符。
- en: 'If you are using Python 2, please follow the steps below. We will try to import
    the library in the interactive prompt to make sure the library can be used:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Python 2，请按照以下步骤。我们将尝试在交互提示符中导入库，以确保库可以使用：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you are using Python 3,please refer the following command-lines for installing
    the dependencies. After installation, we will import the library to make sure
    it is correctly installed:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Python 3，请参考以下命令行安装依赖项。安装后，我们将导入库以确保它已正确安装：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Paramiko overview
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Paramiko概述
- en: 'Let''s look at a quick Paramiko example using the Python 3 interactive shell:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个使用Python 3交互式shell的快速Paramiko示例：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `time.sleep()` function inserts a time delay to ensure that all the outputs
    were captured. This is particularly useful on a slower network connection or a
    busy device. This command is not required but is recommended depending on your
    situation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.sleep()`函数插入时间延迟，以确保所有输出都被捕获。这在网络连接较慢或设备繁忙时特别有用。这个命令不是必需的，但根据您的情况，建议使用。'
- en: 'Even if you are seeing the Paramiko operation for the first time, the beauty
    of Python and its clear syntax means that you can make a pretty good educated
    guess at what the program is trying to do:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您是第一次看到Paramiko操作，Python及其清晰的语法意味着您可以对程序尝试做什么有一个相当好的猜测：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first four lines create an instance of the `SSHClient` class from Paramiko.
    The next line sets the policy that the client should use when the SSH server''s
    hostname; in this case, `iosv-1`, is not present in either the system host keys
    or the application''s keys. In our scenario, we will automatically add the key
    to the application''s `HostKeys` object. At this point, if you log on to the router,
    you will see the additional login session from Paramiko:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前四行创建了Paramiko的`SSHClient`类的实例。下一行设置了客户端在SSH服务器的主机名（在本例中为`iosv-1`）不在系统主机密钥或应用程序密钥中时应使用的策略。在我们的情况下，我们将自动将密钥添加到应用程序的`HostKeys`对象中。此时，如果您登录路由器，您将看到Paramiko的额外登录会话：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The next few lines invoke a new interactive shell from the connection and a
    repeatable pattern of sending a command and retrieving the output. Finally, we
    close the connection.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行调用连接的新交互式shell，并重复发送命令和检索输出的模式。最后，我们关闭连接。
- en: 'Some readers who have used Paramiko before might be familiar with the `exec_command()` method
    instead of invoking a shell. Why do we need to invoke an interactive shell instead
    of using `exec_command()` directly? Unfortunately, `exec_command()` on Cisco IOS
    only allows a single command. Consider the following example with `exec_command()`
    for the connection:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一些之前使用过Paramiko的读者可能对`exec_command()`方法比调用shell更熟悉。为什么我们需要调用交互式shell而不是直接使用`exec_command()`呢？不幸的是，在Cisco
    IOS上，`exec_command()`只允许一个命令。考虑以下使用`exec_command()`进行连接的示例：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Everything works great; however, if you look at the number of sessions on the
    Cisco device, you will notice that the connection is dropped by the Cisco device
    without you closing the connection:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都很顺利；但是，如果您查看Cisco设备上的会话数量，您会注意到连接被Cisco设备中断，而您并没有关闭连接：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Because the SSH session is no longer active, `exec_command()` will return an
    error if you want to send more commands to the remote device:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因为SSH会话不再活动，如果您想向远程设备发送更多命令，`exec_command()`将返回错误：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The Netmiko library by Kirk Byers is an open source Python library that simplifies
    SSH management to network devices. To read about it, check out this article, [https://pynet.twb-tech.com/blog/automation/netmiko.html,](https://pynet.twb-tech.com/blog/automation/netmiko.html) and
    the source code, [https://github.com/ktbyers/netmiko](https://github.com/ktbyers/netmiko).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Kirk Byers的Netmiko库是一个开源的Python库，简化了对网络设备的SSH管理。要了解更多信息，请查看这篇文章[https://pynet.twb-tech.com/blog/automation/netmiko.html](https://pynet.twb-tech.com/blog/automation/netmiko.html)，以及源代码[https://github.com/ktbyers/netmiko](https://github.com/ktbyers/netmiko)。
- en: 'What would happen if you did not clear out the received buffer? The output
    would just keep on filling up the buffer and would overwrite it:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不清除接收到的缓冲区，会发生什么？输出将继续填充缓冲区并覆盖它：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: For consistency of the deterministic output, we will retrieve the output from
    the buffer each time we execute a command.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持确定性输出的一致性，我们将在每次执行命令时从缓冲区中检索输出。
- en: Our first Paramiko program
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个Paramiko程序
- en: Our first program will use the same general structure as the Pexpect program
    we have put together. We will loop over a list of devices and commands while using
    Paramiko instead of Pexpect. This will give us a good compare and contrast of
    the differences between Paramiko and Pexpect.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个程序将使用与我们组合的Pexpect程序相同的一般结构。我们将循环遍历设备和命令列表，同时使用Paramiko而不是Pexpect。这将使我们很好地比较Paramiko和Pexpect之间的差异。
- en: 'If you have not done so already, you can download the code, `chapter2_3.py`,
    from the book''s GitHub repository, [https://github.com/PacktPublishing/Mastering-Python-Networking-second-edition](https://github.com/PacktPublishing/Mastering-Python-Networking).
    I will list the notable differences here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，您可以从书的GitHub存储库[https://github.com/PacktPublishing/Mastering-Python-Networking-second-edition](https://github.com/PacktPublishing/Mastering-Python-Networking)下载代码`chapter2_3.py`。我将在这里列出显著的区别：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We no longer need to match the device prompt using Paramiko; therefore, the
    device dictionary can be simplified:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要使用Paramiko来匹配设备提示；因此，设备字典可以简化：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There is no sendline equivalent in Paramiko; instead, we manually include the
    newline break in each of the commands:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Paramiko中没有sendline的等价物；相反，我们需要在每个命令中手动包含换行符：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We include a new method to clear the buffer for sending commands, such as `terminal
    length 0` or `enable`, because we do not need the output for those commands. We
    simply want to clear the buffer and get to the execution prompt. This function
    will later be used in the loop, such as in line 25 of the script:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含了一个新的方法来清除发送命令的缓冲区，比如`terminal length 0`或`enable`，因为我们不需要这些命令的输出。我们只是想清除缓冲区并进入执行提示符。这个函数稍后将在循环中使用，比如脚本的第25行：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The rest of the program should be pretty self-explanatory, similar to what
    we have seen in this chapter. The last thing I would like to point out is that
    since this is an interactive program, we place some buffer and wait for the command
    to be finished on the remote device before retrieving the output:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的其余部分应该是相当容易理解的，类似于我们在本章中看到的内容。我想指出的最后一件事是，由于这是一个交互式程序，我们在远程设备上放置了一些缓冲区，并等待命令在远程设备上完成后再检索输出。
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After we clear the buffer, during the time between the execution of commands,
    we will wait two seconds. This will give the device adequate time to respond if
    it is busy.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在清除缓冲区之后，在执行命令之间，我们将等待两秒。这将给设备足够的时间来响应，如果它很忙的话。
- en: More Paramiko features
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多Paramiko功能
- en: We will look at Paramiko a bit later in the book, when we discuss Ansible, as
    Paramiko is the underlying transport for many of the network modules. In this
    section, we will take a look at some of the other features of Paramiko.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面部分再次看到Paramiko，当我们讨论Ansible时，Paramiko是许多网络模块的基础传输。在本节中，我们将看一下Paramiko的一些其他功能。
- en: Paramiko for servers
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Paramiko用于服务器
- en: Paramiko can be used to manage servers through SSHv2 as well. Let's look at
    an example of how we can use Paramiko to manage servers. We will use key-based
    authentication for the SSHv2 session.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Paramiko也可以用于通过SSHv2管理服务器。让我们看一个使用Paramiko管理服务器的例子。我们将使用基于密钥的身份验证进行SSHv2会话。
- en: In this example, I used another Ubuntu virtual machine on the same hypervisor
    as the destination server. You can also use a server on the VIRL simulator or
    an instance in one of the public cloud providers, such as Amazon AWS EC2.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我使用了与目标服务器相同的虚拟机上的另一个Ubuntu虚拟机。您也可以使用VIRL模拟器上的服务器或者公共云提供商之一的实例，比如亚马逊AWS
    EC2。
- en: 'We will generate a public-private key pair for our Paramiko host:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为Paramiko主机生成一个公私钥对：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This command, by default, will generate a public key named `id_rsa.pub`, as
    the public key under the user home directory `~/.ssh` along with a private key
    named `id_rsa`. Treat the private key with the same attention as you would private
    passwords that you do not want to share with anybody else. You can think of the
    public key as a business card that identifies who you are. Using the private and
    public keys, the message will be encrypted by your private key locally and decrypted
    by the remote host using the public key. We should copy the public key to the
    remote host. In production, we can do this via out-of-band using a USB drive;
    in our lab, we can simply copy the public key to the remote host's `~/.ssh/authorized_keys`
    file. Open up a Terminal window for the remote server, so you can paste in the
    public key.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令默认会生成一个名为`id_rsa.pub`的公钥，作为用户主目录`~/.ssh`下的公钥，以及一个名为`id_rsa`的私钥。对待私钥的注意力应与您不想与任何其他人分享的私人密码一样。您可以将公钥视为标识您身份的名片。使用私钥和公钥，消息将在本地由您的私钥加密，然后由远程主机使用公钥解密。我们应该将公钥复制到远程主机。在生产环境中，我们可以通过使用USB驱动器进行离线复制；在我们的实验室中，我们可以简单地将公钥复制到远程主机的`~/.ssh/authorized_keys`文件中。打开远程服务器的终端窗口，这样您就可以粘贴公钥。
- en: 'Copy the content of `~/.ssh/id_rsa` on your management host with Paramiko:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Paramiko将`~/.ssh/id_rsa`的内容复制到您的管理主机上：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, paste it to the remote host under the `user` directory; in this case,
    I am using `echou` for both sides:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其粘贴到远程主机的`user`目录下；在这种情况下，我在双方都使用`echou`：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You are now ready to use Paramiko to manage the remote host. Notice in this
    example that we will use the private key for authentication as well as the `exec_command()`
    method for sending commands:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用Paramiko来管理远程主机。请注意，在这个例子中，我们将使用私钥进行身份验证，以及`exec_command()`方法来发送命令：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice that in the server example, we do not need to create an interactive session
    to execute multiple commands. You can now turn off password-based authentication
    in your remote host's SSHv2 configuration for more secure key-based authentication
    with automation enabled. Some network devices, such as Cumulus and Vyatta switches,
    also support key-based authentication.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在服务器示例中，我们不需要创建交互式会话来执行多个命令。您现在可以关闭远程主机的SSHv2配置中基于密码的身份验证，以实现更安全的基于密钥的身份验证，并启用自动化。一些网络设备，如Cumulus和Vyatta交换机，也支持基于密钥的身份验证。
- en: Putting things together for Paramiko
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Paramiko整合各种功能
- en: 'We are almost at the end of the chapter. In this last section, let''s make
    the Paramiko program more reusable. There is one downside of our existing script:
    we need to open up the script every time we want to add or delete a host, or whenever
    we need to change the commands we want to execute on the remote host. This is
    due to the fact that both the host and command information are statically entered
    inside of the script. Hardcoding the host and command has a higher chance of making
    mistakes. Besides, if you were to pass on the script to colleagues, they might
    not feel comfortable working in Python, Paramiko, or Linux.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎已经到了本章的结尾。在这最后一节中，让我们使Paramiko程序更具重用性。我们现有脚本的一个缺点是：每次我们想要添加或删除主机，或者每当我们需要更改要在远程主机上执行的命令时，我们都需要打开脚本。这是因为主机和命令信息都是静态输入到脚本中的。硬编码主机和命令更容易出错。此外，如果你要把脚本传给同事，他们可能不太愿意在Python、Paramiko或Linux中工作。
- en: By making both the host and command files be read in as parameters for the script,
    we can eliminate some of these concerns. Users (and a future you) can simply modify
    these text files when you need to make host or command changes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将主机和命令文件都作为脚本的参数读入，我们可以消除一些这些顾虑。用户（包括未来的你）可以在需要更改主机或命令时简单地修改这些文本文件。
- en: We have incorporated the change in the script named `chapter2_4.py`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在名为`chapter2_4.py`的脚本中引入了更改。
- en: 'Instead of hardcoding the commands, we broke the commands into a separate `commands.txt`
    file. Up to this point, we have been using show commands; in this example, we
    will make configuration changes. In particular, we will change the logging buffer
    size to `30000` bytes:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有将命令硬编码，而是将命令分成一个单独的`commands.txt`文件。到目前为止，我们一直在使用show命令；在这个例子中，我们将进行配置更改。特别是，我们将日志缓冲区大小更改为`30000`字节：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The device''s information is written into a `devices.json` file. We choose
    JSON format for the device''s information because JSON data types can be easily
    translated into Python dictionary data types:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 设备的信息被写入`devices.json`文件。我们选择JSON格式来存储设备信息，因为JSON数据类型可以很容易地转换为Python字典数据类型：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the script, we made the following changes:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，我们做出了以下更改：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here is an abbreviated output from the script execution:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是脚本执行的简化输出：
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Do a quick check to make sure the change has taken place in both `running-config`
    and `startup-config`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 快速检查确保更改已经在`running-config`和`startup-config`中生效：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Looking ahead
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展望未来
- en: We have taken a pretty huge leap forward in this chapter as far as automating
    our network using Python is concerned. However, the method we have used feels
    like somewhat of a workaround for automation. We attempted to trick the remote
    devices into thinking they were interacting with a human on the other end.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 就自动化网络使用Python而言，本章我们已经取得了相当大的进步。然而，我们使用的方法感觉有点像自动化的变通方法。我们试图欺骗远程设备，让它们认为它们在与另一端的人类进行交互。
- en: Downsides of Pexpect and Paramiko compared to other tools
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与其他工具相比，Pexpect和Paramiko的缺点
- en: The biggest downside of our method so far is that the remote devices do not
    return structured data. They return data that is ideal to be fitted on a terminal
    to be interpreted by a human, not by a computer program. The human eye can easily
    interpret a space, while a computer only sees a return character.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的方法最大的缺点是远程设备没有返回结构化数据。它们返回的数据适合在终端上显示并由人类解释，而不是由计算机程序。人眼可以轻松解释空格，而计算机只能看到回车符。
- en: We will take a look at a better way in the upcoming chapter. As a prelude to
    [Chapter 3](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml), *APIs and Intent-Driven
    Networking*, let's discuss the idea of idempotency.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中看到更好的方法。作为[第3章](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml) *API和意图驱动的网络*的序曲，让我们讨论幂等性的概念。
- en: Idempotent network device interaction
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络设备交互的幂等性
- en: The term **idempotency** has different meanings, depending on its context. But
    in this book's context, the term means that when a client makes the same call
    to a remote device, the result should always be the same. I believe we can all
    agree that this is necessary. Imagine a scenario where each time you execute the
    same script, you get a different result back. I find that scenario very scary.
    How can you trust your script if that is the case? It would render our automation
    effort useless because we need to be prepared to handle different returns.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**幂等性**一词在不同的语境中有不同的含义。但在本书的语境中，该术语意味着当客户端对远程设备进行相同的调用时，结果应始终相同。我相信我们都同意这一点。想象一种情况，每次执行相同的脚本时，你都会得到不同的结果。我觉得那种情况非常可怕。如果是这种情况，你怎么能相信你的脚本呢？这将使我们的自动化工作变得毫无意义，因为我们需要准备处理不同的返回结果。'
- en: Since Pexpect and Paramiko are blasting out a series of commands interactively,
    the chance of having a non-idempotent interaction is higher. Going back to the
    fact that the return results needed to be screen scraped for useful elements,
    the risk of difference is much higher. Something on the remote end might have
    changed between the time we wrote the script and the time when the script is executed
    for the 100th time. For example, if the vendor makes a screen output change between
    releases without us updating the script, the script might break.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Pexpect和Paramiko正在交互式地发送一系列命令，非幂等交互的机会更高。回到需要从返回结果中筛选有用元素的事实，差异的风险更高。在我们编写脚本和脚本执行100次之间，远程端的某些内容可能已经发生了变化。例如，如果供应商在发布之间更改了屏幕输出，而我们没有更新脚本，脚本可能会出错。
- en: If we need to rely on the script for production, we need the script to be idempotent
    as much as possible.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要依赖脚本进行生产，我们需要尽可能使脚本具有幂等性。
- en: Bad automation speeds bad things up
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 糟糕的自动化会加速糟糕的事情发生
- en: Bad automation allows you to poke yourself in the eye a lot faster, it is as
    simple as that. Computers are much faster at executing tasks than us human engineers.
    If we had the same set of operating procedures executed by a human versus a script,
    the script would finish faster than humans, sometimes without the benefit of having
    a solid feedback loop between procedures. The internet is full of horror stories
    of when someone pressed the *Enter* key and immediately regretted it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕的自动化会让你更快地刺瞎自己的眼睛，就是这么简单。计算机在执行任务时比我们人类工程师快得多。如果我们用相同的操作程序由人类和脚本执行，脚本会比人类更快地完成，有时甚至没有在程序之间建立良好的反馈循环的好处。互联网上充满了当有人按下*Enter*键后立即后悔的恐怖故事。
- en: We need to make sure the chances of bad automation scripts screwing things up
    are as small as possible. We all make mistakes; carefully test your script before
    any production work and small blast radius are two keys to making sure you can
    catch your mistake before it comes back and bites you.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保糟糕的自动化脚本搞砸事情的机会尽可能小。我们都会犯错；在进行任何生产工作之前仔细测试您的脚本和小的影响范围是确保您能在错误发生之前捕捉到它的关键。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered low-level ways to communicate directly with network
    devices. Without a way to programmatically communicate and make changes to network
    devices, there is no automation. We looked at two libraries in Python that allow
    us to manage devices that were meant to be managed by the CLI. Although useful,
    it is easy to see how the process can be somewhat fragile. This is mostly due
    to the fact that the network gears in question were meant to be managed by human
    beings and not computers.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了与网络设备直接通信的低级方式。如果没有一种以编程方式与网络设备通信并对其进行更改的方法，就不可能实现自动化。我们看了Python中的两个库，它们允许我们管理本来应该由CLI管理的设备。虽然有用，但很容易看出这个过程可能有些脆弱。这主要是因为所涉及的网络设备本来是为人类而不是计算机管理而设计的。
- en: In [Chapter 3](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml), *APIs and Intent-Driven
    Networking*, we will look at network devices supporting API and intent-driven
    networking.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml)中，*API和意图驱动的网络*，我们将看看支持API和意图驱动网络的网络设备。

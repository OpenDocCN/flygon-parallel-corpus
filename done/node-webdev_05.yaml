- en: HTTP Servers and Clients
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP服务器和客户端
- en: Now that you've learned about Node.js modules, it's time to put this knowledge
    to use by building a simple Node.js web application. The goal of this book is
    to learn about web application development with Node.js. The next step in that
    journey is getting a basic understanding of the `HTTPServer` and `HTTPClient`
    objects. To do that, we'll create a simple application that will enable us to
    explore a popular application framework for Node.js—Express. In later chapters,
    we'll do more complex work on the application, but before we can walk, we must
    learn to crawl.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了Node.js模块，是时候将这些知识应用到构建一个简单的Node.js web应用程序中了。本书的目标是学习使用Node.js进行web应用程序开发。在这个过程中的下一步是对`HTTPServer`和`HTTPClient`对象有一个基本的了解。为了做到这一点，我们将创建一个简单的应用程序，使我们能够探索Node.js中一个流行的应用程序框架——Express。在后面的章节中，我们将在应用程序上做更复杂的工作，但在我们能够行走之前，我们必须学会爬行。
- en: The goal of this chapter is to start to understand how to create applications
    on the Node.js platform. We'll create a handful of small applications, which means
    we'll be writing code and talking about what it does. Beyond learning about some
    specific technologies, we want to get comfortable with the process of initializing
    a work directory, creating the Node.js code for an application, installing dependencies
    required by the application, and running/testing the application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是开始了解如何在Node.js平台上创建应用程序。我们将创建一些小型的应用程序，这意味着我们将编写代码并讨论它的作用。除了学习一些具体的技术之外，我们还希望熟悉初始化工作目录、创建应用程序的Node.js代码、安装应用程序所需的依赖项以及运行/测试应用程序的过程。
- en: The Node.js runtime includes objects such as `EventEmitter`, `HTTPServer`, and
    `HTTPClient`, which provide a foundation on which we can build applications. Even
    if we rarely use these objects directly, it is useful to understand how they work,
    and in this chapter, we will cover a couple of exercises using these specific
    objects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js运行时包括诸如`EventEmitter`、`HTTPServer`和`HTTPClient`等对象，它们为我们构建应用程序提供了基础。即使我们很少直接使用这些对象，了解它们的工作原理也是有用的，在本章中，我们将涵盖使用这些特定对象的一些练习。
- en: We'll first build a simple application directly using the `HTTPServer` object.
    Then, we'll move on to using Express to create an application for computing Fibonacci
    numbers. Because this can be computationally expensive, we'll use this to explore
    why it's important to not block the event queue in Node.js and what happens to
    applications that do. This will give us an excuse to develop a simple background
    **Representational State Transfer** (**REST**) server, an HTTP client for making
    requests on that server, and the implementation of a multi-tier web application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先直接使用`HTTPServer`对象构建一个简单的应用程序。然后，我们将使用Express来创建一个计算斐波那契数的应用程序。因为这可能是计算密集型的，我们将利用这一点来探讨为什么在Node.js中不阻塞事件队列是重要的，以及对这样做的应用程序会发生什么。这将给我们一个借口来开发一个简单的后台REST服务器，一个用于在服务器上发出请求的HTTP客户端，以及一个多层web应用程序的实现。
- en: In today's world, the microservice application architecture implements background
    REST servers, which is what we'll do in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的世界中，微服务应用架构实现了后台REST服务器，这就是我们在本章中要做的事情。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Sending and receiving events using the `EventEmitter` pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`EventEmitter`模式发送和接收事件
- en: Understanding an HTTP server application by building a simple application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过构建一个简单的应用程序来理解HTTP服务器应用程序
- en: Web application frameworks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web应用程序框架
- en: Using the Express framework to build a simple application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express框架构建一个简单的应用程序
- en: Handling computationally intensive calculations in an Express application and
    the Node.js event loop
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Express应用程序中处理计算密集型计算和Node.js事件循环。
- en: Making HTTP Client requests
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发出HTTP客户端请求
- en: Creating a simple REST service with Express
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express创建一个简单的REST服务
- en: By going through these topics, you'll gain an understanding of several aspects
    of designing HTTP-based web services. The goal is for you to understand how to
    create or consume an HTTP service and to get an introduction to the Express framework.
    By the end of this chapter, you'll have a basic understanding of these two tools.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习这些主题，你将了解设计基于HTTP的web服务的几个方面。目标是让你了解如何创建或消费一个HTTP服务，并对Express框架有一个介绍。在本章结束时，你将对这两个工具有一个基本的了解。
- en: That's a lot to cover, and it will give us a good foundation for the rest of
    this book.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多内容，但这将为本书的其余部分奠定一个良好的基础。
- en: Sending and receiving events with EventEmitter
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EventEmitter发送和接收事件
- en: '`EventEmitter` is one of the core idioms of Node.js. If Node.js''s core idea
    is an event-driven architecture, emitting events from an object is one of the
    primary mechanisms of that architecture. `EventEmitter` is an object that gives
    notifications (events) at different points in its life cycle. For example, an
    `HTTPServer` object emits events concerning each stage of the startup/shutdown
    of the Server object and at each stage of processing HTTP requests from HTTP clients.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter`是Node.js的核心习语之一。如果Node.js的核心思想是事件驱动的架构，那么从对象中发出事件是该架构的主要机制之一。`EventEmitter`是一个在其生命周期的不同阶段提供通知（事件）的对象。例如，一个`HTTPServer`对象会发出与服务器对象的启动/关闭以及处理来自HTTP客户端的HTTP请求的每个阶段相关的事件。'
- en: Many core Node.js modules are `EventEmitter` objects, and `EventEmitter` objects
    are an excellent skeleton on which to implement asynchronous programming. `EventEmitter`
    objects are so much a part of the Node.js woodwork that you may skip over their
    existence. However, because they're used everywhere, we need some understanding
    of what they are and how to use them when necessary.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 许多核心的Node.js模块都是`EventEmitter`对象，而`EventEmitter`对象是实现异步编程的一个很好的基础。`EventEmitter`对象在Node.js中非常常见，以至于你可能会忽略它们的存在。然而，因为它们随处可见，我们需要了解它们是什么，以及在必要时如何使用它们。
- en: In this chapter, we'll work with the `HTTPServer` and `HTTPClient` objects.
    Both are subclasses of the `EventEmitter` class and rely on it to send events
    for each step of the HTTP protocol. In this section, we'll first learn about using
    JavaScript classes, and then we will create an `EventEmitter` subclass so that
    we can learn about `EventEmitter`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用`HTTPServer`和`HTTPClient`对象。两者都是`EventEmitter`类的子类，并依赖于它来发送HTTP协议每个步骤的事件。在本节中，我们将首先学习使用JavaScript类，然后创建一个`EventEmitter`子类，以便我们可以学习`EventEmitter`。
- en: JavaScript classes and class inheritance
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript类和类继承
- en: 'Before getting started on the `EventEmitter` class, we need to take a look
    at another one of the ES2015 features: classes. JavaScript has always had objects
    and the concept of a class hierarchy, but nothing as formal as in other languages.
    The ES2015 class object builds on the existing prototype-based inheritance model,
    but with a syntax that looks a lot like class definitions in other languages.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始`EventEmitter`类之前，我们需要看一下ES2015的另一个特性：类。JavaScript一直有对象和类层次结构的概念，但没有其他语言那样正式。ES2015类对象建立在现有的基于原型的继承模型之上，但其语法看起来很像其他语言中的类定义。
- en: 'For example, consider the following class, which we''ll be using later in this
    book:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下类，我们将在本书的后面使用：
- en: '[PRE0]js\1'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]js\1'
- en: 'Functions marked with the `get` or `set` keywords are getters and setters,
    used as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`get`或`set`关键字标记的函数是getter和setter，用法如下：
- en: '[PRE1]js\1'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE1]js\1'
- en: 'Finally, you declare a subclass using the `extends` operator, similar to how
    you would in other languages:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用`extends`运算符声明一个子类，类似于其他语言中的操作：
- en: '[PRE2]js\1'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE2]js\1'
- en: This is an ES6 module that defines a class named `Pulser`. The class inherits
    from `EventEmitter` and provides a few methods of its own.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个定义了名为`Pulser`的类的ES6模块。该类继承自`EventEmitter`并提供了一些自己的方法。
- en: Another thing to examine is how `this.emit` in the callback function refers
    to the `Pulser` object instance. This implementation relies on the ES2015 arrow
    function. Before arrow functions, our callbacks used a regular function, and `this`
    would not have referred to the `Pulser` object instance. Instead, `this` would
    have referred to some other object related to the `setInterval` function. One
    of the attributes of arrow functions is that `this` inside the arrow function
    has the same value as `this` in the surrounding context. This means, in this case,
    that `this` does refer to the `Pulser` object instance.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件要检查的事情是回调函数中的`this.emit`如何引用`Pulser`对象实例。这个实现依赖于ES2015箭头函数。在箭头函数之前，我们的回调使用了一个常规的`function`，而`this`不会引用`Pulser`对象实例。相反，`this`会引用与`setInterval`函数相关的其他对象。箭头函数的一个特性是，箭头函数内部的`this`与周围上下文中的`this`具有相同的值。这意味着，在这种情况下，`this`确实引用`Pulser`对象实例。
- en: 'Back when we had to use `function`, rather than an arrow function, we had to
    assign `this` to another variable, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们必须使用`function`而不是箭头函数时，我们必须将`this`分配给另一个变量，如下所示：
- en: '[PRE3]js\1'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE3]js\1'
- en: The purpose of the `Pulser` class is to send a timed event once a second to
    any listeners. The `start` method uses `setInterval` to kick off a repeated callback
    execution that is scheduled for every second and calls `emit` to send the `pulse`
    events to any listeners.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pulser`类的目的是每秒向任何监听器发送一个定时事件。`start`方法使用`setInterval`来启动重复的回调执行，计划每秒调用`emit`将`pulse`事件发送给任何监听器。'
- en: 'Now, let''s see how we can use the `Pulser` object. Create a new file called
    `pulsed.mjs`, containing the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`Pulser`对象。创建一个名为`pulsed.mjs`的新文件，其中包含以下代码：
- en: '[PRE4]js\1'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE4]js\1'
- en: For each `pulse` event received, a `pulse received` message is printed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个接收到的`pulse`事件，都会打印一个`pulse received`消息。
- en: That gives you a little practical knowledge of the `EventEmitter` class. Let's
    now look at its operational theory.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这为您提供了一些关于`EventEmitter`类的实际知识。现在让我们看一下它的操作理论。
- en: The EventEmitter theory
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EventEmitter理论
- en: With the `EventEmitter` class, your code emits events that other code can receive.
    This is a way of connecting two separated sections of your program, kind of like
    how quantum entanglement means two electrons can communicate with each other from
    any distance. It seems simple enough.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`EventEmitter`类，您的代码会发出其他代码可以接收的事件。这是一种连接程序中两个分离部分的方式，有点像量子纠缠的方式，两个电子可以在任何距离上相互通信。看起来很简单。
- en: The event name can be anything that makes sense to you, and you can define as
    many event names as you like. Event names are defined simply by calling `.emit`
    with the event name. There's nothing formal to do and no registry of event names
    is required. Simply making a call to `.emit` is enough to define an event name.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 事件名称可以是任何对您有意义的内容，您可以定义尽可能多的事件名称。事件名称是通过使用事件名称调用`.emit`来定义的。无需进行任何正式操作，也不需要注册事件名称。只需调用`.emit`就足以定义事件名称。
- en: By convention, the `error` event name indicates an error.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，`error`事件名称表示错误。
- en: An object sends events using the `.emit` function. Events are sent to any listeners
    that have registered to receive events from the object. The program registers
    to receive an event by calling that object's `.on` method, giving the event name
    and an event handler function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象使用`.emit`函数发送事件。事件被发送到任何已注册接收对象事件的监听器。程序通过调用该对象的`.on`方法注册接收事件，给出事件名称和事件处理程序函数。
- en: There is no central distribution point for all events. Instead, each instance
    of an `EventEmitter` object manages its own set of listeners and distributes its
    events to those listeners.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有事件没有一个中央分发点。相反，每个`EventEmitter`对象实例管理其自己的监听器集，并将其事件分发给这些监听器。
- en: 'Often, it is required to send data along with an event. To do so, simply add
    the data as arguments to the `.emit` call, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，需要在事件中发送数据。要这样做，只需将数据作为参数添加到`.emit`调用中，如下所示：
- en: '[PRE5]js\1'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE5]js\1'
- en: There is no handshaking between event receivers and the event sender. That is,
    the event sender simply goes on with its business and it gets no notifications
    about any events that were received, any action taken, or any errors that occurred.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 事件接收器和事件发送器之间没有握手。也就是说，事件发送器只是继续它的业务，不会收到任何关于接收到的事件、采取的任何行动或发生的任何错误的通知。
- en: In this example, we used another one of the ES2015 features—the `rest` operator—used
    here in the form of `...theArgs.` The `rest` operator catches any number of remaining
    function parameters into an array. Since `EventEmitter` can pass along any number
    of parameters and the `rest` operator can automatically receive any number of
    parameters, it's a match made in heaven—or at least in the TC-39 committee.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了ES2015的另一个特性——`rest`运算符——在这里以`...theArgs`的形式使用。`rest`运算符将任意数量的剩余函数参数捕获到一个数组中。由于`EventEmitter`可以传递任意数量的参数，而`rest`运算符可以自动接收任意数量的参数，它们是天作之合，或者至少是在TC-39委员会中。
- en: We've now learned how to use JavaScript classes and how to use the `EventEmitter`
    class. What's next is examining how the `HTTPServer` object uses `EventEmitter`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何使用JavaScript类以及如何使用`EventEmitter`类。接下来要做的是检查`HTTPServer`对象如何使用`EventEmitter`。
- en: Understanding HTTP server applications
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解HTTP服务器应用程序
- en: The `HTTPServer` object is the foundation of all Node.js web applications. The
    object itself is very close to the HTTP protocol, and its use requires knowledge
    of this protocol. Fortunately, in most cases, you'll be able to use an application
    framework, such as Express, to hide the HTTP protocol details. As application
    developers, we want to focus on business logic.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTPServer`对象是所有Node.js Web应用程序的基础。这个对象本身非常接近HTTP协议，使用它需要对这个协议有所了解。幸运的是，在大多数情况下，您可以使用应用程序框架，比如Express，来隐藏HTTP协议的细节。作为应用程序开发者，我们希望专注于业务逻辑。'
- en: 'We already saw a simple HTTP server application in [Chapter 2](bd2253cb-6a41-4fc5-ae86-cc9632d44da4.xhtml),
    *Setting Up Node.js. *Because `HTTPServer` is an `EventEmitter` object, the example
    can be written in another way to make this fact explicit by separately adding
    the event listener:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第2章](bd2253cb-6a41-4fc5-ae86-cc9632d44da4.xhtml)中看到了一个简单的HTTP服务器应用程序，*设置Node.js。*因为`HTTPServer`是一个`EventEmitter`对象，所以可以以另一种方式编写示例，以明确这一事实，通过分别添加事件监听器：
- en: '[PRE6]js\1'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE6]js\1'
- en: 'The `request` event is emitted by `HTTPServer` every time a request arrives
    from a web browser. In this case, we want to respond differently based on the
    request URL, which arrives as `req.url`. This value is a string containing the
    URL from the HTTP request. Since there are many attributes to a URL, we need to
    parse the URL so that we can correctly match the pathname for one of two paths:
    `/` and `/osinfo`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`request`事件是由`HTTPServer`每次从Web浏览器接收到请求时发出的。在这种情况下，我们希望根据请求URL的不同而有不同的响应，请求URL以`req.url`的形式到达。这个值是一个包含来自HTTP请求的URL的字符串。由于URL有许多属性，我们需要解析URL以便正确匹配两个路径中的一个的路径名：`/`和`/osinfo`。'
- en: Parsing a URL with the URL class requires a **base URL**, which we've supplied
    in the `listenOn` variable. Notice how we're reusing this same variable in a couple
    of other places, using one string to configure multiple parts of the application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用URL类解析URL需要一个**基本URL**，我们在`listenOn`变量中提供了这个URL。请注意，我们在其他地方多次重用了这个变量，使用一个字符串来配置应用程序的多个部分。
- en: Depending on the path, either the `homePage` or `osInfo` functions are called.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根据路径，要么调用`homePage`函数，要么调用`osInfo`函数。
- en: This is called **request routing**, where we look at attributes of the incoming
    request, such as the request path, and route the request to handler functions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**请求路由**，我们在其中查看传入请求的属性，比如请求路径，并将请求路由到处理程序函数。
- en: In the handler functions, the `req` and `res` parameters correspond to the `request` and `response` objects.
    Where `req` contains data about the incoming request, we send the response using
    `res`. The `writeHead` function sets up the return status (`200` means success,
    while `404` means the page is not found) and the `end` function sends the response.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理程序函数中，`req`和`res`参数对应于`request`和`response`对象。`req`包含有关传入请求的数据，我们使用`res`发送响应。`writeHead`函数设置返回状态（`200`表示成功，而`404`表示页面未找到），`end`函数发送响应。
- en: If the request URL is not recognized, the server sends back an error page using
    a `404` result code. The result code informs the browser about the status of the
    request, where a `200` code means everything is fine and a `404` code means the
    requested page doesn't exist. There are, of course, many other HTTP response codes,
    each with their own meaning.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求的URL没有被识别，服务器将使用`404`结果代码发送回一个错误页面。结果代码通知浏览器有关请求状态，其中`200`代码表示一切正常，`404`代码表示请求的页面不存在。当然，还有许多其他HTTP响应代码，每个代码都有自己的含义。
- en: There are plenty more functions attached to both objects, but that's enough
    to get us started.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个对象都附加了许多其他函数，但这已经足够让我们开始了。
- en: 'To run it, type the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行它，请输入以下命令：
- en: '[PRE7]js\1'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE7]js\1'
- en: 'Before ES2015, one way to implement a multiline string was to use the following
    construct:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES2015之前，实现多行字符串的一种方法是使用以下结构：
- en: '[PRE8]js\1'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE8]js\1'
- en: This is more succinct and straightforward. The opening quote is on the first
    line, the closing quote is on the last line, and everything in between is part
    of our string.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这更加简洁和直接。开头引号在第一行，结束引号在最后一行，中间的所有内容都是我们的字符串的一部分。
- en: The real purpose of the template strings feature is to support easily substituting
    values directly into strings. Many other programming languages support this ability,
    and now JavaScript does, too.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串功能的真正目的是支持将值直接替换到字符串中。许多其他编程语言支持这种能力，现在JavaScript也支持了。
- en: 'Pre-ES2015, a programmer would have written their code like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES2015之前，程序员会这样编写他们的代码：
- en: '[PRE9]js\1'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE9]js\1'
- en: Within a template string, the part within the `${ .. }` brackets is interpreted
    as an expression. This can be a simple mathematical expression, a variable reference,
    or, as in this case, a function call.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板字符串中，`${..}`括号中的部分被解释为表达式。这可以是一个简单的数学表达式、一个变量引用，或者在这种情况下，一个函数调用。
- en: Using template strings to insert data carries a security risk. Have you verified
    that the data is safe? Will it form the basis of a security attack? As always,
    data coming from an untrusted source, such as user input, must be properly encoded
    for the target context where the data is being inserted. In the example here,
    we should have used a function to encode this data as HTML, perhaps. But for this
    case, the data is in the form of simple strings and numbers and comes from a known,
    safe data source—the built-in `os` module—and so we know that this application
    is safe.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板字符串插入数据存在安全风险。您是否验证了数据的安全性？它会成为安全攻击的基础吗？与始终如一的数据来自不受信任的来源，如用户输入，必须为数据要插入的目标上下文正确编码。在这个例子中，我们应该使用一个函数来将这些数据编码为HTML，也许。但是对于这种情况，数据是简单的字符串和数字形式，并来自已知的安全数据源——内置的`os`模块，因此我们知道这个应用程序是安全的。
- en: For this and many other reasons, it is often safer to use an external template
    engine. Applications such as Express make it easy to do so.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个原因和许多其他原因，通常更安全使用外部模板引擎。诸如Express之类的应用程序可以轻松实现这一点。
- en: We now have a simple HTTP-based web application. To gain more experience with
    HTTP events, let's add to one to a module for listening to all HTTP events.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个简单的基于HTTP的Web应用程序。为了更多地了解HTTP事件，让我们为监听所有HTTP事件的模块添加一个。
- en: HTTP Sniffer – listening to the HTTP conversation
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP Sniffer - 监听HTTP对话
- en: The events emitted by the `HTTPServer` object can be used for additional purposes
    beyond the immediate task of delivering a web application. The following code
    demonstrates a useful module that listens to all of the `HTTPServer` events. It
    could be a useful debugging tool, which also demonstrates how `HTTPServer` objects
    operate.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTPServer`对象发出的事件可以用于除了传递Web应用程序的直接任务之外的其他目的。以下代码演示了一个有用的模块，它监听所有`HTTPServer`事件。这可能是一个有用的调试工具，还演示了`HTTPServer`对象的操作方式。'
- en: Node.js's `HTTPServer` object is an `EventEmitter` object, and HTTP Sniffer
    simply listens to every server event, printing out information pertinent to each
    event.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的`HTTPServer`对象是一个`EventEmitter`对象，而HTTP Sniffer只是监听每个服务器事件，打印出与每个事件相关的信息。
- en: 'Create a file named `httpsniffer.mjs`, containing the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`httpsniffer.mjs`的文件，其中包含以下代码：
- en: '[PRE10]js\1'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE10]js\1'
- en: 'Then, change the server setup, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下方式更改服务器设置：
- en: '[PRE11]js\1'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE11]js\1'
- en: You now have a tool for snooping on `HTTPServer` events. This simple technique
    prints a detailed log of event data. This pattern can be used for any `EventEmitter`
    objects. You can use this technique as a way to inspect the actual behavior of
    `EventEmitter` objects in your program.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有一个用于窥探`HTTPServer`事件的工具。这种简单的技术打印出事件数据的详细日志。这种模式可以用于任何`EventEmitter`对象。您可以使用这种技术来检查程序中`EventEmitter`对象的实际行为。
- en: Before we move on to using Express, we need to discuss why we use application
    frameworks at all.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续使用Express之前，我们需要讨论为什么要使用应用程序框架。
- en: Web application frameworks
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web应用程序框架
- en: The `HTTPServer` object is very close to the HTTP protocol. While this is powerful
    in the same way that driving a stick shift car gives you low-level control over
    the driving experience, typical web application programming is better done at
    a higher level. Does anyone use assembly language to write web applications? It's
    better to abstract away the HTTP details and concentrate on your application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTPServer`对象与HTTP协议非常接近。虽然这在某种程度上很强大，就像驾驶手动挡汽车可以让您对驾驶体验进行低级控制一样，但典型的Web应用程序编程最好在更高的级别上完成。有人使用汇编语言来编写Web应用程序吗？最好将HTTP细节抽象出来，集中精力放在应用程序上。'
- en: The Node.js developer community has developed quite a few application frameworks
    to help with different aspects of abstracting away HTTP protocol details. Of these
    frameworks, Express is the most popular, and Koa ([http://koajs.com/](http://koajs.com/))
    should be considered because it has fully integrated support for async functions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js开发者社区已经开发了相当多的应用程序框架，以帮助抽象HTTP协议细节的不同方面。在这些框架中，Express是最受欢迎的，而Koa（[http://koajs.com/](http://koajs.com/)）应该被考虑，因为它完全集成了对异步函数的支持。
- en: The Express.js wiki has a list of frameworks built on top of Express.js or tools
    that work with it. This includes template engines, middleware modules, and more.
    The Express.js wiki is located at [https://github.com/expressjs/express/wiki](https://github.com/expressjs/express/wiki).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js维基上列出了建立在Express.js之上或与其一起使用的框架和工具。这包括模板引擎、中间件模块等。Express.js维基位于[https://github.com/expressjs/express/wiki](https://github.com/expressjs/express/wiki)。
- en: 'One reason to use a web framework is that they often have well-tested implementations
    of the best practices used in web application development for over 20 years. The
    usual best practices include the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Web框架的一个原因是它们通常具有在Web应用程序开发中使用了20多年的最佳实践的经过充分测试的实现。通常的最佳实践包括以下内容：
- en: Providing a page for bad URLs (the `404` page)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个用于错误URL的页面（`404`页面）
- en: Screening URLs and forms for any injected scripting attacks
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 筛选URL和表单以防注入脚本攻击
- en: Supporting the use of cookies to maintain sessions
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持使用cookie来维护会话
- en: Logging requests for both usage tracking and debugging
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录请求以进行使用跟踪和调试
- en: Authentication
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证
- en: Handling static files, such as images, CSS, JavaScript, or HTML
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理静态文件，如图像、CSS、JavaScript或HTML
- en: Providing cache-control headers to caching proxies
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供缓存控制头以供缓存代理使用
- en: Limiting things such as the page size or execution time
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制页面大小或执行时间等事项
- en: Web frameworks help you invest your time in a task without getting lost in the
    details of implementing the HTTP protocol. Abstracting away details is a time-honored
    way for programmers to be more efficient. This is especially true when using a
    library or framework that provides prepackaged functions that take care of the
    details.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Web框架帮助您将时间投入到任务中，而不会迷失在实现HTTP协议的细节中。抽象化细节是程序员提高效率的一种历史悠久的方式。当使用提供预打包函数来处理细节的库或框架时，这一点尤其正确。
- en: With that in mind, let's turn to a simple application implemented with Express.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们转向使用Express实现的一个简单应用程序。
- en: Getting started with Express
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Express
- en: Express is perhaps the most popular Node.js web app framework. Express is described
    as being Sinatra-like, which refers to a popular Ruby application framework. It
    is also regarded as not being an opinionated framework, meaning the framework
    authors don't impose their opinions about structuring an application. This means
    Express is not at all strict about how your code is structured; you just write
    it the way you think is best.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Express可能是最受欢迎的Node.js Web应用程序框架。Express被描述为类似于Sinatra，这是一个流行的Ruby应用程序框架。它也被认为不是一种武断的框架，这意味着框架作者不会对应用程序的结构施加自己的意见。这意味着Express对代码的结构并不严格；您只需按照您认为最好的方式编写即可。
- en: You can visit the home page for Express at [http://expressjs.com/](http://expressjs.com/).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问Express的主页[http://expressjs.com/](http://expressjs.com/)。
- en: As of the time of writing this book, Express 4.17 is the current version, and
    Express 5 is in alpha testing. According to the Express.js website, there are
    very few differences between Express 4 and Express 5.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 截至撰写本书时，Express 4.17是当前版本，Express 5正在进行alpha测试。根据Express.js网站，Express 4和Express
    5之间几乎没有什么区别。
- en: Let's start by installing `express-generator`. While we can just start with
    writing some code, `express-generator` provides a blank starting application,
    which we'll take and modify.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先安装`express-generator`。虽然我们可以直接开始编写一些代码，但`express-generator`提供了一个空白的起始应用程序，我们将使用它并进行修改。
- en: 'Install `express-generator` using the following commands:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令安装`express-generator`：
- en: '[PRE12]js\1'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE12]js\1'
- en: 'Run the `express` command, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`express`命令，如下所示：
- en: '[PRE13]js\1'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE13]js\1'
- en: This executes exactly the same, without having to install `express-generator`
    and (as we'll see in a moment) remembering to uninstall it when you're done using
    the command.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这样执行完全相同，无需安装`express-generator`，并且（我们马上会看到）在使用命令结束时记得卸载它。
- en: 'Now that you''ve installed `express-generator` in the `fibonacci` directory,
    use it to set up the blank framework application:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经在`fibonacci`目录中安装了`express-generator`，使用它来设置空白框架应用程序：
- en: '[PRE14]js\1'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE14]js\1'
- en: 'This uninstalls the `express-generator` tool. The next thing to do is to run
    the blank application in the way that we''re told. The `npm start` command relies
    on a section of the supplied `package.json` file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将卸载`express-generator`工具。接下来要做的是按照我们被告知的方式运行空白应用程序。`npm start`命令依赖于提供的`package.json`文件的一个部分：
- en: '[PRE15]js\1'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE15]js\1'
- en: Setting the `DEBUG` variable this way turns on the debugging output, which includes
    a message about listening on port `3000`. Otherwise, we aren't told this information.
    This syntax is what's used in the Bash shell to run a command with an environment
    variable. If you get an error when running `npm start`, then refer to the next
    section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式设置`DEBUG`变量会打开调试输出，其中包括有关监听端口`3000`的消息。否则，我们不会得到这些信息。这种语法是在Bash shell中使用环境变量运行命令的方式。如果在运行`npm
    start`时出错，请参考下一节。
- en: 'We can modify the supplied `npm start` script to always run the app with debugging
    enabled. Change the `scripts` section to the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改提供的`npm start`脚本，始终使用启用调试的应用程序。将`scripts`部分更改为以下内容：
- en: '[PRE16]js\1'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE16]js\1'
- en: 'Then, the command is executed, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行以下命令：
- en: '[PRE17]js\1'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE17]js\1'
- en: This means that `app.js` is a CommonJS module that exports the application object
    generated by the `express` module. Our task in `app.js` is to configure that application
    object. This task does not include starting the `HTTPServer` object, however.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`app.js`是一个CommonJS模块，它导出了由`express`模块生成的应用程序对象。我们在`app.js`中的任务是配置该应用程序对象。但是，这个任务不包括启动`HTTPServer`对象。
- en: 'Now, let''s turn to the `bin/www` script. It is in this script where the HTTP
    server is started. The first thing to notice is that it starts with the following
    line:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向`bin/www`脚本。在这个脚本中启动了HTTP服务器。首先要注意的是它以以下行开始：
- en: '[PRE18]js\1'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE18]js\1'
- en: We can also see that the script was made executable by `express-generator`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到该脚本是通过`express-generator`可执行的。
- en: 'It calls the `app.js` module, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它调用`app.js`模块，如下所示：
- en: '[PRE19]js\1'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE19]js\1'
- en: By specifying an environment variable for `PORT`, we can tell the application
    to listen in on port `4242`, where you can ponder the meaning of life.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为`PORT`指定环境变量，我们可以告诉应用程序监听端口`4242`，您可以在那里思考生活的意义。
- en: The `app` object is next passed to `http.createServer()`. A look at the Node.js
    documentation tells us that this function takes `requestListener`, which is simply
    a function that takes the `request` and `response` objects that we saw previously.
    Therefore, the `app` object is the same kind of function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来将`app`对象传递给`http.createServer()`。查看Node.js文档告诉我们，这个函数接受`requestListener`，它只是一个接受我们之前看到的`request`和`response`对象的函数。因此，`app`对象是相同类型的函数。
- en: Finally, the `bin/www` script starts the server listening process on the port
    we specified.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`bin/www`脚本启动了服务器监听进程，监听我们指定的端口。
- en: 'Let''s now go through `app.js` in more detail:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更详细地了解`app.js`：
- en: '[PRE20]js\1'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE20]js\1'
- en: 'The `app.use` function mounts middleware functions. This is an important piece
    of Express jargon, which we will discuss shortly. At the moment, let''s say that
    middleware functions are executed during the processing of requests. This means
    all the features named here are enabled in `app.js`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.use`函数挂载中间件函数。这是Express术语中的重要部分，我们很快会讨论。目前，让我们说中间件函数在处理请求时被执行。这意味着`app.js`中启用了这里列出的所有功能：'
- en: Logging is enabled using the `morgan` request logger. Refer to [https://www.npmjs.com/package/morgan](https://www.npmjs.com/package/morgan)
    for its documentation.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`morgan`请求记录器启用日志记录。请参考[https://www.npmjs.com/package/morgan](https://www.npmjs.com/package/morgan)获取其文档。
- en: The `body-parser` module handles parsing HTTP request bodies. Refer to [https://www.npmjs.com/package/body-parser](https://www.npmjs.com/package/body-parser)
    for its documentation.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body-parser`模块处理解析HTTP请求主体。请参考[https://www.npmjs.com/package/body-parser](https://www.npmjs.com/package/body-parser)获取其文档。'
- en: The `cookie-parser` module is used to parse HTTP cookies. Refer to [https://www.npmjs.com/package/cookie-parser](https://www.npmjs.com/package/cookie-parser)
    for its documentation.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cookie-parser`模块用于解析HTTP cookie。请参考[https://www.npmjs.com/package/cookie-parser](https://www.npmjs.com/package/cookie-parser)获取其文档。'
- en: A static file web server is configured to serve the asset files in the `public`
    directory. Refer to [http://expressjs.com/en/starter/static-files.html](http://expressjs.com/en/starter/static-files.html) for
    its documentation.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置静态文件Web服务器以提供`public`目录中的资产文件。请参考[http://expressjs.com/en/starter/static-files.html](http://expressjs.com/en/starter/static-files.html)获取其文档。
- en: Two router modules—`routes` and `users`—to set up which functions handle which
    URLs.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个路由模块——`routes`和`users`——设置哪些函数处理哪些URL。
- en: The static file web server arranges to serve, via HTTP requests, the files in
    the named directory. With the configuration shown here, the `public/stylesheets/style.css` file is
    available at `http://HOST/stylesheets/style.css`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 静态文件Web服务器安排通过HTTP请求提供命名目录中的文件。使用此配置，`public/stylesheets/style.css`文件可在`http://HOST/stylesheets/style.css`上访问。
- en: We shouldn't feel limited to setting up an Express application this way. This
    is the recommendation of the Express team, but there is nothing constraining us
    from setting it up another way. For example, later in this book, we'll rewrite
    this entirely as ES6 modules, rather than sticking to CommonJS modules. One glaring
    omission is handlers for uncaught exceptions and unhandled Promise rejections.
    We'll go over both of these later in this book.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该感到受限于以这种方式设置Express应用程序。这是Express团队的建议，但我们并不受限于以另一种方式设置它。例如，在本书的后面部分，我们将完全将其重写为ES6模块，而不是坚持使用CommonJS模块。一个明显的遗漏是未捕获异常和未处理的Promise拒绝的处理程序。我们稍后会在本书中讨论这两者。
- en: Next, we will discuss Express **middleware** functions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论Express的**中间件**函数。
- en: Understanding Express middleware
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Express中间件
- en: Let's round out our walkthrough of `app.js` by discussing what Express middleware
    functions do for our application. Middleware functions are involved in processing
    requests and sending results to HTTP clients. They have access to the `request`
    and `response` objects and are expected to process their data and perhaps add
    data to these objects. For example, the cookie parser middleware parses HTTP cookie
    headers to record in the `request` object the cookies sent by the browser.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过讨论Express中间件函数为我们的应用程序做了什么来完成对`app.js`的漫游。中间件函数参与处理请求并将结果发送给HTTP客户端。它们可以访问`request`和`response`对象，并且预期处理它们的数据，也许向这些对象添加数据。例如，cookie解析中间件解析HTTP
    cookie头，以记录浏览器发送的cookie在`request`对象中。
- en: 'We have an example of this at the end of our script:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在脚本的最后有一个例子：
- en: '[PRE21]js\1'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE21]js\1'
- en: This does not call `next` but instead calls `res.send`. The HTTP response is
    sent for certain functions on the `response` object, such as `res.send` or `res.render`. This
    is the correct method for ending the request-response cycle, by sending a response
    (`res.send`) to the request. If neither `next` nor `res.send` are called, the
    request never gets a response and the requesting client will hang.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这不调用`next`，而是调用`res.send`。对于`response`对象上的某些函数，如`res.send`或`res.render`，会发送HTTP响应。这是通过发送响应(`res.send`)来结束请求-响应循环的正确方法。如果既不调用`next`也不调用`res.send`，则请求永远不会得到响应，请求的客户端将挂起。
- en: 'So, a middleware function does one of the following four things:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，中间件函数执行以下四种操作中的一种：
- en: Executes its own business logic. The request logger middleware shown earlier
    is an example of this.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行自己的业务逻辑。前面显示的请求记录中间件就是一个例子。
- en: Modifies the `request` or `response` objects. Both `body-parser` and
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`request`或`response`对象。`body-parser`和
- en: '`cookie-parser` do this, looking for data to add to the `request` object.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`cookie-parser`执行此操作，查找要添加到`request`对象的数据。'
- en: Calls `next` to proceed to the next middleware function or otherwise signals
    an error.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`next`以继续下一个中间件函数，或者以其他方式发出错误信号。
- en: Sends a response, ending the cycle.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送响应，结束循环。
- en: The ordering of middleware execution depends on the order that they're added
    to the `app` object. The first function added is executed first, and so on.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件执行的顺序取决于它们添加到`app`对象的顺序。添加的第一个函数首先执行，依此类推。
- en: The next thing to understand is request handlers and how they differ from middleware
    functions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要理解的是请求处理程序以及它们与中间件函数的区别。
- en: Contrasting middleware and request handlers
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件和请求处理程序的对比
- en: We've seen two kinds of middleware functions so far. In one, the first argument
    is the handler function. In the other, the first argument is a string containing
    a URL snippet and the second argument is the handler function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了两种中间件函数。在一种中，第一个参数是处理程序函数。在另一种中，第一个参数是包含URL片段的字符串，第二个参数是处理程序函数。
- en: 'What''s actually going on is `app.use` has an optional first argument: the
    path that the middleware is mounted on. The path is a pattern match against the
    request URL, and the given function is triggered if the URL matches the pattern.
    There''s even a method to supply named parameters in the URL:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`app.use`有一个可选的第一个参数：中间件挂载的路径。该路径是对请求URL的模式匹配，并且如果URL匹配模式，则触发给定的函数。甚至有一种方法可以在URL中提供命名参数：
- en: '[PRE22]js\1'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE22]js\1'
- en: The required behavior of `GET` is to retrieve data, while the behavior of `PUT`
    is to store data. However, as the example was written above, it would match either
    of the HTTP methods when the handler function is only correct for the `GET` verb.
    However, using `app.get`, as is the case here, ensures that the application correctly
    matches the desired HTTP method.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`的所需行为是检索数据，而`PUT`的行为是存储数据。然而，如上所述的示例，当处理程序函数仅对`GET`动词正确时，它将匹配任一HTTP方法。但是，使用`app.get`，如本例中的情况，确保应用程序正确匹配所需的HTTP方法。'
- en: 'Finally, we get to the `Router` object. This is the kind of middleware used
    explicitly for routing requests based on their URL. Take a look at `routes/users.js`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了`Router`对象。这是一种专门用于根据其URL路由请求的中间件。看一下`routes/users.js`：
- en: '[PRE23]js\1'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE23]js\1'
- en: This takes the `router` object, with its zero-or-more router functions, and
    mounts it on the `/users` URL. As Express looks for a matching routing function,
    it first scans the functions attached to the `app` object, and for any router
    object, it scans its functions as well. It then invokes any routing functions
    that match the request.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`router`对象及其零个或多个路由函数挂载到`/users` URL上。当Express寻找匹配的路由函数时，首先扫描附加到`app`对象的函数，对于任何路由器对象，它也会扫描其函数。然后调用与请求匹配的任何路由函数。
- en: Going back to the issue of the `/` URL, the fact that the router is *mounted
    on* the `/users` URL is important. That's because the actual URL it considers
    matching is the mount point (`/users`) concatenated with the URL in the `router`
    function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`/` URL的问题，`router`实际上*挂载在*`/users` URL上是很重要的。这是因为它考虑匹配的实际URL是挂载点(`/users`)与`router`函数中的URL连接起来的。
- en: The effect is that the mount prefix is stripped from the request URL for the
    purpose of matching against the `router` functions attached to the `router` object.
    So, with that mount point, an incoming URL of `/users/login` would be stripped
    to just `/login` in order to find a matching `router` function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 效果是为了匹配附加到`router`对象的`router`函数，请求URL的挂载前缀被剥离。因此，使用该挂载点，`/users/login`的传入URL将被剥离为`/login`，以便找到匹配的`router`函数。
- en: Since not everything goes according to plan, our applications must be capable
    of handling error indications and showing error messages to users.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并非一切都按计划进行，我们的应用程序必须能够处理错误指示并向用户显示错误消息。
- en: Error handling
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: Now, we can finally get back to the generated `app.js` file, the `404 Error
    page not found` error, and any other errors that the application might show to
    the user.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于可以回到生成的`app.js`文件，`404 Error page not found`错误，以及应用程序可能向用户显示的任何其他错误。
- en: A middleware function indicates an error by passing a value to the `next` function
    call, namely by calling `next(err)`. Once Express sees the error, it skips over
    any remaining non-error routings and only passes the error to error handlers instead.
    An error handler function has a different signature than what we saw earlier.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件函数通过将值传递给`next`函数调用来指示错误，即通过调用`next(err)`。一旦Express看到错误，它将跳过任何剩余的非错误路由，并仅将错误传递给错误处理程序。错误处理程序函数的签名与我们之前看到的不同。
- en: 'In `app.js`, which we''re examining, the following is our error handler, provided
    by `express-generator`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们正在检查的`app.js`中，以下是我们的错误处理程序，由`express-generator`提供：
- en: '[PRE24]js\1'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE24]js\1'
- en: In a Handlebars template, the `{{value}}` markup means to substitute into the
    template the value of the expression or variable. The values referenced by this
    template—`message` and `error`—are provided by setting `res.locals` as shown here.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在Handlebars模板中，`{{value}}`标记意味着将表达式或变量的值替换到模板中。此模板引用的`message`和`error`是通过设置`res.locals`提供的，如下所示。
- en: 'To see the error handler in action, let''s add the following to `routes/index.js`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看错误处理程序的操作，请将以下内容添加到`routes/index.js`：
- en: '[PRE25]js\1'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE25]js\1'
- en: Most of this is what `express-generator` gave us. The `var` statements have
    been changed to `const` for that little teensy bit of extra comfort. We explicitly
    imported the `hbs` module so that we could do some configuration. We also imported
    a router module for `Fibonacci`, which we'll see in a minute.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这大部分是`express-generator`给我们的。`var`语句已更改为`const`，以获得更多的舒适度。我们明确导入了`hbs`模块，以便进行一些配置。我们还导入了一个`Fibonacci`的路由模块，我们马上就会看到。
- en: For the `Fibonacci` application, we don't need to support users and so we have
    deleted the routing module. The `routes/fibonacci.js` module, which we'll show
    next, serves to query a number for which we'll calculate the Fibonacci number.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Fibonacci`应用程序，我们不需要支持用户，因此已删除了路由模块。我们将在接下来展示的`routes/fibonacci.js`模块用于查询我们将计算斐波那契数的数字。
- en: 'In the top-level directory, create a file, `math.js`, containing the following
    extremely simplistic Fibonacci implementation:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶级目录中，创建一个名为`math.js`的文件，其中包含以下极其简单的斐波那契实现：
- en: '[PRE26]js\1'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE26]js\1'
- en: This file contains the structure that we'll use for the HTML pages. Going by
    the Handlebars syntax, we can see that `{{title}}` appears within the HTML `title`
    tag. This means that when we call `res.render`, we should supply a `title` attribute.
    The `{{{body}}}` tag is where the `view` template content lands.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含我们将用于HTML页面的结构。根据Handlebars语法，我们可以看到`{{title}}`出现在HTML`title`标记中。这意味着当我们调用`res.render`时，我们应该提供一个`title`属性。`{{{body}}}`标记是`view`模板内容的落脚点。
- en: 'Change `views/index.hbs` to just contain the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将`views/index.hbs`更改为只包含以下内容：
- en: '[PRE27]js\1'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE27]js\1'
- en: This will serve as a navigation bar that's included on every page.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这将作为包含在每个页面上的导航栏。
- en: 'Create a file, `views/fibonacci.hbs`, containing the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`views/fibonacci.hbs`的文件，其中包含以下代码：
- en: '[PRE28]js\1'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE28]js\1'
- en: The anonymous object passed to `res.render` contains the data values we provide
    to the layout and view templates. We're now passing a new welcome message.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`res.render`的匿名对象包含我们提供给布局和视图模板的数据值。我们现在传递了一个新的欢迎消息。
- en: 'Then, finally, in the `routes` directory, create a file named `fibonacci.js`,
    containing the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`routes`目录中，创建一个名为`fibonacci.js`的文件，其中包含以下代码：
- en: '[PRE29]js\1'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE29]js\1'
- en: 'As this suggests, you can visit `http://localhost:3000/` and see what we have:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个示例所暗示的，您可以访问`http://localhost:3000/`，看看我们有什么：
- en: '![](img/1be8113c-faf7-4ee3-b759-0c221f0bc703.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1be8113c-faf7-4ee3-b759-0c221f0bc703.png)'
- en: 'This page is rendered from the `views/index.hbs` template. Simply click on
    the Fibonacci''s link to go to the next page, which is, of course, rendered from
    the `views/fibonacci.hbs` template. On that page, you''ll be able to enter a number,
    click on the Submit button, and get an answer (hint—pick a number below `40` if
    you want your answer in a reasonable amount of time):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面是从`views/index.hbs`模板中渲染出来的。只需点击斐波那契的链接，就可以进入下一个页面，当然，这个页面是从`views/fibonacci.hbs`模板中渲染出来的。在那个页面上，您可以输入一个数字，点击提交按钮，然后得到一个答案（提示-如果您希望在合理的时间内得到答案，请选择一个小于`40`的数字）：
- en: '![](img/55b25999-812a-4621-aa47-3f9cf3dcda98.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55b25999-812a-4621-aa47-3f9cf3dcda98.png)'
- en: We asked you to enter a number less than `40`. Go ahead and enter a larger number,
    such as `50`, but go take a coffee break because this is going to take a while to
    calculate. Or, proceed on to reading the next section, where we will start to
    discuss the use of computationally intensive code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求您输入一个小于`40`的数字。继续输入一个更大的数字，比如`50`，但是请喝杯咖啡，因为这将需要一段时间来计算。或者，继续阅读下一节，我们将开始讨论使用计算密集型代码。
- en: Computationally intensive code and the Node.js event loop
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算密集型代码和Node.js事件循环
- en: This Fibonacci example is purposely inefficient to demonstrate an important
    consideration for your applications. What happens to the Node.js event loop when
    long computations are run? To see the effect, open two browser windows, each viewing
    the Fibonacci page. In one, enter the number `55` or greater, and in the other,
    enter `10`. Note how the second window freezes, and if you leave it running long
    enough, the answer will eventually pop up in both windows. What's happening in
    the Node.js event loop is blocked from processing events because the Fibonacci
    algorithm is running and does not ever yield to the event loop.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个斐波那契的例子故意效率低下，以演示应用程序的一个重要考虑因素。当长时间计算运行时，Node.js事件循环会发生什么？为了看到效果，打开两个浏览器窗口，每个窗口查看斐波那契页面。在一个窗口中，输入数字`55`或更大，而在另一个窗口中，输入`10`。注意第二个窗口会冻结，如果您让它运行足够长的时间，答案最终会在两个窗口中弹出。Node.js事件循环中发生的情况是，由于斐波那契算法正在运行并且从不让出事件循环，事件循环被阻塞无法处理事件。
- en: Since Node.js has a single execution thread, processing requests depends on
    request handlers quickly returning to the event loop. Normally, the asynchronous
    coding style ensures that the event loop executes regularly.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Node.js具有单个执行线程，处理请求取决于请求处理程序快速返回到事件循环。通常，异步编码风格确保事件循环定期执行。
- en: This is true even for requests that load data from a server halfway around the
    globe because the asynchronous request is non-blocking and control is quickly
    returned to the event loop. The naïve Fibonacci function we chose doesn't fit
    into this model because it's a long-running blocking operation. This type of event
    handler prevents the system from processing requests and stops Node.js from doing
    what it's meant to do—namely, to be a blisteringly fast web server.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是从地球的另一端加载数据的请求，也是如此，因为异步请求是非阻塞的，并且控制很快返回到事件循环。我们选择的天真的斐波那契函数不符合这个模型，因为它是一个长时间运行的阻塞操作。这种类型的事件处理程序会阻止系统处理请求，并阻止Node.js做它应该做的事情-即成为一个速度极快的Web服务器。
- en: In this case, the long-response-time problem is obvious. The response time to
    calculate a Fibonacci number quickly escalates to the point where you can take
    a vacation to Tibet, become a Lama, and perhaps get reincarnated as a llama in
    Peru in the time it takes to respond! However, it's also possible to create a
    long-response-time problem without it being as obvious as this one. Of the zillion-and-one
    asynchronous operations in a large web service, which one is both blocking and
    takes a long time to compute the result? Any blocking operations like this will
    cause a negative effect on the server throughput.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，长响应时间的问题是显而易见的。计算斐波那契数的响应时间迅速上升到您可以去西藏度假，成为喇嘛，也许在这段时间内转世为秘鲁的羊驼！然而，也有可能创建一个长响应时间的问题，而不像这个问题那么明显。在大型Web服务中的无数异步操作中，哪一个既是阻塞的又需要很长时间来计算结果？像这样的任何阻塞操作都会对服务器吞吐量产生负面影响。
- en: 'To see this more clearly, create a file named `fibotimes.js`, containing the
    following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地看到这一点，创建一个名为`fibotimes.js`的文件，其中包含以下代码：
- en: '[PRE30]js\1'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE30]js\1'
- en: This quickly calculates the first 40 or so members of the Fibonacci sequence,
    but after the 40^(th) member, it starts taking a couple of seconds per result
    and quickly degrades from there. It is untenable to execute code of this sort
    on a single-threaded system that relies on a quick return to the event loop. A
    web service containing code like this would give a poor performance to the users.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可以快速计算斐波那契数列的前40个成员，但是在第40个成员之后，每个结果开始花费几秒钟的时间，并且很快就会变得更糟。在依赖快速返回到事件循环的单线程系统上执行这种代码是不可行的。包含这种代码的Web服务会给用户带来糟糕的性能。
- en: 'There are two general ways to solve this problem in Node.js:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中有两种一般的方法来解决这个问题：
- en: '**Algorithmic refactoring**: Perhaps, like the Fibonacci function we chose,
    one of your algorithms is suboptimal and can be rewritten to be faster. Or, if
    it is not faster, it can be split into callbacks dispatched through the event
    loop. We''ll look at one method for this in a moment.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算法重构**：也许，就像我们选择的斐波那契函数一样，你的某个算法是次优的，可以重写为更快的。或者，如果不更快，它可以被拆分成通过事件循环分派的回调。我们马上就会看到其中一种方法。'
- en: '**Creating a backend service**: Can you imagine a backend server that is dedicated
    to calculating Fibonacci numbers? Okay, maybe not, but it''s quite common to implement
    backend servers to offload work from frontend servers, and we will implement a
    backend Fibonacci server at the end of this chapter.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建后端服务**：你能想象一个专门用于计算斐波那契数的后端服务器吗？好吧，也许不行，但实现后端服务器以卸载前端服务器的工作是非常常见的，我们将在本章末实现一个后端斐波那契服务器。'
- en: With that in mind, let's examine these possibilities.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们来看看这些可能性。
- en: Algorithmic refactoring
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法重构
- en: 'To prove that we have an artificial problem on our hands, here is a much more
    efficient Fibonacci function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明我们手头上有一个人为的问题，这里有一个更有效的斐波那契函数：
- en: '[PRE31]js\1'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE31]js\1'
- en: Sometimes, your performance problems will be this easy to optimize, but other
    times, they won't.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你的性能问题会很容易优化，但有时则不会。
- en: The discussion here isn't about optimizing mathematics libraries but about dealing
    with inefficient algorithms that affect event throughput in a Node.js server.
    For that reason, we will stick with the inefficient Fibonacci implementation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的讨论不是关于优化数学库，而是关于处理影响Node.js服务器事件吞吐量的低效算法。因此，我们将坚持使用低效的斐波那契实现。
- en: 'It is possible to divide the calculation into chunks and then dispatch the
    computation of those chunks through the event loop. Add the following code to
    `math.js`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '可以将计算分成块，然后通过事件循环分派这些块的计算。将以下代码添加到`math.js`中： '
- en: '[PRE32]js\1'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE32]js\1'
- en: We're back to an inefficient algorithm, but one where calculations are distributed
    through the event loop. Running this version of `fibotimes.js` demonstrates its
    inefficiency. To demonstrate it in the server, we need to make a few changes.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们又回到了一个低效的算法，但是其中的计算是通过事件循环分布的。运行这个`fibotimes.js`版本会展示它的低效性。为了在服务器中展示它，我们需要做一些改变。
- en: 'Because it''s an asynchronous function, we will need to change our router code.
    Create a new file, named `routes/fibonacci-async1.js`, containing the following
    code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它是一个异步函数，我们需要更改我们的路由器代码。创建一个名为`routes/fibonacci-async1.js`的新文件，其中包含以下代码：
- en: '[PRE33]js\1'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE33]js\1'
- en: With this change, the server no longer freezes when calculating a large Fibonacci
    number. The calculation, of course, still takes a long time, but at least other
    users of the application aren't blocked.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个改变，服务器在计算一个大的斐波那契数时不再冻结。当然，计算仍然需要很长时间，但至少应用程序的其他用户不会被阻塞。
- en: 'You can verify this by again opening two browser windows in the application.
    Enter `60` in one window, and in the other, start requesting smaller Fibonacci
    numbers. Unlike with the original `fibonacci` function, using `fibonacciAsync`
    allows both windows to give answers, although if you really did enter `60` in
    the first window, you might as well take that three-month vacation to Tibet:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过再次在应用程序中打开两个浏览器窗口来验证这一点。在一个窗口中输入`60`，在另一个窗口中开始请求较小的斐波那契数。与原始的`fibonacci`函数不同，使用`fibonacciAsync`允许两个窗口都给出答案，尽管如果您确实在第一个窗口中输入了`60`，那么您可能会去西藏度个三个月的假期：
- en: '![](img/08f9d3d1-d06b-4c79-8b9b-944cd2928f9d.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08f9d3d1-d06b-4c79-8b9b-944cd2928f9d.png)'
- en: It's up to you and your specific algorithms to choose how best to optimize your
    code and handle any long-running computations you may have.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 优化代码和处理可能存在的长时间运行的计算是由你和你的具体算法来选择的。
- en: We've created a simple Express application and demonstrated that there is a
    flaw that affects performance. We've also discussed algorithmic refactoring, which
    just leaves us to discuss how to implement a backend service. But first, we need
    to learn how to create and access a REST service.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的Express应用程序，并演示了一个影响性能的缺陷。我们还讨论了算法重构，这只剩下我们讨论如何实现后端服务了。但首先，我们需要学习如何创建和访问REST服务。
- en: Making HTTPClient requests
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行HTTPClient请求
- en: Another way to mitigate computationally intensive code is to push the calculation
    to a backend process. To explore that strategy, we'll request computations from
    a backend Fibonacci server, using the `HTTPClient` object to do so. However, before we
    look at that, let's first talk in general about using the `HTTPClient` object.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种缓解计算密集型代码的方法是将计算推送到后端进程。为了探索这种策略，我们将使用`HTTPClient`对象从后端斐波那契服务器请求计算。然而，在讨论这个之前，让我们先一般性地讨论一下使用`HTTPClient`对象。
- en: Node.js includes an `HTTPClient` object, which is useful for making HTTP requests.
    It has the capability to issue any kind of HTTP request. In this section, we'll
    use the `HTTPClient` object to make HTTP requests similar to calling a REST web
    service.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js包括一个`HTTPClient`对象，用于进行HTTP请求非常有用。它具有发出任何类型的HTTP请求的能力。在本节中，我们将使用`HTTPClient`对象来进行类似调用REST
    web服务的HTTP请求。
- en: 'Let''s start with some code inspired by the `wget` or `curl` commands to make
    HTTP requests and show the results. Create a file named `wget.js`, containing
    the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从受`wget`或`curl`命令启发的一些代码开始，以便进行HTTP请求并显示结果。创建一个名为`wget.js`的文件，其中包含以下代码：
- en: '[PRE34]js\1'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE34]js\1'
- en: Yes, `example.com` is a real website—visit it someday. There's more in the printout,
    namely the HTML of the page at `http://example.com/`. What we've done is demonstrated
    how to invoke an HTTP request using the `http.request` function.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，`example.com`是一个真实的网站——有一天去访问它。在打印输出中还有更多内容，即`http://example.com/`页面的HTML。我们所做的是演示如何使用`http.request`函数调用HTTP请求。
- en: 'The `options` object is fairly straightforward, with the `host`, `port`, and
    `path` fields specifying the URL that is requested. The `method` field must be
    one of the HTTP verbs (`GET`, `PUT`, `POST`, and so on). You can also provide
    a `headers` array for the headers in the HTTP request. For example, you might
    need to provide a cookie:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`options`对象非常简单，`host`、`port`和`path`字段指定了请求的URL。`method`字段必须是HTTP动词之一（`GET`、`PUT`、`POST`等）。你还可以为HTTP请求中的头部提供一个`headers`数组。例如，你可能需要提供一个cookie：'
- en: '[PRE35]js\1'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE35]js\1'
- en: This is a stripped-down Express application that gets right to the point of
    providing a Fibonacci calculation service. The one route it supports handles the
    Fibonacci computation using the same functions that we've already worked with.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化的Express应用程序，直接提供Fibonacci计算服务。它支持的一个路由使用了我们已经使用过的相同函数来处理Fibonacci计算。
- en: This is the first time we've seen `res.send` used. It's a flexible way to send
    responses that can take an array of header values (for the HTTP response header)
    and an HTTP status code. As used here, it automatically detects the object, formats
    it as JSON text, and sends it with the correct `Content-Type` parameter.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次看到`res.send`的使用。这是一种灵活的发送响应的方式，可以接受一个头部值的数组（用于HTTP响应头）和一个HTTP状态码。在这里使用时，它会自动检测对象，将其格式化为JSON文本，并使用正确的`Content-Type`参数发送它。
- en: 'In `package.json`, add the following to the `scripts` section:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`中，将以下内容添加到`scripts`部分：
- en: '[PRE36]js\1'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE36]js\1'
- en: 'Then, in a separate command window, we can use the `curl` program to make some
    requests against this service:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在一个单独的命令窗口中，我们可以使用`curl`程序对这个服务发出一些请求：
- en: '[PRE37]js\1'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE37]js\1'
- en: 'That''s easy—using `curl`, we can make HTTP `GET` requests. Now, let''s create
    a simple client program, `fiboclient.js`, to programmatically call the Fibonacci
    service:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单——使用`curl`，我们可以发出HTTP `GET`请求。现在，让我们创建一个简单的客户端程序`fiboclient.js`，以编程方式调用Fibonacci服务：
- en: '[PRE38]js\1'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE38]js\1'
- en: 'Then, run the `client` app:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行`client`应用程序：
- en: '[PRE39]js\1'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE39]js\1'
- en: This is a new variant of the Fibonacci route handler, this time calling the
    REST backend service. We've transplanted the `http.request` call from `fiboclient.js` and
    integrated the events coming from the `client` object with the Express route handler.
    In the normal path of execution, the `HTTPClient` issues a `response` event, containing
    a `response` object. When that object issues a `data` event, we have our result.
    The result is JSON text, which we can parse and then return to the browser as
    the response to its request.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Fibonacci路由处理程序的一个新变体，这次调用REST后端服务。我们将`fiboclient.js`中的`http.request`调用移植过来，并将来自`client`对象的事件与Express路由处理程序集成。在正常的执行路径中，`HTTPClient`发出一个`response`事件，包含一个`response`对象。当该对象发出一个`data`事件时，我们就有了结果。结果是JSON文本，我们可以解析然后作为响应返回给浏览器。
- en: 'In `app.js`, make the following change:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.js`中，进行以下更改：
- en: '[PRE40]js\1'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE40]js\1'
- en: How can we have the same value for `SERVERPORT` for all three `scripts` entries?
    The answer is that the variable is used differently in different places. In `startrest`,
    this variable is used in `routes/fibonacci-rest.js` to know at which port the
    REST service is running. Likewise, in `client`, `fiboclient.js` uses this variable
    for the same purpose. Finally, in `server`, the `fiboserver.js` script uses the
    `SERVERPORT` variable to know which port to listen on.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何为所有三个`scripts`条目设置相同的`SERVERPORT`值？答案是该变量在不同的地方使用方式不同。在`startrest`中，该变量用于`routes/fibonacci-rest.js`中，以知道REST服务运行在哪个端口。同样，在`client`中，`fiboclient.js`使用该变量来达到相同的目的。最后，在`server`中，`fiboserver.js`脚本使用`SERVERPORT`变量来知道要监听哪个端口。
- en: In `start` and `startrest`, no value is given for `PORT`. In both cases, `bin/www`
    defaults to `PORT=3000` if a value is not specified.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在`start`和`startrest`中，没有为`PORT`指定值。在这两种情况下，如果没有指定值，`bin/www`默认为`PORT=3000`。
- en: 'In a command window, start the backend server, and in another, start the application.
    Open a browser window, as before, and make a few requests. You should see an output
    similar to the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令窗口中，启动后端服务器，在另一个窗口中，启动应用程序。像之前一样，打开一个浏览器窗口，并发出一些请求。你应该会看到类似以下的输出：
- en: '[PRE41]js\1'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE41]js\1'
- en: Because we haven't changed the templates, the screen will look exactly as it
    did earlier.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有改变模板，所以屏幕看起来和之前一样。
- en: 'We may run into another problem with this solution. The asynchronous implementation
    of our inefficient Fibonacci algorithm may cause the Fibonacci service process
    to run out of memory. In the Node.js FAQs, [https://github.com/nodejs/node/wiki/FAQ](https://github.com/nodejs/node/wiki/FAQ),
    it''s suggested to use the `--max_old_space_size` flag. You''d add this to `package.json`,
    as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会在这个解决方案中遇到另一个问题。我们低效的Fibonacci算法的异步实现可能会导致Fibonacci服务进程耗尽内存。在Node.js的FAQ中，[https://github.com/nodejs/node/wiki/FAQ](https://github.com/nodejs/node/wiki/FAQ)，建议使用`--max_old_space_size`标志。你可以将这个标志添加到`package.json`中，如下所示：
- en: '```js\1'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '```js\1'
- en: However, the FAQs also say that if you're running into maximum memory space
    problems, your application should probably be refactored. This goes back to the
    point we made earlier that there are several approaches to addressing performance
    problems, one of which is the algorithmic refactoring of your application.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，FAQ中还说，如果你遇到最大内存空间问题，你的应用程序可能需要重构。这回到了我们之前提到的一点，解决性能问题有几种方法，其中之一是对应用程序进行算法重构。
- en: Why go through the trouble of developing this REST server when we could just
    directly use `fibonacciAsync`?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要费力开发这个REST服务器，而不直接使用`fibonacciAsync`呢？
- en: The main advantage is the ability to push the CPU load for this heavyweight
    calculation to a separate server. Doing so preserves the CPU capacity on the frontend
    server so that it can attend to the web browsers. GPU coprocessors are now widely
    used for numerical computing and can be accessed via a simple network API. The
    heavy computation can be kept separate, and you can even deploy a cluster of backend
    servers sitting behind a load balancer, evenly distributing requests. Decisions
    such as this are made all the time to create multi-tier systems.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 主要优势是将这种繁重计算的CPU负载推送到一个单独的服务器上。这样做可以保留前端服务器的CPU容量，以便它可以处理Web浏览器。 GPU协处理器现在广泛用于数值计算，并且可以通过简单的网络API访问。重计算可以保持分离，甚至可以部署一个位于负载均衡器后面的后端服务器集群，均匀分发请求。这样的决策一直在不断地制定，以创建多层系统。
- en: What we've demonstrated is that it's possible to implement simple multi-tier
    REST services in a few lines of Node.js and Express. This whole exercise gave
    us a chance to think about computationally intensive code in Node.js and the value
    of splitting a larger service into multiple services.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所展示的是，在几行Node.js和Express代码中实现简单的多层REST服务是可能的。整个练习让我们有机会思考在Node.js中实现计算密集型代码的价值，以及将一个较大的服务拆分成多个服务的价值。
- en: Of course, Express isn't the only framework that can help us create REST services.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Express并不是唯一可以帮助我们创建REST服务的框架。
- en: Some RESTful modules and frameworks
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些RESTful模块和框架
- en: 'Here are a few available packages and frameworks to assist your REST-based
    projects:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可用的包和框架，可以帮助您的基于REST的项目：
- en: '**Restify** ([>http://restify.com/](http://restify.com/)): This offers both
    client-side and server-side frameworks for both ends of REST transactions. The
    server-side API is similar to Express.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Restify** ([>http://restify.com/](http://restify.com/))：这为REST事务的两端提供了客户端和服务器端框架。服务器端API类似于Express。'
- en: '**Loopback** ([http://loopback.io/](http://loopback.io/)): This is an offering
    from StrongLoop. It offers a lot of features and is, of course, built on top of
    Express.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Loopback** ([http://loopback.io/](http://loopback.io/))：这是StrongLoop提供的一个产品。它提供了许多功能，并且当然是建立在Express之上的。'
- en: In this section, we've done a big thing in creating a backend REST service.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们在创建后端REST服务方面取得了很大的成就。
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You learned a lot in this chapter about Node.js's `EventEmitter` pattern, `HTTPClient`,
    and server objects, at least two ways to create an HTTP service, how to implement
    web applications, and even how to create a REST client and REST service integrated
    into a customer-facing web application. Along the way, we again explored the risks
    of blocking operations, the importance of keeping the event loop running, and
    a couple of ways to distribute work across multiple services.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学到了很多关于Node.js的`EventEmitter`模式、`HTTPClient`和服务器对象，至少有两种创建HTTP服务的方法，如何实现Web应用程序，甚至如何创建一个REST客户端和REST服务集成到面向客户的Web应用程序中。在这个过程中，我们再次探讨了阻塞操作的风险，保持事件循环运行的重要性，以及在多个服务之间分发工作的几种方法。
- en: 'Now, we can move on to implementing a more complete application: one for taking
    notes. We will use the `Notes` application in several upcoming chapters as a vehicle
    to explore the Express application framework, database access, deployment to cloud
    services or on your own server, user authentication, semi-real-time communication
    between users, and even hardening an application against several kinds of attacks.
    We''ll end up with an application that can be deployed to cloud infrastructure.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续实现一个更完整的应用程序：一个用于记笔记的应用程序。在接下来的几章中，我们将使用`Notes`应用程序作为一个工具来探索Express应用程序框架、数据库访问、部署到云服务或您自己的服务器、用户身份验证、用户之间的半实时通信，甚至加强应用程序对多种攻击的防御。最终，我们将得到一个可以部署到云基础设施的应用程序。
- en: There's still a lot to cover in this book, and it starts in the next chapter
    with creating a basic Express application.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书还有很多内容要涵盖，下一章将从创建一个基本的Express应用程序开始。

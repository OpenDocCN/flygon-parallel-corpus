- en: Chapter 3. Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。函数
- en: 'Mastering functions is an important skill when you learn any programming language,
    and even more so when it comes to JavaScript. This is because JavaScript has many
    uses for functions, and much of the language''s flexibility and expressiveness
    comes from them. Where most programming languages have a special syntax for some
    object-oriented features, JavaScript just uses functions. This chapter will cover
    the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握函数是学习任何编程语言时的重要技能，尤其是在学习JavaScript时更是如此。这是因为JavaScript对函数有许多用途，语言的灵活性和表现力大部分来自于函数。大多数编程语言对于一些面向对象的特性都有特殊的语法，而JavaScript只使用函数。本章将涵盖以下主题：
- en: How to define and use a function
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何定义和使用函数
- en: Passing arguments to a function
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向函数传递参数
- en: Predefined functions that are available to you for free
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以免费使用的预定义函数
- en: The scope of variables in JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript中变量的作用域
- en: The concept that functions are just data, albeit a special type of data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数只是数据的概念，尽管是一种特殊类型的数据
- en: 'Understanding these topics will provide a solid base that will allow you to
    dive into the second part of the chapter, which shows some interesting applications
    of functions, as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些主题将为您提供一个坚实的基础，使您能够深入本章的第二部分，其中展示了一些有趣的函数应用，如下所示：
- en: Using anonymous functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用匿名函数
- en: Callbacks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调
- en: Immediate (self-invoking) functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即（自调用）函数
- en: Inner functions (functions defined inside other functions)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部函数（在其他函数内定义的函数）
- en: Functions that return functions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回函数的函数
- en: Functions that redefine themselves
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新定义自己的函数
- en: Closures
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: What is a function?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是函数？
- en: 'Functions allow you to group together a code, give it a name, and reuse it
    later, addressing it by the name you gave it. Let''s consider the following code
    as an example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 函数允许您将代码组合在一起，给它一个名称，并在以后重复使用，通过您给它的名称进行调用。让我们考虑以下代码作为示例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The parts that make up a function are shown as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 组成函数的部分如下所示：
- en: The `function` keyword.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function`关键字。'
- en: The name of the function; in this case, `sum`.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的名称；在这种情况下是`sum`。
- en: The function parameters; in this case, `a` and `b`. A function can take any
    number of parameters, or no parameters, separated by commas.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数；在这种情况下是`a`和`b`。函数可以接受任意数量的参数，或者没有参数，用逗号分隔。
- en: A code block, also called the body of the function.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码块，也称为函数的主体。
- en: The `return` statement. A function always returns a value. If it doesn't return
    a value explicitly, it implicitly returns the value `undefined`.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return`语句。函数总是返回一个值。如果它没有显式返回一个值，它将隐式返回值`undefined`。'
- en: Note that a function can only return a single value. If you need to return more
    values, you can simply return an array that contains all of the values you need
    as elements of this array.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，函数只能返回单个值。如果需要返回更多值，您可以简单地返回一个包含您需要的所有值的数组作为此数组的元素。
- en: The preceding syntax is called a function declaration. It's just one of the
    ways to create a function in JavaScript, and more ways are coming up.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语法称为函数声明。这只是在JavaScript中创建函数的一种方式，还有更多的方式即将出现。
- en: Calling a function
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用函数
- en: In order to make use of a function, you will need to call it. You can call a
    function simply using its name, optionally, followed by any number of values in
    parentheses. To invoke a function is another way of saying to call.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用函数，您需要调用它。您可以简单地使用函数的名称调用函数，可选地在括号中跟随任意数量的值。调用函数是另一种说法是调用。
- en: 'Let''s call the `sum()`function, passing two arguments and assigning the value
    that the function returns to the variable `result`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用`sum()`函数，传递两个参数，并将函数返回的值赋给变量`result`：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Parameters
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数
- en: 'When defining a function, you can specify what parameters the function expects
    to receive when it''s called. A function may not require any parameters, but if
    it does, and you forget to pass them, JavaScript will assign the `undefined` value
    to the ones you skipped. In the next example, the function call returns `NaN`
    because it tries to sum `1` and `undefined`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义函数时，您可以指定函数在调用时期望接收的参数。函数可能不需要任何参数，但如果需要，并且您忘记传递它们，JavaScript将为您跳过的参数分配`undefined`值。在下一个示例中，函数调用返回`NaN`，因为它尝试对`1`和`undefined`进行求和：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Technically speaking, there is a difference between parameters and arguments,
    although the two are often used interchangeably. Parameters are defined together
    with the function, while arguments are passed to the function when it''s called.
    Consider the following example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，参数和参数之间有区别，尽管两者经常可以互换使用。参数与函数一起定义，而参数在调用函数时传递给函数。考虑以下示例：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `a` and `b` are parameters, while `1` and `2` are arguments.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`a`和`b`是参数，而`1`和`2`是参数。
- en: 'JavaScript is not picky at all when it comes to accepting arguments. If you
    pass more than the function expects, the extra ones will be silently ignored,
    as shown in the following example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及接受参数时，JavaScript并不挑剔。如果您传递的参数多于函数所期望的，额外的参数将被静默忽略，如下例所示：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What''s more, you can create functions that are flexible about the number of
    parameters they accept. This is possible thanks to the special value `arguments`
    that are created automatically inside each function. Here''s a function that simply
    returns whatever arguments are passed to it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以创建接受参数数量灵活的函数。这是由于在每个函数内部自动创建的特殊值`arguments`。以下是一个简单返回传递给它的任何参数的函数：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using `arguments`, you can improve the `sum()` function to accept any number
    of arguments and add them all up, as shown in the following example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`arguments`，您可以改进`sum()`函数以接受任意数量的参数并将它们全部相加，如下例所示：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you test this function by calling it with a different number of arguments,
    or even none at all, you can verify that it works as expected, as you can see
    in the following example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过使用不同数量的参数或甚至根本不使用参数来调用此函数进行测试，您可以验证它是否按预期工作，如下例所示：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `arguments.length` expression returns the number of arguments passed when
    the function was called. Don't worry if the syntax is unfamiliar, we'll examine
    it in detail in the next chapter. You'll also see that `arguments` is not an array
    (although it sure looks like one), but an array-like object.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments.length`表达式返回函数调用时传递的参数数量。如果语法不熟悉，不用担心，我们将在下一章节详细讨论。您还会看到`arguments`不是一个数组（尽管看起来像），而是一个类似数组的对象。'
- en: ES6 introduces several important improvements around function parameters. ES6
    function parameters can now have default values, rest parameters, and allows destructuring.
    The next section discusses each of these concepts in detail.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ES6在函数参数周围引入了几个重要的改进。ES6函数参数现在可以有默认值、剩余参数，并允许解构。下一节将详细讨论这些概念。
- en: Default parameters
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认参数
- en: 'Function parameters can be assigned default values. While calling the function,
    if a parameter is omitted, the default value assigned to the parameter is used:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数可以分配默认值。在调用函数时，如果省略了参数，则使用分配给参数的默认值：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, we are omitting the `spark_level` parameter, and hence the
    default value assigned to the parameter is used. It is important to note that
    `undefined` is considered as an absence of parameter value; consider the following
    line of code, for example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们省略了`spark_level`参数，因此使用了分配给参数的默认值。重要的是要注意`undefined`被视为参数值的缺失；例如考虑以下代码行：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'While providing default values of parameters, it is possible to refer to other
    parameters as well:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供参数的默认值时，也可以引用其他参数：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Default parameters have their own scope; this scope is sandwiched between the
    outer function scope and the inner scope of the function. If the parameter is
    shadowed by a variable in inner scope, surprisingly, the inner variable is not
    available. The following example will help explain this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数有它们自己的作用域；这个作用域夹在外部函数作用域和函数内部作用域之间。如果参数被内部作用域中的变量遮蔽，令人惊讶的是，内部变量是不可用的。下面的例子将有助于解释这一点：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You may expect `val` to get shadowed by the inner definition of the `scope`
    variable, but as the default parameters have their own scope, the value assigned
    to `val` is unaffected by the inner scope.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能期望`val`被内部定义的`scope`变量所遮蔽，但是由于默认参数有它们自己的作用域，所以赋给`val`的值不受内部作用域的影响。
- en: Rest parameters
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剩余参数
- en: 'ES6 introduces rest parameters. Rest parameters allow us to send an arbitrary
    number of parameters to a function in the form of an array. Rest parameter can
    only be the last one in the list of parameters, and there can only be one rest
    parameter. Putting a rest operator(`...`) before the last formal parameter indicates
    that parameter is a rest parameter. The following example shows adding a rest
    operator before the last formal parameter:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ES6引入了剩余参数。剩余参数允许我们以数组的形式向函数发送任意数量的参数。剩余参数只能是参数列表中的最后一个，并且只能有一个剩余参数。在最后一个形式参数之前放置一个剩余运算符(`...`)表示该参数是一个剩余参数。以下示例显示在最后一个形式参数之前添加一个剩余运算符：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first parameter passed to the function is received in `tone`, while the
    rest of the parameters are received as an array. Variable arguments (var-args)
    have been part of several other languages and a welcome edition to ES6\. Rest
    parameters can replace the slightly controversial `arguments` variable. The major
    difference between rest parameters and the `arguments` variable is that the rest
    parameters are real arrays. All array methods are available to rest parameters.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给函数的第一个参数在`tone`中接收，而其余的参数作为数组接收。可变参数（var-args）已经成为其他几种语言的一部分，并且是ES6的一个受欢迎的新增功能。剩余参数可以替代略有争议的`arguments`变量。剩余参数和`arguments`变量之间的主要区别在于剩余参数是真正的数组。所有数组方法都适用于剩余参数。
- en: Spread operators
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展开运算符
- en: 'A spread operator looks exactly like a rest operator but performs the exact
    opposite function. Spread operators are used while providing arguments while calling
    a function or defining an array. The spread operator takes an array and splits
    its element into individual variables. The following example illustrates how the
    spread operator provides a much clearer syntax while calling functions that take
    an array as an argument:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 展开运算符看起来与剩余运算符完全相同，但执行相反的功能。在调用函数或定义数组时，展开运算符用于提供参数。展开运算符接受一个数组并将其元素分割成单独的变量。以下示例说明了展开运算符在调用以数组作为参数的函数时提供了更清晰的语法：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In ES5, it is common to use the `apply()` function when passing an array as
    an argument to a function. In the preceding example, we have an array we need
    to pass to a function where the function accepts three variables. The ES5 method
    of passing an array to this function uses the `apply()` function, where the second
    argument allows an array to be passed to the function being called. ES6 spread
    operators give a much cleaner and precise way to deal with this situation. While
    calling `sumAll()`, we use the spread operator(`...`) and pass the `numbers` array
    to the function call. The array is then split into individual variables-`a`, `b`,
    and `c`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES5中，当将数组作为参数传递给函数时，通常使用`apply()`函数。在前面的例子中，我们有一个数组需要传递给一个函数，而函数接受三个变量。将数组传递给这个函数的ES5方法使用`apply()`函数，第二个参数允许将数组传递给被调用的函数。ES6的展开运算符提供了一种更清晰和精确处理这种情况的方法。在调用`sumAll()`时，我们使用展开运算符(`...`)并将`numbers`数组传递给函数调用。然后数组被分割成单独的变量-`a`、`b`和`c`。
- en: 'Spread operators improve the capabilities of arrays in JavaScript. If you want
    to create an array that is made up of another array, the existing array syntax
    does not support this. You have to use `push`, `splice`, and `concat` to achieve
    this. However, using spread operators, this becomes trivial:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 展开运算符提高了JavaScript中数组的功能。如果要创建由另一个数组组成的数组，则现有的数组语法不支持这一点。您必须使用`push`、`splice`和`concat`来实现这一点。然而，使用展开运算符，这变得微不足道：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding example, we are constructing a `week` array using two arrays,
    `midweek` and `weekend`, using the spread operator.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们使用两个数组`midweek`和`weekend`，使用扩展运算符构造了一个`week`数组。
- en: Predefined functions
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预定义函数
- en: 'There are a number of functions that are built into the JavaScript engine and
    are available for you to use. Let''s take a look at them. While doing so, you''ll
    have a chance to experiment with functions, their arguments and return values,
    and become comfortable working with functions. The following is a list of the
    built-in functions:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript引擎中内置了许多函数，供您使用。让我们来看看它们。在这样做的过程中，您将有机会尝试使用函数、它们的参数和返回值，并且变得熟悉使用函数。以下是内置函数的列表：
- en: parseInt()
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: parseInt()
- en: parseFloat()
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: parseFloat()
- en: isNaN()
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: isNaN()
- en: isFinite()
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: isFinite()
- en: encodeURI()
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: encodeURI()
- en: decodeURI()
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: decodeURI()
- en: encodeURIComponent()
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: encodeURIComponent()
- en: decodeURIComponent()
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: decodeURIComponent()
- en: eval()
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: eval()
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**The black box function**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑匣子函数**'
- en: Often, when you invoke functions, your program doesn't need to know how these
    functions work internally. You can think of a function as a black box, give it
    some values (as input arguments), and then take the output result it returns.
    This is true for any function-one that's built into the JavaScript engine, one
    that you create, or one that a co-worker or someone else created.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当您调用函数时，您的程序不需要知道这些函数在内部是如何工作的。您可以将函数视为一个黑匣子，给它一些值（作为输入参数），然后获取它返回的输出结果。这对于任何函数都是正确的-无论是内置在JavaScript引擎中的函数，您创建的函数，还是同事或其他人创建的函数。
- en: parseInt()
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: parseInt()
- en: 'The `parseInt()` function takes any type of input (most often a string) and
    tries to make an integer out of it. If it fails, it returns `NaN`, as shown in
    the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseInt()`函数接受任何类型的输入（通常是字符串）并尝试将其转换为整数。如果失败，它将返回`NaN`，如下面的代码所示：'
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The function accepts an optional second parameter, which is the radix, telling
    the function what type of number to expect-decimal, hexadecimal, binary, and so
    on. For example, trying to extract a decimal number out of the `FF` string makes
    no sense, so the result is `NaN`, but if you try `FF` as a hexadecimal, then you
    get `255`, as shown in the following piece of code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个可选的第二个参数，即基数，告诉函数期望的数字类型-十进制、十六进制、二进制等。例如，尝试从字符串`FF`中提取一个十进制数是没有意义的，因此结果是`NaN`，但如果您尝试将`FF`作为十六进制，则会得到`255`，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Another example would be parsing a string with a base `10` (decimal) and base
    `8` (octal):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是解析带有基数`10`（十进制）和基数`8`（八进制）的字符串：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you omit the second argument when calling `parseInt()`, the function will
    assume `10` (a decimal), with the following exceptions:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调用`parseInt()`时省略第二个参数，函数将假定`10`（十进制），以下是一些例外情况：
- en: If you pass a string beginning with `0x`, then the radix is assumed to be `16`
    (a hexadecimal number is assumed).
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您传递以`0x`开头的字符串，则假定基数为`16`（假定为十六进制数）。
- en: 'If the string you pass starts with `0`, the function assumes radix `8` (an
    octal number is assumed). Consider the following examples:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您传递的字符串以`0`开头，函数会假定基数为`8`（假定为八进制数）。请考虑以下示例：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The safest thing to do is to always specify the radix. If you omit the radix,
    your code will probably still work in 99 percent of cases (because most often
    you parse decimals); however, every once in a while, it might cause you a bit
    of hair loss while debugging some edge cases. For example, imagine you have a
    form field that accepts calendar days or months and the user types `06` or `08`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最安全的做法是始终指定基数。如果省略基数，您的代码在99%的情况下可能仍然有效（因为大多数情况下您解析十进制数）；然而，偶尔可能会在调试一些边缘情况时导致您有点头发丢失。例如，想象一下，您有一个表单字段接受日历天数或月份，用户输入`06`或`08`。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: ECMAScript 5 removes the octal literal values and avoids the confusion with
    `parseInt()` and unspecified radix.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 5删除了八进制文字值，并避免了与`parseInt()`和未指定基数的混淆。
- en: parseFloat()
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: parseFloat()
- en: 'The `parseFloat()` function is similar to the `parseInt()` function, but it
    also looks for decimals when trying to figure out a number from your input. This
    function takes only one parameter, which is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseFloat()`函数类似于`parseInt()`函数，但在尝试从输入中找出数字时，它还会寻找小数。该函数只接受一个参数，如下所示：'
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As with `parseInt()`, `parseFloat()` gives up at the first occurrence of an
    unexpected character, even though the rest of the string might have usable numbers
    in it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与`parseInt()`一样，`parseFloat()`在遇到意外字符的第一次出现时就会放弃，即使字符串的其余部分可能包含可用的数字：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `parseFloat()` function understands exponents in the input (unlike `parseInt()`):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseFloat()`函数理解输入中的指数（与`parseInt()`不同）：'
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: isNaN()
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: isNaN()
- en: 'Using `isNaN()`, you can check if an input value is a valid number that can
    safely be used in arithmetic operations. This function is also a convenient way
    to check whether `parseInt()`, `parseFloat()`, or any arithmetic operation succeeded:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`isNaN()`，您可以检查输入值是否是一个有效的数字，可以安全地用于算术运算。这个函数也是一个方便的方法来检查`parseInt()`，`parseFloat()`或任何算术操作是否成功：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The function will also try to convert the input to a number:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数还将尝试将输入转换为数字：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `isNaN()` function is useful because the special value `NaN` is not equal
    to anything, including itself. In other words, `NaN === NaN` is `false`. So, `NaN`
    cannot be used to check if a value is a valid number.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`isNaN()`函数很有用，因为特殊值`NaN`与任何东西都不相等，包括它自己。换句话说，`NaN === NaN`是`false`。因此，`NaN`不能用来检查一个值是否是有效的数字。'
- en: isFinite()
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: isFinite()
- en: 'The `isFinite()` function checks whether the input is a number that is neither
    `Infinity` nor `NaN`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`isFinite()`函数检查输入是否是既不是`Infinity`也不是`NaN`的数字：'
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you are wondering about the results returned by the last two calls, remember
    from the previous chapter that the biggest number in JavaScript is `1.7976931348623157e+308`,
    so `1e309` is effectively infinity.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对最后两个调用返回的结果感到困惑，请记住前一章中提到的JavaScript中最大的数字是`1.7976931348623157e+308`，因此`1e309`实际上是无穷大。
- en: Encode/decode URIs
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编码/解码URI
- en: 'In a **Uniform Resource Locator** (**URL**) or a **Uniform Resource Identifier**
    (**URI**), some characters have special meanings. If you want to escape those
    characters, you can use the `encodeURI()` or `encodeURIComponent()`functions.
    The first one will return a usable URL, while the second one assumes you''re only
    passing a part of the URL, such as a query string for example, and will encode
    all applicable characters, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在**统一资源定位符**（**URL**）或**统一资源标识符**（**URI**）中，一些字符具有特殊含义。如果你想转义这些字符，你可以使用`encodeURI()`或`encodeURIComponent()`函数。第一个函数将返回一个可用的URL，而第二个函数假定你只传递了URL的一部分，比如一个查询字符串，它将编码所有适用的字符，如下所示：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The opposites of `encodeURI()` and `encodeURIComponent()` are `decodeURI()`
    and `decodeURIComponent()`, respectively.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`encodeURI()`和`encodeURIComponent()`的相反函数分别是`decodeURI()`和`decodeURIComponent()`。'
- en: Sometimes, in legacy code, you might see the functions `escape()` and `unescape()`
    used to encode and decode URLs, but these functions have been deprecated; they
    encode differently and should not be used.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在旧代码中，你可能会看到`escape()`和`unescape()`函数用于编码和解码URL，但这些函数已经被弃用；它们进行编码的方式不同，不应该使用。
- en: eval()
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: eval()
- en: 'The `eval()` function takes a string input and executes it as a JavaScript
    code, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval()`函数接受一个字符串输入并将其作为JavaScript代码执行，如下所示：'
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So, `eval('var ii = 2;')` is the same as `var ii = 2;`
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`eval('var ii = 2;')`等同于`var ii = 2;`
- en: 'The `eval()` function can be useful sometimes, but it should be avoided if
    there are other options. Most of the time, there are alternatives, and in most
    cases, the alternatives are more elegant and easier to write and maintain. *Eval
    is evil* is a mantra you can often hear from seasoned JavaScript programmers.
    The drawbacks of using `eval()` are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval()`函数有时可能会有用，但如果有其他选择，应该避免使用它。大多数情况下，都有替代方案，而且在大多数情况下，这些替代方案更加优雅、更容易编写和维护。*Eval
    is evil*是一个你经常会听到有经验的JavaScript程序员说的口头禅。使用`eval()`的缺点如下：'
- en: '**Security**: JavaScript is powerful, which also means it can cause damage.
    If you don''t trust the source of the input you pass to `eval()`, just don''t
    use it.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：JavaScript很强大，这也意味着它可能会造成损害。如果你不信任传递给`eval()`的输入源，就不要使用它。'
- en: '**Performance**: It''s slower to evaluate live code than to have the code directly
    in the script.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：评估实时代码比直接在脚本中编写代码要慢。'
- en: A bonus - the alert() function
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个奖励 - alert()函数
- en: Let's take a look at another common function-`alert()`. It's not part of the
    core JavaScript (it's nowhere to be found in the ECMA specification), but it's
    provided by the host environment-the browser. It shows a string of text in a message
    box. It can also be used as a primitive debugging tool, although the debuggers
    in modern browsers are much better suited for this purpose.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个常见的函数-`alert()`。它不是核心JavaScript的一部分（在ECMA规范中找不到它），但它是由宿主环境-浏览器提供的。它在消息框中显示一串文本。它也可以作为一个原始的调试工具，尽管现代浏览器中的调试器更适合这个目的。
- en: 'Here''s a screenshot showing the result of executing the `alert("Hi There")`
    code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一张截图显示了执行`alert("Hi There")`代码的结果：
- en: '![A bonus - the alert() function](graphics/alert-e1483529706612.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![一个奖励 - alert()函数](graphics/alert-e1483529706612.jpg)'
- en: Before using this function, bear in mind that it blocks the browser thread,
    meaning that no other code will be executed until the user closes the alert. If
    you have a busy Ajax-type application, it's generally not a good idea to use `alert()`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这个函数之前，请记住它会阻塞浏览器线程，这意味着在用户关闭警告框之前不会执行其他代码。如果你有一个繁忙的Ajax类型应用程序，通常不建议使用`alert()`。
- en: Scope of variables
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量的作用域
- en: It's important to note, especially if you have come to JavaScript from another
    language, that variables in JavaScript are not defined in a block scope, but in
    a function scope. This means that if a variable is defined inside a function,
    it's not visible outside of the function. However, if it's defined inside an `if`
    or a `for` code block, it's visible outside the block. The term global variables
    describes variables you define outside of any function (in the global program
    code), as opposed to local variables, which are defined inside a function. The
    code inside a function has access to all global variables as well as to its own
    local ones.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 特别要注意的是，如果你从其他语言转到JavaScript，JavaScript中的变量不是在块作用域中定义的，而是在函数作用域中定义的。这意味着如果一个变量在函数内部定义，它在函数外部是不可见的。但是，如果它在`if`或`for`代码块中定义，它在块外是可见的。全局变量这个术语描述了你在任何函数之外定义的变量（在全局程序代码中），与局部变量相对，局部变量是在函数内部定义的。函数内部的代码可以访问所有全局变量以及它自己的局部变量。
- en: 'In the next example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中：
- en: The `f()`function has access to the `global` variable
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f()`函数可以访问`global`变量'
- en: Outside the `f()`function, the `local` variable doesn't exist
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`f()`函数外部，`local`变量不存在
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s test this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It''s also important to note that if you don''t use `var` to declare a variable,
    this variable is automatically assigned a global scope. Let''s see an example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，如果你不使用`var`来声明一个变量，这个变量会自动分配一个全局作用域。让我们看一个例子：
- en: '![Scope of variables](graphics/image_03_001-e1482742379131.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![变量的作用域](graphics/image_03_001-e1482742379131.jpg)'
- en: What happened? The `f()`function contains the `local` variable. Before calling
    the function, the variable doesn't exist. When you call the function for the first
    time, the `local` variable is created with a global scope. Then, if you access
    the `local` variable outside the function, it will be available.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？`f()`函数包含`local`变量。在调用函数之前，这个变量是不存在的。当你第一次调用函数时，`local`变量会被创建为全局作用域。然后，如果你在函数外部访问`local`变量，它将是可用的。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Best practice tips**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践提示**'
- en: Minimize the number of global variables in order to avoid naming collisions.
    Imagine two people working on two different functions in the same script, and
    they both decide to use the same name for their global variable. This could easily
    lead to unexpected results and hard-to-find bugs. Always declare your variables
    with the `var` statement. Consider a single `var` pattern. Define all variables
    needed in your function at the very top of the function so you have a single place
    to look for variables and, hopefully, prevent accidental globals.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 减少全局变量的数量以避免命名冲突。想象两个人在同一个脚本中工作的两个不同函数中工作，他们都决定使用相同的名称作为他们的全局变量。这很容易导致意外的结果和难以找到的错误。始终使用`var`语句声明变量。考虑使用单一`var`模式。在函数中定义所需的所有变量，这样你就有一个地方可以查找变量，希望可以防止意外的全局变量。
- en: Variable hoisting
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量提升
- en: 'Here''s an interesting example that shows an important aspect of local versus
    global scoping:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个有趣的例子，展示了本地作用域与全局作用域的一个重要方面：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You might expect that the first `alert()` function will display `123` (the value
    of the global variable `a`) and the second will display `1` (the local variable
    `a`). But, this is not the case. The first alert will show `undefined`. This is
    because, inside the function, the local scope is more important than the global
    scope. So, a local variable overwrites any global variable with the same name.
    At the time of the first `alert()`, the `a` variable was not yet defined (hence
    the `undefined` value), but it still existed in the local space due to the special
    behavior called **hoisting**.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能期望第一个`alert()`函数将显示`123`（全局变量`a`的值），第二个将显示`1`（局部变量`a`）。但是，情况并非如此。第一个警报将显示`undefined`。这是因为，在函数内部，局部作用域比全局作用域更重要。因此，局部变量会覆盖同名的全局变量。在第一个`alert()`时，`a`变量尚未定义（因此为`undefined`值），但它仍然存在于局部空间中，这是由于称为**提升**的特殊行为。
- en: 'When your JavaScript program execution enters a new function, all the variables
    declared anywhere in the function are moved, elevated, or hoisted to the top of
    the function. This is an important concept to keep in mind. Further, only the
    declaration is hoisted, meaning only the presence of the variable is moved to
    the top. Any assignments stay where they are. In the preceding example, the declaration
    of the local variable `a` was hoisted to the top. Only the declaration was hoisted,
    but not the assignment to `1`. It''s as if the function was written in the following
    way:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当JavaScript程序执行进入新函数时，函数中任何地方声明的所有变量都会被移动、提升或提升到函数顶部。这是一个重要的概念要记住。此外，只有声明被提升，意味着只有变量的存在被移动到顶部。任何赋值保持原样。在前面的例子中，局部变量`a`的声明被提升到顶部。只有声明被提升，而不是对`1`的赋值。就好像函数是这样写的：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can also adopt the single var pattern mentioned previously in the best practice
    section. In this case, you'll be doing a sort of manual variable hoisting to prevent
    confusion with the JavaScript hoisting behavior.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以采用之前提到的最佳实践部分的单一var模式。在这种情况下，你将进行一种手动的变量提升，以防止与JavaScript提升行为混淆。
- en: Block scope
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块作用域
- en: ES6 provides additional scope while declaring variables. We looked at function
    scope and how it affects variables declared with the `var` keyword. If you are
    coding in ES6, block scope will mostly replace your need to use variables declared
    using `var`. Although, if you are still with ES5, we want you to make sure that
    you look at hoisting behavior carefully.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ES6在声明变量时提供了额外的作用域。我们看了函数作用域以及它对使用`var`关键字声明的变量的影响。如果你在ES6中编码，块作用域将大多取代你使用`var`声明变量的需求。虽然，如果你仍在使用ES5，我们希望你确保仔细观察变量提升的行为。
- en: ES6 introduces the `let` and `const` keywords that allow us to declare variables.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ES6引入了`let`和`const`关键字，允许我们声明变量。
- en: 'Variables declared with `let` are block-scoped. They exist only within the
    current block. Variables declared with `var` are function scoped, as we saw earlier.
    The following example illustrates the block scope:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`let`声明的变量是块作用域的。它们只存在于当前块中。使用`var`声明的变量是函数作用域的，正如我们之前所看到的。下面的例子说明了块作用域：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The scope between an opening brace`''{''` and a closing brace `''}''` is a
    block. If you are coming from a background in Java or C/C++, the concept of a
    block scope will be very familiar to you. In those languages, programmers introduced
    blocks just to define a scope. In JavaScript, however, there was a need to idiomatically
    introduce blocks as they didn''t have a scope associated to it. However, ES6 allows
    you to create block-scoped variables using the `let` keyword. As you can see in
    the preceding example, variable `a` created inside the block is available within
    the block. While declaring block-scoped variables, it is generally recommended
    to add the `let` declaration at the top of the block. Let''s look at another example
    to clearly distinguish function and block scope:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号`'{'`和`'}'`之间的作用域是一个块。如果你来自Java或C/C++的背景，块作用域的概念对你来说将非常熟悉。在这些语言中，程序员引入块只是为了定义一个作用域。然而，在JavaScript中，有必要习惯性地引入块，因为它们没有与之关联的作用域。然而，ES6允许你使用`let`关键字创建块作用域变量。正如你在前面的例子中看到的，块内创建的变量`a`在块内是可用的。在声明块作用域变量时，通常建议在块的顶部添加`let`声明。让我们看另一个例子，以清楚地区分函数作用域和块作用域：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see, `tmp` is declared with `let` and is available only in the block
    in which it was defined. For all practical purposes, you should maximize your
    use of block-scoped variables. Unless there is something very specific you are
    trying to do that makes it necessary for you to use `var` declarations, make sure
    you prefer block scoped variables. However, incorrectly using the `let` keyword
    can cause a couple of problems. First, you cannot redeclare the same variable
    within the same function or block scope using the `let` keyword:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`tmp`是用`let`声明的，并且只在它被定义的块中可用。在实际操作中，你应该最大化使用块作用域变量。除非有非常特定的事情需要你使用`var`声明，否则请确保你优先使用块作用域变量。然而，错误地使用`let`关键字可能会导致一些问题。首先，你不能在同一个函数或块作用域中使用`let`关键字重新声明相同的变量：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In ES6, variables declared by the `let` keyword are hoisted to block scope.
    However, referencing the variable before its declaration is an error.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6中，使用`let`关键字声明的变量被提升到块作用域。然而，在声明之前引用变量是一个错误。
- en: Another keyword introduced in ES6 is `const`. A variable declared with the `const`
    keyword creates a read-only reference to a value. This does not mean that the
    value held by the reference is immutable. However, the variable identifier cannot
    be reassigned. Constants are block-scoped just like variables created using the
    `let` keyword. Also, you have to assign a value to the variable while declaring
    them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ES6中引入的另一个关键字是`const`。使用`const`关键字声明的变量创建一个只读引用值。这并不意味着引用持有的值是不可变的。然而，变量标识符不能被重新分配。常量与使用`let`关键字创建的变量一样是块作用域的。此外，在声明变量时必须为变量赋值。
- en: 'Although it sounds like it does, `const` has nothing to do with immutable values.
    Constants create immutable binding. This is an important distinction and needs
    to be understood correctly. Let''s consider the following example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它听起来像是，`const`与不可变值无关。常量创建不可变绑定。这是一个重要的区别，需要正确理解。让我们考虑下面的例子：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is a valid code; here we are assigning value `{}` to a constant `car`.
    Once assigned, this reference cannot be changed. In ES6, you should do the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有效的代码；在这里我们将`{}`赋值给一个常量`car`。一旦赋值，这个引用就不能被改变。在ES6中，你应该这样做：
- en: 'Use `const` where possible. Use them for all variables whose values don''t
    change:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用`const`。对所有值不会改变的变量使用它：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Avoid `var`.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用`var`。
- en: Functions are data
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数是数据
- en: 'Functions in JavaScript are actually data. This is an important concept that
    we''ll need later on. This means that you can create a function and assign it
    to a variable, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的函数实际上是数据。这是一个我们以后会需要的重要概念。这意味着你可以创建一个函数并将它分配给一个变量，如下所示：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This way of defining a function is sometimes referred to as **function literal
    notation**.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这种定义函数的方式有时被称为**函数文字表示法**。
- en: 'The `function () { return 1;}` part is a **function expression**. A function
    expression can optionally have a name, in which case it becomes a **named function
    expression** (**NFE**). So, this is also allowed, although rarely seen in practice
    (and causes IE to mistakenly create two variables in the enclosing scope-`f` and
    `myFunc`):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`function () { return 1;}`部分是一个**函数表达式**。函数表达式可以选择地有一个名字，这样它就成为了**命名函数表达式**（**NFE**）。因此，这也是允许的，尽管在实践中很少见（并且会导致IE错误地在封闭作用域中创建两个变量-`f`和`myFunc`）：'
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, there's no difference between a named function expression and
    a function declaration. But they are, in fact, different. The only way to distinguish
    between the two is to look at the context in which they are used. Function declarations
    may only appear in program code (in a body of another function or in the main
    program). You'll see many more examples of functions later on in the book that
    will clarify these concepts.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，命名函数表达式和函数声明之间没有区别。但实际上它们是不同的。区分两者的唯一方法是看它们被使用的上下文。函数声明只能出现在程序代码中（在另一个函数的主体中或在主程序中）。你将在本书的后面看到更多的函数示例，这将澄清这些概念。
- en: 'When you use the `typeof` operator on a variable that holds a function value,
    it returns the string `"function"` as shown in the following example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在一个包含函数值的变量上使用`typeof`运算符时，它返回字符串`"function"`，如下例所示：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So, JavaScript functions are data, but a special kind of data with the following
    two important features:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，JavaScript函数是数据，但是一种具有以下两个重要特征的特殊数据：
- en: They contain code
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们包含代码
- en: They are executable (they can be invoked)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是可执行的（它们可以被调用）
- en: 'As you have seen before, the way to execute a function is by adding parentheses
    after its name. As the next example demonstrates, this works regardless of how
    the function was defined. In the example, you can also see how a function is treated
    as a regular value; it can be copied to a different variable, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你之前所见，执行函数的方法是在函数名后面加括号。如下一个例子所示，这种方法可以在不管函数是如何定义的情况下工作。在这个例子中，你还可以看到函数是如何被视为一个常规值的；它可以被复制到另一个变量中，如下所示：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As functions are data assigned to variables, the same rules for naming functions
    apply as for naming variables-a function name cannot start with a number and it
    can contain any combination of letters, numbers, the underscore character, and
    the dollar sign.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因为函数是分配给变量的数据，所以命名函数的命名规则与变量的命名规则相同-函数名不能以数字开头，它可以包含任意组合的字母、数字、下划线字符和美元符号。
- en: Anonymous functions
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数
- en: 'As you now know, there exists a function expression syntax where you can have
    a function defined like the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在所知道的，存在一种函数表达式语法，你可以像下面这样定义一个函数：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is also often called an **anonymous function** (as it doesn''t have a
    name), especially when such a function expression is used even without assigning
    it to a variable. In this case, there can be two elegant uses for such anonymous
    functions, which are as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这也经常被称为**匿名函数**（因为它没有名字），特别是当这样的函数表达式即使没有分配给变量也被使用时。在这种情况下，这样的匿名函数有两种优雅的用法，如下所示：
- en: You can pass an anonymous function as a parameter to another function. The receiving
    function can do something useful with the function that you pass.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将匿名函数作为参数传递给另一个函数。接收函数可以对您传递的函数执行一些有用的操作。
- en: You can define an anonymous function and execute it right away.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以定义一个匿名函数并立即执行它。
- en: Let's see these two applications of anonymous functions in more detail.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看匿名函数的这两个应用。
- en: Callback functions
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调函数
- en: As a function is just like any other data assigned to a variable, it can be
    defined, copied, and also passed as an argument to other functions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数就像分配给变量的任何其他数据一样，它可以被定义、复制，并且也可以作为参数传递给其他函数。
- en: 'Here''s an example of a function that accepts two functions as parameters,
    executes them, and returns the sum of what each of them returns:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个接受两个函数作为参数、执行它们并返回它们各自返回值之和的函数的例子：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, let''s define two simple additional functions using a function declaration
    pattern that only returns hardcoded values:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用仅返回硬编码值的函数声明模式来定义两个简单的附加函数：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now you can pass those functions to the original function, `invokeAdd()`, and
    get the following result:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将这些函数传递给原始函数`invokeAdd()`，并获得以下结果：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Another example of passing a function as a parameter is to use anonymous functions
    (function expressions). Instead of defining `one()` and `two()`, you can simply
    do the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数作为参数传递的另一个例子是使用匿名函数（函数表达式）。您可以简单地执行以下操作，而不是定义`one()`和`two()`：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Or, you can make it more readable, as shown in the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使其更易读，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Or, you can do the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以这样做：
- en: '[PRE46]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When you pass a function, A, to another function, B, and then B executes A,
    it's often said that A is a **callback** function. If A doesn't have a name, then
    you can say that it's an anonymous callback function.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将函数A传递给另一个函数B，然后B执行A时，通常会说A是一个**回调**函数。如果A没有名称，那么您可以说它是一个匿名回调函数。
- en: 'When are callback functions useful? Let''s see some examples that demonstrate
    the benefits of callback functions, namely:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数何时有用？让我们看一些示例，演示回调函数的好处，即：
- en: They let you pass functions without the need to name them, which means there
    are fewer variables floating around
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们让您无需命名即可传递函数，这意味着浮动的变量更少。
- en: You can delegate the responsibility of calling a function to another function,
    which means there is less code to write
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将调用函数的责任委托给另一个函数，这意味着要编写的代码更少
- en: They can help with performance by deferring the execution or by unblocking calls
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以通过推迟执行或解除阻塞调用来提高性能
- en: Callback examples
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回调函数示例
- en: 'Take a look at this common scenario-you have a function that returns a value,
    which you then pass to another function. In our example, the first function, `multiplyByTwo()`,
    accepts three parameters, loops through them, multiplies them by two, and returns
    an array containing the result. The second function, `addOne()`, takes a value,
    adds one to it, and returns it, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这种常见情况-您有一个返回值的函数，然后将其传递给另一个函数。在我们的例子中，第一个函数`multiplyByTwo()`接受三个参数，循环遍历它们，将它们乘以二，并返回包含结果的数组。第二个函数`addOne()`接受一个值，将其加一，并返回它，如下所示：
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s test these functions:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试这些函数：
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, let''s say you want to have an array, `myarr`, that contains three elements,
    and each of the elements is to be passed through both functions. First, let''s
    start with a call to `multiplyByTwo()`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您想要有一个包含三个元素的数组`myarr`，并且每个元素都要通过这两个函数传递。首先，让我们从调用`multiplyByTwo()`开始：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, loop through each element, passing it to `addOne()`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，循环遍历每个元素，将其传递给`addOne()`：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As you can see, everything works fine, but there''s room for improvement. For
    example, there were two loops. Loops can be expensive if they go through a lot
    of repetitions. You can achieve the same result with only one loop. Here''s how
    to modify `multiplyByTwo()` so that it accepts a callback function and invokes
    that callback on every iteration:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，一切都运行正常，但还有改进的空间。例如，有两个循环。如果循环次数很多，循环可能会很昂贵。您可以通过只有一个循环来实现相同的结果。以下是如何修改`multiplyByTwo()`以便接受回调函数并在每次迭代时调用该回调的方法：
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Using the modified function, all the work is done with just one function call,
    which passes the start values and the `callback` function, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用修改后的函数，所有工作都是通过一个函数调用完成的，该函数传递了起始值和`callback`函数，如下所示：
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Instead of defining `addOne()`, you can use an anonymous function, therefore
    saving an extra global variable:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用匿名函数来定义`addOne()`，从而节省额外的全局变量：
- en: '[PRE53]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Anonymous functions are easy to change should the need arise:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数很容易更改，如果需要的话：
- en: '[PRE54]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Immediate functions
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 立即函数
- en: 'So far, we have discussed using anonymous functions as callbacks. Let''s see
    another application of an anonymous function-calling a function immediately after
    it''s defined. Here''s an example:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了使用匿名函数作为回调。让我们看看匿名函数的另一个应用-在定义后立即调用函数。这是一个例子：
- en: '[PRE55]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The syntax may look a little scary at first, but all you do is simply place
    a function expression inside parentheses followed by another set of parentheses.
    The second set says execute now and is also the place to put any arguments that
    your anonymous function might accept, for example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 语法一开始可能看起来有点吓人，但你所做的就是简单地将一个函数表达式放在括号内，然后再加上另一组括号。第二组括号表示立即执行，也是放置您的匿名函数可能接受的任何参数的地方，例如：
- en: '[PRE56]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Alternatively, you can move the closing of the first set of parentheses to
    the end. Both of these work:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以将第一组括号的关闭移到末尾。这两种方法都可以：
- en: '[PRE57]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: One good application of immediate (self-invoking) anonymous functions is when
    you want to have some work done without creating extra global variables. A drawback,
    of course, is that you cannot execute the same function twice. This makes immediate
    functions best suited for one-off or initialization tasks.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 立即（自我调用）匿名函数的一个很好的应用是在不创建额外全局变量的情况下完成一些工作。当然，缺点是您无法两次执行相同的函数。这使得立即函数最适合一次性或初始化任务。
- en: 'An immediate function can also optionally return a value if you need one. It''s
    not uncommon to see code that looks like the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，立即函数也可以选择返回一个值。看到以下代码并不罕见：
- en: '[PRE58]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In this case, you don''t need to wrap the function expression in parentheses;
    you only need the parentheses that invoke the function. So, the following piece
    of code also works:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您不需要将函数表达式包装在括号中；您只需要调用函数的括号。因此，以下代码片段也有效：
- en: '[PRE59]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This syntax works, but may look slightly confusing; without reading the end
    of the function, you don't know if `result` is a function or the return value
    of the immediate function.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法有效，但可能看起来有点令人困惑；如果没有阅读函数的结尾，您就不知道`result`是一个函数还是立即函数的返回值。
- en: Inner (private) functions
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部（私有）函数
- en: 'Bearing in mind that a function is just like any other value, there''s nothing
    that stops you from defining a function inside another function, here''s the example:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，函数就像任何其他值一样，没有什么能阻止您在另一个函数中定义一个函数，下面是一个例子：
- en: '[PRE60]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Using a function expression, this can also be written as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数表达式，这也可以写成如下形式：
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'When you call the global `outer()`function, it will internally call the local
    `inner()`function. As `inner()` is local, it''s not accessible outside `outer()`,
    so you can say it''s a private function:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用全局`outer()`函数时，它将在内部调用本地`inner()`函数。由于`inner()`是本地的，所以在`outer()`之外是无法访问的，因此可以说它是一个私有函数：
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The benefits of using private functions are as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用私有函数的好处如下：
- en: You can keep the global namespace clean, which is less likely to cause naming
    collisions
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以保持全局命名空间的清洁，这样不太可能引起命名冲突
- en: Privacy-you can expose only those functions to the outside world that you decide,
    and keep the functionality that is not meant to be consumed by the rest of the
    application to yourself
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐私-您只能向外界公开您决定的那些函数，并将不打算被应用程序的其余部分使用的功能保留给自己
- en: Functions that return functions
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回函数的函数
- en: 'As mentioned earlier, a function always returns a value, and if it doesn''t
    do it explicitly with `return`, then it does so implicitly by returning `undefined`.
    A function can return only one value, and this value can just as easily be another
    function, for example:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，函数总是返回一个值，如果没有使用`return`显式返回，则会隐式返回`undefined`。函数只能返回一个值，而这个值也可以很容易地是另一个函数，例如：
- en: '[PRE63]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In this example, the `a()`function does its job (says `A!`) and returns another
    function that does something else (says `B!`). You can assign the return value
    to a variable and then use this variable as a normal function, as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`a()`函数完成其工作（警报`A!`），然后返回另一个执行其他操作的函数（警报`B!`）。您可以将返回值分配给一个变量，然后像普通函数一样使用这个变量，如下所示：
- en: '[PRE64]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here, the first line will alert `A!` and the second will alert `B!`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一行将警报`A!`，第二行将警报`B!`。
- en: 'If you want to execute the returned function immediately without assigning
    it to a new variable, you can simply use another set of parentheses. The end result
    will be the same:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想立即执行返回的函数而不将其分配给一个新变量，您可以简单地使用另一组括号。最终结果将是相同的：
- en: '[PRE65]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Function, rewrite thyself!
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数，重写自己！
- en: 'As a function can return a function, you can use the new function to replace
    the old one. Continuing with the previous example, you can take the value returned
    by the call to `a()` to overwrite the actual `a()` function:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数可以返回函数，您可以使用新函数来替换旧函数。继续使用前面的例子，您可以使用调用`a()`的返回值来覆盖实际的`a()`函数：
- en: '[PRE66]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The preceding line of code alerts `A!`, but the next time you call `a()` it
    alerts `B!`. This is useful when a function has some initial one-off work to do.
    The function overwrites itself after the first call in order to avoid doing unnecessary
    repetitive work every time it's called.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行代码会警报`A!`，但下一次调用`a()`时会警报`B!`。当函数有一些初始的一次性工作要做时，这是很有用的。函数在第一次调用后会覆盖自身，以避免每次调用时都做不必要的重复工作。
- en: 'In the preceding example, the function was redefined from the outside and the
    returned value was assigned back to the function. But, the function can actually
    rewrite itself from the inside, as shown in the following example:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，函数是从外部重新定义的，并且返回的值被重新分配给函数。但是，函数实际上可以从内部重写自身，如下例所示：
- en: '[PRE67]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If you call this function for the first time, it will do the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您第一次调用此函数，它将执行以下操作：
- en: Alert `A!` (consider this as being the one-off preparatory work)
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警报`A!`（将其视为一次性的准备工作）
- en: Redefine the global variable `a` and assigning a new function to it
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新定义全局变量`a`并将新函数分配给它
- en: Every subsequent time that the function is called, it will alert `B!`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用该函数时，它都会警报`B!`。
- en: 'Here''s another example that combines several of the techniques discussed in
    the last few sections of this chapter:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个例子，结合了本章最后几节讨论的几种技术：
- en: '[PRE68]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'From this example, you can note the following things:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，您可以注意到以下几点：
- en: You have private functions; `someSetup()` and `actualWork()`.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您有私有函数；`someSetup()`和`actualWork()`。
- en: 'You have an immediate function: an anonymous function that calls itself using
    the parentheses following its definition.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您有一个立即函数：一个匿名函数，使用其定义后面的括号调用自身。
- en: The function executes for the first time, calls `someSetup()`, and then returns
    a reference to the `actualWork` variable, which is a function. Notice that there
    are no parentheses in the `return` statement because you're returning a function
    reference, not the result of invoking this function.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数首次执行时，调用`someSetup()`，然后返回对`actualWork`变量的引用，该变量是一个函数。请注意，在`return`语句中没有括号，因为您返回的是函数引用，而不是调用此函数的结果。
- en: As the whole thing starts with `var a =`, the value returned by the self-invoked
    function is assigned to `a`.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于整个过程以`var a =`开始，自调用函数的返回值被分配给`a`。
- en: 'If you want to test your understanding of the topics just discussed, answer
    the following questions. What will the preceding code alert be in the following
    cases:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想测试一下刚才讨论的话题的理解程度，请回答以下问题。在以下情况下，前面的代码会弹出什么：
- en: It is initially loaded?
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它最初加载了吗？
- en: You call `a()` afterwards?
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后你调用`a()`？
- en: These techniques could be really useful when working in the browser environment.
    Different browsers can have different ways of achieving the same result. If you
    know that the browser features won't change between function calls, you can have
    a function determine the best way to do the work in the current browser, then
    redefine itself so that the browser capability detection is done only once. You'll
    see concrete examples of this scenario later in this book.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器环境中，这些技术可能非常有用。不同的浏览器可能有不同的实现相同结果的方式。如果你知道浏览器特性在函数调用之间不会改变，你可以让一个函数确定在当前浏览器中做工作的最佳方式，然后重新定义自己，以便浏览器能力检测只做一次。你将在本书的后面看到这种情况的具体例子。
- en: Closures
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: The rest of the chapter is about closures (what better way to close a chapter?).
    Closures can be a little hard to grasp initially, so don't feel discouraged if
    you don't get it during the first read. You should go through the rest of the
    chapter and experiment with the examples on your own, but if you feel you don't
    fully understand the concept, you can come back to it later when the topics discussed
    previously in this chapter have had a chance to sink in.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分是关于闭包的（还有什么更好的方式来结束一个章节呢？）。闭包可能一开始有点难以理解，所以如果你在第一次阅读时没有理解，不要感到沮丧。你应该阅读本章的其余部分，并自己尝试示例，但如果你觉得自己没有完全理解这个概念，可以在本章前面讨论的话题有机会消化后再回来看。
- en: Before moving on to closures, let's first review and expand on the concept of
    scope in JavaScript.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续讨论闭包之前，让我们首先回顾并扩展JavaScript中作用域的概念。
- en: Scope chain
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域链
- en: 'As you know, in JavaScript, there is no curly braces scope, but there is a
    function scope. A variable defined in a function is not visible outside the function,
    but a variable defined in a code block (for example an `if` or a `for` loop) is
    visible outside the block, for example:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，在JavaScript中，没有花括号作用域，但有函数作用域。在函数中定义的变量在函数外部不可见，但在代码块（例如`if`或`for`循环）中定义的变量在块外部可见，例如：
- en: '[PRE69]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `a` variable is in the global space, while `b` is in the scope of the function
    `f()`. So, we have the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`a`在全局空间中，而`b`在函数`f()`的作用域中。所以，我们有以下情况：
- en: Inside `f()`, both `a` and `b` are visible
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`f()`内部，`a`和`b`都是可见的
- en: Outside `f()`, `a` is visible, but `b` is not
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`f()`外部，`a`是可见的，但`b`不可见
- en: 'If you define an `inner()`function nested inside `outer()`, it will have access
    to variables in its own scope, plus the scope of its parents. This is known as
    a scope chain, and the chain can be as long (deep) as you need it to be:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在`outer()`内部嵌套定义一个`inner()`函数，它将可以访问其自己的作用域中的变量，以及其父级的作用域。这就是所谓的作用域链，链可以很长（深），可以根据需要延伸：
- en: '[PRE70]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let''s test if the `inner()` function has access to all variables:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下`inner()`函数是否可以访问所有变量：
- en: '[PRE71]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Breaking the chain with a closure
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用闭包打破链条
- en: 'Let''s introduce closures with an illustration and look at the following code
    and see what''s happening there:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来介绍闭包，并看看以下代码发生了什么：
- en: '[PRE72]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'First, there is the global scope **G**. Think of it as the universe, as if
    it contains everything:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是全局作用域**G**。把它想象成宇宙，好像它包含了一切：
- en: '![Breaking the chain with a closure](graphics/image_03_002.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![使用闭包打破链条](graphics/image_03_002.jpg)'
- en: 'It can contain global variables such as **a1** and **a2** and global functions
    such as **F**:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以包含全局变量，如**a1**和**a2**，以及全局函数，如**F**：
- en: '![Breaking the chain with a closure](graphics/image_03_003.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![使用闭包打破链条](graphics/image_03_003.jpg)'
- en: 'Functions have their own private space and can use it to store other variables,
    such as **b**, and inner functions, such as **N** (for inner). At some point,
    you will end up with a picture like the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 函数有自己的私有空间，并且可以用它来存储其他变量，比如**b**，以及内部函数，比如**N**（用于内部）。在某个时候，你会得到以下的图片：
- en: '![Breaking the chain with a closure](graphics/image_03_004.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![使用闭包打破链条](graphics/image_03_004.jpg)'
- en: If you're at point a, you're inside the global space. If you're at point **b**,
    which is inside the space of the **F** function, then you have access to the global
    space and to the **F** space. If you're at point **c**, which is inside the **N**
    function, then you can access the global space, the **F** space, and the **N**
    space. You cannot reach from **a** to **b**, because **b** is invisible outside
    **F**. But, you can get from **c** to **b** if you want or from **N** to **b**.
    The interesting part is that the closure effect happens when somehow **N** breaks
    out of **F** and ends up in the global space.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在点a，你就在全局空间内。如果你在点**b**，也就是在**F**函数的空间内，那么你就可以访问全局空间和**F**空间。如果你在点**c**，也就是在**N**函数的空间内，那么你可以访问全局空间、**F**空间和**N**空间。你无法从**a**到达**b**，因为**b**在**F**外部是不可见的。但是，如果你愿意，你可以从**c**到达**b**，或者从**N**到达**b**。有趣的是，当**N**以某种方式打破了**F**并进入了全局空间时，闭包效果就会发生。
- en: '![Breaking the chain with a closure](graphics/image_03_005.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![使用闭包打破链条](graphics/image_03_005.jpg)'
- en: What happens then? **N** is in the same global space as **a**. And, as functions
    remember the environment in which they were defined, **N** will still have access
    to the **F** space, and hence, can access **b**. This is interesting, because
    **N** is where **a** is and yet **N** does have access to **b**, but **a** doesn't.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然后会发生什么？**N**在与**a**相同的全局空间中。而且，由于函数记住了它们被定义的环境，**N**仍然可以访问**F**空间，因此可以访问**b**。这很有趣，因为**N**在**a**所在的地方，但**N**确实可以访问**b**，但**a**不行。
- en: Additionally, how does **N** break the chain? By making itself global (omitting
    `var`) or by having **F** deliver (or `return`) it to the global space. Let's
    see how this is done in practice.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，**N**是如何打破链条的？通过使自己成为全局的（省略`var`）还是通过让**F**将其传递（或`return`）到全局空间。让我们看看这在实践中是如何做的。
- en: 'Closure #1'
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '闭包 #1'
- en: 'Take a look at the following function, which is the same as before, only `F`
    returns `N` and also `N` returns `b`, to which it has access via the scope chain:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的函数，它和之前的一样，只是`F`返回`N`，而`N`返回`b`，通过作用域链它可以访问到`b`：
- en: '[PRE73]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `F` function contains the `b` variable, which is local, and therefore inaccessible
    from the global space:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`F`函数包含`b`变量，它是局部的，因此无法从全局空间访问：'
- en: '[PRE74]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `N` function has access to its private space, to the `F()` function''s
    space, and to the global space. So, it can see `b`. As `F()` is callable from
    the global space (it''s a global function), you can call it and assign the returned
    value to another global variable. The result - a new global function that has
    access to the `F()` function''s private space:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`N`函数可以访问它的私有空间，`F()`函数的空间和全局空间。因此，它可以看到`b`。由于`F()`可以从全局空间调用（它是一个全局函数），你可以调用它并将返回的值赋给另一个全局变量。结果是一个新的全局函数，它可以访问`F()`函数的私有空间：'
- en: '[PRE75]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Closure #2'
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 闭包＃2
- en: The final result of the next example will be the same as the previous example,
    but the way to achieve it is a little different. `F()` doesn't return a function,
    but instead it creates a new global function, `inner()`, inside its body.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子的最终结果将与前一个例子相同，但实现方式略有不同。`F()`不返回一个函数，而是在其内部创建一个新的全局函数`inner()`。
- en: 'Let''s start by declaring a placeholder for the global function-to-be. This
    is optional, but it''s always good to declare your variables. Then, you can define
    the `F()`function as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先声明一个全局函数的占位符。这是可选的，但总是好习惯。然后，你可以定义`F()`函数如下：
- en: '[PRE76]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, let''s see what happens if you invoke `F()`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果你调用`F()`会发生什么：
- en: '[PRE77]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'A new function, `N()`,is defined inside `F()` and assigned to the global `inner`
    function. During definition time, `N()` was inside `F()`, so it had access to
    the `F()` function''s scope. The `inner()` function will keep its access to the
    `F()` function''s scope, even though it''s part of the global space, for example:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在`F()`内部定义了一个新函数`N()`，并赋值给全局的`inner`函数。在定义时，`N()`在`F()`内部，因此它可以访问`F()`函数的作用域。即使`inner()`函数是全局空间的一部分，它也将保持对`F()`函数作用域的访问，例如：
- en: '[PRE78]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'A definition and closure #3'
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义和闭包＃3
- en: Every function can be considered a closure. This is because every function maintains
    a secret link to the environment (the scope) in which it was created. But, most
    of the time, this scope is destroyed unless something interesting happens (as
    shown in the preceding code) that causes it to be maintained.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都可以被视为一个闭包。这是因为每个函数都保持着一个秘密的链接到它被创建的环境（作用域）。但是，大多数情况下，这个作用域会被销毁，除非发生一些有趣的事情（如前面的代码所示）导致它被保留。
- en: Based on what you've seen so far, you can say that a closure is created when
    a function keeps a link to its parent scope even after the parent has returned.
    And, every function is a closure because, at the very least, every function maintains
    access to the global scope, which is never destroyed.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你目前所见，你可以说当一个函数在其父级返回后仍保持对其父级作用域的链接时，就创建了一个闭包。而且，每个函数都是一个闭包，因为至少每个函数都保持对全局作用域的访问，而全局作用域永远不会被销毁。
- en: 'Let''s see one more example of a closure, this time using the function parameters.
    Function parameters behave like local variables to this function, but they are
    implicitly created; you don''t need to use `var` for them. You can create a function
    that returns another function, which in turn returns its parent''s parameter,
    as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个闭包的例子，这次使用函数参数。函数参数的行为就像这个函数的局部变量，但它们是隐式创建的；你不需要为它们使用`var`。你可以创建一个返回另一个函数的函数，然后返回其父级的参数，如下所示：
- en: '[PRE79]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'You can use the function as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按以下方式使用该函数：
- en: '[PRE80]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Notice how `param++` was incremented after the function was defined and yet,
    when called, `inner()` returned the updated value. This demonstrates that the
    function maintains a reference to the scope where it was defined, and not to the
    variables and their values found in the scope during the function execution.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`param++`在函数定义后递增，但当调用`inner()`时，它返回了更新后的值。这表明函数保持对其定义时的作用域的引用，而不是在函数执行期间在作用域中找到的变量和它们的值的引用。
- en: Closures in a loop
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环中的闭包
- en: Let's take a look at a canonical rookie mistake when it comes to closures. It
    can easily lead to hard-to-spot bugs, because on the surface, everything looks
    normal.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看闭包时一个经典的新手错误。这很容易导致难以发现的错误，因为表面上一切都很正常。
- en: 'Let''s loop three times, each time creating a new function that returns the
    loop sequence number. The new functions will be added to an array and the array
    is returned at the end. Here''s the function:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们循环三次，每次创建一个返回循环序列号的新函数。新函数将被添加到一个数组中，并在最后返回该数组。以下是函数：
- en: '[PRE81]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Let''s run the function, assigning the result to the `arr` array:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行该函数，并将结果赋给`arr`数组：
- en: '[PRE82]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now you have an array of three functions. Let''s invoke them by adding parentheses
    after each array element. The expected behavior is to see the loop sequence printed
    out as `0`, `1`, and `2`. Let''s try:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个包含三个函数的数组。让我们在每个数组元素后面加上括号来调用它们。预期的行为是打印出循环序列`0`、`1`和`2`。让我们试试：
- en: '[PRE83]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Hmm, not quite as expected. What happened here? All three functions point to
    the same local variable: `i`. Why? The functions don''t remember values, they
    only keep a link (reference) to the environment where they were created. In this
    case, the `i` variable happens to live in the environment where the three functions
    were defined. So, all functions, when they need to access the value, reach back
    to the environment and find the most current value of `i`. After the loop, the
    `i` variable''s value is `3`. So, all three functions point to the same value.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，不太符合预期。这里发生了什么？所有三个函数指向同一个局部变量：`i`。为什么？这些函数不记住值，它们只保留一个指向它们创建时的环境的链接（引用）。在这种情况下，`i`变量恰好存在于定义这三个函数的环境中。因此，所有函数在需要访问该值时，都会回到环境中找到`i`的最新值。循环结束后，`i`变量的值为`3`。因此，所有三个函数指向相同的值。
- en: Why three and not two is another good question to think about for better understanding
    the `for` loop.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是三而不是两是另一个更好的问题，以便更好地理解`for`循环。
- en: 'So, how do you implement the correct behavior? The answer is to use another
    closure, as shown in the following piece of code:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何实现正确的行为呢？答案是使用另一个闭包，如下面的代码所示：
- en: '[PRE84]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This gives you the expected result as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给你期望的结果如下：
- en: '[PRE85]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here, instead of just creating a function that returns `i`, you pass the `i`
    variable's current value to another immediate function. In this function, `i`
    becomes the local value `x`, and `x` has a different value every time.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您不仅创建一个返回`i`的函数，还将`i`变量的当前值传递给另一个立即函数。在这个函数中，`i`变成了本地值`x`，并且`x`每次都有不同的值。
- en: 'Alternatively, you can use a normal (as opposed to an immediate) inner function
    to achieve the same result. The key is to use the middle function to localize
    the value of `i` at every iteration, as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用一个普通的（而不是立即的）内部函数来实现相同的结果。关键是使用中间函数在每次迭代时将`i`的值局部化，如下所示：
- en: '[PRE86]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Getter and setter
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Getter和setter
- en: Let's see two more examples of using closures. The first one involves the creation
    of the getter and setter functions. Imagine that you have a variable that should
    contain a specific type of value or a specific range of values. You don't want
    to expose this variable because you don't want just any part of the code to be
    able to alter its value. You can protect this variable inside a function and provide
    two additional functions-one to get the value and one to set it. The one that
    sets it could contain some logic to validate a value before assigning it to the
    protected variable. Let's make the validation part simple (for the sake of keeping
    the example short) and only accept number values.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用闭包的另外两个例子。第一个涉及创建getter和setter函数。想象一下，您有一个变量，它应该包含特定类型的值或特定范围的值。您不想暴露这个变量，因为您不希望代码的任何部分都能够改变它的值。您可以将这个变量保护在一个函数内，并提供两个额外的函数——一个用于获取值，一个用于设置值。设置它的函数可以包含一些逻辑来验证值在分配给受保护的变量之前。让我们简化验证部分（为了保持示例简短）并只接受数字值。
- en: 'You can place both the getter and the setter functions inside the same function
    that contains the `secret` variable so that they share the same scope:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将getter和setter函数都放在包含`secret`变量的同一个函数中，以便它们共享相同的作用域：
- en: '[PRE87]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In this case, the function that contains everything is an immediate function.
    It defines `setValue()` and `getValue()` as global functions, while the `secret`
    variable remains local and inaccessible directly, as shown in the following example:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，包含所有内容的函数是一个立即函数。它将`setValue()`和`getValue()`定义为全局函数，而`secret`变量保持本地和无法直接访问，如下例所示：
- en: '[PRE88]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Iterator
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器
- en: The last closure example (also the last example in this chapter) shows the use
    of a closure to accomplish an iterator functionality.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个闭包示例（也是本章的最后一个示例）展示了使用闭包来实现迭代器功能。
- en: You already know how to loop through a simple array, but there might be cases
    where you have a more complicated data structure with different rules as to what
    the sequence of values has. You can wrap the complicated who's next logic into
    an easy-to-use `next()` function. Then, you can simply call `next()` every time
    you need the consecutive value.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经知道如何循环遍历一个简单的数组，但可能存在更复杂的数据结构的情况，其中有不同的规则来确定值的顺序。您可以将复杂的下一个逻辑封装到一个易于使用的`next()`函数中。然后，您可以在需要连续值的每个时间简单地调用`next()`。
- en: 'For this example, let''s just use a simple array and not a complex data structure.
    Here''s an initialization function that takes an input array and also defines
    a secret pointer, `i`, that will always point to the next element in the array:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，让我们只使用一个简单的数组而不是一个复杂的数据结构。这是一个初始化函数，它接受一个输入数组，并定义一个秘密指针`i`，它将始终指向数组中的下一个元素：
- en: '[PRE89]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Calling the `setup()` function with a data array will create the `next()` function
    for you, as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 调用带有数据数组的`setup()`函数将为您创建`next()`函数，如下所示：
- en: '[PRE90]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'From there it''s easy and fun; calling the same function over and over again
    gives you the next element, which is as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里开始就很容易和有趣了；一遍又一遍地调用相同的函数给你下一个元素，如下所示：
- en: '[PRE91]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: IIFE versus blocks
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IIFE与块
- en: 'As ES5 did not provide block scope, a popular pattern to achieve block scope
    was to use **immediately invoked function expressions** (**IIFE**), for example:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ES5没有提供块作用域，实现块作用域的一种流行模式是使用**立即调用的函数表达式**（**IIFE**），例如：
- en: '[PRE92]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: With ES6's support for block scopes, you can simply use a `let` or `const` declaration.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 有了ES6对块作用域的支持，您可以简单地使用`let`或`const`声明。
- en: Arrow functions
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'JavaScript uses almost all variations of arrows. With ES6, it introduces a
    new syntax for writing functions. We have always written function expressions
    in JavaScript. It is idiomatic to write code like this in JavaScript (this example
    is in jQuery):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript几乎使用了所有箭头的变体。ES6引入了一种新的语法来编写函数。我们一直在JavaScript中编写函数表达式。在JavaScript中写代码像这样是惯用的（此示例是在jQuery中）：
- en: '[PRE93]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This is a typical jQuery event handler. The event handler `click()` function
    accepts a function as a parameter and we will simply create an inline anonymous
    function expression and pass it to the click function. This style of writing anonymous
    function expressions is known as **Lambda functions**. Several other languages
    support this feature. Though lambdas are more or less standard in new languages,
    JavaScript was responsible for popularizing their usage. However, the lambda syntax
    in JavaScript has not been very concise. ES6 arrow functions fill that gap and
    provide a concise syntax to write functions.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的jQuery事件处理程序。事件处理程序`click()`函数接受一个函数作为参数，我们将简单地创建一个内联的匿名函数表达式并将其传递给click函数。这种写法匿名函数表达式被称为**Lambda函数**。其他几种语言支持这个特性。虽然lambda在新语言中更或多或少是标准的，但JavaScript负责推广它们的使用。然而，JavaScript中的lambda语法并不是非常简洁。ES6箭头函数填补了这一空白，并提供了一种简洁的语法来编写函数。
- en: 'Arrow function provide a more concise syntax than the traditional function
    expressions; for example, consider the following piece of code:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数提供了比传统函数表达式更简洁的语法；例如，考虑以下代码片段：
- en: '[PRE94]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Arrow functions syntax can simplify the function to the following line of code:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数语法可以简化函数为以下代码行：
- en: '[PRE95]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: As you can see, there is no `function` or `return` keyword anywhere. If your
    function has only one argument, you will end up writing the function as `identifer
    => expression`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，任何地方都没有`function`或`return`关键字。如果你的函数只有一个参数，你将会写成`identifer => expression`。
- en: 'When you need multiple arguments, you need to wrap the argument list in braces:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要多个参数时，你需要用括号包裹参数列表：
- en: '**No parameters**: `() => {...}`'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有参数**：`() => {...}`'
- en: '**One parameter**: `a => {...}`'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个参数**：`a => {...}`'
- en: '**More than one parameters**: `(a,b) => {...}`'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多个参数**：`(a,b) => {...}`'
- en: 'Arrow functions can have both the statement block bodies as well as expression
    bodies:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数可以有语句块体和表达式体：
- en: '[PRE96]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Both are equivalent but the second variation is concise and preferred. Arrow
    functions are always anonymous. One important aspect of arrow functions that we
    will discuss a little later is that arrow functions do not bind their own values
    of the `this` keyword-the value is lexically derived from the surrounding scope.
    As we have not yet looked at the `this` keyword in detail, we will defer the discussion
    to a later part of this book.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 两者是等价的，但第二种变体更简洁，更受欢迎。箭头函数始终是匿名的。箭头函数的一个重要方面是，它们不会绑定`this`关键字的值-该值是从周围作用域中词法推导出来的。由于我们还没有详细讨论`this`关键字，我们将把讨论推迟到本书的后面部分。
- en: Exercises
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Write a function that converts a hexadecimal color, for example blue (`#0000FF`),
    into its RGB representation, `rgb(0, 0, 255)`. Name your function `getRGB()` and
    test it with the following code (hint: treat the string as an array of characters):'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，将十六进制颜色（例如蓝色(`#0000FF`)）转换为其RGB表示形式，`rgb(0, 0, 255)`。将你的函数命名为`getRGB()`，并使用以下代码进行测试（提示：将字符串视为字符数组）：
- en: '[PRE97]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: What do each of these following lines print in the console?
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下每行代码在控制台中打印什么？
- en: '[PRE98]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: What does this following code alert?
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码会弹出什么？
- en: '[PRE99]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: All these following examples alert `"Boo!"`. Can you explain why?
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有以下示例都会弹出`"Boo!"`。你能解释为什么吗？
- en: 'Example 1:'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例1：
- en: '[PRE100]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Example 2:'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例2：
- en: '[PRE101]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Example 3:'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例3：
- en: '[PRE102]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Summary
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'You have now completed the introduction to the fundamental concepts related
    to functions in JavaScript. This has laid the groundwork that will allow you to
    quickly grasp the concepts of object-oriented JavaScript and the patterns used
    in modern JavaScript programming. So far, we''ve been avoiding the OO features,
    but as you have reached this point in the book, it''s only going to get more interesting
    from here on in. Let''s take a moment to review the topics discussed in this chapter:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经完成了与JavaScript中函数相关的基本概念的介绍。这为你快速掌握面向对象的JavaScript概念和现代JavaScript编程中使用的模式奠定了基础。到目前为止，我们一直在避免面向对象的特性，但是当你达到本书的这一部分时，从现在开始会变得更加有趣。让我们花一点时间回顾本章讨论的主题：
- en: The basics of how to define and invoke (call) a function using either a function
    declaration syntax or a function expression
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用函数声明语法或函数表达式定义和调用函数的基础知识
- en: Function parameters and their flexibility
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数及其灵活性
- en: Built-in functions-`parseInt()`, `parseFloat()`, `isNaN()`, `isFinite()`, and
    `eval()`-and the four functions to encode/decode a URL
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置函数-`parseInt()`、`parseFloat()`、`isNaN()`、`isFinite()`和`eval()`，以及四个编码/解码URL的函数
- en: The scope of variables in JavaScript-no curly braces scope, variables have only
    function scope and the scope chain
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript中的变量作用域-没有花括号作用域，变量只有函数作用域和作用域链
- en: 'Functions as data-a function is like any other piece of data that you assign
    to a variable and a lot of interesting applications follow from this, such as:'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为数据-函数就像你分配给变量的任何其他数据一样，这样会有很多有趣的应用程序，比如：
- en: Private functions and private variables
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有函数和私有变量
- en: Anonymous functions
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名函数
- en: Callbacks
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调
- en: Immediate functions
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即函数
- en: Functions overwriting themselves
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数覆盖自身
- en: Closures
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: Arrow functions
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数

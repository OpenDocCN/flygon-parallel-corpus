- en: Appendix E. Answers to Exercise Questions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录E. 练习问题的答案
- en: This appendix lists possible answers to the exercises at the end of the chapters.
    Possible answers meaning they are not the only ones, so don't worry if your solution
    is different.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录列出了章节末尾练习的可能答案。可能的答案意味着它们不是唯一的答案，所以如果您的解决方案不同，不要担心。
- en: As with the rest of the book, you should try them in your console and play around
    a bit.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书的其余部分一样，您应该在控制台中尝试并玩一下。
- en: The first and the last chapters don't have the *Exercises* section, so let's
    start with [Chapter 2](ch02.html "Chapter 2. Primitive Data Types, Arrays, Loops,
    and Conditions"), *Primitive Data Types, Arrays, Loops, and Conditions*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第一章和最后一章没有*练习*部分，所以让我们从[第2章](ch02.html "第2章。原始数据类型、数组、循环和条件")开始，*原始数据类型、数组、循环和条件*。
- en: Chapter 2, Primitive Data Types, Arrays, Loops, and Conditions
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章，原始数据类型、数组、循环和条件
- en: 'Lets try and solve the following exercises:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试解决以下练习：
- en: Exercises
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'The result will be as follows:'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果将如下：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When you declare a variable but do not initialize it with a value, it automatically
    gets the undefined value. You can also check:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当您声明一个变量但不用值初始化它时，它会自动获得未定义的值。您还可以检查：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The value of `v` will be:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`v`的值将是：'
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Adding `1` to the string `'1s'` returns the string `'1s1'`, which is *Not A
    Number*, but the `++` operator should return a number; so it returns the special
    `NaN` number.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字`1`添加到字符串`'1s'`中，返回字符串`'1s1'`，这是*不是一个数字*，但`++`运算符应该返回一个数字；所以它返回特殊的`NaN`数字。
- en: 'The program is as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 程序如下：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The tricky part of the question is that `"false"` is a string and all strings
    are `true` when cast to Booleans (except the empty string `""`). If the question
    wasn''t about the string `"false"` but the Boolean `false` instead, the double
    negation !! returns the same Boolean:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 问题的棘手部分在于`"false"`是一个字符串，所有字符串在转换为布尔值时都是`true`（除了空字符串`""`）。如果问题不是关于字符串`"false"`而是布尔值`false`，则双重否定!!将返回相同的布尔值：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you''d expect, single negation returns the opposite:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的，单个否定返回相反的值：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can test with any string and it will cast to a Boolean `true`, except the
    empty string:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以测试任何字符串，它都会转换为布尔值`true`，除了空字符串：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output after executing `undefined` is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`undefined`后的输出如下：
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here `undefined` is one of the falsy values and it casts to `false`. You can
    try with any of the other falsy values, such the empty string `""` in the previous
    example, `NaN`, or `0`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`undefined`是假值之一，它转换为`false`。您可以尝试任何其他假值，例如前面示例中的空字符串`""`，`NaN`或`0`。
- en: '[PRE8]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The number type includes all numbers, `NaN`, positive and negative `Infinity`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 数字类型包括所有数字、`NaN`、正数和负数`Infinity`。
- en: 'The output after executing the following is:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作后的输出是：
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The string `"0"` is cast to the number `0`. Division by `0` is `Infinity`, which
    has no remainder.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串`"0"`被转换为数字`0`。除以`0`得到`Infinity`，没有余数。
- en: 'The output after executing the following is:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作后的输出是：
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Comparison with `==` operator doesn''t check the types, but converts the operands;
    in this case both are falsy values. Strict comparison checks the types too:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与`==`运算符的比较不检查类型，但转换操作数；在这种情况下，两者都是假值。严格比较也检查类型：
- en: '[PRE11]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is the code line and its output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码行及其输出：
- en: '[PRE12]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Strict comparison between different types (in this case Boolean and string)
    is doomed to fail, no matter what the values are.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型之间的严格比较（在本例中是布尔值和字符串）注定会失败，无论值是什么。
- en: 'The following is the code line and its output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码行及其输出：
- en: '[PRE13]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Anything in quotes is a string, even though:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 引号中的任何内容都是字符串，尽管：
- en: '[PRE14]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following is the code line and its output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码行及其输出：
- en: '[PRE15]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`3e+3` is `3` with three zeroes, meaning `3000`. Then `++` is a post-increment,
    meaning it returns the old value and then it increments it and assigns it to `a`.
    That''s why you get the return value `3000` in the console, although `a` is now
    `3001`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`3e+3`是`3`加上三个零，意思是`3000`。然后`++`是后增量，意思是它返回旧值，然后增加它并将其分配给`a`。这就是为什么您在控制台中得到返回值`3000`，尽管`a`现在是`3001`：'
- en: '[PRE16]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The value of `v` after executing the following is:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下操作后的`v`的值是：
- en: '[PRE17]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If `v` has never been declared, it''s `undefined` so this is the same as:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`v`从未被声明过，则为`undefined`，因此这与以下内容相同：
- en: '[PRE18]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: However, if `v` has already been defined and initialized with a non-falsy value,
    you'll get the previous value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果`v`已经被定义并初始化为一个非假值，您将获得先前的值。
- en: '[PRE19]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The second use of `var` doesn't "reset" the variable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次使用`var`不会“重置”变量。
- en: If `v` was already a falsy value (not a `100`), the check `v || 10` will return
    `10`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`v`已经是一个假值（不是`100`），则检查`v || 10`将返回`10`。
- en: '[PRE20]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For printing multiplication tables, perform the following:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打印乘法表，请执行以下操作：
- en: '[PRE21]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Or:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '[PRE22]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Chapter 3, Functions
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章，函数
- en: 'Lets do the following exercises:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做以下练习：
- en: Exercises
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'To convert Hex colors to RGB, perform the following:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将十六进制颜色转换为RGB，请执行以下操作：
- en: '[PRE23]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: One problem with this solution is that array access to strings like `hex[0]`
    is not in ECMAScript 3, although many browsers have supported it for a long time
    and is now described in ES5.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案的一个问题是，像`hex[0]`这样的字符串数组访问不在ECMAScript 3中，尽管许多浏览器长期支持它，现在在ES5中也有描述。
- en: 'However, But at this point in the book, there was as yet no discussion of objects
    and methods. Otherwise an ES3-compatible solution would be to use one of the string
    methods, such as `charAt()`, `substring()`, or `slice()`. You can also use an
    array to avoid too much string concatenation:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在本书的这一部分，尚未讨论对象和方法。否则，符合ES3的解决方案将是使用字符串方法之一，例如`charAt()`、`substring()`或`slice()`。您还可以使用数组来避免太多的字符串连接：
- en: '[PRE24]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Bonus exercise**: Rewrite the preceding function using a loop so you don''t
    have to type `parseInt()` three times, but just once.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**奖励练习**：重写前面的函数，使用循环，这样您就不必三次输入`parseInt()`，而只需一次。'
- en: 'The result is as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE25]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, the parsing of a string gives up on the first non-integer value. `parseInt()`
    doesn''t understand exponential literals, it expects integer notation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，字符串的解析放弃了第一个非整数值。`parseInt()`不理解指数文字，它期望整数表示法：
- en: '[PRE26]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is parsing the string `''1e1''` while expecting it to be in decimal notation,
    including exponential:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解析字符串`'1e1'`，同时期望它是十进制表示法，包括指数：
- en: '[PRE27]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following is the code line and its output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码行及其输出：
- en: '[PRE28]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Because `0/10` is `0` and `0` is finite.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`0/10`是`0`，而`0`是有限的。
- en: 'The following is the code line and its output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码行及其输出：
- en: '[PRE29]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Because division by `0` is `Infinity`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因为除以`0`是`Infinity`：
- en: '[PRE30]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following is the code line and its output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码行及其输出：
- en: '[PRE31]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Parsing the special `NaN` value is `NaN`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 解析特殊的`NaN`值是`NaN`。
- en: 'What is the result of:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是结果：
- en: '[PRE32]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This snippet alerts `2` even though `n()` was defined before the assignment,
    `a = 2`. Inside the function `n()` you see the variable `a` that is in the same
    scope, and you access its most recent value at the time invocation of `f()` (and
    hence `n()`). Due to hoisting `f()` acts as if it was:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码警报`2`，即使`n()`在赋值`a = 2`之前被定义。在函数`n()`内部，你看到的是在相同作用域中的变量`a`，并且在调用`f()`（因此`n()`）时访问它的最新值。由于变量提升，`f()`的行为就像是：
- en: '[PRE33]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'More interestingly, consider this code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，考虑这段代码：
- en: '[PRE34]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It alerts `undefined` and then `2`. You might expect the first alert to say
    `1`, but again due to variable hoisting, the declaration (not initialization)
    of `a` is moved to the top of the function. As if `f()` was:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它警报`undefined`，然后是`2`。你可能期望第一个警报显示`1`，但由于变量提升，`a`的声明（而不是初始化）被移动到函数的顶部。就像`f()`是：
- en: '[PRE35]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The local `a` "shadows" the global `a`, even if it's at the bottom.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本地的`a`“遮蔽”了全局的`a`，即使它在底部。
- en: Why all these alert "Boo!"
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么所有这些警报都是“Boo!”
- en: 'The following is the result of Example 1:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例1的结果：
- en: '[PRE36]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following is the result of Example 2\. You can assign a function to a different
    variable. So `f()` points to `alert()`. Evaluating this string is like doing:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例2的结果。你可以将一个函数分配给另一个变量。所以`f()`指向`alert()`。评估这个字符串就像这样：
- en: '[PRE37]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following is the output after we execute `eval()`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们执行`eval()`之后，以下是输出：
- en: '[PRE38]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following is the output of Example 3\. `eval()` returns the result on the
    evaluation. In this case it''s an assignment `e = f` that also returns the new
    value of `e`. Like the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例3的输出。`eval()`返回评估的结果。在这种情况下，它是一个赋值`e = f`，也返回`e`的新值。就像下面这样：
- en: '[PRE39]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So `eval('e=f')` gives you a pointer to `alert()` that is executed immediately
    with `"Boo!"`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所以`eval('e=f')`给你一个指向`alert()`的指针，它立即执行带有`"Boo!"`的`alert()`。
- en: 'The immediate (self-invoking) anonymous function returns a pointer to the function
    `alert()`, which is also immediately invoked with a parameter `"Boo!"`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 立即（自调用）匿名函数返回对函数`alert()`的指针，然后立即用参数`"Boo!"`调用它：
- en: '[PRE40]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Chapter 4, Objects
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章，对象
- en: 'Lets solve the following exercises:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决以下练习：
- en: Exercises
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: What happens here? What is `this` and what's `o`?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里发生了什么？`this`是什么，`o`是什么？
- en: '[PRE41]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, `this === window` because `C()` was called without `new`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`this === window`，因为`C()`是在没有`new`的情况下调用的。
- en: Also `o === window` because `new F()` returns the object returned by `C()`,
    which is `this`, and `this` is `window`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`o === window`，因为`new F()`返回`C()`返回的对象，即`this`，而`this`是`window`。
- en: 'You can make the call to `C()` a constructor call:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将对`C()`的调用变成构造函数调用：
- en: '[PRE42]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here, `this` is the object created by the `C()` constructor. So is `o`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`this`是由`C()`构造函数创建的对象。`o`也是：
- en: '[PRE43]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It becomes more interesting with ES5''s strict mode. In the strict mode, non-constructor
    invocations result in `this` being `undefined`, not the global object. With `"use
    strict"` inside `F()` or `C()` constructor''s body, `this` would be `undefined`
    in `C()`. Therefore, `return C()` cannot return the non-object `undefined` (because
    all constructor invocations return some sort of object) and returns `F` instances''
    `this` (which is in the closure scope). Try it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES5的严格模式下会更有趣。在严格模式下，非构造函数调用会导致`this`为`undefined`，而不是全局对象。在`F()`或`C()`构造函数的主体内部使用`"use
    strict"`，`this`在`C()`中将是`undefined`。因此，`return C()`不能返回非对象的`undefined`（因为所有构造函数调用都返回某种对象），并返回`F`实例的`this`（在闭包范围内）。试试看：
- en: '[PRE44]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Testing:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 测试：
- en: '[PRE45]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: What happens when invoking this constructor with `new`?
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`new`调用这个构造函数会发生什么？
- en: '[PRE46]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`new C()` is an object, not Boolean, because constructor invocations always
    produce an object. It''s the `this` object you get unless you return some other
    object in your constructor. Returning non-objects doesn''t work and you still
    get `this`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`new C()`是一个对象，不是布尔值，因为构造函数调用总是产生一个对象。这是你得到的`this`对象，除非你在构造函数中返回其他对象。返回非对象是行不通的，你仍然得到`this`。'
- en: What does this do?
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是做什么？
- en: '[PRE47]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is because `sort()` compares strings. `[1, 2].toString()` is `"1,2"`, so
    it comes after `"1"` and before `"2"`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`sort()`比较字符串。`[1, 2].toString()`是`"1,2"`，所以它在`"1"`之后和`"2"`之前。
- en: 'The same thing with `join()`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`join()`也是一样的：
- en: '[PRE48]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Pretend `String()` doesn't exist and create `MyString()` mimicking `String()`.
    Treat the input primitive strings as arrays (array access officially supported
    in ES5).
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`String()`不存在，并创建模仿`String()`的`MyString()`。将输入的原始字符串视为数组（ES5中正式支持数组访问）。
- en: Here's a sample implementation with just the methods the exercise asked for.
    Feel free to continue with the rest of the methods. Refer to [Appendix C](apc.html
    "Appendix C. Built-in Objects"), *Built-in Objects* for the full list.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个只有练习要求的方法的示例实现。随意继续使用其他方法。参考[附录C](apc.html "附录 C. 内置对象")，*内置对象*，获取完整列表。
- en: '[PRE49]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Testing:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 测试：
- en: '[PRE50]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Feel free to play splitting with a regular expression.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 随意使用正则表达式进行拆分。
- en: 'Update `MyString()` with a `reverse()` method:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`reverse()`方法更新`MyString()`：
- en: '[PRE51]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Imagine `Array()` is gone and the world needs you to implement `MyArray()`.
    Here are a handful of methods to get you started:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想象`Array()`消失了，世界需要你实现`MyArray()`。以下是一些方法，让你开始：
- en: '[PRE52]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Testing:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 测试：
- en: '[PRE53]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If you found this exercise amusing, don't stop with `join()`; go on with as
    many methods as possible.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得这个练习有趣，不要停在`join()`上；尽可能多地使用方法。
- en: Create `MyMath` object that also has `rand()`, `min([])`, `max([])`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`MyMath`对象，它还具有`rand()`，`min([])`，`max([])`。
- en: The point here is that `Math` is not a constructor, but an object that has some
    "static" properties and methods. Below are some methods to get you started.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重点是`Math`不是一个构造函数，而是一个具有一些“静态”属性和方法的对象。以下是一些方法，供您开始使用。
- en: Let's also use an immediate function to keep some private utility functions.
    You can also take this approach with `MyString` above, where `this._value` could
    be really private.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用立即函数来保留一些私有实用函数。您也可以采用上面的`MyString`方法，在那里`this._value`可以真正是私有的。
- en: '[PRE54]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: After you have finished the book and know about ES5 you can try using `defineProperty()`
    for tighter control and closer replication of the built-ins.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在您完成本书并了解ES5之后，您可以尝试使用`defineProperty()`来更严格地控制和更接近内置对象的复制。
- en: Chapter 5, Prototype
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章，原型
- en: 'Lets try and solve the following exercise:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试解决以下练习：
- en: Exercises
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Create an object called `shape` that has a `type` property and a `getType()`
    method:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`shape`的对象，该对象具有`type`属性和`getType()`方法：
- en: '[PRE55]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The following is the program for a `Triangle ()` constructor:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是`Triangle()`构造函数的程序：
- en: '[PRE56]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To add the `getPerimeter()` method, use the following code:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加`getPerimeter()`方法，请使用以下代码：
- en: '[PRE57]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Test the following code:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试以下代码：
- en: '[PRE58]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Loop over `t` showing only own properties and methods:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历`t`，只显示自有属性和方法：
- en: '[PRE59]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Randomize array elements using the following code snippet:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码片段随机化数组元素：
- en: '[PRE60]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Testing:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 测试：
- en: '[PRE61]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Chapter 6, Inheritance
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章，继承
- en: 'Lets solve the following exercise:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决以下练习：
- en: Exercises
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Multiple inheritance by mixing into the prototype, for example:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过混合到原型中进行多重继承，例如：
- en: '[PRE62]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Testing:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 测试：
- en: '[PRE63]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Property `a` is `2` because `obj_b` overwrote the property with the same name
    from `obj_a` (last one wins):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 属性`a`是`2`，因为`obj_b`覆盖了与`obj_a`相同名称的属性（最后一个获胜）：
- en: '[PRE64]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Practice with the canvas example at [http://www.phpied.com/files/canvas/](http://www.phpied.com/files/canvas/).
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[http://www.phpied.com/files/canvas/](http://www.phpied.com/files/canvas/)上使用画布示例进行练习。
- en: 'Draw a few triangles using the following code snippet:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码片段绘制几个三角形：
- en: '[PRE65]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Draw a few squares using the following code snippet:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码片段绘制几个正方形：
- en: '[PRE66]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Draw a few rectangles using the following code snippet:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码片段绘制几个矩形：
- en: '[PRE67]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To add Rhombus, Kite, Pentagon, Trapezoid, and Circle (reimplements `draw()`),
    use the following code:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加菱形、风筝、五边形、梯形和圆（重新实现`draw()`），请使用以下代码：
- en: '[PRE68]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Testing:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 测试：
- en: '[PRE69]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '![Exercises](graphics/image_69_001.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![练习](graphics/image_69_001.jpg)'
- en: The result of testing new shapes
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 测试新形状的结果
- en: Think of another way to do the inheritance part. Use `uber` so kids can have
    access to their parents. Also, get parents to be aware of their children.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想出另一种继承的方法。使用`uber`让子类可以访问其父类。还要让父类意识到它们的子类。
- en: 'Keep in mind that not all children inherit `Shape`; for example, `Rhombus`
    inherits `Kite` and `Square` inherits `Rectangle`. You end up with something like
    this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，并非所有子类都继承`Shape`；例如，`Rhombus`继承`Kite`，`Square`继承`Rectangle`。您最终会得到类似这样的东西：
- en: '[PRE70]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In the inheritance pattern from the chapter and the previous exercise, all
    children were sharing the same prototype, for example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和上一个练习中的继承模式中，所有子类都共享相同的原型，例如：
- en: '[PRE71]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: While this is convenient, it also means no one can touch the prototype because
    it will affect everyone else's prototype. The drawback is that all custom methods
    need to own properties, for example `this.getArea`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很方便，但这也意味着没有人可以触及原型，因为这会影响其他人的原型。缺点是所有自定义方法都需要自有属性，例如`this.getArea`。
- en: It's a good idea to have methods shared among instances and defined in the prototype,
    instead of recreating them for every object. The following example moves the custom
    `getArea()` methods to the prototype.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将方法共享在实例之间，并在原型中定义，而不是为每个对象重新创建它们。以下示例将自定义的`getArea()`方法移动到原型中。
- en: 'In the inheritance function, you''ll see the children only inherit the parent''s
    prototype. So own properties such as `this.lines` will not be set. Therefore,
    you need to have each child constructor call its `uber` in order to get the own
    properties, for example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在继承函数中，您会看到子类只继承父类的原型。因此，诸如`this.lines`之类的自有属性将不会被设置。因此，您需要让每个子类构造函数调用其`uber`以获取自有属性，例如：
- en: '[PRE72]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Another nice-to-have feature is carrying over the prototype properties already
    added to the child. This allows the child to inherit first and then add more customizations
    or the other way around as well, which is just a little more convenient.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的功能是将已添加到子类的原型属性传递给子类。这允许子类首先继承，然后添加更多自定义或者反过来，这也更方便一些。
- en: '[PRE73]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Everything about `Shape()`, `Line()`, and `Point()` stays the same. The changes
    are in the children only:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shape()`，`Line()`和`Point()`的一切都保持不变。变化只发生在子类中：'
- en: '[PRE74]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Inheritance:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 继承：
- en: '[PRE75]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Testing:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 测试：
- en: '[PRE76]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Testing that `instanceof` is correct:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 测试`instanceof`是否正确：
- en: '[PRE77]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `children` arrays:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`children`数组：'
- en: '[PRE78]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'And uber looks ok too:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 并且`uber`看起来也不错：
- en: '[PRE79]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Calling `isPrototypeOf()` also returns expected results:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`isPrototypeOf()`也会返回预期的结果：
- en: '[PRE80]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The full code is available at [http://www.phpied.com/files/canvas/index2.html](http://www.phpied.com/files/canvas/index2.html),
    together with the additional `Kite()`, `Circle()`, and so on from the previous
    exercise.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可在[http://www.phpied.com/files/canvas/index2.html](http://www.phpied.com/files/canvas/index2.html)上找到，还有来自上一个练习的额外的`Kite()`，`Circle()`等。
- en: Chapter 7, The Browser Environment
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章，浏览器环境
- en: 'Lets practice the following exercise:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们练习以下练习：
- en: Exercises
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'The title clock program is as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标题时钟程序如下：
- en: '[PRE81]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To animate resizing of a 200 x 200 pop up to 400 x 400, use the following code:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要动画调整弹出窗口的大小从200 x 200到400 x 400，请使用以下代码：
- en: '[PRE82]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Every 100 ms (1/10th of a second) the pop-up size increases by five pixels.
    You keep a reference to the interval `i` so you can clear it once done. The variable
    `size` tracks the pop-up size (and why not keep it private inside a closure).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 每100毫秒（1/10秒），弹出窗口的大小增加五个像素。您保留对间隔`i`的引用，以便在完成后清除它。变量`size`跟踪弹出窗口的大小（为什么不在闭包内保持它私有）。
- en: 'The earthquake program is as follows:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 地震程序如下：
- en: '[PRE83]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Try all of them, but using `requestAnimationFrame()` instead of `setInterval()`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试所有这些，但使用`requestAnimationFrame()`而不是`setInterval()`。
- en: 'A different `walkDOM()` with a callback is as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带有回调的不同的`walkDOM()`如下：
- en: '[PRE84]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Testing:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 测试：
- en: '[PRE85]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'To remove content and clean up functions, use the following code:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除内容并清理函数，请使用以下代码：
- en: '[PRE86]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Testing:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 测试：
- en: '[PRE87]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'To include scripts dynamically, use the following code:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要动态包含脚本，请使用以下代码：
- en: '[PRE88]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Testing:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 测试：
- en: '[PRE89]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '**Events**: The event utility program is as follows:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**事件**：事件实用程序如下：'
- en: '[PRE90]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '**Testing**: Go to any page with links, execute the following, and then click
    any link:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试**：转到任何带有链接的页面，执行以下操作，然后单击任何链接：'
- en: '[PRE91]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Move a `div` around with the keyboard using the following code:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码使用键盘移动`div`：
- en: '[PRE92]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Your own Ajax utility:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你自己的Ajax实用程序：
- en: '[PRE93]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'When testing, remember that same origin restrictions apply, so you have to
    be on the same domain. You can go to [http://www.phpied.com/files/jinc/](http://www.phpied.com/files/jinc/),
    which is a directory listing and then test in the console:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试时，请记住相同的来源限制适用，因此您必须在相同的域上。您可以转到[http://www.phpied.com/files/jinc/](http://www.phpied.com/files/jinc/)，这是一个目录列表，然后在控制台中进行测试：
- en: '[PRE94]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The result of the two is the same, but if you look into the **Network** tab
    of the Web Inspector, you can see that the second is indeed a `POST` request with
    a body.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 两者的结果是相同的，但是如果您查看Web检查器的**网络**选项卡，您会发现第二个确实是带有主体的`POST`请求。

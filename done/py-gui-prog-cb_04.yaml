- en: Chapter 4. Data and Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。数据和类
- en: 'In this chapter, we will use data and OOP classes using Python 3:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Python 3来使用数据和OOP类：
- en: How to use StringVar()
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用StringVar()
- en: How to get data from a widget
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从小部件获取数据
- en: Using module-level global variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块级全局变量
- en: How coding in classes can improve the GUI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在类中编码可以改进GUI
- en: Writing callback functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写回调函数
- en: Creating reusable GUI components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可重用的GUI组件
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will save our GUI data into tkinter variables.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把GUI数据保存到tkinter变量中。
- en: We will also start using **object-oriented programming** (**OOP**) to extend
    the existing tkinter classes in order to extend tkinter's built-in functionality.
    This will lead us into creating reusable OOP components.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将开始使用**面向对象编程**（**OOP**）来扩展现有的tkinter类，以扩展tkinter的内置功能。这将使我们创建可重用的OOP组件。
- en: How to use StringVar()
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用StringVar()
- en: There are built-in programming types in tkinter that differ slightly from the
    Python types we are used to programming with. StringVar() is one of those tkinter
    types.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在tkinter中有一些内置的编程类型，它们与我们习惯用Python编程的类型略有不同。StringVar()就是这些tkinter类型之一。
- en: This recipe will show you how to use the StringVar() type.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将向您展示如何使用StringVar()类型。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are learning how to save data from the tkinter GUI into variables so we can
    use that data. We can set and get their values, very similar to the Java getter/setter
    methods.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在学习如何将tkinter GUI中的数据保存到变量中，以便我们可以使用这些数据。我们可以设置和获取它们的值，与Java的getter/setter方法非常相似。
- en: 'Here are some of the available types of coding in tkinter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是tkinter中可用的一些编码类型：
- en: '| `strVar = StringVar()` | # Holds a string; the default value is an empty
    string "" |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `strVar = StringVar()` | # 保存一个字符串；默认值是一个空字符串"" |'
- en: '| `intVar = IntVar()` | # Holds an integer; the default value is 0 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `intVar = IntVar()` | # 保存一个整数；默认值是0 |'
- en: '| `dbVar = DoubleVar()` | # Holds a float; the default value is 0.0 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `dbVar = DoubleVar()` | # 保存一个浮点数；默认值是0.0 |'
- en: '| `blVar = BooleanVar()` | # Holds a Boolean, it returns 0 for false and 1
    for true |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `blVar = BooleanVar()` | # 保存一个布尔值，对于false返回0，对于true返回1 |'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Different languages call numbers with decimal points, floats, or doubles. Tkinter
    calls a DoubleVar for what in Python is called a float datatype. Depending on
    the level of precision, floats and double data can be different. Here, we are
    translating the tkinter DoubleVar into what Python turns into a Python float type.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的语言称带有小数点的数字为浮点数或双精度数。Tkinter将Python中称为浮点数据类型的内容称为DoubleVar。根据精度级别，浮点数和双精度数据可能不同。在这里，我们将tkinter的DoubleVar翻译成Python中的Python浮点类型。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are creating a new Python module and the following screenshot shows both
    the code and the resulting output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个新的Python模块，下面的截图显示了代码和生成的输出：
- en: '![How to do it...](graphics/B04829_04_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_04_01.jpg)'
- en: First, we import the tkinter module and alias it to the name `tk`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入tkinter模块并将其别名为`tk`。
- en: Next, we use this alias to create an instance of the `Tk` class by appending
    parentheses to `Tk`, which calls the constructor of the class. This is the same
    mechanism as calling a function, only here we are creating an instance of a class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用这个别名通过在`Tk`后面加括号来创建`Tk`类的一个实例，这样就调用了类的构造函数。这与调用函数的机制相同，只是这里我们创建了一个类的实例。
- en: Usually we use this instance assigned to the variable `win` to start the main
    event loop later in the code. But here, we are not displaying a GUI but demonstrating
    how to use the tkinter StringVar type.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们使用分配给变量`win`的实例来在代码中稍后启动主事件循环。但是在这里，我们不显示GUI，而是演示如何使用tkinter的StringVar类型。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We still have to create an instance of `Tk()`. If we comment out this line,
    we will get an error from tkinter, so this call is necessary.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然必须创建`Tk()`的一个实例。如果我们注释掉这一行，我们将从tkinter得到一个错误，因此这个调用是必要的。
- en: Then we create an instance of the tkinter StringVar type and assign it to our
    Python `strData` variable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个tkinter StringVar类型的实例，并将其分配给我们的Python`strData`变量。
- en: After that, we use our variable to call the `set()` method on StringVar and,
    after having it set to a value, we then get the value and save it in a new variable
    named `varData` and then print out its value.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用我们的变量调用StringVar的`set()`方法，并在设置为一个值后，然后获取该值并将其保存在一个名为`varData`的新变量中，然后打印出它的值。
- en: In the Eclipse PyDev console, towards the bottom of the screenshot, we can see
    the output printed to the console, which is **Hello StringVar**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse PyDev控制台中，可以看到输出打印到控制台的底部，这是**Hello StringVar**。
- en: Next, we will print the default values of tkinter's IntVar, DoubleVar, and BooleanVar
    types.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将打印tkinter的IntVar、DoubleVar和BooleanVar类型的默认值。
- en: '![How to do it...](graphics/B04829_04_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_04_02.jpg)'
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As can be seen in the preceding screenshot, the default values do not get printed
    as we would have expected.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，默认值并没有像我们预期的那样被打印出来。
- en: The online literature mentions default values, but we won't see those values
    until we call the `get` method on them. Otherwise, we just get a variable name
    that automatically increments (for example PY_VAR3, as can be seen in the preceding
    screenshot).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在线文献提到了默认值，但在调用它们的`get`方法之前，我们不会看到这些值。否则，我们只会得到一个自动递增的变量名（例如在前面的截图中可以看到的PY_VAR3）。
- en: Assigning the tkinter type to a Python variable does not change the outcome.
    We still do not get the default value.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将tkinter类型分配给Python变量并不会改变结果。我们仍然没有得到默认值。
- en: 'Here, we are focusing on the simplest code (which creates PY_VAR0):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们专注于最简单的代码（创建PY_VAR0）：
- en: '![How it works...](graphics/B04829_04_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B04829_04_03.jpg)'
- en: The value is PY_VAR0, not the expected 0, until we call the `get` method. Now
    we can see the default value. We did not call `set`, so we see the default value
    automatically assigned to each tkinter type once we call the `get` method on each
    type.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 该值是PY_VAR0，而不是预期的0，直到我们调用`get`方法。现在我们可以看到默认值。我们没有调用`set`，所以一旦我们在每种类型上调用`get`方法，就会看到自动分配给每种tkinter类型的默认值。
- en: '![How it works...](graphics/B04829_04_04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B04829_04_04.jpg)'
- en: Notice how the default value of 0 gets printed to the console for the `IntVar`
    instance we saved in the `intData` variable. We can also see the values in the
    Eclipse PyDev debugger window at the top of the screenshot.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`IntVar`实例的默认值为0被打印到控制台，我们将其保存在`intData`变量中。我们还可以在屏幕截图的顶部看到Eclipse PyDev调试器窗口中的值。
- en: How to get data from a widget
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何从小部件中获取数据
- en: When the user enters data, we want to do something with it in our code. This
    recipe shows how to capture data in a variable. In the previous recipe, we created
    several tkinter class variables. They were standalone. Now we are connecting them
    to our GUI, using the data we get from the GUI and storing it in Python variables.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入数据时，我们希望在我们的代码中对其进行处理。这个配方展示了如何在变量中捕获数据。在上一个配方中，我们创建了几个tkinter类变量。它们是独立的。现在我们正在将它们连接到我们的GUI，使用我们从GUI中获取的数据并将其存储在Python变量中。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are continuing to use the Python GUI we were building in the previous chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用我们在上一章中构建的Python GUI。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We are assigning a value from our GUI to a Python variable.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将来自我们的GUI的值分配给一个Python变量。
- en: 'Add the following code towards the bottom of our module, just above the main
    event loop:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模块底部，就在主事件循环之上，添加以下代码：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Running the code gives us the following result:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会给我们以下结果：
- en: '![How to do it...](graphics/B04829_04_05.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_04_05.jpg)'
- en: We are retrieving the current value of the `Spinbox` control.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在检索`Spinbox`控件的当前值。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We placed our code above the GUI main event loop and so the printing happens
    before the GUI becomes visible. We would have to place the code in a callback
    function if we wanted to print out the current value after displaying the GUI
    and changing the value of the `Spinbox` control.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的代码放在GUI主事件循环之上，因此打印发生在GUI变得可见之前。如果我们想要在显示GUI并改变`Spinbox`控件的值之后打印出当前值，我们将不得不将代码放在回调函数中。
- en: 'We created our Spinbox widget using the following code, hard-coding the available
    values into it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码创建了我们的Spinbox小部件，将可用值硬编码到其中：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can also move the hard-coding of the data out of the creation of the `Spinbox`
    class instance and set it later.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将数据的硬编码从`Spinbox`类实例的创建中移出，并稍后设置它。
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It does not matter how we create our widget and insert data into it because
    we can access this data by using the `get()` method on the instance of the widget.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们如何创建小部件并将数据插入其中，因为我们可以通过在小部件实例上使用`get()`方法来访问这些数据，所以我们可以访问这些数据。
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order to get values out of our GUI written using tkinter, we use the tkinter
    `get()` method on an instance of the widget we wish to get the value from.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从使用tkinter编写的GUI中获取值，我们使用tkinter的`get()`方法来获取我们希望获取值的小部件的实例。
- en: In the above example we used the Spinbox control, but the principle is the same
    for all widgets that have a `get()` method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们使用了Spinbox控件，但对于所有具有`get()`方法的小部件，原理是相同的。
- en: Once we have gotten the data, we are in a pure Python world and tkinter did
    serve us to build our GUI. Now that we know how to get the data out of our GUI,
    we can use this data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了数据，我们就处于一个纯粹的Python世界，而tkinter确实帮助我们构建了我们的GUI。现在我们知道如何从我们的GUI中获取数据，我们可以使用这些数据。
- en: Using module-level global variables
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块级全局变量
- en: Encapsulation is a major strength in any programming language that enables us
    to program using OOP. Python is both OOP and procedural. We can create global
    variables that are localized to the module they reside in. They are global only
    to this module, which is one form of encapsulation. Why do we want this? Because,
    as we add more and more functionality to our GUI, we want to avoid naming conflicts,
    which could result in bugs in our code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是任何编程语言中的一个主要优势，它使我们能够使用OOP进行编程。Python既是OOP又是过程化的。我们可以创建局部化到它们所在模块的全局变量。它们只对这个模块全局，这是一种封装的形式。为什么我们想要这样做？因为随着我们向我们的GUI添加越来越多的功能，我们希望避免命名冲突，这可能导致我们代码中的错误。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We do not want naming clashes creating bugs in our code! Namespaces are one
    way to avoid these bugs, and in Python, we can do this by using Python modules
    (which are unofficial namespaces).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望命名冲突在我们的代码中创建错误！命名空间是避免这些错误的一种方法，在Python中，我们可以通过使用Python模块（这些是非官方的命名空间）来实现这一点。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We can declare module-level globals in any module just above and outside of
    functions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何模块的顶部和函数之外声明模块级全局变量。
- en: We then have to use the `global` Python keyword to refer to them. If we forget
    to use `global` in functions, we will accidentally create new local variables.
    This would be a bug and something we really do not want to do.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们必须使用`global` Python关键字来引用它们。如果我们在函数中忘记使用`global`，我们将意外创建新的局部变量。这将是一个错误，而且是我们真的不想做的事情。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Python is a dynamic, strongly typed language. We will only notice bugs like
    this (forgetting to scope variables with the global keyword) at runtime.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种动态的、强类型的语言。我们只会在运行时注意到这样的错误（忘记使用全局关键字来限定变量的范围）。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Add the code shown on line 15 to the GUI we used in the previous recipe and
    the last chapter, which creates a module-level global variable. We use the C-style
    all uppercase convention, which is not truly "Pythonic" but I think this does
    emphasize the principle we are addressing in this recipe.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将第15行中显示的代码添加到我们在上一章和上一章中使用的GUI中，这将创建一个模块级的全局变量。我们使用了C风格的全大写约定，这并不真正“Pythonic”，但我认为这确实强调了我们在这个配方中要解决的原则。
- en: '![How to do it...](graphics/B04829_04_06.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_04_06.jpg)'
- en: Running the code results in a printout of the global. Notice **42** being printed
    to the Eclipse console.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会导致全局变量的打印。注意**42**被打印到Eclipse控制台。
- en: '![How to do it...](graphics/B04829_04_07.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_04_07.jpg)'
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We define a global variable at the top of our module and, later, towards the
    bottom of our module, we print out its value.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的模块顶部定义一个全局变量，稍后，在我们的模块底部，我们打印出它的值。
- en: That works.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 那起作用。
- en: 'Add this function towards the bottom of our module:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模块底部添加这个函数：
- en: '![How it works...](graphics/B04829_04_08.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B04829_04_08.jpg)'
- en: 'Above, we are using the module-level global. It is easy to make a mistake by
    shadowing the `global`, as demonstrated in the following screenshot:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，我们正在使用模块级全局变量。很容易出错，因为`global`被遮蔽，如下面的屏幕截图所示：
- en: '![How it works...](graphics/B04829_04_09.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B04829_04_09.jpg)'
- en: Note how `42` became `777`, even though we are using the same variable name.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使我们使用相同的变量名，`42`也变成了`777`。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is no compiler in Python that warns us if we overwrite global variables
    in a local function. This can lead to difficulties in debugging at runtime.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Python中没有编译器警告我们在本地函数中覆盖全局变量。这可能导致在运行时调试时出现困难。
- en: 'Using the global qualifier (line 234) prints out the value we originally assigned
    it (42) towards the top of our module, as can be seen in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全局限定符（第234行）打印出我们最初分配的值（42），如下面的屏幕截图所示：
- en: '![How it works...](graphics/B04829_04_10.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B04829_04_10.jpg)'
- en: 'But, be careful. When we uncomment the local global, we print out the value
    of the local, not the global:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，要小心。当我们取消本地全局时，我们打印出本地的值，而不是全局的值：
- en: '![How it works...](graphics/B04829_04_11.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B04829_04_11.jpg)'
- en: Even though we are using the `global` qualifier, the local variable seems to
    override it. We are getting a warning from the Eclipse PyDev plug-in that our
    `GLOBAL_CONST = 777` is not being used, yet running the code still prints 777
    instead of the expected 42.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们使用了`global`限定符，但本地变量似乎会覆盖它。我们从Eclipse PyDev插件中得到了一个警告，即我们的`GLOBAL_CONST
    = 777`没有被使用，但运行代码仍然打印出777，而不是预期的42。
- en: This might not be the behavior we expect. Using the `global` qualifier we might
    expect that we are pointing to the global variable created earlier.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是我们期望的行为。使用`global`限定符，我们可能期望指向先前创建的全局变量。
- en: Instead, it seems that Python creates a new global variable in a local function
    and overwrites the one we created earlier.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，似乎Python在本地函数中创建了一个新的全局变量，并覆盖了我们之前创建的全局变量。
- en: Global variables can be very useful when programming small applications. They
    can help to make data available across methods and functions within the same Python
    module and sometimes the overhead of OOP is not justified.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量在编写小型应用程序时非常有用。它们可以帮助在同一Python模块中的方法和函数之间共享数据，并且有时OOP的开销是不合理的。
- en: As our programs grow in complexity, the benefit we gained from using globals
    can quickly diminish.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的程序变得越来越复杂，使用全局变量所获得的好处很快就会减少。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is best to avoid globals and accidentally shadowing variables by using the
    same name in different scopes. We can use OOP instead of using globals.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最好避免使用全局变量，并通过在不同范围中使用相同的名称而意外地遮蔽变量。我们可以使用面向对象编程来代替使用全局变量。
- en: We played around with global variables within procedural code and learned how
    that can lead to hard-to-debug bugs. In the next chapter, we will move on to OOP,
    which can eliminate these kinds of bugs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在过程化代码中玩了全局变量，并学会了如何导致难以调试的错误。在下一章中，我们将转向面向对象编程，这可以消除这些类型的错误。
- en: How coding in classes can improve the GUI
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在类中编码可以改进GUI
- en: So far, we have been coding in a procedural style. This is a quick scripting
    method from Python. Once our code gets larger and larger, we need to advance to
    coding in OOP.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在以过程化的方式编码。这是来自Python的一种快速脚本化方法。一旦我们的代码变得越来越大，我们就需要进步到面向对象编程。
- en: Why?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？
- en: Because, among many other benefits, OOP allows us to move code around by using
    methods. Once we use classes, we no longer have to physically place code above
    the code that calls it. This gives us great flexibility in organizing our code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因为，除了许多其他好处之外，面向对象编程允许我们通过使用方法来移动代码。一旦我们使用类，我们就不再需要在调用代码的代码上方物理放置代码。这使我们在组织代码方面具有很大的灵活性。
- en: We can write related code next to other code and no longer have to worry that
    the code will not run because the code does not sit above the code that calls
    it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将相关代码写在其他代码旁边，不再担心代码不会运行，因为代码不在调用它的代码上方。
- en: We can take that to some rather fancy extremes by coding up modules that refer
    to methods that are not being created within that module. They rely on the runtime
    state having created those methods during the time the code runs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过编写引用未在该模块中创建的方法的模块来将其推向一些相当花哨的极端。它们依赖于运行时状态在代码运行时创建了这些方法。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the methods we call have not been created by that time, we get a runtime
    error.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用的方法在那时还没有被创建，我们会得到一个运行时错误。
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will turn our entire procedural code into OOP very simply. We just turn it
    into a class, indent all the existing code, and prepend `self` to all variables.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将整个过程化代码简单地转换为面向对象编程。我们只需将其转换为一个类，缩进所有现有代码，并在所有变量之前添加`self`。
- en: It is very easy.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常容易。
- en: While at first it might feel a little bit annoying having to prepend everything
    with the `self` keyword, making our code more verbose (hey, we are wasting so
    much paper…); in the end, it will be worth it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然起初可能感觉有点烦人，必须在所有东西之前加上`self`关键字，使我们的代码更冗长（嘿，我们浪费了这么多纸...）；但最终，这将是值得的。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In the beginning, all hell breaks loose, but we will very soon fix this apparent
    mess.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，一切都乱了，但我们很快就会解决这个明显的混乱。
- en: Note that, in Eclipse, the PyDev editor hints at coding problems by highlighting
    them in red on the right-side portion of the code editor.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在Eclipse中，PyDev编辑器通过在代码编辑器的右侧部分将其标记为红色来提示编码问题。
- en: Maybe we should not code in OOP after all, but this is what we do, and for very
    good reasons.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们毕竟不应该使用面向对象编程，但这就是我们所做的，而且理由非常充分。
- en: '![How to do it...](graphics/B04829_04_12.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_04_12.jpg)'
- en: We just have to prepend all variables with the `self` keyword and also bind
    the functions to the class by using `self`, which officially and technically turns
    the functions into methods.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需使用`self`关键字在所有变量之前添加，并通过使用`self`将函数绑定到类中，这样官方和技术上将函数转换为方法。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is a difference between functions and methods. Python makes this very
    clear. Methods are bound to a class while functions are not. We can even mix the
    two within the same Python module.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和方法之间有区别。Python非常清楚地表明了这一点。方法绑定到一个类，而函数则没有。我们甚至可以在同一个Python模块中混合使用这两种方法。
- en: Let's prefix everything with `self` to get rid of the red, so we can run our
    code again.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`self`作为前缀来消除红色，这样我们就可以再次运行我们的代码。
- en: '![How to do it...](graphics/B04829_04_13.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_04_13.jpg)'
- en: Once we do this for all of the errors highlighted in red, we can run our Python
    code again.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对所有在红色中突出显示的错误做了这些，我们就可以再次运行我们的Python代码。
- en: The `clickMe` function is now bound to the class and has officially become a
    method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`clickMe`函数现在绑定到类上，正式成为一个方法。'
- en: Unfortunately, starting in a procedural way and then translating it into OOP
    is not as simple as I stated above. The code became a huge mess. This is a very
    good reason to start programming in Python using the OOP paradigm.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，以过程式方式开始，然后将其转换为面向对象的方式并不像我上面说的那么简单。代码变得一团糟。这是以面向对象的方式开始编程的一个很好的理由。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Python is good at doing things the easy way. The easy code often becomes more
    complex (because it was easy to begin with). Once we get too complex, refactoring
    our procedural code into what truly could be OOP code becomes harder with every
    single line of code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Python擅长以简单的方式做事。简单的代码通常变得更加复杂（因为一开始很容易）。一旦变得过于复杂，将我们的过程式代码重构为真正的面向对象的代码变得越来越困难。
- en: We are translating our procedural code into object-oriented code. Looking at
    all the troubles we got ourselves into, translating only 200+ lines of Python
    code into OOP could suggest that we might as well start coding in OOP from the
    beginning.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将我们的过程式代码转换为面向对象的代码。看看我们陷入的所有麻烦，仅仅将200多行的Python代码转换为面向对象的代码可能表明，我们可能最好从一开始就开始使用面向对象的方式编码。
- en: We actually did break some of our previously working functionality. Using Tab
    2 and clicking the radio buttons no longer works. We have to refactor more.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们确实破坏了一些之前工作正常的功能。现在无法使用Tab 2和点击单选按钮了。我们必须进行更多的重构。
- en: The procedural code was easy in the sense that it was simply top to bottom coding.
    Now that we have placed our code into a class, we have to move all callback functions
    into methods. This works, but does take some work to translate our original code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 过程式代码之所以容易，是因为它只是从上到下的编码。现在我们把我们的代码放入一个类中，我们必须把所有的回调函数移到方法中。这样做是可以的，但确实需要一些工作来转换我们的原始代码。
- en: 'Our procedural code looked like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的过程式代码看起来像这样：
- en: '[PRE3]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We moved the callback methods to the top of the module, inside the new OOP class.
    We moved all the widget creation code into one rather long method, which we call
    in the initializer of the class.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回调方法移到模块顶部，放在新的面向对象类内部。我们将所有的部件创建代码放入一个相当长的方法中，在类的初始化器中调用它。
- en: Technically, deep underneath the hood of low-level code, Python does have a
    constructor, yet Python frees us from any worries about this. It is taken care
    of for us.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，在低级代码的深处，Python确实有一个构造函数，但Python让我们摆脱了对此的任何担忧。这已经为我们处理了。
- en: Instead, in addition to a "real" constructor, Python provides us with an initializer.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，除了一个“真正的”构造函数之外，Python还为我们提供了一个初始化器。
- en: We are strongly encouraged to use this initializer. We can use it to pass in
    parameters to our class, initializing variables we wish to use inside of our class
    instance.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议使用这个初始化器。我们可以用它来向我们的类传递参数，初始化我们希望在类实例内部使用的变量。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Python, several classes can exist within the same Python module.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，同一个Python模块中可以存在多个类。
- en: Unlike Java, which has a very rigid naming convention (without which it does
    not work), Python is much more flexible.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java不同，它有一个非常严格的命名约定（没有这个约定它就无法工作），Python要灵活得多。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can create multiple classes within the same Python module. Unlike Java, we
    do not depend on a file name that has to match each class name.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在同一个Python模块中创建多个类。与Java不同，我们不依赖于必须与每个类名匹配的文件名。
- en: Python truly rocks!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Python真的很棒！
- en: Once our Python GUI gets large, we will break some classes out into their own
    modules but, unlike Java, we do not have to. In this book and project, we will
    keep some classes in the same module, while at the same time, we will break out
    some other classes into their own modules, importing them into what can be considered
    as a main() function (this is not C, but we can think C-like because Python is
    very flexible).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的Python GUI变得庞大，我们将把一些类拆分成它们自己的模块，但与Java不同，我们不必这样做。在这本书和项目中，我们将保持一些类在同一个模块中，同时，我们将把一些其他类拆分成它们自己的模块，将它们导入到可以被认为是一个main()函数的地方（这不是C，但我们可以像C一样思考，因为Python非常灵活）。
- en: What we have achieved so far is to add the `ToolTip` class to our Python module
    and refactor our procedural Python code into OOP Python code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的是将`ToolTip`类添加到我们的Python模块中，并将我们的过程式Python代码重构为面向对象的Python代码。
- en: Here, in this recipe, we can see that more than one class can live in the same
    Python module.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在这个示例中，我们可以看到一个Python模块中可以存在多个类。
- en: Cool stuff, indeed!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 确实很酷！
- en: '![How to do it...](graphics/B04829_04_14.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_04_14.jpg)'
- en: Both the `ToolTip` class and the `OOP` class reside within the same Python module.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToolTip`类和`OOP`类都驻留在同一个Python模块中。'
- en: '![How to do it...](graphics/B04829_04_15.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_04_15.jpg)'
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we advanced our procedural code into object-oriented-programming
    (OOP) code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将我们的过程式代码推进到面向对象编程（OOP）代码。
- en: Python enables us to write code in both a practical, procedural style like the
    C-programming language.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Python使我们能够以实用的过程式风格编写代码，就像C编程语言一样。
- en: At the same time, we have the option to code in an OOP style, like Java, C#,
    and C++.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我们有选择以面向对象的方式编码，就像Java、C#和C++一样。
- en: Writing callback functions
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写回调函数
- en: At first, callback functions can seem to be a little bit intimidating. You call
    the function, passing it some arguments, and now the function tells you that it
    is really very busy and it will call you back!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，回调函数可能看起来有点令人生畏。您调用函数，传递一些参数，现在函数告诉您它真的很忙，会回电话给您！
- en: 'You wonder: "Will this function *ever* call me back?" "And how long do I have
    to *wait*?"'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你会想：“这个函数会*永远*回调我吗？”“我需要*等*多久？”
- en: In Python, even callback functions are easy and, yes, they usually do call you
    back.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，即使回调函数也很容易，是的，它们通常会回调你。
- en: They just have to complete their assigned task first (hey, it was you who coded
    them in the first place…).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 它们只需要先完成它们分配的任务（嘿，是你编码它们的第一次...）。
- en: Let us understand a little bit more about what happens when we code callbacks
    into our GUI.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更多地了解一下当我们将回调编码到我们的GUI中时会发生什么。
- en: Our GUI is event-driven. After it has been created and displayed onscreen, it
    typically sits there waiting for an event to happen. It is basically waiting for
    an event to be sent to it. We can send an event to our GUI by clicking one of
    its action buttons.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的GUI是事件驱动的。在创建并显示在屏幕上之后，它通常会等待事件发生。它基本上在等待事件被发送到它。我们可以通过点击其动作按钮之一来向我们的GUI发送事件。
- en: This creates an event and, in a sense, we "called" our GUI by sending it a message.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个事件，并且在某种意义上，我们通过发送消息“调用”了我们的GUI。
- en: Now, what is supposed to happen after we send a message to our GUI?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们发送消息到我们的GUI后应该发生什么？
- en: What happens after clicking the button depends on whether we created an event
    handler and associated it with this button. If we did not create an event handler,
    clicking the button will have no effect.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮后发生的事情取决于我们是否创建了事件处理程序并将其与此按钮关联。如果我们没有创建事件处理程序，点击按钮将没有任何效果。
- en: The event handler is a callback function (or method, if we use classes).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序是一个回调函数（或方法，如果我们使用类）。
- en: The callback method is also sitting there passively, like our GUI, waiting to
    be invoked.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 回调方法也是被动的，就像我们的GUI一样，等待被调用。
- en: Once our GUI gets its button clicked, it will invoke the callback.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的GUI被点击按钮，它将调用回调函数。
- en: The callback often does some processing and, when done, it returns the result
    to our GUI.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 回调通常会进行一些处理，完成后将结果返回给我们的GUI。
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In a sense, we can see that our callback function is calling back to our GUI.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，我们可以看到我们的回调函数在回调我们的GUI。
- en: Getting ready
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The Python interpreter runs through all the code in a project once, finding
    any syntax errors and pointing them out. You cannot run your Python code if you
    do not have the syntax right. This includes indentation (if not resulting in a
    syntax error, wrong indentation usually results in a bug).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Python解释器会运行项目中的所有代码一次，找到任何语法错误并指出它们。如果语法不正确，您无法运行Python代码。这包括缩进（如果不导致语法错误，错误的缩进通常会导致错误）。
- en: On the next parsing round, the interpreter interprets our code and runs it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一轮解析中，解释器解释我们的代码并运行它。
- en: At runtime, many GUI events can be generated and it is usually callback functions
    that add functionality to GUI widgets.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，可以生成许多GUI事件，通常是回调函数为GUI小部件添加功能。
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here is the callback for the Spinbox widget:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Spinbox小部件的回调：
- en: '![How to do it...](graphics/B04829_04_16.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_04_16.jpg)'
- en: How it works...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We created a callback method in the `OOP` class, which gets called when we select
    a value from the Spinbox widget because we bound the method to the widget via
    the `command` argument (`command=self._spin`). We use a leading underscore to
    hint at the fact that this method should be respected like a private Java method.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`OOP`类中创建了一个回调方法，当我们从Spinbox小部件中选择一个值时，它会被调用，因为我们通过`command`参数（`command=self._spin`）将该方法绑定到小部件。我们使用下划线前缀来暗示这个方法应该像一个私有的Java方法一样受到尊重。
- en: Python intentionally avoids language restrictions such as private, public, friend,
    and so on.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Python故意避免了私有、公共、友好等语言限制。
- en: In Python, we use naming conventions instead. Leading and trailing double underscores
    surrounding a keyword are expected to be restricted to the Python language, and
    we should not use them in our own Python code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们使用命名约定。预期用双下划线包围关键字的前后缀应该限制在Python语言中，我们不应该在我们自己的Python代码中使用它们。
- en: However, we can use a leading underscore prefix to a variable name or function
    to provide a hint that this name should be respected as a private helper.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们可以使用下划线前缀来提供一个提示，表明这个名称应该被视为私有助手。
- en: 'At the same time, we can postfix a single underscore if we wish to use what
    otherwise would be Python built-in names. For example, if we wished to abbreviate
    the length of a list, we could do the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，如果我们希望使用本来是Python内置名称的名称，我们可以在后面加上一个下划线。例如，如果我们希望缩短列表的长度，我们可以这样做：
- en: '[PRE4]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Often, the underscore is hard to read and easy to oversee, so this might not
    be the best idea in practice.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，下划线很难阅读，容易忽视，因此在实践中这可能不是最好的主意。
- en: Creating reusable GUI components
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可重用的GUI组件
- en: We are creating reusable GUI components using Python.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Python创建可重用的GUI组件。
- en: In this recipe, we will keep it simple by moving our `ToolTip` class into its
    own module. Next, we will import and use it for displaying tooltips over several
    widgets of our GUI.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将简化操作，将我们的`ToolTip`类移动到其自己的模块中。接下来，我们将导入并在GUI的几个小部件上使用它来显示工具提示。
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We are building on our previous code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建我们之前的代码。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will start by breaking out our `ToolTip` class into a separate Python module.
    We will slightly enhance it to pass in the control widget and the tooltip text
    we wish to display when we hover the mouse over the control.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将我们的`ToolTip`类拆分为一个单独的Python模块。我们将稍微增强它，以便传入控件小部件和我们希望在悬停鼠标在控件上时显示的工具提示文本。
- en: We create a new Python module and place the `ToolTip` class code into it and
    then import this module into our primary module.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的Python模块，并将`ToolTip`类代码放入其中，然后将此模块导入我们的主要模块。
- en: We then reuse the imported `ToolTip` class by creating several tooltips, which
    can be seen when hovering the mouse over several of our GUI widgets.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过创建几个工具提示来重用导入的`ToolTip`类，当鼠标悬停在几个GUI小部件上时可以看到它们。
- en: Refactoring our common `ToolTip` class code out into its own module helps us
    to reuse this code from other modules. Instead of copy/paste/modify we use the
    DRY principle and our common code is located in only one place, so when we modify
    the code, all modules that import it will automatically get the latest version
    of our module.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们通用的`ToolTip`类代码重构到自己的模块中有助于我们重用这些代码。我们使用DRY原则，将我们的通用代码放在一个地方，这样当我们修改代码时，导入它的所有模块将自动获得我们模块的最新版本，而不是复制/粘贴/修改。
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: DRY stands for Don't Repeat Yourself and we will look at it again in a later
    chapter.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: DRY代表不要重复自己，我们将在以后的章节中再次讨论它。
- en: We can do similar things by turning our Tab3 image into a reusable component.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将选项卡3的图像转换为可重用组件来做类似的事情。
- en: To keep this recipe's code simple, we removed Tab 3, but you can experiment
    with the code from the previous chapter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持本示例的代码简单，我们删除了选项卡3，但您可以尝试使用上一章的代码进行实验。
- en: '![How to do it...](graphics/B04829_04_17.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_04_17.jpg)'
- en: '[PRE5]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This also works on the second tab.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于第二个选项卡。
- en: '![How to do it...](graphics/B04829_04_18.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_04_18.jpg)'
- en: 'The new code structure looks like this now:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 新的代码结构现在看起来像这样：
- en: '![How to do it...](graphics/B04829_04_19.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_04_19.jpg)'
- en: 'The import statement looks like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 导入语句如下所示：
- en: '![How to do it...](graphics/B04829_04_20.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_04_20.jpg)'
- en: 'And the broken out (aka refactored) code in a separate module looks like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 而在单独的模块中分解（重构）的代码如下所示：
- en: '![How to do it...](graphics/B04829_04_21.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_04_21.jpg)'
- en: How it works...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the preceding screenshots, we can see several tooltip messages being displayed.
    The one for the main window might appear a little bit annoying, so it is better
    not to display a tooltip for the main window because we really wish to highlight
    the functionality of the individual widgets. The main window form has a title
    that explains its purpose; no need for a tooltip.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到显示了几条工具提示消息。主窗口的工具提示可能有点烦人，所以最好不要为主窗口显示工具提示，因为我们真的希望突出显示各个小部件的功能。主窗体有一个解释其目的的标题；不需要工具提示。

- en: Thread-Based Parallelism
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于线程的并行性
- en: Currently, the most widely used programming paradigm for the management of concurrency
    in software applications is based on multithreading. Generally, an application
    is made by a single processthat is divided into multiple independent threads,
    which represent activities of different types that run in paralleland compete
    with each other.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在软件应用程序中管理并发的最广泛使用的编程范式是基于多线程的。通常，一个应用程序由一个被分成多个独立线程的单一进程组成，这些线程代表不同类型的活动，以并行方式运行并相互竞争。
- en: Nowadays, modern applications that use multithreading have been adopted on a
    massive scale. In fact, all current processors are multicore, just so they can
    perform parallel operations and exploit the computer's computational resources.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，使用多线程的现代应用程序已经被大规模采用。事实上，所有当前的处理器都是多核的，这样它们可以执行并行操作并利用计算机的计算资源。
- en: Hence, *multithreaded programming*is definitely a good way to achieve concurrent
    applications. However, multithreaded programming often hides some non-trivial
    difficulties, which must be managed appropriately to avoid errors such as deadlocksor synchronization
    issues.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*多线程编程*绝对是实现并发应用程序的一种好方法。然而，多线程编程经常隐藏一些非常规的困难，必须适当地管理以避免出现死锁或同步问题等错误。
- en: We will first define the concepts of thread-based and multithreaded programming
    and then introduce the `multithreading` library. We will learn about the main
    directives for thread definition, management, and communication.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义基于线程和多线程编程的概念，然后介绍`multithreading`库。我们将学习关于线程定义、管理和通信的主要指令。
- en: Through the `multithreading` library, we will see how to solve problems through
    different techniques, such as*lock*, *RLock*, *semaphores*, *condition*, *event*, *barrier, *and
    *queue*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`multithreading`库，我们将看到如何通过不同的技术解决问题，例如*锁*、*RLock*、*信号量*、*条件*、*事件*、*屏障*和*队列*。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: What is a thread?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是线程？
- en: How to define a thread
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何定义线程
- en: How to determine the current thread
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确定当前线程
- en: How to use a thread in a subclass
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在子类中使用线程
- en: Thread synchronization with a lock
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用锁进行线程同步
- en: Thread synchronization with an RLock
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RLock进行线程同步
- en: Thread synchronization with semaphores
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用信号量进行线程同步
- en: Thread synchronization with a condition
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用条件进行线程同步
- en: Thread synchronization with an event
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件进行线程同步
- en: Thread synchronization with a barrier
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用屏障进行线程同步
- en: Thread communication using a queue
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用队列进行线程通信
- en: We will also explore the main options offered by Python to program with threads.
    To do this, we will focus on using the `threading` module.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨Python提供的主要线程编程选项。为此，我们将专注于使用`threading`模块。
- en: What is a thread?
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是线程？
- en: A *thread* is an independent execution flow that can be executed in parallel
    and concurrently with other threads in the system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*线程*是一个独立的执行流，可以与系统中的其他线程并行和并发执行。'
- en: Multiple threads can share data and resources, taking advantage of the so-called
    space of shared information. The specific implementation of threads and processes
    depends on the OS on which you plan to run the application, but, in general, it
    can be stated that a thread is contained inside a process and that different threads
    in the same process conditions share some resources. In contrast to this, different
    processes do not share their own resources with other processes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 多个线程可以共享数据和资源，利用所谓的共享信息空间。线程和进程的具体实现取决于您计划运行应用程序的操作系统，但是一般来说，可以说线程包含在进程内，并且同一进程中的不同线程条件共享一些资源。相比之下，不同进程不与其他进程共享自己的资源。
- en: 'A thread is composed of three elements: program counters, registers, and stack.
    Shared resources with other threads of the same process essentially include *data*
    and *OS resources*. Moreover, threads have their own state of execution, namely,
    *thread state*, and can be *synchronized* with other threads.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 线程由三个元素组成：程序计数器、寄存器和堆栈。与同一进程的其他线程共享的资源主要包括*数据*和*操作系统资源*。此外，线程有自己的执行状态，即*线程状态*，并且可以与其他线程*同步*。
- en: 'A thread state can be ready, running, or blocked:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 线程状态可以是就绪、运行或阻塞：
- en: When a thread is created, it enters the **Ready **state.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当线程被创建时，它进入**就绪**状态。
- en: A thread is scheduled for execution by the OS (or by the runtime support system)
    and, when its turn arrives, it begins execution by going into the **Running **state.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程由操作系统（或运行时支持系统）安排执行，当轮到它执行时，它通过进入**运行**状态开始执行。
- en: 'The thread can wait for a condition to occur, passing from the **Running **state
    to the **Blocked **state. Once the locked condition is terminated, the **Blocked **thread
    returns to the **Ready **state:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程可以等待条件发生，从**运行**状态转换到**阻塞**状态。一旦锁定条件终止，**阻塞**线程返回到**就绪**状态：
- en: '![](assets/1c9d8391-719e-4277-a1ae-dd4155345659.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1c9d8391-719e-4277-a1ae-dd4155345659.png)'
- en: Thread life cycle
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 线程生命周期
- en: The main advantage of multithreading programming lies in performances, as the
    context switch between processes turns out to be much heavier than the switch
    context between threads that belong to the same process.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程编程的主要优势在于性能，因为进程之间的上下文切换比属于同一进程的线程之间的上下文切换要重得多。
- en: In the next recipes, until the end of the chapter, we will examine the Python
    `threading` module, introducing its main functions through programming examples.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的食谱中，直到本章结束，我们将通过编程示例来研究Python的`threading`模块，介绍其主要功能。
- en: Python threading module
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python线程模块
- en: Python manages threads with the `threading` module provided by the Python standard
    library. This module provides some very interesting features that make the threading-based
    approach a whole lot easier; in fact, the `threading` module provides several
    synchronization mechanisms that are very simple to implement.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Python使用Python标准库提供的`threading`模块来管理线程。该模块提供了一些非常有趣的功能，使基于线程的方法变得更加容易；事实上，`threading`模块提供了几种非常简单实现的同步机制。
- en: 'The major components of the threading module are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`threading`模块的主要组件如下：'
- en: The `thread` object
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thread`对象'
- en: The `lock` object
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock`对象'
- en: The `RLock` object
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RLock`对象'
- en: The `semaphore` object
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`semaphore`对象'
- en: The `condition` object
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`condition`对象'
- en: The `event` object
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event`对象'
- en: In the following recipes, we examine the features offered by the `threading`
    library with different application examples. For the examples that follow, we
    will refer to the Python 3.5.0 distribution ([https://www.python.org/downloads/release/python-350/](https://www.python.org/downloads/release/python-350/)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将使用`threading`库提供的功能来检查不同应用示例。对于接下来的示例，我们将参考Python 3.5.0发行版([https://www.python.org/downloads/release/python-350/](https://www.python.org/downloads/release/python-350/))。
- en: Defining a thread
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义线程
- en: The simplest way to use a thread is to instantiate it with a target function
    and then call the start method to let it begin the job.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程的最简单方法是使用目标函数实例化它，然后调用`start`方法让它开始工作。
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The Python `threading` module provides a `Thread` class that is used to run
    processes and functions in a different thread:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Python `threading`模块提供了一个`Thread`类，用于在不同的线程中运行进程和函数：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here are the parameters of the `Thread` class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Thread`类的参数：
- en: '`group`: This is the `group` value, which should be `None`; this is reserved
    for future implementations.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group`：这是`group`值，应为`None`；这是为将来的实现保留的。'
- en: '`target`: This is the function that is to be executed when you start a thread
    activity.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`：这是启动线程活动时要执行的函数。'
- en: '`name`: This is the name of the thread; by default, a unique name of the form
    of `Thread-N` is assigned to it.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是线程的名称；默认情况下，它被分配一个形式为`Thread-N`的唯一名称。'
- en: '`args`: This is the tuple of arguments that are to be passed to a target.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args`：这是要传递给目标的参数元组。'
- en: '`kwargs`: This is the dictionary of keyword arguments that are to be used for
    the `target` function.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kwargs`：这是要用于`target`函数的关键字参数字典。'
- en: In the next section, let's learn about how to define a thread.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们了解如何定义线程。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll define a thread by passing it a number, which represents the thread
    number, and finally, the result will be printed out:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过传递一个数字来定义一个线程，该数字表示线程编号，最后将打印出结果：
- en: 'Import the `threading` module by using the following Python command:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下Python命令导入`threading`模块：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `main` program, a `Thread` object is instantiated with a `target` function
    called `my_func`. Then, an argument to the function that will be included in the
    output message is passed:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`程序中，使用`target`函数`my_func`实例化了一个`Thread`对象。然后，传递给函数的参数将包含在输出消息中：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The thread does not start running until the start method is called, and the
    `join` method makes the calling thread and waits until the thread has finished
    the execution, as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程在调用`start`方法之前不会开始运行，而`join`方法使调用线程等待，直到线程完成执行，如下所示：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the `main` program, we initialize the thread''s list, to which we add the
    instance of each thread that is created. The total number of threads created is
    10, while the **i**-index for the i^(th) thread is passed as an argument to the
    i^(th) thread:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`程序中，我们初始化线程列表，将每个创建的线程实例添加到其中。创建的线程总数为10，而第i个线程的**i**索引作为参数传递给第i个线程：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There's more...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: All current processors are multicore, thus offering the possibility of performing
    multiple parallel operations and making the most of the computer's computational
    resources. Although this is true, multithread programming hides a number of non-trivial
    difficulties, which must be managed appropriately to avoid errors such as deadlocks
    or synchronization problems.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有当前处理器都是多核的，因此可以执行多个并行操作，并充分利用计算机的计算资源。尽管如此，多线程编程隐藏了许多非平凡的困难，必须适当地管理，以避免死锁或同步问题等错误。
- en: Determining the current thread
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定当前线程
- en: Using arguments to identify or name the thread is cumbersome and unnecessary.
    Each `Thread` instance has a *name* with a default value that can be changed as
    the thread is created.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数来标识或命名线程是繁琐且不必要的。每个`Thread`实例都有一个默认值的*name*，可以在创建线程时更改。
- en: Naming threads is useful in server proc*esses* with multiple service threads
    that handle different operations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程名对于处理不同操作的多个服务线程的服务器进程中是有用的。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This `threading` module provides the `currentThread().getName()` method, which
    returns the name of the current thread.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`threading`模块提供了`currentThread().getName()`方法，返回当前线程的名称。
- en: The following section shows us how to use this function to determine which thread
    is running.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将学习如何使用此函数来确定正在运行的线程。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s have a look at the following steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: 'To determine which thread is running, we create three `target` functions and
    import the `time` module to introduce a suspended execution of two seconds:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要确定正在运行的线程，我们创建了三个`target`函数，并导入`time`模块以引入暂停执行两秒：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Three threads are instantiated with a `target` function. Then, we pass the
    name that is to be printed and, if it is not defined, then the default name will
    be used. Then, the `start()` and `join()` methods are called for each thread:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个线程使用`target`函数实例化。然后，我们传递要打印的名称，如果未定义，则将使用默认名称。然后，为每个线程调用`start()`和`join()`方法：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We are going to set up three threads, each of which is assigned a `target` function.
    When the `target` function is executed and terminated, the function name is appropriately
    printed out.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置三个线程，每个线程都分配了一个`target`函数。当执行并终止`target`函数时，将适当地打印出函数名。
- en: 'For this example, the output should look like this (even if the order shown
    cannot be the same):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，输出应该如下（即使显示的顺序可能不同）：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Defining a thread subclass
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个线程子类
- en: Creating a thread can require the definition of a subclass, which inherits from
    the `Thread` class. The latter, as explained in *Defining a thread* section, is
    included in the `threading` module, which must then be imported.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建线程可能需要定义一个从`Thread`类继承的子类。后者，如*定义一个线程*部分所述，包含在`threading`模块中，必须导入。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The class that we will define in the next section, which represents our thread,
    respects a precise structure: we will first have to define the **`__init__`**
    method, but, above all, we will have to override the `run` method.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中定义的类代表我们的线程，遵循一个明确的结构：我们首先必须定义**`__init__`**方法，但最重要的是，我们必须重写`run`方法。
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The steps involved are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的步骤如下：
- en: 'We defined the `MyThreadClass` class, which we can use to create all the threads
    we want. Each thread of this type will be characterized by the operations defined
    in the `run` method, which, in this simple example, limits itself to printing
    a string at the beginning and at the end of its execution:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了`MyThreadClass`类，可以用它来创建所有想要的线程。这种类型的每个线程将以`run`方法中定义的操作为特征，在这个简单的例子中，`run`方法限制于在执行开始和结束时打印一个字符串：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Furthermore, in the `__init__` method, we have specified two initialization
    parameters, respectively,`name` and `duration`, that will be used in the `run`
    method:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在`__init__`方法中，我们指定了两个初始化参数，分别是`name`和`duration`，它们将在`run`方法中使用：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These parameters will then be set during the creation of the thread. In particular,
    the `duration` parameter is computed using the `randint` function that outputs
    a random integer between `1` and `10`. Starting from the definition of `MyThreadClass`,
    let''s see how to instantiate more threads, as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在创建线程时设置这些参数。特别是，`duration`参数是使用`randint`函数计算的，该函数输出1到10之间的随机整数。从`MyThreadClass`的定义开始，让我们看看如何实例化更多的线程，如下所示：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this example, we created nine threads, each with their own `name` and `duration`
    property, according to the definition of the `__init__` method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了九个线程，每个线程都有自己的`name`和`duration`属性，根据`__init__`方法的定义。
- en: We then run them using the `start` method, which is limited to executing the
    contents of the previously defined `run` method. Note that the process ID for
    each thread is the same, meaning that we are in a multithreaded process.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`start`方法运行它们，该方法仅限于执行先前定义的`run`方法的内容。请注意，每个线程的进程ID相同，这意味着我们处于多线程进程中。
- en: 'Also, note that the start method *is not blocking*: when it is executed, the
    control immediately goes to the next line, while the thread is started in the
    background. In fact, as you can see, the creation of threads *does not take place*
    in the order specified by the code. Likewise, thread termination is constrained
    to the value of the `duration` parameter, evaluated using the `randint` function,
    and passed by the parameter for each thread creation instance. To wait for a thread
    to finish, a `join` operation must be performed.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，注意`start`方法*不是阻塞的*：当它被执行时，控制立即转移到下一行，而线程在后台启动。实际上，正如你所看到的，线程的创建*不是*按照代码指定的顺序进行的。同样，线程终止受`duration`参数的约束，使用`randint`函数进行评估，并通过参数传递给每个线程创建实例。要等待线程完成，必须执行`join`操作。
- en: 'The output looks like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There's more...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The feature that is most frequently associated with OOP is *inheritance*, which
    is the ability to define a new class as a modified version of an already existing
    class. The main advantage of inheritance is that you can add new methods to a
    class without having to change the original definition.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与OOP最常关联的特性是*继承*，它是定义新类作为已经存在的类的修改版本的能力。继承的主要优势是可以向类添加新方法，而无需更改原始定义。
- en: The original class is often referred to as the parent class and the derived
    class, subclass. Inheritance is a powerful feature, and some programs can be written
    much more easily and concisely, providing the possibility to customize the behavior
    of a class without modifying the original class. The very fact that the inheritance
    structure can reflect that of the problem can, in some cases, make the program
    easier to understand.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类通常被称为父类和派生类，子类。继承是一个强大的特性，一些程序可以更轻松、更简洁地编写，提供了在不修改原始类的情况下定制类行为的可能性。继承结构可以反映问题的结构，有时可以使程序更容易理解。
- en: However (to put the user on guard!), inheritance can make it more difficult
    to read the program. This is because, when invoking a method, it is not always
    clear where this has been defined within the code that must be traced within multiple
    modules, instead of being in a single well-defined place.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而（提醒用户注意！），继承可能会使程序更难阅读。这是因为在调用方法时，不清楚该方法在代码中的哪里定义，必须在多个模块中进行跟踪，而不是在一个单一明确定义的地方。
- en: Many of the things that can be done with inheritance can usually be managed
    elegantly even without it, so it is appropriate to only use inheritance if the
    structure of the problem requires it. If used at the wrong time, then the harm
    inheritance can cause can outweigh the benefits of using it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 许多继承可以做的事情通常即使没有继承也可以优雅地处理，因此只有在问题的结构需要时才适合使用继承。如果在错误的时间使用，继承可能造成的危害可能会超过使用它的好处。
- en: Thread synchronization with a lock
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用锁进行线程同步
- en: The `threading` module also includes a simple lock mechanism, which allows us
    to implement synchronization between threads.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`threading`模块还包括了一个简单的锁机制，允许我们在线程之间实现同步。'
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: A *lock* is nothing more than an object that is typically accessible by multiple
    threads, which a thread must possess before it can proceed to the execution of
    a protected section of a program. These locks are created by executing the `Lock()`
    method, which is defined in the `threading` module.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*锁*只不过是一个通常可以被多个线程访问的对象，线程在执行受保护的程序部分之前必须拥有该对象。这些锁是通过在`threading`模块中定义的`Lock()`方法来创建的。'
- en: 'Once the lock has been created, we can use two methods that allow us to synchronize
    the execution of two (or more) threads: the `acquire()` method to acquire the
    lock control, and the `release()` method to release it.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦锁被创建，我们可以使用两种方法来同步执行两个（或更多）线程：`acquire()` 方法用于获取锁控制，`release()` 方法用于释放锁。
- en: The `acquire()` method accepts an optional parameter that, if not specified
    or set to `True`, forces the thread to suspend its execution until the lock is
    released and can then be acquired. If, on the other hand, the `acquire()` method
    is executed with an argument equal to `False`, then it immediately returns a Boolean
    result, which is `True` if the lock has been acquired, or `False` otherwise.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`acquire()`方法接受一个可选参数，如果未指定或设置为`True`，则强制线程暂停执行，直到锁被释放并可以获取。另一方面，如果使用参数等于`False`执行`acquire()`方法，则立即返回一个布尔结果，如果锁已被获取，则为`True`，否则为`False`。'
- en: In the following example, we show the lock mechanism by modifying the code introduced
    in the previous recipe, *Defining a thread subclass*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们通过修改上一个示例*定义线程子类*中引入的代码来展示锁机制。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The steps involved are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的步骤如下：
- en: 'As shown in the following code block, the `MyThreadClass` class has been modified,
    introducing the `acquire()` and `release()` methods within the **`run`** method,
    while the `Lock()` definition is outside the definition of the class itself:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下面的代码块所示，`MyThreadClass`类已经被修改，在**`run`**方法中引入了`acquire()`和`release()`方法，而`Lock()`的定义在类本身的定义之外：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `main()` function has not changed with respect to the previous code sample:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main()`函数与之前的代码示例相比没有改变：'
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We have modified the code of the previous section by using a lock so that the
    threads will be executed in sequence.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用锁修改了上一节的代码，以便线程按顺序执行。
- en: The first thread acquires the lock and performs its task while the other eight
    remain *on hold.* At the end of the execution of the first thread, that is, when
    the `release()` method is executed, the second one will get the lock and the threads
    from three to eight will still be waiting until the end of the execution (that
    is, once again, only after running the `release()` method).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个线程获取锁并执行其任务，而其他八个线程保持*等待*状态。在第一个线程执行结束时，也就是执行`release()`方法时，第二个线程将获取锁，而第三到第八个线程仍将等待直到执行结束（也就是再次运行`release()`方法后）。
- en: 'The *lock-acquire* and *lock-release* execution are repeated until the ninth
    thread, with the final result that as a result of the lock mechanism, this execution
    takes place in a sequential mode, as can be seen in the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*锁获取*和*锁释放*的执行重复进行，直到第九个线程，最终结果是由于锁机制，这个执行是按顺序进行的，如下面的输出所示：'
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There's more...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The insertion points of the `acquire()` and `release()` methods determine the
    entire execution of the code. For this reason, it is very important that you take
    the time to analyze what threads you want to use and how you want to synchronize
    them.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`acquire()`和`release()`方法的插入点决定了整个代码的执行。因此，非常重要的是，您花时间分析您想要使用的线程以及如何同步它们。'
- en: 'For example, we can change the insertion point of the `release()` method in
    the `MyThreadClass` class like so:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以像这样在`MyThreadClass`类中改变`release()`方法的插入点：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this case, the output changes quite significantly:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出会发生相当大的变化：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, only the thread creation happens in sequential mode. Once thread
    creation is complete, the new thread acquires the lock, while the previous one
    continues the computation in the background.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，只有线程的创建是按顺序进行的。一旦线程创建完成，新线程获取锁，而前一个线程在后台继续计算。
- en: Thread synchronization with RLock
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RLock进行线程同步
- en: A reentrant lock, or simply an RLock, is a synchronization primitive that can
    be acquired multiple times by the same thread.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可重入锁，或者简称为RLock，是一种同步原语，同一个线程可以多次获取它。
- en: It uses the concept of the proprietary thread. This means that in the *locked
    state*, some threads own the lock, while in the *unlocked state*, the lock is
    not owned by any thread.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用专有线程的概念。这意味着在*锁定状态*下，一些线程拥有锁，而在*解锁状态*下，锁没有被任何线程拥有。
- en: The next example demonstrates how to manage threads through the `RLock()` mechanism.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例演示了如何通过`RLock()`机制管理线程。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: An RLock is implemented through the `threading.RLock()` class. It provides the
    `acquire()` and `release()` methods that have the same syntax as the `threading.Lock()`
    class.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`threading.RLock()`类实现了RLock。它提供了与`threading.Lock()`类相同语法的`acquire()`和`release()`方法。
- en: An `RLock` block can be acquired multiple times by the same thread. Other threads
    will not be able to acquire the `RLock` block until the thread that owns it has
    made a `release()` call for every previous `acquire()` call. Indeed, the `RLock`
    block must be released, but only by the thread that acquired it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`RLock`块可以被同一个线程多次获取。其他线程在拥有它的线程对每次之前的`acquire()`调用进行`release()`调用之前将无法获取`RLock`块。确实，`RLock`块必须被释放，但只能由获取它的线程释放。
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The steps involved are as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的步骤如下：
- en: 'We introduced the `Box` class, which provides the `add()` and `remove()` methods
    that access the `execute()` method in order to perform the action to add or delete
    an item, respectively. Access to the `execute()` method is regulated by `RLock()`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们引入了`Box`类，它提供了`add()`和`remove()`方法，这些方法访问`execute()`方法，以执行添加或删除项目的操作。对`execute()`方法的访问由`RLock()`进行调节：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following functions are called by the two threads. They have the `box` class and
    the total number of `items` to add or to remove as parameters:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个线程调用以下函数。它们有`box`类和要添加或移除的项目的总数作为参数：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, the total number of items to add or to remove from the box is set. As
    you can see, these two numbers will be different. The execution ends when both
    the `adder` and `remover` methods accomplish their tasks:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，设置要添加或从箱子中移除的项目的总数。正如你所看到的，这两个数字将是不同的。当`adder`和`remover`方法都完成它们的任务时，执行结束：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the `main` program, the two threads of `t1` and `t2` have been associated
    with the `adder()` and `remover()` functions. The functions are active if the
    number of items is greater than zero.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`程序中，`t1`和`t2`两个线程已经与`adder()`和`remover()`函数关联。如果项目的数量大于零，这些函数是活动的。
- en: 'The call to `RLock()` is carried out inside the `__init__` method of the **`Box`**
    class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对`RLock()`的调用是在**`Box`**类的`__init__`方法中进行的：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The two `adder()` and `remover()` functions interact with the items of the `Box`
    class, respectively, and call the `Box` class methods of `add()` and `remove()`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`adder()`和`remover()`函数分别与`Box`类的项目进行交互，并调用`Box`类的`add()`和`remove()`方法。'
- en: In each method call, a resource is captured and then released using the `lock`
    parameter that is set in the `_init_` method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个方法调用中，使用在`_init_`方法中设置的`lock`参数来捕获和释放资源。
- en: 'Here is the output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There's more...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The differences between *lock* and *RLock* are as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*lock*和*RLock*之间的区别如下：'
- en: A *lock* can only be acquired once before it must be released. However, `RLock`
    can be acquired multiple times from the same thread; it must be released the same
    number of times in order to be released.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*lock*只能在释放之前被获取一次。但是，`RLock`可以从同一个线程多次获取；为了释放，必须释放相同次数。'
- en: Another difference is that an acquired lock can be released by any thread, whereas
    an acquired `RLock` can only be released by the thread that acquired it.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个区别是，已获取的锁可以被任何线程释放，而已获取的`RLock`只能被获取它的线程释放。
- en: Thread synchronization with semaphores
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用信号量进行线程同步
- en: A **semaphore** is an abstract data type managed by the OS to synchronize access
    by multiple threads to shared resources and data. It consists of an internal variable
    that identifies the amount of concurrent access to a resource with which it is
    associated.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**信号量**是由操作系统管理的抽象数据类型，用于同步多个线程对共享资源和数据的访问。它由一个内部变量组成，用于标识与其关联的资源的并发访问量。'
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好了
- en: 'The operation of a semaphore is based on two functions: `acquire()` and `release()`,
    as explained here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量的操作基于两个函数：`acquire()`和`release()`，如下所述：
- en: Whenever a thread wants to access a given or a resource that is associated with
    a semaphore, it must invoke the `acquire()` operation, which *decreases the internal
    variable of the semaphore* and allows access to the resource if the value of this
    variable appears to be non-negative. If the value is negative, then the thread
    will be suspended and the release of the resource by another thread will be placed
    on hold.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当一个线程想要访问与信号量相关的给定资源时，它必须调用`acquire()`操作，这会*减少信号量的内部变量*，如果这个变量的值看起来是非负的，就允许访问资源。如果值为负，则线程将被挂起，另一个线程释放资源的操作将被搁置。
- en: Having finished using shared resources, the thread frees resources through the
    `release()` instruction. In this way, the internal variable of the semaphore is
    increased, allowing, for a *waiting* thread (if any), the opportunity to access
    the newly freed resource.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用共享资源后，线程通过`release()`指令释放资源。这样，信号量的内部变量增加，允许*等待*线程（如果有的话）有机会访问新释放的资源。
- en: The semaphore is one of the oldest synchronization primitives in the history
    of computer science, invented by the early Dutch computer scientist Edsger W.
    Dijkstra.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量是计算机科学历史上最古老的同步原语之一，由早期荷兰计算机科学家Edsger W. Dijkstra发明。
- en: The following example shows how to synchronize threads through a semaphore.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何通过信号量同步线程。
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The following code describes a problem where we have two threads, `producer()`
    and `consumer()`, that share a common resource, which is the item. The task of
    `producer()` is to generate the item while the `consumer()` thread's task is to
    use the item that has been produced.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码描述了一个问题，我们有两个线程`producer()`和`consumer()`，它们共享一个公共资源，即项目。`producer()`的任务是生成项目，而`consumer()`线程的任务是使用已经生成的项目。
- en: 'If the item has not yet produced the `consumer()` thread, then it has to wait.
    As soon as the item is produced, the `producer()` thread notifies the consumer
    that the resource should be used:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目尚未由`consumer()`线程生成，则它必须等待。一旦项目生成，`producer()`线程通知消费者应该使用资源：
- en: 'By initializing a semaphore to `0`, we obtain a so-called semaphore event whose
    sole purpose is to synchronize the computation of two or more threads. Here, a
    thread must make use of data or common resources simultaneously:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将信号量初始化为`0`，我们获得了一个所谓的信号量事件，其唯一目的是同步两个或多个线程的计算。在这里，一个线程必须同时使用数据或共享资源：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This operation is very similar to that described in the lock mechanism of the
    lock. The `producer()` thread creates the item and, after that, it frees the resource
    by calling the `release()` method:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个操作与锁的锁定机制中描述的非常相似。`producer()`线程创建项目，之后通过调用`release()`方法释放资源：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Similarly, the `consumer()` thread acquires the data by the `acquire()` method.
    If the semaphore''s counter is equal to `0`, then it blocks the condition''s `acquire()`
    method until it gets notified by a different thread. If the semaphore''s counter
    is greater than `0`, then it decrements the value. When the producer creates an
    item, it releases the semaphore, and then the consumer acquires it and consumes
    the shared resource:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，`consumer()`线程通过`acquire()`方法获取数据。如果信号量的计数器等于`0`，那么它会阻塞条件的`acquire()`方法，直到被其他线程通知。如果信号量的计数器大于`0`，那么它会递减该值。当生产者创建一个项目时，它释放信号量，然后消费者获取并消耗共享资源：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The synchronization process that is done via the semaphores is shown in the
    following code block:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过信号量进行的同步过程如下代码块所示：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The data acquired is then printed on the standard output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 获取的数据然后被打印到标准输出：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is the result that we get after 10 runs:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在10次运行后得到的结果：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There's more...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A particular use of semaphores is the *mutex*. A mutex is nothing but a semaphore
    with an internal variable initialized to the value of `1`, which allows the realization
    of mutual exclusion in access to data and resources.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量的一个特殊用途是*互斥体*。互斥体只是一个内部变量初始化为`1`的信号量，它允许在对数据和资源的访问中实现互斥排他。
- en: 'Semaphores are still commonly used in programming languages that are multithreaded;
    however, they have two major problems, which we have discussed, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量仍然广泛用于多线程编程的编程语言；然而，它们有两个主要问题，我们已经讨论如下：
- en: They do not prevent the possibility of a thread performing more wait operations
    on the same semaphore. It is very easy to forget to do all the necessary signals
    in relation to the number of waits performed.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们并不能阻止一个线程对同一个信号量执行更多的等待操作。很容易忘记对执行的等待数量做出所有必要的信号。
- en: You can run into situations of deadlock. For example, a deadlock situation is
    created when the `t1` thread executes a wait on the `s1` semaphore, while the
    **`t2`** thread executes a wait on the thread `t1`, executes a wait on `s2` and
    `t2`, and then executes a wait on `s1`.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能会遇到死锁的情况。例如，当`t1`线程在`s1`信号量上执行等待时，`t2`线程在`t1`线程上执行等待，然后在`s2`和`t2`上执行等待，最后在`s1`上执行等待时，就会创建死锁情况。
- en: Thread synchronization with a condition
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用条件进行线程同步
- en: A *condition* identifies a change of state in the application. It is a synchronization
    mechanism where a thread waits for a specific condition and another thread notifies
    that this *condition has taken place*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*condition*标识应用程序中状态的变化。它是一种同步机制，其中一个线程等待特定条件，另一个线程通知该*条件已发生*。'
- en: Once the condition takes place, the thread *acquires* the lock in order to get
    *exclusive access* to the shared resource.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦条件发生，线程就会*获取*锁，以便对共享资源进行*独占访问*。
- en: Getting ready
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: A good way to illustrate this mechanism is by looking again at a producer/consumer
    problem. The class producer writes to a buffer if it is not full, and the class
    consumer takes the data from the buffer (eliminating them from the latter) if
    the buffer is full. The class producer will notify the consumer that the buffer
    is not empty, while the consumer will report to the producer that the buffer is
    not full.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的说明这种机制的方法是再次看一个生产者/消费者问题。生产者类在缓冲区不满时向缓冲区写入数据，而消费者类在缓冲区满时从缓冲区中取出数据（从后者中消除）。生产者类将通知消费者缓冲区不为空，而消费者将向生产者报告缓冲区不满。
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The steps involved are as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的步骤如下：
- en: 'The class consumer acquires the shared resource that is modelled through the **`items[]`** list:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消费者类获取通过**`items[]`**列表建模的共享资源：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the length of the list is equal to `0`, then the consumer is placed in a
    waiting state:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果列表的长度等于`0`，则消费者被置于等待状态：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then it makes a **`pop`** operation from the items list:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后它从items列表中进行一次**`pop`**操作：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So, the consumer''s state is notified to the producer and the shared resource
    is released:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，消费者的状态被通知给生产者，共享资源被释放：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The class producer acquires the shared resource and then it verifies that the
    list is completely full (in our example, we place the maximum number of items,
    `10`, that can be contained in the items list). If the list is full, then the
    producer is placed in the wait state until the list is consumed:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生产者类获取共享资源，然后验证列表是否完全满（在我们的示例中，我们放置了最大数量的项目`10`，可以包含在items列表中）。如果列表已满，则生产者被置于等待状态，直到列表被消耗：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If the list is not full, then a single item is added. The state is notified
    and the resource is released:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果列表不满，则添加一个单个项目。状态被通知并且资源被释放：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To show you the condition mechanism, we will use the *consumer/producer* modelagain:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了向你展示条件机制，我们将再次使用*消费者/生产者*模型：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`producer` generates the item and stores it in the buffer continuously. At
    the same time, `consumer` uses the data produced, removing it from the buffer
    from time to time.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`producer`不断生成项目并将其存储在缓冲区中。与此同时，`consumer`不时使用生成的数据，从缓冲区中删除它。'
- en: As soon as `consumer` has picked up an object from the buffer, it will wake
    up `producer`, who will start to fill the buffer again.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`consumer`从缓冲区中取出一个对象，它就会唤醒`producer`，后者将开始再次填充缓冲区。
- en: Similarly, `consumer` will suspend if the buffer is empty. As soon as `producer`
    has downloaded the data into the buffer, `consumer` will wake up.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果缓冲区为空，`consumer`将被挂起。一旦`producer`将数据下载到缓冲区中，`consumer`就会被唤醒。
- en: As you can see, even in this case, the use of the `condition` directive allows
    the threads to be properly synchronized.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，即使在这种情况下，使用`condition`指令也允许线程正确同步。
- en: 'The result that we get after a single run is as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 单次运行后我们得到的结果如下：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There's more...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It''s interesting to see the Python internals for the condition synchronization
    mechanism. The internal `class _Condition` creates an `RLock()` object if no existing
    lock has been passed to the class''s constructor. Also, the lock will be managed
    when `acquire()` and `released()` are called:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，查看Python内部的条件同步机制。如果没有现有的锁被传递给类的构造函数，内部的`class _Condition`会创建一个`RLock()`对象。此外，当调用`acquire()`和`released()`时，锁将被管理：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Thread synchronization with an event
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件进行线程同步
- en: An event is an object that is used for communication between threads. A thread
    waits for a signal while another thread outputs it. Basically, an `event` object
    manages an internal flag that can be set to `false` with `clear()`, set to `true`
    with `set()`, and tested with `is_set()`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是用于线程间通信的对象。一个线程等待信号，而另一个线程输出它。基本上，`event`对象管理一个内部标志，可以通过`clear()`设置为`false`，通过`set()`设置为`true`，并通过`is_set()`进行测试。
- en: A thread can hold a signal by means of the `wait()` method, which sends the
    call with the `set()` method.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`wait()`方法，线程可以持有一个信号，该方法会发送调用`set()`方法。
- en: Getting ready
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To understand thread synchronization through the `event` object, let's take
    a look at the producer/consumer problem.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解通过`event`对象进行线程同步，让我们来看看生产者/消费者问题。
- en: How to do it...
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Again, to explain how to synchronize threads through events, we will refer to
    the *producer/consumer* problem. The problem describes two processes, a producer
    and a consumer, who share a common buffer of a fixed size. The producer's task
    is to generate items and deposit them in the continuous buffer. At the same time,
    the consumer will use the items produced, removing them from the buffer from time
    to time.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，为了解释如何通过事件同步线程，我们将参考*生产者/消费者*问题。该问题描述了两个进程，一个生产者和一个消费者，它们共享一个固定大小的公共缓冲区。生产者的任务是生成项目并将它们存放在连续的缓冲区中。与此同时，消费者将使用生成的项目，不时地从缓冲区中取出它们。
- en: The problem is to ensure that the producer does not process new data if the
    buffer is full and that the consumer does not look for data if the buffer is empty.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于确保如果缓冲区已满，生产者不会处理新数据，消费者不会在缓冲区为空时寻找数据。
- en: 'Now, let''s see how to implement the consumer/producer problem by using thread
    synchronization with an `event` statement:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`event`语句实现消费者/生产者问题的线程同步：
- en: 'Here, the relevant libraries are imported as follows:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，相关的库被导入如下：
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we define the log output format. It is useful to clearly visualize what''s
    happening:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义日志输出格式。清晰地可视化发生的事情是很有用的：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Set the `items` list. This parameter will be used by the `Consumer` and `Producer`
    classes:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`items`列表。该参数将被`Consumer`和`Producer`类使用：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `event` parameter is defined as follows. This parameter will be used to
    synchronize the communication between threads:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`event`参数定义如下。该参数将用于同步线程之间的通信：'
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `Consumer` class is initialized with the list of items and the `Event()`
    function. In the `run` method, the consumer waits for a new item to consume. When
    the item arrives, it is popped from the `item` list:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Consumer`类使用项目列表和`Event()`函数进行初始化。在`run`方法中，消费者等待新项目进行消费。当项目到达时，它从`item`列表中弹出：'
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `Producer` class is initialized with the list of items and the `Event()`
    function. Unlike the example with `condition` objects, the item list is not global,
    but it is passed as a parameter:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Producer`类使用项目列表和`Event()`函数进行初始化。与使用`condition`对象的示例不同，项目列表不是全局的，而是作为参数传递的：'
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the `run` method for each item that is created, the `Producer` class appends
    it to the list of items and then notifies the event:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`run`方法中，对于每个创建的项目，`Producer`类将其附加到项目列表，然后通知事件：
- en: '[PRE43]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'There are two steps that you need to take for this and the first step, which
    are as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这需要两个步骤，第一步如下：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `t1` thread appends a value to the list and then sets the event to notify
    the consumer. The consumer''s call to `wait()` stops blocking and the integer
    is retrieved from the list:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`t1`线程向列表添加一个值，然后设置事件以通知消费者。消费者调用`wait()`停止阻塞，并从列表中检索整数：'
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'All the operations between the `Producer` and the `Consumer` classes can be
    easily resumed with the help of the following schema:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下模式可以轻松地总结`Producer`和`Consumer`类之间的所有操作：
- en: '![](assets/915fcac0-899f-465a-9fd2-ce18a24bb0f0.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/915fcac0-899f-465a-9fd2-ce18a24bb0f0.png)'
- en: Thread synchronization with event objects
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件对象进行线程同步
- en: 'In particular, the `Producer`and the `Consumer` classes have the following
    behavior:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，`Producer`和`Consumer`类具有以下行为：
- en: '`Producer` acquires a lock, adds an item to the queue, and notifies this event
    to`Consumer` (`set event`). It then sleeps until it receives a new item to add.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Producer`获取锁，向队列添加项目，并通知`Consumer`这个事件（设置事件）。然后它会休眠，直到收到新的项目添加。'
- en: '`Consumer` acquires a block and then begins to listen to the elements in a
    continuous cycle. The moment the event arrives, the consumer abandons the block,
    thus allowing other producers/consumers to enter and acquire the block. If `Consumer`
    is reactivated, then it reacquires the lock by safely processing new items from
    the queue:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Consumer`获取一个块，然后开始循环监听元素。当事件到达时，消费者放弃块，从而允许其他生产者/消费者进入并获取块。如果`Consumer`重新激活，则通过安全地处理队列中的新项目重新获取锁：'
- en: '[PRE46]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Thread synchronization with a barrier
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用屏障进行线程同步
- en: 'Sometimes, an application can be divided into phases with the rule that no
    process can continue if first, all threads of the process have completed their
    own task. A **barrier** implements this concept: a thread that has finished its
    phase calls a primitive barrier and stops. When all the threads involved have
    finished their stage of execution and have also invoked the primitive barrier,
    the system unlocks them all, allowing threads to move to a later stage.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个应用程序可以被划分为阶段，根据规则，如果首先，所有进程的线程都完成了自己的任务，那么没有一个进程可以继续。一个**屏障**实现了这个概念：完成了自己阶段的线程调用一个原始的屏障并停止。当所有涉及的线程都完成了他们的执行阶段并调用了原始的屏障时，系统解锁它们所有，允许线程进入后续阶段。
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Python's threading module implements barriers through the **`Barrier`** class. In
    the next section, let's learn about how to use this synchronization mechanism
    in a very simple example.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Python的线程模块通过**`Barrier`**类实现屏障。在下一节中，让我们学习如何在一个非常简单的例子中使用这种同步机制。
- en: How to do it...
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this example, we simulate a run with three participants, `Huey`, `Dewey`,
    and `Louie`, in which a barrier is assimilated to that of a finish line.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们模拟了一个有三个参与者`Huey`、`Dewey`和`Louie`的比赛，其中一个屏障被类比为终点线。
- en: Moreover, the race can end on its own when all three participants cross the
    finish line.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当所有三个参与者都穿过终点线时，比赛可以自行结束。
- en: 'The barrier is implemented through the `Barrier` class, in which the number
    of threads to be completed must be specified as an argument to move to the next
    stage:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 屏障是通过`Barrier`类实现的，必须在参数中指定要完成的线程数才能进入下一个阶段：
- en: '[PRE47]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: First, we set the number of runners to `num_runners = 3`in order to set the
    final goal on the next line through the `Barrier` directive. The runners are set
    in the runners' list; each of them will have an arrival time that is determined
    in the `runner` function, using the `randrange` directive.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将参与者的数量设置为`num_runners = 3`，以便通过`Barrier`指令在下一行设置最终目标。参与者被设置在参与者列表中；每个参与者都将在`runner`函数中使用`randrange`指令确定到达时间。
- en: 'When a runner arrives at the finish line, call the `wait` method, which will
    block all the runners (the threads) that have made that call. The output for this
    is as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个跑步者到达终点线时，调用`wait`方法，这将阻塞所有已经做出该调用的跑步者（线程）。这个的输出如下：
- en: '[PRE48]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this case, `Dewey` won the race.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Dewey`赢得了比赛。
- en: Thread communication using a queue
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用队列进行线程通信
- en: Multithreading can be complicated when threads need to share data or resources.
    Luckily, the threading module provides many synchronization primitives, including
    semaphores, condition variables, events, and locks.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程需要共享数据或资源时，多线程可能会变得复杂。幸运的是，线程模块提供了许多同步原语，包括信号量、条件变量、事件和锁。
- en: However, it is considered a best practice to use the `queue` module. In fact,
    a queue is much easier to deal with and makes threaded programming considerably
    safer, as it effectively funnels all access to a resource of a single thread and
    allows for a cleaner and more readable design pattern.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`queue`模块被认为是最佳实践。事实上，队列要容易处理得多，并且使得线程编程变得更加安全，因为它有效地将对资源的所有访问集中到一个单独的线程，并允许更清晰和更可读的设计模式。
- en: Getting ready
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will simply consider these queue methods:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简单地考虑这些队列方法：
- en: '`put()`: Puts an item in the queue'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put()`: 将一个项目放入队列'
- en: '`get()`: Removes and returns an item from the queue'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()`: 从队列中移除并返回一个项目'
- en: '`task_done()`: Needs to be called each time an item has been processed'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`task_done()`: 每次处理完一个项目时都需要调用'
- en: '`join()`: Blocks until all items have been processed'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join()`: 阻塞直到所有项目都被处理'
- en: How to do it...
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this example, we will see how to use the `threading` module with the `queue`
    module. Also, we have two entities here that try to share a common resource, a
    queue. The code is as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将看到如何使用`threading`模块和`queue`模块。此外，我们在这里有两个实体试图共享一个共同的资源，即一个队列。代码如下：
- en: '[PRE49]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: First, with the `producer` class, we don't need to pass the integers list because
    we use the queue to store the integers that are generated.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`producer`类，我们不需要传递整数列表，因为我们使用队列来存储生成的整数。
- en: The thread in the `producer` class generates integers and puts them in the queue
    in a `for`loop. The `producer`class uses `Queue.put(item[, block[, timeout]])`
    to insert data in the queue. It has the logic to acquire the lock before inserting
    data in a queue.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`producer`类中的线程生成整数并将它们放入队列中的`for`循环。`producer`类使用`Queue.put(item[, block[,
    timeout]])`在队列中插入数据。它具有在将数据插入队列之前获取锁的逻辑。'
- en: 'There are two possibilities:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种可能性：
- en: If the optional arguments `block` is `true` and `timeout` is `None` (this is
    the default case that we used in the example), then it is necessary for us to
    block until a free slot is available. If the timeout is a positive number, then
    it blocks at most timeout seconds and raises the full exception if no free slot
    is available within that time.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可选参数`block`为`true`且`timeout`为`None`（这是我们在示例中使用的默认情况），则我们需要阻塞直到有一个空闲槽可用。如果超时是一个正数，则最多阻塞超时秒，并在该时间内没有可用的空闲槽时引发full异常。
- en: If the block is `false`, then put an item in the queue if a free slot is immediately
    available, otherwise, raise the full exception (timeout is ignored in this case).
    Here, `put` checks whether the queue is full and then calls `wait` internally,
    after which, the producer starts waiting.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`block`为`false`，则如果立即有空闲槽，则将项目放入队列，否则引发full异常（在这种情况下忽略超时）。在这里，`put`检查队列是否已满，然后在内部调用`wait`，之后生产者开始等待。
- en: Next is the `consumer` class. The thread gets the integer from the queue and
    indicates that it is done working on it by using `task_done`. The `consumer` class
    uses `Queue.get([block[, timeout]])` and acquires the lock before removing data
    from the queue. The consumer is placed in a waiting state, in case the queue is
    empty. Finally, in the `main` function, we create four threads, one for the `producer`
    class and three for the `consumer` class, respectively.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`consumer`类。线程从队列中获取整数，并使用`task_done`指示完成对其的操作。`consumer`类使用`Queue.get([block[,
    timeout]])`并在从队列中移除数据之前获取锁定。如果队列为空，消费者将处于等待状态。最后，在`main`函数中，我们创建四个线程，一个用于`producer`类，三个用于`consumer`类。
- en: 'The output should be like this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE50]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There's more...
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'All the operations between the `producer` class and the `consumer` class can
    easily be resumed with the following schema:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`producer`类和`consumer`类之间的所有操作都可以很容易地用以下模式来总结：'
- en: '![](assets/cb11a94d-258a-485f-a1b4-8954a860b41a.png)Thread synchronization
    with the queue module'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/cb11a94d-258a-485f-a1b4-8954a860b41a.png)使用队列模块进行线程同步'
- en: The `Producer` thread acquires the lock and then inserts data in the **QUEUE**
    data structure.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Producer`线程获取锁定，然后将数据插入**QUEUE**数据结构中。'
- en: The `Consumer` threads get the integers from the **QUEUE**. These threads acquire
    the lock before removing data from the **QUEUE**.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Consumer`线程从**QUEUE**中获取整数。这些线程在从**QUEUE**中移除数据之前获取锁定。'
- en: If the **QUEUE** is empty, then the `consumer` threads get in a **waiting**
    state.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**QUEUE**为空，那么`consumer`线程将进入**等待**状态。
- en: With this recipe, the chapter dedicated to thread-based parallelism comes to
    an end.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个示例，本章关于基于线程的并行性就结束了。

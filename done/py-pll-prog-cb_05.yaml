- en: Asynchronous Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程
- en: 'Beside the sequential and parallel execution models, there is a third model
    that is of fundamental importance together with the concept of event programming:
    the *asynchronous model*.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 除了顺序和并行执行模型之外，还有一个与事件编程概念一起具有基本重要性的第三个模型：*异步模型*。
- en: The execution model of asynchronous tasks can be implemented through a single
    main control flow, both in single-processor systems and in multiprocessor systems.
    In the concurrent asynchronous execution model, the executions of various tasks
    intersect along the timeline, and everything happens under the action of a single
    flow of control (single-threaded). Once started, the execution of tasks can be
    suspended and then resumed over time, alternating with the execution of other
    current tasks that are present.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 异步任务的执行模型可以通过单一的主控制流来实现，无论是在单处理器系统还是多处理器系统中。在并发异步执行模型中，各种任务的执行在时间线上交叉，并且一切都发生在单一控制流（单线程）的作用下。一旦开始，任务的执行可以随时间暂停然后恢复，与存在的其他当前任务的执行交替进行。
- en: The development of code for the asynchronous model is completely different from
    that for multithreaded programming. A substantial difference between the concurrent
    multithreaded parallel model and the single-threaded concurrent asynchronous model
    lies in the fact that, in the first case, the OS decides on the timeline if we
    suspend the activity of one thread and start another.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 异步模型的代码开发与多线程编程的代码开发完全不同。并发多线程并行模型和单线程并发异步模型之间的一个重要区别在于，在第一种情况下，如果我们暂停一个线程的活动并启动另一个线程，操作系统会决定时间表。
- en: This remains outside the control of the coder, unlike the asynchronous model.
    The execution or termination of a task continues as long as it is explicitly required.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这与异步模型不同，它保持在编码者的控制之外。任务的执行或终止会持续进行，只要明确要求。
- en: The most important feature of this type of programming is that the code is not
    performed on multiple threads, as in the classic concurrent programming, but on
    a single thread. Thus, it is not at all true that two tasks are executed at the
    same time, but, according to this approach, they are performed at almost the same
    time.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程类型的最重要特征是代码不是在多个线程上执行，而是在单个线程上执行，与经典的并发编程不同。因此，两个任务并不是真正同时执行，而是根据这种方法，它们几乎同时执行。
- en: In particular, we will describe the `asyncio`Python module, which was introduced
    in Python 3.4\. This allows us to use coroutines and futures to make writing asynchronous
    code easier and to make it more readable.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们将描述Python 3.4中引入的`asyncio`模块。这使我们能够使用协程和未来来更轻松地编写异步代码，并使其更易读。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Using the `concurrent.futures` Python module
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`concurrent.futures` Python模块
- en: Managing the event loopwith `asyncio`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`asyncio`管理事件循环
- en: Handling coroutines with `asyncio`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`asyncio`处理协程
- en: Manipulating tasks with `asyncio`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`asyncio`操纵任务
- en: Dealing with `asyncio` and futures
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理`asyncio`和未来
- en: Using the concurrent.futures Python module
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`concurrent.futures` Python模块
- en: The `concurrent.futures` module, which is part of the standard Python library,
    provides a level of abstraction on threads by modelling them as asynchronous functions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`concurrent.futures`模块是Python标准库的一部分，通过将线程建模为异步函数，提供了对线程的抽象层次。'
- en: 'This module is built by two main classes:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块由两个主要类构建：
- en: '`concurrent.futures.Executor`: This is an abstract class that provides methods
    to execute calls asynchronously.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concurrent.futures.Executor`：这是一个抽象类，提供异步执行调用的方法。'
- en: '`concurrent.futures.Future`: This encapsulates the asynchronous execution of
    a callable. Future objects are instantiated by submitting tasks (functions with
    optional parameters) to `Executors`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concurrent.futures.Future`：这封装了可调用的异步执行。`Future`对象是通过将任务（具有可选参数的函数）提交给`Executors`来实例化的。'
- en: 'Here are some of the main methods of the module:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该模块的一些主要方法：
- en: '`submit(function,argument)`: This schedules the execution of the callable function
    on the arguments.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`submit(function,argument)`：这会安排在参数上执行可调用函数。'
- en: '**`map(function,argument)`**: This executes the functions of arguments in asynchronous
    mode.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`map(function,argument)`**：这以异步模式执行参数的函数。'
- en: '`shutdown(Wait=True)`: This signals the executor to free any resource.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown(Wait=True)`：这表示执行器释放任何资源。'
- en: 'The executors are accessed through their subclasses: `ThreadPoolExecutor` or
    `ProcessPoolExecutor`. Because the instantiation of threads and processes is a
    resource-demanding task, it is better to pool these resources and use them as
    repeatable launchers or executors (hence the `Executors` concept) for parallel
    or concurrent tasks.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器通过它们的子类访问：`ThreadPoolExecutor`或`ProcessPoolExecutor`。因为实例化线程和进程是一个资源密集型的任务，最好将这些资源池化并将它们用作可重复启动器或执行器（因此是`Executors`概念）以用于并行或并发任务。
- en: The approach we are taking here involves using a pool executor. We will submit
    the assets to the pool (thread and process) and get the futures, which are the
    results that will be available to us in the future. Of course, we can wait for
    all futures to become real results.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里采取的方法涉及使用池执行器。我们将资产提交到池（线程和进程）并获得未来，这些未来将来会对我们可用。当然，我们可以等待所有未来变成真正的结果。
- en: A thread or process pool (also called *pooling*) indicates a management software
    that is being used to optimize and simplify the use of threads and/or processes
    within a program. Through pooling, you can submit the task (or tasks) in order
    to execute them to the pooler.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 线程或进程池（也称为*池化*）表示正在用于优化和简化程序中线程和/或进程的使用的管理软件。通过池化，您可以将任务（或任务）提交给池执行。
- en: 'The pool is equipped with an internal queue of tasks pending and several threads
    *or* processes that execute them. A recurring concept in pooling is reusing: a
    thread (or process) is used several times for different tasks during its life
    cycle. This decreases the overhead of creating new threads or processes and increases
    the performance of the program.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 池配备有一个待处理任务的内部队列和多个线程*或*执行它们的进程。池中的一个经常出现的概念是重用：一个线程（或进程）在其生命周期内多次用于不同的任务。这减少了创建新线程或进程的开销，并提高了程序的性能。
- en: Reuse *is not a rule*, but it is one of the main reasons that lead a coder to
    use pooling in their application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 重用*不是一个规则*，但它是导致编码人员在他们的应用程序中使用池的主要原因之一。
- en: Getting ready
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The `concurrent.futures` module provides two subclasses of the `Executor` class,which
    asynchronously manipulate a pool of threads and a pool of processes. The two subclasses
    are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`concurrent.futures`模块提供了`Executor`类的两个子类，它们可以异步地操作一个线程池和一个进程池。这两个子类如下：'
- en: '`concurrent.futures.ThreadPoolExecutor(max_workers)`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concurrent.futures.ThreadPoolExecutor(max_workers)`'
- en: '`concurrent.futures.ProcessPoolExecutor(max_workers)`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concurrent.futures.ProcessPoolExecutor(max_workers)`'
- en: The `max_workers` parameter identifies the maximum number of workers that execute
    the call asynchronously.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`max_workers`参数标识着异步执行调用的最大工作线程数。'
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Here is an example of thread and process pool usage, where we will compare the
    execution time with the time it takes for sequential execution.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是线程和进程池使用的一个例子，我们将比较执行时间与顺序执行所需的时间。
- en: 'The task to be performed is as follows: we have a list of 10 elements. Each
    element of the list is made to count up to 100,000,000 (just to waste time), and
    then the last number is multiplied by the *i-th* element of the list. In particular,
    we are evaluating the following cases:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行的任务如下：我们有一个包含10个元素的列表。列表的每个元素都被计数到100,000,000（只是为了浪费时间），然后最后一个数字乘以列表的第*i*个元素。特别是，我们正在评估以下情况：
- en: '**Sequential execution**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序执行**'
- en: '**Thread pool with five workers**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具有五个工作线程的线程池**'
- en: '**Process pool with five workers**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用五个工作线程的进程池**'
- en: 'Now, let''s look at how to do it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何做：
- en: 'Import the relevant libraries:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入相关的库：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Define the list of numbers from `1` to `10`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义从`1`到`10`的数字列表：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `count(number)`function counts the numbers from `1` to `100000000`, and
    then returns the product of `number` × 100,000,000:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`count(number)`函数计算从`1`到`100000000`的数字，然后返回`number` × 100,000,000的乘积：'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `evaluate(item)` function evaluates the `count` function on the `item`
    parameter. It prints out the `item` value and the result of `count(item)`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`evaluate(item)`函数评估`item`参数上的`count`函数。它打印出`item`值和`count(item)`的结果：'
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In `__main__`, the sequential execution, thread pool, and process pool are
    executed:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__main__`中，执行顺序执行、线程池和进程池：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For the sequential execution, the `evaluate` function is executed for each
    item of `number_list`. Then, the execution time is printed out:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于顺序执行，对`number_list`的每个项目执行`evaluate`函数。然后，打印出执行时间：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Regarding thread and process pool execution, the same number of workers (`max_workers=5`)
    is used. Of course, for both pools, execution times are displayed:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于线程和进程池的执行，使用相同数量的工作线程（`max_workers=5`）。当然，对于两个池，执行时间都会显示出来：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We build a list of numbers stored in `number_list`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建一个存储在`number_list`中的数字列表：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For each element in the list, we operate the counting procedure until we reach `100000000`
    iterations, and then multiply the resulting value for `100000000`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表中的每个元素，我们对计数过程进行操作，直到达到`100000000`次迭代，然后将得到的值乘以`100000000`：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the `main` program, we execute the same task in sequential mode:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`程序中，我们以顺序模式执行相同的任务：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, in parallel mode, use the `concurrent.futures` pooling capabilities for
    a thread pool:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，以并行模式使用`concurrent.futures`的线程池功能：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And do the same for a process pool:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后对进程池执行相同的操作：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that both the thread *and* process pools are set with`max_workers=5`; moreover,
    if `max_workers` is equal to `None`, it will default to the number of processors
    on the machine.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，线程池和进程池都设置为`max_workers=5`；此外，如果`max_workers`等于`None`，它将默认为机器上的处理器数量。
- en: 'To run this example, open Command Prompt and, in the same folder where the
    example is contained, type the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，打开命令提示符，并在包含示例的相同文件夹中输入以下内容：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By executing the preceding example, we can see the execution of the three execution
    models with relative times:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行上述例子，我们可以看到三种执行模型的执行时间：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It should be noted that although the example is not expensive in computational
    terms, sequential and thread pool execution are comparable in terms of time. Using
    a process pool gives us the fastest execution time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，尽管这个例子在计算方面不算昂贵，但是顺序执行和线程池执行在时间上是可比的。使用进程池可以获得最快的执行时间。
- en: The pool then distributes the processes (in this case, five processes) between
    the available cores (for this example, a machine with four cores was used) in
    **FIFO** (short for **first in, first out**) mode.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，池将进程（在本例中为五个进程）以**FIFO**（先进先出）模式分配给可用的核心（对于本例，使用了一个有四个核心的机器）。
- en: So, for each core, the assigned process runs in series. Only after the I/O operation
    is performed does the pool schedule the execution of another process. Of course,
    the execution mechanism is the same if you use a thread pool.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于每个核心，分配的进程按顺序运行。只有在执行I/O操作后，池才会安排执行另一个进程。当然，如果使用线程池，执行机制是相同的。
- en: The computational times, which are lower in the case of the process pool, must
    be traced back to the fact that I/O operations are not significant. This allows
    the pool of processes to be faster because, unlike threads, they do not require
    any synchronization mechanisms (as explained in [Chapter 1](64fc65f9-fe29-4c34-9da7-13f272eaab9e.xhtml), *Getting
    Started with Parallel Computing and Python*, in the *Introducing parallel programming* recipe).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在进程池的情况下，计算时间较短，这要归因于I/O操作不重要的事实。这使得进程池可以更快，因为与线程不同，它们不需要任何同步机制（如在*并行计算和Python入门*的*介绍并行编程*中所解释的）。
- en: There's more...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The pooling technique is widely used in server applications, as it is necessary
    to manage multiple simultaneous requests from any number of clients.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 池技术广泛用于服务器应用程序，因为需要处理来自任意数量客户端的多个同时请求。
- en: 'Many other applications, however, require that every activity be performed
    immediately or that you have more control over the thread that runs it: in this
    case, pooling is not the best choice.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多其他应用程序要求每个活动立即执行，或者您对运行它的线程有更多控制：在这种情况下，池不是最佳选择。
- en: See also
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'An interesting tutorial on `concurrent.futures` can be found here: [http://masnun.com/2016/03/29/python-a-quick-introduction-to-the-concurrent-futures-module.html](http://masnun.com/2016/03/29/python-a-quick-introduction-to-the-concurrent-futures-module.html).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里可以找到有关`concurrent.futures`的有趣教程：[http://masnun.com/2016/03/29/python-a-quick-introduction-to-the-concurrent-futures-module.html](http://masnun.com/2016/03/29/python-a-quick-introduction-to-the-concurrent-futures-module.html)。
- en: Managing the event loop with asyncio
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用asyncio管理事件循环
- en: The `asyncio` Python module provides facilities for managing events, coroutines,
    tasks, as well as threads, and synchronization primitives for writing concurrent
    code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio` Python模块提供了管理事件、协程、任务以及线程和同步原语以编写并发代码的便利设施。'
- en: 'The main components of this module are as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块的主要组件如下：
- en: '**Event loop**: The `asyncio` module allows one event loop per process. This
    is the entity that deals with managing and distributing the execution of different
    tasks. In particular, this registers the tasks and manages them by switching the
    control flow from one task to another.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件循环**：`asyncio`模块允许每个进程一个事件循环。这是处理和分配执行不同任务的实体。特别是，它注册任务并通过从一个任务切换控制流来管理它们。'
- en: '**Coroutines**: This is a generalization of the concept of the subroutine.
    Also, a coroutine can be suspended during execution to wait for external processing
    (some routine in I/O) and return from the point it had stopped at when the external
    processing is done.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协程**：这是子例程概念的泛化。此外，协程可以在执行期间暂停以等待外部处理（I/O中的某个例程）并在外部处理完成时从停止的点返回。'
- en: '**Futures**: This defines the `Future` object exactly like the `concurrent.futures`
    module. It represents a computation that *has still not been accomplished*.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Futures**：这与`concurrent.futures`模块完全相同。它表示*尚未完成的计算*。'
- en: '**Tasks**: This is a subclass of `asyncio` that is used to encapsulate and
    manage coroutines in a parallel mode.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务**：这是`asyncio`的一个子类，用于以并行模式封装和管理协程。'
- en: In this recipe, the focus is on the concept of eventsand event management (namely, event
    loops) within a software program.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，重点是软件程序中的事件和事件管理（即事件循环）的概念。
- en: Understanding event loops
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解事件循环
- en: In computer science, an *event *is an action intercepted by the program that
    can be managed by the program itself. As an example, an event could be the virtual
    pressure of a key by the user during interaction with the graphical interface,
    the pressure of a key on the physical keyboard, an external interrupt signal,
    or, more abstractly, the reception of data through the network. But more generally,
    any other form of event that has happened that can be detected and managed in
    some way.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，*事件*是程序拦截并可以由程序本身管理的操作。例如，事件可以是用户在与图形界面交互期间虚拟按键的压力，物理键盘上的按键压力，外部中断信号，或者更抽象地说，通过网络接收数据。但更一般地，任何其他形式的事件发生都可以以某种方式被检测和管理。
- en: Within a system, the entity that can generate events is called an *event source*,
    while the entity that deals with handling an event that occurs are an event handler.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统内，可以生成事件的实体称为*事件源*，而处理发生的事件的实体称为事件处理程序。
- en: The *event loop* programming construct realizes the functionality of managing
    events within a program. More precisely, the event loop acts cyclically during
    the whole execution of the program, keeping track of events that have occurred
    within a data structure to queue and then process them one at a time by invoking
    the event handler if the main thread is free.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*事件循环*编程构造实现了程序内部事件的管理功能。更确切地说，事件循环在整个程序执行期间循环执行，跟踪发生的事件并将其排队，然后通过调用事件处理程序逐个处理它们，如果主线程空闲。'
- en: 'The pseudocode of the event loop manager is shown here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环管理器的伪代码如下所示：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All the events that are fed into the `while` loop are caught and then processed
    by the event handler. The handler that processes an event is the only activity
    taking place in the system. When the handler has ended, control passes to the
    next event scheduled.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所有输入`while`循环的事件都被捕获，然后由事件处理程序处理。处理事件的处理程序是系统中唯一正在进行的活动。处理程序结束后，控制权转移到下一个计划的事件。
- en: '`asyncio` provides the following methods to manage an event loop:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`提供以下方法来管理事件循环：'
- en: '`loop = get_event_loop()`: This gets the event loop for the current context.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop = get_event_loop()`: 这获取当前上下文的事件循环。'
- en: '`loop.call_later(time_delay,callback,argument)`: This arranges for the callback
    to be called after the given `time_delay`, in seconds.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop.call_later(time_delay,callback,argument)`: 这安排在给定的`time_delay`后调用回调，单位为秒。'
- en: '`loop.call_soon(callback, argument)`: This arranges for a callback to be called
    as soon as possible. The callback is called after `call_soon()` ([https://docs.python.org/3/library/asyncio-eventloop.html](https://docs.python.org/3/library/asyncio-eventloop.html))
    returns when control returns to the event loop.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop.call_soon(callback, argument)`: 这安排一个回调尽快被调用。当控制返回到事件循环时，`call_soon()`（[https://docs.python.org/3/library/asyncio-eventloop.html](https://docs.python.org/3/library/asyncio-eventloop.html)）返回后调用回调。'
- en: '`loop.time()`: This returns the current time as a `float` value ([https://docs.python.org/3/library/functions.html](https://docs.python.org/3/library/functions.html)),
    according to the event loop''s internal clock.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop.time()`: 这将根据事件循环的内部时钟返回当前时间作为`float`值（[https://docs.python.org/3/library/functions.html](https://docs.python.org/3/library/functions.html)）。'
- en: '`asyncio.set_event_loop()`: This sets the event loop for the current context
    to loop.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio.set_event_loop()`: 这将当前上下文的事件循环设置为`loop`。'
- en: '`asyncio.new_event_loop()`: This creates and returns a new event loop object
    according to this policy''s rules.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio.new_event_loop()`: 这根据此策略的规则创建并返回一个新的事件循环对象。'
- en: '`loop.run_forever()`: This runs until `stop()` ([https://docs.python.org/3/library/asyncio-eventloop.html](https://docs.python.org/3/library/asyncio-eventloop.html))
    is called.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop.run_forever()`: 这将一直运行，直到调用`stop()`（[https://docs.python.org/3/library/asyncio-eventloop.html](https://docs.python.org/3/library/asyncio-eventloop.html)）。'
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In this example, we look at how to use the event loop statements provided by
    the `asyncio` library, in order to build an application that works in asynchronous
    mode.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看一下如何使用`asyncio`库提供的事件循环语句，以便构建一个以异步模式工作的应用程序。
- en: In this example, we defined three tasks. Each task has an execution time determined
    by a time random parameter. Once the execution is finished, **Task A** calls **Task
    B**, **Task B** calls **Task C**, and **Task C** calls **Task A**.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了三个任务。每个任务的执行时间由一个随机时间参数确定。一旦执行完成，**Task A**调用**Task B**，**Task B**调用**Task
    C**，**Task C**调用**Task A**。
- en: 'The event loop will continue until a termination condition is met. As we can
    imagine, this example follows this asynchronous schema:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环将持续进行，直到满足终止条件。正如我们可以想象的那样，这个例子遵循这个异步模式：
- en: '![](assets/49fee3e4-437a-47a5-b656-1ecf755cf488.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/49fee3e4-437a-47a5-b656-1ecf755cf488.png)'
- en: Asynchronous programming model
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程模型
- en: 'Let''s have a look at the following steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: 'Let''s start by importing the libraries needed for our implementation:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从导入我们实现所需的库开始：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we define `task_A`, whose execution time is determined randomly and can
    vary from `1` to `5` seconds. At the end of the execution, if the termination
    condition is not satisfied, then the computation goes to `task_B`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了`task_A`，其执行时间是随机确定的，可以从`1`到`5`秒不等。在执行结束时，如果终止条件没有满足，那么计算就会转到`task_B`：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, `task_B` is defined.Its execution time is determined randomly and can
    vary from `4` to `7` seconds. At the end of the execution, if the termination
    condition is not satisfied, then the computation goes to `task_B`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，定义了`task_B`。它的执行时间是随机确定的，可以从`4`到`7`秒不等。在执行结束时，如果终止条件没有满足，那么计算就会转到`task_B`：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, `task_C` is implemented. Its execution time is determined randomly and
    can vary from `6` to `10` seconds. At the end of the execution, if the termination
    condition is not satisfied, then the computation goes back to `task_A`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，实现`task_C`。它的执行时间是随机确定的，可以从`6`到`10`秒不等。在执行结束时，如果终止条件没有满足，那么计算就会回到`task_A`：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The next statement defines the `loop` parameter, which simply gets the current
    event loop:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个语句定义了`loop`参数，它只是获取当前事件循环：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `end_loop` value defines the termination condition. The execution of this
    example code must last `60` seconds:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`end_loop`值定义了终止条件。这个例子代码的执行时间必须为`60`秒：'
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, let''s request the execution of `task_A`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们请求执行`task_A`：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we set a long duration cycle that continues to respond to events until
    it is stopped:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们设置一个长时间循环，直到停止响应事件为止：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, close the event loop:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，关闭事件循环：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In order to manage the execution of the three tasks, `task_A`, `task_B`, and `task_C`,
    we need to capture the event loop:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理三个任务`task_A`、`task_B`和`task_C`的执行，我们需要捕获事件循环：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we schedule the first call to `task_A` by using the`call_soon` construct:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`call_soon`构造安排第一次调用`task_A`：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s note the definition of `task_A`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们注意`task_A`的定义：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The asynchronous behavior of the application is determined by the following
    parameters:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的异步行为由以下参数确定：
- en: '`time.sleep(random.randint(0, 5))`: This defines the duration time of the task
    execution.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.sleep(random.randint(0, 5))`: 这定义了任务执行的持续时间。'
- en: '`end_time`: This defines the upper time limit within`task_A`and makes the call
    to `task_B` through the`call_later` method.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end_time`: 这定义了`task_A`中的上限时间，并通过`call_later`方法调用`task_B`。'
- en: '`loop`: This is the event loop captured previously with the `get_event_loop()`
    method.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop`: 这是之前使用`get_event_loop()`方法捕获的事件循环。'
- en: 'After executing the task, `loop.time` is compared to `end_time`. If the execution
    time is within the maximum time (60 seconds), then the computation continues by
    calling `task_B`, otherwise, the computation ends, closing the event loop:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行任务后，将`loop.time`与`end_time`进行比较。如果执行时间在最大时间（60秒）内，那么通过调用`task_B`继续计算，否则，计算结束，关闭事件循环：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For the other two tasks, the operations are practically the same, but only the
    execution time and the call to the next task vary.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于另外两个任务，操作几乎相同，只是执行时间和对下一个任务的调用不同。
- en: 'Now, let me summarize the situation:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我总结一下情况：
- en: '`task_A` calls `task_B` with a random execution time between 1 and 5 seconds.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`task_A`以1到5秒之间的随机执行时间调用`task_B`。'
- en: '`task_B` calls `task_C` with a random execution time between 4 and 7 seconds.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`task_B`以4到7秒之间的随机执行时间调用`task_C`。'
- en: '`task_C` calls `task_A` with a random execution time between 6 and 10 seconds.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`task_C`以6到10秒之间的随机执行时间调用`task_A`。'
- en: 'When the running time expires, the event loop must end:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时间到期时，事件循环必须结束：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A possible output of this example would be the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的可能输出如下：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There's more...
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Asynchronous event programming replaces a type of concurrent programming in
    which several parts of the program are executed simultaneously by different threads
    that have access to the same data in memory, thus giving rise to the problem of
    critical runs. At the same time, it has become essential to be able to exploit
    the different cores of modern CPUs because, in certain areas, performance similar
    to that made available by the latter can no longer be achieved with a single-core
    processor.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 异步事件编程取代了一种并发编程，其中程序的几个部分由具有对同一内存中数据的访问权限的不同线程同时执行，从而产生了关键运行的问题。与此同时，能够利用现代CPU的不同核心已经变得至关重要，因为在某些领域，单核处理器已经无法实现类似于后者提供的性能。
- en: See also
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here is a good introduction to `asyncio`: [https://hackernoon.com/a-simple-introduction-to-pythons-asyncio-595d9c9ecf8c](https://hackernoon.com/a-simple-introduction-to-pythons-asyncio-595d9c9ecf8c).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于`asyncio`的很好的介绍：[https://hackernoon.com/a-simple-introduction-to-pythons-asyncio-595d9c9ecf8c](https://hackernoon.com/a-simple-introduction-to-pythons-asyncio-595d9c9ecf8c)。
- en: Handling coroutines with asyncio
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用asyncio处理协程
- en: Throughout the various examples presented, we have seen that when a program
    becomes very long and complex, it is convenient to divide it into subroutines,
    each of which implements a specific task. However, subroutines cannot be executed
    independently, but only at the request of the main program, which is responsible
    for coordinating the use of subroutines.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们所呈现的各种示例中，我们已经看到，当程序变得非常长和复杂时，将其分成子程序是方便的，每个子程序实现一个特定的任务。但是，子程序不能独立执行，而只能在主程序的请求下执行，主程序负责协调子程序的使用。
- en: 'In this section, we introduce a generalization of the concept of subroutines,
    known as coroutines: just like subroutines, coroutines compute a single computational
    step, but unlike subroutines, there is no `main` program to coordinate the results.
    The coroutines link themselves together to form a pipeline without any supervising
    function responsible for calling them in a particular order.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们介绍了子程序概念的一个泛化，称为协程：就像子程序一样，协程计算单个计算步骤，但与子程序不同的是，没有“主”程序来协调结果。协程将自己链接在一起，形成一个管道，没有任何监督功能负责按特定顺序调用它们。
- en: 'In a coroutine, the execution point can be suspended and resumed later, since
    the coroutine keeps track of the state of execution. Having a pool of coroutines,
    it is possible to interleave the computations: the first one runs until it *yields
    control back*, then the second runs and goes on down the line.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在协程中，执行点可以被暂停并稍后恢复，因为协程跟踪执行状态。拥有一组协程后，可以交错计算：第一个运行直到*将控制权让出*，然后第二个运行并继续下去。
- en: The interleaving is managed by the event loop, which was described in the *Managing
    the event loop with asyncio* recipe. It keeps track of all the coroutines and
    schedules when they will be executed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 交错由事件循环管理，该事件循环在*使用asyncio管理事件循环*配方中进行了描述。它跟踪所有协程，并安排它们何时执行。
- en: 'Other important aspects of coroutines are as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 协程的其他重要方面如下：
- en: Coroutines allow for multiple entry points that can yield multiple times.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程允许多个入口点，可以多次产生。
- en: Coroutines can transfer execution to any other coroutine.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程可以将执行转移到任何其他协程。
- en: The term *yield* is used here to describe a coroutine pausing and passing the
    control flow to another coroutine.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，术语*yield*用于描述协程暂停并将控制流传递给另一个协程。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will use the following notation to work with coroutines:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下表示法来处理协程：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Coroutines use the `yield from` syntax introduced in PEP 380 (read more at[https://www.python.org/dev/peps/pep-0380/](https://www.python.org/dev/peps/pep-0380/))
    to stop the execution of the current computation and suspends the coroutine's
    internal state.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 协程使用PEP 380中引入的`yield from`语法（在[https://www.python.org/dev/peps/pep-0380/](https://www.python.org/dev/peps/pep-0380/)中阅读更多）来停止当前计算的执行并挂起协程的内部状态。
- en: In particular, in the case of `yield from future`, the coroutine is suspended
    until `future` is done, then the result of `future` will be propagated (or raise
    an exception); in the case of `yield from coroutine`, the coroutine waits for
    another coroutine to produce a result that will be propagated (or raise an exception).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在`yield from future`的情况下，协程被挂起，直到`future`完成，然后将传播`future`的结果（或引发异常）；在`yield
    from coroutine`的情况下，协程等待另一个协程产生结果，该结果将被传播（或引发异常）。
- en: As we shall see in the next example, in which the coroutines will be used to
    simulate a finite state machine, we will use the `yield from coroutine` notation.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一个示例中看到的，其中协程将用于模拟有限状态机，我们将使用`yield from coroutine`表示法。
- en: More on coroutines with `asyncio` are available at [https://docs.python.org/3.5/library/asyncio-task.html](https://docs.python.org/3.5/library/asyncio-task.html).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用`asyncio`的协程的更多信息，请访问[https://docs.python.org/3.5/library/asyncio-task.html](https://docs.python.org/3.5/library/asyncio-task.html)。
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this example, we see how to use coroutines to simulate a finite state machine
    with five states.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们看到如何使用协程来模拟具有五个状态的有限状态机。
- en: A **finite state machine** or **finite state automaton** is a mathematical model
    that is widely used in engineering disciplines, but also in sciences such as mathematics
    and computer science.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**有限状态机**或**有限状态自动机**是一种在工程学科中广泛使用的数学模型，也在数学和计算机科学等科学中使用。'
- en: 'The automaton that we want to simulate the behavior of using coroutines is
    as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要使用协程模拟行为的自动机如下：
- en: '![](assets/11c82c0c-3add-446c-8ca7-ba4f599bc622.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/11c82c0c-3add-446c-8ca7-ba4f599bc622.png)'
- en: Finite-state machine
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有限状态机
- en: 'The states of the system are **S0**, **S1**, **S2**, **S3**, and **S4**, with
    **0** and **1**: the values for which the automaton can pass from one state to
    the next state (this operation is called a *transition*). So, for example, state
    **S0** can pass to state **S1**, but only for the value **1**, and **S0** can
    pass to state **S2**, but only for the value **0**.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的状态为**S0**、**S1**、**S2**、**S3**和**S4**，其中**0**和**1**是自动机可以从一个状态过渡到下一个状态的值（这个操作称为*过渡*）。例如，状态**S0**可以过渡到状态**S1**，但只能为值**1**，**S0**可以过渡到状态**S2**，但只能为值**0**。
- en: 'The following Python code simulates a transition of the automaton from state
    **S0** (the start state), up to state **S4** (the end state):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Python代码模拟了自动机从状态**S0**（起始状态）到状态**S4**（结束状态）的过渡：
- en: 'The first step is obviously to import the relevant libraries:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先要做的是导入相关的库：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we define the coroutine relative to `start_state`. The `input_value`
    parameter is evaluated randomly; it can be `0` or `1`. If it is `0`, then the
    control goes to coroutine `state2`; otherwise, it changes to coroutine `state1`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了相对于`start_state`的协程。`input_value`参数是随机评估的；它可以是`0`或`1`。如果是`0`，则控制转移到协程`state2`；否则，它会改变为协程`state1`：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here is the coroutine for `state1`. The `input_value` parameter is evaluated
    randomly; it can be `0` or `1`. If it is `0`, then the control goes to `state2`;
    otherwise, it changes to `state1`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`state1`的协程。`input_value`参数是随机评估的；它可以是`0`或`1`。如果是`0`，则控制转移到`state2`；否则，它会改变为`state1`：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The coroutine for `state1` has the`transition_value` argument that allowed
    the passage of the state. Also, in this case, `input_value` is randomly evaluated.
    If it is `0`, then the state transitions to `state3`; otherwise, the control changes
    to `state2`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`state1`的协程具有允许状态过渡的`transition_value`参数。同样，在这种情况下，`input_value`是随机评估的。如果是`0`，则状态转换到`state3`；否则，控制转移到`state2`：'
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The coroutine for `state3`has the `transition_value` argument, whichallowed
    the passage of the state. `input_value` is randomly evaluated. If it is `0`, then
    the state transitions to `state1`; otherwise, the control changes to `end_state`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`state3`的协程具有`transition_value`参数，允许状态过渡。`input_value`是随机评估的。如果是`0`，则状态转换到`state1`；否则，控制转移到`end_state`：'
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`end_state` prints out the `transition_value` argument, which allowed the passage
    of the state, and then stops the computation:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`end_state`打印出允许状态过渡的`transition_value`参数，然后停止计算：'
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the `__main__` function, the event loop is acquired, and then we start the
    simulation of the finite state machine, calling the automaton''s `start_state`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__main__`函数中，获取事件循环，然后我们开始模拟有限状态机，调用自动机的`start_state`：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Each state of the automaton has been defined by using the decorator:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 自动机的每个状态都是通过装饰器定义的：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For example, state **S0** is defined here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，状态**S0**在这里被定义：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The transition to the next state is determined by `input_value`, which is defined
    by the `randint (0,1)` function of Python's `random` module.This function randomly provides
    a value of `0` or `1`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个状态的过渡由`input_value`决定，它由Python的`random`模块的`randint (0,1)`函数定义。这个函数随机提供`0`或`1`的值。
- en: 'In this manner, `randint` randomly determines the state to which the finite
    state machine will pass:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`randint`随机确定有限状态机将过渡到的状态：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After determining the values to pass, the coroutine calls the next coroutine
    using the `yield from` command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 确定要传递的值后，协程使用`yield from`命令调用下一个协程：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `result` variable is the value that each coroutine returns. It is a string,
    and, at the end of the computation, we can reconstruct the transition from the
    initial state of the automaton, `start_state`, up to `end_state`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`result`变量是每个协程返回的值。它是一个字符串，在计算结束时，我们可以重构从自动机的初始状态`start_state`到`end_state`的过渡。'
- en: 'The `main` program starts the evaluation inside the event loop:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`程序在事件循环内开始评估：'
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Running the code, we have an output like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码，我们有以下输出：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There's more...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Before Python 3.5 was released, the `asyncio` module used generators to mimic
    asynchronous calls and, therefore, had a different syntax than the current version
    of Python 3.5.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.5发布之前，`asyncio`模块使用生成器来模拟异步调用，因此与Python 3.5的当前版本有不同的语法。
- en: Python 3.5 introduced the `async` and `await` keywords.Notice the lack of parentheses
    around the `await func()` call.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.5引入了`async`和`await`关键字。请注意，在`await func()`调用周围没有括号。
- en: 'The following is an example of `"Hello, world!"`, using `asyncio` with the
    new syntax introduced by Python 3.5+:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用Python 3.5+引入的新语法和`asyncio`的`"Hello, world!"`的示例：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: See also
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Coroutines in Python are well described here: [https://www.geeksforgeeks.org/coroutine-in-python/](https://www.geeksforgeeks.org/coroutine-in-python/).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的协程在这里有很好的描述：[https://www.geeksforgeeks.org/coroutine-in-python/](https://www.geeksforgeeks.org/coroutine-in-python/)。
- en: Manipulating tasks with asyncio
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用asyncio操纵任务
- en: The `asyncio`module is designed to handle asynchronous processes and concurrent
    task execution over an event loop. It also provides the `asyncio.Task()` class
    for the purpose of wrapping coroutines in a task ([https://docs.python.org/3/library/asyncio-task.html](https://docs.python.org/3/library/asyncio-task.html)).
    Its use is to allow independently running tasks to run concurrently with other
    tasks over the same event loop.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`模块旨在处理异步进程和事件循环上的并发任务执行。它还提供了`asyncio.Task()`类，用于将协程包装在任务中（[https://docs.python.org/3/library/asyncio-task.html](https://docs.python.org/3/library/asyncio-task.html)）。它的用途是允许独立运行的任务与同一事件循环上的其他任务并发运行。'
- en: When a coroutine is wrapped in a task, it connects `Task` to the event loop
    and then runs automatically when the loop is started, thus providing a mechanism
    for automatically driving the coroutine.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个协程被包装在一个任务中时，它将`Task`连接到事件循环，然后在循环启动时自动运行，从而提供了自动驱动协程的机制。
- en: The `asyncio` module provides the `asyncio.Task(coroutine)` method to handle
    computations with tasks; moreover, `asyncio.Task(coroutine)` schedules the execution
    of a coroutine ([https://docs.python.org/3/library/asyncio-task.html](https://docs.python.org/3/library/asyncio-task.html)).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`模块提供了`asyncio.Task(coroutine)`方法来处理任务的计算；此外，`asyncio.Task(coroutine)`安排了协程的执行（[https://docs.python.org/3/library/asyncio-task.html](https://docs.python.org/3/library/asyncio-task.html)）。'
- en: A task is responsible for executing a coroutine object in an *event loop.*
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一个任务负责在*事件循环*中执行一个协程对象。
- en: If the wrapped coroutine uses the `yields from future` notation, as already
    described in the *Handling coroutines with asyncio* section*, *then the task suspends
    the execution of the wrapped coroutine and awaits completion of the future.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包装的协程使用`yields from future`表示法，如*使用asyncio处理协程*部分中已经描述的那样，那么任务将暂停包装的协程的执行并等待未来的完成。
- en: When the future is done, the execution of the wrapped coroutine restarts with
    the result or the exception of the future. Also, we must note that an event loop
    only runs one task at a time. Other tasks may run in parallel if other event loops
    are running in different threads.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当未来完成时，包装的协程的执行将重新开始，使用未来的结果或异常。此外，必须注意，事件循环一次只运行一个任务。如果其他事件循环在不同的线程中运行，则其他任务可以并行运行。
- en: While a task waits for the completion of a future, the event loop executes a
    new task.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当任务等待未来的完成时，事件循环执行一个新任务。
- en: How to do it...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this example, we show how three mathematical functions can be executed concurrently
    by the `asyncio.Task()` statement:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们展示了如何通过`asyncio.Task()`语句同时执行三个数学函数：
- en: 'Of course, let''s start by importing the `asyncio` library:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，让我们首先导入`asyncio`库：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the first coroutine, the `factorial` function is defined:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个协程中，定义了`factorial`函数：
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After which, the second function is defined—the `fibonacci` function:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，定义第二个函数——`fibonacci`函数：
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The last function to be executed concurrently is the binomial coefficient:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后并行执行的函数是二项式系数：
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the `__main__` function, `task_list` contains the functions that must be
    performed in parallel using the `asyncio.Task` function:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__main__`函数中，`task_list`包含了必须使用`asyncio.Task`函数并行执行的函数：
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we acquire the event loop and start the computation:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们获取事件循环并开始计算：
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Each coroutine is defined by the `@asyncio.coroutine` annotation (called the*decorator*):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 每个协程都由`@asyncio.coroutine`注释（称为*装饰器*）定义：
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To run in parallel, each function is an argument of the `asyncio.Task` module,
    and therefore, they are included in `task_list`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了并行运行，每个函数都是`asyncio.Task`模块的参数，因此它们包含在`task_list`中：
- en: '[PRE52]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, we get the event loop:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们得到了事件循环：
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, we add the execution of `task_list` to the event loop:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`task_list`的执行添加到事件循环中：
- en: '[PRE54]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that the `asyncio.wait(task_list)` statement waits for the given coroutines
    to complete.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`asyncio.wait(task_list)`语句等待给定的协程完成。
- en: 'The output for the preceding code looks like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE55]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: There's more...
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`asyncio` provides other ways to schedule tasks using the `ensure_future()`
    or `AbstractEventLoop.create_task()` methods, which both accept a coroutine object.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`提供了使用`ensure_future()`或`AbstractEventLoop.create_task()`方法调度任务的其他方法，两者都接受一个协程对象。'
- en: See also
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'More on `asyncio` and tasks can be found here: [https://tutorialedge.net/python/concurrency/asyncio-tasks-tutorial/](https://tutorialedge.net/python/concurrency/asyncio-tasks-tutorial/).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`asyncio`和任务的更多信息可以在这里找到：[https://tutorialedge.net/python/concurrency/asyncio-tasks-tutorial/](https://tutorialedge.net/python/concurrency/asyncio-tasks-tutorial/)。
- en: Dealing with asyncio and futures
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理asyncio和futures
- en: 'Another key component of the `asyncio` module is the`asyncio.Future` class.It
    is very similar to `concurrent.Futures`, but, of course, it is adapted to the
    main mechanism of `asyncio`: the event loop.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`模块的另一个关键组件是`asyncio.Future`类。它与`concurrent.Futures`非常相似，但当然，它适应了`asyncio`的主要机制：事件循环。'
- en: The `asyncio.Future` class represents a result (but can also be an exception)
    that is not yet available.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio.Future`类代表尚不可用的结果（但也可以是异常）。'
- en: Hence, it represents an abstraction of something that is yet to be achieved.
    The callbacks that have to process any results are, in fact, added to instances
    of this class.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它代表了一些尚未实现的东西的抽象。必须注意的是，必须处理任何结果的回调实际上是添加到这个类的实例中。
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To define a `future` object, the following syntax must be used:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个`future`对象，必须使用以下语法：
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The main methods to manage this object are the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 管理此对象的主要方法如下：
- en: '`cancel()`: This cancels the `future` object and schedules callbacks.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cancel()`: 这将取消`future`对象并安排回调。'
- en: '`result()`: This returns the result that this `future` represents.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`result()`: 返回此`future`代表的结果。'
- en: '`exception()`: This returns the exception that was set on this `future`.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exception()`: 返回在此`future`上设置的异常。'
- en: '`add_done_callback(fn)`: This adds a callback to be run when `future` is done.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_done_callback(fn)`: 这将在`future`完成时添加一个回调来运行。'
- en: '`remove_done_callback(fn)`: This removes all instances of a callback from the
    call when done.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove_done_callback(fn)`: 这将从完成时的调用中删除所有回调的实例。'
- en: '`set_result(result)`: This marks `future` as done and sets its result.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_result(result)`: 这标记`future`为完成并设置其结果。'
- en: '`set_exception(exception)`: This marks `future` as done and sets an exception.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_exception(exception)`: 这标记`future`为完成并设置异常。'
- en: How to do it...
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following example shows how to use the `asyncio.Future` class for the management
    of two coroutines: `first_coroutine` and `second_coroutine`, which perform the
    following tasks. `first_coroutine` performs the sum of the first *N* integers,
    and `second_coroutine` performs the factorial of N:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何使用`asyncio.Future`类来管理两个协程：`first_coroutine`和`second_coroutine`，它们执行以下任务。`first_coroutine`执行前*N*个整数的和，`second_coroutine`执行N的阶乘：
- en: 'Now, let''s import the relevant libraries:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们导入相关的库：
- en: '[PRE57]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`first_coroutine` implements the `sum` function of the first *N* integers:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`first_coroutine`实现了前*N*个整数的`sum`函数：'
- en: '[PRE58]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In `second_coroutine`, we still implement the `factorial` function:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`second_coroutine`中，我们仍然实现`factorial`函数：
- en: '[PRE59]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Using the `got_result` function, we print the output of the computation:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`got_result`函数，我们打印计算的输出：
- en: '[PRE60]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the `main` function, the `num1` and `num2` parameters must be set by the
    user. They will be used as parameters for the functions implemented by the first
    and second coroutines:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数中，`num1`和`num2`参数必须由用户设置。它们将作为第一个和第二个协程实现的函数的参数：
- en: '[PRE61]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, let''s take the event loop:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来看事件循环：
- en: '[PRE62]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here, the futures are defined by the `asyncio.future` function:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，期货由`asyncio.future`函数定义：
- en: '[PRE63]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The two coroutines—`first_couroutine` and `second_couroutine`—included in the
    `tasks` list have the `future1` and `future2`futures, the user-defined arguments,
    and the `num1` and `num2` parameters:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tasks`列表中包含的两个协程`first_couroutine`和`second_couroutine`分别具有`future1`和`future2`期货、用户定义的参数以及`num1`和`num2`参数：'
- en: '[PRE64]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The futures have added a callback:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 期货已添加回调：
- en: '[PRE65]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, the `tasks` list is added to the event loop, so that the computation
    can begin:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`tasks`列表添加到事件循环中，以便开始计算：
- en: '[PRE66]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How it works...
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In the `main` program, we define the `future` objects,`future1` and `future2` respectively,
    using via the `asyncio.Future()` directive:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`程序中，我们分别使用`asyncio.Future()`指令定义`future`对象`future1`和`future2`：
- en: '[PRE67]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In defining the tasks, we pass the `future` objectsas an argument of the two
    coroutines `first_couroutine` and `second_couroutine`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义任务时，我们将`future`对象作为两个协程`first_couroutine`和`second_couroutine`的参数传递：
- en: '[PRE68]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, we add a callback to be run when `future` is done:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加一个回调函数，当`future`完成时运行：
- en: '[PRE69]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here, `got_result` is a function that prints the result of`future`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`got_result`是一个打印`future`结果的函数：
- en: '[PRE70]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In the coroutine, we pass the `future` object as an argument. After the computation,
    we set `sleep` times of 3 seconds for the first coroutine and 4 seconds for the
    second one:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在协程中，我们将`future`对象作为参数传递。计算后，我们为第一个协程设置3秒的睡眠时间，第二个协程设置4秒的睡眠时间：
- en: '[PRE71]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The following output is obtained by executing the command with different values:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用不同的值执行命令可以获得以下输出：
- en: '[PRE72]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: There's more...
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can invert the output results, that is, have the output of `second_coroutine`
    first, by simply swapping the sleep time between the coroutines:`yield from asyncio.sleep(2)`in
    the `first_coroutine` definition, and`yield from asyncio.sleep(1)` in the `second_coroutine`
    definition. This can be shown by the following example:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以颠倒输出结果，即通过简单地交换协程之间的睡眠时间来先输出`second_coroutine`的输出，即在`first_coroutine`定义中使用`yield
    from asyncio.sleep(2)`，在`second_coroutine`定义中使用`yield from asyncio.sleep(1)`。以下示例可以说明这一点：
- en: '[PRE73]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: See also
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: More examples of `asyncio` and futures can be found at[https://www.programcreek.com/python/example/102763/asyncio.futures](https://www.programcreek.com/python/example/102763/asyncio.futures).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`asyncio`和期货的示例可以在[https://www.programcreek.com/python/example/102763/asyncio.futures](https://www.programcreek.com/python/example/102763/asyncio.futures)找到。

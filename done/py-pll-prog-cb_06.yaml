- en: Distributed Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式Python
- en: This chapter will introduce some important Python modules for distributed computing.
    In particular, we will describe the `socket` module, which allows you to implement
    simple applications distributed through the client-server model.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍一些重要的Python模块，用于分布式计算。特别是，我们将描述`socket`模块，它允许您通过客户端-服务器模型实现简单的分布式应用程序。
- en: Then, we will introduce the Celery module, which is a powerful Python framework
    that is used to manage distributed tasks. Finally, we will describe the `Pyro4`
    module, which allows you to call methods that are used in different processes,
    potentially on a different machine.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将介绍Celery模块，这是一个强大的Python框架，用于管理分布式任务。最后，我们将描述`Pyro4`模块，它允许您调用在不同进程中使用的方法，可能在不同的机器上。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Introducing distributed computing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍分布式计算
- en: Using the Python socket module
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python的socket模块
- en: Distributed task management with Celery
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Celery进行分布式任务管理
- en: Remote Method Invocation (RMI) with `Pyro4`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Pyro4`进行远程方法调用（RMI）
- en: Introducing distributed computing
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍分布式计算
- en: '*Parallel* and *distributed computing* are similar technologies designed to
    increase the amount of processing power available for a specific task. Generally,
    these methods are used to solve problems that require large computational capabilities.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*并行*和*分布式计算*是类似的技术，旨在增加特定任务的处理能力。通常，这些方法用于解决需要大量计算能力的问题。'
- en: When the problem is divided into many small pieces, individual sections of the
    problem can be calculated by many processors simultaneously. This allows more
    processing power to be exercised on the problem than can be provided by a single
    processor.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当问题被分成许多小部分时，问题的各个部分可以同时由许多处理器计算。这允许问题上的处理能力比单个处理器提供的要多。
- en: The main difference between parallel and distributed processing is that parallel
    configurations include many processors within a single system, while distributed
    configurations exploit the processing power of many computers simultaneously.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 并行处理和分布式处理的主要区别在于，并行配置在单个系统内包含许多处理器，而分布式配置利用许多计算机的处理能力。
- en: 'Let''s look at the other differences:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看其他的区别：
- en: '| **Parallel processing** | **Distributed processing** |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **并行处理** | **分布式处理** |'
- en: '| Parallel processing has the advantage of providing reliable processing power
    with a very low degree of latency. | Distributed processing is not extremely efficient
    on a processor-by-processor basis, as the data must travel over the network rather
    than through the internal connections of a single system. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 并行处理具有提供可靠处理能力并具有非常低延迟的优势。 | 分布式处理在处理器的基础上并不是非常高效，因为数据必须通过网络传输，而不是通过单个系统的内部连接传输。
    |'
- en: '| By concentrating all the processing power in one system, speed loss due to
    data transfer is minimized. | Each processor will contribute much less processing
    power than any processor in a parallel system since data transfer creates a bottleneck
    that limits processing power. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 通过将所有处理能力集中在一个系统中，可以最大程度地减少由于数据传输而导致的速度损失。 | 由于数据传输会产生限制处理能力的瓶颈，因此每个处理器提供的处理能力远远低于并行系统中的任何处理器。
    |'
- en: '| The only real limit is the number of processors incorporated in the system.
    | The system is almost infinitely scalable since there is no actual upper limit
    to the number of processors in a distributed system. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 唯一的真正限制是系统中集成的处理器数量。 | 由于分布式系统中处理器数量没有实际上限，因此系统几乎可以无限扩展。 |'
- en: 'However, in the context of computer applications, it is customary to distinguish
    between local and distributed architectures:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在计算机应用的背景下，习惯上区分本地架构和分布式架构：
- en: '| **Local architectures** | **Distributed architectures** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **本地架构** | **分布式架构** |'
- en: '| All the components are on the same machine. | Applications and components
    can reside on different nodes that are connected by a network. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 所有组件都在同一台机器上。 | 应用程序和组件可以驻留在由网络连接的不同节点上。 |'
- en: The advantages of using distributed computing consist mainly of the possibility
    of concurrent use of the programs, the centralization of the data, and the distribution
    of the processing load, which all come at the price of greater complexity, especially
    with communication between the various components.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分布式计算的优势主要在于程序的并发使用、数据的集中化以及处理负载的分布，但这些优势都伴随着更大的复杂性，特别是在各个组件之间的通信方面。
- en: Types of distributed applications
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式应用程序的类型
- en: 'Distributed applications can be classified according to the degree of distribution:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式应用程序可以根据分布程度进行分类：
- en: '**Client-server applications**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端-服务器应用程序**'
- en: '**Multi-level applications**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多级应用程序**'
- en: Client-server applications
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端-服务器应用程序
- en: There are only two levels and the operations are carried out entirely on the
    server. As an example, we can mention the classic static or dynamic websites.
    The tools for the realization of these types of applications are the network sockets,
    whose programming is possible in various languages, including C, C ++, Java, and,
    of course, Python.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 只有两个级别，操作完全在服务器上进行。例如，我们可以提到经典的静态或动态网站。实现这些类型应用的工具是网络套接字，可以用多种语言进行编程，包括C、C++、Java，当然还有Python。
- en: The term *client-server system* refe*rs* to a network architecture in which
    a client computer or client terminal is generally connected to a server for the
    use of a certain service; for example, the sharing of a certain hardware/software
    resource with other clients, or relying on the underlying protocol architecture.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*客户端-服务器系统*指的是一个网络架构，其中客户端计算机或客户端终端通常连接到服务器以使用某项服务；例如，与其他客户端共享某些硬件/软件资源，或依赖底层协议架构。
- en: Client-server architecture
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端-服务器架构
- en: The client-server architecture is a system that realizes a distribution of both
    processing and data. The central element of the architecture is the server. The
    server can be considered both from a logical point of view and from a physical
    point of view. From the physical point of view—hardware—a server is a machine
    dedicated to running a software server.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器架构是一个实现处理和数据分布的系统。架构的中心元素是服务器。服务器可以从逻辑和物理角度来考虑。从物理角度来看，服务器是专门用于运行软件服务器的机器。
- en: From a logical point of view, a server is software. The server, as a logical
    process, provides services to other processes that take on the role of requester
    or client. Generally, the server does not send the results to the requester until
    the results are requested by the client.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑上看，服务器是软件。服务器作为逻辑进程，为扮演请求者或客户端角色的其他进程提供服务。通常情况下，服务器直到客户端请求结果之前不会将结果发送给请求者。
- en: 'A feature that distinguishes the client from its server is that the client
    can initiate a transaction with the server, while the server can never initiate
    a transaction with the client on its own initiative:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 区分客户端和服务器的一个特征是客户端可以与服务器启动事务，而服务器永远不能主动与客户端启动事务：
- en: '![](assets/f9df2fb0-1a78-4826-b494-5e3b43effbf0.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f9df2fb0-1a78-4826-b494-5e3b43effbf0.png)'
- en: Client-server architecture
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器架构
- en: In fact, the specific tasks of the client are to start transactions, request
    specific services, notify the completion of the service, and receive results from
    the server, as shown in the preceding diagram.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，客户端的具体任务是启动事务，请求特定服务，通知服务完成，并从服务器接收结果，如前图所示。
- en: Client-server communications
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端-服务器通信
- en: Communication between clients and servers can take place using a variety of
    mechanisms—from geographic to local networks, up to communication services—between
    applications at the OS level. Furthermore, a client-server architecture must be
    independent of the physical connection method that exists between the client and
    the server.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器之间的通信可以使用各种机制——从地理网络到本地网络，直到操作系统级别的应用程序之间的通信服务。此外，客户端-服务器架构必须独立于客户端和服务器之间存在的物理连接方法。
- en: It should also be noted that it is not necessary for a client-server process
    to reside on physically separate systems. In fact, the server process and the
    client process can reside on the same computing platform.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 还应该注意的是，客户端-服务器进程不必驻留在物理上分离的系统上。事实上，服务器进程和客户端进程可以驻留在同一计算平台上。
- en: The main objective of the client-server architecture, in the context of data
    management, is to allow client applications to access data managed by the servers.
    The server (understood in a logical sense as software) is often running on a remote
    system (for example, in another city or on a local network).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据管理的背景下，客户端-服务器架构的主要目标是允许客户端应用程序访问服务器管理的数据。服务器（在逻辑上理解为软件）通常运行在远程系统上（例如，在另一个城市或本地网络上）。
- en: Therefore, client-server applications are often associated with distributed
    processing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，客户端-服务器应用程序通常与分布式处理相关联。
- en: TCP/IP client-server architecture
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP客户端-服务器架构
- en: The TCP/IP connection establishes a point-to-point connection between two applications.
    The extremes of this connection are marked by an IP address, which identifies
    the workstation by a port number, which makes it possible to have several connections
    that are connected to independent applications on the same workstation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP连接在两个应用程序之间建立了点对点的连接。这种连接的两端由IP地址标记，IP地址标识了工作站，而端口号使得可以在同一工作站上连接到独立应用程序的多个连接。
- en: Once the connection is established and the protocol can exchange data over it,
    the underlying TCP/IP protocol takes care of sending this data, divided into packets,
    from one end of the connection to the other. In particular, the TCP protocol deals
    with assembling and disassembling the packets, as well as managing the handshaking
    that guarantees the reliability of the connection, while the IP protocol takes
    care of transporting the individual packets and the choice of the best routing
    of the packets along with the network.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接建立，协议可以在其上交换数据，底层的TCP/IP协议负责将这些数据分成数据包，从连接的一端发送到另一端。特别是，TCP协议负责组装和拆卸数据包，以及管理握手来保证连接的可靠性，而IP协议负责传输单个数据包和选择最佳的路由来沿着网络传输数据包。
- en: This mechanism underlies the robustness of the TCP/IP protocol, which, in turn,
    represents one of the reasons for the development of the protocol itself in the
    military sphere (ARPANET).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制是TCP/IP协议稳健性的基础，而TCP/IP协议的发展又是军事领域（ARPANET）发展的原因之一。
- en: The various existing standard applications (such as web browsing, file transfer,
    and email) use standardized application protocols, such as HTTP, FTP, POP3, IMAP,
    and SMTP.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 各种现有的标准应用程序（如Web浏览、文件传输和电子邮件）使用标准化的应用程序协议，如HTTP、FTP、POP3、IMAP和SMTP。
- en: Each specific client-server application must instead define and apply its own
    proprietary application protocol. This can involve the exchange of data in blocks
    of a fixed size (which is the simplest solution).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每个特定的客户端-服务器应用程序必须定义和应用自己的专有应用程序协议。这可能涉及以固定大小的数据块交换数据（这是最简单的解决方案）。
- en: Multi-level applications
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多级应用程序
- en: 'There are a greater number of levels that enable the processing load of the
    servers to be alleviated. Those that are, in fact, subdivided are the functionalities
    of the server-side, leaving the characteristics of the client part that has the
    task of hosting the application interface largely unchanged. An example of this
    type of architecture is that of the three-tier model, having a structure divided
    into three layers or levels:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多级别可以减轻服务器的处理负载。实际上，被细分的是服务器端的功能，而客户端部分的特性基本保持不变，其任务是托管应用程序界面。这种架构的一个例子是三层模型，其结构分为三层或级别：
- en: Frontend or presentation tier or interface
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端或演示层或界面
- en: Middle tier or application logic
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间层或应用逻辑
- en: Backend or data tier or persistent data management
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端或数据层或持久数据管理
- en: 'This nomenclature is typical of web applications. More generally, it is possible
    to refer to a subdivision in three levels that are applicable to any software
    application, which is the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这种命名方式通常用于Web应用程序。更一般地，可以将任何软件应用程序分为三个级别，如下所示：
- en: '**Presentation Layer** (**PL**): This is the visualization part of the data
    (such as modules and controls of input) necessary for the user interface.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示层**（**PL**）：这是数据的可视化部分（例如用户界面所需的模块和输入控件）。'
- en: '**Business Logic Layer** (**BLL**): This is the main part of the application,
    which defines the various entities and their relationships independently of the
    methods of presentation available to the user and saved in the archives.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务逻辑层**（**BLL**）：这是应用程序的主要部分，独立于用户可用的演示方法并保存在档案中，定义了各种实体及其关系。'
- en: '**Data Access Layer** (**DAL**): This contains everything necessary for the
    management of persistent data (essentially, database management systems).'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据访问层**（**DAL**）：其中包含管理持久数据所需的一切（基本上是数据库管理系统）。'
- en: This chapter will present some of the solutions proposed by Python for the implementation
    of distributed architectures. We will begin by describing the `socket` module
    with which we will implement some examples of the fundamental client-server model.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍Python提出的一些分布式架构的解决方案。我们将首先描述`socket`模块，然后使用它来实现一些基本的客户端-服务器模型的示例。
- en: Using the Python socket module
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python套接字模块
- en: A socket is a software object that allows data to be sent and received between
    remote hosts (via a network) or between local processes, such as **Inter-Process
    Communication** (**IPC**).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是一种软件对象，允许在远程主机（通过网络）或本地进程之间发送和接收数据，例如**进程间通信**（**IPC**）。
- en: Sockets were invented at Berkeley as part of the **BSD Unix** project. They
    are based precisely on the management model of input and output of Unix files.
    In fact, the operations of opening, reading, writing, and closing a socket occur
    in the same way as the management of Unix files, but with the difference that
    should be considered are the useful parameters for communication, such as addresses,
    port numbers, and protocols.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是在伯克利作为**BSD Unix**项目的一部分发明的。它们基于Unix文件的输入和输出管理模型。事实上，打开、读取、写入和关闭套接字的操作与Unix文件的管理方式相同，但需要考虑的区别是用于通信的有用参数，如地址、端口号和协议。
- en: The success and spread of socket technology have gone hand in hand with the
    development of the internet. In fact, the combination of sockets with the internet
    has made communication between machines that are of any type, and/or are scattered
    throughout the world, incredibly easy (at least when compared with other systems).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字技术的成功和传播与互联网的发展息息相关。事实上，套接字与互联网的结合使得任何类型的机器之间的通信以及分散在世界各地的机器之间的通信变得非常容易（至少与其他系统相比是如此）。
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The socket Python module exposes low-level C APIs for communication over a network
    using the **BSD** *(*short for **Berkeley Software Distribution**) socket interface.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Python套接字模块公开了用于使用**BSD**（**Berkeley Software Distribution**的缩写）套接字接口进行网络通信的低级C
    API。
- en: 'This module includes the `Socket` class, which includes the main methods for
    managing the following tasks:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块包括`Socket`类，其中包括管理以下任务的主要方法：
- en: '`socket ([family [, type [, protocol]]])`: Builds a socket using the following
    as arguments:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket([family [, type [, protocol]]])`: 使用以下参数构建套接字：'
- en: The `family` address, which can be `AF_INET (default)`, `AF_INET6`, or `AF_UNIX`
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`family`地址，可以是`AF_INET（默认）`，`AF_INET6`，或`AF_UNIX`'
- en: The `type` socket, which can be `SOCK_STREAM (default)`, `SOCK_DGRAM`, or perhaps
    one of the other `"SOCK_"` constants
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`套接字，可以是`SOCK_STREAM（默认）`，`SOCK_DGRAM`，或者其他`"SOCK_"`常量之一'
- en: The `protocol` number (that is usually zero)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protocol`号码（通常为零）'
- en: '`gethostname()`: Returns the current IP address of the machine.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gethostname()`: 返回机器的当前IP地址。'
- en: '`accept ()`: Returns the following pair of values (`conn` and `address`), where
    `conn` is a socket type object (to send/receive data on the connection), while
    `address` is the address connected to the socket on the other end of the connection.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accept()`: 返回以下一对值（`conn`和`address`），其中`conn`是套接字类型对象（用于在连接上发送/接收数据），而`address`是连接到连接的另一端的套接字的地址。'
- en: '`bind (address)`: Associates the socket with the `address` server.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bind(address)`: 将套接字与服务器的`address`关联。'
- en: This method historically accepted a couple of parameters for the `AF_INET` addresses
    instead of a single tuple.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法历史上接受`AF_INET`地址的一对参数，而不是单个元组。
- en: '`close ()`: Provides the option to clean up the connection once communication
    with the client is finished. The sockets are closed and collected by the garbage
    collector.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close()`: 提供选项，一旦与客户端的通信结束，就可以清理连接。套接字被关闭并由垃圾收集器收集。'
- en: '`connect(address)`: Connects a remote socket to an address. The `address` format
    depends on the family address.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect(address)`: 将远程套接字连接到地址。`address`格式取决于地址族。'
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: In the following example, the server is listening on a default port, and by
    following a TCP/IP connection, the client sends to the server the date and time that
    the connection was established.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，服务器正在监听默认端口，并通过TCP/IP连接，客户端向服务器发送连接建立的日期和时间。
- en: 'Here is the server implementation for `server.py`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`server.py`的服务器实现：
- en: 'Import the relevant Python modules:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入相关的Python模块：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a new socket using the given address, socket type, and protocol number:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用给定的地址、套接字类型和协议号创建新的套接字：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Get the local machine name (`host`):'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取本地机器名称（`host`）：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Set the `port` number:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`port`号码：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Connect (bind) the socket to `host` and to`port`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将套接字连接（绑定）到`host`和`port`：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listen for connections made to the socket. The argument of `5` specifies the
    maximum number of connections in the queue. The maximum value depends on the system
    (usually, it is `5`) and the minimum value is always `0`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听套接字的连接。`5`的参数指定了队列中的最大连接数。最大值取决于系统（通常为`5`），最小值始终为`0`：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Establish a connection:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立连接：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, the connection is accepted. The return value is a pair (`conn`, `address`),
    where `conn`is a new `socket` object that is used to send and receive data, and
    `address` is the address linked to the socket. Once accepted, a new socket is
    created and it will have its own identifier. This new socket is only used with
    this particular client:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，接受连接。返回值是一对（`conn`，`address`），其中`conn`是用于发送和接收数据的新`socket`对象，`address`是与套接字关联的地址。一旦接受，将创建一个新的套接字，并且它将有自己的标识符。这个新的套接字只用于这个特定的客户端：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The address and the port that is connected are printed out:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印连接的地址和端口：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`currentTime` is evaluated:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估`currentTime`：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following statement sends data to the socket, returning the number of bytes
    sent:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下语句将数据发送到套接字，并返回发送的字节数：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following statement indicates the socket closure (that is, the communication
    channel); all subsequent operations on the socket will fail. The sockets are automatically
    closed when they are rejected, but it is always recommended to close them with
    the `close()` operation:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下语句表示套接字关闭（即通信通道）；套接字上的所有后续操作都将失败。当套接字被拒绝时，它们会自动关闭，但始终建议使用`close()`操作关闭它们：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The code for the client (`client.py`) is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端（`client.py`）的代码如下：
- en: 'Import the `socket` library:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`socket`库：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `socket` object is then created:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建`socket`对象：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Get the local machine name (`host`):'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取本地机器名称（`host`）：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Set the `port` number:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`port`号码：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Set up the connection to `host`and `port`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立到`host`和`port`的连接：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The maximum number of bytes that can be received is no more than 1,024 bytes:
    (`tm=s.recv(1024)`).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以接收的最大字节数不超过1024字节：（`tm=s.recv(1024)`）。
- en: 'Now, close the connection and finally print out the connection time to the
    server:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，关闭连接并最终打印连接到服务器的连接时间：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Clients and servers create their respective sockets, and the server listens
    to them on a port. The client makes a connection request to the server. It should
    be noted that we can have two different port numbers because one could only be
    dedicated to outgoing traffic, and the other could only be dedicatedto entry.
    This depends on the host configuration.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器分别创建它们的套接字，并在一个端口上监听它们。客户端向服务器发出连接请求。应该注意，我们可以有两个不同的端口号，因为一个可能只专用于出站流量，另一个可能只专用于入站流量。这取决于主机配置。
- en: Essentially, the client's local port does not necessarily coincide with the
    server's remote port. The server receives the request and, if accepted, a new
    connection is created. Now, the client and server communicate through a virtual
    channel, between the socket and the server, which is created specifically for
    the data flow of the data socket connection.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，客户端的本地端口不一定与服务器的远程端口相符。服务器接收请求，如果接受，将创建一个新连接。现在，客户端和服务器通过专门为数据套接字连接的数据流创建的虚拟通道进行通信。
- en: Consistent with what was mentioned in the first phase, the server creates the
    data socket because the first one is used exclusively for managing requests. Therefore, it
    is possible that there are many clients communicating with the server using the
    data socket created by the server for them. The TCP protocol is connection-oriented,
    which means that when there is no longer a need to communicate, the client communicates
    this to the server and the connection is closed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一阶段提到的一致，服务器创建数据套接字，因为第一个套接字专门用于处理请求。因此，可能有许多客户端使用服务器为它们创建的数据套接字与服务器进行通信。TCP协议是面向连接的，这意味着当不再需要通信时，客户端会将此通知服务器，并关闭连接。
- en: 'To run the example, execute the server:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行示例，请执行服务器：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, execute the client (in a different Windows terminal):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在不同的Windows终端中执行客户端：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The result on the client side should report the address (`addr`) and report
    `port` as connected:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端端的结果应报告地址（`addr`）并报告`port`已连接：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, on the server side, the result should be as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在服务器端，结果应该如下：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There's more...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: With a small change to the previous code, we can create a simple client-server
    application for file transfer. The server instantiates the socket and waits for
    the connection instance from the client. Once connected to the server, the client
    starts the data transfer.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对先前的代码进行小改动，我们可以创建一个简单的客户端-服务器应用程序进行文件传输。服务器实例化套接字并等待来自客户端的连接实例。一旦连接到服务器，客户端开始数据传输。
- en: The data to be transferred, which is in the `mytext.txt` file, is copied byte
    by byte and sent to the server through the call to the `conn.send` function. The
    server then receives the data and writes it to a second file, `received.txt`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要传输的数据在`mytext.txt`文件中，按字节复制并通过调用`conn.send`函数发送到服务器。服务器然后接收数据并将其写入第二个文件`received.txt`。
- en: 'The source code for `client2.py` is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`client2.py`的源代码如下：'
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is the source code for `client.py`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`client.py`的源代码：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Types of sockets
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字类型
- en: 'We can distinguish between the following three types of sockets, which are
    characterized by connection modes:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分以下三种套接字类型，其特点是连接模式：
- en: '**Stream sockets**: These are connection-oriented sockets, and they are based
    on reliable protocols such as TCP or SCTP.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流套接字**：这些是面向连接的套接字，它们基于可靠的协议，如TCP或SCTP。'
- en: '**Datagram** **sockets**: These are not connection-oriented (connectionless)
    sockets, and are based on the fast but unreliable UDP protocol.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据报套接字**：这些套接字不是面向连接的（无连接）套接字，而是基于快速但不可靠的UDP协议。'
- en: '**Raw socket** (raw IP): The transport level is bypassed, and the header is
    accessible at the application level.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始套接字**（原始IP）：传输层被绕过，头部在应用层可访问。'
- en: Stream sockets
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流套接字
- en: We will see more in particular of this type of socket only. Being based on transport
    layer protocols such as TCP, they guarantee a reliable, full-duplex, and connection-oriented
    communication, with a variable-length byte stream.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只看到这种类型的套接字。由于它们基于TCP等传输层协议，它们保证可靠、全双工和面向连接的通信，具有可变长度的字节流。
- en: 'Communication through this socket consists of these phases:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个套接字进行通信包括以下阶段：
- en: '**Creation of sockets**: Clients and servers create their respective sockets,
    and the server listens to them on a port. Since the server can create multiple
    connections with different clients (but also with the same one), it needs a queue
    to handle the various requests.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**套接字的创建**：客户端和服务器创建各自的套接字，并且服务器在端口上监听它们。由于服务器可以与不同客户端（但也可能是同一个客户端）创建多个连接，因此它需要一个队列来处理各种请求。'
- en: '**Connection request**: The client requests a connection to the server. Note
    that we can have different port numbers because one could only be assigned to
    the outgoing traffic, and the other only to entry. This depends on the host configuration.
    Essentially, the client''s local port does not necessarily coincide with the server''s
    remote port. The server receives the request and, if accepted, a new connection
    is created. In the diagram, the port of the client socket is `8080`, while for
    the socket server, the port is `80`.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**连接请求**：客户端请求与服务器建立连接。请注意，我们可以有不同的端口号，因为一个可能只分配给出站流量，另一个只分配给入站流量。这取决于主机配置。基本上，客户端的本地端口不一定与服务器的远程端口相符。服务器接收请求，如果接受，将创建一个新连接。在图中，客户端套接字的端口是`8080`，而服务器套接字的端口是`80`。'
- en: '**Communication**: Now, the client and server communicate through a virtual
    channel, between the client''s socket, and a new socket (server side)*,* created
    specifically for the data flow of this connection: a data socket. As it was mentioned
    in the first phase, the server creates the data socket because the first data
    socket is used exclusively for managing requests. Therefore, it is possible that
    there are many clients communicating with the server, each with the data socket
    specifically created by the server for them.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通信**：现在，客户端和服务器通过一个虚拟通道进行通信，介于客户端套接字和一个新的套接字（服务器端）之间，专门为此连接的数据流创建：一个数据套接字。正如在第一阶段中提到的，服务器创建数据套接字，因为第一个数据套接字专门用于处理请求。因此，可能有许多客户端与服务器通信，每个客户端都有服务器专门为其创建的数据套接字。'
- en: '**Closure of the connection**: Since the TCP is a connection-oriented protocol
    when there is no longer a need to communicate, the client communicates it to the
    server, which deallocates the data socket.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**连接的关闭**：由于TCP是一种面向连接的协议，当不再需要通信时，客户端会通知服务器，服务器会释放数据套接字。'
- en: 'The phases of communication through stream sockets are shown in the following
    diagram:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过流套接字进行通信的阶段如下图所示：
- en: '![](assets/4a04807a-ed49-44eb-9f21-2346ea59f835.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4a04807a-ed49-44eb-9f21-2346ea59f835.png)'
- en: Stream socket phases
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 流套接字阶段
- en: See also
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: More information on Python sockets can be found at [https://docs.python.org/3/howto/sockets.html](https://docs.python.org/3/howto/sockets.html).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Python套接字的更多信息，请访问[https://docs.python.org/3/howto/sockets.html](https://docs.python.org/3/howto/sockets.html)。
- en: Distributed task management with Celery
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Celery进行分布式任务管理
- en: '*Celery* is a Python framework that manages distributed tasks by following
    theobject-oriented middleware approach. Its main feature is handling many small
    tasks and distributing them on many computational nodes. Finally, the result of
    each task will then be reworked in order to compose the overall solution.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*Celery*是一个Python框架，通过遵循面向对象的中间件方法来管理分布式任务。其主要特点是处理许多小任务并将它们分发到许多计算节点上。最终，每个任务的结果将被重新处理，以组成整体解决方案。'
- en: To use Celery, a message broker is required. This is an independent (from Celery)
    software component that has the function of middleware, which is used to send
    and receive messages to distributed task workers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Celery，需要一个消息代理。这是一个独立的（与Celery无关）软件组件，具有中间件的功能，用于向分布式任务工作者发送和接收消息。
- en: 'In fact, a message broker—also known as message middleware—deals with the exchange
    of messages in a communication network.: the addressing scheme of this type of
    middleware is no longer of the point-to-point type, but is message-oriented addressing.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，消息代理（也称为消息中间件）处理通信网络中消息的交换：这种中间件的寻址方案不再是点对点类型，而是面向消息的寻址。
- en: 'The reference architecture, with which the message broker manages the exchange
    of messages, is based on the so-called publish/subscribe paradigm, which is depicted
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理的参考架构，用于管理消息的交换，基于所谓的发布/订阅范式，如下所示：
- en: '![](assets/081ba83c-57b4-44c6-aaa5-89f6d9e0989c.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/081ba83c-57b4-44c6-aaa5-89f6d9e0989c.png)'
- en: Message broker architecture
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理架构
- en: Celery supports many types of brokers. However, the more complete ones are RabbitMQ
    and Redis.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Celery支持许多类型的代理。但是，更完整的是RabbitMQ和Redis。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To install Celery, use the `pip` installer as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Celery，请使用`pip`安装程序，如下所示：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, a message broker must be installed. There are several choices available,
    but for our example, it is recommended to install RabbitMQ from the following
    link: [http://www.rabbitmq.com/download.html](http://www.rabbitmq.com/download.html).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，必须安装消息代理。有几种选择可用，但是对于我们的示例，建议从以下链接安装 RabbitMQ：[http://www.rabbitmq.com/download.html](http://www.rabbitmq.com/download.html)。
- en: 'RabbitMQ is a message-oriented middleware that implements the **Advanced Message
    Queuing Protocol** (**AMQP**). The RabbitMQ server is written in the Erlang programming
    language, so in order to install it, you need to install Erlang after downloading
    it from [http://www.erlang.org/download.html](http://www.erlang.org/download.html).The
    steps involved are as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 是一个实现 **高级消息队列协议** (**AMQP**) 的消息导向中间件。RabbitMQ 服务器是用 Erlang 编程语言编写的，因此在安装它之前，您需要从
    [http://www.erlang.org/download.html](http://www.erlang.org/download.html) 下载并安装
    Erlang。涉及的步骤如下：
- en: 'To check the `celery` installation, first start the message broker (for example, RabbitMQ).
    Then, type the following:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查 `celery` 的安装，首先启动消息代理（例如 RabbitMQ）。然后，输入以下内容：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following output, which indicates the `celery` version, is as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下输出表示 `celery` 版本：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, let's learn about how to create and call a task using the `celery` module.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解如何使用 `celery` 模块创建和调用任务。
- en: '`celery` provides the following two methods to perform a call to a task:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`celery` 提供以下两种方法来调用任务：'
- en: '`apply_async(args[, kwargs[, ...]])`: This sends a task message.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply_async(args[, kwargs[, ...]])`：这发送一个任务消息。'
- en: '`delay(*args, **kwargs)`: This is a shortcut to send a task message, but it
    does not support execution options.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay(*args, **kwargs)`：这是发送任务消息的快捷方式，但不支持执行选项。'
- en: 'The `delay` method is easier to use because it is called as a** regular function**: `task.delay(arg1,
    arg2, kwarg1=''x'', kwarg2=''y'')`. However, for `apply_async`, the syntax is `task.apply_async
    (args=[arg1,arg2] kwargs={''kwarg1'':''x'',''kwarg2'': ''y''})`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`delay` 方法更容易使用，因为它被调用为**常规函数**：`task.delay(arg1, arg2, kwarg1=''x'', kwarg2=''y'')`。然而，对于
    `apply_async`，语法是 `task.apply_async (args=[arg1,arg2] kwargs={''kwarg1'':''x'',''kwarg2'':
    ''y''})`。'
- en: Windows setup
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows 设置
- en: 'In order to use Celery in a Windows environment, you must perform the following
    procedure:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Windows 环境中使用 Celery，必须执行以下过程：
- en: Go to System Properties | Environment Variables | User or System variables |
    New.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到系统属性 | 环境变量 | 用户或系统变量 | 新建。
- en: 'Set the following values:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置以下值：
- en: 'Variable name: `FORKED_BY_MULTIPROCESSING`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名：`FORKED_BY_MULTIPROCESSING`
- en: 'Variable value: `1`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量值：`1`
- en: The reason for this setup is because of Celery's dependence on the `billiard`
    package ([https://github.com/celery/billiard](https://github.com/celery/billiard)),
    which uses the `FORKED_BY_MULTIPROCESSING` variable.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 进行此设置的原因是因为 Celery 依赖于 `billiard` 包 ([https://github.com/celery/billiard](https://github.com/celery/billiard))，它使用
    `FORKED_BY_MULTIPROCESSING` 变量。
- en: For more information on Celery's Windows setup, read [https://www.distributedpython.com/2018/08/21/celery-4-windows/](https://www.distributedpython.com/2018/08/21/celery-4-windows/).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Celery 在 Windows 上的设置的更多信息，请阅读 [https://www.distributedpython.com/2018/08/21/celery-4-windows/](https://www.distributedpython.com/2018/08/21/celery-4-windows/)。
- en: How to do it...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The task here is a sum of two numbers. To perform this easy task, we have to
    compose the `addTask.py` and `addTask_main.py` script files:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的任务是两个数字的和。为了执行这个简单的任务，我们必须组成 `addTask.py` 和 `addTask_main.py` 脚本文件：
- en: 'For `addTask.py`, start to import the Celery framework as follows:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `addTask.py`，开始导入 Celery 框架如下：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, define the task. In our example, the task is a sum of two numbers:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义任务。在我们的示例中，任务是两个数字的和：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, import the `addTask.py`file that was defined previously into `addtask_main.py`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，导入之前定义的 `addTask.py` 文件到 `addtask_main.py` 中：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, call `addTask.py` to execute the sum of two numbers:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调用 `addTask.py` 执行两个数字的和：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In order to use Celery, the first thing to do is to run the RabbitMQ service,
    and then execute the Celery worker server (that is, the `addTask.py` file script)
    by typing the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Celery，首先要做的是运行 RabbitMQ 服务，然后执行 Celery 工作者服务器（即 `addTask.py` 文件脚本），方法是输入以下内容：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, the second script is launched using Python:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 Python 启动第二个脚本：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, the result should be as follows in the first Command Prompt:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第一个命令提示符中，结果应该如下所示：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see, the result is `10`. Let''s focus on the first script, `addTask.py`:
    in the first two lines of code, we create a `Celery` application instance that
    uses the RabbitMQ service broker:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，结果是 `10`。让我们专注于第一个脚本 `addTask.py`：在代码的前两行中，我们创建了一个使用 RabbitMQ 服务代理的
    `Celery` 应用实例：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first argument in the `Celery` function is the name of the current module
    (`addTask.py`), and the second is the broker keyboard argument; this indicates
    the URL that is used to connect the broker (RabbitMQ).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Celery` 函数的第一个参数是当前模块的名称（`addTask.py`），第二个是代理键盘参数；这表示用于连接代理（RabbitMQ）的 URL。'
- en: Now, let's introduce the task to be accomplished.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们介绍要完成的任务。
- en: Each task must be added with the `@app.task` annotation (namely, decorator); the
    decorator helps `Celery` to identify which functions can be scheduled in the task
    queue.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务必须使用 `@app.task` 注释（即装饰器）添加；装饰器帮助 `Celery` 确定哪些函数可以在任务队列中调度。
- en: 'After the decorator, we create the task that the workers can execute: this
    will be a simple function that performs the sum of two numbers:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在装饰器之后，我们创建工作者可以执行的任务：这将是一个执行两个数字之和的简单函数：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the second script, `addTask_main.py`, we call our task by using the `delay()`
    method:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个脚本 `addTask_main.py` 中，我们使用 `delay()` 方法调用我们的任务：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Let's remember that this method is a shortcut to the `apply_async()` method,
    which gives us greater control over the task execution.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记住，这种方法是 `apply_async()` 方法的快捷方式，它可以更好地控制任务的执行。
- en: There's more...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Celery usage is very simple. It can be executed by using the following commands:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Celery 的使用非常简单。可以通过以下命令执行：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here, the options are as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，选项如下：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The main commands are as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 主要命令如下：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Celery protocol can be implemented in any language by using Webhooks ([https://developer.github.com/webhooks/](https://developer.github.com/webhooks/)).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Celery协议可以通过使用Webhooks（[https://developer.github.com/webhooks/](https://developer.github.com/webhooks/)）在任何语言中实现。
- en: See also
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: More information on Celery can be found at [http://www.celeryproject.org/](http://www.celeryproject.org/).
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Celery的更多信息，请访问[http://www.celeryproject.org/](http://www.celeryproject.org/)。
- en: The recommended message brokers ([https://en.wikipedia.org/wiki/Message_broker](https://en.wikipedia.org/wiki/Message_broker)) are RabbitMQ
    ([https://en.wikipedia.org/wiki/RabbitMQ](https://en.wikipedia.org/wiki/RabbitMQ)) or Redis
    ([https://en.wikipedia.org/wiki/Redis](https://en.wikipedia.org/wiki/Redis)).
    Additionally, there is MongoDB ([https://en.wikipedia.org/wiki/MongoDB](https://en.wikipedia.org/wiki/MongoDB)),
    Beanstalk, Amazon SQS ([https://en.wikipedia.org/wiki/Amazon_Simple_Queue_Service](https://en.wikipedia.org/wiki/Amazon_Simple_Queue_Service)), CouchDB
    ([https://en.wikipedia.org/wiki/Apache_CouchDB](https://en.wikipedia.org/wiki/Apache_CouchDB)),
    and IronMQ ([https://www.iron.io/mq](https://www.iron.io/mq)).
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐的消息代理（[https://en.wikipedia.org/wiki/Message_broker](https://en.wikipedia.org/wiki/Message_broker)）是RabbitMQ（[https://en.wikipedia.org/wiki/RabbitMQ](https://en.wikipedia.org/wiki/RabbitMQ)）或Redis（[https://en.wikipedia.org/wiki/Redis](https://en.wikipedia.org/wiki/Redis)）。此外，还有MongoDB（[https://en.wikipedia.org/wiki/MongoDB](https://en.wikipedia.org/wiki/MongoDB)）、Beanstalk、Amazon
    SQS（[https://en.wikipedia.org/wiki/Amazon_Simple_Queue_Service](https://en.wikipedia.org/wiki/Amazon_Simple_Queue_Service)）、CouchDB（[https://en.wikipedia.org/wiki/Apache_CouchDB](https://en.wikipedia.org/wiki/Apache_CouchDB)）和IronMQ（[https://www.iron.io/mq](https://www.iron.io/mq)）。
- en: RMI with Pyro4
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pyro4的RMI
- en: '**Pyro **is short for **Python Remote Objects**. It works exactly like the
    Java **RMI **(short for **Remote Method Invocation**) allowing to invoke a method
    of a remote object (belonging to a different process) exactly as if the object
    were local (belonging to the same process in which the invocation runs).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pyro**是**Python Remote Objects**的缩写。它的工作原理与Java的**RMI**（远程方法调用）完全相同，允许调用远程对象的方法（属于不同进程），就像对象是本地的一样（属于调用运行的同一进程）。'
- en: The use of an RMI mechanism, in an object-oriented system, involves significant
    advantages of uniformity and symmetry in the project, as this mechanism enables
    the modelling of interactions between distributed processes using the same conceptual
    tool.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的系统中使用RMI机制，可以在项目中获得统一性和对称性的重要优势，因为这种机制使得可以使用相同的概念工具对分布式进程之间的交互进行建模。
- en: 'As you can see from the following diagram, `Pyro4` enables objects to be distributed in
    a client/server style; this means that the main parts of a `Pyro4` system may
    switch from a client caller to a remote object, which is called to serve a function:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 从下图中可以看出，`Pyro4`使对象以客户端/服务器的方式分布；这意味着`Pyro4`系统的主要部分可以从客户端调用者切换到远程对象，后者被调用来执行一个函数：
- en: '![](assets/1782750b-b3f5-4ac1-8274-f01d46cff0ec.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1782750b-b3f5-4ac1-8274-f01d46cff0ec.png)'
- en: RMI
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: RMI
- en: 'It is important to note that during the remote calling, there are always two
    distinct parts: a client and a server that accept and execute the client call.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在远程调用过程中，始终存在两个不同的部分：一个客户端和一个接受并执行客户端调用的服务器。
- en: Getting ready
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The entire method of managing this mechanism in a distributed way is provided
    by `Pyro4`. To install the latest release of `Pyro4`, use the `pip` installer
    (Windows installation is used here) and add the following command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 管理这种分布式方式的整个方法由`Pyro4`提供。要安装最新版本的`Pyro4`，请使用`pip`安装程序（这里使用Windows安装），并添加以下命令：
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We are using the `pyro_server.py` and `pyro_client.py` codes for this recipe.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`pyro_server.py`和`pyro_client.py`代码来完成这个示例。
- en: How to do it...
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this example, we''ll see how to build and use a simple client-server communicationusing
    the `Pyro4` middleware. The code for the client is `pyro_server.py`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将看到如何使用`Pyro4`中间件构建和使用简单的客户端-服务器通信。客户端的代码是`pyro_server.py`：
- en: 'Import the `Pyro4` library:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`Pyro4`库：
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Define the `Server` class that contains the`welcomeMessage()` method that will
    be exposed:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义包含`welcomeMessage()`方法的`Server`类：
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that the decorator, `@Pyro4.expose`, means that the preceding method will
    be remotely accessible.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，装饰器`@Pyro4.expose`表示前面的方法将是远程可访问的。
- en: 'The `startServer` function contains all the instructions that are used to start
    the server:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`startServer`函数包含了启动服务器所使用的所有指令：'
- en: '[PRE44]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, build the `server` instance of the `Server` class:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，构建`Server`类的`server`实例：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, define the `Pyro4` daemon:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义`Pyro4`守护程序：
- en: '[PRE46]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To execute this script, we must run a `Pyro4` statement to locate a nameserver:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行此脚本，我们必须运行一个`Pyro4`语句来定位名字服务器：
- en: '[PRE47]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Register the object server as *Pyro object*; it will only be known inside the
    Pyro daemon:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对象服务器注册为*Pyro对象*；它只会在Pyro守护程序内部知道：
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we can register the object server with a name in the nameserver:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在名字服务器中注册对象服务器的名称：
- en: '[PRE49]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The function ends with a call to the daemon''s `requestLoop` method. This starts
    the event loop of the server and waits for calls:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数以调用守护进程的`requestLoop`方法结束。这启动了服务器的事件循环，并等待调用：
- en: '[PRE50]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, call `startServer` via the `main` program:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过`main`程序调用`startServer`：
- en: '[PRE51]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here is the code for the client (`pyro_client.py`):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是客户端的代码（`pyro_client.py`）：
- en: 'Import the `Pyro4` library:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`Pyro4`库：
- en: '[PRE52]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `Pyro4` API enables the developer to distribute objects in a transparent
    way. In this example, the client script sends requests to the server program in
    order to execute the `welcomeMessage()` method:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Pyro4` API使开发人员能够以透明的方式分发对象。在这个例子中，客户端脚本发送请求到服务器程序，以执行`welcomeMessage()`方法：'
- en: '[PRE53]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, the remote call is created:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建远程调用：
- en: '[PRE54]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, the client calls the server, printing a message:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，客户端调用服务器，打印一条消息：
- en: '[PRE55]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works...
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The preceding example is composed of two main functions: `pyro_server.py`and
    `pyro_client.py`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例由两个主要函数组成：`pyro_server.py`和`pyro_client.py`。
- en: 'In `pyro_server.py`, the `Server` class object provides the `welcomeMessage()` method,
    returning a string equal to the name inserted in the client session:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pyro_server.py`中，`Server`类对象提供`welcomeMessage()`方法，返回与客户端会话中插入的名称相等的字符串：
- en: '[PRE56]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`Pyro4` uses daemon objects to dispatch incoming calls to appropriate objects.
    A server must create just one daemon that manages everything from its instance.
    Each server has a daemon that knows about all the Pyro objects that the server
    provides:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pyro4`使用守护对象将传入调用分派给适当的对象。服务器必须创建一个管理其所有实例的守护进程。每个服务器都有一个守护进程，它知道服务器提供的所有Pyro对象：'
- en: '[PRE57]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As for the `pyro_client.py` function, the remote call is first performed and
    creates a `Proxy` object. In particular, the `Pyro4` client uses proxy objects
    to forward method calls to the remote objects, and then passes the results back
    to the calling code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 至于`pyro_client.py`函数，首先执行远程调用并创建一个`Proxy`对象。特别是，`Pyro4`客户端使用代理对象将方法调用转发到远程对象，然后将结果传递回调用代码：
- en: '[PRE58]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In order to execute a client-server connection, we need to have a `Pyro4` nameserver
    running. In Command Prompt, type the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行客户端-服务器连接，我们需要运行一个`Pyro4`名称服务器。在命令提示符中，输入以下内容：
- en: '[PRE59]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After this, you''ll see the following message:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您将看到以下消息：
- en: '[PRE60]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The preceding message means that the nameserver is running in your network.
    Finally, we can start the server and the client scripts in two separate Windows
    consoles:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的消息意味着名称服务器正在您的网络中运行。最后，我们可以在两个单独的Windows控制台中启动服务器和客户端脚本：
- en: 'To run `pyro_server.py`, just type the following:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行`pyro_server.py`，只需输入以下内容：
- en: '[PRE61]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Following that, you''ll see something like this:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，您将看到类似于这样的内容：
- en: '[PRE62]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, run the client by typing the following:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，输入以下内容运行客户端：
- en: '[PRE63]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The following message will be printed out:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将打印出以下消息：
- en: '[PRE64]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Insert a name (for example, `Ruvika`):'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入一个名称（例如，`Ruvika`）：
- en: '[PRE65]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The following welcome message will be displayed:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将显示以下欢迎消息：
- en: '[PRE66]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: There's more...
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Among the features of `Pyro4`, there is the creation of object topologies.
    For example, let''s suppose we want to build a distributed architecture that follows
    a chain topology, as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pyro4`的功能之一是创建对象拓扑。例如，假设我们想要构建一个遵循链式拓扑结构的分布式架构，如下所示：'
- en: '![](assets/7f93a4ab-70f7-4ecb-8a0b-f5633c11bad1.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7f93a4ab-70f7-4ecb-8a0b-f5633c11bad1.png)'
- en: Chaining objects with Pyro4
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Pyro4链接对象
- en: The Client makes a request to **Server 1**, and then the request is forwarded to
    **Server *2***, which then calls **Server** **3**. The chain call ends when **Server
    3 **calls **Server 1**.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端向**服务器1**发出请求，然后将请求转发到**服务器2**，然后调用**服务器3**。当**服务器3**调用**服务器1**时，链式调用结束。
- en: Implementing chain topology
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现链式拓扑
- en: To implement a chain topology using `Pyro4`**,** we need to implement a `chain`
    object and the `client` and `server` objects. The `Chain`class allows the call
    to be redirected to the next server by processing the input message and reconstructing
    the server address to which the request should be addressed.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Pyro4`实现链式拓扑，我们需要实现一个`chain`对象和`client`和`server`对象。`Chain`类允许通过处理输入消息并重建请求应该发送到的服务器地址来将调用重定向到下一个服务器。
- en: 'Also note, in this case, the `@Pyro4.expose` decorator, which allows all the
    methods of the class (`chainTopology.py`) to be exposed:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在这种情况下，`@Pyro4.expose`装饰器允许公开类（`chainTopology.py`）的所有方法：
- en: '[PRE67]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If the chain is closed (the last call is done from `server_chain_3.py`to `server_chain_1.py`),
    then a closing message is printed out:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果链路关闭（最后一次调用是从`server_chain_3.py`到`server_chain_1.py`），则会打印出关闭消息：
- en: '[PRE68]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'A forwarding message is printed out if there is a next element in the chain:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果链中有下一个元素，则会打印出转发消息：
- en: '[PRE69]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Next, we have the source code for the client (`client_chain.py`):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是客户端的源代码（`client_chain.py`）：
- en: '[PRE70]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Following this is the source code for the first server (namely, `server_1`)
    in the chain that is called from the client (`server_chain_1.py`). Here, the relevant
    libraries are imported. Note, the import to the `chainTopology.py` file that was described
    previously:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是链中第一个服务器的源代码（即`server_1`），它是从客户端（`server_chain_1.py`）调用的。在这里，导入了相关的库。请注意，之前描述的`chainTopology.py`文件的导入：
- en: '[PRE71]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Note also that the source code for the servers only differs as regards the
    definitions of the current and the next servers of the chain:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，服务器的源代码只有当前链和下一个链服务器的定义不同：
- en: '[PRE72]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The remaining lines of code define the communication with the next element
    in the chain:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 其余代码行定义了与链中下一个元素的通信：
- en: '[PRE73]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'To execute this example, first run the `Pyro4` nameserver:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此示例，首先运行`Pyro4`名称服务器：
- en: '[PRE74]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Run the three servers in three different terminals, typing each of them respectively 
    (Windows terminals are used here):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在三个不同的终端中运行三个服务器，分别输入它们（这里使用Windows终端）：
- en: 'The first server (`server_chain_1.py`) in the first terminal:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个服务器（`server_chain_1.py`）在第一个终端中：
- en: '[PRE75]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Followed by the second server (`server_chain_2.py`) in the second terminal:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是第二个服务器（`server_chain_2.py`）在第二个终端中：
- en: '[PRE76]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'And finally, the third server  (`server_chain_3.py`) in the third terminal:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第三个服务器（`server_chain_3.py`）在第三个终端中：
- en: '[PRE77]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Then, run the `client_chain.py` script from another terminal:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从另一个终端运行`client_chain.py`脚本：
- en: '[PRE78]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This is the output, as shown in the Command Prompt:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在命令提示符中显示的输出：
- en: '[PRE79]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The preceding message is displayed as a result of the forwarding request passed
    across the three servers after it returned the fact that the task is completed
    to`server_chain_1`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回任务完成的三个服务器之间传递转发请求后，将显示前面的消息。
- en: 'Also, we can focus on the behavior of the object servers while the request
    is forwarded to the next object in the chain (refer to the message underneath
    the start message):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以关注对象服务器在请求转发到链中的下一个对象时的行为（参见开始消息下方的消息）：
- en: '**`server_ 1`** is started and the following message is forwarded to`server_ 2`:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`server_1`**已启动，并将以下消息转发到**`server_2`**：'
- en: '[PRE80]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '`server_2` forwards the following message to `server_3`:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`server_2`将以下消息转发到`server_3`：'
- en: '[PRE81]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '`server_ 3`forwards the following message to `server_1`:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`server_3`将以下消息转发给`server_1`：'
- en: '[PRE82]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Finally, the message returns to the starting point (in other words, `server_1`),
    closing the chain :'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，消息返回到起始点（也就是`server_1`），链路关闭：
- en: '[PRE83]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: See also
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The `Pyro4` documentation is available at[https://buildmedia.readthedocs.org/media/pdf/pyro4/stable/pyro4.pdf](https://buildmedia.readthedocs.org/media/pdf/pyro4/stable/pyro4.pdf).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pyro4`文档可在[https://buildmedia.readthedocs.org/media/pdf/pyro4/stable/pyro4.pdf](https://buildmedia.readthedocs.org/media/pdf/pyro4/stable/pyro4.pdf)上找到。'
- en: This contains a description and some application examples of the 4.75 release.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 其中包含了4.75版本的描述和一些应用示例。

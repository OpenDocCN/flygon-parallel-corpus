- en: Python Debugging and Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试阶段
- en: This last chapter will introduce two important software engineering topics—debugging
    and testing—that are important steps in the software development process.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一章将介绍两个重要的软件工程主题——调试和测试，这是软件开发过程中的重要步骤。
- en: The first part of the chapter is focused on code debugging. A bug is a mistake
    in a program and can cause different problems that may be more or less serious
    depending on the situation. To encourage programmers to search for bugs, special
    software tools are used, called **debuggers***;* using these software tools, we
    have the ability to find errors or malfunctions within a program by taking advantage
    of specific debugging functions, an activity that exists precisely for identifying
    the portion of software affected by a bug.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分专注于代码调试。错误是程序中的错误，可能会导致不同严重程度的问题，具体取决于情况。为了鼓励程序员寻找错误，使用称为**调试器**的特殊软件工具；使用这些软件工具，我们有能力通过利用特定的调试功能来找到程序中的错误或故障，这是一个专门用于识别受错误影响的软件部分的活动。
- en: In the second part, the main topic is *software testing: *it is a process used
    to identify deficiencies of *correctness*, *completeness*, and *reliability* in
    a software product that is being developed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，主要主题是*软件测试*：这是用于识别正在开发的软件产品中的*正确性*、*完整性*和*可靠性*缺陷的过程。
- en: In this context, we will, therefore, examine the three most important Python
    tools for debugging code in action. These are `winpdb-reborn`, which involves
    debugging with a visualization tool; `pdb`, the debugger from the Python standard
    library; and `rpdb`, where `r` stands for remote, meaning that it is code debugging
    from a remote machine*.*
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将研究三个最重要的Python调试代码工具。这些是`winpdb-reborn`，涉及使用可视化工具进行调试；`pdb`，Python标准库中的调试器；和`rpdb`，其中`r`代表远程，意味着它是从远程机器进行代码调试。
- en: 'Regarding software testing, we will examine the following tools: `unittest`
    and `nose`.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`nose`进行应用程序测试
- en: These are frameworks for developing unit tests, whereby the unit is the minimum
    component of a program within an independent operation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，这一活动得到了特定应用程序和调试器的支持，这些调试器通过逐步软件指令向程序员展示执行过程，允许同时查看和分析程序本身的输入和输出。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is debugging?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是调试？
- en: What is software testing?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是软件测试？
- en: Debugging using Winpdb Reborn
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Winpdb Reborn进行调试
- en: Interacting with `pdb`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`rpdb`进行调试
- en: Implementing `rpdb` for debugging
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是调试？
- en: Dealing with `unittest`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理`unittest`
- en: Application testing using `nose`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些是用于开发单元测试的框架，其中单元是程序中独立操作的最小组件。
- en: What is debugging?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 术语*调试*表示在软件使用后，识别代码部分中发现一个或多个错误（bug）的活动。
- en: The term *debugging* indicates the activity of identifying the portion of code
    in which one or more errors (bugs) are detected in software following its use.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 关于软件测试，我们将研究以下工具：`unittest`和`nose`。
- en: The error can be localized during the testing phase of the program; that is
    when it is still in the development phase and is not yet ready to be used by the
    end-user, or during the use of the program by the latter. After finding the error,
    the debugging phase ensues and identifies the software part in which the error
    lies, which is sometimes very complex.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是软件测试？
- en: Nowadays, this activity is supported by specific applications and debuggers,
    which show the execution to the programmer using step-by-step software instructions,
    allowing the viewing and analysis of the inputs and outputs of the program itself at
    the same time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 错误可以在程序的测试阶段定位；即在开发阶段尚未准备好供最终用户使用时，或者在最终用户使用程序时。找到错误后，将进行调试阶段，并确定错误所在的软件部分，有时非常复杂。
- en: Before these tools were available for the activity of identifying and correcting
    errors (and even now, in the absence of them), the simplest (but also least effective)
    techniques for code inspection were printing a file or printing the instructions
    on the screen that the program was executing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些工具可用于识别和纠正错误的活动之前（甚至现在，在没有它们的情况下），代码检查的最简单（但也是最不有效的）技术是打印文件或打印程序正在执行的指令。
- en: Debugging is one of the most important operations for the development of a program.
    It is often extremely difficult due to the complexity of the software that is
    being developed. It is even delicate due to the risk of introducing new errors
    or behaviors that are not in line with those desired in the attempt to correct
    those for which the activity was undertaken.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是程序开发中最重要的操作之一。由于正在开发的软件的复杂性，通常非常困难。由于存在引入新错误或行为的风险，这甚至是微妙的，这些错误或行为与尝试纠正的错误不符。
- en: 'Although the task of perfecting software using debugging is unique every time
    and constitutes a story in itself, some general principles are always applicable.
    In particular, in the context of software applications, it is possible to recognize
    the following four *debugging phases*, summarized in the following diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用调试来完善软件的任务每次都是独一无二的，构成了一个独立的故事，但一些通用原则始终适用。特别是在软件应用程序的上下文中，可以识别以下四个*调试阶段*，总结如下图所示：
- en: '![](assets/16de8223-a2d3-4378-8677-70527c657df8.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: 与`pdb`交互
- en: Debugging phasesOf course, Python offers the developer numerous debugging tools
    (see [https://wiki.python.org/moin/PythonDebuggingTools](https://wiki.python.org/moin/PythonDebuggingTools)
    for a list of Python debuggers). In this chapter, we will consider Winpdb Reborn, `rpdb`, and
    `pdb`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Python为开发人员提供了许多调试工具（请参阅[https://wiki.python.org/moin/PythonDebuggingTools](https://wiki.python.org/moin/PythonDebuggingTools)以获取Python调试器列表）。在本章中，我们将考虑Winpdb
    Reborn、`rpdb`和`pdb`。
- en: What is software testing?
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python调试和测试
- en: As mentioned in the introduction of this chapter, software testing is a process
    used to identify deficiencies of correctness, completeness, and reliability in
    a software product that is being developed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章介绍中所述，软件测试是用于识别正在开发的软件产品中的正确性、完整性和可靠性缺陷的过程。
- en: With this activity, we, therefore, want to ensure the quality of the product
    by searching search for defects, or a sequence of instructions and procedures
    that, when executed with particular input data and in particular operating environments,
    generate malfunctions. A malfunction is a behavior of the software that is not
    expected by the user; therefore, it is different from the specifications and from
    the implicit or explicit requirements defined for such applications.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过这项活动，我们希望通过搜索缺陷或一系列指令和程序来确保产品的质量，当以特定输入数据和特定操作环境执行时，会产生故障。故障是用户不期望的软件行为；因此，它与规范以及为此类应用程序定义的隐式或显式要求不同。
- en: The purpose of testing is, therefore, to detect defects through malfunctions,
    so as to minimize the probability of such malfunctions occurring in the normal
    use of the software product. Testing cannot establish that a product functions
    correctly under all possible conditions of execution, but it can highlight defects
    under specific conditions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试的目的是通过故障检测缺陷，以便在软件产品的正常使用中最小化此类故障发生的概率。测试无法确定产品在所有可能的执行条件下都能正确运行，但可以在特定条件下突出显示缺陷。
- en: In fact, given the impossibility of testing all the input combinations and the
    possible software and hardware environments in which the application may be operating,
    the probability of malfunctions cannot be reduced to zero, but it must be reduced
    to a minimum in order to be acceptable to the user.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，鉴于无法测试所有输入组合以及应用程序可能运行的可能软件和硬件环境，故障的概率无法降低到零，但必须降低到最低以使用户可以接受。
- en: A particular type of software testing is the unit test (which we will learn
    about in this chapter), the purpose of which is to isolate each part of a program
    and show its correctness and completeness in the implementation. It also promptly
    brings out any defects so that they can be corrected easily before integration.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试的一种特定类型是单元测试（我们将在本章中学习），其目的是隔离程序的每个部分，并展示其在实现上的正确性和完整性。它还可以及时发现任何缺陷，以便在集成之前轻松进行纠正。
- en: Furthermore, the unit test lowers the costs—in terms of time and resources—of
    identifying and correcting defects, compared to achieving the same result by performing
    tests on the entire application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与在整个应用程序上执行测试相比，单元测试降低了识别和纠正缺陷的成本（时间和资源）。
- en: Debugging using Winpdb Reborn
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Winpdb Reborn进行调试
- en: '**Winpdb Reborn** is one of the most important and well-known Python debuggers.
    The major strength of this debugger is managing the debugging of thread-based
    code.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**Winpdb Reborn**是最重要和最知名的Python调试器之一。该调试器的主要优势在于管理基于线程的代码的调试。'
- en: 'Winpdb Reborn is based on the RPDB2 debugger, while Winpdb is the GUI frontend
    to RPDB2 (see: [https://github.com/bluebird75/winpdb/blob/master/rpdb2.py](https://github.com/bluebird75/winpdb/blob/master/rpdb2.py)).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Winpdb Reborn基于RPDB2调试器，而Winpdb是RPDB2的GUI前端（参见：[https://github.com/bluebird75/winpdb/blob/master/rpdb2.py](https://github.com/bluebird75/winpdb/blob/master/rpdb2.py)）。
- en: Getting ready
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The most commonly used way to install Winpdb Reborn (*release 2.0.0 dev5*)
    is via `pip`, so from your console, you need to type the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Winpdb Reborn（*release 2.0.0 dev5*）最常用的方法是通过`pip`，因此您需要在控制台中输入以下内容：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Also, if you have not already installed wxPython in your Python distribution,
    then you need to do so. wxPython is a cross-platform GUI toolkit for the Python
    language.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果您尚未在Python发行版中安装wxPython，则需要这样做。wxPython是Python语言的跨平台GUI工具包。
- en: For Python Version 2.x, please refer to [https://sourceforge.net/projects/wxpython/files/wxPython/](https://sourceforge.net/projects/wxpython/files/wxPython/).
    For Python Version 3.x, wxPython is automatically installed as a dependency via
    `pip`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python 2.x版本，请参考[https://sourceforge.net/projects/wxpython/files/wxPython/](https://sourceforge.net/projects/wxpython/files/wxPython/)。对于Python
    3.x版本，wxPython会自动通过`pip`作为依赖项安装。
- en: In the next section, we will examine the main features and the graphical interface
    of Winpdb Reborn through a simple example of its use.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过一个Winpdb Reborn的简单示例来检查Winpdb Reborn的主要特性和图形界面的使用。
- en: How to do it...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Suppose we want to analyze the following Python application, which uses the
    threading library. An example that is very similar to the following example is
    already described in the *How to define a thread subclass* section of [Chapter
    2](c95be391-9558-4d2d-867e-96f61fbc5bbf.xhtml), *Thread-Based Parallelism*. In
    the following example, we use the `MyThreadClass` class to create and manage the
    execution of three threads. Here is the entire code to debug:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要分析以下使用线程库的Python应用程序。与下面的示例非常相似的示例已经在[第2章](c95be391-9558-4d2d-867e-96f61fbc5bbf.xhtml)的*如何定义线程子类*部分中描述过。在下面的示例中，我们使用`MyThreadClass`类来创建和管理三个线程的执行。以下是整个调试代码：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s have a look at the following steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: 'Open your console and type in the name of the folder containing the sample
    file, `winpdb_reborn_code_example.py`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并输入包含示例文件`winpdb_reborn_code_example.py`的文件夹名称：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This works on macOS as well, but you have to use a framework build of Python.
    If you are using Winpdb Reborn with Anaconda, simply use `pythonw` instead of
    `python` to launch a Winpdb Reborn session.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这在macOS上也适用，但您必须使用Python的框架构建。如果您在Anaconda中使用Winpdb Reborn，只需使用`pythonw`而不是`python`来启动Winpdb
    Reborn会话。
- en: 'If the installation was successful, then the Winpdb Reborn GUI should open:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果安装成功，Winpdb Reborn GUI应该会打开：
- en: '![](assets/2fba89a5-4840-407f-8266-63aab36b85ba.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2fba89a5-4840-407f-8266-63aab36b85ba.png)'
- en: Windpdb Reborn GUI
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Windpdb Reborn GUI
- en: 'As you can see in the following screenshot, we have inserted two breakpoints
    (using the Breakpoints menu), in both line 12 and line23 (highlighted in red):'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下截图所示，我们在第12行和第23行（红色高亮显示）分别插入了两个断点（使用断点菜单）：
- en: '***![](assets/5a2ccb87-7020-4948-8b20-80a3f393b972.png)***'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '***![](assets/5a2ccb87-7020-4948-8b20-80a3f393b972.png)***'
- en: Code breakpointsTo learn about what a breakpoint is, move on to the *There's
    more...* section of this recipe.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 代码断点要了解断点是什么，请转到本教程的*更多内容...*部分。
- en: 'Remaining in the Source window, we place the mouse on line 23, where we have
    inserted the second breakpoint, and press the *F8* key, and then the *F5* key.
    The breakpoint allows the code to be executed up to the selected line. As you
    can see, Namespace indicates that we are considering the instance of the `MyThreadClass`
    class, with `thread#1` as an argument:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持在源窗口中，将鼠标放在第23行，我们在那里插入了第二个断点，然后按下*F8*键，然后按下*F5*键。断点允许执行代码直到所选行。如您所见，命名空间指示我们正在考虑`MyThreadClass`类的实例，带有`thread#1`作为参数：
- en: '![](assets/1a27af00-4468-449f-88ee-ee0c6b9bb6a4.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1a27af00-4468-449f-88ee-ee0c6b9bb6a4.png)'
- en: Namespace
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: Another fundamental feature of the debugger is the **Step Into** capability,
    which is the ability to inspect not only the code being debugged but also the
    library functions and the subroutines called for execution.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试器的另一个基本功能是**步入**功能，它可以检查不仅正在调试的代码，还可以检查库函数和调用执行的子例程。
- en: 'Before you start to delete the previous breakpoints (Menu | Breakpoints | Clear
    All), insert the new breakpoint on line 28:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始删除之前的断点（菜单|断点|清除所有）之前，在第28行插入新的断点：
- en: '![](assets/b27f1402-d9ab-4924-bfa2-df62a894b50c.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b27f1402-d9ab-4924-bfa2-df62a894b50c.png)'
- en: Line 28 breakpoint
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第28行断点
- en: Finally, press the *F5* key and the application will be executed up to the breakpoint
    of line **28**.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，按下*F5*键，应用程序将执行到第**28**行的断点。
- en: Then, press *F7*. Here, the source window no longer shows our sample code, but
    rather, the `threading` library we are using (see the next screenshot).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按下*F7*。在这里，源窗口不再显示我们的示例代码，而是显示我们正在使用的`threading`库（请参见下一张截图）。
- en: 'Therefore, the Breakpoints functionality, together with that of Step Into, not
    only allow the debugging of the code in question but also allow the inspection
    of all the library functions and any other subroutines used:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，断点功能以及“步入”功能不仅允许调试所涉及的代码，还允许检查所有库函数和任何其他使用的子例程：
- en: '![](assets/70c4308b-78e8-4633-8a9c-7435c583eb9c.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/70c4308b-78e8-4633-8a9c-7435c583eb9c.png)'
- en: Line 28 Source window after executing Step Into
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 执行“步入”后的第28行源窗口
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this first example, we have become familiar with the Winpdb Reborn tool.
    This debugging environment (like every environment in general) allows you to stop
    program execution at precise points, inspect the execution stack, the contents
    of the variables, the status of the objects created, and much more.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个例子中，我们已经熟悉了Winpdb Reborn工具。这个调试环境（像每个一般的环境一样）允许您在精确的点停止程序执行，检查执行堆栈，变量的内容，创建的对象的状态等等。
- en: 'To use Winpdb Reborn, just take a note of the following basic steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Winpdb Reborn，只需记住以下基本步骤：
- en: Set some breakpoints in the source code (the Source window).
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源代码（源窗口）中设置一些断点。
- en: Inspect the functions through the Step Into function.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过“步入”功能检查函数。
- en: View the status of the variables (the Namespace window) and the execution stack
    (the Stack window).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看变量的状态（命名空间窗口）和执行堆栈（堆栈窗口）。
- en: The breakpoints are set by simply double-clicking the desired line with the
    left mouse button (you will see the selected line underlined in red). As a general
    warning, it is inadvisable to have multiple commands on the same line; otherwise,
    it will not be possible to associate breakpoints with some of them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地用鼠标左键双击所需的行（您会看到所选行被红色下划线标出）来设置断点。一般来说，不建议在同一行上有多个命令；否则，将无法将断点与其中一些命令关联起来。
- en: When you use the right mouse button, you can selectively *disable breakpoints*without
    removing them (the red highlighting will disappear). To remove all the breakpoints
    instead, use the Clear All command, which is present in the Breakpoints menu, as
    mentioned previously.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用鼠标右键，可以选择性地*禁用断点*而不是删除它们（红色高亮将消失）。要删除所有断点，可以使用“清除所有”命令，该命令位于断点菜单中，如前所述。
- en: 'When the first breakpoint is reached, it is good to keep an eye on the following
    views in the point of the program that is being analyzed:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当到达第一个断点时，最好关注正在分析的程序点的以下视图：
- en: The Stack view shows the contents of the execution stack, where all the instances
    of various methods that are currently suspended appear. Typically, the one at
    the bottom of the stack is the main method and the one at the top of the stack
    is the method containing the breakpoint that has been reached.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈视图显示了执行堆栈的内容，当前挂起的各种方法的所有实例都会显示出来。通常，堆栈底部的是主方法，堆栈顶部的是包含已达到断点的方法。
- en: The Namespace view shows the local variables of the method and allows you to
    inspect the values. If the variables refer to objects, then it is possible to
    find out the unique identifier of the object and inspect its status.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间视图显示了方法的局部变量，并允许您检查值。如果变量是对象的引用，则可以找出对象的唯一标识符并检查其状态。
- en: In general, the execution of a program can be managed with different modes associated
    with the icon (or the *Fx* keys) present on the Winpdb Reborn command bar.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，程序的执行可以通过与Winpdb Reborn命令栏上的图标（或*Fx*键）相关联的不同模式来管理。
- en: 'Finally, we''ll point out the following important execution methods:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将指出以下重要的执行方法：
- en: 'Step Into (*F7* key): This resumes the execution of the program one line at
    a time, and invocations of library methods or subroutines.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 步入（*F7*键）：这会一次一行地恢复程序的执行，并调用库方法或子例程。
- en: 'Return (*F12* key): This allows you to resume execution at the exact point
    where the Step Into function was activated.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回（*F12*键）：这允许您在Step Into功能被激活的确切点恢复执行。
- en: 'Next (*F6* key): This resumes the execution of the program one line at a time
    without stopping in any methods invoked.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个（*F6*键）：这会一次一行地恢复程序的执行，而不会在调用的任何方法中停止。
- en: Run to Line (*F8* key) This runs the program until it stops (waiting for new
    commands) at the indicated line.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行到行（*F8*键）：这会运行程序直到在指定行停止（等待新命令）。
- en: There's more...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As you saw in the Winpdb Reborn GUI screenshot, the GUI is divided into five
    main windows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在Winpdb Reborn GUI截图中看到的，GUI分为五个主要窗口：
- en: Namespace: In this window, the names of entities are displayed, which are various
    variables and identifiers that are defined by the program and used in the source
    file.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间：在这个窗口中，显示了程序定义并在源文件中使用的各种变量和标识符的名称。
- en: Threads: The current thread of the execution is shown, and it is characterized
    by the **TID**(short for **T**hread **ID**entification) fields, the name of the
    thread, and the thread status.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程：显示当前执行线程，并以**TID**（线程ID）字段、线程名称和线程状态为特征。
- en: Stack: This is where the execution stack of the program to be analyzed is shown.
    Stacks are also known as**Last In, First Out** (**LIFO**) data structures, as
    the last element inserted is the first to be removed. When a program calls a function,
    the called function must know how to return the calling control, so the return
    address of the calling function is entered into the program execution stack. The
    program execution stack also contains the memory for the local variables used
    at each invocation of the function.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈：这里显示了要分析的程序的执行堆栈。堆栈也被称为**后进先出**（**LIFO**）数据结构，因为最后插入的元素是第一个被移除的。当程序调用一个函数时，被调用的函数必须知道如何返回调用控制，因此调用函数的返回地址被输入到程序执行堆栈中。程序执行堆栈还包含每次调用函数时使用的本地变量的内存。
- en: Console: This is a command-line interface, thus allowing a textual interaction
    between the user and Winpdb Reborn.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制台：这是一个命令行界面，因此允许用户和Winpdb Reborn之间进行文本交互。
- en: Source:This window shows the source code to debug. By scrolling along the lines
    of code, it is also possible to insert the breakpoints by pressing *F9 *once you
    are on the line of code of interest.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码：这个窗口显示要调试的源代码。通过沿着代码行滚动，也可以在感兴趣的代码行上按下*F9*来插入断点。
- en: The breakpoint is a very basic debugging tool. In fact, it allows you to run
    a program, but with the possibility of interrupting it at the desired point or
    when certain conditions occur, in order to acquire information on a running program***.***
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 断点是一个非常基本的调试工具。实际上，它允许您运行程序，但可以在所需的点或在发生某些条件时中断它，以获取有关正在运行的程序的信息***。***
- en: 'There are multipledebugging strategies. Here, we list some of them:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种调试策略。在这里，我们列出其中一些：
- en: '**Reproduce the error**: Identify the input data that caused it.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重现错误**：识别导致错误的输入数据。'
- en: '**Simplify the error**: Identify the simplest possible data that caused it.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化错误**：识别导致错误的可能最简单的数据。'
- en: '**Divide and** **rule**: Perform the main proceeding in step-over mode until
    the anomaly occurs. The method that caused it is the last performed before it
    was possible to find the problem, so we can re-debug by doing step-in into that
    particular invocation, and proceeding again with step-over following the method''s
    instructions.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分而治之**：以步进模式执行主要过程，直到出现异常。导致异常的方法是在能够找到问题之前执行的最后一个方法，因此我们可以通过对该特定调用进行步进调试，然后再次按照方法的指示进行步进。'
- en: '**Proceed consciously**: During debugging, you constantly compare the current
    values of the variables with the ones you would expect.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**谨慎进行**：在调试过程中，不断比较变量的当前值与您期望的值。'
- en: '**Check all the details**: Don''t overlook the details while debugging. It
    is best to make a note if you notice any discrepancies in the source code.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查所有细节**：在调试时不要忽视细节。如果您注意到源代码中有任何差异，最好做个记录。'
- en: '**Correct the errors**: Correct the error only if you are sure you have understood
    the problem well.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纠正错误**：只有在确信已经理解了问题时才纠正错误。'
- en: See also
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: A good Winpdb Reborn tutorial can be found at [http://heather.cs.ucdavis.edu/~matloff/winpdb.html#usewin](http://heather.cs.ucdavis.edu/~matloff/winpdb.html#usewin).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[http://heather.cs.ucdavis.edu/~matloff/winpdb.html#usewin](http://heather.cs.ucdavis.edu/~matloff/winpdb.html#usewin)找到一个很好的Winpdb
    Reborn教程。
- en: Interacting with pdb
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与pdb交互
- en: '`pdb` is a Python module for performing interactive debugging.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdb`是用于进行交互式调试的Python模块。'
- en: 'The main features of `pdb` are as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdb`的主要特点如下：'
- en: The use of breakpoints
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用断点
- en: Interactive processing of the source code line by line
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐行交互处理源代码
- en: Stack frame analysis
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈帧分析
- en: The debugger is implemented through the `pdb` class. For this reason, it can
    be easily extended with new features.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器是通过`pdb`类实现的。因此，它可以很容易地扩展新功能。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'No installation of `pdb` is required because it is part of the Python standard
    library.It can be launched with the following main use pattern:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要安装`pdb`，因为它是Python标准库的一部分。可以使用以下主要用法模式启动它：
- en: Interacting with the command line
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与命令行交互
- en: Using the Python interpreter
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python解释器
- en: Inserting a directive (that is, a `pdb` statement) in the code to debug
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中插入指令（即`pdb`语句）进行调试
- en: Interacting with the command line
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与命令行交互
- en: 'The simplest method is simply passing the name of your program as input. For
    example, for the `pdb_test.py` program, this is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法就是将程序的名称作为输入。例如，对于`pdb_test.py`程序，如下所示：
- en: '[PRE3]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'By executing from the command line, `pdb` loads the source file to be analyzed
    and stops its execution at the first statement found. In this case, the debug
    stops at line `1` (that is, at the definition of the`Pdb_test` class):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从命令行执行，`pdb`加载要分析的源文件，并在找到的第一个语句处停止执行。在这种情况下，调试停在第1行（即`Pdb_test`类的定义处）：
- en: '[PRE4]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using the Python interpreter
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python解释器
- en: 'The `pdb` module can be used in interactive mode by using the `run()` command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdb`模块可以通过使用`run()`命令以交互模式使用：'
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, the `run()` statement is from the debugger and will stop the execution
    before evaluating the first expression.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`run()`语句来自调试器，并且会在评估第一个表达式之前停止执行。
- en: Inserting a directive in the code to debug
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在代码中插入指令进行调试
- en: 'For a long-running process, where the problem occurs much later in the program
    execution, it would be much more convenient to start the debugger within the program
    using the `pdb set_trace()` directive:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于长时间运行的进程，在程序执行的后期出现问题的情况下，通过使用`pdb set_trace()`指令在程序内部启动调试器会更加方便：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`set_trace()` can be called at any point in the program to debug. For example,
    it can be called based on conditions, exception handlers, or a specific branch
    of control instructions.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_trace()`可以在程序的任何地方调用进行调试。例如，可以基于条件、异常处理程序或特定的控制指令分支进行调用。'
- en: 'In this case, the output is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出如下：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code run stops, exactly after the `pdb.set_trace()` statement completes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 代码运行在`pdb.set_trace()`语句完成后立即停止。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To interact with `pdb`, you need to use its language, which allows you to move
    around the code, examine and modify the values of the variables, insert breakpoints,
    or move through stack calls:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要与`pdb`交互，需要使用其语言，该语言允许您在代码中移动，检查和修改变量的值，插入断点或浏览堆栈调用：
- en: 'Use the `where` command (or alternatively, the compact form,`w`) to view which
    line of code is running and the call stack. In this case, this is on line 17 in
    the `go()` method of the `pdb_test.py` module:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`where`命令（或者紧凑形式`w`）查看正在运行的代码所在的行以及调用堆栈。在这种情况下，这是在`pdb_test.py`模块的`go()`方法的第17行：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Inspect the lines of code near the current location (indicated by an arrow)
    by using `list`. In the default mode, `11` rows are listed around the current
    one (five before and five after):'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`list`检查当前位置附近的代码行（由箭头指示）。在默认模式下，列出当前行周围的11行（之前5行和之后5行）：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If `list` receives two parameters, then they are interpreted as the first and
    last lines to be displayed:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`list`接收两个参数，则它们被解释为要显示的第一行和最后一行：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use `up` (or `u`) to move to older frames on the stack and `down` (or `d`)
    to move to more recent stack frames:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`up`（或`u`）移动到堆栈上更旧的帧，使用`down`（或`d`）移动到更近的堆栈帧：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The debugging activity is carried out following the flow of the running program
    (tracing). In each line of code, the coder displays the operations performed by
    the instructions in real time and the values recorded in the variables. In this
    way, the developer can check that everything is working properly or identify the
    cause of a malfunction.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 调试活动是按照运行程序的流程（跟踪）进行的。在每一行代码中，编码器实时显示指令执行的操作和变量中记录的值。通过这种方式，开发人员可以检查一切是否正常工作，或者确定故障的原因。
- en: Each programming language has its own debugger. However, there is no valid debugger
    for all programming languages because each language has its own syntax and grammar.
    The debugger executes the step-by-step source code. Therefore, the debugger must
    know the rules of the language, like the compiler.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言都有自己的调试器。但是，并没有适用于所有编程语言的有效调试器，因为每种语言都有自己的语法和语法。调试器逐步执行源代码。因此，调试器必须了解语言的规则，就像编译器一样。
- en: There's more...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The most useful `pdb` commands, along with their short forms, to keep in mind
    while working with the Python debugger are as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Python调试器时要牢记的最有用的`pdb`命令及其简写形式如下：
- en: '| **Command** | **Action** |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **操作** |'
- en: '| `args` | Prints the argument list of the current function |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `args` | 打印当前函数的参数列表 |'
- en: '| `break` | Creates a breakpoint (requires parameters)  |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `break` | 创建断点（需要参数） |'
- en: '| `continue` | Continues program execution |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `continue` | 继续程序执行 |'
- en: '| `help` | Lists the commands (or help) for a command (as a parameter) |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `help` | 列出命令（或帮助）的命令（作为参数） |'
- en: '| `jump` | Sets the next line to be executed |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `jump` | 设置要执行的下一行 |'
- en: '| `list` | Prints the source code around the current line |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `list` | 打印当前行周围的源代码 |'
- en: '| `next` | Continues execution until the next line in the current function
    is reached or returns |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `next` | 继续执行，直到到达当前函数中的下一行或返回 |'
- en: '| `step` | Executes the current line, stopping at the first possible occasion
    |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `step` | 执行当前行，停在第一个可能的位置 |'
- en: '| `pp` | Pretty-prints the value of the expression |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `pp` | 漂亮打印表达式的值 |'
- en: '| **`quit` **or** `exit`** | Aborts from `pdb` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **`quit`**或**`exit`** | 从`pdb`中退出 |'
- en: '| `return` | Continues execution until the current function returns |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `return` | 继续执行，直到当前函数返回 |'
- en: See also
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find out more about `pdb` by watching this interesting video tutorial: [https://www.youtube.com/watch?v=bZZTeKPRSLQ](https://www.youtube.com/watch?v=bZZTeKPRSLQ).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过观看这个有趣的视频教程了解更多关于`pdb`的信息：[https://www.youtube.com/watch?v=bZZTeKPRSLQ](https://www.youtube.com/watch?v=bZZTeKPRSLQ)。
- en: Implementing rpdb for debugging
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现用于调试的rpdb
- en: In some cases, it is appropriate to debug code in a remote location; that is,
    a location that doesn't reside on the same machine in which we run the debugger.
    For this purpose, `rpdb` was developed. This is a wrapper on `pdb` that uses a
    TCP socket to communicate with the world outside.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，适合在远程位置调试代码；也就是说，在与运行调试器的机器不在同一台机器上的位置。为此，开发了`rpdb`。这是`pdb`的包装器，它使用TCP套接字与外部世界通信。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The installation of `rpdb` first requires the main step of using `pip`. For
    Windows OS, just type the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先安装`rpdb`需要使用`pip`的主要步骤。对于Windows操作系统，只需输入以下内容：
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Then, you need to be sure that you have a working **telnet** client enabled
    on your machine. In Windows 10, if you open Command Prompt and type `telnet`,
    then the OS will respond with an error as it is not present by default in the
    installation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要确保你的机器上有一个可用的**telnet**客户端。在Windows 10中，如果你打开命令提示符并输入`telnet`，那么操作系统会以错误响应，因为它在安装中默认不包含。
- en: 'Let''s see how to install it with a few simple steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过几个简单的步骤安装它：
- en: Open Command Prompt in administrator mode.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以管理员模式打开命令提示符。
- en: Click on the Cortana button and type `cmd`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Cortana按钮，然后输入`cmd`。
- en: In the list that appears, right-click on the Command Prompt item and select
    Run as Administrator.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的列表中，右键单击“命令提示符”项目，然后选择“以管理员身份运行”。
- en: 'Then, when running Command Prompt as an administrator, type the following command:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，当以管理员身份运行命令提示符时，输入以下命令：
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Wait a few minutes until the installation finishes. If the process is successful,
    then you will see this:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待几分钟，直到安装完成。如果过程成功，那么你会看到这个：
- en: '![](assets/92df2ec3-4eb3-43be-a8a0-f6351d39f5de.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/92df2ec3-4eb3-43be-a8a0-f6351d39f5de.png)'
- en: 'Now, you can use telnet directly from the prompt. By typing `telnet`, the following
    window should appear:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以直接从提示符使用telnet。通过输入`telnet`，应该会出现以下窗口：
- en: '![](assets/1e25886f-dca3-41a6-8e2a-efaf80ff5b05.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1e25886f-dca3-41a6-8e2a-efaf80ff5b05.png)'
- en: In the following example, let's see how to run a remote debug with `rpdb`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，让我们看看如何使用`rpdb`进行远程调试。
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s perform the following steps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'Consider the following sample code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下示例代码：
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To use `rpdb`, you need to insert the following lines of code (just after the
    `import threading` statement). In fact, these three lines of code enable the use
    of `rpdb` via a remote client on port `4444` with an IP address of`127.0.0.1`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`rpdb`，你需要插入以下代码行（在`import threading`语句之后）。实际上，这三行代码使得通过端口`4444`和IP地址`127.0.0.1`上的远程客户端使用`rpdb`成为可能：
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you run the sample code after inserting these three lines of code that enable
    the use of `rpdb`, then you should see the following message on Python Command
    Prompt:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在插入了这三行代码以启用`rpdb`的示例代码中运行代码，那么你应该在Python命令提示符上看到以下消息：
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, you can switch to debug the sample code remotely by making the following
    telnet connection:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以通过以下telnet连接远程调试示例代码：
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following window should open:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该打开以下窗口：
- en: '![](assets/9f1b0949-3689-4ca7-9cd9-502cdaf6a028.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9f1b0949-3689-4ca7-9cd9-502cdaf6a028.png)'
- en: 'In the sample code, note the arrow in line 7. The code is not running, it is
    just waiting for an instruction to execute:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在示例代码中，注意第7行的箭头。代码没有运行，只是等待执行指令：
- en: '![](assets/1aa03050-e016-4563-94a9-b3418cef7ef4.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1aa03050-e016-4563-94a9-b3418cef7ef4.png)'
- en: 'For example, here, we execute the code and type the `next` statementrepeatedly:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，在这里，我们执行代码并重复输入“next”语句：
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once the program is finished, you can still run a new debug section. Now, let's
    see how `rpdp` works in the next section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 程序完成后，你仍然可以运行一个新的调试部分。现在，让我们看看在下一节中`rpdp`是如何工作的。
- en: How it works...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this section, we'll see how to simply move through the code by using the
    `next` statement, which continues execution until the next line in the current
    function is reached or returned.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何简单地通过使用`next`语句在代码中移动，该语句继续执行，直到达到或返回当前函数中的下一行。
- en: 'To use `rpdb`, follow these steps:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`rpdb`，请按照以下步骤进行：
- en: 'Import the relevant `rpdb` library:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入相关的`rpdb`库：
- en: '[PRE19]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Set the `debugger` parameter, which specifies the telnet port to connect to
    in order to run the debugger:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`debugger`参数，指定telnet端口以连接以运行调试器：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Call the `set_trace()`  directive, which makes it possible to enter into debugging
    mode:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`set_trace()`指令，这使得进入调试模式成为可能：
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In our case, we placed the `set_trace()` directive immediately after the `debugger`
    instance. In reality, we can place it anywhere in the code; for example, if conditions
    are satisfied, or within a section managed by an exception.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将`set_trace()`指令放在`debugger`实例之后。实际上，我们可以将它放在代码的任何地方；例如，如果条件满足，或者在由异常管理的部分内。
- en: 'The second step, instead, consists of opening Command Prompt and launching
    `telnet` by setting the same port value specified in the `debugger` parameter
    definition within the sample code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步，是打开命令提示符并启动`telnet`，并设置与示例代码中`debugger`参数定义中指定的相同端口值：
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is possible to interact with the `rpdb` debugger by using a small command
    language that allows movement between calls to the stack, to examine and to modify
    the values of the variables and control the way in which the debugger executes
    its own program.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用一个小的命令语言与`rpdb`调试器进行交互，该语言允许在调用堆栈之间移动，检查和修改变量的值，并控制调试器执行自己的程序的方式。
- en: There's more...
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The list of commands with which you can interact with in `rpdb` can be displayed
    by typing the `help` command from the `Pdb` prompt:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`Pdb`提示符下输入`help`命令，可以显示可以与`rpdb`交互的命令列表：
- en: '[PRE23]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Among the most useful commands, this is how we insert the breakpoints in the
    code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在最有用的命令中，这是我们在代码中插入断点的方法：
- en: 'Type `b` and the line numberto set a breakpoint. Here, a breakpoint is set
    in lines `5` and `10`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`b`和行号来设置断点。在这里，断点设置在第`5`行和第`10`行：
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It is sufficient to type the `b` command to display the list of breakpoints
    implemented:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需输入`b`命令即可显示已实施的断点列表：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: At each new breakpoint added, a numeric identifier is assigned. These identifiers
    are used to enable, disable, and interactively remove breakpoints. To disable
    a breakpoint, use the `disable` command, which tells the debugger not to stop
    when that line is reached. The breakpoint is not forgotten but is ignored.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每次添加新的断点时，都会分配一个数字标识符。这些标识符用于启用、禁用和交互式地删除断点。要禁用断点，请使用`disable`命令，告诉调试器在达到该行时不要停止。断点不会被遗忘，而是被忽略。
- en: See also
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'You can find a lot of information on `pdb`, and then on `rpdb`, on this site:
    [https://github.com/spiside/pdb-tutorial](https://github.com/spiside/pdb-tutorial).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这个网站上找到关于`pdb`和`rpdb`的大量信息：[https://github.com/spiside/pdb-tutorial](https://github.com/spiside/pdb-tutorial)。
- en: 'In the next two sections, we will look at some Python tools that are used for
    the implementation of unit tests:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，我们将看一些用于实施单元测试的Python工具：
- en: '`unittest`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unittest`'
- en: '`nose`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nose`'
- en: Dealing with unittest
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理单元测试
- en: The `unittest` module is provided with the standard Python library. It has an
    extensive set of tools and procedures for performing unit tests. In this section,
    we'll briefly see how the `unittest` module works.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`模块是标准Python库提供的。它具有一套广泛的工具和程序，用于执行单元测试。在本节中，我们将简要介绍`unittest`模块的工作原理。'
- en: 'A unit test consists of two parts:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试由两部分组成：
- en: The code to manage the so-called *test system*
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理所谓的*测试系统*的代码
- en: The test itself
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试本身
- en: Getting ready
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The simplest `unittest` module can be obtained via the `TestCase` subclass,
    to which the appropriate methods must be rewritten or added.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的`unittest`模块可以通过`TestCase`子类获得，必须重写或添加适当的方法。
- en: 'A simple `unittest` module can be composed as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的`unittest`模块可以如下组成：
- en: '[PRE26]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To run the `unittest` module,you need to include `unittest.main ()`, while we
    have a single method, `test()`, which fails if `True`is ever `False`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行`unittest`模块，需要包含`unittest.main()`，而我们有一个单一的方法`test()`，如果`True`曾经是`False`，则失败。
- en: 'By executing the preceding example, you get the following result:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行上面的例子，您将得到以下结果：
- en: '[PRE27]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The test was successful, thus giving the result, `OK`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 测试成功，因此得到结果`OK`。
- en: In the following section, we go into more detail about how the `unittest` module
    works. In particular, we want to study what the possible outcomes of a unit test are.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将更详细地介绍`unittest`模块的工作原理。特别是，我们想研究单元测试的可能结果。
- en: How to do it...
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see how we can characterize the results of a test with this example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过这个例子来描述测试的结果：
- en: 'Import the relevant module:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入相关模块：
- en: '[PRE28]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Define the `outcomesTest` class, which has the `TestCase` subclass as its argument:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`outcomesTest`类，它的参数是`TestCase`子类：
- en: '[PRE29]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first method we define is `testPass`:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义的第一个方法是`testPass`：
- en: '[PRE30]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is the `TestFail` method:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`TestFail`方法：
- en: '[PRE31]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we have the `TestError` method:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有`TestError`方法：
- en: '[PRE32]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we have the `main` function, with which we recall our procedure:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有`main`函数，通过它我们回顾我们的过程：
- en: '[PRE33]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this example, the possible outcomes of a unit test by `unittest` are shown.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，展示了`unittest`的单元测试可能的结果。
- en: 'The possible outcomes are as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的结果如下：
- en: '`ERROR`: The test raises an exception other than `AssertionError`. There is
    no explicit way to pass a test, so the test status depends on the presence (or
    absence) of an exception.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ERROR`：测试引发了除`AssertionError`之外的异常。没有明确的方法来通过测试，因此测试状态取决于异常的存在（或不存在）。'
- en: '`FAILED`: The test is not passed and an `AssertionError` exception is raised.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FAILED`：测试未通过，并引发了`AssertionError`异常。'
- en: '`OK`: The test is passed.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OK`：测试通过。'
- en: 'The output is as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE34]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Most tests affirm the truth of a condition. There are different ways of writing
    tests that verify a truth, depending on the perspective of the author of the test
    and whether the desired result of the code is verified. If the code produces a
    value that can be evaluated as true, then the `failUnless ()` and `assertTrue ()`
    methods should be used. If the code produces a false value, then it makes more
    sense to use the `failIf ()` and`assertFalse ()` methods:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数测试都确认条件的真实性。根据测试作者的角度和代码的期望结果是否得到验证，编写验证真实性的测试有不同的方式。如果代码产生一个可以评估为真的值，那么应该使用`failUnless ()`和`assertTrue ()`方法。如果代码产生一个假值，那么使用`failIf ()`和`assertFalse ()`方法更有意义：
- en: '[PRE35]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The result is as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE36]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There's more...
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As mentioned previously, if a test raises an exception other than `AssertionError`,
    then it is treated as an error. This is very useful for discovering errors that
    occur while you are editing code for which a matched test already exists.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果测试引发的异常不是`AssertionError`，那么它将被视为错误。这对于发现在编辑已存在匹配测试的代码时发生的错误非常有用。
- en: 'There are circumstances, however, in which you would want to run a test to
    verify that certain code actually produces an exception. For example, in cases
    when an invalid value is passed as an attribute of an object. In such cases, `failUnlessRaises()`
    makes the code clearer than capturing the exception in your code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些情况下，您可能希望运行一个测试来验证某些代码是否实际产生异常。例如，在传递无效值作为对象的属性时。在这种情况下，`failUnlessRaises()`比在代码中捕获异常更清晰：
- en: '[PRE37]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The results for both are the same. However, the result for the second test,
    which uses `failUnlessRaises()`, is shorter:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 两者的结果是一样的。然而，使用`failUnlessRaises()`的第二个测试的结果更短：
- en: '[PRE38]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: See also
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: More information on Python testing can be found at [https://realpython.com/python-testing/](https://realpython.com/python-testing/).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Python测试的更多信息可以在[https://realpython.com/python-testing/](https://realpython.com/python-testing/)找到。
- en: Application testing using nose
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用nose进行应用测试
- en: '`nose` is an important Python module for defining unit tests. It allows us
    to write simple test functions using subclasses of `unittest.TestCase`but also,
    classes of tests that are *not subclasse*s of `unittest.TestCase`.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`nose`是一个重要的Python模块，用于定义单元测试。它允许我们编写简单的测试函数，使用`unittest.TestCase`的子类，但也可以编写*不是`unittest.TestCase`的子类*的测试类。'
- en: Getting ready
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Install `nose`by using `pip`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pip`安装`nose`：
- en: '[PRE39]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The source package can be downloaded and installed at [https://pypi.org/project/nose/](https://pypi.org/project/nose/)
    by following these steps:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下步骤下载和安装源包：[https://pypi.org/project/nose/](https://pypi.org/project/nose/)
- en: Unzip the source package.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压源包。
- en: '`cd` to the new directory.'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cd`到新目录。'
- en: 'Then, enter the following command:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输入以下命令：
- en: '[PRE40]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'One of the strengths of `nose` is automatically collecting tests from the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`nose`的一个优点是自动从以下位置收集测试：'
- en: Python source files
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python源文件
- en: Directories and packages found in the working directory
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工作目录中找到的目录和包
- en: 'To specify which tests to run, pass the relevant test names on the command
    line:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定要运行的测试，请在命令行上传递相关的测试名称：
- en: '[PRE41]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The test names specified may be file or module names, and may optionally indicate
    the test case to run by separating the module or filename from the test case name
    with a colon. Filenames may be relative or absolute.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 指定的测试名称可以是文件或模块名称，并且可以通过使用冒号分隔模块或文件名和测试用例名称来指示要运行的测试用例。文件名可以是相对的或绝对的。
- en: 'Some examples are as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些例子：
- en: '[PRE42]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You may also change the working directory, where `nose` looks for tests, by
    using the `-w` switch:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`-w`开关更改`nose`查找测试的工作目录：
- en: '[PRE43]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Note, however, that support for multiple `-w` arguments is now deprecated and
    will be removed in a future release. However, it is possible to get the same behavior
    by specifying the target directories without the `-w` switch:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，对多个`-w`参数的支持现已不推荐使用，并将在将来的版本中删除。但是，可以通过在没有`-w`开关的情况下指定目标目录来获得相同的行为：
- en: '[PRE44]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Further customization of test selection and loading is possible through the
    use of plugins.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用插件，可以进一步自定义测试选择和加载。
- en: The test result output is identical to that of `unittest`, except for the additional
    features, such as error classes, and plugin-supplied features such as output capture
    and assert introspection.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 测试结果输出与`unittest`相同，除了额外的功能，例如错误类和插件提供的功能，如输出捕获和断言内省。
- en: In the next section, we look at testing a class using `nose`*.*
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍使用`nose`测试类的方法。
- en: How to do it...
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s perform the steps that follow:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: Import the relevant `nose.tools`*:*
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入相关的`nose.tools`*：*
- en: '[PRE45]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, set the `TestSuite`class. Here,the methods of the class are tested by
    the `eq_` function:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，设置`TestSuite`类。在这里，通过`eq_`函数测试类的方法：
- en: '[PRE46]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: A unit test can be developed independently by the developer, but it is good
    practice to have a standard product such as `unittest` and adhere to a common
    test practice.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以独立开发单元测试，但最好使用标准产品，如`unittest`，并遵循常见的测试实践。
- en: 'As you can see from the following example, the test method was set by using
    the `eq_` function. This is similar to `assertEquals` by `unittest`, which verifies
    that the two parameters are equal:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从以下示例中所见，使用`eq_`函数设置了测试方法。这类似于`unittest`的`assertEquals`，它验证两个参数是否相等：
- en: '[PRE47]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This testing practice, despite good in intentions, has obvious limitations,
    such as not being able to be repeated over time (for example, when a software
    module changes) for so-called **regression tests**.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试实践，尽管意图良好，但显然有明显的局限性，例如不能随时间重复（例如，当软件模块更改时）所谓的**回归测试**。
- en: 'Here is the output:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE48]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In general, testing is not able to identify all the errors in a program and
    the same is true for unit testing, which, by analyzing individual units by definition,
    cannot identify integration errors, performance problems, and other system-related
    problems. In general, unit testing is more effective when used in conjunction
    with other software testing techniques.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，测试不能识别程序中的所有错误，对于单元测试也是如此，因为根据定义，单元测试无法识别集成错误、性能问题和其他与系统相关的问题。一般来说，单元测试与其他软件测试技术结合使用时更有效。
- en: Like any form of testing, even unit testing cannot certify the absence of errors,
    but can only *highlight* their presence.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何形式的测试一样，即使单元测试也不能证明错误的不存在，而只能*突出显示*它们的存在。
- en: There's more...
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Software testing is a combinatorial mathematics problem. For example, each Boolean
    test requires at least two tests, one for the true condition and one for the false
    condition. It can be shown that, for each functional code line, three to five
    lines of code are required for a test. It is therefore unrealistic to test all
    possible input combinations of any non-trivial code without a dedicated test case
    generation tool.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试是一个组合数学问题。例如，每个布尔测试都需要至少两个测试，一个用于真条件，一个用于假条件。可以证明，对于每个功能代码行，需要三到五行代码进行测试。因此，对于任何非平凡代码，测试所有可能的输入组合是不现实的，除非有专门的测试用例生成工具。
- en: To achieve the desired benefits from a unit test, a strict sense of discipline
    is required throughout the development process. It is essential to keep track
    not only of the tests that have been developed and performed but also of all the
    changes made to the functional code of the unit in question and all the other
    units. The use of a version control system is essential. If a later version of
    a unit fails a test that it previously passed, then a version control system allow
    you to highlight the code changes that have occurred in the meantime.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从单元测试中获得期望的好处，开发过程中需要严格的纪律。不仅要跟踪已开发和执行的测试，还要跟踪对所讨论的单元的功能代码以及所有其他单元所做的所有更改。使用版本控制系统是必不可少的。如果单元的后续版本未通过先前通过的测试，则版本控制系统允许您突出显示其间发生的代码更改。
- en: See also
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: A valid tutorial on `nose` is available at[https://nose.readthedocs.io/en/latest/index.html](https://nose.readthedocs.io/en/latest/index.html).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`nose`的有效教程可在[https://nose.readthedocs.io/en/latest/index.html](https://nose.readthedocs.io/en/latest/index.html)找到。'

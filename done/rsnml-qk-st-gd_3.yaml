- en: Creating ReasonReact Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ReasonReact组件
- en: 'Now that we''ve set up our development environment, we''re ready to get started
    with ReasonReact—the future of ReactJS. Both ReasonML and ReasonReact were built
    by the same person who built ReactJS. ReasonReact is just Reason, much like how
    ReactJS is just JavaScript. Throughout the rest of this book, we will be working
    with an application that we will start building in this chapter. The following
    are screenshots of what we''ll have built by the end of this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了开发环境，我们准备开始使用ReasonReact——ReactJS的未来。ReasonML和ReasonReact都是由构建ReactJS的同一个人构建的。ReasonReact就是Reason，就像ReactJS就是JavaScript一样。在本书的其余部分，我们将使用在本章开始构建的应用程序。以下是本章结束时我们将构建的内容的截图：
- en: '![](img/b88262e1-bf4b-4508-aa96-84b090a76664.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b88262e1-bf4b-4508-aa96-84b090a76664.png)'
- en: To follow along, clone this book's GitHub repository and start from `Chapter03/start`.
    Throughout the rest of this book, each directory shares the same development environment
    as the one we set up at the end of [Chapter 2](4e4e3057-fca6-4c81-b6a7-05575aeeace3.xhtml),
    *Setting Up a Development Environm**ent*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟着做，克隆这本书的GitHub存储库，并从`Chapter03/start`开始。在本书的其余部分，每个目录都与我们在[第2章](4e4e3057-fca6-4c81-b6a7-05575aeeace3.xhtml)结束时设置的开发环境相同。
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We'll first explore ReasonReact, and at about halfway through this chapter,
    we'll shift to the `Chapter03/app-start` directory, where we'll start building
    an application with ReasonReact's built-in router.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探索ReasonReact，并且在本章的中间部分，我们将转移到`Chapter03/app-start`目录，在那里我们将开始使用ReasonReact的内置路由器构建应用程序。
- en: 'In this chapter, we will do the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Explore creating stateless and stateful ReasonReact components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索创建无状态和有状态的ReasonReact组件
- en: Create an application that includes navigation and routing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包括导航和路由的应用程序
- en: See how so many of the ReactJS concepts you're already familiar with map nicely
    to ReasonReact
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看你已经熟悉的这么多ReactJS概念如何很好地映射到ReasonReact
- en: Learn how ReasonReact can help us create more robust components thanks to Reason's
    type system
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解ReasonReact如何通过Reason的类型系统帮助我们创建更健壮的组件
- en: Component creation basics
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件创建基础知识
- en: 'Let''s start by analyzing a simple stateless component. In `App.re`, let''s
    render a `<div />` element with some text:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从分析一个简单的无状态组件开始。在`App.re`中，让我们呈现一个带有一些文本的`<div />`元素：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And in `Index.re`, render the component to a DOM element with an ID of `"root"`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 并在`Index.re`中，将组件呈现到ID为`"root"`的DOM元素：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Due to Reason's module system, we do not need an `import` statement in `Index.re` nor
    an export statement in `App.re`. Every Reason file is a module, and every Reason
    module is globally available. Later in this book, we will see how a module's implementation
    details can be hidden so that users of your component only access things they
    are supposed to access.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Reason的模块系统，我们不需要在`Index.re`中使用`import`语句，也不需要在`App.re`中使用导出语句。每个Reason文件都是一个模块，每个Reason模块都是全局可用的。在本书的后面，我们将看到如何隐藏模块的实现细节，以便您组件的用户只能访问他们应该访问的内容。
- en: Component templates
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件模板
- en: 'In ReasonReact, all components are created with one of the following four functions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在ReasonReact中，所有组件都是使用以下四个函数之一创建的：
- en: '`ReasonReact.statelessComponent`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReasonReact.statelessComponent`'
- en: '`ReasonReact.statelessComponentWithRetainedProps`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReasonReact.statelessComponentWithRetainedProps`'
- en: '`ReasonReact.reducerComponent`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReasonReact.reducerComponent`'
- en: '`ReasonReact.reducerComponentWithRetainedProps`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReasonReact.reducerComponentWithRetainedProps`'
- en: 'Each of the four functions accepts a `string` and returns a `record` corresponding
    to a different component template. The `string` argument is only for debugging
    purposes. The component gets its name (`<App />`) from its filename (`App.re`).
    The fields the returned record contains are dependent on which of the functions
    was used. In the case of our previous example, we have the following fields that
    we can override:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个函数中的每一个都接受一个`string`并返回与不同组件模板对应的`record`。`string`参数仅用于调试目的。组件的名称(`<App />`)来自其文件名(`App.re`)。返回的记录包含的字段取决于使用了哪个函数。在我们之前的例子中，我们可以覆盖以下字段：
- en: '`render`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render`'
- en: '`didMount`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`didMount`'
- en: '`willReceiveProps`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`willReceiveProps`'
- en: '`shouldUpdate`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shouldUpdate`'
- en: '`willUpdate`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`willUpdate`'
- en: '`didUpdate`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`didUpdate`'
- en: '`willUnmount`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`willUnmount`'
- en: Aside from the `render` field, the rest are just familiar ReactJS life cycle
    events. To override a field, add that field within the `make` function's returned
    `record`. In the preceding example, the component template's `render` field was
    replaced with the custom `render` function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`render`字段外，其余的都是熟悉的ReactJS生命周期事件。要覆盖一个字段，在`make`函数返回的`record`中添加该字段。在前面的例子中，组件模板的`render`字段被自定义的`render`函数替换了。
- en: The `make` function accepts `props` as arguments, and returns a `record` of
    the same shape as the one that was initially created by one of the four component
    creation functions. The last argument to the `make` function must be the `children` prop.
    You may have noticed that `children` is prefixed with an `_` in the preceding
    example. If your component does not need a reference to the children prop, then
    prefixing the argument with an `_` prevents a compiler warning for the unused
    binding.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`make`函数接受`props`作为参数，并返回与四个组件创建函数之一最初创建的形状相同的`record`。`make`函数的最后一个参数必须是`children`属性。您可能已经注意到，在前面的例子中，`children`前缀为`_`。如果您的组件不需要引用children属性，则使用`_`前缀可以防止未使用绑定的编译器警告。'
- en: It may not appear immediately obvious, but the `make` function's curly braces
    belong to the returned `record` literal. The `...component` expression spreads
    the contents of the original `record` in this new `record` so that individual
    fields can be overridden without having to explicitly set each field.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`make`函数的花括号属于返回的`record`文字。`...component`表达式将原始`record`的内容扩展到这个新的`record`中，以便可以覆盖单个字段，而无需显式设置每个字段。'
- en: self
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: self
- en: 'The `render` field holds a callback function that accepts an argument called
    `self`, and returns a value of type `ReasonReact.reactElement`. The three fields
    of the `self` record are the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`字段保存一个接受名为`self`的参数的回调函数，并返回类型为`ReasonReact.reactElement`的值。`self`记录的三个字段如下：'
- en: '`state`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`'
- en: '`handle`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handle`'
- en: '`send`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send`'
- en: By choice, ReasonReact does not have the concept of JavaScript's `this`. Instead,
    `self` holds the necessary information and is provided to callbacks that need
    it. We'll see more of `self` when using stateful components.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ReasonReact不具有JavaScript的`this`的概念。相反，`self`保存必要的信息，并提供给需要它的回调函数。在使用有状态组件时，我们将看到更多关于`self`的内容。
- en: Event handlers
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件处理程序
- en: 'In our render function, we can attach event listeners to DOM elements the same
    way that we would in ReactJS. For example, to listen for the click event, we add
    an `onClick` attribute and set its value to an event handler:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的渲染函数中，我们可以以与ReactJS相同的方式将事件侦听器附加到DOM元素上。例如，要监听点击事件，我们添加一个`onClick`属性并将其值设置为事件处理程序：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, this callback function must accept exactly one argument (corresponding
    to a JavaScript DOM event) and mustreturn a type called `unit`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这个回调函数必须接受一个参数（对应于JavaScript DOM事件）并且必须返回一个名为`unit`的类型。
- en: unit
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: unit
- en: 'In Reason, `unit` is a type that means "nothing." A function whose return type
    is `unit` cannot return anything other than `unit`. There is exactly one value
    of type `unit`: `()` (that is, a pair of empty parentheses, which is also called
    `unit`).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在Reason中，`unit`是一个表示"nothing"的类型。返回类型为`unit`的函数除了`unit`之外不能返回任何其他值。`unit`类型有一个值：`()`（即一对空括号，也称为`unit`）。
- en: 'In contrast, there are exactly two values of type `bool`: `true` and `false`.
    There are an infinite number of values of type `int`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`bool`类型有两个值：`true`和`false`。`int`类型有无限多个值。
- en: As discussed in [Chapter 1](75c7a9ae-b7e6-4ba7-97d0-eaa5cad2967c.xhtml), *Introduction to
    ReasonML*, the idiomatic way to represent a nullable value in Reason is with the
    `option` type. The major difference between the `option` type and the `unit` type
    is that a value of type `option` could be nothing, or it could be some value where
    as a value of type `unit` is always `()`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](75c7a9ae-b7e6-4ba7-97d0-eaa5cad2967c.xhtml)中讨论了*ReasonML简介*，在Reason中表示可空值的习惯方式是使用`option`类型。`option`类型和`unit`类型之间的主要区别在于`option`类型的值可以是空，也可以是某个值，而`unit`类型的值始终是`()`。
- en: A function that accepts and/or returns `unit` likely causes side effects. For
    example, `Js.log` is a function that returns `unit`. The `onClick` event handler
    is also a function that returns `unit`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接受和/或返回`unit`的函数可能会引起副作用。例如，`Js.log`是一个返回`unit`的函数。`onClick`事件处理程序也是一个返回`unit`的函数。
- en: '`Random.bool` is an example of a function that accepts `unit` as its argument
    and returns a `bool`. The syntax for calling a function with `unit` is quite familiar:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Random.bool`是一个接受`unit`作为参数并返回`bool`的函数的示例。调用带有`unit`的函数的语法非常熟悉：'
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since `onClick` needs a function that returns `unit`, the following will result
    in a type error:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`onClick`需要一个返回`unit`的函数，以下内容将导致类型错误：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The type error is shown here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 类型错误显示在这里：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the error message, `This expression` refers to `42`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误消息中，`This expression`指的是`42`。
- en: JSX
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX
- en: 'Reason comes with the JSX syntax. One difference in ReasonReact''s version
    of JSX is that we cannot do the following in ReasonReact:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Reason带有JSX语法。ReasonReact版本的JSX的一个区别是我们不能在ReasonReact中执行以下操作：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Instead, we need to convert the `string` to a `ReasonReact.reactElement` with
    the `ReasonReact.string` function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们需要使用`ReasonReact.string`函数将`string`转换为`ReasonReact.reactElement`：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, this still doesn''t work. We need to also wrap the expression with
    `{ }` to help the parser differentiate between multiple possible children:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这仍然不起作用。我们还需要用`{ }`来包装表达式，以帮助解析器区分多个可能的子元素：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You''re free to create an alias that is less verbose and use that instead:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自由创建一个更简洁的别名并使用它：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When a custom component is invoked in JSX, its `make` function is called. The `<App
    />` syntax desugars to the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSX中调用自定义组件时，将调用其`make`函数。`<App />`语法解糖为以下内容：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When a component will receive new props, its `make` function will again be called
    with the new props as arguments. The `make` function is like a combination of
    ReactJS's `constructor` and ReactJS's `componentWillReceiveProps`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件将接收新的props时，它的`make`函数将再次被调用，并将新的props作为参数。`make`函数就像ReactJS的`constructor`和ReactJS的`componentWillReceiveProps`的组合。
- en: Props
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Props
- en: 'Let''s add a few props to our `<App />` component:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给我们的`<App />`组件添加一些props：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After compiling, we get a compiler error, because in `Index.re` we aren''t
    providing the required `greeting` and `name` props:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，我们得到了一个编译器错误，因为在`Index.re`中我们没有提供所需的`greeting`和`name`属性：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`greeting` and `name` are **labelled arguments** of the `make` function, meaning
    that they can be provided in any order. To convert an argument to a labelled argument,
    prefix it with a tilde (`~`). Reason also supports optional arguments as well
    as arguments with defaults. Let''s give `greeting` a default value and make `name`
    optional:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`greeting`和`name`是`make`函数的**标记参数**，这意味着它们可以以任何顺序提供。要将参数转换为标记参数，请使用波浪号(`~`)作为前缀。Reason还支持可选参数以及带默认值的参数。让我们给`greeting`一个默认值并使`name`可选：'
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since `name` is an optional argument, it's wrapped in an `option` type, and
    we can then pattern match on its value. Of course, this is just a long-winded
    way of providing `name` with a default argument of `""`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`name`是一个可选参数，它被包装在`option`类型中，然后我们可以对其值进行模式匹配。当然，这只是一种提供`name`默认参数为`""`的冗长方式。
- en: 'Now, our example compiles even if `<App />` isn''t provided with any props:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，即使未为`<App />`提供任何props，我们的示例也可以编译：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we then decide to remove the name prop, the compiler will tell us where we
    need to update the usage of `<App />`. This gives us the freedom to refactor our
    components without worrying about forgetting to update an area of our codebase.
    The compiler has our back!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定删除名称属性，编译器将告诉我们需要更新`<App />`的使用位置。这使我们可以自由地重构我们的组件，而不必担心忘记更新代码库中的某个区域。编译器支持我们！
- en: Children
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子元素
- en: The last argument to the `make` function is always the `children` prop—it's
    mandatory. Just like other props, children can be any data structure. As long
    as the component allows it, we can use the render prop pattern that is popular
    in ReactJS. Importantly, ReasonReact always wraps children in an array, so we
    need to unwrap the array with the `...` syntax if we don't want this wrapping.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`make`函数的最后一个参数始终是`children`属性-它是强制性的。与其他属性一样，子元素可以是任何数据结构。只要组件允许，我们就可以使用在ReactJS中流行的渲染属性模式。重要的是，ReasonReact始终将子元素包装在数组中，因此如果我们不想要这种包装，就需要使用`...`语法来解包数组。'
- en: 'In `App.re`, we''ll remove all props except for the required `children` prop.
    In the render function, we invoke children with our hardcoded greeting:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在`App.re`中，我们将删除除了必需的`children`属性之外的所有属性。在渲染函数中，我们使用我们硬编码的问候语调用子元素：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And in `Index.re`, we add a function as a child of `<App />` that accepts the
    provided greeting and returns JSX (which is of type `ReasonReact.reactElement`).
    Notice the `...` syntax used to unwrap the array that all ReasonReact children
    are wrapped with:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Index.re`中，我们添加一个作为`<App />`子元素的函数，该函数接受提供的问候并返回JSX（类型为`ReasonReact.reactElement`）。请注意`...`语法用于解包所有ReasonReact子元素都包装在其中的数组：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we forget the `...`, the compiler will kindly let us know:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忘记了`...`，编译器会友好地提醒我们：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We'll even get a similar compiler message if we don't include any children (that
    is, just `<App />`), since that translates into an empty array. This means that
    we're guaranteed that users of our component have to provide a function of type
    `string => ReasonReact.reactElement` as a child of `<App />` if it's going to
    type check.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不包含任何子元素（即只有`<App />`），甚至会收到类似的编译器消息，因为这会转换为空数组。这意味着我们保证组件的用户必须在`<App />`的子元素中提供类型为`string
    => ReasonReact.reactElement`的函数，如果它要进行类型检查的话。
- en: 'We can also mandate that our component accepts other children types, for example,
    a tuple of two strings:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以要求我们的组件接受其他类型的子元素，例如两个字符串的元组：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Reason is able to infer that children must be a tuple of type `(string, string)`
    because of its use in `App.re`. For example, consider the following usage:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在`App.re`中使用了它，Reason能够推断出子元素必须是类型为`(string, string)`的元组。例如，考虑以下用法：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will result in a friendly compiler error because the `App` component requires
    its children to be a tuple but the `App` component's children is not a tuple.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致友好的编译器错误，因为`App`组件要求其子元素是一个元组，但`App`组件的子元素不是元组。
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is incredibly powerful. Since we get these guarantees at compile time,
    we don't have to worry about runtime checks on the shape of our component's children.
    Similarly, we are guaranteed that props type check at compile time. Refactoring
    components is much less stressful because the compiler guides us along the way.
    What's more, thanks to Reason's powerful type inference, we haven't had to explicitly
    annotate any types so far.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常强大。由于我们在编译时获得了这些保证，因此我们不必担心组件子元素的形状是否符合运行时检查。同样，我们保证了属性在编译时进行类型检查。重构组件变得不那么紧张，因为编译器会指导我们。更重要的是，由于Reason的强大类型推断，到目前为止我们还没有必须明确注释任何类型。
- en: Life cycles
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期
- en: 'ReasonReact supports the familiar ReactJS life cycle events. We will get a
    closer look at some of the life cycle events as we build our app, but, for now,
    let''s see how we can implement ReactJS''s `componentDidMount` life cycle hook
    for `<App />`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ReasonReact支持熟悉的ReactJS生命周期事件。当我们构建我们的应用程序时，我们将更仔细地查看一些生命周期事件，但是现在，让我们看看如何为`<App
    />`实现ReactJS的`componentDidMount`生命周期挂钩：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Instead of `componentDidMount`, we use `didMount`. Again, `didMount` is just
    a field within a record returned by the component's `make` function. The type
    of `didMount` is `self => unit`, which is a function that accepts `self` and returns
    `unit`. Since it returns `unit`, it's likely that `didMount` causes a side effect,
    and in our example it does. Running this in the browser results in `mounted` logged
    to the console.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`didMount`而不是`componentDidMount`。同样，`didMount`只是组件的`make`函数返回的记录中的一个字段。`didMount`的类型是`self
    => unit`，它是一个接受`self`并返回`unit`的函数。由于它返回`unit`，它很可能会导致副作用，在我们的示例中确实如此。在浏览器中运行结果会在控制台中记录`mounted`。
- en: Subscriptions helper
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅助手
- en: 'To make writing cleanup code more convenient and easier to remember, ReasonReact
    provides `self.onUnmount`, which can be used directly within a component''s `didMount`
    life cycle (or anywhere that has access to `self`). This allows you to write the
    cleanup code alongside its complement instead of separately, within `willUnmount`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使编写清理代码更加方便和容易记忆，ReasonReact提供了`self.onUnmount`，它可以直接在组件的`didMount`生命周期中使用（或者在任何可以访问`self`的地方）。这允许您将清理代码与其补充一起编写，而不是分开在`willUnmount`中：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Stateful components
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有状态组件
- en: So far, we've only used the `ReasonReact.statelessComponent` template. To create
    a stateful component, we switch out the component template to `ReasonReact.reducerComponent`
    and override some additional fields within the record returned by its `make` function.
    As we'll soon see, we'll also need to declare custom type definitions for use
    in these additional fields. It's called `reducerComponent` because it has the
    concept of state, actions, and reducers built in—just like Redux, except state,
    actions, and reducers are local to the component.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了`ReasonReact.statelessComponent`模板。要创建一个有状态的组件，我们将组件模板切换为`ReasonReact.reducerComponent`，并覆盖其`make`函数返回的记录中的一些附加字段。很快我们将看到，我们还需要声明自定义类型定义以在这些附加字段中使用。它被称为`reducerComponent`，因为它具有状态、操作和内置的reducer的概念-就像Redux一样，只是状态、操作和reducer是局部的。
- en: 'A simple counter component with buttons to increment and decrement the current
    count is shown here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了一个简单的计数器组件，带有增加和减少当前计数的按钮：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The ReactJS Fragment syntax (`<>` and `</>`) is used here to wrap the `<button>`
    and `<span>` elements without adding an unnecessary DOM node.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用了ReactJS片段语法（`<>`和`</>`）来包装`<button>`和`<span>`元素，而不添加不必要的DOM节点。
- en: State, action, and reducer
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态、动作和减速器
- en: 'Let''s break this down. At the top of the file, we see two type declarations,
    one for state and one for actions. The names `state` and `action` are a convention,
    but you can use any name you like:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下。在文件的顶部，我们看到了两个类型声明，一个是状态，一个是动作。`state`和`action`是一种约定，但您可以使用任何您喜欢的名称：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Just as in Redux, events trigger actions that are sent to a reducer that then
    updates state. Next, the button''s click event triggers a `Decrement` action that
    gets sent to the component''s reducer via `self.send`. Remember, the render function
    is provided `self` as its argument:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在Redux中一样，事件触发动作，这些动作被发送到一个减速器，然后更新状态。接下来，按钮的点击事件触发一个“减量”动作，通过“self.send”发送到组件的减速器。记住，渲染函数将“self”作为其参数提供：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `state` type declaration defines the shape of our state. In this case,
    our state is just an integer that holds the component''s current count. The component''s
    initial state is `0`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`state`类型声明定义了我们状态的形状。在这种情况下，我们的状态只是一个保存组件当前计数的整数。组件的初始状态是`0`：'
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`initialState` requires a function of type `unit => state`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`initialState`需要一个类型为`unit => state`的函数。'
- en: 'When triggered by an action, the reducer function accepts that action as well
    as the current state, and returns a new state. Pattern matching is used on the
    current action, and `ReasonReact.Update` is used to return a new state:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当被动作触发时，减速器函数接受该动作以及当前状态，并返回一个新状态。在当前动作上使用模式匹配，并使用`ReasonReact.Update`返回一个新状态：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To help keep your ReasonReact apps ready for the coming ReactJS Fiber release,
    ensure that everything in `reducer` is pure. One way to trigger side effects indirectly
    while keeping `reducer` pure is by using `ReasonReact.UpdateWithSideEffects`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您的ReasonReact应用程序为即将到来的ReactJS Fiber发布做好准备，确保`减速器`中的一切都是纯的。间接触发副作用的一种方法是使用`ReasonReact.UpdateWithSideEffects`：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The return value of `reducer` must be one of the following variant constructors:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`减速器`的返回值必须是以下变体构造函数之一：'
- en: '`ReasonReact.NoUpdate`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReasonReact.NoUpdate`'
- en: '`ReasonReact.Update(state)`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReasonReact.Update(state)`'
- en: '`ReasonReact.SideEffects(self => unit)`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReasonReact.SideEffects(self => unit)`'
- en: '`ReasonReact.UpdateWithSideEffects(state, self => unit)`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “ReasonReact.UpdateWithSideEffects(state, self => unit)”
- en: 'We can trigger new actions from within our side effects, since we''re again
    provided with `self`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从我们的副作用中触发新的动作，因为我们再次提供了“self”：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After incrementing, the `reducer` triggers a side-effect that triggers the `Decrement`
    action after one second.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 增加后，`减速器`触发一个副作用，在一秒后触发“减量”动作。
- en: Refactoring
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: 'Let''s imagine we now need our stateful component to display a message that
    congratulates the user when they get to a count of 10, and once the message is
    displayed, the user can close the message by clicking a close button. Thanks to
    our helpful compiler, we can follow these steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想象我们现在需要我们的有状态组件在计数达到10时显示一条祝贺用户的消息，一旦消息显示出来，用户可以通过点击关闭按钮关闭消息。多亏了我们乐于助人的编译器，我们可以按照以下步骤进行操作：
- en: Update the shape of `state`
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`state`的形状
- en: Update the available `actions`
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新可用的`动作`
- en: Step through the compiler errors
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编译器错误进行步骤
- en: Update the `render` function
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`render`函数
- en: 'The compiler messages will remind us to update the component''s initial state
    and reducer. Since we now need to also keep track of whether or not to display
    a message, let''s change the shape of `state` to this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器消息将提醒我们更新组件的初始状态和减速器。由于我们现在还需要跟踪是否显示消息，让我们将`state`的形状更改为这样：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For our actions, let''s combine `Increment` and `Decrement` into one constructor
    that accepts an `int`, and we''ll have a new constructor to toggle the message:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的动作，让我们将`增量`和`减量`合并为一个接受`int`的构造函数，我们将有一个新的构造函数来切换消息：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, instead of `Increment` and `Decrement`, we have `UpdateCount`, which holds
    an integer representing the amount to change the current count by.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再有`增量`和`减量`，而是有`UpdateCount`，它包含一个表示当前计数变化量的整数。
- en: 'After compiling, we see a friendly error letting us know that our previous
    action `Decrement` cannot be found:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，我们看到一个友好的错误提示，告诉我们之前的“减量”动作找不到：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `render` function, replace  `Increment`  with `UpdateCount(+1)` and
    `Decrement` with `UpdateCount(-1)`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`render`函数中，用`UpdateCount(+1)`替换`增量`，用`UpdateCount(-1)`替换`减量`：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Compiling again, we''re informed that in our reducer, `Increment` does not
    belong to type `action`. Let''s update our reducer to handle both `UpdateCount`
    and `ToggleMessage`. If we were to forget a constructor, the compiler would let
    us know that the switch expression in the reducer is not exhaustive:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 再次编译，我们被告知在我们的减速器中，`增量`不属于类型`动作`。让我们更新我们的减速器来处理`UpdateCount`和`ToggleMessage`。如果我们忘记了一个构造函数，编译器会让我们知道减速器中的switch表达式不是穷尽的：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There are few things to mention regarding the preceding code snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的代码片段，有几件事情需要提到：
- en: In `UpdateCount`, we're declaring a binding `count` that reflects the new count.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`UpdateCount`中，我们声明了一个反映新计数的绑定`count`。
- en: We're using `...` to override just a portion of the state record.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用“...”来覆盖状态记录的一部分。
- en: 'Thanks to record punning support, we can write `{...state, count}` instead
    of `{...state, count: count}`.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '多亏了记录标点符号的支持，我们可以写`{...state, count}`而不是`{...state, count: count}`。'
- en: '`UpdateCount` is using `UpdateWithSideEffects` to trigger a `ToggleMessage`
    action when the count reaches 10; we could have instead done this:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “UpdateCount”正在使用“UpdateWithSideEffects”触发一个“ToggleMessage”动作，当计数达到10时；我们也可以这样做：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: I prefer using `UpdateWithSideEffects` so that `UpdateCount` only ever has to
    worry about its count field, and if some other field needs to get updated, `UpdateCount`
    can trigger the right action for that to happen, without needing to know how it
    needs to happen.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢使用`UpdateWithSideEffects`，这样`UpdateCount`只需要关心它的计数字段，如果需要更新其他字段，`UpdateCount`可以触发正确的操作，而不需要知道如何发生。
- en: 'After compiling here, we get an interesting compiler error:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里编译后，我们得到一个有趣的编译器错误：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The compiler sees `state` in `state.count` on line 18 (shown previously) as
    having type `int` instead of type `state`. This is because our render function
    is using `string_of_int(self.state)` instead of `string_of_int(self.state.count)`.
    After updating our render function to reflect this, we get another similar message
    complaining that type `int` and type `state` are incompatible. That's because
    our initial state is still returning `0` instead of a record of type `state`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在第18行（之前显示）的`state.count`中看到`state`，将其视为`int`类型而不是`state`类型。这是因为我们的渲染函数使用`string_of_int(self.state)`而不是`string_of_int(self.state.count)`。在更新我们的渲染函数以反映这一点后，我们得到另一个类似的消息，抱怨类型`int`和类型`state`不兼容。这是因为我们的初始状态仍然返回`0`而不是`state`类型的记录。
- en: 'After updating initial state, the code finally compiles successfully:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 更新初始状态后，代码最终成功编译：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we''re ready to update the render function to display a message when the
    count reaches 10:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备更新渲染函数，在计数达到10时显示消息：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Since `if/else` is an expression in Reason, we can use it within JSX to either
    render markup or `ReasonReact.null` (which has type `ReasonReact.reactElement`).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`if/else`在Reason中是一个表达式，我们可以在JSX中使用它来渲染标记或`ReasonReact.null`（类型为`ReasonReact.reactElement`）。
- en: Instance variables
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例变量
- en: Although our example correctly shows the message when count reaches 10 for the
    first time, there is nothing preventing our `ToggleMessage` action from getting
    fired again within the `UpdateCount` case in the reducer. If a user gets to 10,
    then decrements and then increments, the message is toggled again. To ensure that
    `UpdateCount` only ever triggers the `ToggleMessage` action once, we can use an
    **instance variable** in state.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的示例在第一次计数达到10时正确显示消息，但没有阻止我们的`ToggleMessage`操作在`reducer`中的`UpdateCount`情况下再次触发。如果用户达到10，然后递减然后递增，消息将再次切换。为了确保`UpdateCount`只触发一次`ToggleMessage`操作，我们可以在状态中使用**实例变量**。
- en: In ReactJS, every time something in state changes, the component gets re-rendered.
    In ReasonReact, instance variables never trigger a re-render, and can be correctly
    placed within a component's state.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在ReactJS中，每当状态发生变化时，组件都会重新渲染。在ReasonReact中，实例变量永远不会触发重新渲染，并且可以正确地放置在组件的状态中。
- en: 'Let''s add an instance variable to keep track of whether the user has already
    seen the message:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个实例变量来跟踪用户是否已经看到消息：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Ref and mutable records
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ref和可变记录
- en: The difference between ReasonReact instance variables and normal state variables
    is the use of `ref`. Previously, we saw that `state.userHasSeenMessage` is of
    type `ref(bool)` instead of `bool`. That makes `state.userHasSeenMessage` an instance
    variable.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ReasonReact实例变量和普通状态变量之间的区别在于使用`ref`。之前，我们看到`state.userHasSeenMessage`的类型是`ref(bool)`而不是`bool`。这使得`state.userHasSeenMessage`成为一个实例变量。
- en: Since `ref` is just syntactic sugar for a record type with a mutable field,
    let's first discuss mutable record fields.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ref`只是具有可变字段的记录类型的语法糖，让我们首先讨论可变记录字段。
- en: 'To allow a record field to be mutable, prefix the field''s name with `mutable`.
    Then, those fields can be updated in place using the `=` operator:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许记录字段可变，需要在字段名称前加上`mutable`。然后，可以使用`=`运算符就地更新这些字段：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'However, the type declaration is already included in Reason''s standard library,
    so we can omit it, and the rest of the preceding code would still work, declaring
    it shadowed the original type declaration. We can prove this by shadowing the
    `ref` type with an immutable record:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类型声明已经包含在Reason的标准库中，所以我们可以省略它，前面的代码的其余部分仍然可以工作，声明它会遮蔽原始类型声明。我们可以通过用不可变记录遮蔽`ref`类型来证明这一点：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The compiler fails with the following error:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器出现以下错误：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In addition to having a built-in type definition, `ref` also has some built-in
    functions. Namely, `ref` is used to create a record of type `ref`, and `^` is
    used to get the contents of a `ref`, and `:=` is used to set the contents of a
    ref:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了具有内置的类型定义之外，`ref`还具有一些内置函数。即`ref`用于创建类型为`ref`的记录，`^`用于获取`ref`的内容，`:=`用于设置`ref`的内容：
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s go back to our ReasonReact example, and let''s use our new `userHasSeenMessage`
    instance variable. After updating the shape of our state, we need to also update
    the component''s initial state:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的ReasonReact示例，让我们使用我们的新的`userHasSeenMessage`实例变量。在更新状态的形状之后，我们还需要更新组件的初始状态：
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, our code again compiles, and we can update `reducer` to use this instance
    variable:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的代码再次编译，我们可以更新`reducer`以使用这个实例变量：
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, the message is correctly displayed once and only once.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，消息被正确显示一次。
- en: Navigation menu
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航菜单
- en: Let's use what we've learned so far as a foundation to build upon while creating
    an application with a navigation menu and client-side routing. On touch devices,
    users will be able to swipe to close the menu, and the menu will respond in real
    time to the user's touch. If the user swipes the menu when it's more than 50%
    closed and then releases, the menu will close; otherwise, it will remain open.
    The one exception is if the user swipes the menu closed with a high enough velocity;
    it will always close.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们迄今为止学到的东西作为基础，创建一个具有导航菜单和客户端路由的应用程序。在触摸设备上，用户将能够滑动关闭菜单，并且菜单将实时响应用户的触摸。如果用户在菜单关闭超过50%时滑动然后释放，菜单将关闭；否则，它将保持打开状态。唯一的例外是，如果用户以足够高的速度关闭菜单，它将始终关闭。
- en: 'We will be working with this application throughout the rest of the book. To
    follow along, clone the GitHub repo and navigate to the directory representing
    the start of this chapter:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的其余部分中使用这个应用程序。要跟随，克隆GitHub存储库并导航到代表本章开头的目录：
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s take a moment to see what we have to work with. You will see the following
    directory structure:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间看看我们要处理的内容。您将看到以下目录结构：
- en: '[PRE48]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Our `bsconfig.json` is set up to place compiled `.bs.js` files within `lib/es6/src`, and
    we've configured webpack to look for `lib/es6/src/Index.bs.js` as an entry point.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`bsconfig.json`设置为将编译后的`.bs.js`文件放在`lib/es6/src`中，并且我们已经配置webpack来查找`lib/es6/src/Index.bs.js`作为入口点。
- en: Run `npm install` and then `npm start` to serve our app at `http://localhost:3000` with
    both bsb and webpack in watch mode.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`npm install`，然后运行`npm start`，以在监视模式下使用bsb和webpack为我们的应用提供服务，地址为`http://localhost:3000`。
- en: Currently, our app displays a blue navigation bar with a hamburger icon. Clicking
    on the icon opens a menu and clicking outside the menu closes it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序显示一个带有汉堡图标的蓝色导航栏。单击图标会打开菜单，单击菜单外部会关闭菜单。
- en: 'In `App.re`, our state is currently a single field record that keeps track
    of the menu''s state:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在`App.re`中，我们的状态目前是一个单字段记录，用于跟踪菜单的状态：
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We have one action:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个动作：
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And our reducer takes care of updating the menu''s state:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的reducer负责更新菜单的状态：
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Although Reason supports record punning, it does not work for single field records,
    since Reason treats `{isOpen}` as a block instead of a record.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Reason支持记录pun，但对于单字段记录，它不起作用，因为Reason将`{isOpen}`视为块而不是记录。
- en: 'Our render function renders a `<div />` element with a conditional class name
    depending on the current state:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的渲染函数渲染一个带有条件类名的`<div />`元素，具体取决于当前状态：
- en: '[PRE52]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`App.scss` uses the `overlay` class to display a dark overlay behind the navigation
    menu only when it''s open:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.scss`使用`overlay`类来在导航菜单打开时只显示一个深色叠加层：'
- en: '[PRE53]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice how the `transition` property is defined for both  `.App:after`  and  `.App.overly:after`,
    the former includes a transition on the `transform` property with a `450ms` delay
    while the latter removes that transition. This has the effect of allowing a smooth
    transition even when the menu is closed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`transition`属性是如何为`.App:after`和`.App.overly:after`定义的，前者包括对`transform`属性的`450ms`延迟的过渡，而后者则移除了该过渡。这样做的效果是即使菜单关闭，也能实现平滑的过渡。
- en: Bindings
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定
- en: 'Let''s inspect the binding to JavaScript''s `require` function at the top of `App.re`. Since
    we''re going to dive deeper into BuckleScript in [Chapter 4](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml),
    *BuckleScript, Belt, and Interoperability*, let''s defer discussing the details
    and just briefly see what this binding is doing:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`App.re`顶部对JavaScript的`require`函数的绑定。由于我们将在[第4章](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml)中深入研究BuckleScript，*BuckleScript，Belt和互操作性*，让我们推迟讨论细节，只简要看一下这个绑定在做什么：
- en: '[PRE54]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `external` keyword creates a new binding, similar to the `let` keyword.
    After binding to JavaScript''s `require` function, we can use it in Reason, as
    long as we''re using the BuckleScript compiler. We use it to require `App.scss`
    as well as a few images. Inspecting the compiled output at `lib/es6/src/App.bs.js`
    shows that the preceding Reason code compiles to the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`external`关键字创建一个新的绑定，类似于`let`关键字。绑定到JavaScript的`require`函数后，只要我们使用BuckleScript编译器，就可以在Reason中使用它。我们用它来要求`App.scss`以及一些图片。检查编译输出`lib/es6/src/App.bs.js`显示，前面的Reason代码编译为以下内容：'
- en: '[PRE55]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Webpack handles the rest from there.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack会处理剩下的事情。
- en: Events
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: Since the top-level `<div />` element has a click event handler that always
    closes the menu, any clicks on its children also fire that top-level click event
    handler. To allow the menu to open (or remain open), we need to call `event.stopPropagation()`
    on click events for some of its child elements.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于顶层`<div />`元素有一个点击事件处理程序，总是关闭菜单，其子元素的任何点击也会触发该顶层点击事件处理程序。为了允许菜单打开（或保持打开），我们需要在某些子元素的点击事件上调用`event.stopPropagation()`。
- en: 'In ReasonReact, we can do this with the `ReactEvent` module:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在ReasonReact中，我们可以使用`ReactEvent`模块来实现这一点：
- en: '[PRE56]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `ReactEvent` module has submodules corresponding to each of ReactJS''s
    synthetic events:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReactEvent`模块有子模块对应于ReactJS的合成事件的每一个：'
- en: Clipboard events
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剪贴板事件
- en: Composition events
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合事件
- en: Keyboard events
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘事件
- en: Focus events
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 焦点事件
- en: Form events
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单事件
- en: Mouse events
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标事件
- en: Pointer events
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针事件
- en: Selection events
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择事件
- en: Touch events
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸事件
- en: UI events
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI事件
- en: Wheel events
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚轮事件
- en: Media events
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体事件
- en: Image events
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像事件
- en: Animation events
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画事件
- en: Transition events
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过渡事件
- en: For more information on ReactJS's synthetic events, visit [https://reactjs.org/docs/events.html](https://reactjs.org/docs/events.html).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有关ReactJS合成事件的更多信息，请访问[https://reactjs.org/docs/events.html](https://reactjs.org/docs/events.html)。
- en: To get values such as `event.changedTouches.item(0).clientX` from a touch event,
    we use a combination of ReasonReact and BuckleScript.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要从触摸事件中获取诸如`event.changedTouches.item(0).clientX`之类的值，我们使用ReasonReact和BuckleScript的组合。
- en: Js.t Object
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Js.t对象
- en: BuckleScript allows us to access arbitrary JavaScript object fields using the
    `##` syntax. We can use syntax on any `Js.t` type, which is a Reason type for
    arbitrary JavaScript objects. We'll learn more about this and other interoperability
    features in [Chapter 4](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml), *BuckleScript,
    Belt, and Interoperability*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: BuckleScript允许我们使用`##`语法访问任意JavaScript对象字段。我们可以在任何`Js.t`类型上使用语法，这是一个用于任意JavaScript对象的Reason类型。我们将在[第4章](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml)中了解更多关于这个和其他互操作特性的信息，*BuckleScript，Belt和互操作性*。
- en: 'Since `ReactEvent.Touch.changedTouches(event)` returns a plain old JavaScript
    object, we can access its fields using the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ReactEvent.Touch.changedTouches(event)`返回一个普通的JavaScript对象，我们可以使用以下方法访问其字段：
- en: '[PRE57]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Looking in the compiled output, we see that it is what we want:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 查看编译输出，我们看到这就是我们想要的：
- en: '[PRE58]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We'll use this to add the touch feature to our menu so that users can swipe
    the menu closed and see the menu move as they swipe.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个来为我们的菜单添加触摸功能，以便用户可以滑动菜单关闭并在滑动时看到菜单移动。
- en: Adding actions
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加动作
- en: 'Let''s start by adding actions for `TouchStart`, `TouchMove`, and `TouchEnd`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先为`TouchStart`、`TouchMove`和`TouchEnd`添加操作：
- en: '[PRE59]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We'll need the touch event's `clientX` property only for `TouchStart` and `TouchMove`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要`TouchStart`和`TouchMove`的触摸事件的`clientX`属性。
- en: 'Let''s add the event listeners on the top-level `<div />` component:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在顶层`<div />`组件上添加事件监听器：
- en: '[PRE60]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In our reducer, let''s just log those `clientX` values for now:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的reducer中，暂时只记录那些`clientX`值：
- en: '[PRE61]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: To figure out the overall direction of a user's swipe, we need the first and
    last `clientX` values for that swipe. The menu should move in proportion to the
    difference of the first and last `clientX` values, but only if the user is swiping
    in the direction that would close the menu.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出用户滑动的整体方向，我们需要该滑动的第一个和最后一个`clientX`值。菜单应该按照第一个和最后一个`clientX`值的差值移动，但只有在用户滑动的方向会关闭菜单的情况下才移动。
- en: 'Our state now includes a `touches` record that holds the value for the first
    and last `clientX` values:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的状态现在包括一个`touches`记录，其中包含第一个和最后一个`clientX`值的值：
- en: '[PRE62]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Since we cannot nest record type definitions, we define the `touches` type separately
    and include it in `state`. You'll notice `state.touches.first` is of type `option(float)`
    because it's possible that the user isn't using a touch device or that the user
    hasn't yet interacted.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不能嵌套记录类型定义，我们单独定义`touches`类型，并将其包含在`state`中。您会注意到`state.touches.first`的类型是`option(float)`，因为用户可能没有使用触摸设备，或者用户尚未进行交互。
- en: 'Changing the shape of our state requires us to also change the initial state:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 改变我们状态的形状需要我们同时改变初始状态：
- en: '[PRE63]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the reducer, if the menu is open, we update `state.touches` with a fresh
    new record in the `TouchStart` case, but in the `TouchMove` case, we only update
    `state.touches.last`. If the menu is not currently open, `ReasonReact.NoUpdate` is
    returned:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在reducer中，如果菜单是打开的，我们在`TouchStart`情况下使用一个新的记录更新`state.touches`，但在`TouchMove`情况下，我们只更新`state.touches.last`。如果菜单当前没有打开，将返回`ReasonReact.NoUpdate`：
- en: '[PRE64]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We'll soon use this state to conditionally set an inline style on the `<nav
    />` element.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快将使用这个状态来有条件地在`<nav />`元素上设置内联样式。
- en: Inline styles
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联样式
- en: 'In ReasonReact, we can add inline styles via `ReactDOMRe.Style.make`, which
    accepts CSS properties as optional labelled arguments. Since they are all optional,
    passing `unit` is necessary to call the function:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在ReasonReact中，我们可以通过`ReactDOMRe.Style.make`添加内联样式，它接受CSS属性作为可选的标记参数。由于它们都是可选的，传递`unit`是调用该函数所必需的：
- en: '[PRE65]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Applying this to our `<nav />` element, we can conditionally add a style if
    we have both a first and last touch in state:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个应用到我们的`<nav />`元素上，我们可以根据状态中是否有第一个和最后一个触摸来有条件地添加样式：
- en: '[PRE66]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Within the `transform` property, we concatenate with `"0px"` instead of just
    `"px"` since the `float` type always includes a decimal point, but it''s possible
    that the user swipes a distance of exactly one hundred pixels, and `transform:
    translateX(100.px)` is not valid CSS, but `transform: translateX(100.0px)` is.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '在`transform`属性中，我们使用`"0px"`进行连接，而不仅仅是`"px"`，因为`float`类型总是包含小数点，但可能用户滑动的距离恰好是一百像素，`transform:
    translateX(100.px)`不是有效的CSS，但`transform: translateX(100.0px)`是。'
- en: 'Running this on a touch device shows that we''re able to get the menu''s position
    to change based on the user''s swipe. Now, let''s focus on the `TouchEnd` case
    within the reducer. For now, let''s set the menu to remain open if the user swipes
    the menu less than half way closed, and close it otherwise. If `state.touches.last` is `None`,
    then the user did not swipe, and we don''t update `state`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在触摸设备上运行这个程序，我们能够根据用户的滑动来改变菜单的位置。现在，让我们专注于reducer中的`TouchEnd`情况。暂时，如果用户将菜单滑动关闭不到一半，我们将设置菜单保持打开状态，否则关闭。如果`state.touches.last`是`None`，那么用户没有滑动，我们不更新`state`：
- en: '[PRE67]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Notice that we reset `state.touches` to a fresh new record with `{first: None,
    last: None}`, which results in an empty style prop on the `<nav />` element.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，我们将`state.touches`重置为一个新的记录，其中包含`{first: None, last: None}`，这将导致`<nav />`元素上的样式属性为空。'
- en: This current implementation assumes that the width of the navigation is `300px`.
    Instead of assuming, we can use a React ref to get a reference to the DOM node,
    and then get its `clientWidth`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的实现假设导航的宽度为`300px`。我们可以使用React ref来获取对DOM节点的引用，然后获取它的`clientWidth`，而不是假设宽度。
- en: React ref
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React ref
- en: 'The React ref is just an instance variable of `state`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: React ref只是`state`的一个实例变量：
- en: '[PRE68]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We attach the React ref on the `<nav />` element by setting the `ref` property
    to the result of `self.handle((ref, self) => ...)`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将`ref`属性设置为`self.handle((ref, self) => ...)`的结果来在`<nav />`元素上附加React ref：
- en: '[PRE69]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Since a React ref could be `null` in JavaScript, we convert it to an option
    and pattern match on its value.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在JavaScript中，React ref可能为`null`，我们将其转换为一个选项，并对其值进行模式匹配。
- en: The type of the React ref depends on whether it is a DOM element or a React
    component. The former's type is `Dom.element`, and the latter's is `ReasonReact.reactRef`.
    To convert a `ReasonReact.reactRef` to a JavaScript object, use `ReasonReact.refToJsObj`
    instead of `ReactDOMRe.domElementToObj`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: React ref的类型取决于它是DOM元素还是React组件。前者的类型是`Dom.element`，后者的类型是`ReasonReact.reactRef`。要将`ReasonReact.reactRef`转换为JavaScript对象，使用`ReasonReact.refToJsObj`而不是`ReactDOMRe.domElementToObj`。
- en: Then, in the reducer, we can use `state.width` instead of `300.0` as the menu's
    width. Since the `TouchStart` and `TouchMove` actions always update state when
    the menu is open, the `<App />` component is always re-rendered, which causes
    our React ref function to re-run, and we can be reasonably sure that the menu's
    width is always correct.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在reducer中，我们可以使用`state.width`代替`300.0`作为菜单的宽度。由于`TouchStart`和`TouchMove`操作总是在菜单打开时更新状态，`<App
    />`组件总是重新渲染，这导致我们的React ref函数重新运行，我们可以合理地确定菜单的宽度始终是正确的。
- en: Velocity
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 速度
- en: 'To get the velocity of a user''s swipe, we''ll need to also store the current
    time along with the touch event''s `clientX`. Let''s bind to the browser''s `performance.now()`
    method:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得用户滑动的速度，我们还需要存储当前时间以及触摸事件的`clientX`。让我们绑定到浏览器的`performance.now()`方法：
- en: '[PRE70]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'And we''ll make some room for the touch''s current time in the `touches` type:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在`touches`类型中为触摸的当前时间腾出一些空间：
- en: '[PRE71]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In the reducer, we then change `Some(clientX)` to `Some((clientX, now()))`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在减速器中，我们将`Some(clientX)`更改为`Some((clientX, now()))`。
- en: 'Now, we can calculate the velocity of a user''s swipe in the `TouchEnd` case:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以计算用户在`TouchEnd`情况下的滑动速度：
- en: '[PRE72]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: A velocity of `-0.3` pixels per millisecond feels right to me, but feel free
    to use whatever feels right for you.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得每毫秒-0.3像素的速度对我来说感觉不错，但是随意使用任何对你来说感觉正确的值。
- en: Notice how we can use pattern matching to destructure `(x, t)`, which creates
    two bindings in scope. Also, `x'` is a valid name for a binding in Reason and
    is commonly pronounced *x prime*. Lastly, notice how our state is shadowed to
    prevent writing duplicate code.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以使用模式匹配来解构`(x, t)`，这会在作用域中创建两个绑定。此外，`x'`是Reason中有效的绑定名称，通常发音为*x prime*。最后，请注意我们的状态被遮蔽以防止编写重复的代码。
- en: 'To finish the velocity feature, we update the `style` property in the render
    function to treat both `state.touches.first` and `state.touches.last` as tuples:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成速度功能，我们在渲染函数中更新`style`属性，以将`state.touches.first`和`state.touches.last`都视为元组：
- en: '[PRE73]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now, when open, the menu responds nicely to a touch—super cool!
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开菜单时，菜单对触摸作出了很好的响应-非常酷！
- en: Client-side routing
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端路由
- en: 'ReasonReact comes with a built-in router found in the `ReasonReact.Router`
    module. It is quite unopinionated and therefore flexible. The public API has only
    four functions:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ReasonReact附带了一个内置路由器，位于`ReasonReact.Router`模块中。它非常不具有偏见，因此非常灵活。公共API只有四个函数：
- en: '`ReasonReact.Router.watchUrl: (url => unit) => watcherID`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReasonReact.Router.watchUrl: (url => unit) => watcherID`'
- en: '`ReasonReact.Router.unwatchUrl: watcherID => unit`'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReasonReact.Router.unwatchUrl: watcherID => unit`'
- en: '`ReasonReact.Router.push: string => unit`'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReasonReact.Router.push: string => unit`'
- en: '`ReasonReact.Router.dangerouslyGetInitialUrl: unit => url`'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReasonReact.Router.dangerouslyGetInitialUrl: unit => url`'
- en: The `watchUrl` function starts watching the URL for changes. When changed, the
    `url => unit` callback is called. The `unwatchUrl` function stops watching the
    URL.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`watchUrl`函数开始监视URL的更改。更改后，将调用`url => unit`回调函数。`unwatchUrl`函数停止监视URL。'
- en: The `push` function sets the URL, and the `dangerouslyGetInitialUrl` function
    gets a record of type `url`. The `dangerouslyGetInitialUrl` function is meant
    to be used only within the `didMount` lifecycle hook, alongside `watchUrl`, to
    prevent issues with stale information.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`push`函数设置URL，`dangerouslyGetInitialUrl`函数获取`url`类型的记录。`dangerouslyGetInitialUrl`函数仅在`didMount`生命周期钩子中使用，与`watchUrl`一起使用，以防止陈旧信息的问题。'
- en: 'The `url` type is defined as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`url`类型定义如下：'
- en: '[PRE74]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We'll learn more about the `list` type constructor in [Chapter 4](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml),
    *BuckleScript, Belt, and Interoperability*. The `path` field in the `url` record
    is of type `list(string)`. If the value of `window.location.pathname` is `"/book/title/edit"`,
    the value of `url.path` will be `["book", "title", "edit"]`, which is a list of
    strings. The syntax makes it look like a JavaScript array, but there are some
    differences. Briefly, Reason lists are singly linked lists that are immutable
    and homogeneous, meaning all elements must be of the same type.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第4章](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml)中学习更多关于`list`类型构造函数的知识，*BuckleScript，Belt和互操作性*。`url`记录中的`path`字段是`list(string)`类型。如果`window.location.pathname`的值是`"/book/title/edit"`，那么`url.path`的值将是`["book",
    "title", "edit"]`，这是一个字符串列表。语法使它看起来像JavaScript数组，但有一些区别。简而言之，Reason列表是不可变的同构单链表，意味着所有元素必须是相同类型的。
- en: The `watcherID` type is an **abstract type**. We'll learn more about abstract
    types in [Chapter 6](a6ac6581-d3bd-49f3-ad4d-bfed965287ca.xhtml),  *CSS-in-JS
    (in Reason)*. The only way to get a value of type `watcherID` is as the return
    value of `ReasonReact.Router.watchUrl`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`watcherID`类型是一个**抽象类型**。我们将在[第6章](a6ac6581-d3bd-49f3-ad4d-bfed965287ca.xhtml)中学习更多关于抽象类型的知识，*CSS-in-JS（在Reason中）*。获取`watcherID`类型的值的唯一方法是作为`ReasonReact.Router.watchUrl`的返回值。'
- en: Let's create a router component that wraps our `<App />` component and provides
    it with a `currentRoute` prop. What follows was inspired by an example from Khoa
    Nguyen (`@thangngoc89`).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个路由器组件，它包装我们的`<App />`组件并为其提供`currentRoute`属性。以下内容受到了Khoa Nguyen（`@thangngoc89`）示例的启发。
- en: 'First, let''s create placeholder components for `<Home />`, `<Page1 />`, `<Page2
    />`, and `<Page3 />`. Then, within `Router.re`, let''s create a type that represents
    a route along with a list of routes:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为`<Home />`，`<Page1 />`，`<Page2 />`和`<Page3 />`创建占位符组件。然后，在`Router.re`中，让我们创建一个表示路由的类型以及路由列表：
- en: '[PRE75]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Each route has an `href`, `title`, and an associated `component`, which will
    be rendered within `<App />` if that route is the current route.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 每个路由都有一个`href`，`title`和一个相关的`component`，如果该路由是当前路由，则将在`<App />`中呈现。
- en: Current route
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当前路由
- en: 'In `Index.re`, let''s wrap `<App />` within a router component that provides
    the `currentRoute` prop:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Index.re`中，让我们在路由器组件中包装`<App />`，并提供`currentRoute`属性：
- en: '[PRE76]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In `Router.re`, we define three components—`<WithRouter />`, `<Link />`, and
    `<NavLink />`—using the `module` syntax. Since each file is also a module, those
    three components are nested under the `Router` module, and in `Index.re` we need
    to tell the compiler to look for `<WithRouter />` within the `Router` module:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Router.re`中，我们使用`module`语法定义了三个组件-`<WithRouter />`，`<Link />`和`<NavLink />`。由于每个文件也是一个模块，这三个组件嵌套在`Router`模块下，在`Index.re`中，我们需要告诉编译器在`Router`模块中查找`<WithRouter
    />`：
- en: '[PRE77]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We've seen all of these concepts before. `<WithRouter />` is just a reducer
    component. The component's state is the same route type defined earlier and there
    is only one action to change the route. Once `<WithRouter />` is mounted, `ReasonReact.Router`
    begins watching the URL, and whenever it changes, the `ChangeRoute` action is
    triggered, which calls the reducer, which then updates state, which then re-renders
    `<App />` with an updated `currentRoute` prop.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经见过所有这些概念。`<WithRouter />`只是一个减速器组件。组件的状态是之前定义的相同路由类型，只有一个操作可以更改路由。一旦`<WithRouter
    />`被挂载，`ReasonReact.Router`开始监视URL，每当URL更改时，就会触发`ChangeRoute`操作，这将调用减速器，然后更新状态，然后使用更新的`currentRoute`属性重新呈现`<App
    />`。
- en: 'To ensure that our menu closes whenever `<App />` receives a fresh `currentRoute`
    prop, we add a `willReceiveProps` lifecycle hook for `<App />`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保每当`<App />`接收到新的`currentRoute`属性时，我们都会关闭菜单，我们为`<App />`添加了一个`willReceiveProps`生命周期钩子：
- en: '[PRE78]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Helper functions
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 辅助函数
- en: 'Since `url.path` of `ReasonReact.Router` is a list of strings, and our `Router.route.href`
    is a string, we need a way to convert from string to a list of strings:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ReasonReact.Router`的`url.path`是一个字符串列表，而我们的`Router.route.href`是一个字符串，我们需要一种将字符串转换为字符串列表的方法：
- en: '[PRE79]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We'll discuss Reason's pipe operator (`|>`) and JavaScript interoperability in
    [Chapter 4](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml), *BuckleScript, Belt,
    and Interoperability*.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第4章](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml)中深入讨论Reason的管道运算符（`|>`）和JavaScript互操作性，*BuckleScript，Belt和互操作性*。
- en: 'We also need a way to convert a `url` to a `route` for use in initial state,
    as well as within the callback function of `watchUrl`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一种方法，将`url`转换为`route`，以便在初始状态和`watchUrl`的回调函数中使用：
- en: '[PRE80]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In [Chapter 4](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml), *BuckleScript, Belt,
    and Interoperability*, we will dive deeper into BuckleScript, Belt, and JavaScript
    interoperability. The `urlToRoute` function tries to find a `route` within the
    `routes` list whose `url.path` is structurally equal to `route.href` after it's
    converted to a list of strings.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml)中，*BuckleScript，Belt和互操作性*，我们将更深入地了解BuckleScript、Belt和JavaScript互操作性。`urlToRoute`函数尝试在将其转换为字符串列表后，找到`routes`列表中`url.path`在结构上等于`route.href`的`route`。
- en: If no such `route` exists, it returns the first `route` from the `routes` list,
    which is the one associated with the `<Home />` component. Otherwise, the matching
    `route` is returned.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在这样的`route`，它将返回`routes`列表中的第一个`route`，这是与`<Home />`组件相关联的`route`。否则，将返回匹配的`route`。
- en: 'The `<Link />` component is a simple stateless component that renders an anchor
    link. Note how the click handler prevents the default browser behavior and updates
    the URL:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`<Link />`组件是一个简单的无状态组件，它呈现一个锚链接。请注意，单击处理程序会阻止默认的浏览器行为并更新URL：'
- en: '[PRE81]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `<NavLink />` component wraps the `<Link />` component, and is provided
    with the current route as a prop that it uses to conditionally set an `active`
    class:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`<NavLink />`组件包装了`<Link />`组件，并提供了当前路由作为属性，它用于有条件地设置`active`类：'
- en: '[PRE82]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Usage
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用法
- en: 'Now that we''ve defined the router, we can rewrite our navigation menu links
    to use the `<NavLink />` component instead of the raw anchor link directly:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了路由器，我们可以重写我们的导航菜单链接，使用`<NavLink />`组件而不是直接使用原始锚链接：
- en: '[PRE83]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Wherever we want to display the current page''s title, we can simply access
    the `title` field on the current route:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们想要显示当前页面的标题，我们都可以简单地访问当前`route`上的`title`字段：
- en: '[PRE84]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'And, we can render a route''s associated component in a similar way:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，我们可以以类似的方式呈现路由的相关组件：
- en: '[PRE85]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: It's important to emphasize that ReasonReact's router does not dictate what
    the callback of `watchUrl` should do. In our case, we trigger an action that updates
    the current route, which is just an arbitrary record. It's completely reasonable
    for the route type to be something entirely different. Also, there is no law that
    says the router should be the top-level component. There is a lot of room for
    creativity here and I'm personally excited to see what the community comes up
    with.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要强调ReasonReact的路由器不会规定`watchUrl`的回调函数应该做什么。在我们的情况下，我们触发一个更新当前路由的动作，这只是一个任意的记录。路由类型完全可以是完全不同的东西。而且，并没有规定路由器应该是顶级组件的法律。在这里有很多创造性的空间，我个人很期待看到社区会有什么想法。
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how ReasonReact is a simpler, safer way to build React
    components. Having Reason's type system enforcing correct component usage at compile
    time is a huge win. Also, it makes refactoring safer, cheaper, and a much more
    pleasant experience. ReasonReact is *just* Reason, much like how ReactJS is *just*
    JavaScript. All of what we've done so far is just Reason and ReasonReact without
    any third-party libraries such as Redux or React Router.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到ReasonReact是构建React组件的一种更简单、更安全的方式。在编译时，Reason的类型系统强制执行正确的组件使用是一个巨大的胜利。此外，它使重构更安全、更便宜，也更愉快。ReasonReact
    *只是* Reason，就像ReactJS *只是* JavaScript一样。到目前为止，我们所做的一切都只是Reason和ReasonReact，没有任何第三方库，比如Redux或React
    Router。
- en: As we'll see in [Chapter 4](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml), *BuckleScript,
    Belt, and Interoperability*, we also have the option to use existing JavaScript
    (and ReactJS) solutions within Reason. After getting more comfortable with BuckleScript,
    the Belt standard library, and JavaScript interoperability, we'll add route transitions.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在[第4章](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml)中看到的，*BuckleScript，Belt和互操作性*，我们还可以选择在Reason中使用现有的JavaScript（和ReactJS）解决方案。熟悉了BuckleScript、Belt标准库和JavaScript互操作性后，我们将添加路由转换。

["```js\ngit clone https://github.com/PacktPublishing/ReasonML-Quick-Start-Guide.git\ncd ReasonML-Quick-Start-Guide\ncd Chapter05/app-start\nnpm install\n```", "```js\n/* Foo.re */\nlet foo = \"foo\";\n\n/* Foo.rei */\nlet foo: string;\n\n/* Bar.re */\nJs.log(Foo.foo);\n```", "```js\n/* Foo.rei */\n/* this is intentionally empty */\n\n/* Bar.re */\nJs.log(Foo.foo); /* Compilation error: The value foo can't be found in Foo */\n```", "```js\n/* Foo.re */\nlet foo = \"foo\";\n\n/* Foo.rei */\nlet foo: string;\nlet bar: string;\n```", "```js\nThe implementation src/Foo.re does not match the interface src/Foo.rei:\nThe value `bar' is required but not provided\n```", "```js\nmodule type FooT {\n  let foo: (~a: int, ~b: int) => int;\n};\n\nmodule Foo: FooT {\n  let foo = (~a, ~b) => a + b;\n};\n```", "```js\nmodule Bar: FooT {\n  let bar = (~a, ~b) => a - b;\n};\n```", "```js\n/* Foo.re */\ntype person = {\n  firstName: string,\n  lastName: string\n};\n\n/* Foo.rei */\ntype person = {\n  firstName: string,\n  lastName: string\n};\n```", "```js\n/* Foo.rei */\ntype person;\n```", "```js\n/* Invoice.re */\ntype t = {\n  name: string,\n  email: string,\n  date: Js.Date.t,\n  total: float\n};\n\nlet make = (~name, ~email, ~date, ~total) => {\n  name,\n  email,\n  date,\n  total\n};\n```", "```js\n/* Email.re */\nlet send = invoice: Invoice.t => ...\nlet invoice =\n  Invoice.make(\n    ~name=\"Raphael\",\n    ~email=\"persianturtle@gmail.com\",\n    ~date=Js.Date.make(),\n    ~total=15.0,\n  );\nsend(invoice);\n```", "```js\n/* Email.re */\nlet invoice =\n  Invoice.make(\n    ~name=\"Raphael\",\n    ~email=\"persianturtle@gmail.com\",\n    ~date=Js.Date.make(),\n    ~total=15.0,\n  );\nlet invoice = {...invoice, total: invoice.total *. 0.8};\nJs.log(invoice);\n```", "```js\n/* Invoice.rei */\ntype t;\nlet make:\n (~name: string, ~email: string, ~date: Js.Date.t, ~total: float) => t;\n```", "```js\n8 \u2502 let invoice = {...invoice, total: invoice.total *. 0.8};\n9 \u2502 Js.log(invoice);\n\nThe record field total can't be found.\n```", "```js\n/* Invoice.re */\ntype t = {\n name: string,\n email: string,\n date: Js.Date.t,\n total: float,\n isDiscounted: bool,\n};\n\ntype discount =\n | Ten\n | Fifteen\n | Twenty;\n\nlet make = (~name, ~email, ~date, ~total) => {\n name,\n email,\n date,\n total,\n isDiscounted: false,\n};\n\nlet discount = (~invoice, ~discount) =>\n if (invoice.isDiscounted) {\n invoice;\n } else {\n {\n ...invoice,\n isDiscounted: true,\n total:\n invoice.total\n *. (\n switch (discount) {\n | Ten => 0.9\n | Fifteen => 0.85\n | Twenty => 0.8\n }\n ),\n };\n };\n\n/* Invoice.rei */\ntype t;\n\ntype discount =\n | Ten\n | Fifteen\n | Twenty;\n\nlet make:\n (~name: string, ~email: string, ~date: Js.Date.t, ~total: float) => t;\n\nlet discount: (~invoice: t, ~discount: discount) => t;\n\n/* Email.re */\nlet invoice =\n Invoice.make(\n ~name=\"Raphael\",\n ~email=\"persianturtle@gmail.com\",\n ~date=Js.Date.make(),\n ~total=15.0,\n );\nJs.log(invoice);\n```", "```js\n/* Invoice.re */\ntype t = (string, string, Js.Date.t, float, bool);\n\ntype discount =\n  | Ten\n  | Fifteen\n  | Twenty;\n\nlet make = (~name, ~email, ~date, ~total) => (\n  name,\n  email,\n  date,\n  total,\n  false,\n);\n\nlet discount = (~invoice, ~discount) => {\n  let (name, email, date, total, isDiscounted) = invoice;\n  if (isDiscounted) {\n    invoice;\n  } else {\n    (\n      name,\n      email,\n      date,\n      total\n      *. (\n        switch (discount) {\n        | Ten => 0.9\n        | Fifteen => 0.85\n        | Twenty => 0.8\n        }\n      ),\n      true,\n    );\n  };\n};\n\n/* Invoice.rei */\ntype t;\n\ntype discount =\n  | Ten\n  | Fifteen\n  | Twenty;\n\nlet make:\n  (~name: string, ~email: string, ~date: Js.Date.t, ~total: float) => t;\n\nlet discount: (~invoice: t, ~discount: discount) => t;\n\n/* Email.re */\nlet invoice =\n  Invoice.make(\n    ~name=\"Raphael\",\n    ~email=\"persianturtle@gmail.com\",\n    ~date=Js.Date.make(),\n    ~total=15.0,\n  );\nlet invoice = Invoice.(discount(~invoice, ~discount=Ten));\nJs.log(invoice);\n```", "```js\ntype option('a) =\n  | None\n  | Some('a);\n```", "```js\n/* Invoice.rei */\ntype t('a);\n\ntype discounted;\ntype undiscounted;\n\ntype discount =\n  | Ten\n  | Fifteen\n  | Twenty;\n\nlet make:\n  (~name: string, ~email: string, ~date: Js.Date.t, ~total: float) =>\n  t(undiscounted);\n\nlet discount:\n  (~invoice: t(undiscounted), ~discount: discount) => t(discounted);\n```", "```js\ntype discounted;\ntype undiscounted;\n```", "```js\nif (isDiscounted) {\n  ...\n} else {\n  ...\n}\n```", "```js\n/* Invoice.re */\ntype t('a) = {\n  name: string,\n  email: string,\n  date: Js.Date.t,\n  total: float,\n};\n\ntype discount =\n  | Ten\n  | Fifteen\n  | Twenty;\n\nlet make = (~name, ~email, ~date, ~total) => {name, email, date, total};\n\nlet discount = (~invoice, ~discount) => {\n  ...invoice,\n  total:\n    invoice.total\n    *. (\n      switch (discount) {\n      | Ten => 0.9\n      | Fifteen => 0.85\n      | Twenty => 0.8\n      }\n    ),\n};\n```", "```js\n/* Email.re */\nlet invoice =\n  Invoice.make(\n    ~name=\"Raphael\",\n    ~email=\"persianturtle@gmail.com\",\n    ~date=Js.Date.make(),\n    ~total=15.0,\n  );\nlet invoice = Invoice.(discount(~invoice, ~discount=Ten));\nlet invoice = Invoice.(discount(~invoice, ~discount=Ten)); /* discounted twice */\nJs.log(invoice);\n```", "```js\nWe've found a bug for you!\n\n   7 \u2502 );\n   8 \u2502 let invoice = Invoice.(discount(~invoice, ~discount=Ten));\n   9 \u2502 let invoice = Invoice.(discount(~invoice, ~discount=Ten));\n  10 \u2502 Js.log(invoice);\n\n  This has type:\n    Invoice.t(Invoice.discounted)\n  But somewhere wanted:\n    Invoice.t(Invoice.undiscounted)\n```", "```js\n/* Email.re */\nlet invoice =\n  Invoice.make(\n    ~name=\"Raphael\",\n    ~email=\"persianturtle@gmail.com\",\n    ~date=Js.Date.make(),\n    ~total=15.0,\n  );\n\nlet send: Invoice.t('a) => unit = invoice => {\n /* send invoice email */\n Js.log(invoice);\n};\n\nsend(invoice);\n```", "```js\nfunction dynamic(a) {\n  switch (typeof a) {\n    case \"string\":\n      return \"String: \" + a;\n    case \"number\":\n      return \"Number: \" + a;\n  }\n}\n```", "```js\n[@bs.val] external dynamic : 'a => string = \"\";\n```", "```js\n[@bs.val] external dynamic : ([@bs.unwrap] [\n  | `Str(string)\n  | `Int(int)\n]) => string = \"\";\n```", "```js\ndynamic(`Int(42));\ndynamic(`Str(\"foo\"));\n```", "```js\ndynamic(42);\n\n/*\nWe've found a bug for you!\n\nThis has type:\n  int\nBut somewhere wanted:\n  [ `Int of int | `Str of string ]\n*/\n```", "```js)\n\nWhenever you see a constructor prefixed with a backtick character, you know it's a polymorphic variant constructor. There may or may not be a type declaration associated with a polymorphic variant constructor.\n\n# Would this work with normal variants?\n\nLet's try to do this with normal variants and see what happens:\n\n```"]
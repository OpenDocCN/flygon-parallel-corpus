- en: Chapter 5. Working with Matrices and ufuncs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 五、使用矩阵和`ufunc`
- en: '*This chapter covers matrices and Universal functions (ufuncs). Matrices are
    well known in mathematics and have their representation in NumPy as well. Universal
    functions work on arrays, element by element, or on scalars. ufuncs expect a set
    of scalars as input and produce a set of scalars as output. Universal functions
    can typically be mapped to their mathematical counterparts such as add, subtract,
    divide, multiply, and so on. We will also introduce trigonometric, bitwise, and
    comparison universal functions.*'
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍矩阵和通用函数（ufuncs）。 矩阵在数学上是众所周知的，在 NumPy 中也具有表示。 通用函数适用于数组，逐元素或标量。 ufuncs 期望一组标量作为输入，并产生一组标量作为输出。
    通用函数通常可以映射到它们的数学对应物，例如加，减，除，乘等。 我们还将介绍三角函数，按位和比较通用函数。
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Matrix creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵创建
- en: Matrix operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵运算
- en: Basic ufuncs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本函数
- en: Trigonometric functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三角函数
- en: Bitwise functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按位函数
- en: Comparison functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较函数
- en: Matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵
- en: Matrices in NumPy are subclasses of `ndarray`. We can create matrices using
    a special string format. They are, just like in mathematics, two-dimensional (see
    [https://www.khanacademy.org/math/precalculus/precalc-matrices](https://www.khanacademy.org/math/precalculus/precalc-matrices)).
    Matrix multiplication is, as you would expect, different from the normal NumPy
    multiplication. The same is true for the power operator. We can create matrices
    with the `mat()`, `matrix()`, and `bmat()` functions.
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 中的矩阵是`ndarray`的子类。 我们可以使用特殊的字符串格式创建矩阵。 就像在数学中一样，[它们是二维的](https://www.khanacademy.org/math/precalculus/precalc-matrices)。
    正如您期望的那样，矩阵乘法不同于正常的 NumPy 乘法。 幂运算符也是如此。 我们可以使用`mat()`，`matrix()`和`bmat()`函数创建矩阵。
- en: Time for action – creating matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 创建矩阵
- en: The `mat()` function does not make a copy if the input is already a matrix or
    an `ndarray`. Calling this function is equivalent to calling `matrix`(`data, copy=False`).
    We will also demonstrate transposing and inverting matrices.
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入已经是矩阵或`ndarray`，则`mat()`函数不会复制。 调用此函数等效于调用`matrix(data, copy=False)`。 我们还将演示转置和求逆矩阵。
- en: 'Rows are delimited by a semicolon and values by a space. Call the `mat()` function
    with the following string to create a matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行用分号分隔，值用空格分隔。 使用以下字符串调用`mat()`函数以创建矩阵：
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The matrix output should be the following matrix:'
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵输出应为以下矩阵：
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Transpose the matrix with the `T` attribute as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下将矩阵转换为具有`T`属性的矩阵：
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is the transposed matrix:'
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是转置矩阵：
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The matrix can be inverted with the `I` attribute as follows (see [https://www.khanacademy.org/math/precalculus/precalc-matrices/inverting_matrices/v/inverse-matrix-part-1](https://www.khanacademy.org/math/precalculus/precalc-matrices/inverting_matrices/v/inverse-matrix-part-1)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`I`属性将矩阵反转，[如下所示](https://www.khanacademy.org/math/precalculus/precalc-matrices/inverting_matrices/v/inverse-matrix-part-1)：
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The inverse matrix is printed as follows (be warned that this is a `O(n³)`
    operation, meaning that it takes on average cubic time):'
  prefs: []
  type: TYPE_NORMAL
  zh: 逆矩阵打印如下（请注意，这是`O(n<sup class="calibre54">3</sup>)`操作，这意味着需要平均三次时间）：
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Instead of using a string to create a matrix, do it with an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不使用字符串创建矩阵，而是使用数组：
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The newly created array is printed as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的数组如下所示：
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We created matrices with the `mat()` function. We transposed the matrices with
    the `T` attribute and inverted them with the `I` attribute (see `matrixcreation.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`mat()`函数创建了矩阵。 我们将使用`T`属性将矩阵转置，并使用`I`属性将其反转（请参见`matrixcreation.py`）：
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Creating a matrix from other matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从其他矩阵创建矩阵
- en: Sometimes, we want to create a matrix from other smaller matrices. We can do
    this with the `bmat()` function. The `b` here stands for block matrix.
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们想由其他较小的矩阵创建矩阵。 我们可以通过`bmat()`函数来实现。 `b`在这里代表块矩阵。
- en: Time for action – creating a matrix from other matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 从其他矩阵创建矩阵
- en: 'We will create a matrix from two smaller matrices as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从两个较小的矩阵创建一个矩阵，如下所示：
- en: 'First, create a 2-by-2 identity matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个`2×2`单位矩阵：
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The identity matrix looks like the following:'
  prefs: []
  type: TYPE_NORMAL
  zh: 单位矩阵如下所示：
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create another matrix like `A` and multiply it by 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个类似于`A`的矩阵，并将其乘以 2：
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The second matrix is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个矩阵如下：
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create the compound matrix from a string. The string uses the same format as
    the `mat()` function—use matrices instead of numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字符串创建复合矩阵。 字符串使用与`mat()`函数相同的格式-使用矩阵而不是数字：
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The compound matrix is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 复合矩阵如下所示：
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We created a block matrix from two smaller matrices with the `bmat()` function.
    We gave the function a string containing the names of matrices instead of numbers
    (see `bmatcreation.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`bmat()`函数从两个较小的矩阵创建了一个块矩阵。 我们给该函数一个字符串，其中包含矩阵名称，而不是数字（请参见`bmatcreation.py`）：
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Pop quiz – defining a matrix with a string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小测验 – 使用字符串定义矩阵
- en: Q1\. What is the row delimiter in a string accepted by the `mat()` and `bmat()`
    functions?
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. `mat()`和`bmat()`函数接受的字符串中的行分隔符是什么？
- en: Semicolon
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分号
- en: Colon
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 句号
- en: Comma
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逗号
- en: Space
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 空格
- en: Universal functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用函数
- en: '**Universal** **functions** (**ufuncs**) expect a set of scalars as input and
    produce a set of scalars as output. They are actually Python objects that encapsulate
    the behavior of a function. We can typically map ufuncs to their mathematical
    counterparts such as add, subtract, divide, multiply, and so on. Universal functions
    are, in general, faster because of their special optimizations and because they
    run on the native level.'
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用函数**（**ufuncs**）期望一组标量作为输入并产生一组标量作为输出。 它们实际上是  Python 对象，它们封装了函数的行为。 通常，我们可以将`ufunc`映射到它们的数学对应项，例如加，减，除，乘等。
    通常，通用函数由于其特殊的优化以及在本机级别上运行而更快。'
- en: Time for action – creating universal functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 创建通用函数
- en: 'We can create a ufunc from a Python function with the NumPy the `frompyfunc()`
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 NumPy 和`frompyfunc()`函数从 Python 函数创建`ufunc`，如下所示：
- en: 'Define a Python function that answers the ultimate question to the universe,
    existence, and the rest (it''s from *The Hitchhiker''s Guide to the Galaxy*, *Douglas
    Adam*, *Pan Books*, if you haven''t read it, you can safely ignore this!):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 Python 函数，该函数回答关于宇宙，存在和其他问题的最终问题（来自《银河系漫游指南》 ，道格拉斯·亚当，Pan Books，如果您还没有阅读，可以安全地忽略这一点！）：
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So far, nothing special; we gave the function the name `ultimate_answer()` and
    defined one parameter, `a`.
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，没有什么特别的。 我们给函数命名为`ultimate_answer()`并定义了一个参数`a`。
- en: 'Create a result consisting of all zeros that has the same shape as `a`, with
    the `zeros_like()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`zeros_like()`函数，创建一个形状与`a`相同的所有零组成的结果：
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, set the elements of the initialized array to the answer `42` and return
    the result. The complete function should appear as shown in the following code
    snippet. The `flat` attribute gives us access to a flat iterator that allows us
    to set the value of the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将初始化数组的元素设置为答案`42`，然后返回结果。 完整的函数应显示在下面的代码片段中。 `flat`属性使我们可以访问平面迭代器，该迭代器允许我们设置数组的值。
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a ufunc with `frompyfunc()`; specify `1` as the number of input parameter
    followed by `1` as the number of output parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`frompyfunc（）`创建一个`ufunc`；指定`1`作为输入参数的数量，然后指定`1`作为输出参数的数量：
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The result for a one-dimensional array is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 一维数组的结果如下所示：
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Do the same for a two-dimensional array with the following code:'
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码对二维数组执行相同的操作：
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output for a two dimensional array is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 二维数组的输出如下所示：
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We defined a Python function. In this function, we initialized to zero the
    elements of an array, based on the shape of an input argument, with the `zeros_like()`
    function. Then, with the `flat` attribute of `ndarray`, we set the array elements
    to the ultimate answer, `42` (see `answer42.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个 Python 函数。 在此函数中，我们使用`zeros_like()`函数，根据输入参数的形状将数组的元素初始化为零。 然后，使用`ndarray`的`flat`属性，将数组元素设置为最终答案`42`（请参见`answer42.py`）：
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Universal function methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用函数的方法
- en: 'How can functions have methods? As we said earlier, universal functions are
    not functions but Python objects representing functions. Universal functions have
    five important methods listed as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 函数如何具有方法？ 如前所述，通用函数不是函数，而是表示函数的 Python 对象。 通用函数具有五种重要方法，如下：
- en: '`ufunc.reduce(a[, axis, dtype, out, keepdims])`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ufunc.reduce(a[, axis, dtype, out, keepdims])`'
- en: '`ufunc.accumulate(array[, axis, dtype, out])`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ufunc.accumulate(array[, axis, dtype, out])`'
- en: '`ufunc.reduceat(a, indices[, axis, dtype, out])`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ufunc.reduceat(a, indices[, axis, dtype, out])`'
- en: '`ufunc.outer(A, B)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ufunc.outer(A, B)`'
- en: '`ufunc.at(a, indices[, b])])])`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ufunc.at(a, indices[, b])])])`'
- en: Time for action – applying the ufunc methods to the add function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 将`ufunc`方法应用于`add`函数
- en: 'Let''s call the first four methods on the `add()` function:'
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`add()`函数上调用前四个方法：
- en: 'The universal function reduces the input array recursively along a specified
    axis on consecutive elements. For the `add()` function, the result of reducing
    is similar to calculating the sum of an array. Call the `reduce()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通用函数沿指定元素的连续轴递归地减少输入数组。 对于`add()`函数，约简的结果类似于计算数组的总和。 调用`reduce()`方法：
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The reduced array should be as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 精简数组应如下所示：
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `accumulate()` method also recursively goes through the input array. But,
    contrary to the `reduce()` method, it stores the intermediate results in an array
    and returns that. The result, in the case of the `add()` function, is equivalent
    to calling the `cumsum()` function. Call the `accumulate()` method on the `add()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`accumulate()`方法也递归地遍历输入数组。 但是，与`reduce()`方法相反，它将中间结果存储在一个数组中并返回它。 如果使用`add()`函数，则结果等同于调用`cumsum()`函数。
    在`add()`函数上调用`accumulate()`方法：'
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The accumulated array is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 累积的数组如下：
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `reduceat()` method is a bit complicated to explain, so let''s call it
    and go through its algorithm, step by step. The `reduceat()` method requires as
    arguments an input array and a list of indices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`reduceat()`方法的解释有点复杂，因此让我们对其进行调用并逐步了解其算法。 `reduceat()`方法需要输入数组和索引列表作为参数：'
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The result is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first step concerns the indices `0` and `5`. This step results in a reduce
    operation of the array elements between indices `0` and `5`:'
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步与索引`0`和`5`有关。 此步骤可减少索引`0`和`5`之间的数组元素的运算：
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output of step 1 is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 1 的输出如下：
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The second step concerns indices `5` and `2`. Since `2` is less than `5`, the
    array element at index `5` is returned:'
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步涉及索引`5`和`2`。 由于`2`小于`5`，因此返回索引为`5`的数组元素：
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The second step results in the following output:'
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步产生以下输出：
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The third step concerns indices `2` and `7`. This step results in a reduce
    operation of the array elements between indices `2` and `7`:'
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步涉及索引`2`和`7`。 此步骤可减少索引`2`和`7`之间的数组元素的运算：
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The result of the third step is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步的结果如下所示：
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The fourth step concerns index `7`. This step results in a reduce operation
    of the array elements from index `7` to the end of the array:'
  prefs: []
  type: TYPE_NORMAL
  zh: 第四步涉及索引`7`。 此步骤导致从索引`7`到数组末尾的数组元素减少操作：
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The fourth step result is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 第四步结果如下所示：
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `outer()` method returns an array that has a rank, which is the sum of
    the ranks of its two input arrays. The method is applied to all possible pairs
    of the input array elements. Call the `outer()` method on the `add()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`outer()`方法返回一个具有等级的数组，该等级是其两个输入数组的等级的总和。 该方法适用于所有可能的输入数组元素对。 在`add()`函数上调用`outer()`方法：'
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The outer sum output result is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 外部总和的输出结果如下：
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We applied the first four methods, `reduce()`, `accumulate()`, `reduceat()`,
    and `outer()`, of universal functions to the `add()` function (see `ufuncmethods.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通用函数的前四种方法`reduce()`，`accumulate()`，`reduceat()`和`outer()`应用于`add()`函数（请参见`ufuncmethods.py`）：
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Arithmetic functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术函数
- en: 'The common arithmetic operators `+`, `-`, and `*` are implicitly linked to
    the add, subtract, and multiply universal functions, respectively. This means
    that when you use one of these operators on a NumPy array, the corresponding universal
    function will get called. Division involves a slightly more complex process. The
    three universal functions that have to do with array division are `divide()`,
    `true_divide()`, and `floor_division()`. Two operators correspond to division:
    `/` and `//`.'
  prefs: []
  type: TYPE_NORMAL
  zh: 通用算术运算符`+`，`-`和`*`分别隐式链接到通用函数的加，减和乘。 这意味着在 NumPy 数组上使用这些运算符之一时，将调用相应的通用函数。 除法涉及一个稍微复杂的过程。
    与数组分割有关的三个通用函数是`divide()`，`true_divide()`和`floor_division()`。 两个运算符对应于除法：`/`和`//`。
- en: Time for action – dividing arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 分割数组
- en: 'Let''s see the array division in action:'
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下数组分割的作用：
- en: 'The `divide()` function does truncated integer division and normal floating-point
    division:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`divide()`函数将截断整数除法和普通浮点除法：'
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The result of the `divide()` function is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`divide()`函数的结果如下所示：'
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, truncation took place.
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，截断发生了。
- en: 'The `true_divide()` function comes closer to the mathematical definition of
    division. Integer division returns a floating-point result and no truncation occurs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数`true_divide()`更接近于除法的数学定义。 整数除法返回浮点结果，并且不会发生截断：
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The result of the `true_divide()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`true_divide()`函数的结果如下：'
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `floor_divide()` function always returns an integer result. It is equivalent
    to calling the `floor()` function after calling the `divide()` function. The `floor()`
    function discards the decimal part of a floating-point number and returns an integer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`floor_divide()`函数总是返回整数结果。 等效于调用`divide()`函数之后调用`floor()`函数。 `floor()`函数丢弃浮点数的小数部分并返回一个整数：'
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `floor_divide()` function call results in:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`floor_divide()`函数调用导致：'
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'By default, the `/` operator is equivalent to calling the `divide()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`/`运算符等效于调用`divide()`函数：
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'However, if this line is found at the beginning of a Python program, the `true_divide()`
    function is called instead. So, this code will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果在 Python 程序的开头找到此行，则将调用`true_divide()`函数。 因此，此代码将如下所示：
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The result is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 'The result is shown as follows:'
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `//` operator is equivalent to calling the `floor_divide()` function. For
    example, look at the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`//`运算符等效于调用`floor_divide()`函数。 例如，查看以下代码片段：'
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `//` operator result is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`//`运算符结果如下所示：'
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'The `divide()` function truncates the integer division and normal floating-point
    division. The `true_divide()` function always returns a floating-point result
    without any truncation. The `floor_divide()` function always returns an integer
    result; the result is the same that you will get by calling the `divide()` and
    `floor()` functions consecutively (see `dividing.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: '`divide()`函数会执行截断整数除法和常规浮点除法。 `true_divide()`函数始终返回浮点结果而没有任何截断。 `floor_divide()`函数始终返回整数结果；
    结果与通过连续调用`divide()`和`floor()`函数（请参见`dividing.py`）获得的相同：'
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Have a go hero – experimenting with __future__.division
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 勇往直前 – 尝试`__future__.division`
- en: Experiment to confirm the impact of importing __future__.division.
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实验确认导入`__future__.division`的影响。
- en: Modulo operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模运算
- en: We can calculate the modulo or remainder using the NumPy `mod()`, `remainder()`,
    and `fmod()` functions. Also, we can use the `%` operator. The main difference
    among these functions is how they deal with negative numbers. The odd one out
    in this group is the `fmod()` function.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 NumPy `mod()`，`remainder()`和`fmod()`函数来计算模或余数。 同样，我们可以使用`%`运算符。 这些函数之间的主要区别在于它们如何处理负数。
    该组中的奇数是`fmod()`函数。
- en: Time for action – computing the modulo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 计算模数
- en: 'Let''s call the previously mentioned functions:'
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用前面提到的函数：
- en: 'The `remainder()` function returns the remainder of the two arrays, element-wise.
    `0` is returned if the second number is `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`remainder()`函数以元素为单位返回两个数组的其余部分。 如果第二个数字为 0，则返回 0：'
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The result of the `remainder()` function is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`remainder()`函数的结果如下所示：'
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `mod()` function does exactly the same as the `remainder()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mod()`函数的功能与`remainder()`函数的功能完全相同：'
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The result of the `mod()` function is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod()`函数的结果如下所示：'
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `%` operator is just shorthand for the `remainder()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`%`运算符只是`remainder()`函数的简写：'
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The result of the `%` operator is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`%`运算符的结果如下所示：'
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `fmod()` function handles negative numbers differently than `mod()`, `fmod()`,
    and `%` do. The sign of the remainder is the sign of the dividend, and the sign
    of the divisor has no influence on the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fmod()`函数处理负数的方式与`mod()`和`%`的处理方式不同。 余数的符号是被除数的符号，除数的符号对结果没有影响：'
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `fmod()` result is printed as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmod()`结果打印如下：'
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We demonstrated the NumPy the `mod()`, `remainder()`, and `fmod()` functions,
    which compute the modulo or remainder (see `modulo.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 NumPy 演示了`mod()`，`remainder()`和`fmod()`函数，它们计算模或余数（请参见`modulo.py`）：
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Fibonacci numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 斐波那契数
- en: 'The **Fibonacci** **numbers** (see [http://en.wikipedia.org/wiki/Fibonacci_number](http://en.wikipedia.org/wiki/Fibonacci_number))
    are based on a recurrence relation:'
  prefs: []
  type: TYPE_NORMAL
  zh: '[**斐波那契数**](http://en.wikipedia.org/wiki/Fibonacci_number) 基于递归关系：'
- en: '![Fibonacci numbers](graphics/4154_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Fibonacci numbers](img/4154_05_04.jpg)'
- en: 'It is difficult to express this relation directly with NumPy code. However,
    we can express this relation in a matrix form or use the following **golden**
    **ratio** formula:'
  prefs: []
  type: TYPE_NORMAL
  zh: 用 NumPy 代码直接表达这种关系是困难的。 但是，我们可以用矩阵形式表示这种关系，也可以按照**黄金比例**公式：
- en: '![Fibonacci numbers](graphics/4154_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Fibonacci numbers](img/4154_05_05.jpg)'
- en: with
  prefs: []
  type: TYPE_NORMAL
  zh: 与
- en: '![Fibonacci numbers](graphics/4154_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Fibonacci numbers](img/4154_05_06.jpg)'
- en: This will introduce the `matrix()` and `rint()` functions. The `matrix()` function
    creates matrices and the `rint()` function rounds numbers to the closest integer,
    but the result is not an integer.
  prefs: []
  type: TYPE_NORMAL
  zh: 这将介绍`matrix()`和`rint()`函数。 `matrix()`函数创建矩阵，   数字四舍五入到最接近的整数，但结果不是整数。
- en: Time for action – computing Fibonacci numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 计算斐波纳契数
- en: 'A matrix can represent the Fibonacci recurrence relation. We can express the
    calculation of Fibonacci numbers as a repeated matrix multiplication:'
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵可以表示斐波那契递归关系。 我们可以将斐波纳契数的计算表示为重复的矩阵乘法：
- en: 'Create the Fibonacci matrix as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下创建斐波那契矩阵：
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The Fibonacci matrix appears as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契矩阵如下所示：
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Calculate the `8th` Fibonacci number (ignoring `0`), by subtracting `1` from
    `8` and taking the power of the matrix. The Fibonacci number then appears on the
    diagonal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从 8 减去 1 并取矩阵的幂，计算出第 8 个斐波那契数（忽略 0）。 斐波那契数然后出现在对角线上：
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The Fibonacci number is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数如下：
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The **golden** **ratio** formula, better known as **Binet''s** formula, allows
    us to calculate Fibonacci numbers with a rounding step at the end. Calculate the
    first eight Fibonacci numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “黄金比例”公式（又称为“Binet”公式）使我们能够计算斐波纳契数，并在最后进行四舍五入。 计算前八个斐波那契数：
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The first eight Fibonacci numbers are as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 前八个斐波那契数如下：
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We computed Fibonacci numbers in two ways. In the process, we learned about
    the `matrix()` function that creates matrices. We also learned about the `rint()`
    function that rounds numbers to the closest integer but does not change the type
    to integer (see `fibonacci.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用两种方法计算了斐波那契数。 在此过程中，我们了解了用于创建矩阵的`matrix()`函数。 我们还了解了`rint()`函数，该函数将数字四舍五入到最接近的整数，但不将类型更改为整数（请参见`fibonacci.py`）：
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Have a go hero – timing the calculations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 勇往直前 – 时间计算
- en: You are probably wondering which approach is faster, so go ahead and time it.
    Create a universal Fibonacci function with `frompyfunc()` and time that too.
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道哪种方法更快，因此请继续并确定时间。 用`frompyfunc()`创建通用的斐波那契函数，并对其计时。
- en: Lissajous curves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利萨如曲线
- en: 'All the standard trigonometric functions such as `sin`, `cos`, `tan`, and so
    on are represented by universal functions in NumPy (see [https://www.khanacademy.org/math/trigonometry](https://www.khanacademy.org/math/trigonometry)).
    **Lissajous** **curves** are a fun way of using trigonometry. I remember producing
    Lissajous figures on an oscilloscope in the physics lab. Two parametric equations
    describe the figures:'
  prefs: []
  type: TYPE_NORMAL
  zh: 所有标准的三角函数，例如`sin`，`cos`，`tan`等，都由 NumPy 中的[通用函数表示](https://www.khanacademy.org/math/trigonometry)）。**利萨如曲线**是使用三角函数的一种有趣方式。
    我记得在物理实验室的示波器上制作了李沙育的数字。 两个参数方程式描述了这些图形：
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Time for action – drawing Lissajous curves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 绘制利萨如曲线
- en: 'The Lissajous figures are determined by four parameters: `A`, `B`, `a`, and
    `b`. Let''s set `A` and `B` to `1` for simplicity:'
  prefs: []
  type: TYPE_NORMAL
  zh: 利萨如的数字是由`A`，`B`，`a`和`b`四个参数确定的  。 为了简单起见，我们将`A`和`B`设置为`1`：
- en: 'Initialize `t` with the `linspace()` function from `-pi` to `pi` with `201`
    points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将具有`linspace()`函数的`t`从`-pi`初始化为具有`201`点的`pi`：
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Calculate `x` with the `sin()` function and `np.pi`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sin()`函数和`np.pi`计算`x`：
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Calculate `y` with the `sin()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sin()`函数计算`y`：
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Plot as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下图所示：
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The result for `a` `=` `9` and `b` `=` `8` is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`a = 9`和`b = 8`的结果如下：'
- en: '![Time for action – drawing Lissajous curves](graphics/4154_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – drawing Lissajous curves](img/4154_05_01.jpg)'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We plotted the Lissajous curve with the aforementioned parametric equations
    where `A=B=1`, `a=9`, and `b=8`. We used the `sin()` and `linspace()` functions,
    as well as the NumPy `pi` constant (see `lissajous.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用上述参数方程式绘制了利萨如曲线，其中`A=B=1`，`a=9`和`b=8`。 我们使用了`sin()`和`linspace()`函数，以及 NumPy
    `pi`常量（请参见`lissajous.py`）：
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Square waves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方波
- en: Square waves are also one of those neat things that you can view on an oscilloscope.
    They can be approximated pretty well with sine waves; after all, a square wave
    is a signal that can be represented by an infinite **Fourier** **series**.
  prefs: []
  type: TYPE_NORMAL
  zh: 方波也是您可以在示波器上查看的那些整洁的东西之一。 正弦波可以很好地将其近似为  。 毕竟，方波是可以用无限**傅立叶级数**表示的信号。
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A Fourier series is the sum of a series of sine and cosine terms named after
    the famous mathematician Jean-Baptiste Fourier (see [http://en.wikipedia.org/wiki/Fourier_series](http://en.wikipedia.org/wiki/Fourier_series)).
  prefs: []
  type: TYPE_NORMAL
  zh: 傅立叶级数是以著名数学家让·巴蒂斯特·傅立叶（Jean-Baptiste Fourier）命名的，一系列[正弦和余弦项之和](http://en.wikipedia.org/wiki/Fourier_series)。
- en: 'The formula of this particular series representing the square wave is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 代表方波的该特定系列的公式如下：
- en: ''
  prefs: []
  type: TYPE_IMG
  zh: '![Square waves](img/4154_05_07.jpg)'
- en: ''
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 绘制方波
- en: '![Square waves](graphics/4154_05_07.jpg)<title>Time for action – drawing a
    square wave</title><link href="epub.css" rel="stylesheet" type="text/css">'
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一节一样，我们将初始化`t`。 我们需要总结一些术语。 术语数量越多，结果越准确； `k = 99`应该足够。 为了绘制方波，请按照下列步骤操作：
- en: Time for action – drawing a square wave
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ''
- en: 'We will initialize `t` just as in the previous section. We need to sum a number
    of terms. The higher the number of terms, the more accurate the result; `k` `=`
    `99` should be sufficient. In order to draw a square wave, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
  zh: ''
- en: 'We will start by initializing `t` and `k`. Set the initial values for the function
    to `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从初始化`t`和`k`开始。 将该函数的初始值设置为`0`：
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Compute the function values with the `sin()` and `sum()` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sin()`和`sum()`函数计算函数值：
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The code to plot is almost identical to the one in the previous section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要绘制的代码与上一节中的代码几乎相同：
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The resulting square wave generated with `k` `=` `99` is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 用`k = 99`生成的所得方波如下：
- en: '![Time for action – drawing a square wave](graphics/4154_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – drawing a square wave](img/4154_05_02.jpg)'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We generated a square wave or, at least, a fair approximation of it, using
    the `sin()` function. The input values were assembled with the `linspace()` function
    and the `k` values with the `arange()` function (see `squarewave.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用  `sin()`函数生成了方波，或者至少是它的近似值。 输入值通过  `linspace()`函数进行组装，而`k`值通过`arange()`函数进行组装（请参见`squarewave.py`）：
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Have a go hero – getting rid of the loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 勇往直前 – 摆脱循环
- en: You may have noticed that there is one loop in the code. Get rid of it with
    NumPy functions and make sure the performance is also improved.
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到代码中存在一个循环。 使用 NumPy 函数摆脱它，并确保性能也得到改善。
- en: Sawtooth and triangle waves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锯齿波和三角波
- en: 'Sawtooth and triangle waves are also a phenomenon easily viewed on an oscilloscope.
    Just as with square waves, we can define an infinite Fourier series. The triangle
    waves can be found by taking the absolute value of a sawtooth wave. The formula
    for the representation of a series of sawtooth waves is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 锯齿波和三角波也是在示波器上容易看到的现象。 就像方波一样，我们可以定义无限傅立叶级数。 三角波可以通过获取锯齿波的绝对值来找到。 表示一系列锯齿波的公式如下：
- en: ''
  prefs: []
  type: TYPE_IMG
  zh: '![Sawtooth and triangle waves](img/4154_05_08.jpg)'
- en: ''
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 绘制锯齿波和三角波
- en: '![Sawtooth and triangle waves](graphics/4154_05_08.jpg)<title>Time for action
    – drawing sawtooth and triangle waves</title><link href="epub.css" rel="stylesheet"
    type="text/css">'
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一节一样，我们初始化`t`。 同样，`k = 99`应该足够。 为了绘制锯齿波和三角波，请按照下列步骤操作：
- en: Time for action – drawing sawtooth and triangle waves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ''
- en: 'We will initialize `t` just like in the previous section. Again, `k` `=` `99`
    should be sufficient. In order to draw sawtooth and triangle waves, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
  zh: ''
- en: 'Set initial values for the function to `zero`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该函数的初始值设置为`zero`：
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Compute the function values with the `sin()` and `sum()` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sin()`和`sum()`函数计算函数值：
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'It''s easy to plot the sawtooth and triangle waves since the value of the triangle
    wave should be equal to the absolute value of the sawtooth wave. Plot the waves
    as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制锯齿波和三角波很容易，因为三角波的值应等于锯齿波的绝对值。 绘制波形，如下所示：
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In the following figure, the triangle wave is the one with the dashed line:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，三角形波是带有虚线的波：
- en: '![Time for action – drawing sawtooth and triangle waves](graphics/4154_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – drawing sawtooth and triangle waves](img/4154_05_03.jpg)'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We drew a sawtooth wave using the `sin()` function. We assembled the input
    values with the `linspace()` function and the `k` values with the `arange()` function.
    A triangle wave was derived from the sawtooth wave by taking the absolute value
    (see `sawtooth.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`sin()`函数绘制了锯齿波  。 我们将输入值与`linspace()`函数组合在一起，并将`k`值与`arange()`函数组合在一起。
    通过取绝对值从锯齿波中产生一个三角波（请参见`sawtooth.py`）：
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Have a go hero – getting rid of the loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 勇往直前 – 摆脱循环
- en: Your challenge, should you choose to accept it, is to get rid of the loop in
    the program. It should be doable with NumPy functions and the performance should
    improve.
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择接受  ，那么您面临的挑战是摆脱程序中的循环。 它应该可以与 NumPy 函数一起使用，并且性能应该得到改善。
- en: Bitwise and comparison functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按位和比较函数
- en: Bitwise functions operate on the bits of integers or integer arrays since they
    are universal functions. The operators `^`, `&`, `|`, `<<`, `>>`, and so on have
    their NumPy counterparts. The same goes for comparison operators such as `<`,
    `>`, `==`, and so on. These operators allow you to do clever tricks, which should
    be good for performance; however, they can make your code quite unreadable, so
    use them with care.
  prefs: []
  type: TYPE_NORMAL
  zh: 按位函数是整数或整数数组的位，因为它们是通用函数。 运算符`^`，`&`，`|`，`<<`，`>>`等具有其 NumPy 对应物。 比较运算符，例如`<`，`>`和`==`等也是如此。
    这些运算符使您可以做一些巧妙的技巧，从而提高性能； 但是，它们会使您的代码难以理解，因此请谨慎使用。
- en: Time for action – twiddling bits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 翻转位
- en: 'We will now cover three tricks—checking whether the signs of integers are different,
    checking whether a number is a power of `2`, and calculating the modulus of a
    number that is a power of `2`. We will show an operators-only notation and one
    using the corresponding NumPy functions:'
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将介绍三个技巧：检查整数的符号是​​否不同，检查数字是否为`2`的幂，以及计算作为`2`的幂的数字的模数。 我们将展示一个仅用于运算符的符号，以及一个使用相应的
    NumPy 函数的符号：
- en: The first trick depends on the `XOR` or `^` operator. The `XOR` operator is
    also called the inequality operator; so, if the sign bit of the two operands is
    different, the `XOR` operation will lead to a negative number (see [https://www.khanacademy.org/computing/computer-science/cryptography/ciphers/a/xor-bitwise-operation](https://www.khanacademy.org/computing/computer-science/cryptography/ciphers/a/xor-bitwise-operation)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个技巧取决于`XOR`或`^`运算符。 `XOR`运算符也称为不等式运算符； 因此，如果两个操作数的符号位不同，[则`XOR`运算将导致负数](https://www.khanacademy.org/computing/computer-science/cryptography/ciphers/a/xor-bitwise-operation)。
- en: 'The following truth table illustrates the `XOR` operator:'
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的真值表说明了`XOR`运算符：
- en: '| Input 1 | Input 2 | XOR |'
  prefs: []
  type: TYPE_TB
  zh: '| 输入 1 | 输入 2 | 异或 |'
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| True | True | False |'
  prefs: []
  type: TYPE_TB
  zh: '| `True` | `True` | `False` |'
- en: '| False | True | True |'
  prefs: []
  type: TYPE_TB
  zh: '| `False` | `True` | `True` |'
- en: '| True | False | True |'
  prefs: []
  type: TYPE_TB
  zh: '| `True` | `False` | `True` |'
- en: '| False | False | False |'
  prefs: []
  type: TYPE_TB
  zh: '| `False` | `False` | `False` |'
- en: 'The `^` operator corresponds to the `bitwise_xor()` function, and the `<` operator
    corresponds to the `less()` function:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`^`运算符对应于`bitwise_xor()`函数，`<`运算符对应于`less()`函数：'
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The result is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 结果为  ，如下所示：
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: As expected, all the signs differ, except for zero.
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，除零以外，所有符号均不同。
- en: A power of `2` is represented by a `1`, followed by a series of trailing zeroes
    in binary notation. For instance, `10`, `100`, or `1000`. A number one less than
    a power of `2` will be represented by a row of ones in binary. For instance, `11`,
    `111`, or `1111` (or `3`, `7`, and `15` in the decimal system). Now, if we bitwise
    `AND` a power of `2`, and the integer that is one less than that, then we should
    get `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2 的幂由 1 表示，后跟一系列二进制表示的尾随零。 例如，`10`，`100`或`1000`。 比 2 的幂小 1 的数字将由一排二进制 1 表示。
    例如，`11`，`111`或`1111`（或十进制中的`3`，`7`和`15`）。 现在，如果我们对 2 的幂，和比它小 1 的整数进行“与”运算，则应该得到
    0。
- en: 'The truth table for the `AND` operator looks like the following:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`AND`运算符的真值表如下所示：'
- en: '| Input 1 | Input 2 | AND |'
  prefs: []
  type: TYPE_TB
  zh: '| 输入 1 | 输入 2 | AND |'
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| True | True | True |'
  prefs: []
  type: TYPE_TB
  zh: '| True | True | True |'
- en: '| False | True | False |'
  prefs: []
  type: TYPE_TB
  zh: '| False | True | False |'
- en: '| True | False | False |'
  prefs: []
  type: TYPE_TB
  zh: '| True | False | False |'
- en: '| False | False | False |'
  prefs: []
  type: TYPE_TB
  zh: '| False | False | False |'
- en: 'The NumPy counterpart of `&` is `bitwise_and()`, and the counterpart of `==`
    is the `equal()` universal function:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`的 NumPy 对应项是`bitwise_and()`，`==`的对应项是`equal()`通用函数：'
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The result is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 'The result is shown as follows:'
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The trick of computing the modulus of 4 actually works when taking the modulus
    of integers that are a power of `2` such as `4`, `8`, `16`, and so on. A bitwise
    left shift leads to doubling of values (see [https://wiki.python.org/moin/BitwiseOperators](https://wiki.python.org/moin/BitwiseOperators)).
    We saw in the previous step that subtracting one from a power of `2` leads to
    a number in binary notation that has a row of ones such as `11`, `111`, or `1111`.
    This basically gives us a mask. Bitwise-ANDing with such a number gives you the
    remainder with a power of `2`. The NumPy equivalent of `<<` is the `left_shift()`
    universal function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当计算整数的 2 的幂的模数时，例如 4、8、16 等，计算 4 的模数的技巧实际上起作用。 [左移导致值加倍](https://wiki.python.org/moin/BitwiseOperators)。我们在上一步中看到，从
    2 的幂中减去 1 会导致二进制表示形式的数字带有一行诸如 11、111 或 1111 之类的数字。 这基本上给了我们一个掩码。 用这样的数字按位与，得到的余数为
    2。 NumPy 的`<<`的等价物是`left_shift()`通用函数：
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The result is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 'The result is shown as follows:'
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We covered three bit twiddling hacks—checking whether the signs of integers
    are different, checking whether a number is a power of `2`, and calculating the
    modulus of a number that is a power of `2`. We saw the NumPy counterparts of the
    operators `^`, `&`, `<<`, and `<` (see `bittwidling.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了三点技巧：检查整数的符号是​​否不同，检查数字是否为`2`的幂，并计算数字的模数为`2`的幂。 我们看到了运算符`^`，`&`，`<<`和`<`的
    NumPy 对应项（请参见`bittwidling.py`）：
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Fancy indexing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 花式索引
- en: The `at()` method was added in **NumPy 1.8**. This method allows fancy indexing
    in-place. Fancy indexing is indexing that does not involve integers or slices,
    which is normal indexing. In-place means that the array we operate on will be
    modified.
  prefs: []
  type: TYPE_NORMAL
  zh: '`at()`方法是在 **NumPy 1.8** 中添加的  。 此方法允许原地建立花式索引。 花式索引是不涉及整数或切片的索引  ，这是正常的索引。
    原地意味着将对我们操作的数组进行修改。'
- en: The signature for the `at()` method is `ufunc.at(a, indices[, b])`. The indices
    array specifies the elements to operate on. We need the `b` array only for universal
    functions with two operands. The following *Time* *for* *action* section gives
    examples of the `at()` method.
  prefs: []
  type: TYPE_NORMAL
  zh: '`at()`方法的签名为`ufunc.at(a, indices[, b])`。 ` indices`数组指定要操作的元素。 我们仅需要`b`数组用于具有两个操作数的通用函数。
    以下“实战时间”部分给出了`at()`方法的示例 。'
- en: Time for action – fancy indexing in-place for ufuncs with the at() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 使用`at()`方法为 ufuncs 原地建立索引
- en: To demonstrate how the `at()` method works, start a Python or IPython shell
    and import NumPy. You should know how to do this by now.
  prefs: []
  type: TYPE_NORMAL
  zh: 要演示方法的工作方式，请启动  Python 或 IPython shell 并导入 NumPy。 您现在应该知道如何执行此操作。
- en: 'Create an array with seven random integers from `-3` to `3` with a seed of
    `42`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个由七个随机整数组成的数组，该整数从`-3`到`3`，种子为`42`：
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: When we talk about random numbers in programming, we usually talk about pseudo-random
    numbers (see [https://www.khanacademy.org/computing/computer-science/cryptography/crypt/v/random-vs-pseudorandom-number-generators](https://www.khanacademy.org/computing/computer-science/cryptography/crypt/v/random-vs-pseudorandom-number-generators)).
    The numbers appear random, but in fact are calculated using a seed.
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在编程中谈论随机数字时，我们通常会谈论[伪随机数](https://www.khanacademy.org/computing/computer-science/cryptography/crypt/v/random-vs-pseudorandom-number-generators)。
    这些数字看起来是随机的，但实际上是使用种子来计算的。
- en: 'Apply the `at()` method of the `sign()` universal function to the fourth and
    sixth array elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`sign()`通用函数的`at()`方法应用于第四和第六个数组元素：
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We used the `at()` method to select array elements and performed an in-place
    operation—determining the sign. We also learned how to create random integers.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`at()`方法来选择数组元素，并执行原地操作-确定符号。 我们还学习了如何创建随机整数。
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned, about matrices and universal functions. We covered
    how to create matrices and looked at how universal functions work. You had a brief
    introduction to arithmetic, trigonometric, bitwise, and comparison universal functions.
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了关于矩阵和通用函数的知识。 我们介绍了如何创建矩阵，并研究了通用函数如何工作。 您简要介绍了算术，三角函数，按位和比较通用函数。
- en: In the next chapter, you will cover the NumPy modules.
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将介绍 NumPy 模块。

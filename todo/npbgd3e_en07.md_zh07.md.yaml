- en: Chapter 7. Peeking into Special Routines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 七、探索特殊例程
- en: '*As NumPy users, we sometimes find ourselves having special needs, for instance,
    financial calculations or signal processing. Fortunately, NumPy provides for most
    of our needs. This chapter describes some of the more specialized NumPy functions.*'
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 NumPy 的用户，我们有时会发现自己有特殊需要，例如财务计算或信号处理。 幸运的是，NumPy 满足了我们的大多数需求。 本章介绍一些更专门的
    NumPy 函数。
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Sorting and searching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序和搜索
- en: Special functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊函数
- en: Financial utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 财务函数
- en: Window functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口函数
- en: Sorting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序
- en: 'NumPy has several data sorting routines:'
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 具有几个数据排序例程：
- en: The `sort()` function returns a sorted array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort()`函数返回排序数组'
- en: The `lexsort()` function performs sorting with a list of keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lexsort()`函数使用键列表执行排序'
- en: The `argsort()` function returns the indices that will sort an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`argsort()`函数返回将对数组进行排序的索引'
- en: The `ndarray` class has a `sort()` method that performs in-place sorting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ndarray`类具有执行原地排序的`sort()`方法'
- en: The `msort()` function sorts an array along the first axis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msort()`函数沿第一轴对数组进行排序'
- en: The `sort_complex()` function sorts complex numbers by their real part and then
    their imaginary part
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort_complex()`函数按复数的实部和虚部对它们进行排序'
- en: From this list, the `argsort()` and `sort()` functions are available as methods
    on NumPy arrays as well.
  prefs: []
  type: TYPE_NORMAL
  zh: 从此列表中，`argsort()`和`sort()`函数也可用作 NumPy 数组的方法。
- en: Time for action – sorting lexically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：按词法排序
- en: 'The NumPy `lexsort()` function returns an array of indices of the input array
    elements corresponding to lexically sorting an array. We need to give the function
    an array or tuple of sort keys:'
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy `lexsort()`函数返回输入数组元素的索引数组，这些索引对应于按词法对数组进行排序。 我们需要给函数一个数组或排序键元组：
- en: 'Let''s go back to [Chapter 3](ch03.html "Chapter 3. Getting Familiar with Commonly
    Used Functions"), *Getting Familiar with Commonly Used Functions*. In that chapter,
    we used stock price data of AAPL. We will load the close prices and the (always
    complex) dates. In fact, create a converter function just for the dates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到第 3 章，“熟悉常用函数”。 在该章中，我们使用了`AAPL`的股价数据。 我们将加载收盘价和（总是复杂的）日期。 实际上，只为日期创建一个转换器函数：
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Sort the names lexically with the `lexsort()` function. The data is already
    sorted by date, but sort it by close as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`lexsort()`函数按词法对名称进行排序。 数据已经按日期排序，但也按结束排序：
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The code prints the following:'
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码显示以下内容：
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We sorted the close prices of AAPL lexically using the NumPy `lexsort()` function.
    The function returned the indices corresponding with sorting the array (see `lex.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 NumPy `lexsort()`函数按词法对`AAPL`的收盘价进行分类。 该函数返回与数组排序相对应的索引（请参见`lex.py`）：
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Have a go hero – trying a different sort order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 勇往直前：尝试不同的排序顺序
- en: We sorted using the dates and the close price sort order. Try a different order.
    Generate random numbers using the random module we learned about in the previous
    chapter and sort those using `lexsort()`.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用日期和收盘价顺序进行了排序。 请尝试其他顺序。 使用我们在上一章中学习到的随机模块生成随机数，然后使用`lexsort()`对其进行排序。
- en: Time for action – partial sorting via selection for a fast median with the partition()
    function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：通过使用`partition()`函数选择快速中位数进行部分排序
- en: The `partition()` function does partial sorting, which should be faster than
    full sorting, because it's less work.
  prefs: []
  type: TYPE_NORMAL
  zh: '`partition()`函数执行部分排序，  应该比完整排序更快，因为它的工作量较小。'
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: For more information, please refer to [http://en.wikipedia.org/wiki/Partial_sorting](http://en.wikipedia.org/wiki/Partial_sorting).
    A common use case is getting the top 10 elements of a collection. Partial sorting
    doesn't guarantee the correct order within the group of top elements itself.
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参考[这里](http://en.wikipedia.org/wiki/Partial_sorting)。 一个常见的用例是获取集合的前
    10 个元素。 部分排序不能保证顶部元素组本身的正确顺序。
- en: 'The first argument of the function is the array to partially sort. The second
    argument is an integer or a sequence of integers corresponding to indices of array
    elements. The `partition()` function sorts elements in those indices correctly.
    With one specified index, we get two partitions; with multiple indices, we get
    more than one partition. The sorting algorithm makes sure that elements in partitions,
    which are smaller than a correctly sorted element, come before this element. Otherwise,
    they are placed behind this element. Let''s illustrate this explanation with an
    example. Start a Python or IPython shell and import NumPy:'
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的第一个参数是要部分排序的数组。 第二个参数是与数组元素索引相对应的整数或整数序列。 `partition()`函数对那些索引中的元素进行正确排序。
    使用一个指定的索引，我们得到两个分区。 具有多个索引，我们得到多个分区。 排序算法确保分区中的元素（小于正确排序的元素）位于该元素之前。 否则，它们将放置在此元素后面。
    让我们用一个例子来说明这个解释。 启动 Python 或 IPython Shell 并导入 NumPy：
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create an array with random elements to sort:'
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含随机元素的数组以进行排序：
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Partially sort the array by partitioning it in two roughly equal parts:'
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其分成两个大致相等的部分，对数组进行部分排序：
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We get an almost perfect sorting except for the last two elements.
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最后两个元素外，我们得到了几乎完美的排序。
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We partially sorted a nine-element array. The sorting only guaranteed that one
    element in the middle at index 4 is at the correct position. This corresponds
    to trying to get the top five elements of the array without caring about the order
    within the top five group. Since the correctly sorted element is in the middle,
    this also gives the median of the array.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 9 个元素的数组进行了部分排序。 排序仅保证索引 4 中间的一个元素位于正确的位置。 这对应于尝试获取数组的前五个元素而不关心前五个组中的顺序。
    由于正确排序的元素位于中间，因此这也给出了数组的中位数。
- en: Complex numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复数
- en: Complex numbers are numbers that have a real and imaginary part. As you remember
    from previous chapters, NumPy has special complex data types that represent complex
    numbers by two floating-point numbers. These numbers can be sorted using the NumPy
    `sort_complex()` function. This function sorts the real part first and then the
    imaginary part.
  prefs: []
  type: TYPE_NORMAL
  zh: 复数是具有实部和虚部的数字。 如您在前几章中所记得的那样，NumPy 具有特殊的复杂数据类型，这些数据类型通过两个浮点数表示复数。 可以使用 NumPy
    `sort_complex()`函数对这些数字进行排序。 此函数首先对实部进行排序，然后对虚部进行排序。
- en: Time for action – sorting complex numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：对复数进行排序
- en: 'We will create an array of complex numbers and sort it:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建复数数组并将其排序：
- en: 'Generate five random numbers for the real part of the complex numbers and five
    numbers for the imaginary part. Seed the random generator to `42`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为复数的实部生成五个随机数，为虚部生成五个数。 将随机生成器播种到`42`：
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Call the `sort_complex()` function to sort the complex numbers we generated
    in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`sort_complex()`函数对我们在上一步中生成的复数进行排序：
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The sorted numbers would be:'
  prefs: []
  type: TYPE_NORMAL
  zh: 排序的数字将是：
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We generated random complex numbers and sorted them using the `sort_complex()`
    function (see `sortcomplex.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成了随机复数，并使用`sort_complex()`函数对其进行了排序（请参见`sortcomplex.py`）：
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Pop quiz – generating random numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小测验 - 生成随机数
- en: Q1\. Which NumPy module deals with random numbers?
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 哪个 NumPy 模块处理随机数？
- en: Randnum
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`randnum`'
- en: random
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`random`'
- en: randomutil
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`randomutil`'
- en: rand
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rand`'
- en: Searching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索
- en: 'NumPy has several functions that can search through arrays:'
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 具有几个可以搜索数组的函数：
- en: 'The `argmax()` function gives the indices of the maximum values of an array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`argmax()`函数提供数组最大值的索引  ：'
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `nanargmax()` function does the same, but ignores NaN values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nanargmax()`函数的作用与上面相同，但忽略 NaN 值：'
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `argmin()` and `nanargmin()` functions provide similar functionality but
    pertaining to minimum values. The `argmax()` and `nanargmax()` functions are also
    available as methods of the `ndarray` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`argmin()`和`nanargmin()`函数提供相似的功能，但针对最小值。 `argmax()`和`nanargmax()`函数也可用作`ndarray`类的方法。'
- en: 'The `argwhere()` function searches for non-zero values and returns the corresponding
    indices grouped by element:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`argwhere()`函数搜索非零值，并返回按元素分组的相应索引：'
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `searchsorted()` function tells you the index in an array where a specified
    value belongs to maintain the sort order. It uses binary search (see [https://www.khanacademy.org/computing/computer-science/algorithms/binary-search/a/binary-search](https://www.khanacademy.org/computing/computer-science/algorithms/binary-search/a/binary-search)),
    which is a `O`(`log` `n`) algorithm. We will see this function in action shortly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchsorted()`函数告诉您数组中的索引，指定值所属的数组将保持排序顺序。 它使用[二分搜索](https://www.khanacademy.org/computing/computer-science/algorithms/binary-search/a/binary-search)，即`O(log
    n)`算法。 我们很快就会看到此函数的作用。'
- en: The `extract()` function retrieves values from an array based on a condition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extract()`函数根据条件从数组中检索值。'
- en: Time for action – using searchsorted
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：使用`searchsorted`
- en: 'The `searchsorted()` function gets the index of a value in a sorted array.
    An example should make this clear:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`searchsorted()`函数获取排序数组中值的索引。 一个例子应该清楚地说明这一点：'
- en: 'To demonstrate, create an array with `arange()`, which of course is sorted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示，使用`arange()`创建一个数组，该数组当然被排序：
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Time to call the `searchsorted()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候调用`searchsorted()`函数了：
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The indices, which should maintain the sort order:'
  prefs: []
  type: TYPE_NORMAL
  zh: 索引，应保持排序顺序：
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Construct the full array with the `insert()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`insert（）`函数构造完整的数组：
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This gives us the full array:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们完整的数组：
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'The `searchsorted()` function gave us indices `5` and `0` for `7` and `-2`.
    With these indices, we made the `array [-2, 0, 1, 2, 3, 4, 7]`, so the array remains
    sorted (see `sortedsearch.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: '`searchsorted()`函数为我们提供了`7`和`-2`的索引`5`和`0`。 使用这些索引，我们将数组设置为`array [-2, 0, 1,
    2, 3, 4, 7]`，因此数组保持排序状态（请参见`sortedsearch.py`）：'
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Array elements extraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组元素提取
- en: The NumPy `extract()` function allows us to extract items from an array based
    on a condition. This function is similar to the `where()` function we encountered
    in [Chapter 3](ch03.html "Chapter 3. Getting Familiar with Commonly Used Functions"),
    *Getting Familiar with Commonly Used Functions*. The special `nonzero()` function
    selects non-zero elements.
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy `extract()`函数使我们可以根据条件从数组中提取项目。 此函数类似于第 3 章，“我们熟悉的函数”。 特殊的`nonzero()`函数选择非零元素。
- en: Time for action – extracting elements from an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：从数组中提取元素
- en: 'Let''s extract the even elements of an array:'
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提取数组的偶数元素：
- en: 'Create the array with the `arange()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`arange()`函数创建数组：
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create the condition that selects the even elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建选择偶数元素的条件：
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Extract the even elements using our condition with the `extract()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的条件和`extract()`函数提取偶数元素：
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This gives us the even numbers as required (`np.extract(condition, a)` is equivalent
    to `a[np.where(condition)[0]]`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了所需的偶数（`np.extract(condition, a)`等于`a[np.where(condition)[0]]`）：
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Select non-zero values with the `nonzero()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`nonzero()`函数选择非零值：
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This prints all the non-zero values of the array:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印数组的所有非零值：
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We extracted the even elements from an array using a Boolean condition with
    the NumPy `extract()` function (see `extracted.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用布尔值条件和 NumPy `extract()`函数从数组中提取了偶数元素（请参见`extracted.py`）：
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Financial functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 财务函数
- en: 'NumPy has a number of financial functions:'
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 具有多种财务函数：
- en: The `fv()` function calculates the so-called **future** **value**. The future
    value gives the value of a financial instrument at a future date, based on certain
    assumptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fv()`函数计算出所谓的**未来值**。 未来值基于某些假设，给出了金融产品在未来日期的价值。'
- en: The `pv()` function computes the present value (see [https://www.khanacademy.org/economics-finance-domain/core-finance/interest-tutorial/present-value/v/time-value-of-money](https://www.khanacademy.org/economics-finance-domain/core-finance/interest-tutorial/present-value/v/time-value-of-money)).
    The present value is the value of an asset today.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pv()`函数计算当前值（请参阅[这里](https://www.khanacademy.org/economics-finance-domain/core-finance/interest-tutorial/present-value/v/time-value-of-money)）。
    当前值是今天的资产价值。'
- en: The `npv()` function returns the **net** **present** **value**. The net present
    value is defined as the sum of all the present value cash flows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npv()`函数返回**净当前值**。 净当前值定义为所有当前现金流的总和。'
- en: The `pmt()` function computes the **payment** **against** **loan** principal
    plus interest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pmt()`函数计算**借贷还款的本金加上利息**。'
- en: The `irr()` function calculates the **internal** **rate** **of** **return**.
    The internal rate of return is the effective interested rate, which does not take
    into account inflation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irr()`函数计算的**内部收益率**。 内部收益率是实际利率，  未将通货膨胀考虑在内。'
- en: The `mirr()` function calculates the **modified** **internal** **rate** **of**
    **return**. The modified internal rate of return is an improved version of the
    internal rate of return.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mirr()`函数计算**修正的内部收益率**。 修正的内部收益率是内部收益率的改进版本。'
- en: The `nper()` function returns the **number** **of** **periodic** **payments**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nper()`函数返回**定期付款数值**。'
- en: The `rate()` function calculates the **rate** **of** **interest**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rate()`函数计算**利率**。'
- en: Time for action – determining the future value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：确定未来值
- en: The future value gives the value of a financial instrument at a future date,
    based on certain assumptions. The future value depends on four parameters—the
    interest rate, the number of periods, a periodic payment, and the present value.
  prefs: []
  type: TYPE_NORMAL
  zh: 未来值根据某些假设给出了金融产品在未来日期的价值。 终值取决于四个参数-利率，周期数，定期付款和当前值。
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'Read more about future value at [http://en.wikipedia.org/wiki/Future_value](http://en.wikipedia.org/wiki/Future_value).
    The formula for future value with compound interest is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在[这个页面](http://en.wikipedia.org/wiki/Future_value)上阅读更多关于未来值的东西。 具有复利的终值的公式如下：
- en: '![Time for action – determining the future value](graphics/4154_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – determining the future value](img/4154_07_09.jpg)'
- en: In the preceding formula, *PV* is the present value, *r* is the interest rate,
    and *n* is the number of periods.
  prefs: []
  type: TYPE_NORMAL
  zh: 在上式中， `PV`是当前值，`r`是利率，`n`是周期数。
- en: 'In this section, let''s take an interest rate of `3` percent, a quarterly payment
    of `10` for `5` years, and a present value of `1000`. Call the `fv()` function
    with the appropriate values (negative values represent outgoing cash flow):'
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们以`3`% 的利率，`5`年的季度`10`的季度付款以及`1000`的当前值。 用适当的值调用`fv()`函数（负值表示支出现金流）：
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The future value is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 终值如下：
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we vary the number of years we save and keep the other parameters constant,
    we get the following plot:'
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改变保存和保持其他参数不变的年数，则会得到以下图表：
- en: '![Time for action – determining the future value](graphics/4154_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – determining the future value](img/4154_07_01.jpg)'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We calculated the future value using the NumPy `fv()` function starting with
    a present value of `1000`, an interest rate of `3` percent, and quarterly payments
    of `10` for `5` years. We plotted the future value for various saving periods
    (see `futurevalue.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 NumPy `fv()`函数从`1000`的当前值，`3`的利率，`5`年和`10`的季度付款开始计算未来值。 。 我们绘制了各种保存期的未来值（请参见`futurevalue.py`）：
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Present value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当前值
- en: The present value is the value of an asset today. The NumPy `pv()` function
    can calculate the present value. This function mirrors the `fv()` function and
    requires the interest rate, number of periods, and the periodic payment as well,
    but here we start with the future value.
  prefs: []
  type: TYPE_NORMAL
  zh: 当前值是今天的资产价值。 NumPy `pv()`函数可以计算当前值。 此函数与`fv()`函数类似，并且需要利率，期间数和定期还款，但是这里我们从终值开始。
- en: Read more about the present value at [http://en.wikipedia.org/wiki/Present_value](http://en.wikipedia.org/wiki/Present_value).
    It should be easy to derive the formula for the present value from the formula
    for the future value, if you want.
  prefs: []
  type: TYPE_NORMAL
  zh: '[了解有关当前值的更多信息](http://en.wikipedia.org/wiki/Present_value)。 如果需要，可以很容易地从将来值的公式中得出当前值的公式。'
- en: Time for action – getting the present value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：获得当前值
- en: 'Let''s reverse compute the present value with the numbers from the *Time for
    action – determining the future value* section:'
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将“实战时间：确定未来值”中的数字反转：
- en: 'Plug in the figures from the *Time for action – determining the future value*
    section:'
  prefs: []
  type: TYPE_NORMAL
  zh: 插入“实战时间：确定未来值”部分：
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This gives us `1000` as expected apart from a tiny numerical error. Actually,
    it is not an error but a representation issue. We are dealing here with outgoing
    cash flow, that is the reason for the negative value:'
  prefs: []
  type: TYPE_NORMAL
  zh: 除了微小的数值误差外，这给了我们`1000`预期的效果。 实际上，这不是错误，而是表示问题。 我们在这里处理现金流出，这就是负值的原因：
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We did the reverse computation of the *Time for action – determining the future
    value* section to get the present value from the future value. This was done with
    the NumPy `pv()` function.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们反转了“实战时间：确定将来值”部分，以从将来值中获得当前值。 这是通过 NumPy `pv()`函数完成的。
- en: Net present value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 净当前值
- en: 'The net present value is defined as the sum of all the present value cash flows.
    The NumPy `npv()` function returns the net present value of cash flows. The function
    requires two arguments: the rate and an array representing the cash flows.'
  prefs: []
  type: TYPE_NORMAL
  zh: 净当前值定义为所有当前值现金流的总和。 NumPy `npv()`函数返回现金流的净当前值。 该函数需要两个参数：`rate`和代表现金流的数组。
- en: 'Read more about the net present value at [http://en.wikipedia.org/wiki/Net_present_value](http://en.wikipedia.org/wiki/Net_present_value).
    In the formula of the net present value, *R* *t* is the cash flow of a time period,
    *r* is the discount rate, and *t* is the index of the time period:'
  prefs: []
  type: TYPE_NORMAL
  zh: '[阅读有关净当前值的更多信息](http://en.wikipedia.org/wiki/Net_present_value)，。 在净当前值的公式中，
    `Rt`是时间段的现金流，`r`是折现率，`t`是时间段的指数：'
- en: ''
  prefs: []
  type: TYPE_IMG
  zh: '![Net present value](img/4154_07_10.jpg)'
- en: ''
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：计算净当前值
- en: '![Net present value](graphics/4154_07_10.jpg)<title>Time for action – calculating
    the net present value</title><link href="epub.css" rel="stylesheet" type="text/css">'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将计算随机产生的现金流序列的净当前值：
- en: Time for action – calculating the net present value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ''
- en: 'We will calculate the net present value for a random generated cash flow series:'
  prefs: []
  type: TYPE_NORMAL
  zh: ''
- en: 'Generate five random values for the cash flow series. Insert `-100` as the
    start value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为现金流量序列生成五个随机值。 插入 -100 作为起始值：
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The cash flows would be as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 现金流如下：
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Call the `npv()` function to calculate the net present value from the cash
    flow series we generated in the previous step. Use a rate of `3` percent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`npv()`函数从上一步生成的现金流量序列中计算净当前值。 使用百分之三的比率：
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The net present value:'
  prefs: []
  type: TYPE_NORMAL
  zh: 净当前值：
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We computed the net present value from a random generated cash flow series
    with the NumPy `npv()` function (see `netpresentvalue.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 NumPy `npv()`函数（请参见`netpresentvalue.py`）从随机生成的现金流序列中计算出净当前值：
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Internal rate of return
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部收益率
- en: The internal rate of return is the effective interested rate, which does not
    take into account inflation. The NumPy `irr()` function returns the internal rate
    of return for a given cash flow series.
  prefs: []
  type: TYPE_NORMAL
  zh: 收益率的内部利率是有效利率，它没有考虑通货膨胀。 NumPy `irr()`函数返回给定现金流序列的内部收益率。
- en: Time for action – determining the internal rate of return
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：确定内部收益率
- en: 'Let''s reuse the cash flow series from the *Time for action – calculating the
    net present value* section. Call the `irr()` function with the cash flow series
    from the *Time for action* section:'
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重用“实战时间：计算净当前值”部分的现金流序列。 在现金流序列上调用`irr()`函数：
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The internal rate of return:'
  prefs: []
  type: TYPE_NORMAL
  zh: 内部收益率：
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We calculated the internal rate of return from the cash flow series of the *Time
    for action – calculating the net present value* section. The value was given by
    the NumPy `irr()` function.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据“实战时间：计算净当前值”部分的现金流系列计算内部收益率。 该值由 NumPy `irr()`函数给出。
- en: Periodic payments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定期付款
- en: The NumPy `pmt()` function allows you to compute periodic payments for a loan,
    based on an interest rate and the number of periodic payments.
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy `pmt()`函数允许您基于利率和定期还款次数来计算贷款的定期还款。
- en: Time for action – calculating the periodic payments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：计算定期付款
- en: Suppose you have a loan of 10 million with an interest rate of `1` percent.
    You have `30` years to pay the loan back. How much do you have to pay each month?
    Let's find out.
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的贷款为 1000 万，利率为`1`%。 您有`30`年还清贷款。 您每个月要付多少钱？ 让我们找出答案。
- en: 'Call the `pmt()` function with the aforementioned values:'
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述值调用`pmt()`函数：
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The monthly payment:'
  prefs: []
  type: TYPE_NORMAL
  zh: 每月付款：
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We calculated the monthly payment for a loan of 10 million at an annual rate
    of `1` percent. Given that we have `30` years to repay the loan the `pmt()` function
    tells us that we need to pay `32163.95` per month.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以每年`1`% 的利率计算了 1000 万的贷款的每月付款。 鉴于我们有`30`年的还款期，`pmt()`函数告诉我们我们需要每月支付`32163.95`。
- en: Number of payments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 付款次数
- en: The NumPy `nper()` function tells us how many periodic payments are necessary
    to pay off a loan. The required parameters are the interest rate of the loan,
    the fixed amount periodic payment, and the present value.
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy `nper()`函数告诉我们要偿还贷款需要多少次定期付款。 必需的参数是贷款的利率，固定金额的定期还款以及当前值。
- en: Time for action – determining the number of periodic payments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：确定定期付款的次数
- en: Consider a loan of `9000` at a rate of `10` percent with fixed monthly payments
    of `100`.
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一笔`9000`的贷款，其利率为`10`% ，固定每月还款`100`。
- en: 'Find out how many payments are required with the NumPy `nper()` function:'
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NumPy `nper()`函数找出需要多少笔付款：
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The number of payments:'
  prefs: []
  type: TYPE_NORMAL
  zh: 付款次数：
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We determined the number of payments needed to pay off a loan of `9000` with
    an interest rate of `10` percent and monthly payments of `100`. The number of
    payments returned was `167`.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确定了还清利率为`10`的`9000`贷款和`100`每月还款所需的还款次数。 返回的付款数为`167`。
- en: Interest rate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利率
- en: The NumPy `rate()` function calculates the interest rate given the number of
    periodic payments, the payment amount or amounts, the present value, and the future
    value.
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy `rate()`函数根据给定的定期付款次数，  付款金额，当前值和终值来计算利率。
- en: Time for action – figuring out the rate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：确定利率
- en: Let's take the values from the *Time for action – determining the number of
    periodic payments* section and reverse compute the interest rate from the other
    parameters.
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从“实战时间：确定定期付款的数量”部分的值，并从其他参数反向计算利率。
- en: 'Fill in the numbers from the previous *Time for action* section:'
  prefs: []
  type: TYPE_NORMAL
  zh: 填写上一个“实战时间”部分中的数字：
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The interest rate is approximately 10 percent as expected:'
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的利率约为 10%：
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We used the NumPy `rate()` function and the values from the *Time for action
    – determining the number of periodic payments* section to compute the interest
    rate of the loan. Ignoring the rounding errors, we got the initial `10` percent
    we started with.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 NumPy `rate()`函数和“实战时间：确定定期付款的数量”部分的值来计算贷款的利率。 忽略舍入错误，我们得到了最初的`10`百分比。
- en: Window functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 窗口函数
- en: 'Window functions are mathematical functions commonly used in signal processing.
    Applications include spectral analysis and filter design. These functions are
    defined to be 0 outside a specified domain. NumPy has a number of window functions:
    `bartlett()`, `blackman()`, `hamming()`, `hanning()`, and `kaiser()`. You can
    find an example of the `hanning()` function in [Chapter 4](ch04.html "Chapter 4. Convenience
    Functions for Your Convenience"), *Convenience Functions for Your Convenience*,
    and [Chapter 3](ch03.html "Chapter 3. Getting Familiar with Commonly Used Functions"),
    *Getting Familiar with Commonly Used Functions*.'
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口函数是信号处理中常用的数学函数。 应用包括光谱分析和过滤器设计。 这些函数在指定域之外定义为 0。 NumPy 具有许多窗口函数：`bartlett()`，`blackman()`，`hamming()`，`hanning()`和`kaiser()`。
    您可以在第 4 章，“便捷函数”和第 3 章，“熟悉常用函数”。
- en: Time for action – plotting the Bartlett window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：绘制 Bartlett 窗口
- en: 'The Bartlett window is a triangular smoothing window:'
  prefs: []
  type: TYPE_NORMAL
  zh: Bartlett 窗口是三角形平滑窗口：
- en: '![Time for action – plotting the Bartlett window](graphics/4154_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – plotting the Bartlett window](img/4154_07_11.jpg)'
- en: 'Call the NumPy `bartlett()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用  NumPy `bartlett()`函数：
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Plotting is easy with matplotlib:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 matplotlib 进行绘图很容易：
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following is the Bartlett window, which is triangular, as expected:'
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，这是 Bartlett 窗口，该窗口是三角形的：
- en: '![Time for action – plotting the Bartlett window](graphics/4154_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – plotting the Bartlett window](img/4154_07_02.jpg)'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We plotted the Bartlett window with the NumPy `bartlett()` function.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用 NumPy `bartlett()`函数绘制了 Bartlett 窗口。
- en: Blackman window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布莱克曼窗口
- en: 'The Blackman window is the sum of the following cosines:'
  prefs: []
  type: TYPE_NORMAL
  zh: 布莱克曼窗口是以下余弦的和：
- en: '![Blackman window](graphics/4154_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Blackman window](img/4154_07_12.jpg)'
- en: The NumPy `blackman()` function returns the Blackman window. The only parameter
    is the number of points `M` in the output window. If this number is `0` or less
    than `0`, the function returns an empty array.
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy `blackman()`函数返回布莱克曼窗口。 唯一参数是输出窗口中`M`的点数。 如果该数字为`0`或小于`0`，则该函数返回一个空数组。
- en: Time for action – smoothing stock prices with the Blackman window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：使用布莱克曼窗口平滑股票价格
- en: 'Let''s smooth the close prices from the small AAPL stock prices data file:'
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从小型`AAPL`股价数据文件中平滑收盘价：
- en: 'Load the data into a NumPy array. Call the NumPy `blackman()` function to form
    a window, and then use this window to smooth the price signal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据加载到 NumPy 数组中。 调用 NumPy `blackman()`函数形成一个窗口，然后使用该窗口平滑价格信号：
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Plot the smoothed prices with matplotlib. In this example, we will omit the
    first five data points and the last five data points. The reason for this is that
    there is a strong boundary effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 matplotlib 绘制平滑价格。 在此示例中，我们将省略前五个数据点和后五个数据点。 这样做的原因是存在强烈的边界效应：
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The closing prices of AAPL smoothed with the Blackman window should appear
    as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 使用布莱克曼窗口平滑的`AAPL`收盘价应如下所示：
- en: '![Time for action – smoothing stock prices with the Blackman window](graphics/4154_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – smoothing stock prices with the Blackman window](img/4154_07_03.jpg)'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We plotted the closing price of AAPL from our sample data file that was smoothed
    using the Blackman window with the NumPy `blackman()` function (see `plot_blackman.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从样本数据文件中绘制了`AAPL`的收盘价，该价格使用布莱克曼窗口和 NumPy `blackman()`函数进行了平滑处理（请参见`plot_blackman.py`）：
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Hamming window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汉明窗口
- en: 'The Hamming window is formed by a weighted cosine. The formula is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 汉明窗由加权余弦形成。 计算公式如下：
- en: '![Hamming window](graphics/4154_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Hamming window](img/4154_07_13.jpg)'
- en: The NumPy `hamming()` function returns the Hamming window. The only parameter
    is the number of points `M` in the output window. If this number is `0` or less
    than `0`, an empty array is returned.
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy `hamming()`函数返回汉明窗口。 唯一的参数是输出窗口中点的数量`M`。 如果此数字为`0`或小于`0`，则返回一个空数组。
- en: Time for action – plotting the Hamming window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：绘制汉明窗口
- en: 'Let''s plot the Hamming window:'
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制汉明窗口：
- en: 'Call the NumPy `hamming()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 NumPy `hamming()`函数：
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Plot the window with matplotlib:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 matplotlib 绘制窗口：
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The Hamming window plot appears as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 汉明窗图显示如下：
- en: '![Time for action – plotting the Hamming window](graphics/4154_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – plotting the Hamming window](img/4154_07_04.jpg)'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We plotted the Hamming window with the NumPy `hamming()` function.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 NumPy `hamming()`函数绘制了汉明窗口。
- en: Kaiser window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 凯撒窗口
- en: The **Kaiser** **window** is formed by the **Bessel** **function**.
  prefs: []
  type: TYPE_NORMAL
  zh: '**凯撒窗口**由**贝塞尔**函数形成。'
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Bessel functions are solutions of the Bessel differential equations (see [http://en.wikipedia.org/wiki/Bessel_function](http://en.wikipedia.org/wiki/Bessel_function)).
  prefs: []
  type: TYPE_NORMAL
  zh: '[贝塞尔函数是贝塞尔微分方程的解](http://en.wikipedia.org/wiki/Bessel_function)。'
- en: 'The formula is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 公式如下：
- en: '![Kaiser window](graphics/4154_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Kaiser window](img/4154_07_14.jpg)'
- en: Here I[0] is the zero order Bessel function. The NumPy `kaiser()` function returns
    the **Kaiser** window. The first parameter is the number of points in the output
    window. If this number is `0` or less than `0`, the function returns an empty
    array. The second parameter is the beta.
  prefs: []
  type: TYPE_NORMAL
  zh: '`I0`是零阶贝塞尔函数。 NumPy `kaiser()`函数返回**凯撒**窗口。 第一个参数是输出窗口中的点数。 如果此数字为`0`或小于`0`，则函数将返回一个空数组。
    第二个参数是`beta`。'
- en: Time for action – plotting the Kaiser window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：绘制凯撒窗口
- en: 'Let''s plot the Kaiser window:'
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制凯撒窗口：
- en: 'Call the NumPy `kaiser()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 NumPy `kaiser()`函数：
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Plot the window with matplotlib:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 matplotlib 绘制窗口：
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The Kaiser window appears as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒窗口显示如下：
- en: '![Time for action – plotting the Kaiser window](graphics/4154_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – plotting the Kaiser window](img/4154_07_05.jpg)'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We plotted the Kaiser window with the NumPy `kaiser()` function.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 NumPy `kaiser()`函数绘制了凯撒窗口。
- en: Special mathematical functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊数学函数
- en: We will end this chapter with some special mathematical functions. The modified
    Bessel function of the first kind 0th order is represented in NumPy by `i0()`.
    The `sinc` function is represented in NumPy by a function with the same name,
    and there is also a two-dimensional version of this function. **Sinc** is a trigonometric
    function; for more details, see [http://en.wikipedia.org/wiki/Sinc_function](http://en.wikipedia.org/wiki/Sinc_function).
    The `sinc()` function has two definitions.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一些特殊的数学函数结束本章。 第一类 0 阶的修正的贝塞尔函数由`i0()`表示为 NumPy 中的  。 `sinc`函数在 NumPy 中由具有相同名称的函数表示，  也有此函数的二维版本。
    `sinc`是三角函数； 有关更多详细信息，请参见[这里](http://en.wikipedia.org/wiki/Sinc_function)。 `sinc()`函数具有两个定义。
- en: 'The NumPy `sinc()` function complies with the following definition:'
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy `sinc()`函数符合以下定义：
- en: ''
  prefs: []
  type: TYPE_IMG
  zh: '![Special mathematical functions](img/4154_07_15.jpg)'
- en: ''
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：绘制修正的贝塞尔函数
- en: '![Special mathematical functions](graphics/4154_07_15.jpg)<title>Time for action
    – plotting the modified Bessel function</title><link href="epub.css" rel="stylesheet"
    type="text/css">'
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看修正的第一种零阶贝塞尔函数是什么样的：
- en: Time for action – plotting the modified Bessel function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ''
- en: 'Let''s see what the modified Bessel function of the first kind 0th order looks
    like:'
  prefs: []
  type: TYPE_NORMAL
  zh: ''
- en: 'Compute evenly spaced values with the NumPy `linspace()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 NumPy `linspace()`函数计算均匀间隔的值：
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Call the NumPy `i0()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 NumPy `i0()`函数：
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Plot the modified Bessel function with matplotlib:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 matplotlib 绘制修正的贝塞尔函数：
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The modified Bessel function will have the following output:'
  prefs: []
  type: TYPE_NORMAL
  zh: 修正的贝塞尔函数将具有以下输出：
- en: '![Time for action – plotting the modified Bessel function](graphics/4154_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – plotting the modified Bessel function](img/4154_07_06.jpg)'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We plotted the modified Bessel function of the first kind 0th order with the
    NumPy `i0()` function.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用 NumPy `i0()`函数绘制了第一种零阶修正的贝塞尔函数。
- en: sinc
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`sinc`'
- en: The `sinc()` function is widely used in mathematics and signal processing. NumPy
    has a function with the same name. A two-dimensional function exists as well.
  prefs: []
  type: TYPE_NORMAL
  zh: '`sinc()`函数广泛用于数学和信号处理中。 NumPy 具有相同名称的函数。 也存在二维函数。'
- en: Time for action – plotting the sinc function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：绘制`sinc`函数
- en: 'We will plot the `sinc()` function:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绘制`sinc()`函数：
- en: 'Compute evenly spaced values with the NumPy `linspace()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 NumPy `linspace()`函数计算均匀间隔的值：
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Call the NumPy `sinc()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 NumPy `sinc()`函数：
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Plot the `sinc()` function with matplotlib:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用 matplotlib 绘制`sinc()`函数：
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `sinc()` function will have the following output:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`sinc()`函数将具有以下输出：'
- en: '![Time for action – plotting the sinc function](graphics/4154_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – plotting the sinc function](img/4154_07_07.jpg)'
- en: 'The `sinc2d()` function requires a two-dimensional array. We can create it
    with the `outer()` function, resulting in this plot (code is in the following
    section):'
  prefs: []
  type: TYPE_NORMAL
  zh: '`sinc2d()`函数需要二维数组。 我们可以使用`outer()`函数创建它，从而得到该图（代码在以下部分中）：'
- en: '![Time for action – plotting the sinc function](graphics/4154_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – plotting the sinc function](img/4154_07_08.jpg)'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We plotted the well-known `sinc` function with the NumPy `sinc()` function
    (see `plot_sinc.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用 NumPy `sinc()`函数（参见`plot_sinc.py`）绘制了众所周知的`sinc`函数：
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We did the same for two dimensions (see `sinc2d.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在两个维度上都做了相同的操作（请参见`sinc2d.py`）：
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This was a special chapter covering more specialized NumPy topics. We covered
    sorting and searching, special functions, financial utilities, and window functions.
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章，涵盖了更多专门的 NumPy 主题。 我们介绍了排序和搜索，特殊函数，财务工具和窗口函数。
- en: The next chapter is about the very important subject of testing.
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是关于非常重要的测试主题的。

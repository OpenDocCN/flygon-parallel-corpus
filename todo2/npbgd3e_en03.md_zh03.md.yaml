- en: Chapter 3. Getting Familiar with Commonly Used Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三、熟悉常用函数
- en: '*In this chapter, we will have a look at common NumPy functions. In particular,
    we will learn how to load data from files by using an example involving historical
    stock prices. Also, we will get to see the basic NumPy mathematical and statistical
    functions.*'
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍常见的 NumPy 函数。 特别是，我们将通过一个涉及历史股价的示例来学习如何从文件加载数据。 此外，我们还将了解 NumPy 的基本数学和统计函数。
- en: '*We will learn how to read from and write to files. Also, we will get a taste
    of the functional programming and linear algebra possibilities in NumPy.*'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何读写文件。 此外，我们还将品尝 NumPy 中的函数式编程和线性代数的可能性。
- en: 'In this chapter, we shall cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Functions working on arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组上的函数
- en: Loading arrays from files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件加载数组
- en: Writing arrays to files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数组写入文件
- en: Simple mathematical and statistical functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的数学和统计函数
- en: File I/O
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件 I/O
- en: First, we will learn about file I/O with NumPy. Data is usually stored in files.
    You would not get far if you were not able to read from and write to files.
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将学习如何使用 NumPy 进行文件 I/O。 数据通常存储在文件中。 如果您无法读取和写入文件，您将走不远。
- en: Time for action – reading and writing files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 读写文件
- en: As an example of file I/O, we will create an identity matrix and store its contents
    in a file.
  prefs: []
  type: TYPE_NORMAL
  zh: 作为文件 I/O 的示例，我们将创建一个单位矩阵并将其内容存储在文件中。
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'In this and other chapters, we will use the following line by convention to
    import NumPy:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和其他章中，我们将按照约定使用以下行导入 NumPy：
- en: '`import numpy as np`'
  prefs: []
  type: TYPE_NORMAL
  zh: '`import numpy as np`'
- en: 'Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
  zh: 请执行以下步骤：
- en: The identity matrix is a square matrix with ones on the main diagonal and zeros
    for the rest (see [https://www.khanacademy.org/math/precalculus/precalc-matrices/zero-identity-matrix-tutorial/v/identity-matrix](https://www.khanacademy.org/math/precalculus/precalc-matrices/zero-identity-matrix-tutorial/v/identity-matrix)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[单位矩阵是一个正方形矩阵，在主对角线上有一，其余部分为零](https://www.khanacademy.org/math/precalculus/precalc-matrices/zero-identity-matrix-tutorial/v/identity-matrix)。'
- en: 'The identity matrix can be created with the `eye()` function. The only argument
    that we need to give the `eye()` function is the number of ones. So, for instance,
    for a two-by-two matrix, write the following code:'
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`eye()`函数创建单位矩阵。 我们需要给`eye()`函数的唯一参数是个数。 因此，例如对于一个二乘二的矩阵，编写以下代码：
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
  zh: 输出为：
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Save the data in a plain text file with the `savetxt()` function. Specify the
    name of the file that we want to save the data in and the array containing the
    data itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`savetxt()`函数将数据保存在纯文本文件中。 指定我们要在其中保存数据的文件的名称以及包含数据本身的数组：
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A file called `eye.txt` should have been created in the same directory as the
    Python script.
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在与 Python 脚本相同的目录中创建名为`eye.txt`的文件。
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: Reading and writing files is a necessary skill for data analysis. We wrote to
    a file with `savetxt()`. We made an identity matrix with the `eye()` function.
  prefs: []
  type: TYPE_NORMAL
  zh: 读写文件是数据分析的必要技能。 我们使用`savetxt()`写入文件。 我们使用`eye()`函数制作了一个单位矩阵。
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of a filename, we can also provide a **file handle**. A file handle
    is a term in many programming languages, which means a variable pointing to a
    file, like a postal address. For more information on how to get a file handle
    in Python, please refer to [http://www.diveintopython3.net/files.html](http://www.diveintopython3.net/files.html).
  prefs: []
  type: TYPE_NORMAL
  zh: 除了文件名，我们还可以提供**文件句柄**。 文件句柄是许多编程语言中的术语，它表示指向文件的变量，例如邮政地址。 有关如何在 Python 中获取文件句柄的更多信息，请参考[这里](http://www.diveintopython3.net/files.html)。
- en: 'You can check for yourself whether the contents are as expected. The code for
    this example can be downloaded from the book support website: [https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)
    (see `save.py`)'
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自己检查内容是否符合预期。 可以[从图书支持网站下载此示例的代码](https://www.packtpub.com/books/content/support)（请参阅`save.py`）。
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Comma-seperated value files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逗号分隔值文件
- en: Files in the **Comma-seperated value** (**CSV**) format are encountered quite
    frequently. Often, the CSV file is just a dump from a database. Usually, each
    field in the CSV file corresponds to a database table column. As we all know,
    spreadsheet programs, such as Excel, can produce CSV files, as well.
  prefs: []
  type: TYPE_NORMAL
  zh: 经常遇到**逗号分隔值**（**CSV**）格式的文件。 通常，CSV 文件只是数据库中的转储。 通常，CSV 文件中的每个字段都对应一个数据库表列。
    众所周知，电子表格程序（例如 Excel）也可以生成 CSV 文件。
- en: Time for action – loading from CSV files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 从 CSV 文件加载
- en: 'How do we deal with CSV files? Luckily, the `loadtxt()` function can conveniently
    read CSV files, split up the fields, and load the data into NumPy arrays. In the
    following example, we will load historical stock price data for Apple (the company,
    not the fruit). The data is in CSV format and is part of the code bundle for this
    book. The first column contains a symbol that identifies the stock. In our case,
    it is AAPL. Second is the date in dd-mm-yyyy format. The third column is empty.
    Then, in order, we have the open, high, low, and close price. Last, but not least,
    is the trading volume of the day. This is what a line looks like:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理 CSV 文件？ 幸运的是，`loadtxt()`函数可以方便地读取 CSV 文件，拆分字段并将数据加载到 NumPy 数组中。 在以下示例中，我们将加载苹果（公司而不是水果）的历史股价数据。
    数据为 CSV 格式，是本书代码集的一部分。 第一列包含一个标识股票的符号。 在我们的情况下，它是`AAPL`。 第二个是`dd-mm-yyyy`格式的日期。
    第三列为空。 然后，依次获得开盘价，最高价，最低价和收盘价。 最后但并非最不重要的是当天的交易量。 这是一行的样子：
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For now, we are only interested in the close price and volume. In the preceding
    sample, that will be `336.1` and `21144800`. Store the close price and volume
    in two arrays as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们仅对收盘价和交易量感兴趣。 在前面的示例中，将是`336.1`和`21144800`。 将收盘价和成交量存储在两个数组中，如下所示：
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, data is stored in the `data.csv` file. We have set the delimiter
    to, (`comma`), since we are dealing with a CSV file. The `usecols` parameter is
    set through a tuple to get the seventh and eighth fields, which correspond to
    the close price and volume. The `unpack` argument is set to `True`, which means
    that data will be unpacked and assigned to the `c` and `v` variables that will
    hold the close price and volume, respectively.
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，数据存储在`data.csv`文件中。 由于我们正在处理 CSV 文件，因此已将定界符设置为（`comma`）。 通过元组设置`usecols`参数以获得与收盘价和交易量相对应的第七和第八字段。
    `unpack`参数设置为`True`，这意味着数据将被解包并分配给分别保持收盘价和交易量的`c`和`v`变量。
- en: Volume Weighted Average Price
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交易量加权平均价格
- en: '**Volume Weighted Average Price** (**VWAP**) is a very important quantity in
    finance. It represents an average price for a financial asset (see [https://www.khanacademy.org/math/probability/descriptive-statistics/old-stats-videos/v/statistics-the-average](https://www.khanacademy.org/math/probability/descriptive-statistics/old-stats-videos/v/statistics-the-average)).
    The higher the volume, the more significant a price move typically is. VWAP is
    often used in algorithmic trading and is calculated using volume values as weights.'
  prefs: []
  type: TYPE_NORMAL
  zh: '**交易量加权平均价格**（**VWAP**）在金融中非常重要。 它代表金融资产的平均价格（请参阅 [https://www.khanacademy.org/math/probability/descriptive-statistics/old-stats-videos/
    v / statistics-the-average](https://www.khanacademy.org/math/probability/descriptive-statistics/old-stats-videos/v/statistics-the-average)
    ）。 的数量越大，价格走势通常越明显。 VWAP 通常用于算法交易中，并使用交易量值作为权重进行计算。'
- en: Time for action – calculating Volume Weighted Average Price
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 计算交易量加权平均价格
- en: 'The following are the actions that we will take:'
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将要采取的行动：
- en: Read the data into arrays.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据读入数组。
- en: 'Calculate VWAP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 VWAP：
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: That wasn't very hard, was it? We just called the `average()` function and set
    its `weights` parameter to use the `v` array for weights. By the way, NumPy also
    has a function to calculate the arithmetic mean. This is an unweighted average
    with all the weights equal to `1`.
  prefs: []
  type: TYPE_NORMAL
  zh: 那不是很难，不是吗？ 我们只是调用了`average()`函数，并将其`weights`参数设置为将`v`数组用于权重。 顺便说一下，NumPy 还具有计算算术平均值的函数。
    这是所有权重均等于`1`的未加权平均值。
- en: The mean() function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`mean()`函数'
- en: The `mean()` function is quite friendly and not so mean. This function calculates
    the arithmetic mean of an array.
  prefs: []
  type: TYPE_NORMAL
  zh: '`mean()`函数是相当友好，并不是那么卑鄙。 此函数计算数组的算术平均值。'
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The arithmetic mean is given by the following formula:'
  prefs: []
  type: TYPE_NORMAL
  zh: 的算术平均值是由以下公式给出的  ：
- en: '![The mean() function](graphics/4154_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![The mean() function](img/4154_03_07.jpg)'
- en: It sums the values in an array `a` and divides the sum by the number of elements
    `n` (see [https://www.khanacademy.org/math/probability/descriptive-statistics/central_tendency/e/mean_median_and_mode](https://www.khanacademy.org/math/probability/descriptive-statistics/central_tendency/e/mean_median_and_mode)).
  prefs: []
  type: TYPE_NORMAL
  zh: 它对数组`a`中的值求和，[然后将总和除以元素数`n`](https://www.khanacademy.org/math/probability/descriptive-statistics/central_tendency/e/mean_median_and_mode)。
- en: 'Let''s see it in action:'
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的运行情况  ：
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As a result, we get the following printout:'
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们得到以下打印输出：
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Time-weighted average price
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间加权平均价格
- en: 'In finance, **time-weighted average price (TWAP)** is another average price
    measure. Now that we are at it, let''s compute the TWAP too. It is just a variation
    on a theme really. The idea is that recent price quotes are more important, so
    we should give recent prices higher weights. The easiest way is to create an array
    with the `arange()` function of increasing values from zero to the number of elements
    in the close price array. This is not necessarily the correct way. In fact, most
    of the examples concerning stock price analysis in this book are only illustrative.
    The following is the TWAP code:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在金融领域，**时间加权平均价格（TWAP）**是另一种平均价格指标。 现在，我们也计算 TWAP。 这实际上只是一个主题的变体。 这个想法是，最近的报价更为重要，因此我们应该给近期的价格赋予更大的权重。
    最简单的方法是使用`arange()`函数创建一个数组，该函数将值从零增加到收盘价数组中的元素数量。 这不一定是正确的方法。 实际上，本书中有关股票价格分析的大多数示例只是说明性的。
    以下是 TWAP 代码：
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It produces the following output:'
  prefs: []
  type: TYPE_NORMAL
  zh: 它产生以下输出：
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The TWAP is even higher than the mean.
  prefs: []
  type: TYPE_NORMAL
  zh: TWAP 甚至高于平均值。
- en: Pop quiz – computing the weighted average
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小测验 - 计算加权平均值
- en: Q1\. Which function returns the weighted average of an array?
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 哪个函数返回数组的加权平均值？
- en: weighted average
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`weighted_average`'
- en: waverage
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`waverage`'
- en: average
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`average`'
- en: avg
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`avg`'
- en: Have a go hero – calculating other averages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 勇往直前 – 计算其他平均值
- en: Try doing the same calculation using the open price. Calculate the mean for
    the volume and the other prices.
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用开盘价进行相同的计算。 计算数量和其他价格的平均值。
- en: Value range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值的范围
- en: Usually, we don't only want to know the average or arithmetic mean of a set
    of values, which are in the middle, to know we also want the extremes, the full
    range—the highest and lowest values. The sample data that we are using here already
    has those values per day—the high and low price. However, we need to know the
    highest value of the high price and the lowest price value of the low price.
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不仅希望知道中间值的一组值的平均值或算术平均值，还希望知道极端值，整个范围（最高和最低值） 。 我们在此处使用的样本数据每天已经具有这些值-高价和低价。
    但是，我们需要知道高价的最高价和低价的最低价。
- en: Time for action – finding highest and lowest values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 找到最高和最低值
- en: 'The `min()` and `max()` functions are the answer for our requirement. Perform
    the following steps to find the highest and lowest values:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`min()`和`max()`函数是我们要求的答案。 执行以下步骤以找到最高和最低值：'
- en: 'First, read our file again and store the values for the high and low prices
    into arrays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，再次阅读我们的文件，并将高价和低价的值存储到数组中：
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The only thing that changed is the `usecols` parameter, since the high and low
    prices are situated in different columns.
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一更改的是`usecols`参数，因为高价和低价位于不同的列中。
- en: 'The following code gets the price range:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码获取价格范围：
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'These are the values returned:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是返回的值：
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, it's easy to get a midpoint, so it is left as an exercise for you to attempt.
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，很容易获得中点，因此留给您练习。
- en: 'NumPy allows us to compute the spread of an array with a function called `ptp()`.
    The `ptp()` function returns the difference between the maximum and minimum values
    of an array. In other words, it is equal to `max(array)`—`min(array)`. Call the
    `ptp()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy 允许我们使用名为`ptp()`的函数来计算数组的传播。 `ptp()`函数返回数组的最大值和最小值之间的差。 换句话说，它等于`max(array)
    - min(array)`。 调用`ptp()`函数：
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You will see this text printed:'
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下文本：
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We defined a range of highest to lowest values for the price. The highest value
    was given by applying the `max()` function to the high price array. Similarly,
    the lowest value was found by calling the `min()` function to the low price array.
    We also calculated the peak-to-peak distance with the `ptp()` function:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为价格定义了最高到最低值的范围。 通过将`max()`函数应用于高价数组，可以得出最高值。 同样，通过将`min()`函数调用到低价数组可以找到最低值。
    我们还使用`ptp()`函数计算了峰峰距离：
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 统计
- en: Stock traders are interested in the most probable close price. Common sense
    says that this should be close to some kind of an average as the price dances
    around a mean, due to random fluctuations. The arithmetic mean and weighted average
    are ways to find the center of a distribution of values. However, neither are
    robust and both are sensitive to outliers. `Outliers` are extreme values that
    are much bigger or smaller than the typical values in a dataset. Usually, outliers
    are caused by a rare phenomenon or a measurement error. For instance, if we have
    a close price value of a million dollars, this will influence the outcome of our
    calculations.
  prefs: []
  type: TYPE_NORMAL
  zh: 股票交易商对最可能的收盘价感兴趣。 常识认为，由于随机波动，当价格围绕均值波动时，这应该接近某种平均水平。 算术平均值和加权平均值是找到值分布中心的方法。
    但是，它们都不健壮，并且都对异常值敏感。 `Outliers`是远大于或小于数据集中典型值的极值。 通常，异常值是由罕见现象或测量误差引起的。 例如，如果我们的收盘价为一百万美元，这将影响我们的计算结果。
- en: Time for action – performing simple statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 执行简单的统计
- en: We can use some kind of threshold to weed out outliers, but there is a better
    way. It is called the median, and it basically picks the middle value of a sorted
    set of values (see [https://www.khanacademy.org/math/probability/descriptive-statistics/central_tendency/e/mean_median_and_mode](https://www.khanacademy.org/math/probability/descriptive-statistics/central_tendency/e/mean_median_and_mode)).
    One half of the data is below the median and the other half is above it. For example,
    if we have the values of 1, 2, 3, 4, and 5, then the median will be 3, since it
    is in the middle.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用某种这种阈值来消除异常值，但是有更好的方法。 它被称为中位数，基本上是[选取一组排序值的中间值](https://www.khanacademy.org/math/probability/descriptive-statistics/central_tendency/e/mean_median_and_mode)。
    数据的一半低于中位数，另一半高于中位数。 例如，如果我们具有值 1、2、3、4 和 5，则中位数将为 3，因为它位于中间。
- en: 'These are the steps to calculate the median:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是计算中位数的步骤：
- en: 'Create a new Python script and call it `simplestats.py`. You already know how
    to load the data from a CSV file into an array. So, copy that line of code and
    make sure that it only gets the close price. The code should appear like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Python 脚本并将其命名为`simplestats.py`。 您已经知道如何将数据从 CSV 文件加载到数组中。 因此，复制该行代码并确保它仅获得收盘价。
    代码应如下所示：
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The function that will do the magic for us is called `median()`. We will call
    it and print the result immediately. Add the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对我们有用的函数称为`median()`。 我们将调用它并立即打印结果。 添加以下代码行：
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The program prints the following output:'
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序将输出以下输出：
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Since it is our first time using the `median()` function, we would like to
    check whether this is correct. Obviously, we can do it by just going through the
    file and finding the correct value, but that is no fun. Instead, we will just
    mimic the median algorithm by sorting the close price array and printing the middle
    value of the sorted array. The `msort()` function does the first part for us.
    Call the function, store the sorted array, and then print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是我们第一次使用`median()`函数，因此我们想检查一下是否正确。 显然，我们可以通过浏览文件并找到正确的值来做到这一点，但这并不有趣。 相反，我们将通过对收盘价数组进行排序并打印排序后的数组的中间值来模拟中值算法。
    `msort()`函数为我们做第一部分。 调用该函数，存储排序后的数组，然后打印它：
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This prints the following output:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下输出：
- en: '![Time for action – performing simple statistics](graphics/4154_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – performing simple statistics](img/4154_03_05.jpg)'
- en: 'Yup, it works! Let''s now get the middle value of the sorted array:'
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它有效！ 现在让我们获取排序数组的中间值：
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding snippet gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码片段为我们提供了以下输出：
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Hey, that''s a different value than the one the `median()` function gave us.
    How come? Upon further investigation, we find that the `median()` function return
    value doesn''t even appear in our file. That''s even stranger! Before filing bugs
    with the NumPy team, let''s have a look at the documentation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 嘿，那和`median()`函数给我们的值不同。 怎么会？ 经过进一步调查，我们发现`median()`函数的返回值甚至没有出现在文件中。 甚至更陌生！
    向 NumPy 团队提交错误之前，让我们看一下文档：
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This mystery is easy to solve. It turns out that our naive algorithm only works
    for arrays with odd lengths. For even-length arrays, the `median` is calculated
    from the average of the two array values in the middle. Therefore, type the following
    code:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谜题很容易解决。 事实证明，我们的朴素算法仅适用于奇数长度的数组。 对于偶数长度的数组，`median`是根据中间两个数组值的平均值计算得出的。 因此，键入以下代码：
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This prints the following output:'
  prefs: []
  type: TYPE_NORMAL
  zh: 'This prints the following output:'
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Another statistical measure that we are concerned with is variance. `Variance`
    tells us how much a variable varies (see [https://www.khanacademy.org/math/probability/descriptive-statistics/variance_std_deviation/e/variance](https://www.khanacademy.org/math/probability/descriptive-statistics/variance_std_deviation/e/variance)).
    In our case, it also tells us how risky an investment is, since a stock price
    that varies too wildly is bound to get us into trouble.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们关注的另一个统计指标是方差。 [“方差”告诉我们变量的变化量](https://www.khanacademy.org/math/probability/descriptive-statistics/variance_std_deviation/e/variance)。
    在我们的案例中，它还告诉我们投资有多高风险，因为股价变化过大必然会给我们带来麻烦。
- en: 'Calculate the variance of the close price (with NumPy, this is just a one-liner):'
  prefs: []
  type: TYPE_NORMAL
  zh: 计算收盘价的方差（使用 NumPy，这只是一种方法）：
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了以下输出：
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Not that we don't trust NumPy or anything, but let's double-check using the
    definition of variance, as found in the documentation. Mind you, this definition
    might be different than the one in your statistics book, but that is quite common
    in the field of statistics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并不是说我们不信任 NumPy 或其他任何东西，而是让我们使用文档中的方差定义仔细检查。 请注意，此定义可能与您的统计书中的定义不同，但这在统计领域非常普遍。
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `population variance` is defined as the mean of the square of deviations
    from the mean, divided by the number of elements in the array:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`population variance`定义为与平均值的偏差平方的平均值，除以数组中元素的数量：'
- en: '![Time for action – performing simple statistics](graphics/4154_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – performing simple statistics](img/4154_03_08.jpg)'
- en: 'Some books tell us to divide by the number of elements in the array minus one
    (this is called a **sample** **variance**):'
  prefs: []
  type: TYPE_NORMAL
  zh: 一些书告诉我们将数组中的元素数除以 1（这称为**样本方差**）：
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 'The output is as follows:'
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'Maybe you noticed something new. We suddenly called the `mean()` function on
    the `c` array. Yes, this is legal, because the `ndarray` class has a `mean()`
    method. This is for your convenience. For now, just keep in mind that this is
    possible. The code for this example can be found in `simplestats.py`:'
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您注意到了一些新东西。 我们突然在`c`数组上调用了`mean()`函数。 是的，这是合法的，因为`ndarray`类具有`mean()`方法。 这是为了您的方便。
    现在，请记住这是可能的。 此示例的代码可以在`simplestats.py`中找到：
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Stock returns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 股票收益
- en: 'In academic literature, it is more common to base analysis on stock returns
    and log returns of the close price. Simple returns are just the rate of change
    from one value to the next. Logarithmic returns, or log returns, are determined
    by taking the log of all the prices and calculating the differences between them.
    In high school, we learned that:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在学术文献中，更常见的是基于收盘价的股票收益和对数收益进行分析。 简单的回报就是从一个值到下一个值的变化率。 对数收益或对数收益是通过取所有价格的对数并计算它们之间的差来确定的。
    在高中时，我们了解到：
- en: '![Stock returns](graphics/4154_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Stock returns](img/4154_03_09.jpg)'
- en: Log returns, therefore, also measure the rate of change. Returns are dimensionless,
    since, in the act of dividing, we divide dollar by dollar (or some other currency).
    Anyway, investors are most likely to be interested in the variance or standard
    deviation of the returns, as this represents risk.
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对数返回还可以测量变化率。 收益是无量纲的，因为在除法操作中，我们将美元除以美元（或其他某种货币）。 无论如何，投资者最有可能对收益的方差或标准差感兴趣，因为这代表了风险。
- en: Time for action – analyzing stock returns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 分析股票收益
- en: 'Perform the following steps to analyze stock returns:'
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来分析股票收益：
- en: 'First, let''s calculate simple returns. NumPy has the `diff()` function that
    returns an array that is built up of the difference between two consecutive array
    elements. This is sort of like differentiation in calculus (the derivative of
    price with respect to time). To get the returns, we also have to divide by the
    value of the previous day. We must be careful though. The array returned by `diff()`
    is one element shorter than the close prices array. After careful deliberation,
    we get the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们计算简单的收益。 NumPy 具有`diff()`函数，该函数返回一个由两个连续数组元素之间的差构成的数组。 这有点像微积分中的差异（价格相对于时间的导数）。
    要获得回报，我们还必须除以前一天的值。 但是我们必须小心。 `diff()`返回的数组比收盘价数组短一个元素。 经过仔细考虑，我们得到以下代码：
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Notice that we don''t use the last value in the divisor. The standard deviation
    is equal to the square root of variance. Compute the standard deviation using
    the `std()` function:'
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不使用除数中的最后一个值。 标准差等于方差的平方根。 使用`std()`函数计算标准差：
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
  zh: 结果为以下输出：
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The log return or logarithmic return is even easier to calculate. Use the `log()`
    function to get the natural logarithm of the close price and then unleash the
    `diff()` function on the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对数收益率或对数收益率甚至更容易计算。 使用`log()`函数获取收盘价的自然对数，然后在结果上释放`diff()`函数：
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Normally, we have to check that the input array doesn't have zeros or negative
    numbers. If it does, we will get an error. Stock prices are, however, always positive,
    so we didn't have to check.
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们必须检查输入数组没有零或负数。 如果是这样，我们将得到一个错误。 但是，股价始终是正数，因此我们不必检查。
- en: 'Quite likely, we will be interested in days when the return is positive. In
    the current setup, we can get the next best thing with the `where()` function,
    which returns the indices of an array that satisfies a condition. Just type the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们很可能会对回报为正的日子感兴趣。 在当前设置中，我们可以使用`where()`函数获得下一个最好的结果，该函数返回满足条件的数组的索引。 只需输入以下代码：
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This gives us a number of indices for the array elements that are positive
    as a tuple, recognizable by the round brackets on both sides of the printout:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这为数组元素提供了多个索引，这些索引作为元组为正，可通过打印输出两侧的圆括号识别：
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In investing, volatility measures price variation of a financial security.
    Historical volatility is calculated from historical price data. The logarithmic
    returns are interesting if you want to know the historical volatility—for instance,
    the annualized or monthly volatility. The annualized volatility is equal to the
    standard deviation of the log returns as a ratio of its mean, divided by one over
    the square root of the number of business days in a year, usually one assumes
    252\. Calculate it with the `std()` and `mean()` functions, as in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在投资中，波动率衡量金融证券的价格变化。 历史波动率是根据历史价格数据计算得出的。 如果您想知道历史波动率（例如，年度或每月波动率），则对数收益很有趣。
    年度波动率等于对数回报率的标准差，即其平均值的比率除以一年的营业日数的平方根，通常假设为 252。 使用`std()`和`mean()`函数进行计算，如以下代码所示：
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Take notice of the division within the `sqrt()` function. Since, in Python,
    integer division works differently than float division, we needed to use floats
    to make sure that we get the proper results. The monthly volatility is similarly
    given by the following code:'
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`sqrt()`函数中除法的  。 由于在 Python 中，整数除法与浮点除法的工作原理不同，因此我们需要使用浮点数来确保获得正确的结果。 以下代码类似地给出了每月波动率：
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We calculated the simple stock returns with the `diff()` function, which calculates
    differences between sequential elements. The `log()` function computes the natural
    logarithms of array elements. We used it to calculate the logarithmic returns.
    At the end of this section, we calculated the annual and monthly volatility (see
    `returns.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`diff()`函数计算了简单的股票收益，该函数计算了连续元素之间的差异。 `log()`函数计算数组元素的自然对数。 我们用它来计算对数收益。
    在本节的最后，我们计算了年度和每月波动率（请参阅`returns.py`）：
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Dates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期
- en: Do you sometimes have the Monday blues or Friday fever? Ever wondered whether
    the stock market suffers from these phenomena? Well, I think this certainly warrants
    extensive research.
  prefs: []
  type: TYPE_NORMAL
  zh: 您有时星期一发烧吗？还是星期五发烧？ 有没有想过股市是否会遭受这些现象的困扰？ 好吧，我认为这当然值得广泛研究。
- en: Time for action – dealing with dates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 处理日期
- en: 'First, we will read the close price data. Second, we will split the prices
    according to the day of the week. Third, for each weekday, we will calculate the
    average price. Finally, we will find out which day of the week has the highest
    average and which has the lowest average. A word of warning before we commence:
    you might be tempted to use the result to buy stock on one day and sell on the
    other. However, we don''t have enough data to make this kind of decisions.'
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将读取收盘价数据。 其次，我们将根据星期几来划分价格。 第三，我们将针对每个工作日计算平均价格。 最后，我们将找出一周中哪一天的平均数最高，而哪一天的平均数最低。
    在我们开始之前提请您注意：您可能会倾向于使用结果在一天中购买股票而在另一天出售。 但是，我们没有足够的数据来做出这种决定。
- en: 'Coders hate dates because they are so complicated! NumPy is very much oriented
    toward floating point operations. For this reason, we need to take extra effort
    to process dates. Try it out yourself; put the following code in a script or use
    the one that comes with this book:'
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员讨厌日期，因为它们是如此复杂！ NumPy 非常面向浮点运算。 因此，我们需要付出更多的努力来处理日期。 自己尝试一下； 将以下代码放入脚本中或使用本书随附的脚本：
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Execute the script and the following error will appear:'
  prefs: []
  type: TYPE_NORMAL
  zh: 执行脚本，将出现以下错误：
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, perform the following steps to deal with dates:'
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行以下步骤来处理日期：
- en: 'Obviously, NumPy tried to convert the dates into floats. What we have to do
    is tell NumPy explicitly how to convert the dates. The `loadtxt()` function has
    a special parameter for this purpose. The parameter is called `converters` and
    is a dictionary that links columns with the so-called converter functions. It
    is our responsibility to write the converter function. Write the function down:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显然，NumPy 试图将日期转换为浮点数。 我们要做的是明确告诉 NumPy 如何转换日期。 为此，`loadtxt()`函数具有一个特殊的参数。 该参数称为“转换器”，是将列与所谓的转换器函数链接在一起的字典。
    编写转换器函数是我们的责任。 写下函数：
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We give the `datestr2num()` function dates as a string, such as 28-01-2011\.
    The string is first turned into a `datetime` object, using a specified format
    `%d-%m-%Y`. By the way, this is standard Python and is not related to NumPy itself
    (see [https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior](https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior)).
    Second, the `datetime` object is turned into a day. Finally, the weekday method
    is called on the date to return a number. As you can read in the comments, the
    number is between 0 and 6\. 0 is, for instance, Monday, and 6 is Sunday. The actual
    number, of course, is not important for our algorithm; it is only used as identification.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`datestr2num()`函数日期指定为字符串，例如`28-01-2011`。 首先使用指定的格式`%d-%m-%Y`将字符串转换为`datetime`对象。
    顺便说一下，这是标准的 Python，[与 NumPy 本身无关](https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior)。
    其次，  `datetime`对象变成一天。 最后，在日期上调用工作日方法以返回数字。 如您在注释中所读，数字是介于 0 和 6 之间。0 是例如星期一，6
    是星期日。 当然，实际数字对于我们的算法并不重要； 它仅用作标识。
- en: 'Now, hook up our date converter function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，连接我们的日期转换器函数：
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This prints the following output:'
  prefs: []
  type: TYPE_NORMAL
  zh: 'This prints the following output:'
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: No Saturdays and Sundays, as you can see. Exchanges are closed over the weekend.
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，没有星期六和星期日。 周末不开放交易。
- en: 'We will now make an array that has five elements for each day of the week.
    Initialize the values of the array to `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将制作一个数组，其中每个星期的每一天都有五个元素。 将数组的值初始化为`0`：
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This array will hold the averages for each weekday.
  prefs: []
  type: TYPE_NORMAL
  zh: 该数组将保存每个工作日的平均值。
- en: 'We already learned about the `where()` function that returns indices of the
    array for elements that conform to a specified condition. The `take()` function
    can use these indices and takes the values of the corresponding array items. We
    will use the `take()` function to get the close prices for each weekday. In the
    following loop, we go through the date values 0 to 4, better known as Monday to
    Friday. We get the indices with the `where()` function for each day and store
    it in the `indices` array. Then, we retrieve the values corresponding to the indices,
    using the `take()` function. Finally, compute an average for each weekday and
    store it in the `averages` array, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经了解了`where`函数，该函数返回符合指定条件的元素的数组索引。` take()`函数可以使用这些索引并获取相应数组项的值。 我们将使用`take()`函数来获取每个工作日的收盘价。
    在下面的循环中，我们遍历日期值 0 到 4，也就是星期一至星期五。 我们每天都使用`where()`函数获取索引，并将其存储在`indices`数组中。 然后，我们使用`take()`函数检索与索引相对应的值。
    最后，计算每个工作日的平均值并将其存储在“ averages”数组中，如下所示：
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The loop prints the following output:'
  prefs: []
  type: TYPE_NORMAL
  zh: 该循环显示以下输出：
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you want, you can go ahead and find out which day has the highest average,
    and which the lowest. However, it is just as easy to find this out with the `max()`
    and `min()` functions, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，可以继续进行操作，找出哪一天的平均值最高，哪一天最低。 但是，使用`max()`和`min()`函数很容易找到它，如下所示：
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 'The output is as follows:'
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'The `argmin()` function returned the index of the lowest value in the `averages`
    array. The index returned was `4`, which corresponds to Friday. The `argmax()`
    function returned the index of the highest value in the `averages` array. The
    index returned was `2`, which corresponds to Wednesday (see `weekdays.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: '`argmin()`函数返回`averages`数组中最小值的索引。 返回的索引为`4`，它对应于星期五。 `argmax()`函数返回`averages`数组中最大值的索引。
    返回的索引为`2`，它对应于星期三（请参阅`weekdays.py`）：'
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Have a go hero – looking at VWAP and TWAP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 勇往直前 – 查看 VWAP 和 TWAP
- en: Hey, that was fun! For the sample data, it appears that Friday is the cheapest
    day and Wednesday is the day when your Apple stock will be worth the most. Ignoring
    the fact that we have very little data, is there a better method to compute the
    averages? Shouldn't we involve volume data as well? Maybe it makes more sense
    to you to do a time-weighted average. Give it a go! Calculate the VWAP and TWAP.
    You can find some hints on how to go about doing this at the beginning of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，那很有趣！ 对于样本数据，似乎星期五是最便宜的一天，而星期三是您的苹果股票最值钱的一天。 忽略我们只有很少的数据这一事实，有没有更好的方法来计算平均值？
    我们是否也应该涉及体积数据？ 进行时间加权平均可能对您更有意义。 搏一搏！ 计算 VWAP 和 TWAP。 您可以在本章开始时找到一些有关如何执行此操作的提示。
- en: Time for action – using the datetime64 data type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 使用`datetime64`数据类型
- en: The `datetime64` data type was introduced in NumPy 1.7.0 (see [http://docs.scipy.org/doc/numpy/reference/arrays.datetime.html](http://docs.scipy.org/doc/numpy/reference/arrays.datetime.html)).
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NumPy 1.7.0 中引入了[`datetime64`数据类型](http://docs.scipy.org/doc/numpy/reference/arrays.datetime.html)。
- en: 'To learn about the `datetime64` data type, start a Python shell and import
    NumPy as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要了解`datetime64`数据类型，请启动 Python Shell 并导入 NumPy，如下所示：
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create a `datetime64` from a string (you can use another date if you like):'
  prefs: []
  type: TYPE_NORMAL
  zh: 从字符串创建`datetime64` （如果愿意，可以使用其他日期）：
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the preceding code, we created a `datetime64` for April 22, 2015, which
    happens to be Earth Day. We used the YYYY-MM-DD format, where Y corresponds to
    the year, M corresponds to the month, and D corresponds to the day of the month.
    NumPy uses the ISO 8601 standard (see [http://en.wikipedia.org/wiki/ISO_8601](http://en.wikipedia.org/wiki/ISO_8601)).
    This is an international standard to represent dates and times. ISO 8601 allows
    the YYYY-MM-DD, YYYY-MM, and YYYYMMDD formats. Check for yourself, as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们为 2015 年 4 月 22 日（恰好是地球日）创建了`datetime64`。 我们使用`YYYY-MM-DD`格式，其中`Y`表示年份，`M`表示月份，`D`表示月份的日期。
    NumPy 使用 [ISO 8601 标准](http://en.wikipedia.org/wiki/ISO_8601)。 这是代表日期和时间的国际标准。
    ISO 8601 允许使用`YYYY-MM-DD`，`YYYY-MM`和`YYYYMMDD`格式。 检查自己，如下所示：
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'By default, ISO 8601 uses the local time zone. Times can be specified using
    the format T[hh:mm:ss]. For example, define January 1, 1677 at 8:19 p.m. as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，ISO 8601 使用本地时区。 可以使用格式`T[hh:mm:ss]`指定时间。 例如，定义 1677 年 1 月 1 日晚上 8:19。
    如下：
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Additionally, a string in the format [hh:mm] specifies an offset that is relative
    to the UTC time zone. Create a `datetime64` with `9` hours offset, as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，格式为`hh:mm`的字符串指定相对于 UTC 时区的偏移量。 创建具有`9`小时偏移的`datetime64`，如下所示：
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `Z` at the end stands for Zulu time, which is how UTC is sometimes referred
    to.
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`Z`代表 Zulu 时间，有时也称为 UTC。
- en: 'Subtract the two `datetime64` objects from each other:'
  prefs: []
  type: TYPE_NORMAL
  zh: 彼此减去两个`datetime64`对象：
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The subtraction creates a NumPy `timedelta64` object, which in this case, indicates
    a `540` minute difference. We can also add or subtract a number of days to a `datetime64`
    object. For instance, April 22, 2015 happens to be a Wednesday. With the `arange()`
    function, create an array holding all the Wednesdays from April 22, 2015 until
    May 22, 2015 as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 减法创建一个 NumPy `timedelta64`对象，在这种情况下，该对象指示`540`分钟的差异。 我们还可以为`datetime64`对象增加或减少天数。
    例如，2015 年 4 月 22 日恰好是星期三。 使用`arange()`函数，创建一个数组，该数组包含从 2015 年 4 月 22 日到 2015 年
    5 月 22 日的所有星期三：
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that in this case, it is mandatory to specify the `dtype` argument, otherwise
    NumPy thinks that we are dealing with strings.
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种情况下，必须指定`dtype`参数，否则 NumPy 认为我们正在处理字符串。
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We learned about the NumPy `datetime64` type. This data type allows us to manipulate
    dates and times with ease. Its features include simple arithmetic and creation
    of arrays using the normal NumPy capabilities.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了 NumPy `datetime64`类型。 这种数据类型使我们可以轻松地操纵日期和时间。 它的功能包括简单的算术运算和使用常规 NumPy
    函数创建数组。
- en: Weekly summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每周汇总
- en: The data that we used in the previous *Time for action* section is end-of-day
    data. In essence, it is summarized data compiled from the trade data for a certain
    day. If you are interested in the market and have decades of data, you might want
    to summarize and compress the data even further. Let's summarize the data of Apple
    stocks to give us weekly summaries.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在先前的“实战时间”部分中使用的数据是当天结束的数据。 本质上，它是根据某一天的贸易数据汇总的汇总数据。 如果您对市场感兴趣并且拥有数十年的数据，则可能希望进一步汇总和压缩数据。
    让我们总结一下苹果股票的数据以给我们每周的摘要。
- en: Time for action – summarizing data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 汇总数据
- en: 'The data we will summarize will be for a whole business week, running from
    Monday to Friday. During the period covered by the data, there was one holiday
    on February 21, President''s Day. This happened to be a Monday and the US stock
    exchanges were closed on this day. As a consequence, there is no entry for this
    day, in the sample. The first day in the sample is a Friday, which is inconvenient.
    Use the following instructions to summarize data:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将汇总的数据将用于整个工作周，从星期一到星期五。 在数据覆盖的期间内，总统日 2 月 21 日有一个假期。 碰巧是星期一，美国证券交易所在这一天关闭。
    结果，样本中没有这一天的输入。 样本的第一天是星期五，这很不方便。 使用以下说明汇总数据：
- en: 'To simplify, just have a look at the first three weeks in the sample— later,
    you can have a go at improving this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为简化起见，只需看一下样本中的前三周，以后便可以进行改进：
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We will be building on the code from the previous *Time for action* section.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于前面的“实战时间”部分的代码。
- en: 'Commencing, we will find the first Monday in our sample data. Recall that Mondays
    have the code `0` in Python. This is what we will put in the condition of the
    `where()` function. Then, we will need to extract the first element that has index
    `0`. The result will be a multidimensional array. Flatten this with the `ravel()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始，我们将在示例数据中找到第一个星期一。 回想一下，星期一在 Python 中的代码为`0`。 这就是我们在`where()`函数中的条件。 然后，我们将需要提取索引为`0`的第一个元素。
    结果将是一个多维数组。 使用`ravel()`函数将其展平：
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This will print the following output:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下输出：
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The next logical step is to find the Friday before last Friday in the sample.
    The logic is similar to the one for finding the first Monday, and the code for
    Friday is `4`. Additionally, we are looking for the second to last element with
    index `2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步的逻辑步骤是在样本中的上一个星期五之前找到星期五。 逻辑类似于查找第一个星期一的逻辑，星期五的代码为 4。 此外，我们正在寻找索引为 2 的倒数第二个元素：
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供以下输出：
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, create an array with the indices of all the days in the three weeks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个包含三个星期中所有天的索引的数组：
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Split the array in pieces of size `5` with the `split()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`split()`函数将数组拆分为大小为`5`的片段：
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This splits the array as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这将数组拆分如下：
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In NumPy, array dimensions are called **axes**. Now, we will get fancy with
    the `apply_along_axis()` function. This function calls another function, which
    we will provide, to operate on each of the elements of an array. Currently, we
    have an array with three elements. Each array item corresponds to one week in
    our sample and contains indices of the corresponding items. Call the `apply_along_axis()`
    function by supplying the name of our function, called `summarize()`, which we
    will define shortly. Furthermore, specify the axis or dimension number (such as
    `1`), the array to operate on, and a variable number of arguments for the `summarize()`
    function, if any:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 NumPy 中，数组尺寸称为**轴**。 现在，我们将使用`apply_along_axis()`函数。 该函数调用我们将提供的另一个函数，以对数组的每个元素进行操作。
    当前，我们有一个包含三个元素的数组。 每个数组项对应于我们样本中的一个星期，并包含相应项的索引。 通过提供我们的函数名称`summarize()`来调用`apply_along_axis()`函数，我们将在稍后对其进行定义。
    此外，指定轴或尺寸号（例如`1`），要操作的数组以及`summarize()`函数的可变参数个数（如果有）：
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'For each week, the `summarize()` function returns a tuple that holds the open,
    high, low, and close price for the week, similar to end-of-day data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每周，`summarize()`函数会返回一个元组，该元组包含一周的开盘价，最高价，最低价和收盘价，类似于日末数据：
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Notice that we used the `take()` function to get the actual values from indices.
    Calculating the high and low values for the week was easily done with the `max()`
    and `min()` functions. The open for the week is the open for the first day in
    the week—Monday. Likewise, the close is the close for the last day of the week—Friday:'
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`take()`函数从索引中获取实际值。 使用`max()`和`min()`函数可以轻松计算一周的高值和低值。 周中营业时间是一周中第一天（周一）营业。
    同样，收盘价是一周中最后一天（周五）的收盘价：
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Store the data in a file with the NumPy `savetxt()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 NumPy `savetxt()`函数将数据存储在文件中：
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: As you can see, have specified a filename, the array we want to store, a delimiter
    (in this case a comma), and the format we want to store floating point numbers
    in.
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，已经指定了文件名，我们要存储的数组，定界符（在本例中为逗号）以及我们要在其中存储浮点数的格式。
- en: 'The format string starts with a percent sign. Second is an optional flag. The`—flag`
    means left justify, `0` means left pad with zeros, and `+` means precede with
    `+` or `-`. Third is an optional width. The width indicates the minimum number
    of characters. Fourth, a dot is followed by a number linked to precision. Finally,
    there comes a character specifier; in our example, the character specifier is
    a string. The character codes are described as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串以百分号开头。 第二个是可选标志。 `—flag`表示左对齐，`0`表示左填充为零，`+`表示以`+`或`-`开头。 第三是可选宽度。 宽度表示最小字符数。
    第四，点后跟与精度相关的数字。 最后，有一个字符说明符。 在我们的示例中，字符说明符是字符串。 字符代码描述如下：
- en: '| Character code | Description |'
  prefs: []
  type: TYPE_TB
  zh: '| 字符码 | 描述 |'
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `c` | character |'
  prefs: []
  type: TYPE_TB
  zh: '| `c` | 字符 |'
- en: '| `d` or `i` | signed decimal integer |'
  prefs: []
  type: TYPE_TB
  zh: '| `d`或`i` | 有符号十进制整数 |'
- en: '| `e` or `E` | scientific notation with `e` or `E`. |'
  prefs: []
  type: TYPE_TB
  zh: '| `e`或`E` | `e`或`E`的科学记数法。 |'
- en: '| `f` | decimal floating point |'
  prefs: []
  type: TYPE_TB
  zh: '| `f` | 十进制浮点数 |'
- en: '| `g`,`G` | use the shorter of `e`,`E` or `f` |'
  prefs: []
  type: TYPE_TB
  zh: '| `g`，`G` | 使用`e`，`E`或`f`中的较短者 |'
- en: '| `o` | signed octal |'
  prefs: []
  type: TYPE_TB
  zh: '| `o` | 八进制 |'
- en: '| `s` | string of characters |'
  prefs: []
  type: TYPE_TB
  zh: '| `s` | 字符串 |'
- en: '| `u` | unsigned decimal integer |'
  prefs: []
  type: TYPE_TB
  zh: '| `u` | 无符号十进制整数 |'
- en: '| `x`,`X` | unsigned hexadecimal integer |'
  prefs: []
  type: TYPE_TB
  zh: '| `x`，`X` | 无符号十六进制整数 |'
- en: 'View the generated file in your favorite editor or type at the command line:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在您喜欢的编辑器中查看生成的文件，或在命令行中键入：
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We did something that is not even possible in some programming languages. We
    defined a function and passed it as an argument to the `apply_along_axis()` function.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了某些编程语言甚至无法做到的事情。 我们定义了一个函数，并将其作为参数传递给`apply_along_axis()`函数。
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The programming paradigm described here is called functional programming. You
    can read more about functional programming in Python at [https://docs.python.org/2/howto/functional.html](https://docs.python.org/2/howto/functional.html).
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的编程范例称为函数式编程。 您可以在[这个页面](https://docs.python.org/2/howto/functional.html)上阅读有关
    Python 中函数式编程的更多信息。
- en: 'Arguments for the `summarize()` function were neatly passed by `apply_along_axis()`
    (see `weeksummary.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply_along_axis()`的函数巧妙地传递了`summarize()`函数的参数（请参见`weeksummary.py`）：'
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Have a go hero – improving the code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 勇往直前 – 改进代码
- en: Change the code to deal with a holiday. Time the code to see how big the speedup
    due to `apply_along_axis()` is.
  prefs: []
  type: TYPE_NORMAL
  zh: 更改代码以处理假期。 计时代码以查看由于`apply_along_axis()`而导致的加速有多大。
- en: Average True Range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平均真实范围
- en: The **Average True Range** (**ATR**) is a technical indicator that measures
    volatility of stock prices. The ATR calculation is not important further but will
    serve as an example of several NumPy functions, including the `maximum()` function.
  prefs: []
  type: TYPE_NORMAL
  zh: '**平均真实范围**（**ATR**）是衡量股票价格波动的技术指标。 ATR 计算不再重要，但将作为几个 NumPy 函数（包括`maximum()`函数）的示例。'
- en: Time for action – calculating the Average True Range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 计算平均真实范围
- en: 'To calculate the ATR, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算 ATR，请执行以下步骤  ：
- en: The ATR is based on the low and high price of `N` days, usually the last 20
    days.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ATR 基于`N`天（通常是最近 20 天）的低价和高价。
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We also need to know the close price of the previous day:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要知道前一天的收盘价：
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'For each day, we calculate the following:'
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一天，我们计算以下内容：
- en: 'The daily range—the difference between the high and low price:'
  prefs: []
  type: TYPE_NORMAL
  zh: 每日范围-最高价和最低价之差：
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The difference between the high and previous close:'
  prefs: []
  type: TYPE_NORMAL
  zh: 最高价和上一个收盘价之间的区别：
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The difference between the previous close and the low price:'
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个收盘价与低价之间的差异：
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `max()` function returns the maximum of an array. Based on those three
    values, we calculate the so-called true range, which is the maximum of these values.
    We are now interested in the element-wise maxima across arrays—meaning the maxima
    of the first elements in the arrays, the second elements in the arrays, and so
    on. Use the NumPy `maximum()` function instead of the `max()` function for this
    purpose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`max()`函数返回数组的最大值。 基于这三个值，我们计算出所谓的真实范围，即这些值的最大值。 现在，我们对跨数组的元素方式的最大值感兴趣，这意味着数组中第一个元素的最大值，数组中第二个元素的最大值，依此类推。
    为此，请使用 NumPy `maximum()`函数而不是`max()`函数：'
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Create an `atr` array of size `N` and initialize its values to `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个大小为`N`的`atr`数组，并将其值初始化为`0`：
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The first value of the array is just the average of the `truerange` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组的第一个值就是`truerange`数组的平均值：
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Calculate the other values with the following formula:'
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下公式计算其他值：
- en: '![Time for action – calculating the Average True Range](graphics/4154_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – calculating the Average True Range](img/4154_03_06.jpg)'
- en: 'Here, PATR is the previous day''s ATR; TR is the true range:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，PATR 是前一天的 ATR； TR 是真实范围：
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We formed three arrays, one for each of the three ranges—daily range, the gap
    between the high of today and the close of yesterday, and the gap between the
    close of yesterday and the low of today. This tells us how much the stock price
    moved and, therefore, how volatile it is. The algorithm requires us to find the
    maximum value for each day. The `max()` function that we used before can give
    us the maximum value within an array, but that is not what we want here. We need
    the maximum value across arrays, so we want the maximum value of the first elements
    in the three arrays, the second elements, and so on. In preceding *Time for action*
    section, we saw that the `maximum()` function can do this. After this, we computed
    a moving average of the true range values (see `atr.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们形成了三个数组，分别用于三个范围-每日范围，今天的高点和昨天的收盘价之间的差距，以及昨天的收盘价和今天的低点之间的差距。 这告诉我们股票价格变动了多少，因此，它的波动性如何。
    该算法要求我们找到每天的最大值。 我们之前使用的`max()`函数可以为我们提供数组中的最大值，但这不是我们想要的。 我们需要整个数组的最大值，因此我们需要三个数组中的第一个元素，第二个元素等等的最大值。
    在前面的“实战时间”部分中，我们看到了`maximum()`函数可以做到这一点。 此后，我们计算了真实范围值的移动平均值（请参见`atr.py`）：
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In the following sections, we will learn better ways to calculate moving averages.
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下各节中，我们将学习更好的方法来计算移动均线。
- en: Have a go hero – taking the minimum() function for a spin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 勇往直前 – 使用`minimum()`函数
- en: Besides the `maximum()` function, there is a `minimum()` function. You can probably
    guess what it does. Make a small script or start an interactive session in IPython
    to test your assumptions.
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`maximum()`函数外，还有`minimum()`函数。 您可能会猜到它在做什么。 使其成为一个小脚本，或者在 IPython 中启动一个交互式会话来测试您的假设。
- en: Simple Moving Average
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单移动均线
- en: The **Simple Moving Average** (**SMA**) is commonly used to analyze time-series
    data. To calculate it, we define a moving window of `N` periods, `N` days in our
    case. We move this window along the data and calculate the mean of the values
    inside the window.
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单移动均线**（**SMA**）通常用于分析时序数据。 为了计算它，我们定义了一个`N`周期的移动窗口，在本例中为`N`天。 我们沿着数据移动此窗口，并计算窗口内值的平均值。'
- en: Time for action – computing the Simple Moving Average
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 计算简单移动均线
- en: The moving average is easy enough to compute with a few loops and the `mean()`
    function, but NumPy has a better alternative—the `convolve()` function. The SMA
    is, after all, nothing more than a convolution with equal weights or, if you like,
    unweighted.
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平均值只需几个循环和`mean()`函数即可轻松计算，但 NumPy 具有更好的选择-`convolve()`函数。 毕竟，SMA 只是具有相等权重的卷积，或者，如果您愿意，可以是未加权的。
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '**Convolution** is a mathematical operation on two functions defined as the
    integral of the product of the two functions after one of the functions is reversed
    and shifted.'
  prefs: []
  type: TYPE_NORMAL
  zh: '**卷积**是两个函数的数学运算，定义为两个函数之一反转和移位后，两个函数的乘积积分。'
- en: '![Time for action – computing the Simple Moving Average](graphics/4154_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – computing the Simple Moving Average](img/4154_03_10.jpg)'
- en: Convolution is described on Wikipedia at [https://en.wikipedia.org/wiki/Convolution](https://en.wikipedia.org/wiki/Convolution).
    Khan Academy also has a tutorial on convolution at [https://www.khanacademy.org/math/differential-equations/laplace-transform/convolution-integral/v/introduction-to-the-convolution](https://www.khanacademy.org/math/differential-equations/laplace-transform/convolution-integral/v/introduction-to-the-convolution).
  prefs: []
  type: TYPE_NORMAL
  zh: 卷积[在维基百科上](https://en.wikipedia.org/wiki/Convolution)进行了描述。 可汗学院也[提供了卷积教程](https://www.khanacademy.org/math/differential-equations/laplace-transform/convolution-integral/v/introduction-to-the-convolution)。
- en: 'Use the following steps to compute the SMA:'
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤来计算 SMA：
- en: 'Use the `ones()` function to create an array of size `N` and elements initialized
    to `1`, and then, divide the array by `N` to give us the weights:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ones()`函数创建一个大小为`N`的数组，并将元素初始化为 1，然后将该数组除以`N`以给我们权重：
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'For `N = 5`, this gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`N = 5`，这将为我们提供以下输出：
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, call the `convolve()` function with these weights:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下权重调用`convolve()`函数：
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'From the array returned by `convolve()`, we extracted the data in the center
    of size `N`. The following code makes an array of time values and plots with `matplotlib`
    that we will cover in a later chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`convolve()`返回的数组中，我们提取了大小为`N`的中心的数据。 以下代码使用`matplotlib`构成了一个时间值和曲线数组，我们将在下一章中介绍：
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In the following chart, the smooth dashed line is the 5 day SMA and the jagged
    thin line is the close price:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图表中，平滑虚线是 5 天均线，锯齿状细线是收盘价：
- en: '![Time for action – computing the Simple Moving Average](graphics/4154_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – computing the Simple Moving Average](img/4154_03_01.jpg)'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We computed the SMA for the close stock price. It turns out that the SMA is
    just a signal processing technique—a convolution with weights `1/N`, where `N`
    is the size of the moving average window. We learned that the `ones()` function
    can create an array with ones and the `convolve()` function calculates the convolution
    of a dataset with specified weights (see `sma.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为收盘价计算了 SMA。 事实证明，SMA 只是一种信号处理技术—具有权重`1/N`的卷积，其中`N`是移动平均窗口的大小。 我们了解到`ones()`函数可以创建一个带有
    1 的数组，而`convolve()`函数可以计算具有指定权重的数据集的卷积（请参见`sma.py`）：
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Exponential Moving Average
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指数移动均线
- en: The **Exponential Moving Average** (**EMA**) is a popular alternative to the
    SMA. This method uses exponentially decreasing weights. The weights for points
    in the past decrease exponentially but never reach zero. We will learn about the
    `exp()` and `linspace()` functions while calculating the weights.
  prefs: []
  type: TYPE_NORMAL
  zh: '**指数移动均线**（**EMA**）是 SMA 的一种流行替代方法。 此方法按指数方式减小权重。 过去点的权重呈指数下降，但从未达到零。 在计算权重时，我们将学习`exp()`和`linspace()`函数。'
- en: Time for action – calculating the Exponential Moving Average
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 计算指数移动平均值
- en: 'Given an array, the `exp()` function calculates the exponential of each array
    element. For example, look at the following code:'
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个数组，`exp()`函数将计算每个数组元素的指数。 例如，在以下代码中查看  ：
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'It gives the following output:'
  prefs: []
  type: TYPE_NORMAL
  zh: 它给出以下输出：
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The `linspace()` function takes as parameters a start value, a stop value,
    and optionally an array size. It returns an array of evenly spaced numbers. This
    is an example:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`linspace()`函数将起始值，终止值以及可选的数组大小作为参数。 它返回一个均匀间隔的数字数组。 这是一个例子：'
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供以下输出：
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Calculate the EMA for our data:'
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的数据计算 EMA：
- en: 'Now, back to the weights, calculate them with `exp()` and `linspace()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，返回权重，使用`exp()`和`linspace()`进行计算：
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Normalize the weights with the `ndarray` `sum()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ndarray sum()`方法标准化权重：
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'For `N = 5`, we get these weights:'
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`N = 5`，我们得到以下权重：
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'After this, use the `convolve()` function that we learned about in the SMA
    section and also plot the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，使用我们在 SMA 部分中了解的`convolve()`函数并绘制结果：
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This gives us a nice chart where, again, the close price is the thin jagged
    line and the EMA is the smooth dashed line:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们一个不错的图表，在该图表中，收盘价再次是锯齿状细线，而 EMA 是平滑虚线：
- en: '![Time for action – calculating the Exponential Moving Average](graphics/4154_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – calculating the Exponential Moving Average](img/4154_03_02.jpg)'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We calculated the EMA of the close price. First, we computed exponentially
    decreasing weights with the `exp()` and `linspace()` functions. The `linspace()`
    function gave us an array with evenly spaced elements, and, then, we calculated
    the exponential for these numbers. We called the `ndarray` `sum()` method in order
    to normalize the weights. After this, we applied the `convolve()` trick that we
    learned in the SMA section (see `ema.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算了收盘价的 EMA。 首先，我们使用`exp()`和`linspace()`函数计算指数递减的权重。 `linspace()`函数为我们提供了元素间隔均匀的数组，然后，我们计算了这些数字的指数。
    为了将权重标准化，我们将调用`ndarray sum()`方法。 此后，我们应用了在 SMA 部分中学到的`convolve()`技巧（请参阅`ema.py`）：
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Bollinger Bands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布林带
- en: '**Bollinger Bands** are yet another technical indicator. Yes, there are thousands
    of them. This one is named after its inventor and indicates a range for the price
    of a financial security. It consists of three parts:'
  prefs: []
  type: TYPE_NORMAL
  zh: '**布林带**是另一个技术指标。 是的，有成千上万个。 此名称以其发明人的名字命名，并指示金融证券价格的范围。 它由三个部分组成：'
- en: A Simple Moving Average.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个简单的移动均线。
- en: An upper band of two standard deviations above this moving average—the standard
    deviation is derived from the same data with which the moving average is calculated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高于此移动平均值的两个标准差的上限-标准差是从所计算的移动平均值的相同数据中得出的。
- en: A lower band of two standard deviations below the moving average.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 低于移动均线两个标准差的较低频带。
- en: Time for action – enveloping with Bollinger Bands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 布林带
- en: 'We already know how to calculate the SMA. So, if you need to refresh your memory,
    please review the *Time for action – computing the simple average* section in
    this chapter. This example will introduce the NumPy `fill()` function. The `fill()`
    function sets the value of an array to a scalar value. The function should be
    faster than `array.flat = scalar` or setting the values of the array one-by-one
    in a loop. Perform the following steps to envelope with the Bollinger Bands:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何计算 SMA。 因此，如果您需要刷新内存，请阅读本章中的“实战时间 – 计算简单平均”部分。 本示例将介绍  NumPy `fill()`函数。
    `fill()`函数将数组的值设置为标量值。 该函数应比`array.flat = scalar`更快，或者应在循环中一对一地设置数组的值。 执行以下步骤以布林带包络：
- en: 'Starting with an array called `sma` that contains the moving average values,
    we will loop through all the datasets corresponding to those values. After forming
    the dataset, calculate the standard deviation. Note that at a certain point, it
    will be necessary to calculate the difference between each data point and the
    corresponding average value. If we do not have NumPy, we will loop through these
    points and subtract each of the values one-by-one from the corresponding average.
    However, the NumPy `fill()` function allows us to construct an array that has
    elements set to the same value. This enables us to save on one loop and subtract
    arrays in one go:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从包含移动平均值的名为`sma`的数组开始，我们将遍历与那些值相对应的所有数据集。 形成数据集后，计算标准差。 注意，在某个点上，有必要计算每个数据点与相应平均值之间的差。
    如果没有 NumPy，我们将遍历这些点，并从相应的平均值中逐个减去每个值。 但是，NumPy `fill()`函数允许我们构造一个元素设置为相同值的数组。
    这样一来，我们就可以节省一个循环并一次性减去数组：
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'To plot, we will use the following code (don''t worry about it now; we will
    see how this works in [Chapter 9](ch09.html "Chapter 9. Plotting with matplotlib"),
    *Plotting with matplotlib*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要进行绘图，我们将使用以下代码（现在不必担心；我们将在第 9 章“matplotlib 绘图”中了解其工作原理）：
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Following is a chart showing the Bollinger Bands for our data. The jagged thin
    line in the middle represents the close price, and the dashed, smoother line crossing
    it is the moving average:'
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是显示数据的布林带的图表。 中间的锯齿状细线表示收盘价，而穿过它的虚线，更平滑的线是移动均线：
- en: '![Time for action – enveloping with Bollinger Bands](graphics/4154_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – enveloping with Bollinger Bands](img/4154_03_03.jpg)'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We worked out the Bollinger Bands that envelope the close price of our data.
    More importantly, we got acquainted with the NumPy `fill()` function. This function
    fills an array with a scalar value. This is the only parameter of the `fill()`
    function (see `bollingerbands.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们制定了包围数据收盘价的布林带。 更重要的是，我们熟悉 NumPy `fill()`函数。 此函数用标量值填充数组。 这是`fill()`函数的唯一参数（请参见`bollingerbands.py`）：
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Have a go hero – switching to Exponential Moving Average
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 勇往直前 – 切换到指数移动均线
- en: It is customary to choose the SMA to center the Bollinger Band on. The second
    most popular choice is the EMA, so try that as an exercise. You can find a suitable
    example in this chapter, if you need pointers.
  prefs: []
  type: TYPE_NORMAL
  zh: 通常选择 SMA 来使布林带居中。 第二个最受欢迎的选择是 EMA，因此请尝试作为练习。 如果需要指针，可以在本章中找到合适的示例。
- en: Check whether the `fill()` function is faster or is as fast as `array.flat =
    scalar`, or setting the value in a loop.
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`fill()`函数是否更快或与`array.flat = scalar`一样快，或循环设置该值。
- en: Linear model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性模型
- en: Many phenomena in science have a related linear relationship model. The NumPy
    `linalg` package deals with linear algebra computations. We will begin with the
    assumption that a price value can be derived from `N` previous prices based on
    a linear relationship relation.
  prefs: []
  type: TYPE_NORMAL
  zh: 科学中的许多现象都有一个相关的线性关系模型。 NumPy `linalg`包处理线性代数计算。 我们首先假设可以基于线性关系从`N`以前的价格中得出价格值。
- en: Time for action – predicting price with a linear model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 使用线性模型预测价格
- en: 'Keeping an open mind, let''s assume that we can express a stock price `p` as
    a linear combination of previous values, that is, a sum of those values multiplied
    by certain coefficients we need to determine:'
  prefs: []
  type: TYPE_NORMAL
  zh: 保持开放态度  ，让我们假设可以将股票价格`p`表示为先前值的线性组合，也就是说，这些值的总和乘以我们需要确定的某些系数：
- en: '![Time for action – predicting price with a linear model](graphics/4154_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – predicting price with a linear model](img/4154_03_11.jpg)'
- en: In linear algebra terms, this boils down to finding a least-squares method (see
    [https://www.khanacademy.org/math/linear-algebra/alternate_bases/orthogonal_projections/v/linear-algebra-least-squares-approximation](https://www.khanacademy.org/math/linear-algebra/alternate_bases/orthogonal_projections/v/linear-algebra-least-squares-approximation)).
  prefs: []
  type: TYPE_NORMAL
  zh: 用线性代数术语，可以归结为[最小二乘法](https://www.khanacademy.org/math/linear-algebra/alternate_bases/orthogonal_projections/v/linear-algebra-least-squares-approximation)。
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'Independently of each other, the astronomers Legendre and Gauss created the
    least squares method around 1805 (see [http://en.wikipedia.org/wiki/Least_squares](http://en.wikipedia.org/wiki/Least_squares)).
    The method was initially used to analyze the motion of celestial bodies. The algorithm
    minimizes the sum of the squared residuals (the difference between `measured`
    and `predicted` values):'
  prefs: []
  type: TYPE_NORMAL
  zh: 天文学家 Legendre 和 Gauss 彼此独立，于 1805 年左右发明了[最小二乘法](http://en.wikipedia.org/wiki/Least_squares)。
    该方法最初用于分析天体的运动。 该算法将残差平方和（`measured`和`predicted`值之间的差）最小化：
- en: '![Time for action – predicting price with a linear model](graphics/4154_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – predicting price with a linear model](img/4154_03_12.jpg)'
- en: 'The recipe goes as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 秘籍如下所示：首先，形成一个包含`N`个价格值的向量`b`：
- en: 'First, form a vector `b` containing `N` price values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ''
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
  zh: ''
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: ''
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: ''
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Second, pre-initialize the matrix `A` to be `N-by-N` and contain zeros:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，将矩阵`A`预先初始化为`N x N`并包含零：
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The following should be printed on your screen:'
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上应打印以下内容：
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Third, fill the matrix `A` with `N` preceding price values for each value in
    `b`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三，对于`b`中的每个值，使用`N`个之前的价格值填充矩阵`A`：
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Now, `A` looks like this:'
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`A`看起来像这样：
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The objective is to determine the coefficients that satisfy our linear model
    by solving the least squares problem. Employ the `lstsq()` function of the NumPy
    `linalg` package to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目的是通过解决最小二乘问题来确定满足我们的线性模型的系数。 使用 NumPy `linalg`包的`lstsq()`函数执行此操作：
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 'The result is as follows:'
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The tuple returned contains the coefficient `x` that we were after, an array
    comprising residuals, the rank of matrix `A`, and the singular values of `A`.
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的元组包含我们所追求的系数`x`，一个包含残差的数组，矩阵`A`的秩以及`A`的奇异值。
- en: 'Once we have the coefficients of our linear model, we can predict the next
    price value. Compute the dot product (with the NumPy `dot()` function) of the
    coefficients and the last known `N` prices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦有了线性模型的系数，就可以预测下一个价格值。 计算系数的点积（使用 NumPy 的`dot()`函数）和最后一次已知的`N`价格：
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The dot product (see [https://www.khanacademy.org/math/linear-algebra/vectors_and_spaces/dot_cross_products/v/vector-dot-product-and-vector-length](https://www.khanacademy.org/math/linear-algebra/vectors_and_spaces/dot_cross_products/v/vector-dot-product-and-vector-length))
    is the linear combination of the coefficients `b` and the prices `x`. As a result,
    we get:'
  prefs: []
  type: TYPE_NORMAL
  zh: '[点积](https://www.khanacademy.org/math/linear-algebra/vectors_and_spaces/dot_cross_products/v/vector-dot-product-and-vector-length)是以下项的线性组合，系数`b`和`x`的乘积。结果，我们得到：'
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: I looked it up; the actual close price of the next day was `353.56`. So, our
    estimate with `N` `=` `5` was not that far off.
  prefs: []
  type: TYPE_NORMAL
  zh: 我抬起头来； 第二天的实际收盘价为`353.56`。 因此，我们对`N = 5`的估算与预期相差不远。
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We predicted tomorrow''s stock price today. If this works in practice, we can
    retire early! See, this book was a good investment, after all! We designed a linear
    model for the predictions. The financial problem was reduced to a linear algebraic
    one. NumPy''s `linalg` package has a practical `lstsq()` function that helped
    us with the task at hand, estimating the coefficients of a linear model. After
    obtaining a solution, we plugged the numbers in the NumPy `dot()` function that
    presented us an estimate through linear regression (see `linearmodel.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们今天预测了明天的股价。 如果这在实践中可行，我们可以提早退休！ 瞧，这本书毕竟是一笔不错的投资！ 我们为预测设计了线性模型。 财务问题被简化为线性代数。
    NumPy 的`linalg`包具有实用的`lstsq()`函数，可帮助我们完成当前的任务，估计线性模型的系数。 在获得解决方案后，我们将数字插入了 NumPy
    `dot()`函数中，该函数通过线性回归为我们提供了一个估计值（请参见`linearmodel.py`）：
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Trend lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 趋势线
- en: A trend line is a line among a number of the so-called pivot points on a stock
    chart. As the name suggests, the line's trend portrays the trend of the price
    development. In the past, traders drew trend lines on paper but nowadays, we can
    let a computer draw it for us. In this section, we shall use a very simple approach
    that probably won't be very useful in real life, but should clarify the principle
    well.
  prefs: []
  type: TYPE_NORMAL
  zh: 趋势线是股票图表上许多所谓的枢轴点中的线。 顾名思义，该线的趋势描绘了价格发展的趋势。 过去，交易员在纸上绘制趋势线，但如今，我们可以让计算机为我们绘制趋势线。
    在本节中，我们将使用一种非常简单的方法，该方法在现实生活中可能不会很有用，但应很好地阐明原理。
- en: Time for action – drawing trend lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 绘制趋势线
- en: 'Perform the following steps to draw trend lines:'
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤绘制趋势线：
- en: 'First, we need to determine the pivot points. We shall pretend they are equal
    to the arithmetic mean of the high, low, and close price:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要确定枢轴点。 我们假设它们等于最高价，最低价和收盘价的算术平均值：
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: From the pivots, we can deduce the so-called **resistance** and **support**
    **levels**. The support level is the lowest level at which the price rebounds.
    The resistance level is the highest level at which the price bounces back. These
    are not natural phenomena, they are merely estimates. Based on these estimates,
    it is possible to draw support and resistance trend lines. We will define the
    daily spread to be the difference of the high and low price.
  prefs: []
  type: TYPE_NORMAL
  zh: 从支点来看，我们可以推断出所谓的**阻力**和**支撑位**。 支撑位是价格反弹的最低水平。 阻力位是价格反弹的最高位。 这些不是自然现象，它们只是估计。
    基于这些估计，可以绘制支撑和阻力趋势线。 我们将每日点差定义为高价和低价之差。
- en: 'Define a function to fit line to data to a line where `y` `=` `at` `+` `b`.
    The function should return `a` and `b`. This is another opportunity to apply the
    `lstsq()` function of the NumPy `linalg` package. Rewrite the line equation to
    `y` = `Ax`, where `A` = `[t` `1]` and `x` `=` `[a` `b]`. Form `A` with the NumPy
    `ones_like()`, which creates an array, where all the values are equal to `1`,
    using an input array as a template for the array dimensions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数以使数据行适合`y = at + b`的行。 该函数应返回`a`和`b`。 这是应用 NumPy `linalg`包的`lstsq()`函数的另一个机会。
    将线方程式重写为`y = Ax`，其中`A = [t 1]`和`x = [a b]`。 使用 NumPy `ones_like()`的形式`A`，该数组创建一个数组，其中所有值均等于`1`，并使用输入数组作为该数组尺寸的模板：
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Assuming that support levels are one daily spread below the pivots, and that
    **resistance levels** are one daily spread above the pivots, fit the support and
    resistance trend lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设支撑位是在枢轴下方的一个每日价差，并且**阻力位**是支撑点和支撑趋势线的一个每日价差：
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'At this juncture, we have all the necessary information to draw the trend lines;
    however, it is wise to check how many points fall between the support and resistance
    levels. Obviously, if only a small percentage of the data is between the trend
    lines, then this setup is of no use to us. Make up a condition for points between
    the bands and select with the `where()` function, based on the following condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，我们掌握了绘制趋势线的所有必要信息。 但是，检查在支撑位和阻力位之间落多少点是明智的。 显然，如果只有一小部分数据位于趋势线之间，则此设置对我们没有用。
    为波段之间的点建立条件，并根据以下条件使用`where()`函数进行选择：
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'These are the printed condition values:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是打印条件值：
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Double-check the values:'
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查值：
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The array returned by the `where()` function has `rank` `2`, so call the `ravel()`
    function before calling the `len()` function:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`where()`函数返回的数组具有`rank 2`，因此在调用`len()`函数之前先调用`ravel()`函数：'
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'You will get the following result:'
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下结果：
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'As an extra bonus, we gained a predictive model. Extrapolate the next day resistance
    and support levels:'
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的奖励，我们获得了一个预测模型。 推断第二天的阻力和支撑位：
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
  zh: 'This results in the following output:'
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Another approach to figure out how many points are between the support and
    resistance estimates is to use `[]` and `intersect1d()`. Define selection criteria
    in the `[]` operator and intersect the results with the `intersect1d()` function:'
  prefs: []
  type: TYPE_NORMAL
  zh: 确定支撑和阻力估计之间有多少个点的另一种方法是使用`[]`和`intersect1d()`。 在`[]`运算符中定义选择标准，并将结果与​​`intersect1d()`函数相交：
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Not surprisingly, we get:'
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，我们得到：
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Once more, plot the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再一次，绘制结果：
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'In the following plot, we have the price data and the corresponding support
    and resistance lines:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们获得了价格数据以及相应的支撑线和阻力线：
- en: '![Time for action – drawing trend lines](graphics/4154_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![Time for action – drawing trend lines](img/4154_03_04.jpg)'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We drew trend lines without having to mess around with rulers, pencils, and
    paper charts. We defined a function that can fit data to a line with the NumPy
    `vstack()`, `ones_like()`, and `lstsq()` functions. We fit the data in order to
    define support and resistance trend lines. Then, we figured out how many points
    are within the support and resistance range. We did this using two separate methods
    that produced the same result.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绘制了趋势线，而不必弄乱标尺，铅笔和纸质图表。 我们使用 NumPy `vstack()`，`ones_like()`和`lstsq()`函数定义了可以使数据适合行的函数。
    我们拟合数据以定义支撑和阻力趋势线。 然后，我们找出了在支撑和阻力范围内的点。 我们使用两种产生相同结果的独立方法进行了此操作。
- en: 'The first method used the `where()` function with a Boolean condition. The
    second method made use of the `[]` operator and the `intersect1d()` function.
    The `intersect1d()` function returns an array of common elements from two arrays
    (see `trendline.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法使用带有布尔条件的`where()`函数。 第二种方法使用`[]`运算符和`intersect1d()`函数。 `intersect1d()`函数从两个数组返回一个公共元素数组（请参见`trendline.py`）：
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Methods of ndarray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ndarray`的方法'
- en: The NumPy `ndarray` class has a lot of methods that work on the array. Most
    of the time, these methods return an array. You may have noticed that many of
    the functions part of the NumPy library have a counterpart with the same name
    and functionality in the `ndarray` class. This is mostly due to the historical
    development of NumPy.
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy `ndarray`类具有在数组上工作的许多方法。 大多数情况下，这些方法返回数组。 您可能已经注意到，NumPy 库的许多功能部分在`ndarray`类中具有相同的名称和功能。
    这主要是由于 NumPy 的历史发展。
- en: The list of `ndarray` methods is pretty long, so we cannot cover them all. The
    `mean()`, `var()`, `sum()`, `std()`, `argmax()`, `argmin()`, and `mean()` functions
    that we saw earlier are also `ndarray` methods.
  prefs: []
  type: TYPE_NORMAL
  zh: '`ndarray`方法的列表很长，因此我们无法涵盖所有​​方法。 我们先前看到的`mean()`，`var()`，`sum()`，`std()`，`argmax()`，`argmin()`和`mean()`函数也是`ndarray`方法。'
- en: Time for action – clipping and compressing arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 剪切和压缩数组
- en: 'Here are a few examples of `ndarray` methods. Perform the following steps to
    clip and compress arrays:'
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`ndarray`方法的一些示例。 执行以下步骤来裁剪和压缩数组：
- en: 'The `clip()` method returns a clipped array, so that all values above a maximum
    value are set to the maximum and values below a minimum are set to the minimum
    value. Clip an array with values `0` to `4` to `1` and `2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`clip()`方法返回一个裁剪后的数组，以便将所有大于最大值的值设置为最大值，而将小于最小值的值设置为最小值。 将值为 0 到 4 的数组裁剪为 1
    和 2 的数组：'
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出以下输出：
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The `ndarray` `compress()` method returns an array based on a condition. For
    instance, look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ndarray compress()`方法根据条件返回一个数组。 例如，看下面的代码：'
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'This returns the following output:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下输出：
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We created an array with values `0` to `3` and selected the last element with
    the `compress()` function based on the `a > 2` condition.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了数组  ，其值是`0`至`3`，并根据`a > 2`条件选择了带有`compress()`函数的最后一个元素。
- en: Factorial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阶乘
- en: Many programming books have an example of calculating the factorial. We should
    not break with this tradition.
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程书籍都有一个计算阶乘的示例。 我们不应该违背这一传统。
- en: Time for action – calculating the factorial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 计算阶乘
- en: 'The `ndarray` class has the `prod()` method, which computes the product of
    the elements in an array. Perform the following steps to calculate the factorial:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`ndarray`类具有`prod()`方法，该方法计算数组中元素的乘积。 执行以下步骤来计算阶乘：'
- en: 'Calculate the factorial of `8`. To do this, generate an array with values `1`
    to `8` and call the `prod()` function on it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算`8`的阶乘。 为此，请生成一个值从 1 到 8 的数组，并对其调用`prod()`函数：
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Check the result with your pocket calculator:'
  prefs: []
  type: TYPE_NORMAL
  zh: 用袖珍计算器检查结果：
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: This is nice, but what if we want to know all the factorials from 1 to 8?
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，但是如果我们想知道从 1 到 8 的所有阶乘，该怎么办？
- en: 'No problem! Call the `cumprod()` method, which computes the cumulative product
    of an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没问题！ 调用`cumprod()`方法，该方法计算数组的累加乘积：
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'It''s pocket calculator time again:'
  prefs: []
  type: TYPE_NORMAL
  zh: 又是袖珍计算器时间了：
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We used the `prod()` and `cumprod()` functions to calculate factorials (see
    `ndarraymethods.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用  `prod()`和`cumprod()`函数来计算阶乘（请参阅`ndarraymethods.py`）：
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Missing values and Jackknife resampling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺失值和折刀重采样
- en: Data often misses values because of errors or technical issues. Even if we are
    not missing values, we may have cause to suspect certain values. Once we doubt
    data values, derived values such as the arithmetic mean, which we learned to calculate
    in this chapter, become questionable too. It is common for these reasons to try
    to estimate how reliable the arithmetic mean, variance, and standard deviation
    are.
  prefs: []
  type: TYPE_NORMAL
  zh: 由于错误或技术问题，数据通常会丢失值。 即使我们不缺少值，我们也可能有理由怀疑某些值。 一旦我们对数据值产生怀疑，我们在本章中学会计算的诸如算术平均值之类的派生值也将变得可疑。
    由于这些原因，通常尝试估算算术平均值，方差和标准差的可靠性。
- en: A simple but effective method is called **Jackknife** **resampling** (see [http://en.wikipedia.org/wiki/Jackknife_resampling](http://en.wikipedia.org/wiki/Jackknife_resampling)).
    The idea behind jackknife resampling is to systematically generate datasets from
    the original dataset by leaving one value out at a time. In effect, we are trying
    to establish what will happen if at least one of the values is wrong. For each
    new generated dataset, we recalculate the arithmetic mean, variance, and standard
    deviation. This gives us an idea of how much those values can vary.
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单但有效的方法，称为[**折刀重采样**](http://en.wikipedia.org/wiki/Jackknife_resampling)。
    折刀重采样背后的想法是通过一次保留一个值来从原始数据集中系统地生成数据集。 实际上，我们正在尝试确定如果至少一个值是错误的，将会发生什么。 对于每个新生成的数据集，我们重新计算算术平均值，方差和标准差。
    这使我们知道这些值可以变化多少。
- en: Time for action – handling NaNs with the nanmean(), nanvar(), and nanstd() functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间 – 使用`nanmean()`，`nanvar()`和`nanstd()`函数处理 NaN
- en: We will apply jackknife resampling to the stock data. Each value will be omitted
    by setting it to **Not a Number** (**NaN**). The `nanmean()`, `nanvar()`, and
    `nanstd()` can then be used to compute the arithmetic mean, variance, and standard
    deviation.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对数据进行折刀重采样。 通过将每个值设置为**非数字**（**NaN**），将省略这些值。 然后，可以使用`nanmean()`，`nanvar()`和`nanstd()`计算算术均值，方差和标准差。
- en: 'First, initialize a 30-by-3 array for the estimates as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，按如下所示初始化`30 x 3`数组以进行估算：
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Loop through the values and generate a new dataset by setting one value to
    NaN at each iteration of the loop. For each new set of values, compute the estimates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在循环的每次迭代中将一个值设置为 NaN 来遍历值并生成新的数据集。 对于每个新值集，计算估计值：
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Print the variance for each estimate (you can also print the mean or standard
    deviation if you prefer):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印每个估计的方差（如果您愿意，也可以打印均值或标准差）：
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The following is printed on the screen:'
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上打印以下内容：
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We estimated the variances of the arithmetic mean, variance, and standard deviation
    of a small dataset using jackknife resampling. This gives us an idea of how much
    the arithmetic mean, variance, and standard deviation vary. The code for this
    example can be found in the `jackknife.py` file in this book''s code bundle:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用折刀重采样估计了小型数据集的算术平均值，方差和标准差的方差。 这使我们知道算术平均值，方差和标准差有多少变化。 该示例的代码可以在本书的代码包的`jackknife.py`文件中找到：
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter informed us about a great number of common NumPy functions. A few
    common statistics functions were also mentioned.
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们介绍了许多常见的 NumPy 函数。 还提到了一些常用的统计函数。
- en: After this tour through the common NumPy functions, we will continue covering
    convenience NumPy functions such as `polyfit()`, `sign()`, and `piecewise()` in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览完常见的 NumPy 函数之后，我们将在下一章继续介绍方便的 NumPy 函数，例如`polyfit()`，`sign()`和`piecewise()`。

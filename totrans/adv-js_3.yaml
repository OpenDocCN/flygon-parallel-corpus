- en: '*Chapter 3*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DOM Manipulation and Event Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Explain DOM traversal and manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the event object and browser events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organize event propagation and bubbling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegate events efficiently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize JQuery to handle events and DOM manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will cover working with document nodes, event objects, and the
    process of chaining, navigation, and handling events.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first chapter, we covered many of the new and powerful features that
    were released in ES6\. We discussed the evolution of JavaScript and highlighted
    the key additions in ES6\. We discussed scope rules, variable declaration, arrow
    functions, template literals, enhanced object properties, destructuring assignment,
    classes and modules, transpiling, and iterators and generators.
  prefs: []
  type: TYPE_NORMAL
- en: In the second chapter, we covered JavaScript's asynchronous programming paradigms.
    We discussed the JavaScript event loop, callbacks, promises, and the async/await
    syntax. This chapter prepared us to apply the material from *Chapter 1, Introducing
    ECMAScript 6* and write powerful asynchronous programs.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the **Document** **Object Model (DOM)**
    and the **JavaScript Event object**. In the first topic, we will define the Document
    Object Model and explain DOM chaining, navigation, and manipulation. Then, we
    will explain the JavaScript event object and show how to interact with and handle
    DOM events. In this chapter, we will cover jQuery and use it to traverse the DOM
    and handle events.
  prefs: []
  type: TYPE_NORMAL
- en: DOM Chaining, Navigation, and Manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Document Object Model (DOM)** is an interface for HTML documents. The
    DOM represents a web page in such a way that programs can change the document
    structure, style, and content. The DOM is the object-oriented representation of
    a web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two standards for the DOM: the **World Wide Web Consortium (W3C)**
    standard and the **Web Hypertext Application Technology Working Group (WHATWG)**
    standard. WHATWG was developed in response to the slow development of the W3C
    standard. Both standards define HTML elements as objects that can be accessed
    by JavaScript code, and properties, accessor methods, and events for all HTML
    elements. DOM object methods are actions you can perform on HTML elements and
    DOM object properties are values you can get or set. The DOM standard provides
    a way for JavaScript to add, get, change, or delete HTML elements programmatically.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The W3C DOM standard and WHATWG DOM standard are implemented by most modern
    browsers (Chrome, Firefox, and Edge), and many browsers extend the standard. When
    interfacing with the DOM, we must make sure that all of the functions we use are
    compatible with the browsers our users may have.
  prefs: []
  type: TYPE_NORMAL
- en: The DOM for a web page is constructed as a tree of objects, called **nodes**.
    The object at the head of the tree is a **document node**. The **document** is
    the interface that serves as an entry point for the web page's content, the DOM
    tree. HTML elements in the page are added to the DOM tree under the document.
    They are called **element nodes**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Elements in the DOM tree can have three types of relationships with the elements
    around them: **parent**, **sibling**, and **child**. An element''s parent element
    is the element that it is contained by. An element''s sibling nodes are elements
    that are also contained by the element''s parent. An element''s child nodes are
    the elements that it contains. An example DOM tree is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: DOM tree structure ](image/Figure_3.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: DOM tree structure'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding diagram, we can see that the global parent is the **document
    object**. The document object has one child node, the `<html>` element. The `<html>`
    element's parent node is the document and it has two child nodes, the `<head>`
    and `<body>` elements. The `<head>` and `<body>` elements are sibling nodes to
    each other because they both have the same parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 20: Building the HTML Document from a DOM Tree Structure'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The aim here is to create a web page, "My title", which displays the header
    "My header" and the link "My link". Reference the preceding diagram for the DOM
    tree structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build an HTML document from a DOM tree structure, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an HTML file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `<html>` tag to the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `<head>` tag inside the `<html>` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `<title>` tag after the `<head>` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the text **My title** in the `<title>` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `<body>` tag below the `<head>` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the elements `<a>` and `<h1>` under the `<body>` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `href` attribute to the `<a>` tag and set its internal text to **My
    link**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the text **My header** inside the `<h1>` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the `body` and `html` tags and fetch the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: index.js
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: https://bit.ly/2FiLgcE
  prefs: []
  type: TYPE_NORMAL
- en: 'Snippet 3.1: Simple site to demonstrate a DOM tree'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: My header link output ](image/Figure_3.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: My header link output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You have successfully built an HTML document from a DOM tree structure.
  prefs: []
  type: TYPE_NORMAL
- en: DOM Navigation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we understand the basic structure of the DOM, we are ready to start
    interfacing with it in our applications. Before we can begin to modify the DOM
    with JavaScript, we have to navigate the DOM tree to find the specific element
    nodes that we want to modify. We can find a specific node in one of two ways:
    **finding it by identifier** or **navigating the DOM tree**. The fastest look
    up method is looking up an element by identifier. DOM elements can be looked up
    in one of four ways:'
  prefs: []
  type: TYPE_NORMAL
- en: ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tag name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS query selector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding a DOM Node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Getting an element by ID is done with the `document.getElementById( id )` method.
    This method takes in a parameter id, which represents the id of the element to
    look up, and returns an element object. The object that''s returned will be the
    element object that describes the DOM node of the specified id. If no element
    matches the id provided, the function will return null. An example of the `getElementById`
    function is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.2: Getting an element by its id'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Getting an element by tag name is done with the `document.getElementsByTagName(
    name )` method. The function takes in a single argument that represents the HTML
    tag name to search for. `getElementsByTagName` returns a live `HTMLCollection`
    of elements that match the given tag name. The returned list is live, which means
    that it updates itself with the DOM tree automatically. There is no need to call
    the function several times with the same element and arguments. An example of
    `getElementsByTagName` is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.3: Getting elements by tag name'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An `HTMLCollection` is an interface that represents a collection (array-like
    object) of element nodes. It can be iterated over and offers methods and properties
    for selecting from the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an element by class name, we use the `document.getElementsByClassName(
    name )` method. The function takes in a single argument that represents the HTML
    class name to search for and returns a live `HTMLCollection` of elements that
    match the given `classname`. An example of `getElementsByClassName` is shown in
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.4: Getting elements by class name'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The two functions, `querySelector()` and `querySelectorAll()`, are used to
    get HTML elements by CSS query selector. They both take in a single string parameter
    that represents a CSS selector string. `querySelector` will return a single element.
    `querySelectorAll` will return a static (non-live) `NodeList` of the elements
    that match the query. Multiple query selectors can be passed into the function
    by creating a comma-separated string that contains each selector. If multiple
    selectors are passed into the query selector functions, the function will match
    and return elements that meet any of the selector''s requirements. The functionality
    for `querySelector` and `querySelectorAll` is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.5: Getting elements by using the CSS selector'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A `NodeList` is similar to an `HTMLCollection`. It is an array-like collection
    of HTML nodes that can be iterated over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the methods covered previously and their function syntax are shown
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: Methods and syntax'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.3: Methods and syntax'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `getElementsByTagName`, `getElementsByClassName`, `querySelector`, and `querySelectorAll`
    functions are not limited to only the document object; they can also be called
    on element nodes. If they are called on an element node, the resulting elements
    collection returned by the function will be limited to only the children of the
    element, which the function was called on. This is shown in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**: We get the element object for the div with the id `div1` and save
    it in the `elem` variable. We then use `getElementsByTagName` to get other div
    elements. The function is called on the element object saved in `elem`, so the
    search space is limited to child nodes of `div1`. `getElementsByTagName` will
    return an `HTMLCollection` with the divs `div2` and `div3` because they are descendants
    of `div1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.6: Returning an HTMLCollection'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The second way to find DOM elements is by navigating the DOM tree through the
    element relationships. Once we have found a DOM element to work with, we can use
    several properties to get that element's child, parent, and sibling nodes. We
    can traverse the DOM tree by going from node to node with the properties `parentNode`,
    `childNodes`, `firstChild`, `lastChild`, `previousSibling`, and `nextSibling`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `parentNode` property returns a node''s parent node. The parent node is
    a node in the DOM tree that the node is a descendent of. The parent node will
    always exist unless `parentNode` is called on the document node. Since the document
    node is at the top of the DOM tree, it has no parent, and the call to `parentNode`
    will return null. The DOM tree can be climbed with the `parentNode` property.
    An example of `parentNode` is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.7: Parent node'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The `nextSibling` and `previousSibling` properties are to get a node''s siblings
    in the DOM tree. `previousSibling` will return the previous sibling in the DOM
    tree (the sibling added to the parent node before the current node) and `nextSibling`
    will return the next sibling in the DOM tree (the sibling node added to the parent
    node after the current node). When DOM trees are drawn, the node''s previous sibling
    is usually shown to the left and the next sibling is usually shown on the right.
    The DOM tree can be traversed laterally with the `nextSibling` and `previousSibling`
    functions. These properties are shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.8: Traversing sibling nodes'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The three last properties are for navigating to a node''s child node; they
    are `childNodes`, `firstChild`, and `lastChild`. The `childNodes` property returns
    a live `NodeList` of the child nodes of an element. The `firstChild` and `lastChild`
    properties return the first or last node from the child `NodeList` respectively.
    The use of these properties is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.9: Traversing sibling nodes'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Traversing the DOM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The DOM tree navigation properties are summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4: DOM tree navigation properties](image/Figure_3.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: DOM tree navigation properties'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: DOM Manipulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you write an app or web page, one of the most powerful tools you have is
    manipulating the document structure in some way. This is done through DOM manipulation
    functions, for controlling the HTML and styling the app or page. Being able to
    manipulate the HTML document while the user uses an app or website allows us to
    dynamically change parts of the page without fully reloading the content. For
    example, when you use a messaging app on your cell phone, the app's code is manipulating
    the document you're looking at. Every time you send a message, it updates the
    document to append the elements and styling that makes up the message. There are
    three basic ways we can manipulate the DOM. We can add elements or nodes, remove
    elements or nodes, and update elements or nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new elements to the DOM tree is a must-have for interactive applications.
    There are many examples in most of the web applications you use. Both Google's
    Gmail and Microsoft's Skype actively add elements to the DOM as you use the application.
    There are two steps to adding a new element to the DOM. First, we must create
    a node for the element we want to add, and then we must add the new node to the
    DOM tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new element or node, we can use the `document.createElement(),`
    `Node.cloneNode()`, and `document.createTextNode()` functions. `CreateElement`
    is called on the global document object and takes in two arguments. The first
    is `tagName`. **tagName** is a string that specifies the type of element to be
    created. If we want to create a new div element, we would pass the `div` string
    in through `tagName`. The second argument is an optional argument called options.
    Options is an `ElementCreationObject` that contains a single property, named ''is''.
    This property allows us to specify if the element being added is a custom element.
    We will not be using this property, but it is important to know what it is used
    for. `CreateElement` returns a newly created Element object. The syntax and usage
    of `document.createElement()` are shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.10: Using document.createElement'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A new element node can also be created with the `cloneNode` function. `cloneNode`
    is called on a DOM node object and duplicates the node that it is called on. It
    takes in one argument, a Boolean called `deep`, and returns a copy of the node
    to clone. If `deep` is set to `false`, `cloneNode` will do a shallow clone and
    only clone the node that it was called on. If `deep` is set to `true`, `cloneNode`
    will do a deep copy and copy the node and all of its child nodes (the node's full
    DOM tree). Cloning a node copies all of its attributes and their values. This
    includes event listeners that are added inline in the HTML, but not listeners
    added through JavaScript with `addEventListener`, or those assigned with element
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of `cloneNode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.11: Cloning a node'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding example, we created a document with two divs, `div1` and `div2`.
    `div2` is nested inside of `div1`. In the preceding code, we selected `div1` by
    its id and cloned it into `div1Clone` by doing a shallow `nodeClone`. We then
    did a deep `nodeClone` and cloned `div1` and its nested child, `div2`, into `div1Div2Clone`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`cloneNode` may lead to duplicate element ids in a document. If you copy a
    node with an id, you should update that node''s id property to something unique.'
  prefs: []
  type: TYPE_NORMAL
- en: The spec for DOM has been updated recently. In the DOM4 specification, deep
    was an optional parameter for `cloneNode`. If omitted, the method would default
    the value to true, using deep cloning as the default behavior. To create a shallow
    clone, deep must be set to false. In the latest DOM spec, this behavior has been
    changed. Deep is still an optional parameter; however, it defaults to false. We
    recommend always providing the deep parameter for backward and forward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: '`CreateTextNode` is used to create text-only nodes. Text-only DOM nodes are
    used when filling the page with text. We use `createTextNode` to place new text
    in an element like a div. `CreateTextNode` takes in one argument, a string called
    `data`, and returns a text node. An example of `createTextNode` is shown in the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.12: Creating a text node'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now that we know how to create new DOM nodes, we must add the new nodes to
    the DOM tree to see changes in our application. We can add new nodes with two
    functions: `Node.appendChild()` and `Node.insertBefore()`. Both functions are
    called on a DOM node object.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Node.appendChild` adds a node to the end of the child list of the node it
    is called on. `Node.appendChild` takes in one argument, `aChild`, and returns
    the appended child. The `aChild` argument is the node that we want to append to
    the parent node''s child list. If `appendChild` is passed in a node that already
    exists in the DOM tree, the node is moved from its current position to the new
    position in the DOM, as a child of the specified parent node. If `appendChild`
    is passed a `DocumentFragment`, the entire content of the `DocumentFragment` is
    moved into the child list of the parent node, and an empty Document Fragment is
    returned. The syntax and use of `appendChild` are shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.13: Inserting a node with appendChild'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A `DocumentFragment` is simply a DOM tree that does not have a parent.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we created an HTML document with a div, `div1`. We
    then created a new div, `div2`, and then appended it to the `div1` child list
    with the `appendChild` function.
  prefs: []
  type: TYPE_NORMAL
- en: A node can also be inserted into the DOM with the `Node.insertBefore()` function.
    The `insertBefore` function inserts a node into the child list of the node it
    is called on, in front of a specified reference node. The `insertBefore` function
    takes in two parameters, `newNode` and `referenceNode`, and returns the inserted
    node. The `newNode` parameter represents the node that we are inserting. The `referenceNode`
    parameter is a node from the parent's child node list or the value `null`. If
    `referenceNode` is a node from the parent's child list, `newNode` will be inserted
    in front of that node, but if `referenceNode` is the value `null`, `newNode` will
    be inserted at the end of the parent's child node list. Much like `Node.appendChild()`,
    if the function is given a node to insert that is already in the DOM tree, the
    node will be removed from its old position in the DOM tree and placed in its new
    position as a child of the parent node. `InsertBefore` can also insert an entire
    `DocumentFragment`. If `newNode` is a `DocumentFragment`, the function will return
    an empty `DocumentFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of `appendChild` is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.14: Inserting a node with insertBefore'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding example, we created a div, `div1`, with a nested child div,
    `div2`. In the script, we got `div1` and `div2` by element id. We then created
    two new divs, `div3` and `div4`. We inserted `div3` into div1's child list. We
    passed `div2` as the reference node, so `div3` is inserted in front of `div2`
    in div1's child list. We then inserted `div4` into the `div1` child list. We passed
    in null as the reference node. This causes `div4` to be appended to the end of
    the div1 child list.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `referenceNode` parameter is not an optional parameter. You must explicitly
    pass in a node or the value null. Different browsers and browser versions interpret
    invalid values differently and app functionality may be compromised.
  prefs: []
  type: TYPE_NORMAL
- en: Another key functionality of manipulating the DOM is the ability to remove DOM
    nodes from the DOM tree. This functionality can be seen in Gmail and Facebook.
    When you delete an email in Gmail or remove a Facebook post, the DOM element associated
    with that email or post is being removed from the DOM tree. DOM node removal is
    done with the `Node.removeChild()` function. `RemoveChild` removes the specified
    child from the parent node it is called from. It takes in one argument, child,
    and returns the child DOM node removed. The child argument must be a child in
    the parent node's child list. If the child element is not a child of the parent
    node, an exception will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the `removeChild` functionality is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.15: Removing a node from the DOM'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding example, we created a div, `div1`, with a nested child div,
    `div2`. In the script, we get both divs by element id, then remove `div2` from
    the `div1` child list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we can add and remove nodes from the DOM, it would be very useful
    to be able to modify nodes that already exist. Nodes can be updated in the following
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the inner HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating Nodes in the DOM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first way to modify a DOM node is by replacing it entirely with a new DOM
    node. A DOM node can have any of its children replaced with the `Node.replaceChild()`
    function. `ReplaceChild` replaces one child of the parent node and it is called
    on with a new specified node. It takes in two arguments, `newChild` and `oldChild`,
    and returns the replaced node (`oldChild`). The `oldChild` parameter is the node
    in the parent's child list that will be replaced and the `newChild` parameter
    is the node that will replace `oldChild`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.16: Replacing nodes in the DOM'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding example, we created two divs, `div1` and `div2`. `Div1` is
    created with a nested child div, `div2`. In the script, we get each div by its
    element id. We then replace the `div1` child, `div2`, with `div3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second way to manipulate a DOM node is by changing the node''s inner HTML.
    The node''s `innerHTML` property can be used to get or set the HTML or XML markup
    contained in the element. The property can be used to change the current HTML
    code of the element''s children. It can be used to update or overwrite anything
    below the element in the DOM tree. To insert HTML into the node, set the `innerHTML`
    parameter equal to a string containing the HTML, elements you want to add. The
    string passed into the parameter is parsed as HTML and new DOM nodes are created;
    they''re then added as children to the parent node the property was referenced
    from. An example of the `innerHTML` property is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.17: Replacing the innerHTML of a node'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the value of `innerHTML` completely overwrites the old value. DOM nodes
    will be removed and replaced with the new nodes that have been parsed from the
    HTML string.
  prefs: []
  type: TYPE_NORMAL
- en: For security reasons, `innerHTML` will not parse and execute script contained
    in `<script>` tags inside of the HTML string. There are, however, other ways to
    execute JavaScript through the `innerHTML` property. You should never use `innerHTML`
    to append string data you have no control over.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third way to manipulate an element node is by changing the node''s attributes.
    Element node attributes can be interacted with through three functions: `Element.getAttribute()`,
    `Element.setAttribute()`, and `Element.removeAttribute()`. All three of these
    functions must be called on an element node.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Some attributes applied to element nodes have special meanings. Be careful
    when adding or removing attributes. A list of HTML attributes is shown here: [https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes).'
  prefs: []
  type: TYPE_NORMAL
- en: The `getAttribute` function takes in one parameter, the name of the attribute,
    and returns the value of the specified attribute. If the attribute does not exist,
    the function will return null or the empty string (""). Modern DOM specifications
    state that the function should return the value null and most browsers follow
    this specification, but some browsers still follow the old DOM3 specification,
    which states that the correct return value should be the empty string. It is important
    to handle both cases.
  prefs: []
  type: TYPE_NORMAL
- en: The `setAttribute` function is used to set or update the value of the specified
    attribute. It takes in two parameters, **name** and **value**, and does not return
    any value. The `name` parameter is the name of the attribute that will be set.
    The `value` parameter is the string value that the attribute will be set to. If
    the value passed in is not a string, it will be converted in to a string before
    being set. Since the value is converted in to a string, setting an attribute to
    an object or null will not have the expected value. The attribute will get set
    to the stringified version of the value that's passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `removeAttribute` function removes the specified attribute from the node.
    It takes in a single parameter, `attrName`, and returns no value. The `attrName`
    parameter is the name of the attribute to be removed. You can use `removeAttribute`
    instead of attempting to set an attribute''s value to null with `setAttribute`.
    An example of `getAttribute`, `setAttribute`, and `removeAttribute` is shown in
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.18: Getting, setting, and removing attributes'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding example, we create a div called `div1`. We then get that div
    by its id, add the `testName` attribute, and set its value to `testValue`. We
    then get the value of `testName` and remove it.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth way to manipulate a node is by changing its class information. Element
    class information is used to associate similar HTML elements for styling and grouping
    purposes. An element's class can be accessed in two ways, the `className` property
    or the `classList` property. The `className` property returns a string containing
    all of the element's class information. This property can be used to get or set
    the class value. The `classList` property returns a live `DOMTokenList` object.
    This object is simply a live list of the current class information with special
    methods for getting and updating class information.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Nodes in the DOM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `classList` object has six helper functions. They are detailed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: Helper functions'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.5: Helper functions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'These helper functions are used in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.19: Using the classList object'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The fifth and final way we typically modify a node is through the style object.
    The style object reflects the node''s CSS styling, and every element node has
    a style object. The style object can be obtained through `Element.style`. The
    style object contains properties for each CSS style that can be assigned to the
    object. This object is meant to be read-only, so element style should not be set
    directly by overwriting the style object. Instead, we should change the individual
    properties of the style object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.20: Using the classList object'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A list of all of the available style properties can be found online at [https://www.w3schools.com/jsref/dom_obj_style.asp](https://www.w3schools.com/jsref/dom_obj_style.asp).
  prefs: []
  type: TYPE_NORMAL
- en: DOM manipulation is one of the most important parts of a web page. The DOM can
    be manipulated by finding, adding, removing, and updating the nodes in the tree.
    We can find a DOM node in several ways—by unique id, by class, or by CSS query
    selector. Once we have found a DOM node, we can traverse the DOM tree by stepping
    to that element's child, sibling, or parent nodes. To add new elements to the
    DOM tree, we must first create a new element node, then append that element somewhere
    in the DOM. To remove an element, we simply get the node for the element we want
    to remove and then call the node remove function. To update a node, we can change
    any of its properties, attributes, or flat out replace the node. DOM manipulation
    allows us to build dynamic web pages and it is important to master it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs: []
  type: TYPE_NORMAL
- en: Web documents built from HTML code are represented by the Document Object Model,
    or DOM. The DOM is a tree-like structure built from nodes. Each node corresponds
    to an element in the HTML source. As programmers, we can interact with the DOM
    to dynamically updated web pages. We can interact with the DOM by finding, creating,
    removing, and updating element nodes. Combining all of these concepts allows us
    to create dynamic web pages that can update the view based on user interaction.
    This kind of functionality can be seen on nearly every website, including Amazon,
    Facebook, and Google.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 21: DOM Manipulation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your team is building an email website. The site needs to load the user's email
    data from a JSON file and dynamically populate a table with the email data that's
    loaded. The emails are provided in the example code file. The email table should
    show the **From**, **To**, and **Subject** fields and have a row for each email.
    Use the emails object to build the email table in the DOM through the DOM manipulation
    you learned about in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build an email list with JavaScript using DOM manipulation techniques, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the file called **exercise** from **/exercises/exercise21/exercise.html.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `script` tag, at the bottom of the file, write the JavaScript code (under
    *Code*, at the end of this exercise).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a new table element (`<table>`) and save it into a variable called `table`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new scope block with curly braces (`{}`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an array to hold the header types **To**, **From**, and **Subject**.
    Save the array into the variable headers.
  prefs: []
  type: TYPE_NORMAL
- en: Create a table row element (`<tr>`) and save it into the variable row. Loop
    through the headers array with a `forEach` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the callback of `forEach`, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the table header element (`<th>`) and save it into the `header` variable.
    Using `appendChild()`, append a new text node to `header`. The text node should
    contain the `header` name.
  prefs: []
  type: TYPE_NORMAL
- en: Append the header element stored in `header` as a child to the table row stored
    in `row`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Append the table row stored in `row` as a child to the table stored in `table`.
    The output is shown in the following figure:![Figure 3.6: Step 4 output](image/Figure_3.6.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.6: Step 4 output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Create a new scope block with curly braces (`{}`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Loop over the data array, `data`, with a `forEach` loop and do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new table row element (`<tr>`) and save it in the `row` variable. Create
    another new table data element (`<td>`) and save it in the `to` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Next, create two more table data elements (`<td>` and `<td>`) and save them
    as variables (`subject` and `from)`.
  prefs: []
  type: TYPE_NORMAL
- en: Append a text node to the table data element stored in `to` that contains the
    `forEach` loop's data object's `to` value. Append another text node to the table
    data element stored in `from` that contains the `forEach` loop's data object's
    `from` value.
  prefs: []
  type: TYPE_NORMAL
- en: Append a text node to the table data element stored in `subject` that contains
    the `forEach` loop's data object's `subject` value.
  prefs: []
  type: TYPE_NORMAL
- en: Append the element stored in `to` to the table row stored in `row`. Append the
    element stored in `from` to the table row stored in `row`.
  prefs: []
  type: TYPE_NORMAL
- en: Append the element stored in `subject` to the table row stored in `row`. Append
    the row stored in `row` to the table stored in `table`.
  prefs: []
  type: TYPE_NORMAL
- en: Get the `emailTableHolder` DOM node and append the table stored in the `table`
    variable as a child node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Load the HTML file in a web browser to view the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.7: Final output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.7: Final output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: solution.html
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.21: DOM manipulation to create an email list'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: https://bit.ly/2FmvdK1
  prefs: []
  type: TYPE_NORMAL
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: You have successfully analyzed DOM manipulation techniques.
  prefs: []
  type: TYPE_NORMAL
- en: DOM Events and Event Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DOM events are the backbone of functional and responsive web applications. Events
    are used in any website that has any form of user interaction. Websites such as
    Facebook, Google, and Skype all heavily make use of events. An event is a signal
    that tells the programmer that something has happened to a DOM node. An event
    can be fired for nearly any reason. We can use JavaScript to listen for events
    and run functions when an event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: DOM Event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **DOM event** is a notification sent by a DOM node to let the programmer know
    that something has happened to the DOM node. This can be anything from a user
    clicking on an element or pressing a key on the keyboard to video playback ending.
    There are a lot of events that can be fired. Every event that can be fired can
    have an event listener attached to it. An event listener is an interface that
    waits for an event to fire and then calls an event handler. An event handler is
    code that is run in response to an event. Event handlers are JavaScript functions
    that we, as programmers, assign to an event. This is called registering an event
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A complete list of events can be found here: [https://developer.mozilla.org/en-US/docs/Web/Events](https://developer.mozilla.org/en-US/docs/Web/Events).'
  prefs: []
  type: TYPE_NORMAL
- en: The best way to add an event handler is with the `addEventListener` function.
    The `addEventListener` function sets up the specified event handler to be called
    when an event of the specified type fires. The function takes in three parameters,
    **type**, **listener**, and either **options** or **useCapture**. The first argument,
    type, is the case-sensitive event type to listen for. The second argument, listener,
    is the object that can receive a notification, usually a JavaScript function.
    The options and **useCapture** parameters are optional and you may only provide
    one of them. The options argument specifies an options objects with the **capture**,
    **once**, and **passive** properties. In the options argument, the property named
    'capture' is a Boolean indicating that events will be dispatched to the event
    handler before they are pushed to the DOM tree. The property named 'once' is a
    Boolean that indicates whether the event handler should be removed after it has
    been called once. The property named 'passive' is a Boolean that indicates that
    event handler will never call the `preventDefault` function (discussed in the
    handling events subtopic). The useCapture parameter functions the same way as
    the `options.capture` property.
  prefs: []
  type: TYPE_NORMAL
- en: Event Listeners
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Event listeners** can be attached to any DOM node. To attach an event listener,
    we must select the node that needs to listen to the event, and then we can call
    the `addEventListener` function on that node. This is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.22: Getting, setting, and removing attributes'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding example, we created a button with the id `button1`. In the
    script, we selected that button and added an event listener. The event listener
    listens for click events. When a click event happens, it calls the handler function,
    which logs to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You may see inline event handlers in HTML code, for example, `<button onclick="alert(
    'Hello! ')">Press me</button>`. You should not do this. It is best practice to
    keep JavaScript and HTML separate. When you mix HTML and JavaScript, the code
    can quickly become unmanageable, inefficient, and harder to parse and interpret.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a later time, if we decide we no longer want an event listener, we can remove
    it with the `removeEventListener` function. The `removeEventListener` function
    removes the specified handler function from the specified event type. It takes
    the same parameters as `addEventListener`. To properly remove an event listener,
    `removeEventListener` must match it with a listener that''s been added. `RemoveEventListener`
    looks for a listener that has the same type, listener function, and capture option.
    If a match is found, then the event listener is removed. An example of `removeEventListener`
    is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.23: Getting, setting, and removing attributes'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding example, we created a button with the id `button1`. In the
    script, we get that button by its id by adding add an event listener for the click
    event. We then remove that same listener, providing the exact same parameters
    we provided to the `addEventListener` function, so that `removeEventListener`
    can properly match the listener that we want to remove.
  prefs: []
  type: TYPE_NORMAL
- en: Event Objects and Handling Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every event handler function takes in a single parameter. This is the event
    object. You will often see this parameter defined as `event`, `evt`, or simply
    `e`. It is automatically passed to the event handler to provide information about
    the event. The event handler can leverage the information in the event object
    to manipulate the DOM and allow the user to interact with the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.24: Using an event handler to manipulate the DOM'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A new instance of an event object can be created by calling a new instance
    of the event class (`new Event()`). The constructor takes in two arguments: **type**
    and **options**. Type is the type of the event and options is an optional object
    containing the following fields: **bubbles**, **cancelable**, and **composed**.
    All three of these fields are also optional. The bubbles property indicates whether
    the event should bubble. The `cancelable` property indicates whether the event
    can be canceled. The composed property indicates whether the event should trigger
    listeners outside of a shadow root. All three default to false.'
  prefs: []
  type: TYPE_NORMAL
- en: The event object has many useful properties and functions. These properties
    can be leveraged to gain additional information about the event. For example,
    we can use the `Event.target` property to obtain the DOM node that the event was
    originally fired from, or we can use `Event.type` to see the name of the event.
    `Event.target` is very useful when you want to use the same handler for multiple
    elements. Instead of having a new handler function for each event, we can reuse
    a handler and simply use `Event.target` to check which element fired the event.
  prefs: []
  type: TYPE_NORMAL
- en: When an event is fired from a DOM element, it notifies the event listeners attached
    to the DOM node. The event then propagates, or bubbles, up the DOM tree to each
    parent node, until it reaches the top of the tree. This effect is called event
    propagation or event bubbling. It allows us make our code more efficient by reducing
    the number of event listeners required in the page. If we have an element with
    many child elements that all require the same user interaction, we could add a
    single event listener to the parent element and catch any event that bubbles up
    from the child nodes. This is called event delegation. Instead of attaching a
    listener to each child node, we delegate the event handing to the parent node.
  prefs: []
  type: TYPE_NORMAL
- en: Event Propagation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Event propagation can be controlled with the `stopPropagation` function. This
    function is one of the many functions in the event object. `StopPropagation` takes
    in no arguments. When it is called, it prevents further propagation of the current
    event. This means that it fully captures the event and prevents it from bubbling
    upwards to any other parent nodes. Stopping an event's propagation can be very
    useful if we are using delegation, or if we have event listeners on child and
    parent nodes that listen to the same event but do different tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Firing Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Standard DOM events are fired automatically by the browser. JavaScript gives
    us two very powerful tools that allow us to have even more control over how events
    in our page are fired. The first tool is firing events through JavaScript. The
    second is custom events.
  prefs: []
  type: TYPE_NORMAL
- en: 'We learned earlier in this chapter that we can create new instances of the
    event object. A lone event is not very useful if we cannot fire the event and
    have the DOM tree be notified that something happened. DOM nodes have a member
    function, `dispatchEvent()`, that allows us to fire, or dispatch, instances of
    the event object. `DispatchEvent()` should be called on the DOM node that you
    want the event node to be fired from. It takes in a single argument and returns
    a Boolean value. This argument is the event object that will be fired on the target
    DOM node. The `DispatchEvent()` boolean return value will be false if the event
    is cancelable and one of the event handlers that handled the event was called
    `Event.preventDefault()`. Otherwise, `dispatchEvent()` will return true. An example
    of `dispatchEvent()` is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.26: Firing an event'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `dispatchEvent` method will throw an `UNSPECIFIED_EVENT_TYPE_ERR` error
    if the event's type is not specified properly. This means that if an event's type
    is null or an empty string, or the event was not initialized before `dispatchEvent()`
    is called, a runtime error will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that events fired with `dispatchEvent()` do not get
    called asynchronously via the event loop. Normal events that are fired by DOM
    nodes call the event handlers asynchronously via the event loop. When `dispatchEvent()`
    is used, the event handlers get invoked synchronously. All applicable event handlers
    are executed and return before the code continues with the code after the `dispatchEvent`
    call. Other events could be blocked if there are many event handlers for that
    event, or if one of the event handlers does a lot of synchronous work.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some browsers implement the `fireEvent()` function for firing events on DOM
    nodes. This function is a non-standard function that will not work on most browsers.
    Do not use this method in production code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 22: Handling Your First Event'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To set up an event listener and catch an event fired, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an HTML file with a `body` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `body` tag, create a button with the text `Click Me!` in it and the
    id `button1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `script` tag after the button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `script` tag, select the button by id and save it into the `button1`
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an event listener for the `click` event to the element stored in `button1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The callback should call the alert function and alert the browser with the `clicked!`
    string.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: index.html
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.25: DOM event handling'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: https://bit.ly/2M0Bcp5
  prefs: []
  type: TYPE_NORMAL
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8: Step 2 Click me! button'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '](image/Figure_3.8.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.8: Step 2 Click me! button'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 3.9: Output view'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.9.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.9: Output view'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You have successfully set up an event listener and caught an event that fired.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript also allows for the creation of custom events. Custom events are
    a way to fire events and listen for events with a custom type. The type of the
    event can be any non-empty string. The most basic way to create a custom event
    is by initializing a new instance of the event object with the event type as the
    custom event name. This is done with the following syntax: `const event = new
    Event( ''myCustomEvent'' )`. Creating an event like this does not allow you to
    add any custom information or properties to the event. To create a custom event
    with additional information, we can use the `CustomEvent` class. The `CustomEvent`
    class constructor takes in two arguments. The first argument is a string that
    represents the type name of the custom event we want to create. The second argument
    is an object that represents the custom event initialization options. It accepts
    the same fields as the options passed into the event class initializer, with the
    addition of a field called `detail`. The detail field defaults to null and is
    an event-dependent value associated with the event. Any information we want passed
    in to our custom event can be passed in through the detail parameter. The data
    in this parameter is also passed to all of the handlers that listen for the custom
    event.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The event constructor works will all modern browsers except for Internet Explorer.
    For full compatibility with IE, you must use the `createEvent()` and `initEvent()`
    methods discussed later, or use a `polyfill` to simulate the `CustomEvent` class.
  prefs: []
  type: TYPE_NORMAL
- en: To maximize code browser compatibility, we must also discuss the `initEvent()`
    and `createEvent()` methods for creating custom events. These methods are deprecated
    and have been removed from the web standard. Some browsers, however, still support
    these functions. To create a custom event in an older browser, you must first
    create the event with `var event = document.createEvent( 'Event' )` (we must use
    `var` instead of `const` in old browsers) and then initialize the new event with
    `event.initEvent()`. `CreateEvent()` takes in a single argument, type. This is
    the type of event object that will be created. This type must be one of the standard
    JavaScript event types, such as `Event`, `MouseEvent`, and so on. `InitEvent()`
    takes in three arguments. The first argument is a string that represents the type
    name of the event. For example, a click event's type is **click**. The second
    argument is a Boolean that represents the event's bubble behavior. The third argument
    is a Boolean that represents the event's cancelable behavior. These two behaviors
    were discussed in the *Event Objects and Handling Events* section of this topic.
  prefs: []
  type: TYPE_NORMAL
- en: To catch and handle custom events, we can use the standard event listener behaviors.
    All we need to do is attach an event listener with `addEventListener()` that listens
    for the custom event type that's been added. For example, if we create a `CustomEvent`
    with the event type `myEvent`, all we need to do to listen for that event is add
    an event listener on that type with `addEventListener( 'myEvent', e => {} )`.
    Whenever an event with the type `myEvent` is fired, the added event listener callback
    will be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the event listener callback is called, the event parameter in the callback
    will have an additional field, `detail`. This field will contain the information
    passed in to the custom event through the `detail` field of the custom event options
    object. Any information that''s relevant to the custom event should be passed
    through the `detail` object. An example of the detail object is shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.27: Firing a custom event with data in the detail'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Exercise 23: Handling and Delegating Events'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You are building a shopping list page to help busy shoppers manage shopping
    lists without pencil and paper. Our shopping list application will be a page with
    a table, a text input, and an add row button. The add row button will add a new
    row to the shopping list table. The rows that are added have the shopping list
    item (text from the text input) and a remove button. The remove button will remove
    that row from the shopping list table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will build the app:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the starter file at **exercises/exercise23/exercise.html**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the HTML `body`, in the `userInteractionHolder` `div`, add a text input and
    a button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the button the id `addButton`.
  prefs: []
  type: TYPE_NORMAL
- en: Add a table element with the id `shoppingList` to the `div` with the id `shoppingListHolder`.
  prefs: []
  type: TYPE_NORMAL
- en: Add a row to the table created in the previous step (`id = "shoppingList"`).
  prefs: []
  type: TYPE_NORMAL
- en: Add two header items to the table, one with the text `Item` and one with the
    text `Remove`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10: Output After stpe 2](image/Figure_3.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Output After step 2'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the `script` tag, select the button by its id and add a click listener that
    calls the `_addRow` function. Create the `_addRow` function with the following
    functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take in one parameter, `e`, which is the event object. Get the text input with
    DOM traversal using the `previousSibling` property on the event target. Save the
    text input element node to a variable, `inputBox`.
  prefs: []
  type: TYPE_NORMAL
- en: Save the value of the text in the `inputBox` to the `value` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Clear the value of the text area by setting it to the empty string (`""`).
  prefs: []
  type: TYPE_NORMAL
- en: Create a table row element and save it in the `row` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Use DOM manipulation and chaining to append a table data element to the table
    row. Append a text node to the table data element.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The text node should contain the value that's stored in `value`.
  prefs: []
  type: TYPE_NORMAL
- en: Use DOM manipulation and chaining to append table data to the table row.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Append a button to the table data element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Append the text `remove` to the button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate back up to the button element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a listener to the button and have it call the `_removeRow` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `shopingList` table and append the row to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `_removeRow`  function with the following functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take in an argument, `e` that will contain the event object.
  prefs: []
  type: TYPE_NORMAL
- en: Get the row element, that the button click occurred in with DOM traversal, and
    the `parentNode` property. Log the row element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using DOM traversal and chaining, get the table that contains the row, and
    then remove the row from the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11: Final output](image/Figure_3.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: Final output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: solution.html
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.28: DOM manipulation and event handling to build a shopping list
    app'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: https://bit.ly/2D1c3rC
  prefs: []
  type: TYPE_NORMAL
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: You have successfully applied event handling concepts to build a useful web
    app.
  prefs: []
  type: TYPE_NORMAL
- en: JQuery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**jQuery** is a lightweight JavaScript library that''s designed to simplify
    DOM interaction. It is one of the most popular libraries used in web development.
    jQuery is designed to simplify calls to the DOM and to make code more streamlined.
    In this topic, we will outline what jQuery is, how to install jQuery in a project,
    jQuery basics, using jQuery for DOM manipulation, and handling events with jQuery.'
  prefs: []
  type: TYPE_NORMAL
- en: jQuery is a library that's designed to make DOM traversal, manipulation, event
    handling, animation, and AJAX requests simpler to use and to make code that uses
    those elements more streamlined. jQuery is an extensive JavaScript library. A
    strong grasp of JavaScript is essential for harnessing all of the power of jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery provides an easy to use API that has extensive cross browser compatibility.
    jQuery implements what they call "current " browser support. This simply means
    that JQuery will run and is supported on a browser's current release version and
    previous release (v23.x and 22.x, but not v21.x). Code may run successfully on
    older browser versions, but bug fixes to jQuery will not be pushed for any bugs
    that appear with older browser versions. jQuery browser compatibility also extends
    to stock mobile browsers on Android and IOS devices.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The full documentation can be found on the official JQuery web page: [https:// jquery.com/](https://jquery.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: The first way to install jQuery is to download the source JavaScript files directly.
    The files can be found at [http://code.jquery.com](http://code.jquery.com). The
    JavaScript files can be added directly to a project's file structure. You should
    use the minified version in production code due to the smaller file size.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Code minification** is the process of removing unnecessary characters from
    source code without changing its functionality. Minification is done to reduce
    the size of the code file. This is important for JavaScript, HTML, and CSS files
    as it reduces the resources required to send and load web pages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second way to install JQuery is by using a package manager. The most popular
    command-line package managers for this are NPM, Yarn, and Bower. NPM will be discussed
    in more detail in the final chapter of this book. To install jQuery with one of
    these CLI (Command-Line Interface) package managers, first install and configure
    the relevant package manager. To install with NPM, run the following line: `npm
    install jquery`. This will place the jQuery files in the `node_modules` folder
    under `node_modules/jquery/dist/`. To install with Yarn, use the following command:
    `yarn add jquery`. To install with Bower, use the following command: `bower install
    jquery`. Installing with Bower will place the files in the `bower_components`
    folder under `bower_components/jquery/dist/`.'
  prefs: []
  type: TYPE_NORMAL
- en: Once JQuery has been installed, we are ready to start load jQuery into our project.
    This is as simple as adding a script tag to the HTML file. In the main HTML file,
    simply add a script tag with the source being the jQuery library file `(<script
    src="path/to/jquey.js"></script>`). JQuery is now installed and ready to be used
    in the project!
  prefs: []
  type: TYPE_NORMAL
- en: jQuery Basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JQuery is a library built around selecting and working with DOM nodes. All of
    the JQuery operations, by default, are available under both the library name `jQuery`
    and the shortcut variable `$`. We will call all JQuery functions by referencing
    the shortcut variable.
  prefs: []
  type: TYPE_NORMAL
- en: When creating or selecting DOM nodes, jQuery always returns an instance of the
    JQuery object. The JQuery object is an array-like collection that contains a zero
    indexed sequence of DOM elements, some familiar array functions and properties,
    and all the built-in JQuery methods. It is important to note two things about
    the JQuery object. First, JQuery objects are not live objects. The contents of
    the JQuery object will not update as the DOM tree changes. If the DOM has changed,
    the JQuery object can be updated by rerunning the same JQuery selector. Second,
    JQuery objects are also not equal. An equality comparison between two JQuery objects
    that are built with the same query will not be truthy. To compare JQuery objects,
    you must inspect the elements contained inside the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Zero indexed means that the object has numeric properties that can be used to
    reference the items from the items sequence (0, 1, 2, …, n).
  prefs: []
  type: TYPE_NORMAL
- en: The JQuery object is not an array. Built-in array properties and functions may
    not exist on the JQuery object.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery Selector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The core functionality of JQuery revolves around selecting and manipulating
    DOM elements. This is done with the jQuery core selector. To select DOM elements,
    we call the jQuery selector function `jQuery( selector )`, or `$( selector )`
    for short. The selector passed in to the jQuery function can take nearly any valid
    CSS selector, a callback function, or an HTML string. If a CSS selector is passed
    in to the JQuery selector, a collection of matched elements will be returned in
    a JQuery object. If the selector passed in is a HTML string, a collection of nodes
    will be created from the provided HTML string. If a callback function is passed
    in to the selector function, the callback will be run when the DOM has finished
    loading. jQuery can also accept a DOM node and create a JQuery object from that.
    If a DOM node is passed into the jQuery selector function, that node will be automatically
    selected and returned in a JQuery collection. An example of the JQuery selector
    function is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.29: Selecting DOM nodes'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Most jQuery functions operate on a selection of DOM nodes (`$()`); however,
    JQuery also offers a set of functions that do not. These are referenced directly
    through the $ variable. The distinction between the two can be confusing for new
    jQuery users. The easiest way to remember this difference is to note that functions
    in the `$` namespace are generally utility methods and do not work with selections.
    There are cases where the selector methods and the core utility methods have the
    same name, for example, `$.each()` and `$().each()`. When reading the jQuery documentation
    and learning new functions, be sure that you are exploring the correct function.
  prefs: []
  type: TYPE_NORMAL
- en: An HTML page's DOM cannot be safely manipulated until the base DOM structure
    has been created. JQuery offers a way to safely wait until the DOM is ready before
    running any code. This is done with the `ready()` JQuery object function. This
    function should be called on a jQuery object containing the HTML document ( `$(
    document ).ready()` ). The `ready()` function take in a single argument, a callback
    function. This function is run once the DOM is ready. Code that manipulates the
    DOM should be put in this callback function.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with multiple libraries in JavaScript, namespace conflicts can
    always be a concern. jQuery and all of its plugins and functionality are contained
    within the `jQuery` namespace. Because of this, there should not be a conflict
    between jQuery and any other library. There is one caveat, however, jQuery, by
    default, uses the `$` as a shortcut for the jQuery namespace. If you are using
    another library that uses the `$` variable, there could be conflicts with jQuery.
    To avoid this, you can put JQuery in no-conflict mode. To do this, call the `noConflict()`
    function on the jQuery namespace (`jQuery.noConflict()`). This will turn on no-conflict
    mode and allow you to assign the jQuery library a new shortcut variable name.
    The variable name can be anything you like, from `$` to `mySuperAwesomeJQuery`.
    A full example of enabling no-conflict mode and changing the jQuery shortcut variable
    name is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.30: Enabling no-conflict mode'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: jQuery DOM Manipulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JQuery is built around DOM manipulation. Here, we will cover the very basics
    of JQuery DOM manipulation. We will start by selecting elements, then move on
    to traversing and manipulating the DOM, and we will end with chaining.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting Elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step in DOM manipulation is always selecting the DOM nodes you''re
    going to work with. JQuery''s most basic concept is "select some elements and
    do something with them." jQuery makes selecting elements very easy with the selector
    function`: $()`. selector. jQuery supports most CSS3 selectors for selecting nodes.
    The simplest ways to select elements are by id, by class name, by attribute, and
    by CSS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Selecting an element by id is done by passing the CSS element id selector into
    the jQuery selector function: `$( ''#elementId'' )`. This will return a JQuery
    object that contains an element matching that id. Selecting by class name is done
    just like selecting by id. Pass the CSS class name selector into the jQuery selector
    function: `$( ''.className'' )`. This will return a jQuery object that contains
    all of the elements that match that class name. Selecting elements by attribute
    is done by passing the attribute CSS selector into the jQuery selector function:
    `$( "div[attribute-name=''example'']" )`. This will return a JQuery object that
    contains all of the elements that match the specified element type and attribute
    name/value. jQuery also supports more complicated selectors. You can pass in compound
    CSS selectors, comma-separated lists of selectors, and pseudo-selectors such as
    `:visible`. These selectors all return JQuery objects that contain the elements
    that match.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If a jQuery selector does not match any nodes, it still returns a JQuery object.
    The JQuery object will have no nodes in the collection and the length property
    of the object will be equal to zero. If you are checking to see if a selector
    found nodes, you must check on the length property, not on the truthiness of the
    JQuery object.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have gotten a selection of nodes, JQuery object functions can be used
    to filter and refine the selection. Some of the simple functions that are very
    useful are `has()`, `not()`, `filter()`, `first()`, and `eq()`. All of these functions
    take in a selector and return a JQuery object with a filtered set of nodes. The
    `has()` function filters the list to contain elements whose descendants match
    the CSS selector that's provided to `has()`. The `not()` function filters the
    JQuery object's nodes to only contain nodes that do not match the provided CSS
    selector. The `filter()` function filters the nodes to only show nodes that match
    the provided CSS selector. `First()` returns the first node in the JQuery object's
    internal node list. The `eq()` function returns a JQuery object containing the
    node at that index. Complete, in-depth documentation on these methods and other
    filtering methods can be found on the JQuery website.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing the DOM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once nodes have been selected with jQuery selectors, we can traverse the DOM
    to find more elements. DOM nodes can be traversed in three directions: to the
    parent nodes, to the child nodes, and to the sibling nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: Traversing parent nodes can be done in many ways, but the simplest ways are
    by calling one of four functions on the JQuery object. The first is a way to traverse
    parent nodes is by calling the `parent()` function. This function simply returns
    a JQuery object that contains the original node's parent node. The second function
    is the `parents()` function. This function takes in a CSS selector and returns
    a JQuery object containing the matching nodes. `parents()` traverses up the DOM
    tree, selecting any parent node, up to the head of the tree, that matches the
    provided query criteria. If no criteria is given, it selects all of the parent
    nodes. The third parent traversing function is the `parentsUntil()` function.
    It also takes in a CSS selector and returns a JQuery object. This function traverses
    up the parent tree, selecting elements until it reaches an element that matches
    the provided selector. The node that matches the provided selector is not included
    in the new JQuery object. The final method is the `closest()` method. This function
    takes in a CSS selector and returns a JQuery object containing the first parent
    node to match the provided selector.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`Closest()` always starts searching at the node contained in the JQuery object
    it is called on. If the selector passed in to `closest()` matches that node, it
    will always return itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Traversing child nodes can be done easily in two ways: `children()` and `find()`.
    The `children()` function takes in a CSS selector and returns a JQuery object
    of nodes are direct descendants, and match the selector, of the node it was called
    on. The `find()` function takes in a CSS selector and returns a JQuery object
    of any descendent node in the DOM tree, including nested children, that match
    the provided CSS selector.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Traversing sibling nodes can be done in the simplest way with the `next()`,
    `prev()`, and `siblings()` functions. `next()` gets the next sibling and `prev()`
    gets the previous sibling. Both functions return the new node in the JQuery object.
    `Siblings()` takes in a CSS selector and selects an element''s siblings in both
    directions (previous and next) that match the provided selector. `Prev()` and
    `next()` also have similar functions: `prevAll()`, `prevUntil()`, `nextAll()`,
    and `nextUntil()`. As you might expect, the `All` functions select all previous
    or next nodes. The `Until` functions select nodes, until but not including the
    node that matches the provided CSS selector.'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the DOM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we can select DOM nodes, we need to learn how to modify and create
    them. To create a node, we can simply pass an HTML string into the selector function.
    JQuery will parse the HTML string and create the nodes in the string. This is
    done like so: `$( ''<div>'' )`. The HTML string will be parsed for the div element
    and a JQuery object will be returned containing that element.'
  prefs: []
  type: TYPE_NORMAL
- en: To add elements to the DOM, we can use the `append()`, `before()`, and `after()`
    functions. The append function takes in a JQuery object and appends it to the
    children of the JQuery object that append was called from. It then returns a JQuery
    object containing the node the `append()` function was called on. `Before()` and
    `after()` function in a similar way. They both take in a JQuery object and insert
    it before or after the nodes contained in the JQuery object they are called on.
  prefs: []
  type: TYPE_NORMAL
- en: To remove DOM nodes, we can use the `remove()` and `detach()` function. Remove
    permanently removes the nodes that match the CSS selector passed in to the function.
    `Remove()` returns a JQuery object containing the removed nodes. All event listeners
    and associated data are removed from the nodes. If they are returned to the DOM,
    the listeners and data will have to be reset. `Detach()` removes nodes but persists
    events and data. Like `remove()`, it returns the detached nodes in a JQuery object.
    `Detach()` should be used if you plan on returning nodes to the page eventually.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying nodes with JQuery is very simple. Once we have selected nodes, traversed
    the tree, then filtered the selection to a single node, we can call JQuery object
    functions to modify things like attributes and CSS. To modify attributes, we can
    use the `attr()` function. `Attr()` takes in two values. The first is the name
    of the attribute to be modified. The second value sets what the attribute equals
    to. To modify an element's CSS, we can use the `css()` function. This function
    takes in two parameters. The first parameter is the CSS property to be modified.
    The second parameter value sets what the CSS property equals to. Both of these
    functions can also be used as `get` functions. If a second value is omitted, the
    `attr()` and `css()` functions will return the value of the attribute or CSS property
    instead of setting it.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most jQuery object functions return jQuery objects. This allows us to chain
    calls together and not separate each function call with a semicolon and newline.
    When chaining jQuery functions, jQuery tracks changes to the selector and nodes
    in the jQuery object. We can use the `end()` function to restore the current selection
    to its original selection. An example of this is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 3.31: Chaining and .end()'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: jQuery Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As discussed previously in the *DOM Events* section, any responsive and functional
    web page must rely on events. jQuery also provides a simple interface for adding
    event handlers and handling events.
  prefs: []
  type: TYPE_NORMAL
- en: '**Registering Handlers**'
  prefs: []
  type: TYPE_NORMAL
- en: Registering events with jQuery is very simple. The jQuery object provides many
    ways to register events. The simplest way to register an event is with the `on()`
    function. `On()` can be called with two different sets of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way to set up an event listener is by calling `on()` with four arguments:
    **events**, **selector**, **data**, and **handler**. Events is a space separated
    string of event types and optional namespaces (`click hover scroll.myPlugin`).
    A listener will be created for each event that''s provided. The second argument
    is selector. It is optional. If a CSS selector string is provided, the event listeners
    will also be added to all descendants of the selected elements that match the
    selector. The third argument is data. This can be anything and is optional. If
    data is provided, then it will be passed to the event object in the data field
    when the event is triggered. The final argument is the handler function. This
    is the function that will be called when the event triggers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second way to set up an event listener is by calling `on()` with three
    arguments: **events**, **selector**, and **data**. Much like the first method,
    events specifies the events that listeners will be created for. However, in this
    case, events is an object. The key is that the event name, which a listener will
    be set up for and the value is the function that will be called when the event
    fires. Like the first method, the selector and data arguments are optional. They
    both function the same way as the first method.'
  prefs: []
  type: TYPE_NORMAL
- en: To remove an event listener, we can use the `off()` method. The simplest way
    to remove event listeners with off is by providing the name of the event we want
    to remove listeners for. Like `on()`, we can provide the event types in a space-separated
    string or through an object.
  prefs: []
  type: TYPE_NORMAL
- en: Firing Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'jQuery provides an easy way to fire events from JavaScript: the `trigger()`
    function. The `trigger()` function should be used to fire an event and takes in
    the event type and an unlimited number of extra parameters. The event type is
    the type of event that will be triggered. The extra parameters are passed to the
    event handler function and are passed in as arguments after the event object.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Custom events in jQuery are very simple. Unlike custom events with Vanilla JavaScript,
    in jQuery, to set up an event handler for a custom event, all we need to do is
    create a listener with the `on()` function, with the event type as the custom
    event. To fire the event, we simply need to fire it with `trigger()`, with the
    event type as the custom event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 3: Implementing jQuery'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to make a web app that controls your home's smart LED lighting system.
    You have three LEDs that can be individually turned on or off, or all toggled
    together. You must build a simple HTML and jQuery interface that shows the on
    state of the lights and has buttons to control the lights.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build a functioning application with JQuery, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a Node.js project with `npm run init` on the command line and install jQuery.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an HTML file that loads the jQuery scripts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the HTML file, add three divs that start as white.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a toggle button above the divs and a button after each div.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up event listeners for click events for each button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The toggle button should change the color of all divs. Other buttons should
    change the color of the associated `div`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On a color change, swap the color between black and white
  prefs: []
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12: After step 4 output](image/Figure_3.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.12: After step 4 output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 3.13: After step 6 output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.13: After step 6 output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You have successfully utilized jQuery to build a functioning application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 285\.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web development revolves around the Document Object Model and the Event object.
    JavaScript is built to quickly and efficiently interact with the DOM and DOM events
    to provide us with powerful and interactive web pages. In the first topic of this
    chapter, we covered the DOM tree and discussed the ways to navigate and manipulate
    the DOM. In the second topic of this chapter, we discussed the JavaScript Event
    object, showed how to interact with DOM events, and demonstrated how to set up
    handlers to catch events. In the final topic of this chapter, we discussed the
    jQuery module. We discussed the jQuery object and jQuery selector, and showed
    how to use jQuery for DOM manipulation and event handling. With the topics learned
    in this chapter, you should be prepared to begin writing your own powerful and
    interactive web pages.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will analyze the benefit of tests and build code testing
    environments.
  prefs: []
  type: TYPE_NORMAL

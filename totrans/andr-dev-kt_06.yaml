- en: Generics Are Your Friends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed concepts related to functional programming
    and functions as first-class citizens in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss concept of generic types and generic functions
    known as generics. We will learn why they exist and how to use them - we will
    define generic classes, interfaces, and functions. We will discuss how to deal
    with generics at runtime, take look at subtyping relations, and deal with generics
    nullability
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the concepts of generic types and generic functions,
    known as generics. We will learn why they exist and how to use them and also how
    to define generic classes, interfaces, and functions. We will discuss how to deal
    with generics at runtime, take a look at subtyping relations, and deal with generic
    nullability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Generic classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic nullability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use-site target versus declaration-site target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaration-site target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type erasure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reified and erased type parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Star-projection syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Generic** is a programming style where classes, functions, data structures,
    or algorithms are written in such a way that the exact type can be specified later.
    In general, generics provide type safety together with the ability to reuse a
    particular code structure for various data types.'
  prefs: []
  type: TYPE_NORMAL
- en: Generics are present in both Java and Kotlin. They work in a similar way, but
    Kotlin offers a few improvements over the Java generic type system, such as use-site
    variance, start-projection syntax, and reified type parameters. We will discuss
    them in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The need for generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Programmers often need a way to specify that a collection contains only elements
    of particular type, such as `Int` , `Student` , or `Car` . Without generics, we
    would need separate classes for each data type (`IntList` , `StudentList` , `CarList`
    , and so on). Those classes would have a very similar internal implementation,
    which would only differ in the stored data type. This means that we would need
    to write the same code (such as adding or removing an item from a collection)
    multiple times and maintain each class separately. This is a lot of work, so before
    generics were implemented, programmers usually operated on a universal list. This
    forced them to cast elements each time they were accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Casting adds boilerplate, and there is no type validation when an element is
    added to a collection. Generics are the solution for this problem, because a generic
    class defines and uses a placeholder instead of a real type. This placeholder
    is called a **type parameter** *.* Let''s define our first generic class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The type parameter means that our class will use a certain type, but this type
    will be specified during class creation. This way, our `SimpleList` class can
    be instantiated for a variety of types. We can parametrize a generic class with
    various data types using *type arguments* . This allows us to create multiple
    data types from single class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `SimpleList` class is parametrized with *type arguments* (`Int` , `Student`
    , and `Car` ) that define what kind of data can be stored in the given list.
  prefs: []
  type: TYPE_NORMAL
- en: Type parameters versus type arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions have parameters (variables declared inside a function declaration)
    and arguments (actual value that is passed to a function). Similar terminology
    applies for generics. A *type parameter* is a blueprint or placeholder for a type
    declared in a generic and a *type argument* is an actual type used to parametrize
    a generic.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a *type parameter* in a method signature. This way, we can make
    sure that we will be able to add items of a certain type to our list and retrieve
    items of a certain type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Generic type parameter `T` used as type for item
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type parameter used as return type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The type of item that can be added to a list or retrieved from a list depends
    on the *type argument* . Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can only add and get items of type `Student` from the list. The compiler
    will automatically perform all necessary type checks. It is guaranteed that the
    collection will only contain objects of a particular type. Passing an object of
    incompatible type to the add method will result in a compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We cannot add Boolean, because expected type is `Student` .
  prefs: []
  type: TYPE_NORMAL
- en: The Kotlin standard library defines various generic collections in the `kotlin.collections`
    package, such as `List` , `Set` , and `Map` . We will discuss them in [Chapter
    7](text00171.html) , *Extension Functions and Properties* .
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, generics are often used in combination with higher-order functions
    (discussed in [Chapter 5](text00125.html) , *Functions as A First Class Citizen*
    ) and extension functions (which we will discuss in [Chapter 7](text00171.html)
    , *Extension Functions and Properties* ). Examples of such connections are functions:
    `map` , `filter` , `takeUntil` , and so on. We can perform common operations that
    will differ in the details. For example, we can find matching elements in the
    collection using the operation `filter` function and specifying how matching elements
    will be detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can call the `startsWith` method, because the collection can contain only
    `Strings` , so the lambda parameter (`it` ) has the same type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generic constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, we can parametrize a generic class with any type of *type argument*
    . However, we can limit the possible types that can be used as *type arguments*
    . To limit the possible values of *type argument* , we need to define a *type
    parameter bound* . The most common type of *constraint* is an *upper bound* .
    By default, all type parameters have `Any?` as an implicit *upper bound* . This
    is why both the following declarations are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding bounds mean that we can use any type we want as *type argument*
    for our `SimpleList` class (including nullable types). This is possible because
    all nullable and non-nullable types are subtypes of `Any?` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In some situations, we want to limit the data types that can be used as *type
    arguments.* To make it happen, we need to explicitly define a *type parameter*
    upper bound. Let''s assume that we want to be able to use only numeric types as
    *type arguments* for our `SimpleList` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `Number` class is an abstract class, that is, a superclass of Kotlin numeric
    types (`Byte` , `Short` , `Int` , `Long` , `Float` , and `Double` ). We can use
    the `Number` class and all its subclasses (`Int` , `Double` , and so on) as a
    *type argument* , but we can't use the `String` class, because it's not a subclass
    of `Number` . Any attempt to add an incompatible type will be rejected by the
    IDE and compiler. Type parameters also incorporate Kotlin type system nullability.
  prefs: []
  type: TYPE_NORMAL
- en: Nullability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we define a class with an unbounded type parameter, we can use both non-nullable
    and nullable types as *type arguments* . Occasionally, we need to make sure that
    a particular generic type will not be parametrized with nullable *type arguments*
    . To block the ability to use nullable types as *type arguments,* we need to explicitly
    define a non-nullable **type parameter upper bound** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now we can't pass a nullable *type argument* (`Action?` ) to the `ActionGroup`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider another example. Imagine that we want to retrieve the last
    `Action` in the `ActionGroup` . A simple definition of the `last` method would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze what will happen when we pass an empty list to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our application crashes, because the method `last` is throwing an error when
    there is no element with such an index on the list. Instead of an exception, we
    might prefer a null value when the list is empty. The Kotlin standard library
    already has a corresponding method that will return a null value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The code will not compile because there is a possibility that the last method
    will return null irrespective of *type argument* nullability (there may be no
    elements in the list to return). To solve this problem, we need to enforce a nullable
    return type by adding a question mark to the type parameter use-site (`T?` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Type parameter *declaration-site* (place in code where type parameter is declared)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type parameter *use-site* (place in code where type parameter is used)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `T?` parameter means that the `lastOrNull` method will always be nullable
    regardless of potential *type argument* nullability. Notice that we restored the
    type parameter `T` bound as non-nullable type `Action` , because we want to store
    non-nullable types and deal with nullability only for certain scenarios (such
    as a non-existing last element). Let''s use our updated `ActionGroup` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `actionGroup` inferred type is nullable even if we parameterized
    the generic with a non-nullable *type argument* .
  prefs: []
  type: TYPE_NORMAL
- en: 'A nullable type at the use-site does not stop us from allowing non-null types
    in the declaration-site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's sum up the above solution. We specified a non-nullable bound for type
    parameter to disallow parameterizing the `ActionGroup` class with nullable types
    as *type arguments* . We parameterized the `ActionGroup` class with the non-nullable
    *type argument* `Action` . Finally, we enforced type parameter nullability at
    the use-site (`T?` ), because the last property can return null if there are no
    elements in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Variance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Subtyping is a popular concept in the OOP paradigm. We define inheritance between
    two classes by extending the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The class `Dog` extends the class `Animal` , so the type `Dog` is a subtype
    of `Animal` . This means that we can use an expression of type `Dog` whenever
    an expression of type `Animal` is required; for example, we can use it as a function
    argument or assign a variable of type `Dog` to a variable of type `Animal` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Before we move on, we need to discuss the difference between class and type.
    Type is a more general term--it can be defined by class or interface, or it can
    be built into the language (primitive type). In Kotlin, for each class (for example,
    `Dog` ), we have at least two possible types--non-nullable (`Dog` ) and nullable
    (`Dog?` ). What is more, for each generic class (for example, `class Box<T>` )
    we can define multiple data types (`Box*<Dog>*` , `Box<Dog?>` *,* `Box<Animal>`
    *,* `Box<Box<Dog>>` , and so on).
  prefs: []
  type: TYPE_NORMAL
- en: The previous example applies only to simple types. Variance specifies how subtyping
    between more complex types (for example, `Box<Dog>` and `Box<Animal>` ) relates
    to subtyping between their components (for example, `Animal` , and `Dog` ).
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, generics are *invariant* by default. This means that there is no
    subtyping relation between the generic types `Box<Dog>` and `Box<Animal>` . The
    `Dog` component is subtype of `Animal` , but `Box<Dog>` is neither a subtype nor
    a supertype of `Box<Animal>` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Error Type mismatch. Required `Box<Animal>` , found `Box<Dog>` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Error Type mismatch. Required `Box<Dog>` , found `Box<Animal>` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Box<Dog>` type is neither a subtype nor a supertype of `Box<Animal>` ,
    so we can't use any of the assignments shown in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: We can define subtyping relations between `Box<Dog>` and `Box<Animal>` . In
    Kotlin, a subtyping relation of generic type can be preserved (co-variant), reversed
    (contra-variant), or ignored (invariant).
  prefs: []
  type: TYPE_NORMAL
- en: When a subtyping relation is co-variant, it means that subtyping is preserved.
    The generic type will have the same relation as the *type arguments* . If `Dog`
    is a subtype of `Animal` , then `Box<Dog>` is a subtype of `Box<Animal>` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Contra-variant is the exact opposite of co-variant, where subtyping is reversed.
    The generic type will have reversed relation with respect to *type arguments*
    . If `Dog` is a subtype of `Animal` , then `Box<Animal>` is a subtype of `Box<Dog>`
    . The following diagram present all types of variance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To define co-variant or contra-variant behavior, we need to use *variance modifiers.*
  prefs: []
  type: TYPE_NORMAL
- en: Variance modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generics in Kotlin are invariant by default. This means that we need to use
    type as the type of declared variable or function parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can't use a generic type parametrized with `Int` , which is a subtype of
    `Number` , and `Any` , which is a supertype of `Number.` We can relax this restriction
    and change the default variance by using variance modifiers. In Java, there is
    question mark (`?` ) notation (wildcard notation) used to represent an unknown
    type. Using it, we can define two types of wildcard bounds--upper bound and lower
    bound. In Kotlin, we can achieve similar behavior using `in` and `out` modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, the upper bound wildcard allows us to define a function that accepts
    any argument that is a certain type of its subtype. In the following example,
    the sum function will accept any `List` that was parametrized with the `Number`
    class or a subtype of the Number class (`Box<Integer>` , `Box<Double>` , and so
    on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now pass `Box<Number>` to our sum function and all the subtypes, for
    example, `Box<Int>` . This Java behavior corresponds to the Kotlin out modifier.
    It represents covariance, which restricts the type to be a specific type or a
    subtype of that type. This means that we can safely pass instances of the `Box`
    class that are parametrized with any direct or indirect subclass of `Number` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In Java, the lower bound wildcard allows us to define a function that accepts
    any argument that is a certain type or its supertype. In the following example,
    the `sum` function will accept any `List` that was parametrized with the `Number`
    class or a supertype of the `Number` class (`Box<Number>` and `Box<Object>` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now pass `Box<Any>` to our sum function and all the subtypes, for example,
    `Box<Any>` . This Java behavior corresponds to the Kotlin in modifier. It represents
    contra-variance, which restricts the type to be a specific type or a supertype
    of that type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It's forbidden to use an `in` and `out` modifier together. We can define variance
    modifiers in two different ways. Let's look at them in the upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: Use-site variance versus declaration-site variance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Use-site* variance and *declaration-site* variance basically describes the
    place in the code (site) where the variance modifier is specified. Let''s consider
    the `View` and `Presenter` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The class `Presenter` is invariant on its type `parameterT` . To fix the problem,
    we can explicitly define the subtyping relation. We can do it in two ways (use-site
    and declaration-site). First, let''s define the variance at the use-site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Variance modifier defined at type argument use-site
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now the `preseter` variable can store subtypes of `Presenter<BaseView>` , including
    `Presenter<ProductView>` . Our solution works, but our implementation can be improved.
    There are two problems with this approach. Now we need to specify this `out` variance
    modifier each time we want to use a generic type, for example, use it in multiple
    variables across different classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Both classes `A` and `B` contains the `preseter` variable that has variance
    modifier. We lose the ability to use type inference and in result the code is
    more verbose. To improve our code we can specify variance modifier at type parameter
    declaration-site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Variance modifier defined at type parameter declaration-site
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We only need to define variance modifier once inside `Presenter` class. In fact,
    both preceding implementations are the equivalent, although *declaration-site*
    variance is more concise and it can be easier used by external clients of the
    class
  prefs: []
  type: TYPE_NORMAL
- en: Collection variance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Java, arrays are co-variant. By default, we can pass an array of `String[]`
    even if an array of `Object[]` is expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This behavior was important in early versions of Java, because it allowed us
    to use different types of arrays as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'But this behavior also may lead to potential runtime errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The function `updateArray` accepts parameters of type `Object[]` and we are
    passing `String[]` . We are calling the add method with a `String` parameter.
    We can do so because array items are of type `Object,` so we can use `String`
    , which is a new value. Finally, we want to add `String` , into the generic array
    that may only contain items of `String` type. Due to default co-variant behavior,
    the compiler can't detect this problem and this will lead to an `ArrayStoreException`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding code would not compile in Kotlin, because the Kotlin compiler
    treats this behavior as potentially dangerous. This is the reason why arrays in
    Kotlin are invariant. Therefore, passing type other than `Array<Number>` when
    `Array<Any>` is required will result in compile time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, passing a type other than `Array<Number>` when `Array<Any>` is required
    will result in a compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that a potential runtime exception may only occur when we can modify
    the object. Variance is also applied to Kotlin collection interfaces. In the Kotlin
    standard library, we have two list interfaces that are defined in different ways.
    The Kotlin `List` interface is defined as co-variant, because it is immutable
    (it does not contain any methods that would allow us to change the inner state),
    while the Kotlin `MutableList` interface is invariant. Here are the definitions
    of their type parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the consequences of such definitions in action. It makes mutable
    lists safe from the risks of covariance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The list is safe, because it has no methods used to change its inner state,
    and its covariance behavior allows more general usage of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We can pass `List<Any>` or any of its subtypes to the `printElements` function,
    because the `List` interface is co-variant. We can only pass `MutableList<Any>`
    to the `addElement` function because the `MutableList` interface is invariant.
  prefs: []
  type: TYPE_NORMAL
- en: Using `in` and `out` modifiers, we can manipulate variance behavior. We should
    also be aware that variance has some limitations. Let's discuss them.
  prefs: []
  type: TYPE_NORMAL
- en: Variance producer/consumer limitation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By applying a variance modifier, we gain co-variant/contra-variant behavior
    for a certain type parameter of the class/interface (declaration-site variance)
    or *type argument* (use-site variance). However, there is a limitation that we
    need to be aware of. To make it safe, the Kotlin compiler limits the positions
    where type parameters can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'With invariant (default no variance modifier on type parameter) we can use
    a type parameter on both `in` (type of function parameter) and `out` (function
    return type) positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: With variance modifier, we are only limited to a single position. This means
    that we can use a type parameter only as a type for method parameters (`in` )
    or method return value (`out` ). Our class can be producer or consumer, but never
    both. We can say that the class *takes in parameters* or *gives out parameters*
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how this restriction relates to variance modifiers specified
    at the declaration-site. Here are all the correct and incorrect usages for the
    two type parameters `R` and `T` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: OK type parameter `T` at in position
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Error, type parameter `R` at in position
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Error, type parameter `T` at out position
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: OK, type parameter `R` at out position
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we can see, the compiler will report an error if the configuration is prohibited.
    Notice that we can add different modifiers for the two type parameters `R` and
    `T` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Position restriction applies only for methods accessible (visible) outside
    the class. This means not only all `public` methods (`public` is the default modifier)
    as used previously, but also methods marked with `protected` or `internal` . When
    we change method visibility to `private` , then we can use our type parameters
    (`R` and `T` ) on any position, just like invariant type parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the following table, which presents all allowed positions for
    type parameters used as type:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Visibility modifier** | **Invariance** | **Covariance (out)** | **Contravariance
    (in)** |'
  prefs: []
  type: TYPE_TB
- en: '| `public` , `protected` , `internal` | in/out | out | in |'
  prefs: []
  type: TYPE_TB
- en: '| `private` | in/out | in/out | in/out |'
  prefs: []
  type: TYPE_TB
- en: Invariant constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one important exception for the `in` and `out` position rules described
    in the previous section: constructor parameters are always invariant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The constructor is public, type parameter `T` is declared as `out,` but we can
    still use it as constructor parameter type at the in position. The reason is that
    the constructor method can't be called after an instance is created, so it is
    always safe to call it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discussed in [Chapter 4](text00088.html) , *Classes and Objects,* we
    can also define a property directly in the class constructor using a `val` or
    `var` modifier. When covariance is specified, we can only define a read-only property
    (`val` ) in the constructor that has co-variant type. It is safe because only
    the getter will be generated, so the value of this property can''t change after
    class instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'With `var` *,* both getter and setter are generated by the compiler, so the
    property value can potentially change at some point. That''s why we can''t declare
    a read-write (`var` ) property of co-variant type in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We already said that variance restriction only applies for external clients,
    so we could still define a co-variant read-write property by adding a private
    visibility modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Another popular generic type restriction, known from Java, relates to type erasure.
  prefs: []
  type: TYPE_NORMAL
- en: Type erasure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type erasure was introduced into JVM to make JVM bytecode backward compatible
    with versions that predate the introduction of generics. On the Android platform,
    both Kotlin and Java are compiled to JVM bytecode, so they both are vulnerable
    to *type erasure* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Type erasure is the process of removing a *type argument* from a generic type,
    so that the generic type loses some of its type information (*type argument* )
    at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The compiler can distinguish both types and guarantee type safety. However,
    during compilation, the parameterized types `Box<Int>` and `Box<String>` are translated
    by the compiler to a `Box` (raw type). The generated Java bytecode does not contain
    any information related to *type arguments* , so we can't distinguish generic
    types at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type erasure leads to a few problems. In JVM, we can''t declare two overloads
    of the same method, with the same JVM signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When the *type argument* is removed, those two methods will have exactly the
    same declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also solve this problem by changing the JVM name of the generated function.
    We can do it using `JvmName` annotation to change the name of one of the methods
    when the code is compiled to JVM bytecode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing changed in this function usage from Kotlin, but since we changed the
    JVM name of the first function, we need to use a new name to use it from Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes we want to preserve the *type argument* at runtime and this is where
    `reified` *type parameters* are quite handy.
  prefs: []
  type: TYPE_NORMAL
- en: Reified type parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are some cases where accessing the type parameter at runtime would be
    useful, but they are not allowed because of type erasure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to overcome JVM limitation, Kotlin allows us to use a special modifier
    that can preserve a *type argument* at runtime. We need to mark the type parameter
    with the reified modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Type parameter marked as refined and function marked as `inline` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can safely access the *type argument* type at runtime. Reified type parameters
    work only with inline functions, because during compilation (inlining), the Kotlin
    compiler replaces reified *type argument* actual class. This way, the *type argument*
    will not be removed by type erasure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use reflection on a reified type to retrieve more information about
    the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Occurrences of a reified type parameter are represented at JVM bytecode level
    as an actual type or a wrapper type for primitive types. That's why reified type
    parameters are not affected by type erasure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using reified type parameters allows us to write methods in a whole new way.
    To start a new `Activity` in Java, we need code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In Kotlin, we can define the `startActivity` method that will allow us to navigate
    to `Activity` in much simpler way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We defined the `startActivity` method and we passed information about the `Activity`
    we want to start (`ProductActivity` ) by using a *type argument* . We also defined
    an explicit reified type parameter bound to make sure that we can only use `Activity`
    (and its subclasses) as *type argument* .
  prefs: []
  type: TYPE_NORMAL
- en: The startActivity method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make proper use of the `startActivity` method, we need a way to pass parameters
    to the `Activity` being started (`Bundle` ). It is possible to update the preceding
    implementation to support arguments like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, arguments are filled using a key and value provided
    by pairs (defined by the inline *to* function). This function implementation is,
    however, outside of the scope of this book. We can, however, use an existing one.
    The **Anko** library ([https://github.com/Kotlin/anko](https://github.com/Kotlin/anko)
    ) already implements the `startActivity` method with all the required functionality.
    We just need to import `Appcompat-v7-commons` dependency.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Anko defines extensions for `Context` and `Fragment` classes so we can use this
    method in any `Activity` or `Fragment` just like any other method defined in the
    class without the need to define the method in the class. We will discuss extensions
    in [Chapter 7](text00171.html) , *Extension Functions and Properties* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Be aware that reified type parameters have one main limitation: we can''t create
    an instance of a class from a reified type parameter (without reflection usage).
    The reason behind this is that a constructor is always only associated to a concrete
    instance (it is never inherited) so there is no constructor that could be safely
    used for all possible type parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: Star-projections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because of type erasure, incomplete type information is available at runtime.
    For example, type parameters of generic types are not available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This leads to a few problems. We can''t perform any check to verify what types
    of elements `List` contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem occurs because a check is performed at runtime where information
    about *t* ype parameters is not available. Kotlin, however, as opposed to Java,
    does not allow us to declare raw type (generic type that is not parametrized with
    *type argument* ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin allows us to use *star-projection* syntax instead, which is basically
    a way to say that information about *type argument* is missing or it is not important:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'By using star-projection syntax, we say that `Box` stores arguments of a certain
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that there is a difference between `Box<*>` and `Box<Any>` . If we want
    to define list contains items of Any we would use `Box<Any>` . However if we want
    to define list that contains terms of certain type, but this type is unknown (it
    may be `Any` , `Int` , `String` , and so on. But we donâ€™t have information about
    this type), while `Box<Any>` means that list contains items of `Any` type. We
    will use `Box<*>` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'If a generic type defines with multiple type parameters, we need to use a star
    (`*` ) for each missing *type argument* :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Star-projection is also helpful when we want to perform an operation on the
    type, but information about *type argument* is not important:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the information about *type argument* is not required
    to determine collection size. Using star-projection syntax reduces the need for
    variance modifiers as long as we don't use any methods that depend on a *type
    argument* .
  prefs: []
  type: TYPE_NORMAL
- en: Type parameter naming conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official Java type parameter naming convention ([https://docs.oracle.com/javase/tutorial/java/generics/types.html](https://docs.oracle.com/javase/tutorial/java/generics/types.html)
    ) defines the following guidelines for parameter naming:'
  prefs: []
  type: TYPE_NORMAL
- en: '*By convention, type parameter names are single, uppercase letters. This stands
    in sharp contrast to the variable naming conventions that you already know about,
    and with good reason. Without this convention, it would be difficult to tell the
    difference between a type variable and an ordinary class or interface name. The
    most commonly used type parameter names are:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*E: Element (used extensively by the Java Collections Framework)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*K: Key*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*N: Number*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*T: Type*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*V: Value*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*S,U,V, and so on: 2nd, 3rd, 4th types*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many classes in the Kotlin standard library follow this convention. It works
    fine for popular kinds of classes such as common classes (`List` *,* `Mat` *,*
    `Set` , and so on) or classes that define a simple type parameter (`Box<T>` class).
    However, with custom classes and multiple type parameters, we quickly realize
    that a single letter does not contain a sufficient amount of information and sometimes
    it's hard to quickly tell what kind of data the type parameter represents. There
    are a few solutions for this problem.
  prefs: []
  type: TYPE_NORMAL
- en: We could make sure that generics are properly documented and, yes, this would
    definitely help, but we still wouldn't be able to determine the meaning of a type
    parameter just by looking at the code. Documentation is important, but we should
    treat documentation as an auxiliary source of information and strive for the highest
    possible code readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over the years, programmers have started to migrate into more meaningful naming
    conventions. The **Google Java Style Guide** ([https://google.github.io/styleguide/javaguide.html#s5.2.8-type-variable-names](https://google.github.io/styleguide/javaguide.html#s5.2.8-type-variable-names)
    ) briefly describes a mix of the official Java type parameter naming convention
    and custom naming conventions. They promote two distinct styles. The first is
    to use a single capital letter, optionally followed by a single numeral (as opposed
    to the `S` *,* `U` *,* `V` names described by Java):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The second style is more descriptive because it adds a meaningful prefix for
    type parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, there is no single standard for type paramete*r* names. The most
    common solution is the use of a single uppercase letter. Those are simplified
    examples, but keep in mind that classes usually use generics in multiple places,
    so proper naming will improve your code readability.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned why generics exist and we have discussed various
    ways of defining a generic class and interface, and declaring generic types. We
    know how to deal with subtyping relations by using use-site and declaration-site
    variance modifiers. We learned how to deal with type erasure and how to preserve
    generic type at runtime using reified type parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss one of the most exciting Kotlin features-extensions.
    This feature allows us to add new behavior to an existing class. We will learn
    how we can implement new methods and properties for any given class, including
    final classes from the Android framework and third-party libraries.
  prefs: []
  type: TYPE_NORMAL

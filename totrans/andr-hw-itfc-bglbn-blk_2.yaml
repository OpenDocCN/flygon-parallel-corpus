- en: Chapter 2. Interfacing with Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, you installed Android on your BBB. You also gathered all
    of the hardware and components that you will need to try out the exercises in
    this book. Now that you have a working Android system and the hardware needed
    to explore it, it is time to dive into Android and find out how to prepare it
    to interface with custom hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Most people would not consider Android and Linux to be very similar, but the
    two have more in common than you might realize. Underneath the polished UIs and
    a wide variety of apps, Android is secretly Linux. Android's filesystem layout
    and services are quite different from those of a typical Linux system, so there
    are certainly many differences between the two in terms of user space (where apps
    and other processes execute). In terms of kernel space (where device drivers execute
    and resources are allocated to each running process), they are almost identical
    in functionality. Understanding how the BBB interacts with Linux kernel drivers
    is the key to creating Android apps that can do the same.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will tell you about Android's hardware abstraction layer,
    or HAL. We will also introduce you to PacktHAL, a special library that you can
    include within your apps to interface with hardware on the BBB. We assume that
    you already have Eclipse **Android Developer Tools** (**ADT**) with the Android
    SDK, the Android **Native Development Kit** (**NDK**), and the **Android Debug
    Bridge** (**ADB**) tools installed and working on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Android HAL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing PacktHAL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Android NDK for PacktHAL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplexing the BBB pins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Are you missing a few tools?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not yet have the Eclipse ADT or Android NDK tools installed on your
    system, you can find installation instructions and download links at these locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eclipse ADT**: [http://developer.android.com/sdk](http://developer.android.com/sdk)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android NDK**: [http://developer.android.com/tools/sdk/ndk](http://developer.android.com/tools/sdk/ndk)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to install ADB is discussed later in this chapter. This chapter assumes
    that you have installed the Eclipse ADT to the `c:\adt-bundle` directory if you
    are using Windows (we make no assumptions for Linux) and that you have installed
    the Android NDK to the `c:\android-ndk` directory (Windows) or `android-ndk` in
    your home directory (Linux). If you have installed these tools to a different
    location, you will have to make a few simple adjustments to a few instructions
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Android HAL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Android kernel contains a few additional features that aren't found in a
    typical Linux kernel, such as **Binder IPC** and the low-memory killer, but otherwise
    it is still Linux. This provides you with one very big advantage when interfacing
    hardware with Android, that is, if a Linux driver already exists in the kernel
    used for an Android system, then you already have an Android driver for that device.
  prefs: []
  type: TYPE_NORMAL
- en: Android apps must interact with the hardware of an Android device by generating
    video and audio data, receiving button and touchscreen input events, and receiving
    sensor events from cameras, accelerometers, and other devices that gather information
    from the outside world. Leveraging existing Linux drivers for these devices makes
    Android support much easier. Unlike a traditional Linux distribution, which grants
    applications permission to directly access many different device files (by directly
    opening files in the `/dev` filesystem), Android dramatically limits the ability
    of processes to directly access hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the number of different Android apps that use the audio functionality
    of the device to play sounds or record audio data. Underneath Android, the Linux
    kernel provides this audio functionality via an **Advanced Linux Sound Architecture**
    (**ALSA**) audio driver. In most cases, only one process at a time can open and
    control the ALSA driver resource. If individual apps were in charge of taking,
    using, and releasing the ALSA driver, it would become a huge mess to coordinate
    audio resource usage among all of the various apps. One misbehaving app can easily
    take control of audio resources and block all other apps from using them! But
    how can the allocation and control of these resources be handled? To solve this
    problem, Android uses *managers*.
  prefs: []
  type: TYPE_NORMAL
- en: Android managers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Managers are the components of the system that control hardware devices on behalf
    of all apps. Every app requires some set of resources (such as audio, GPS, and
    network access) to perform its job. Managers are in charge of allocating and interfacing
    with each of these resources and determining whether an app has permission to
    use that resource.
  prefs: []
  type: TYPE_NORMAL
- en: Having managers deal with these low-level details makes life much easier. Android
    can be installed on a wide variety of hardware platforms that vary wildly in terms
    of physical size and input/output capabilities, and app developers can't be expected
    to have intimate knowledge of each and every platform that their app can be installed
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a resource, an app must create a reference to the proper manager via
    the `getSystemService()` method of the `android.content.Context` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, make information and control requests via this manager reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Apps interact with managers through the Java Android API. While managers respond
    to these Java methods, they must eventually use the **Java native interface**
    (**JNI**) to call the native code that directly interacts with the hardware. This
    is where the true control of the hardware takes place. The bridge between the
    Android API and calls to the native code that control the hardware is known as
    the **hardware abstraction layer** (**HAL**).
  prefs: []
  type: TYPE_NORMAL
- en: The various pieces of the HAL are typically written in C/C++, and each device's
    vendor is responsible for implementing them. If some pieces of the HAL are missing,
    services and apps won't be able to fully utilize all aspects of the hardware platform.
    Various Android services use the HAL to communicate with the hardware, and apps
    use IPC to communicate with these services and gain access to the hardware. The
    services interact with the hardware on an app's behalf (assuming that the app
    has the proper Android permissions to access that particular hardware resource).
  prefs: []
  type: TYPE_NORMAL
- en: The HAL development workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Typically, creating a complete HAL follows these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify or develop a Linux kernel device driver to control the hardware.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a kernel Device Tree overlay that instantiates and configures the driver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Develop a user space library to interface with the kernel device driver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Develop JNI bindings to the userspace library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Develop an Android manager using the JNI bindings to interface with the hardware.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sometimes, it isn't a clear decision as to where a particular piece of custom
    hardware should be properly integrated into the HAL and which manager should be
    in charge of accessing the hardware. What Android permissions control access to
    the hardware? Will the API have to be extended to offer new types of permissions?
    Will a custom service have to be created?
  prefs: []
  type: TYPE_NORMAL
- en: Implementing every aspect of a proper HAL for a piece of custom hardware is
    a bit of an overkill for hobbyists, students, and other developers interested
    in simple experimentation with hardware interfacing. While a commercial Android
    system must address all of these steps to develop a proper HAL, we take a far
    more direct approach to hardware access in this book.
  prefs: []
  type: TYPE_NORMAL
- en: As our focus is on showing how you can interface Android apps with hardware,
    we skip steps 1 through 4 by providing you with **PacktHAL**, a native library
    that implements a very simple HAL. PacktHAL will ease you into the daunting task
    of interfacing with hardware on the BBB, and it provides a set of functions that
    are capable of interfacing with the hardware used in the examples throughout this
    book. Strictly speaking, your apps will act as the manager in charge of each hardware
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: Working with PacktHAL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apps communicate with the native calls of PacktHAL using JNI. PacktHAL demonstrates
    how to perform user space interfacing with hardware via three different interfacing
    methods: `GPIO`, `SPI`, and `I2C`. Using PacktHAL, you have direct access to hardware
    devices. [Chapters 3](part0024_split_000.html#page "Chapter 3. Handling Inputs
    and Outputs with GPIOs") through [Chapter 6](part0041_split_000.html#page "Chapter 6. Creating
    a Complete Interfacing Solution") provide examples of how this interfacing works
    and how you can use it within your own Android app code. Each chapter will examine
    the various pieces of PacktHAL used in the app examples of that chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**How does PacktHAL actually talk to hardware?**'
  prefs: []
  type: TYPE_NORMAL
- en: Generally, any method that allows you to interface with hardware under Linux
    can also be used by the HAL for interfacing. Reading, writing, and making `ioctl()`
    calls to files in the `/dev` filesystem will work, as does using `mmap()` to provide
    access to memory-mapped control registers. PacktHAL uses all of these techniques
    to interface with the hardware that you connect to your BBB.
  prefs: []
  type: TYPE_NORMAL
- en: Using PacktHAL is nowhere near as secure as a proper HAL implementation because
    we must change the permissions on the hardware's user space interfaces such that
    *any* app can access the hardware directly. This can potentially make your system
    vulnerable to malicious apps, so such an approach should never be used in a production
    device. Users that root (gain superuser access to) commercial Android phones and
    tablets often do so to lessen the strict permissions on these devices by default.
    This allows them to install and enable custom features, and it provides more flexibility
    and customization for their devices.
  prefs: []
  type: TYPE_NORMAL
- en: As you are using the BBB as an Android-prototyping device, such an approach
    is the easiest way for you to interact with the hardware. This is a stepping stone
    towards developing your own custom managers and services that speak to your hardware
    on behalf of apps. Ideally, on a commercial device, only an Android manager will
    have the necessary permissions to directly interface with the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you become comfortable with using PacktHAL in your apps, you can then examine
    PacktHAL's source code to better understand how native code interfaces with the
    Linux kernel. Eventually, you might find yourself integrating PacktHAL into your
    own custom managers. You might even find yourself developing custom code for the
    actual kernel!
  prefs: []
  type: TYPE_NORMAL
- en: Installing PacktHAL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the various pieces of PacktHAL are located in the `PacktHAL.tgz` file,
    which is available for download from Packt's website ([http://www.packtpub.com/support](http://www.packtpub.com/support)).
    This is a compressed tar file that contains all of the source code and configuration
    files required to modify BBBAndroid to use PacktHAL and include PacktHAL support
    in your apps.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing PacktHAL under Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have downloaded the `PacktHAL.tgz` file, you must decompress and untar
    it. We will assume that you have copied `PacktHAL.tgz` to your home directory
    after downloading it and will decompress it from there. We will refer to your
    home directory as `$HOME`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the Linux `tar` command to decompress and untar the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A directory named `PacktHAL` now exists in your `$HOME` directory. All of the
    PacktHAL files are located in this directory.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing PacktHAL under Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have downloaded the `PacktHAL.tgz` file, decompress and untar it. We
    will assume that you have copied `PacktHAL.tgz` to the root directory of the `C:`
    drive after downloading it and will use WinRAR to decompress it from there.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Where should I unpack PacktHAL.tgz?**'
  prefs: []
  type: TYPE_NORMAL
- en: You can decompress and untar `PacktHAL.tgz` on the desktop or wherever else
    you wish, but you will be performing some command-line commands to copy files
    around later. It is much simpler to perform these operations if `PacktHAL.tgz`
    is decompressed and untarred in the root directory of the `C:` drive, so we will
    assume that you are performing these operations from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to extract the `PacktHAL.tgz` file:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a file explorer window and navigate to the root of the `C:` drive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `PacktHAL.tgz` file in file explorer and select **Extract
    Here**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A directory named `C:\PacktHAL` now exists. All of the PacktHAL files are located
    in this directory.
  prefs: []
  type: TYPE_NORMAL
- en: The PacktHAL directory structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `PacktHAL` directory has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `cape` subdirectory contains the source code and build script for building
    a Device Tree overlay that enables all of the hardware features that PacktHAL
    needs. You will learn more about Device Tree overlays later in this chapter. The
    `jni` subdirectory contains the source code files that implement PacktHAL. These
    source files will be added to your projects in later chapters to build PacktHAL
    support into your apps. The `prebuilt` directory contains a few premade files
    that must be added to your BBBAndroid image and Android NDK to build and use PacktHAL.
    You will install the files in the `prebuilt` directory to their required locations
    in the next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing Android for PacktHAL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before using PacktHAL with any apps, you have to prepare your BBBAndroid installation.
    By default, Android is very restrictive on the permissions that it assigns to
    hardware devices. To use PacktHAL, you must lessen the permission restrictions
    and configure Android for the hardware that you will interface with. These actions
    require copying some prebuilt files into your Android system to make a few configuration
    changes that relax various Android permissions and configure the hardware properly
    for PacktHAL's use.
  prefs: []
  type: TYPE_NORMAL
- en: You will use the ADB tool to push (`push`) the necessary files over to your
    running BBB system. Prior to pushing the files, boot Android on the BBB and connect
    the BBB to your PC using the USB cable that came with your BBB. Once you have
    reached this point, continue with the instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing PacktHAL files under Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps are used in order to publish PacktHAL files under Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you get started, make sure that ADB can see your BBB by using the `adb
    devices` command. The BBB will report as having a serial number of `BBBAndroid`.
    Execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are missing the `adb` command, install the `android-tools-adb` package
    via `apt-get`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Why can''t Linux find my BBB?**'
  prefs: []
  type: TYPE_NORMAL
- en: If `adb` is installed on your system and you are unable to see the BBB, you
    might need to add a `udev` rule to your system and perform some additional troubleshooting.
    Google provides directions for adding this rule and some troubleshooting steps
    if you run into any difficulty, and this can be found at [http://developer.android.com/tools/device.html](http://developer.android.com/tools/device.html).
  prefs: []
  type: TYPE_NORMAL
- en: BBBAndroid reports the USB device ID of its ADB interface as `18D1:4E23`, which
    is the device ID of a Google Nexus S, so the USB vendor ID for the BBB is 18D1
    (the device ID for Google devices).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have verified that `adb` can see the BBB, change into the `PacktHAL`
    directory, shell into Android via `adb`, and remount the read-only `rootfs` filesystem
    as read-write:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, push the necessary files into Android''s `rootfs` filesystem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, shell into Android''s `rootfs` filesystem to sync it and remount it
    as read-only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You have now prepared your BBBAndroid image for PacktHAL under Linux. Remove
    the power supply cable and USB cable from your BBB to shut it down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, power up the BBB to verify that Android boots properly with the modifications
    that you have just made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pushing PacktHAL files under Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You must locate where your `adb.exe` file is located. It is part of the platform
    tools in the Android SDK. In the following instructions, we are assuming that
    you installed the Eclipse ADT in the `c:\adt-bundle` directory, making the full
    path to `adb` to be `c:\adt-bundle\sdk\platform-tools\adb.exe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps are used in order to publish PacktHAL files under Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you get started, make sure that `adb` can see your BBB by using the
    `adb devices` command. The BBB will report as having a serial number of `BBBAndroid`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Why can''t Windows find my BBB?**'
  prefs: []
  type: TYPE_NORMAL
- en: It can be notoriously difficult to get `adb` to see Android devices under Windows.
    This is because each hardware manufacturer that creates an Android device provides
    its own Windows ADB device driver that Windows uses to talk to that device. BBBAndroid
    reports the USB device ID of its ADB interface as `18D1:4E23`, which is the device
    ID of a Google Nexus S. This device is one of the (many) USB devices that are
    supported by Koushik Dutta's excellent Universal ADB driver for Windows. If `adb`
    can't find your BBB, install the Universal ADB driver and then try again. You
    can download the driver from [http://www.koushikdutta.com/post/universal-adb-driver](http://www.koushikdutta.com/post/universal-adb-driver).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have verified this, `adb` can see the BBB, shell into Android via
    `adb`, and remount the read-only `rootfs` filesystem as read-write:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, push the necessary files into Android''s `rootfs` filesystem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, shell into Android''s `rootfs` filesystem to sync it and remount it
    as read-only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You have now prepared your BBBAndroid image for PacktHAL under Windows. Remove
    the power supply cable and USB cable from your BBB to shut it down. Then, power
    up the BBB to verify that Android boots properly with the modifications that you
    have just made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Why is it that the init.genericam33xx(flatteneddevicetr.rc file is named
    so oddly?**'
  prefs: []
  type: TYPE_NORMAL
- en: Android devices have a set of read-only properties that describe the hardware
    and software of the system to apps and managers. One of these properties is `ro.hardware`,
    which describes the hardware that the kernel is configured for. Device-specific
    `.rc` files in Android have the `init.{ro.hardware}.*rc` form.
  prefs: []
  type: TYPE_NORMAL
- en: In the Linux kernel source, the `arch/arm/mach-omap2/board-generic.c` file uses
    a `DT_MACHINE_START()` macro to specify the name of the BBB platform as `Generic
    AM33XX (Flattened Device Tree)`. This text string is converted to lowercase, spaces
    are removed, and the string is truncated to produce the final string that is stored
    in the `ro.hardware` property.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Android NDK for PacktHAL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, the Android **Native Development Kit** (**NDK**) is missing a
    kernel header file that is needed to build PacktHAL. The missing header describes
    the interface between user space apps and the generic SPI driver (`spidev`, which
    you will use in [Chapter 5](part0035_split_000.html#page "Chapter 5. Interfacing
    with High-speed Sensors Using SPI"), *Interfacing with High-speed Sensors Using
    SPI*). It is not the fault of the NDK that this header file is missing, as usually
    apps will never need direct access to the `spidev` driver.
  prefs: []
  type: TYPE_NORMAL
- en: As you are using an app to talk directly talk to the hardware, you will need
    to copy this missing header into your NDK installation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For your convenience, we have included a copy of this header file in the PacktHAL
    source tarball. You only need to copy the file into your NDK installation prior
    to building PacktHAL.
  prefs: []
  type: TYPE_NORMAL
- en: BBBAndroid is 4.4.4 KitKat, and API level 19 is the highest level supported
    by this version. You will be building all of the examples in this book for API
    level 19\. Each API level has a different set of headers in the NDK, so you must
    add the missing headers to the `include/linux` directory for API level 19\. If
    you decide to build apps at lower API levels, you can repeat the following steps
    to add the additional header file to any of the other API levels that you wish
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the header to the NDK under Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are going to be building apps using Eclipse ADT under Linux, you will
    need to have the Android NDK installed on your Linux system. For these instructions,
    we will assume that you have already installed the NDK to the `android-ndk` folder
    in your `$HOME` directory. As you have already downloaded, decompressed, and untarred
    the `PacktHAL.tgz` file to your `$HOME` directory earlier in this chapter, we
    will assume that the `PacktHAL` directory that you created is still there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will copy the contents of the `spi` header file directory into your NDK
    header files. Your Linux NDK installation now has the extra header file that it
    needs to build PacktHAL.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the header to the NDK under Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are going to be building apps using Eclipse ADT under Windows, you will
    need to have the Android NDK installed on your Windows system. For these instructions,
    we will assume that you have installed the NDK to the `c:\android-ndk` folder.
    As you have already downloaded, decompressed, and untarred the `PacktHAL.tgz`
    file to your `c:\` directory earlier in this chapter, we will assume that the
    `PacktHAL` directory that you created is still there:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a file explorer window and navigate to the `c:\android-ndk\platforms\android-19\arch-arm\usr\include\linux`
    path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a second file explorer window and navigate to the `c:\PacktHAL\prebuilt`
    path. Right-click on the `spi` directory and select **Copy** from the context
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change to the Android NDK window, right-click anywhere within the white space
    of the file list in the window, and select **Paste** from the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will copy the contents of the `spi` header file directory into your NDK
    header files. Your Windows NDK installation now has the extra header file that
    it needs to build PacktHAL.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplexing the BBB pins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As accessing hardware resources follows the same process under Android as it
    does under Linux, it is important to understand how the Linux kernel configures
    device drivers and allocates them to particular pieces of hardware. It is also
    necessary to understand how these kernel drivers provide user space interfaces
    that PacktHAL can interact with.
  prefs: []
  type: TYPE_NORMAL
- en: The BBB's AM3359 processor offers a wide variety of signals on its hundreds
    of pins. These signals include many different, specialized interface buses and
    sensor inputs. There are far too many potential signals for the number of pins
    available to supply these signals to the outside world. To select which signals
    are available on the pins, the pins are multiplexed, or *muxed*, to specific signals.
  prefs: []
  type: TYPE_NORMAL
- en: Several of the processor's pins are wired to the connections of the BBB's P8
    and P9 headers. The muxing of these particular pins is of great interest to BBB
    users, as the muxing determines which processor signals and features are easily
    accessible to the user for hardware interfacing. There are 46 pins on each of
    the BBB's two headers, giving you a total of 92 pins to interface with. Unfortunately,
    61 of these pins are in use by default, meaning that only 31 pins can be changed
    around for your projects without you having to disable one or more standard features
    of the BBB to make more pins available.
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiplexing the BBB pins](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The P8 and P9 expansion headers of the BeagleBone Black
  prefs: []
  type: TYPE_NORMAL
- en: Some pins on the headers are permanently assigned, such as the pins that provide
    access to voltage (1.8, 3.3, and 5 VDC are available) and ground signals. The
    other pins though, can be muxed to meet the needs of your project. Proper muxing
    all of the P8/P9 pins to provide all of the resources that you require can sometimes
    be tricky, particularly if you are only beginning to learn about the hardware
    interfacing aspects of the BBB. Luckily, we have already determined a pinmux configuration
    for you that will provide PacktHAL with all of the hardware resources that it
    needs to run all of the exercises in this book.
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiplexing the BBB pins](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Default pins in use on the BeagleBone Black
  prefs: []
  type: TYPE_NORMAL
- en: The kernel Device Tree and capemgr
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The pins of the BBB must be muxed in a specific way to speak with custom hardware,
    but where and how is this actually done? The answer is "the kernel's **Device
    Tree**." The Device Tree is a hierarchical data structure inside the kernel that
    describes what hardware is present, which resources are used by that hardware,
    and which kernel drivers should be used to talk to each hardware device. It describes
    different facets of the hardware, such as pin muxing settings, clock speeds, and
    parameters that are passed to kernel device drivers.
  prefs: []
  type: TYPE_NORMAL
- en: It would be an annoying hassle if the user was required to install a new kernel
    every time the hardware changed. For a hardware platform like the BBB, the user
    can change the hardware connected to the BBB between power cycles! It would be
    very useful to be able to dynamically change the Device Tree to add or remove
    hardware on the fly. The BBB's Linux 3.8 kernel has a special subsystem, called
    the **cape manager** (**capemgr**) that allows you to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The capemgr dynamically adds and removes pieces or *overlays* of the Device
    Tree. It provides three important services:'
  prefs: []
  type: TYPE_NORMAL
- en: It recognizes any cape hardware that is connected to the BBB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It loads the appropriate Device Tree overlay to enable and configure each recognized
    cape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows arbitrary Device Tree overlays to be loaded dynamically from user
    space to configure any hardware that is not automatically discovered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a cape
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A cape is any hardware add-on that connects to the BBB's P8/P9 connectors (similar
    to how shield boards connect to an Arduino) and contains an **electrically erasable
    programmable read-only memory** (**EEPROM**) chip that reports the cape's identity
    to the kernel's capebus. The capemgr in the kernel can then dynamically enable
    the appropriate Device Tree overlay for that particular cape. This is what allows
    you to connect a variety of different, commercially available cape boards to the
    BBB, and they all just automatically work without you having to change a single
    configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: A much looser definition of a cape is any external circuitry that interfaces
    via the P8/P9 connectors. Without including an EEPROM that tells the capemgr "I
    am a cape and my name is XYZ", the capemgr won't automatically locate and load
    the proper Device Tree overlay for the cape. This is the case for all of the examples
    in this book. You can still consider the hardware that you connect to the BBB
    to be a cape that Android is interfacing with, but the Device Tree overlay must
    be loaded manually from user space.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in this chapter, you used `adb` to push a file named `BB-PACKTPUB-00A0.dtbo`
    to your Android image. This file is the Device Tree overlay that configures the
    BBB for the hardware that you will use in the exercises throughout this book.
    The custom `init.genericam33xx(flatteneddevicetr.rc` file that you also pushed
    over to the Android image manually loads this overlay for you during Android's
    boot process.
  prefs: []
  type: TYPE_NORMAL
- en: In the Linux filesystem, custom overlays are placed into the `/lib/firmware`
    directory. Under Android, however, there is no `/lib` directory in `rootfs`, so
    overlays are instead placed into the `/system/vendor/firmware` directory. This
    is also the location where firmware (`.fw` files) built during kernel compilation
    is installed. When using your own Device Tree overlays for your future projects,
    remember to place them into the `/system/vendor/firmware` directory so that the
    capemgr can find them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Where can I learn more about multiplexing the BBB''s pins, the Device Tree,
    and creating custom overlays?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Learning how to select the best pin muxing for custom projects and creating
    the appropriate Device Tree overlays are outside the scope of this book, but there
    are many excellent resources available that can introduce you to the process.
    Here are a few great resources we recommend that you read to learn more:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The BeagleBone Black System reference manual: [http://www.adafruit.com/datasheets/BBB_SRM.pdf](http://www.adafruit.com/datasheets/BBB_SRM.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Derek Molloy''s website: [http://derekmolloy.ie/category/embedded-systems/beaglebone/](http://derekmolloy.ie/category/embedded-systems/beaglebone/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AdaFruit''s Device Tree Overlay tutorial: [https://learn.adafruit.com/introduction-to-the-beaglebone-black-device-tree](https://learn.adafruit.com/introduction-to-the-beaglebone-black-device-tree)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explained how Android uses a HAL to allow Android managers
    to provide hardware access to apps. We introduced you to PacktHAL that can be
    used to interface with all of the examples throughout this book. You configured
    your BBBAndroid image to use PacktHAL, and you modified your NDK installation
    to build PacktHAL into your apps.
  prefs: []
  type: TYPE_NORMAL
- en: We also showed which pins of the BBB's P8/P9 headers can be multiplexed, what
    the Device Tree is and how it is used to multiplex pins, and how the capemgr loads
    Device Tree overlays to dynamically mux the BBB's pins.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll put PacktHAL to work and build your first hardware-interfacing
    app using GPIOs.
  prefs: []
  type: TYPE_NORMAL

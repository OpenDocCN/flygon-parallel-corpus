- en: Chapter 3. Handling Inputs and Outputs with GPIOs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, you prepared your development PC and BBBAndroid system
    for the development of hardware-interfacing Android apps. Now that your development
    environment is set up and ready to go, you will begin exploring your very first
    app that is capable of direct communication with hardware connected to the BBB.
  prefs: []
  type: TYPE_NORMAL
- en: '**General**-**Purpose Input/Output** (**GPIO**) is one of the most basic interfaces
    in digital electronics. In the examples within this chapter, you will be working
    with GPIOs to receive digital input signals from the outside world and send digital
    output signals back in response. While this is a small start, it is the first
    step in developing and understanding hardware-interfacing apps that are much more
    complex. GPIOs can be used to implement complex and powerful interfacing logic.
    We will discuss both the hardware and software sides of GPIO interfacing and explain
    how calling Java methods in Android apps can interface with low-level hardware-interfacing
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding GPIOs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a GPIO interface circuit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including PacktHAL within your apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the GPIO example app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding GPIOs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At its most basic level, communication between two pieces of hardware requires
    the transmission of data back and forth between them. In computer systems, this
    data is represented as voltage levels sent over a wire that connects the devices
    together. The patterns and levels of voltage back and forth form a communication
    protocol that the devices use to transmit data between each other.
  prefs: []
  type: TYPE_NORMAL
- en: GPIO is the most basic interfacing option offered by microcontrollers and microprocessors.
    Some pins of the BBB's processor are allocated as GPIOs that act as an *input*
    (monitoring voltage on the wire to receive data) or an *output* (placing a particular
    voltage on the wire to send data). The BBB has dozens of available GPIO pins,
    which makes GPIO a flexible and simple way for Android apps to interact with the
    outside world without requiring fancy device drivers or extra interfacing hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Nuts and bolts of GPIO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Digital logic operates on the concept that there are two discrete voltage levels
    that represent an *on/high* state and an *off/low* state. By toggling between
    these two states, binary bits of data are transmitted between devices. The BBB
    uses the voltage of 3.3 V for its high level and a voltage of 0 V (connected to
    a ground) for the low level. This voltage scheme is known as a *3.3 V logic level*,
    and it is commonly used for single-board computers such as the BeagleBoard and
    Raspberry Pi. Many microcontrollers (many Arduinos, for example) use a 5 V logic
    level instead.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Never apply more than 3.3 V to any BBB pin!**'
  prefs: []
  type: TYPE_NORMAL
- en: Applying greater than 3.3 V to a BBB GPIO can fry the BBB's processor, so always
    make sure that you only work with a maximum of 3.3 V when designing the GPIO interface
    circuitry for the BBB. Pins P9.3/4 supply 3.3 V, and pins P9.5/6 supply 5 V. It
    is very simple to accidentally connect a breadboard wire to the pins supplying
    5 V when you intended to use the 3.3 V pins. To help avoid this mistake, try covering
    the P9.5/6 pins with a piece of tape. This prevents you from accidentally inserting
    a breadboard wire into these pins.
  prefs: []
  type: TYPE_NORMAL
- en: The BBB's processor has four banks of GPIOs, with 32 individual GPIOs in each
    bank. With only 92 pins available on the P8/9 connectors, it is not possible to
    give every GPIO access to the outside world. In fact, the BBB's System Reference
    Manual shows that it is only possible to mux about 65 unique GPIOs to P8/P9 at
    the same time, even if every other feature being muxed to P8/9 was disabled. There
    are a few other GPIOs that are used internally for tasks such as lighting and
    blinking the BBB's LEDs, but you should consider yourself restricted to only using
    the GPIOs that are accessible via P8/P9 and that do not conflict with any of the
    standard BBB features.
  prefs: []
  type: TYPE_NORMAL
- en: GPIO access methods under Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two basic approaches to interacting with GPIOs on the BBB: **file
    I/O** and **memory-mapping**. With the file I/O, you pass GPIO requests through
    a kernel driver by reading and writing to GPIO files in the filesystem. With memory-mapping,
    you map the GPIO control resistors into memory and then read and write these mapped
    memory locations to directly manipulate the control resistors. As both of these
    methods are made possible by the Linux kernel, they will both work just as well
    under Android as they do under Linux.'
  prefs: []
  type: TYPE_NORMAL
- en: Pros and cons of the file I/O method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The file I/O method can be performed by any process that has the proper permissions
    to read/write the GPIO device files. However, like any file I/O operation, this
    can be quite slow.
  prefs: []
  type: TYPE_NORMAL
- en: Pros and cons of the memory-mapping method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The memory-mapping method allows you to directly access the resistors that control
    the GPIOs. Memory-mapping is very fast (about 1000 times faster than file I/O!),
    but only processes with root permissions can use it.
  prefs: []
  type: TYPE_NORMAL
- en: As your apps are unable to execute with root permissions without some serious
    permission changes, you will be unable to use memory-mapping to access GPIOs.
    This effectively restricts you to only using file I/O for your apps.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PacktHAL implements both memory-mapping and file I/O for GPIO access. If you
    are interested in the low-level details of how both of these approaches work,
    examine the `jni/gpio.c` file in `PacktHAL.tgz`.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing Android for GPIO use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 2](part0019_split_000.html#page "Chapter 2. Interfacing with Android"),
    *Interfacing with Android*, you used `adb` to push two prebuilt files from PacktHAL
    to your Android system. These two files, `BB-PACKTPUB-00A0.dtbo` and `init.{ro.hardware}.rc`,
    configure your Android system to enable specific GPIOs and allow your apps to
    access them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that when we talk about the `init.{ro.hardware}.rc` file, we are referring
    to the `init.genericam33xx(flatteneddevice.tr` file in the root directory of the
    Android filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BB-PACKTPUB-00A0.dtbo` file is a Device Tree overlay that muxes the BBB
    to support all of the examples in this book. As far as GPIOs are concerned, this
    overlay muxes the P9.11 and P9.13 pins into GPIOs. In the `PacktHAL.tgz` file,
    the source code for the overlay is located in the `cape/BB-PACKTPUB-00A0.dts`
    file. The code responsible for muxing the two GPIOs is located in the `bb_gpio_pins`
    node within `fragment@0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The details of the hex values used in the `bb_gpio_pins` node are beyond the
    scope of this book. However, the general idea is that they specify which pin is
    of interest, which mode the pin should be muxed to, a few details about pull-up/pull-down
    resistors, whether it is an input or an output pin, and whether any skewing adjustments
    should be made to the signal.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The details of what skew is and how to adjust for it are beyond the scope of
    this book. If you would like to learn more about skewing, we suggest the Wikipedia
    page on the subject as a good starting point ([http://en.wikipedia.org/wiki/Clock_skew](http://en.wikipedia.org/wiki/Clock_skew)).
  prefs: []
  type: TYPE_NORMAL
- en: At boot, this overlay is loaded by the `init.{ro.hardware}.rc` file. The kernel
    then knows which pins are treated as GPIOs. After loading the overlay, the `init.{ro.hardware}.rc`
    file then executes a few commands that explicitly "unlock" these GPIO files for
    use by apps by *exporting* them. Exporting a GPIO pin creates a series of files
    in the `/sys` filesystem that can be read and written to interact with that GPIO
    pin.
  prefs: []
  type: TYPE_NORMAL
- en: 'By exporting a GPIO pin and then changing the permissions of the proper files
    in the `/sys` filesystem via `chmod`, any process can read from or write to GPIOs.
    This is exactly what the commands in the `init.{ro.hardware}.rc` file do to allow
    Android apps to interface with GPIOs. The following portion of the `init.{ro.hardware}.rc`
    file performs the export and `chmod` operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Each GPIO has a specific integer identifier that is determined by the bank the
    GPIO belongs to and its position within that bank. In our case, the GPIO muxed
    to P9.11 is the 30th GPIO in bank 0, and P9.13 is the 31st GPIO in bank 0\. This
    makes their integer identifiers 30 and 31, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GPIO pins 30 and 31 are only available via the `/sys` filesystem because
    they were explicitly exported via the `write` commands in the `init.{ro.hardware}.rc`
    file. Other GPIO pins will not be available via the filesystem unless they are
    also explicitly exported in the same fashion.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very insecure way of allowing GPIO access because it opens up the
    GPIOs for use by processes that we might not want to have direct access to them.
    For experimentation and prototyping, this is not a problem. However, you certainly
    should not do this in a commercial system. Unless you develop a proper, privileged
    Android manager to handle the GPIO resources, you must allow *all* processes to
    access the GPIO files unless you tailor the permissions to only be usable by apps
    belonging to a specific user or group. As each app is assigned its own user, you
    would have to chown the GPIOs to the proper user and group after you install the
    app's `.apk` file onto the system.
  prefs: []
  type: TYPE_NORMAL
- en: Building a GPIO-interfacing circuit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you begin developing software that communicates using GPIOs, you must
    first construct a hardware circuit for the GPIOs to interface with. For this chapter,
    you will build a simple circuit that consists of a 1k ohm resistor, an LED, and
    a pushbutton switch. Part numbers and suppliers for these components were listed
    in [Chapter 1](part0014_split_000.html#page "Chapter 1. Introduction to Android
    and the BeagleBone Black"), *Introduction to Android and the BeagleBone Black*.
    Before getting started, be sure that you have all of the proper parts and remove
    all power sources from your BBB (unplug the power supply and USB cables) prior
    to connecting anything to the BBB's P8/P9 connector.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Don''t disassemble your circuit!**'
  prefs: []
  type: TYPE_NORMAL
- en: The GPIO circuit in this chapter is part of a much larger circuit used in [Chapter
    6](part0041_split_000.html#page "Chapter 6. Creating a Complete Interfacing Solution"),
    *Creating a Complete Interfacing Solution*. If you build the circuit as it is
    positioned in the following diagram (towards the top of the breadboard), you can
    simply leave the GPIO components and wires in place as you build the remaining
    circuits in this book. This way, it will already be constructed and working when
    you reach [Chapter 6](part0041_split_000.html#page "Chapter 6. Creating a Complete
    Interfacing Solution").
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The circuit that you will build interfaces with the following four BBB''s pins:'
  prefs: []
  type: TYPE_NORMAL
- en: P9.1 (ground)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: P9.3 (3.3 V)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: P9.11 (GPIO)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: P9.13 (GPIO)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The P9.11 pin is configured as an output GPIO, and it drives the LED. The P9.13
    pin is configured as an input GPIO, and it sets its state depending upon the input
    voltage that is applied to it. Both GPIO pins are configured by the `BB-PACKTPUB-00A0.dtbo`
    overlay to use an internal pull-up resistor. If you are not familiar with what
    a pull-up resistor is, don't worry. For the purposes of these examples, it simply
    means that the logic level of the GPIOs will not "float" between on and off if
    nothing is attached to the GPIO pins. Instead, the logic level will be "pulled-up"
    to the on state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interested in learning more about what a pull-up resistor is and how it works?
    We suggest that you check out this online tutorial on pull-up and pull-down resistors,
    available at [http://www.resistorguide.com/pull-up-resistor_pull-down-resistor](http://www.resistorguide.com/pull-up-resistor_pull-down-resistor).
  prefs: []
  type: TYPE_NORMAL
- en: Breadboards typically have two vertical buses on either side that run almost
    the entire length of the breadboard. These buses are used to provide convenient
    access to power and ground signals for any components inserted into the breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![Constructing the circuit](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The complete GPIO-interfacing circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can start constructing our circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the BBB's ground (P9.1) and 3.3 V (P9.3) signals to the two vertical
    buses on the breadboard. The ground bus is the vertical bus towards the center
    of the breadboard. The 3.3 V bus is the vertical bus towards the edge of the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, connect the anode, or the positive lead, of the LED to P9.11\. LEDs have
    a polarity, so current will only flow through them in one direction. Current flows
    from the longer lead (the anode) of the LED to the shorter lead (the cathode).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the LED's leads have been cut to the same length and you are unable to tell
    which lead is which, feel around the edge of the LED's plastic casing. The edge
    of the casing is flat on the cathode side and rounded on the anode side. As long
    as the cathode is connected to the ground and the anode is connected to the GPIO
    pin, the LED will work properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You must limit the current drawn by the LED to ensure that you do not damage
    the GPIO pin, so place a 1K ohm resistor between the LED's cathode lead and the
    ground signal. Resistors do not have a polarity like LEDs do, so the direction
    that you connect it to the breadboard will not matter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you wish to learn more about using a current-limiting resistor with an LED,
    such as selecting the right resistor for the task, we suggest that you read the
    tutorial from SparkFun, available at [https://www.sparkfun.com/tutorials/219](https://www.sparkfun.com/tutorials/219).
  prefs: []
  type: TYPE_NORMAL
- en: Now that the LED and resistor have been connected to the BBB, you must connect
    the pushbutton switch. Different switches have different numbers of leads, but
    the switch that we suggested for your use has a total of four leads. These leads
    form two pairs of two leads each. The two leads in each pair are always electrically
    connected to each other, but one pair will only be electrically connected to the
    other pair when the button is being pressed. Two sides of the switch are smooth,
    and the other two sides have two protruding leads on each side. The two protruding
    leads on a single side of the switch belong to different pairs of leads. Pick
    one side of the switch with two leads on it and connect one lead to P9.13 and
    the other lead to the breadboard's ground bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your circuit is now complete. Double-check your wiring against the diagram of
    the complete GPIO-interfacing circuit to ensure that everything is connected properly.
  prefs: []
  type: TYPE_NORMAL
- en: Checking your wiring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have completed the wiring of the GPIO circuit, you should test it to
    ensure that it works properly. Luckily, you can do this easily by shelling into
    the BBB and working with the exported GPIO pin files. We will assume that you
    are using `adb` to shell into the Android system, but using the FTDI to access
    the console shell will work in exactly the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**How do I use the FTDI cable?**'
  prefs: []
  type: TYPE_NORMAL
- en: If you have never used an FTDI cable to communicate with your BBB, there is
    a page on the [www.elinux.org](http://www.elinux.org) wiki (maintained by the
    BeagleBoard.org staff) that can help you get started, which is [http://elinux.org/Beagleboard:Terminal_Shells](http://elinux.org/Beagleboard:Terminal_Shells).
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will only be using the USB cable and ADB shell to access the
    BBB. However, learning how to use the FTDI to monitor and troubleshoot your BBB
    can really come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect power to your BBB and then use the USB cable to connect the BBB to
    your development system. After shelling into the BBB, begin testing your GPIO
    circuit using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change into the directory for the GPIO pin muxed to P9.11 (GPIO pin 30):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `echo` command to turn the LED on by forcing the state of this GPIO
    to 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The LED will now be turned on. Use the `echo` command to turn the LED off by
    forcing the state of this GPIO to 0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The LED will now be turned off. Change into the directory for the GPIO pin
    muxed to P9.13 (the GPIO pin 31):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `cat` command to check the current state of the pushbutton switch.
    When executing this command, make sure that you are not pushing the button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, execute the following `cat` command while holding down the button. You
    should type the entire command, press the button, and then hit the *Enter* key
    to enter the command while still holding the button down:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pushbutton values look reversed because of how the circuit is wired. The
    pull-up resistor on P9.13 will pull the value of the GPIO to `1` when the button
    is not pressed. When the button is pressed, the P9.13 pin becomes connected to
    the ground signal and changes the GPIO to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: If you saw the LED turn on and off and the correct values were returned when
    the switch was pressed and released, you have correctly wired the circuit. If
    the LED did not light up, make sure that you have not accidentally swapped the
    anode and cathode leads of the LED. If the switch always returns a value of 0,
    make sure that you have connected the correct pair of leads on the switch to the
    ground signal bus and P9.13.
  prefs: []
  type: TYPE_NORMAL
- en: Including PacktHAL within your apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into using PacktHAL to interface with GPIOs, you must understand
    how to include PacktHAL support in your apps. We will walk you through the process
    of adding the PacktHAL code into your app and then building it. PacktHAL will
    be packaged with your app in the`.apk` app as a shared library. The source code
    for the library exists within the app's project directory, but it is built separately
    from the Java code of the app. You must manually build the PacktHAL shared library
    before your app can include it within the `.apk` app and use it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We include a prebuilt version of the PacktHAL library in each of the example
    app projects included with this book, so you can jump into building and running
    the example apps right away without worrying about the details of building PacktHAL.
    Once you begin creating your own custom apps and modifying PacktHAL for your own
    hardware projects, you will need to understand how to build PacktHAL from source.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Java Native Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android apps are written in Java, but the functions in PacktHAL are written
    in C native code. Native code is the code that is compiled into a native binary,
    such as a shared library or executable, and then executed directly by the Android
    OS. Native code is built using the compiler toolchain supplied within the Android
    NDK. Native binaries are not as portable as the "build once, run anywhere" bytecode
    of Android apps, but they can be used for low-level interfacing in ways that Java
    code cannot. Unlike Java bytecode, which is executable on any platform that has
    a proper virtual machine, native code is compiled for one specific hardware architecture
    (such as ARM, x86, or PowerPC) and can be executed only on that architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Functions implemented in native code are called from an app's Java code via
    the **Java Native Interface** (**JNI**). JNI is a popular interfacing mechanism
    that Java applications use to interact with native C/C++ code. Among other features,
    JNI is used to *translate* Java datatypes into C datatypes and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the Java `String` type. While Java has a `String` implementation,
    there is no equivalent type in C. The string must be suitably converted to a compatible
    type before it can be used by the C code. Each Java type is represented in C by
    a series of equivalent types, such as `jint`, `jstring`, and `jboolean`, which
    are defined in the standard `jni.h` header file that is supplied by the Android
    NDK.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new app project that uses PacktHAL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps demonstrate how you can create a new custom app that includes
    PacktHAL:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch the Eclipse ADT and select the menu option **File**, then **New**, then
    **Android Application Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **New Android Application** dialog, enter `myapp` into the **Application
    Name** field. This will automatically populate the **Project Name** and **Application
    Name** fields. Change the **Minimum Required SDK**, **Target SDK**, and **Compile
    With** fields to **API 19: Android 4.4**. The theme field can be left alone or
    changed to whichever theme you would like for your app. When finished, click on
    the **Next** button.![Creating a new app project that uses PacktHAL](img/00011.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The New Android Application screen
  prefs: []
  type: TYPE_NORMAL
- en: Proceed through the successive dialog screens, retaining the default settings
    for each screen, until you click on the **Finish** button on the final screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The name of the default activity created for your new app is `MainActivity`.
    After creating the new project, the folder structure of your new `myapp` project
    will reside in the `myapp` (`$PROJECT`) directory and have a directory structure
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After creating the app for the first time, several new folders will be created
    to hold the various intermediary files created during the build process. Once
    you have created your app, you must add the PacktHAL code to it and compile it.
  prefs: []
  type: TYPE_NORMAL
- en: Building PacktHAL under Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PacktHAL must be built into a library and included within your app''s project
    codebase to be used by your app. Assuming that you decompressed and untarred the
    `PacktHAL.tgz` file in `c:\`, you can copy the PacktHAL code into your app''s
    project directory (`$PROJECT`) using the following process:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a file explorer window and browse to the `$PROJECT` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a second file explorer window and browse to `c:\PacktHAL`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `jni` directory in the `c:\PacktHAL` directory and select
    **Copy** from the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click anywhere convenient on white space within the `$PROJECT` directory
    window and then select **Paste** from the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that the `jni\` directory exists in your `$PROJECT` directory, you can
    build PacktHAL using the Android NDK. Assuming that you installed the Android
    NDK in `c:\android-ndk`, you can build PacktHAL using the following process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch `cmd.exe` for a command prompt window. Using the command prompt, change
    into the `$PROJECT` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the PacktHAL library using the Android NDK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The PacktHAL library is now built and present in your project as the file `$PROJECT\libs\armeabi\libpacktHAL.so`.
  prefs: []
  type: TYPE_NORMAL
- en: Building PacktHAL under Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PacktHAL must be built into a library and included within your app''s project
    codebase to be used by your app. Assuming that you decompressed and untarred the
    `PacktHAL.tgz` file in your `$HOME` directory, you can copy the PacktHAL code
    into your app''s project directory (`$PROJECT`) using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the `jni` directory exists in your `$PROJECT` directory, you can build
    PacktHAL using the Android NDK. Assuming that you installed the Android NDK in
    `$HOME/android-ndk`, you can build PacktHAL using the following process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change into the `$PROJECT/jni` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the PacktHAL library using the Android NDK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The PacktHAL library is now built and present in your project as the `$PROJECT/libs/armeabi/libpacktHAL.so`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the GPIO example app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will examine the example Android app that performs GPIO
    interfacing on BBB. The purpose of this application is to demonstrate how to use
    PacktHAL to perform GPIO read and write processes from within an actual app. PacktHAL
    provides a set of interfacing functions that you will use to work with GPIOs from
    within your Android apps. These functions allow you to read the values of input
    GPIOs and set the values of output GPIOs. The low-level details of the hardware
    interfacing are implemented in PacktHAL, so you can quickly and easily get your
    apps interacting with GPIOs.
  prefs: []
  type: TYPE_NORMAL
- en: Before digging through the GPIO app's code, you must install the code to your
    development system and install the app to your Android system. The source code
    for the app, as well as a precompiled `.apk` package, are located in the `chapter3.tgz`
    file, which is available for download from the book's website.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the app and source under Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have downloaded the `chapter3.tgz` file, you must decompress and untar
    it. We will assume that you have copied `chapter3.tgz` to the root directory of
    `c:\` after downloading it and will decompress it from there. We will refer to
    your workspace directory as `$WORKSPACE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will assume that your `adb.exe` binary is in your current path. If it is
    not, call `adb` by using the full path to the `adb.exe` binary:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a file explorer window and navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `chapter3.tgz` file in file explorer and select **Extract
    Here**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A directory named `c:\gpio` now exists, and it contains all of the files for
    the GPIO example app. You must import this project into your Eclipse ADT workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch Eclipse ADT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **File** menu and select **Import**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Import** dialog, expand the **Android** folder and highlight **Existing
    Android Code Into Workspace**. The **Next** button at the bottom of the dialog
    will become active. Click on it to continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Import Projects** dialog, type `c:\gpio` in the **Root Directory**
    text field. Then, click on the **Refresh** button. The **gpio** project will appear
    on the list of projects to import.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Select All** button, then select the checkbox for **Copy projects
    into workspace**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Finish** button to import the `gpio` app project into your workspace
    and copy the `c:\gpio` directory into your `$WORKSPACE` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All of the project files for the GPIO app are now located in that `gpio` directory.
    A prebuilt `.apk` package for the app is provided in the `$WORKSPACE\gpio\bin`
    directory. You can install this `.apk` package directly to your Android system
    using `adb`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch `cmd.exe` for a command prompt window. Using the command prompt, change
    into the `$WORKSPACE\gpio\bin` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that `adb` can see your BBB using the `adb devices` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Install `gpio.apk` to your Android system via the `install` command in `adb`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have already installed the `gpio.apk` app once and are now receiving
    the failure message of `INSTALL_FAILED_ALREADY_EXISTS`, use `adb` to reinstall
    `gpio.apk`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `gpio.apk` app is now installed on your Android system, and the app's source
    is now installed in your Eclipse ADT workspace.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the app and source under Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have downloaded the `chapter3.tgz` file, you must decompress and untar
    it. We will assume that you have copied `chapter3.tgz` to your `$HOME` directory
    after downloading it and will decompress it from there. We will refer to your
    workspace directory as `$WORKSPACE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the Linux `tar` command to decompress and untar the `chapter3.tgz` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A directory named `gpio` now exists in your `$HOME` directory, and it contains
    all of the files for the gpio example app. You must import this project into your
    Eclipse ADT workspace as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch Eclipse ADT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **File** menu and select **Import**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Import** dialog, expand the `Android` folder and highlight **Existing
    Android Code Into Workspace**. The **Next** button at the bottom of the dialog
    will become active. Click on it to continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Import Projects** dialog, type `$HOME/gpio` (substituting in the full
    path for `$HOME`) in the **Root Directory** text field. Then, click on the **Refresh**
    button. The **gpio** project will appear on the list of projects to import.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Select All** button, then select the checkbox for **Copy projects
    into workspace**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Finish** button to import the gpio app project into your workspace
    and copy the `$HOME/gpio` directory into your `$WORKSPACE` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All of the project files for the app are now located in the `$WORKSPACE/gpio`
    directory. A prebuilt `.apk` package for the gpio project is provided in the `gpio/bin`
    directory. You can install this `.apk` package directly to your Android system
    using `adb`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change into the `bin` directory of the `gpio` project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that `adb` can see your BBB using the `adb devices` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Install `gpio.apk` to your Android system via the `install` command in `adb`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have already installed the `gpio.apk` app once and are now receiving
    the failure message of `INSTALL_FAILED_ALREADY_EXISTS`, use `adb` to reinstall
    `gpio.apk`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `gpio.apk` app is now installed on your Android system, and the app's source
    is now installed in your Eclipse ADT workspace.
  prefs: []
  type: TYPE_NORMAL
- en: The app's user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Launch the `gpio` app on the Android system to see the app's (UI). If you are
    using a touchscreen cape, you can simply touch the gpio app icon on the screen
    to launch the app and interact with its UI. If you are using the HDMI for video,
    connect a USB mouse to the BBB's USB port and use the mouse to click on the gpio
    app icon to launch the app.
  prefs: []
  type: TYPE_NORMAL
- en: The app uses a very simple UI to interact with the GPIOs. As it is so simple,
    the only activity that the app has is default `MainActivity`. The UI consists
    of only three buttons and text view.
  prefs: []
  type: TYPE_NORMAL
- en: '![The app''s user interface](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The GPIO sample app screen
  prefs: []
  type: TYPE_NORMAL
- en: The **Poll Button State** button checks the current state of the pushbutton
    switch and updates the value of the **Button State** text view to report that
    state. The switch state will be reported as **UNKNOWN** until the **Poll Button
    State** button is pressed for the first time. The **Turn light on** button will
    turn on the LED if it is not already on, and the **Turn light off** button will
    turn the LED off.
  prefs: []
  type: TYPE_NORMAL
- en: 'The text view has an ID associated with it in `res/layout/activity_main.xml`
    so that the app can update the text view''s value programmatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the three buttons have an `onClick()` handler defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Each `onClick()` handler will trigger one of the PacktHAL GPIO functions to
    read the state of a GPIO or write a new state to a GPIO.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need a refresher on the fine details of the various Android UI elements,
    there are several resources available online that can help you. We recommend that
    you start with the official Android Developer website at [http://developer.android.com/guide/topics/ui/index.html](http://developer.android.com/guide/topics/ui/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Calling the PacktHAL functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The GPIO interface functionality in PacktHAL is implemented in four C functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`openGPIO()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readGPIO()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`writeGPIO()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`closeGPIO()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The prototypes for these functions are located in the `jni/PacktHAL.h` header
    file within the app''s project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Ideally, you would load the PacktHAL shared library into your app and then simply
    call the library functions directly to control the GPIOs. The example app actually
    *does* load the PacktHAL library via a `System.loadLibrary()` call, but then things
    become less straightforward because these C functions cannot be called directly.
    You must specify Java methods that, when called, actually call the C functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MainActivity` class specifies four methods with the `native` keyword to
    call the PacktHAL C functions in `MainActivity.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'These four Java methods specified in `MainActivity` are not actually a direct
    mapping to the C functions of the same name in PacktHAL. Notice that the GPIO
    methods in `MainActivity` are all `private native` within the scope of the class.
    Any method defined with the `native` keyword will attempt to call a native *JNI
    wrapper function* when it is invoked. However, the naming of the invoked JNI wrapper
    function follows some very specific rules that represent the scope of its Java-side
    method. The following figure shows how these JNI wrapper functions finally call
    the GPIO-interfacing functions inside of PacktHAL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calling the PacktHAL functions](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The MainActivity methods and the PacktHAL GPIO-interfacing functions that they
    call
  prefs: []
  type: TYPE_NORMAL
- en: Each `native` method in the `MainActivity` class with the name `name()` will
    use JNI to call a JNI wrapper function with the name `Java_com_packt_gpio_MainActivity_name()`.
    The name of this wrapper function is determined by replacing each `.` in the fully
    qualified name of the app with an underscore. The `Java_` prefix of the function
    name tells Android that the function is being called via a method in a Java class.
    There are a few exceptions to this JNI naming convention, but this general rule
    will get you through most cases.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Do I need to know all about JNI to make my own Android interfacing projects?**'
  prefs: []
  type: TYPE_NORMAL
- en: Not really. Using JNI can be quite confusing, and many, many books and tutorials
    have been dedicated to describing it in great detail. For now, don't worry about
    not knowing everything that there is to know about JNI. When you have spent some
    time experimenting with hardware interfacing under Android, you can revisit this
    topic and learn more of the fine details of how JNI works. In this book, we will
    focus on showing you just enough information about JNI to get you started.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, our Java `openGPIO()` method in the `MainActivity` class for
    the `com.packtpub.gpio` example app uses JNI to call the wrapper C function `Java_com_packtpub_gpio_MainActivity_openGPIO()`.
    This is a little confusing, but still very manageable. PacktHAL implements these
    JNI wrapper C functions in the `jni/packt_native_gpio.c` file. Looking at this
    source file, you can see where the `Java_com_packtpub_gpio_MainActivity_openGPIO()`
    function in PacktHAL calls the `openGPIO()` C function in PacktHAL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Why not just do away with the separate `openGPIO()` C function and place all
    of the hardware interface code inside `Java_com_packt_gpio_MainActivity_openGPIO()`?
    Functions such as `openGPIO()` in PacktHAL will usually not change once you have
    them working properly, and you can use these same functions under both Linux and
    Android. Wrapper functions such as `Java_com_packt_gpio_MainActivity_openGPIO()`
    will change their name and implementation details based upon how and where they
    are invoked from an app's Java code. It is better to isolate functionality that
    will not change in its own function. This avoids your accidentally breaking something
    when customizing or renaming the functions invoked via JNI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just remember that a Java method in your app, such as `openGPIO()` in the `MainActivity`
    class, makes a JNI call to invoke a PacktHAL C function with a long, mangled name
    like `Java_com_packt_gpio_MainActivity_openGPIO()`. The JNI wrapper function will
    then call one of the PacktHAL C functions, for example, `openGPIO()`, that actually
    controls the hardware. From the app developer's point of view, once you sort out
    the JNI wrapper function details, it is almost like calling the C function that
    controls the hardware directly from the Java app code!
  prefs: []
  type: TYPE_NORMAL
- en: Using the PacktHAL GPIO functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have seen how the PacktHAL GPIO functions are called from Java,
    you will see what each of these functions does and how you can use them.
  prefs: []
  type: TYPE_NORMAL
- en: The `openGPIO()` function initializes your app's access to GPIOs. This function
    offers you two different methods for GPIO interfacing, of which you select one
    method using `openGPIO()` function's `useMmap` parameter. The two methods are
    file I/O (by setting `useMmap` to 0) and memory-mapping (by setting `useMmap`
    to any non-zero number). To change from one interfacing method to the other, you
    must call `closeGPIO()` to shut down the GPIO portion of PacktHAL and then call
    `openGPIO()` again with a different value for `useMmap`.
  prefs: []
  type: TYPE_NORMAL
- en: Processes must run as `root` to use memory- mapping to directly access the GPIO
    control resistors. As apps cannot run as root, the JNI wrapper function always
    passes `0` as the `useMmap` argument to `openGPIO()` to force the use of file
    I/O to interact with GPIOs. The `openGPIO()` method in the `MainActivity` class
    does not accept any arguments because of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example app calls the `openGPIO()` method from the `onCreate()` method
    of the `MainActivity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The complementary call to the `closeGPIO()` method is made by the `onDestroy()`
    method of the `MainActivity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `readGPIO()` method reads the state of a particular input GPIO. Both the
    PacktHAL `readGPIO()` function and the `readGPIO()` method in `MainActivity` take
    the same two parameters. The first parameter is a connector number on the BBB
    (8 or 9), and the second parameter is a pin location on that connector (1 through
    42). The `readGPIO()` method is called from within the `onClick()` handler of
    the `PollStatus` button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In `onClickPollStatus()`, the `readGPIO()` method call is reading the state
    of the GPIO pin P9.13\. This is the GPIO pin that you connected to the pushbutton
    switch. If the switch is pressed when the `readGPIO()` method is called, `true`
    is returned. Otherwise, `false` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `writeGPIO()` method is used to set the state of an output GPIO. Both the
    PacktHAL `writeGPIO()` function and the `writeGPIO()` method in `MainActivity`
    take three parameters. The first parameter is the connector number on the BBB
    (8 or 9), the second parameter is a pin location on that connector (1 through
    42), and the third parameter is the value to set (0 or 1). The `writeGPIO()` method
    is called from within the `onClick` handlers of the `LightOn` and `LightOff` buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In both of these `onClick()` handlers, the GPIO being set is P9.11\. This is
    the GPIO pin that you connected to the LED. The `onClickButtonLightOn()` method
    sets the GPIO to 1, turning the LED on. Likewise, the `onClickButtonLightOff()`
    method sets the GPIO to 0, turning the LED off.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Are you ready for a challenge?**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen all of the pieces of the gpio app, why not change it
    to add new functionality? For a challenge, try changing the app to use only a
    single button that toggles the state of the LED. If the LED is currently off,
    pressing the button will turn it on and vice versa. We have provided one possible
    implementation of this in the `chapter3_challenge.tgz` file, which is available
    for download from the book's website.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced you to GPIOs and how they work. You constructed
    a circuit that uses GPIOs for both input and output, and then you did some basic
    testing on the circuit to ensure that the circuit was constructed properly and
    that the kernel is able to interact with the circuit via the filesystem. You also
    learned about the portions of the PacktHAL `init.{ro.hardware}.rc` file and `BB-PACKTPUB-00A0.dtbo`
    Device Tree overlay that are responsible for configuring GPIOs and making them
    available for your app's use.
  prefs: []
  type: TYPE_NORMAL
- en: We showed you how to add PacktHAL into a newly created app project and how to
    build PacktHAL using the Android NDK. Then, you learned how JNI integrates PacktHAL
    into your Java app via JNI wrapper functions and explored how each GPIO function
    of PacktHAL is called and used from within an app.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to integrate I2C bus devices into your
    apps and begin interacting with hardware that is much more sophisticated than
    the basic on/off logic of GPIOs.
  prefs: []
  type: TYPE_NORMAL

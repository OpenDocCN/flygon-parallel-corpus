- en: Chapter 3. Interfacing Java and C/C++ with JNI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用JNI在Java和C/C++之间进行接口
- en: '*Android is inseparable from Java. Its kernel and core libraries are native,
    but the Android application framework is almost entirely written in Java or at
    least wrapped inside a thin layer of Java. Do not expect to build your Android
    GUI directly in C/C++! Most APIs are available only from Java. At best, we can
    hide it under the cover... Thus, native C/C++ code on Android would be nonsense
    if it was not possible to tie Java and C/C++ together.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Android与Java密不可分。它的内核和核心库是本地的，但Android应用程序框架几乎完全是用Java编写的，或者至少包裹在一层薄薄的Java中。不要指望直接在C/C++中构建Android
    GUI！大多数API只能从Java中使用。最好的情况下，我们可以将其隐藏起来...因此，如果无法将Java和C/C++绑定在一起，Android上的本地C/C++代码将是无意义的。*'
- en: '>'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*This role is devoted to the Java Native Interface API. JNI is a standardized
    specification allowing Java to call native code and native code to call Java back.
    It is a two-way bridge between the Java and native side; the only way to inject
    the power of C/C++ into your Java application.*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*这个角色专门致力于Java本机接口API。JNI是一个标准化规范，允许Java调用本地代码，本地代码回调Java。它是Java和本地端之间的双向桥梁；是将C/C++的强大功能注入到您的Java应用程序中的唯一途径。*'
- en: '>'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Thanks to JNI, one can call C/C++ functions from Java like any Java method,
    passing Java primitives or objects as parameters and receiving them as result
    of native calls. In turn, native code can access, inspect, modify, and call Java
    objects or raise exceptions with a reflection-like API. JNI is a subtle framework
    which requires care as any misuse can result in a dramatic ending…*'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*借助JNI，可以像调用任何Java方法一样从Java中调用C/C++函数，将Java原语或对象作为参数传递，并将它们作为本地调用的结果接收。反过来，本地代码可以访问、检查、修改和调用Java对象，或者使用类似反射的API引发异常。JNI是一个微妙的框架，需要小心使用，任何误用都可能导致悲剧性的结局...*'
- en: In this chapter, we will implement a basic key/value store to handle various
    data types. A simple Java GUI will allow defining an *entry* composed of a key
    (a character string), a type (an integer, a string, and so on), and a value related
    to the selected type. Entries are retrieved, inserted, or updated (remove will
    not be supported) inside a simple fixed size array of entries, which will reside
    on the native side.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现一个基本的键/值存储，以处理各种数据类型。一个简单的Java GUI将允许定义一个由键（字符字符串）、类型（整数、字符串等）和与所选类型相关的值组成的*条目*。条目将被检索、插入或更新（不支持删除）在一个简单的固定大小的条目数组中，该数组将驻留在本地端。
- en: 'To implement this project, we are going to:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个项目，我们将要做：
- en: Initialize a native JNI library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化本地JNI库
- en: Convert Java Strings in native code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地代码中转换Java字符串
- en: Pass Java primitives to native code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Java原语传递给本地代码
- en: Handle Java object references in native code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地代码中处理Java对象引用
- en: Manage Java Arrays in native code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地代码中管理Java数组
- en: Raise and check Java exceptions in native code.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地代码中引发和检查Java异常。
- en: By the end of this chapter, you should be able perform native calls with any
    Java type and use exceptions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您应该能够使用任何Java类型执行本地调用并使用异常。
- en: JNI is a very technical framework that requires care, as any misuse can result
    in a dramatic ending. This chapter does not pretend to cover it exhaustively but
    rather focuses on the essential knowledge to bridge the gap between Java and C++.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: JNI是一个非常技术性的框架，需要小心使用，任何误用都可能导致悲剧性的结局。本章并不打算详尽地覆盖它，而是专注于桥接Java和C++之间的基本知识。
- en: Initializing a native JNI library
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化本地JNI库
- en: Before accessing their native methods, native libraries must be loaded through
    a Java call to `System.loadLibrary()`. JNI provides a hook, `JNI_OnLoad()`, to
    plug your own initialization code. Let's override it to initialize our native
    store.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问其本地方法之前，本地库必须通过Java调用`System.loadLibrary()`进行加载。JNI提供了一个钩子`JNI_OnLoad()`，用于插入自己的初始化代码。让我们重写它来初始化我们的本地存储。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `Store_Part4`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的项目名称为`Store_Part4`。
- en: Time for action – defining a simple GUI
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-定义一个简单的GUI
- en: 'Let''s create a Java Graphical User Interface for our `Store` and bind it to
    the native store structure that we will create:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的`Store`创建一个Java图形用户界面，并将其绑定到我们将创建的本地存储结构：
- en: 'Rewrite the `res/fragment_layout.xml` layout to define the graphical interface
    as follows. It defines:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`res/fragment_layout.xml`布局，定义如下图形界面。它定义了：
- en: A **Key** `TextView` label and `EditText` to enter the key
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**键**`TextView`标签和`EditText`以输入键
- en: A **Value** `TextView` label and `EditText` to enter the value matching the
    key
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**值**`TextView`标签和`EditText`以输入与键匹配的值
- en: A **Type** `TextView` label and `Spinner` to define the type of the value
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**类型**`TextView`标签和`Spinner`来定义值的类型
- en: A **Get Value** and a **Set Value** `Button` to retrieve and change a value
    in the store
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**获取值**和一个**设置值**`按钮`，用于检索和更改存储中的值
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The end result should look as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应如下所示：
- en: '![Time for action – defining a simple GUI](img/9645_03_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间-定义一个简单的GUI](img/9645_03_02.jpg)'
- en: 'Create a new class in `StoreType.java` with an empty enumeration:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StoreType.java`中创建一个新的空枚举类：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The GUI and native store need to be bound together. This is the role undertaken
    by the `StoreActivity` class. To do this, when `PlaceholderFragment` is created
    in `onCreateView()`, initialize all the GUI components defined earlier in the
    layout file:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GUI和本地存储需要绑定在一起。这是`StoreActivity`类承担的角色。为了做到这一点，在`onCreateView()`中创建`PlaceholderFragment`时，初始化在布局文件中定义的所有GUI组件：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`Spinner` content is bound to the `StoreType` enum. Use `ArrayAdapter` to bind
    together the `Spinner` and `enum` values.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Spinner`内容绑定到`StoreType`枚举。使用`ArrayAdapter`将`Spinner`和`enum`值绑定在一起。'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The **Get Value** and **Set Value** buttons trigger the private methods `onGetValue()`
    and `onSetValue()`, which respectively pull data from and push data to the store.
    Use `OnClickListener` to bind buttons and methods together:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**获取值**和**设置值**按钮触发私有方法`onGetValue()`和`onSetValue()`，分别从存储中提取数据并将数据推送到存储中。使用`OnClickListener`将按钮和方法绑定在一起：'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In `PlaceholderFragment`, define the `onGetValue()`method, which will retrieve
    entries from the store according to `StoreType` selected in the GUI. Leave the
    switch empty as it will not handle any kind of entries for now:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlaceholderFragment`中，定义`onGetValue()`方法，根据GUI中选择的`StoreType`从存储中检索条目。现在将开关留空，因为它现在不会处理任何类型的条目：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, still in `PlaceholderFragment`, define the `onSetValue()`method in `StoreActivity`
    to insert or update entries in the store. If the value format is incorrect, a
    message is displayed:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`PlaceholderFragment`中，定义`StoreActivity`中的`onSetValue()`方法，以在存储中插入或更新条目。如果值的格式不正确，将显示一条消息：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, a little helper method `displayMessage()` in `PlaceholderFragment`
    will help warn the user when a problem occurs. It displays a simple Android Toast
    message:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`PlaceholderFragment`中的一个小助手方法`displayMessage()`将帮助警告用户当出现问题时。它显示一个简单的Android
    Toast消息：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*What just happened?*'
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: We created a basic Graphical User Interface in Java with a few visual components
    from the Android framework. As you can see, there is nothing specific to the NDK
    here. The moral of the story is that native code can be integrated with any existing
    Java code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Java中创建了一个基本的图形用户界面，其中包含了一些来自Android框架的可视组件。正如你所看到的，这里没有任何特定于NDK的内容。故事的寓意是本地代码可以与任何现有的Java代码集成。
- en: Obviously, we still have some work to do to make our native code perform some
    useful things for the Java application. Let's now switch to the native side.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们仍然需要做一些工作，使我们的本地代码为Java应用程序执行一些有用的事情。现在让我们转到本地端。
- en: Time for action – initializing the native store
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 初始化本地存储
- en: 'We need to create and initialize all the structures we will use for the next
    section of the chapter:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建和初始化我们将在本章的下一部分中使用的所有结构：
- en: 'Create the `jni/Store.h` file, which defines store data structures:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`jni/Store.h`文件，定义存储数据结构：
- en: The `StoreType` enumeration will reflect the corresponding Java enumeration.
    Leave it empty for now.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StoreType`枚举将反映相应的Java枚举。现在先留空。'
- en: The `StoreValue` union will contain any of the possible store values. Leave
    it empty for now too.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StoreValue`联合将包含任何可能的存储值。现在也将其留空。'
- en: The `StoreEntry` structure contains one piece of data in the store. It is composed
    of a key (a raw C string made from `char*`), a type (`StoreType`), and a value
    (`StoreValue`).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StoreEntry`结构包含存储中的一个数据。它由一个键（由`char*`制成的原始C字符串）、一个类型（`StoreType`）和一个值（`StoreValue`）组成。'
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we will see how to set up and use C++ STL strings in [Chapter 9](ch09.html
    "Chapter 9. Porting Existing Libraries to Android"), *Porting Existing Libraries
    to Android*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将在[第9章](ch09.html "第9章。将现有库移植到Android")中看到如何设置和使用C++ STL字符串，*将现有库移植到Android*。
- en: '`Store` is the main structure that defines a fixed size array of entries and
    a length (that is, the number of allocated entries):'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Store`是定义了固定大小条目数组和长度（即分配的条目数）的主要结构：'
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Include guards (that is, `#ifndef`, `#define`, and `#endif`), which ensure that
    a header file is included only once during compilation, and can be replaced by
    the non-standard (but widely supported) preprocessor instruction, `#pragma once`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 包含保护（即`#ifndef`、`#define`和`#endif`），确保头文件在编译期间只包含一次，并可以用非标准（但广泛支持）的预处理器指令`#pragma
    once`替换。
- en: 'In `jni/com_packtpub_Store.cpp`, implement the `JNI_OnLoad()` initialization
    hook. Inside, initialize the unique instance of the `Store` data structure store
    into a static variable:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/com_packtpub_Store.cpp`中，实现`JNI_OnLoad()`初始化钩子。在其中，将`Store`数据结构的唯一实例存储到静态变量中：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Update the native `store getCount()` method accordingly to reflect the store
    allocated entry count:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相应地更新本地的`store getCount()`方法，以反映分配的存储条目计数：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*What just happened?*'
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: 'We built the foundation of our store project with a simple GUI and a native
    in-memory data array. The containing native library is loaded with either a call
    to:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用一个简单的GUI和一个本地的内存数据数组构建了我们的存储项目的基础。包含本地库的加载方式是通过以下方式之一：
- en: '`System.load()`, which takes the library full path in parameter.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.load()`，它以参数形式接受库的完整路径。'
- en: '`System.loadLibrary()`, which requires only the library name without the path,
    prefix (that is, `lib`), or extension.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.loadLibrary()`，它只需要库的名称，不需要路径、前缀（即`lib`）或扩展名。'
- en: The native code initialization occurs in the `JNI_OnLoad()` hook, which is called
    only once during the lifetime of the native code. It is a perfect place to initialize
    and cache global variables. JNI elements (classes, methods, fields, and so on)
    are also often cached in `JNI_OnLoad()` to improve the performance. We will see
    more about this throughout this chapter and the next one.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 本地代码初始化发生在`JNI_OnLoad()`钩子中，它在本地代码的生命周期中只调用一次。这是一个完美的地方来初始化和缓存全局变量。JNI元素（类、方法、字段等）也经常在`JNI_OnLoad()`中缓存，以提高性能。我们将在本章和下一章中更多地了解这一点。
- en: Please note that the pendent call `JNI_OnUnload()` defined in the JNI specification
    is almost useless in Android since there is no way to guarantee that a library
    is unloaded before process termination.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由JNI规范定义的悬空调用`JNI_OnUnload()`在Android中几乎没有用处，因为无法保证在进程终止之前卸载库。
- en: 'The `JNI_OnLoad()` signature is systematically defined as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`JNI_OnLoad()`的签名被系统地定义如下：'
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'What makes `JNI_OnLoad()` so useful is its `JavaVM` parameter. From it, you
    can retrieve the **JNIEnv interface pointer** as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`JNI_OnLoad()`如此有用的原因在于它的`JavaVM`参数。通过它，您可以按如下方式检索**JNIEnv接口指针**：'
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `JNI_OnLoad()` definition in a JNI library is optional. However, if omitted,
    you may notice that a warning **No JNI_OnLoad found in <mylib>.so** is displayed
    in the **Logcat** when you start your application. This has absolutely no consequence
    and can be safely ignored.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: JNI库中的`JNI_OnLoad()`定义是可选的。但是，如果省略了，当您启动应用程序时，您可能会注意到在**Logcat**中显示警告**No JNI_OnLoad
    found in <mylib>.so**。这绝对没有任何影响，可以安全地忽略。
- en: '`JNIEnv` is the main entry point for all JNI calls, which explains why it is
    passed to all native methods. It provides a set of methods to access Java primitives
    and arrays from native code. It is complemented with a reflection-like API to
    give full access to Java objects from native code. We are going to discover its
    features in more detail throughout this chapter and the next one.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`JNIEnv`是所有JNI调用的主要入口点，这就解释了为什么它被传递给所有本地方法。它提供了一组方法，用于从本地代码访问Java基本类型和数组。它还配备了一个类似反射的API，以便从本地代码完全访问Java对象。我们将在本章和下一章中更详细地了解其功能。'
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `JNIEnv` interface pointer is thread-specific. You must not share it between
    threads! Use it only on the thread it was retrieved from. Only a JavaVM element
    is thread-safe and can be shared among threads.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`JNIEnv`接口指针是特定于线程的。您不应该在线程之间共享它！只能在检索到它的线程上使用它。只有JavaVM元素是线程安全的，可以在线程之间共享。'
- en: Converting Java strings in native code
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地代码中转换Java字符串
- en: The first kind of entry we will handle is strings. Strings, which are represented
    as (almost) classic objects in Java, can be manipulated on the native side and
    translated to native strings, that is, raw character arrays, thanks to JNI. Strings
    are a first-class citizen despite their complexity inherent to their heterogeneous
    representations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理的第一种条目是字符串。字符串在Java中被表示为（几乎）经典对象，可以在本地端进行操作，并通过JNI转换为本地字符串，即原始字符数组。尽管字符串的复杂性与其异构表示有关，但它们仍然是一流的公民。
- en: In this part, we will send Java strings to the native side and translate them
    to their native counterpart. We will also convert them back to a Java string.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，我们将向本地端发送Java字符串，并将其转换为其本地对应项。我们还将把它们转换回Java字符串。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `Store_Part5`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目将在本书中提供，名称为`Store_Part5`。
- en: Time for action – handling strings in the native store
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理本地存储中的字符串
- en: 'Let''s handle String values in our store:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的存储中处理String值：
- en: 'Open `StoreType.java` and specify the new String type our store handles in
    the enumeration:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`StoreType.java`并在枚举中指定我们的存储处理的新String类型：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In `StoreActivity.java`, retrieve string entries from the native `Store` in
    the `onGetValue()` method. Do it according to the type `StoreType` currently selected
    in the GUI (even if there is only one possible type for now):'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StoreActivity.java`中，在`onGetValue()`方法中从本地`Store`中检索字符串条目。根据GUI中当前选择的`StoreType`类型进行操作（即使现在只有一种可能的类型）：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Insert or update string entries in the store in the `onSetValue()` method:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onSetValue()`方法中插入或更新存储中的字符串条目：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In `jni/Store.h`, include a new `header jni.h` to access the JNI API.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/Store.h`中，包含一个新的`header jni.h`以访问JNI API。
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, integrate strings into the native `StoreType` enumeration and the `StoreValue`
    union:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将字符串整合到本地`StoreType`枚举和`StoreValue`联合中：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Terminate by declaring utility methods to check, create, find, and destroy
    entries. `JNIEnv` and `jstring` are JNI types defined in the `jni.h` header:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后声明实用方法来检查、创建、查找和销毁条目。`JNIEnv`和`jstring`是在`jni.h`头文件中定义的JNI类型：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a new file `jni/Store.cpp` to implement all these utility methods.First,
    `isEntryValid()` simply checks whether an entry is allocated and has the expected
    type:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件`jni/Store.cpp`来实现所有这些实用方法。首先，`isEntryValid()`简单地检查条目是否已分配并且具有预期的类型：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `findEntry()` method compares the key passed as a parameter with every key
    in the store until a match is found. Instead of working with classic native strings
    (that is, a `char*`), it receives a `jstring` parameter, which is the direct representation
    of a Java `String` on the native side.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`findEntry()`方法将传递的键与存储中的每个键进行比较，直到找到匹配项。它不使用经典的本地字符串（即`char*`），而是接收一个`jstring`参数，这是Java`String`在本地端的直接表示。'
- en: 'To recover a native string from a Java `String`, use `GetStringUTFChars()`
    from the JNI API to get a temporary character buffer containing the converted
    Java string. Its content can then be manipulated using standard C routines. `GetStringUTFChars()`
    must be systematically coupled with a call to `ReleaseStringUTFChars()` to release
    the temporary buffer allocated in `GetStringUTFChars()`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从Java`String`中恢复本地字符串，使用JNI API中的`GetStringUTFChars()`来获取一个临时字符缓冲区，其中包含转换后的Java字符串。然后可以使用标准C例程来操作其内容。`GetStringUTFChars()`必须始终与`ReleaseStringUTFChars()`一起使用，以释放在`GetStringUTFChars()`中分配的临时缓冲区：
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Java strings are stored in memory as UTF-16 strings. When their content is extracted
    in native code, the returned buffer is encoded in Modified UTF-8\. Modified UTF-8
    is compatible with standard C String functions, which usually works on string
    buffers composed of 8 bits per characters.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Java字符串以UTF-16字符串的形式存储在内存中。当它们的内容在本地代码中提取时，返回的缓冲区以Modified UTF-8编码。Modified
    UTF-8与标准C字符串函数兼容，通常用于由每个字符组成的8位字符串缓冲区。
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: JNI does not forgive any mistakes. If, for example, you pass `NULL` as the first
    parameter in `GetStringUTFChars()`, VM will abort immediately. In addition, Android
    JNI does not respect JNI specification perfectly. Although the JNI Specification
    indicates that `GetStringUTFChars()` might return `NULL` if the memory could not
    be allocated, Android VMs will simply abort in such cases.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: JNI不会原谅任何错误。例如，如果您在`GetStringUTFChars()`的第一个参数中传递`NULL`，VM将立即中止。此外，Android JNI并不完全遵守JNI规范。尽管JNI规范指出`GetStringUTFChars()`可能在内存无法分配时返回`NULL`，但在这种情况下，Android
    VM将简单地中止。
- en: Implement `allocateEntry()`, which either creates a new entry (that is, increments
    the store length and returns the last element) or returns an existing one if the
    key already exists (after releasing its previous value).
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`allocateEntry()`，它要么创建一个新条目（即增加存储长度并返回最后一个元素），要么如果键已经存在则返回现有条目（释放其先前的值后）。
- en: 'If the entry is a new one, convert its key to a native string that can be kept
    in the memory. Indeed, raw JNI objects live for the duration of a native method
    call and must not be kept outside its scope:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条目是新的，将其键转换为可以保存在内存中的本地字符串。事实上，原始的JNI对象只在本地方法调用的持续时间内存在，并且不能在其范围之外保留：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Write the last method `releaseEntryValue()`, which frees the memory allocated
    for a value if needed:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写最后一个方法`releaseEntryValue()`，如果需要，释放为值分配的内存：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Refresh the JNI header file `jni/com_packtpub_Store.h` with `javah` as seen
    in the previous chapter. You should see two new methods `Java_com_packtpub_store_Store_getString()`
    and `Java_com_packtpub_store_Store_setString()` in it.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`javah`刷新JNI头文件`jni/com_packtpub_Store.h`，如前一章所示。您应该在其中看到两个新方法`Java_com_packtpub_store_Store_getString()`和`Java_com_packtpub_store_Store_setString()`。
- en: 'In `jni/com_packtpub_Store.cpp`, insert the `cstdlib` header file:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/com_packtpub_Store.cpp`中，插入`cstdlib`头文件：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With the help of the previously generated JNI header, implement the native method
    `getString()`. This method looks for the key passed to the store and returns its
    corresponding string value. If any problem occurs, a default `NULL` value is returned.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 借助先前生成的JNI头文件，实现本地方法`getString()`。此方法查找传递给存储的键，并返回其对应的字符串值。如果出现任何问题，则返回默认的`NULL`值。
- en: 'Java strings are not real primitives. Types `jstring` and `char*` cannot be
    used interchangeably as we already saw. To create a Java `String` object from
    a native string, use `NewStringUTF()` from the JNI API:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java字符串不是真正的原语。正如我们已经看到的，类型`jstring`和`char*`不能互换使用。要从本地字符串创建Java `String`对象，请使用JNI
    API中的`NewStringUTF()`：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then, implement the `setString()` method, which allocates an entry (that is,
    creates a new entry in the store or reuses an existing one if it has the same
    key) and stores the converted Java string value in it.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，实现`setString()`方法，该方法分配一个条目（即在存储中创建一个新条目，如果具有相同的键则重用现有条目），并将转换后的Java字符串值存储在其中。
- en: 'The string value is translated from a Java string directly to our own string
    buffer using the `GetStringUTFLength()` and `GetStringUTFRegion()` methods from
    the JNI API. This is an alternative to `GetStringUTFChars()` used earlier. Finally,
    we must not forget to append the `null` character, which is the standard for a
    raw C string:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JNI API中的`GetStringUTFLength()`和`GetStringUTFRegion()`方法，将字符串值直接从Java字符串转换为我们自己的字符串缓冲区。这是`GetStringUTFChars()`的替代方法。最后，我们不要忘记附加`null`字符，这是原始C字符串的标准：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, update the `Android.mk` file to compile `Store.cpp`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新`Android.mk`文件以编译`Store.cpp`：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*What just happened?*'
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: Run the application. Try to save a few entries with different keys and values.
    Then try to get them back from the native store. We managed to pass and retrieve
    strings from Java to C/C++. These values are saved in a native memory as native
    strings. Entries can then be retrieved as Java strings from the store according
    to their key.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序。尝试使用不同的键和值保存几个条目。然后尝试从本地存储中获取它们。我们成功地从Java传递并检索了字符串到C/C++。这些值保存在本地内存中作为本地字符串。然后可以根据它们的键从存储中检索为Java字符串。
- en: Java and C strings are completely different beasts. Java strings need a concrete
    conversion to native strings to allow processing of their content using standard
    C string routines. Indeed, `jstring` is not a representation of a classic `char*`
    array but of a reference to a Java `String` object, accessible from the Java code
    only.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Java和C字符串完全不同。Java字符串需要将其内容转换为本地字符串，以便使用标准的C字符串例程进行处理。实际上，`jstring`不是经典的`char*`数组的表示，而是对Java
    `String`对象的引用，仅从Java代码中访问。
- en: 'We discovered two ways to convert Java strings to native strings in this part:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，我们发现了将Java字符串转换为本地字符串的两种方法：
- en: By pre-allocating a memory buffer in which the converted Java string is copied.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过预先分配内存缓冲区，将转换后的Java字符串复制到其中。
- en: By retrieving a converted Java string in a memory buffer managed by JNI.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在JNI管理的内存缓冲区中检索转换后的Java字符串。
- en: Choosing either solution depends on how memory is handled by the client code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 选择哪种解决方案取决于客户端代码如何处理内存。
- en: Native character encoding
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地字符编码
- en: 'JNI provides two kinds of methods to deal with strings:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: JNI提供了两种处理字符串的方法：
- en: The ones with UTF in their name that work with Modified UTF-8 strings
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有UTF的名称的方法，用于处理Modified UTF-8字符串
- en: The ones without UTF in their name that work with UTF-16 encoding
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不带UTF名称的方法，用于处理UTF-16编码
- en: 'Modified UTF-8 and UTF-16 strings are two different character encodings:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Modified UTF-8和UTF-16字符串是两种不同的字符编码：
- en: '**Modified UTF-8** is a slightly different flavor of UTF-8 specific to Java.
    This encoding can represent standard ASCII characters (each on one byte) or can
    grow up to 4 bytes to represent extended characters (Ararbic, Cyrilic, Greek,
    Hebrew, and so on). The difference between standard UTF-8 and Modified UTF-8 resides
    in the different representation of the `null` character, which simply does not
    exist in the latter encoding. In this way, such strings can be processed with
    a standard C routine for which the `null` character is used as an ending sentinel.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Modified UTF-8**是特定于Java的略有不同的UTF-8变体。该编码可以表示标准ASCII字符（每个字符占用一个字节），也可以增长到4个字节以表示扩展字符（阿拉伯语、西里尔语、希腊语、希伯来语等）。标准UTF-8和Modified
    UTF-8之间的区别在于对`null`字符的不同表示，后者中根本不存在该字符。因此，这样的字符串可以使用标准C例程进行处理，其中`null`字符用作结束标记。'
- en: '**UTF-16** is the real encoding employed for Java strings. Each character is
    represented with two bytes, hence the Java `char` size. As a consequence, it is
    more efficient to work with UTF-16 in native code rather than Modified UTF-8 since
    they do not require conversion. The drawback is that classic C string routines
    will not work with them since they are not `null` terminated.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UTF-16**是Java字符串实际使用的编码。每个字符用两个字节表示，因此是Java `char`大小。因此，在本地代码中使用UTF-16比Modified
    UTF-8更有效，因为它们不需要转换。缺点是经典的C字符串例程将无法使用它们，因为它们没有`null`终止符。'
- en: Character encoding is a complex subject for which you can find more information
    at [http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html](http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html)
    and in the Android documentation at [http://developer.android.com/training/articles/perf-jni.html#UTF_8_and_UTF_16_strings](http://developer.android.com/training/articles/perf-jni.html#UTF_8_and_UTF_16_strings).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 字符编码是一个复杂的主题，您可以在[http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html](http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html)和Android文档中找到更多信息[http://developer.android.com/training/articles/perf-jni.html#UTF_8_and_UTF_16_strings](http://developer.android.com/training/articles/perf-jni.html#UTF_8_and_UTF_16_strings)。
- en: JNI String API
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JNI字符串API
- en: 'JNI provides several methods to handle a Java string on the native side:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: JNI提供了几种方法来处理本地端的Java字符串：
- en: '`GetStringUTFLength()` computes the Modified UTF-8 string length in *byte*
    (indeed UTF-8 strings have varying character sizes), whereas `GetStringLength()`
    computes UTF-16 string *number of characters* (not bytes, since UTF-16 characters
    are of a fixed size):'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetStringUTFLength()`计算*字节*中的修改后的UTF-8字符串长度（实际上UTF-8字符串具有不同的字符大小），而`GetStringLength()`计算UTF-16字符串的*字符数*（而不是字节，因为UTF-16字符的大小是固定的）：'
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`GetStringUTFChars()` and `GetStringChars()` allocate a new memory buffer managed
    by JNI to store the result of Java to native (respectively Modified UTF-8 and
    UTF-16) string conversion. Use it when you want to convert an entire string without
    bothering with memory allocation. The last parameter `isCopy`, when not `null`,
    indicates whether the string has been internally copied by JNI or whether the
    returned buffer points to the real Java string memory. In Android, the returned
    `isCopy` value is generally `JNI_TRUE` for `GetStringUTFChars()` and `JNI_FALSE`
    for `GetStringChars()` (indeed the latter does not require encoding conversion):'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetStringUTFChars()`和`GetStringChars()`分配一个由JNI管理的新内存缓冲区，用于存储Java到本地（分别是修改后的UTF-8和UTF-16）字符串的转换结果。当您想要转换整个字符串而不必担心内存分配时，请使用它。最后一个参数`isCopy`，当不为`null`时，指示字符串是否已被JNI内部复制，或者返回的缓冲区指向真正的Java字符串内存。在Android中，`isCopy`的返回值通常为`JNI_TRUE`，对于`GetStringUTFChars()`和`JNI_FALSE`对于`GetStringChars()`（实际上后者不需要编码转换）：'
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Although JNI specification indicates that `GetStringUTFChars()` can return NULL
    (which means that the operation has failed because, for example, memory could
    not be allocated), in practice, this check is useless because the Dalvik or ART
    VMs generally abort in this case. So simply avoid getting into that situation!
    You should still keep NULL-checks if your code aims at being portable to other
    Java Virtual Machines.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JNI规范指出`GetStringUTFChars()`可以返回NULL（这意味着操作失败，例如，无法分配内存），但实际上，这个检查是无用的，因为Dalvik或ART虚拟机通常会在这种情况下中止。因此，简单地避免陷入这种情况！如果您的代码旨在可移植到其他Java虚拟机，仍应保留NULL检查。
- en: '`ReleaseStringUTFChars()` and `ReleaseStringChars()` free the memory buffer
    allocated by `GetStringUTFChars()` and `GetStringChars()` when the client has
    finished processing it. These methods must always be called in pairs:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReleaseStringUTFChars()`和`ReleaseStringChars()`在客户端处理完毕后释放`GetStringUTFChars()`和`GetStringChars()`分配的内存缓冲区。这些方法必须成对调用：'
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`GetStringUTFRegion()` and `GetStringRegion()` retrieve all or only a region
    of the Java string. It works on a string buffer provided and managed by the client
    code. Use it when you want to manage memory allocation (for example, to reuse
    an existing memory buffer) or need to access small sections of a string:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetStringUTFRegion()`和`GetStringRegion()`检索Java字符串的全部或部分区域。它在客户端代码提供和管理的字符串缓冲区上工作。当您想要管理内存分配（例如，重用现有的内存缓冲区）或需要访问字符串的小部分时，请使用它：'
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`GetStringCritical()` and `ReleaseStringCritical()` are similar to `GetStringChars()`
    and `ReleaseStringChars()` but are only available for UTF-16 strings. According
    to the JNI specification, `GetStringCritical()` is more likely to return a direct
    pointer without making any copy. In exchange, the caller must not perform blocking
    or JNI calls and should not hold the string for a long time (like a critical section
    with threads). In practice, Android seems to behave similarly whether you use
    critical functions or not (but this may change):'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetStringCritical()`和`ReleaseStringCritical()`类似于`GetStringChars()`和`ReleaseStringChars()`，但仅适用于UTF-16字符串。根据JNI规范，`GetStringCritical()`更有可能返回一个直接指针而不进行任何复制。作为交换，调用者不得执行阻塞或JNI调用，并且不应长时间持有字符串（例如，使用线程的关键部分）。实际上，Android似乎无论您是否使用关键函数都会表现出类似的行为（但这可能会改变）：'
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is the essential knowledge you need to know to deal with Java strings through
    JNI.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您需要了解的处理Java字符串的JNI的基本知识。
- en: Passing Java primitives to native code
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Java原始类型传递给本地代码
- en: The simplest kinds of elements we can handle with JNI are Java primitive types.
    Indeed, both the Java and native side use practically the same representation
    for this kind of data which, does not require any specific memory management.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用JNI处理的最简单的元素是Java原始类型。实际上，Java和本地代码两侧对于这种数据几乎使用相同的表示，不需要任何特定的内存管理。
- en: In this part, we will see how to pass integers to the native side and send them
    back to the Java side.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看到如何将整数传递到本地代码并将它们发送回Java端。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `Store_Part6`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目在本书中以`Store_Part6`的名称提供。
- en: Time for action – handling primitives in the native store
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地存储中处理原始类型的时间
- en: 'In `StoreType.java`, add the newly managed integer type to the enumeration:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StoreType.java`中，将新管理的整数类型添加到枚举中：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Open `Store.java` and define the new integer functionalities our native store
    provides:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Store.java`并定义本地存储提供的新整数功能：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `StoreActivity` class, update the `onGetValue()` method to retrieve
    integer entries from the store when they are selected in the GUI:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StoreActivity`类中，更新`onGetValue()`方法，以在GUI中选择整数条目时从存储中检索它们：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Also, insert or update integer entries in the store in the `onSetValue()` method.
    The entry data needs to be parsed before being passed to the native side:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在`onSetValue()`方法中插入或更新存储中的整数条目。在传递到本地端之前，需要解析条目数据：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In `jni/Store.h`, append the integer type in the native `StoreType` enumeration
    and the `StoreValue` union:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/Store.h`中，将整数类型附加到本地`StoreType`枚举和`StoreValue`联合体中：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Refresh the JNI header file `jni/com_packtpub_Store.h` with `javah`. Two new
    methods `Java_com_packtpub_store_Store_getInteger()` and `Java_com_packtpub_store_Store_getInteger()`
    should appear.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`javah`刷新JNI头文件`jni/com_packtpub_Store.h`。应该出现两个新方法`Java_com_packtpub_store_Store_getInteger()`和`Java_com_packtpub_store_Store_getInteger()`。
- en: 'In `jni/com_packtpub_Store.cpp`, implement `getInteger()` with the help of
    the generated JNI header. This method simply returns the integer value of an entry
    without doing any specific conversion other than an implicit cast from `int32_t`
    to `jint`. If any problem occurs, during retrieval, a default value is returned:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/com_packtpub_Store.cpp`中，使用生成的JNI头文件实现`getInteger()`。这个方法只是返回条目的整数值，而不进行任何特定的转换，只是从`int32_t`到`jint`的隐式转换。如果在检索过程中出现任何问题，将返回默认值：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The second method `setInteger()` stores the given integer value in the allocated
    entry. Note how here too that the passed JNI integer can be reversely cast to
    a C/C++ integer:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个方法`setInteger()`将给定的整数值存储在分配的条目中。请注意，这里传递的JNI整数也可以被反向转换为C/C++整数：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*What just happened?*'
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: Run the application. Try to save a few entries with different keys, types, and
    values. Then try to get them back from the native store. We have this time managed
    to pass and retrieve integer primitives from Java to C/C++.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序。尝试使用不同的键、类型和值保存几个条目。然后尝试从本地存储中获取它们。这一次我们成功地从Java传递和检索了整数原语到C/C++。
- en: Integer primitives wear several dresses during native calls; first, `int` in
    Java code, then `jint` during transfer from/to Java code, and finally, `int` or
    `int32_t` in native code. Obviously, we could have kept the JNI representation
    `jint` in native code if we wanted to, since all of these types are simply equivalent.
    In other words, `jint` is simply an alias.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 整数原语在本地调用期间穿着几种服装；首先，在Java代码中是`int`，然后在从/到Java代码的传输过程中是`jint`，最后，在本地代码中是`int`或`int32_t`。显然，如果愿意的话，我们可以在本地代码中保留JNI表示`jint`，因为所有这些类型都是等价的。换句话说，`jint`只是一个别名。
- en: Tip
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `int32_t` type is `typedef` introduced by the C99 standard library with
    the aim at more portability. The difference with the standard `int` type is that
    its size-in-bytes is fixed for all compilers and platforms. More numeric types
    are defined in `stdint.h` (in C) or `cstdint` (in C++).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`int32_t`类型是C99标准库引入的`typedef`，旨在提高可移植性。与标准的`int`类型的区别在于，它的字节大小对于所有编译器和平台都是固定的。更多的数字类型在`stdint.h`（在C中）或`cstdint`（在C++中）中定义。'
- en: 'All primitive types have their proper alias in JNI:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 所有原始类型在JNI中都有自己的别名：
- en: '| Java type | JNI type | C type | Stdint C type |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| Java类型 | JNI类型 | C类型 | Stdint C类型 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `boolean` | `Jboolean` | `unsigned char` | `uint8_t` |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | `Jboolean` | `unsigned char` | `uint8_t` |'
- en: '| `byte` | `Jbyte` | `signed char` | `int8_t` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '`byte` | `Jbyte` | `signed char` | `int8_t` |'
- en: '| `char` | `Jchar` | `unsigned short` | `uint16_t` |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `char` | `Jchar` | `unsigned short` | `uint16_t` |'
- en: '| `double` | `Jdouble` | `double` | `N/A` |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `Jdouble` | `double` | `N/A` |'
- en: '| `float` | `jfloat` | `float` | `N/A` |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `jfloat` | `float` | `N/A` |'
- en: '| `int` | `jint` | `Int` | `int32_t` |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `jint` | `Int` | `int32_t` |'
- en: '| `long` | `jlong` | `long long` | `int64_t` |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `jlong` | `long long` | `int64_t` |'
- en: '| `short` | `jshort` | `Short` | `int16_t` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `short` | `jshort` | `Short` | `int16_t` |'
- en: You can use them exactly the same way we used integers in this part. More information
    about primitive types in JNI can be found at [http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/types.html](http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/types.html)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像在本部分中使用整数一样使用它们。有关JNI中原始类型的更多信息，请访问[http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/types.html](http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/types.html)
- en: Have a go hero – passing and returning other primitive types
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试通过传递和返回其他原始类型
- en: 'The current store deals only with integers and strings. Based on this model,
    try to implement store methods for other primitive types: `boolean`, `byte`, `char`,
    `double`, `float`, `long`, and `short`.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的存储只处理整数和字符串。基于这个模型，尝试为其他原始类型实现存储方法：`boolean`，`byte`，`char`，`double`，`float`，`long`和`short`。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `Store_Part6_Full`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目在本书中以`Store_Part6_Full`的名称提供。
- en: Referencing Java objects from native code
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从本地代码引用Java对象
- en: We know from the previous section that a string is represented in JNI as `jstring`,
    which is in fact a Java object, which means that it is possible to exchange any
    Java object through JNI! However, because native code cannot understand or access
    Java directly, all Java objects have the same representation, `jobject`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从前一节知道，字符串在JNI中表示为`jstring`，实际上是一个Java对象，这意味着可以通过JNI交换任何Java对象！然而，由于本地代码无法直接理解或访问Java，所有Java对象都具有相同的表示形式`jobject`。
- en: In this part, we will focus on how to save an object on the native side and
    how to send it back to Java. As an example, we will work with a custom object
    `Color`, although any other type of object would work too.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，我们将重点介绍如何在本地端保存对象以及如何将其发送回Java。例如，我们将使用自定义对象`Color`，尽管任何其他类型的对象也可以工作。
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `Store_Part7`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目在本书中以`Store_Part7`的名称提供。
- en: Time for action – saving references to Objects in native Store
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-在本地存储中保存对象的引用
- en: 'Create a new Java class `com.packtpub.store.Color` encapsulating an integer
    representation of a color. This integer is parsed from `String` containing HTML
    code (for example, `#FF0000`) thanks to the `android.graphics.Color` class:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Java类`com.packtpub.store.Color`，封装颜色的整数表示。这个整数是从包含HTML代码的`String`中解析出来的（例如，`#FF0000`），这要归功于`android.graphics.Color`类：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In `StoreType.java`, append the new Color data type to the enumeration:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StoreType.java`中，将新的Color数据类型附加到枚举中：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the `Store` class, append two new native methods to retrieve and save a
    `Color` object:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Store`类中，附加两个新的本地方法来检索和保存`Color`对象：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Open `StoreActivity.java` and update methods `onGetValue()` and `onSetValue()`
    to parse and display `Color` instances:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`StoreActivity.java`并更新`onGetValue()`和`onSetValue()`方法以解析和显示`Color`实例：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In `jni/Store.h`, append the new color type to the `StoreType` enumeration
    and add a new member to the `StoreValue` union. But what type should you use,
    `Color` is an object known only from Java? In JNI, all java objects have the same
    type; `jobject`, an (indirect) object reference:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/Store.h`中，将新的颜色类型附加到`StoreType`枚举中，并向`StoreValue`联合体添加一个新成员。但是，您应该使用什么类型，`Color`只是从Java中知道的对象？在JNI中，所有Java对象都具有相同的类型；`jobject`，一个（间接）对象引用：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Regenerate the JNI header file `jni/com_packtpub_Store.h` with `javah`. You
    should see two new methods `Java_com_packtpub_store_Store_getColor()` and `Java_com_packtpub_store_Store_setColor()`
    in it.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`javah`重新生成JNI头文件`jni/com_packtpub_Store.h`。您应该在其中看到两个新方法`Java_com_packtpub_store_Store_getColor()`和`Java_com_packtpub_store_Store_setColor()`。
- en: 'Open `jni/com_packtpub_Store.cpp` and implement the two freshly generated methods
    `getColor()` and `setColor()`. The first one simply returns the Java Color object
    kept in the store entry as shown in the following code:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`jni/com_packtpub_Store.cpp`并实现两个新生成的方法`getColor()`和`setColor()`。第一个方法简单地返回存储条目中保存的Java
    Color对象，如下面的代码所示：
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The real subtleties are introduced in the second method `setColor()`. Indeed,
    at first sight, simply saving the `jobject` value in the store entry would seem
    sufficient. However, this assumption is wrong. Objects passed in parameters or
    created inside a JNI method are Local references. Local references cannot be kept
    in native code outside of the native method scope (such as for strings).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的微妙之处出现在第二个方法`setColor()`中。事实上，乍一看，只是将`jobject`值保存在存储条目中似乎足够了。然而，这个假设是错误的。在JNI方法中传递的对象或在其中创建的对象都是本地引用。本地引用不能在本地代码中保留在本地方法范围之外（例如字符串）。
- en: 'To be allowed to keep a Java object reference in native code after native method
    returns, they must be turned into Global references in order to inform the Dalvik
    VM that they must not be garbage collected. To do so, the JNI API provides the
    `NewGlobalRef()` method:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地方法返回后允许保留Java对象引用，它们必须转换为全局引用，以便通知Dalvik VM它们不能被垃圾回收。为此，JNI API提供了`NewGlobalRef()`方法：
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In `Store.cpp`, modify `releaseEntryValue()` to delete the global reference
    when the entry is replaced by a new one. This is done with the `DeleteGlobalRef()`
    method, which is the counterpart of `NewGlobalRef()`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Store.cpp`中，修改`releaseEntryValue()`以在条目被新条目替换时删除全局引用。这是通过`DeleteGlobalRef()`方法完成的，它是`NewGlobalRef()`的对应物：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*What just happened?*'
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: Run the application. Enter and save a color value such as **#FF0000** or **red**,
    which is a predefined value allowed by the Android color parser. Get the entry
    back from the store. We managed to reference a Java object on the native side!
    Java objects are not and cannot be converted to C++ objects. Both are inherently
    different. Thus, to keep Java objects on the native side, we must keep references
    to them using the JNI API.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序。输入并保存颜色值，例如**#FF0000**或**红色**，这是Android颜色解析器允许的预定义值。从存储中获取条目。我们成功在本地端引用了一个Java对象！Java对象不是也不能转换为C++对象。两者本质上是不同的。因此，要在本地端保留Java对象，我们必须使用JNI
    API保留对它们的引用。
- en: All objects coming from Java are represented by `jobject`, even `jstring` (which
    is in fact a `typedef` over `jobject` internally). A `jobject` is just a dumb
    "pointer" without any smart garbage collection mechanism (after all, we want to
    get rid of Java, at least partially). It does not give you a direct reference
    to the Java object memory but rather an indirect one. Indeed, Java objects do
    not have a fixed location in memory on the opposite to C++ objects. They may be
    moved during their lifetime. Regardless, it would be a bad idea to mess with a
    Java object representation in the memory.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 所有来自Java的对象都由`jobject`表示，甚至`jstring`（实际上在内部是`jobject`的`typedef`）。`jobject`只是一个没有任何智能垃圾收集机制的“指针”（毕竟，我们至少部分地想要摆脱Java）。它不会直接给您Java对象内存的引用，而是间接的。事实上，与C++对象相反，Java对象在内存中没有固定的位置。它们在其生命周期中可能会移动。无论如何，在内存中操纵Java对象表示都是一个坏主意。
- en: Local references
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地引用
- en: Native calls have a scope limited to a method, which means that as soon as a
    native method ends, the VM becomes in charge again. The JNI specification uses
    this fact to its advantage in order to keep object references local to method
    boundaries. This means that `jobject` can only be used safely inside the method
    it was given to. Once native method returns, the Dalvik VM has no way to know
    if native code still holds object references and can decide to collect them at
    any time.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 本地调用的范围仅限于方法，这意味着一旦本地方法结束，VM再次负责。JNI规范利用这一事实，以便将对象引用局限于方法边界。这意味着`jobject`只能在赋予它的方法内部安全使用。一旦本地方法返回，Dalvik
    VM就无法知道本地代码是否仍然持有对象引用，并且可以随时决定收集它们。
- en: 'These kinds of references are called **Local** references. They are automatically
    freed (the reference, not the object although the garbage collector might too)
    when native method returns to allow proper garbage collection later in the Java
    code. For example, the following piece of code should be strictly prohibited.
    Keeping such a reference outside the JNI method will eventually lead to an undefined
    behavior (a memory corruption, a crash, and so on):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这种引用被称为**本地**引用。它们在本地方法返回后会自动释放（引用，而不是对象，尽管垃圾收集器也可能会释放对象），以便稍后在Java代码中进行适当的垃圾回收。例如，以下代码片段应严格禁止。在JNI方法之外保留这样的引用最终会导致未定义的行为（内存损坏、崩溃等）：
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Tip
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Objects are passed to native methods as Local references. Every `jobject` returned
    by JNI functions (except `NewGlobalRef()`) is a Local reference. Just remember
    that everything is a Local reference by default.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对象作为本地引用传递给本地方法。JNI 函数返回的每个 `jobject`（除了 `NewGlobalRef()`）都是本地引用。只需记住，默认情况下一切都是本地引用。
- en: 'JNI provides several methods for managing Local references:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: JNI 提供了几种管理本地引用的方法：
- en: '`NewLocalRef()` to create one explicitly (from a Global references, for example),
    although this is rarely needed in practice:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NewLocalRef()` 明确创建一个本地引用（例如从全局引用），尽管在实践中很少需要：'
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`DeleteLocalRef()` to delete one when it is no longer needed:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DeleteLocalRef()` 在不再需要时删除一个本地引用：'
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Tip
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Local references cannot be used outside the method scope and cannot be shared
    between threads, even during a single native call!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本地引用不能在方法范围之外使用，也不能在单个本机调用期间在线程之间共享！
- en: You are not required to delete Local references explicitly. However, according
    to the JNI specification, a JVM is only required to store 16 Local references
    at the same time and may refuse to create more (this is implementation-specific).
    It is thus good practice to release unused Local references as soon as possible,
    especially when working with arrays.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要显式删除本地引用。但是，根据 JNI 规范，JVM 一次只需要存储 16 个本地引用，并且可能拒绝创建更多（这是特定于实现的）。因此，尽快释放未使用的本地引用是一个良好的实践，特别是在处理数组时。
- en: Hopefully, JNI provides a few more methods to help working with Local references.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 希望 JNI 提供了一些方法来帮助处理本地引用。
- en: '`EnsureLocalCapacity()` informs the VM that it needs more Local references.
    This method return `-1` and throws a Java `OutOfMemoryError` when it cannot guarantee
    the requested capacity:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EnsureLocalCapacity()` 通知虚拟机需要更多本地引用。当无法保证所请求的容量时，此方法返回 `-1` 并抛出 Java `OutOfMemoryError`：'
- en: '[PRE50]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`PushLocalFrame()` and `PopLocalFrame()` offer a second way to allocate more
    Local references. It can be understood as a way to batch Local slot allocation
    and Local references deletion. This method also returns `-1` and throws a Java
    `OutOfMemoryError` when it cannot guarantee the requested capacity:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PushLocalFrame()` 和 `PopLocalFrame()` 提供了第二种分配更多本地引用的方法。可以将其理解为一种批量本地槽分配和本地引用删除的方法。当无法保证所请求的容量时，此方法也返回
    `-1` 并抛出 Java `OutOfMemoryError`：'
- en: '[PRE51]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Tip
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Until Android 4.0 Ice Cream Sandwich, Local references were actually direct
    pointers, which means they could be kept beyond their natural scope and still
    be working. This is not the case anymore and such buggy code must be avoided.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 Android 4.0 冰淇淋三明治，本地引用实际上是直接指针，这意味着它们可以超出其自然范围并仍然有效。现在不再是这种情况，必须避免这种错误的代码。
- en: Global references
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局引用
- en: To be able to use an object reference outside the method scope or keep it for
    a long period of time, references must be made **Global**. Global references also
    allow sharing objects between threads, which is not the case with Local references.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在方法范围之外使用对象引用或长时间保留它，引用必须是**全局**的。全局引用还允许在线程之间共享对象，这在本地引用中不适用。
- en: 'JNI provides two methods for this purpose:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: JNI 为此提供了两种方法：
- en: '`NewGlobalRef()` to create Global references preventing garbage collection
    of the pointed object and allowing it to be shared between threads. It is possible
    for two references for the same object to be different:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NewGlobalRef()` 用于创建全局引用，防止指向的对象被垃圾回收，并允许在线程之间共享。同一个对象可能有两个不同的引用：'
- en: '[PRE52]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`DeleteGlobalRef()` to delete Global references when they are no longer needed.
    Without it, the Dalvik VM would consider that objects are still referenced and
    would never collect them:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DeleteGlobalRef()` 用于在不再需要时删除全局引用。如果没有，Dalvik 虚拟机将认为对象仍然被引用，并且永远不会收集它们：'
- en: '[PRE53]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`IsSameObject()` to compare two object references, instead of using `==`, which
    is not a correct way to compare references:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IsSameObject()` 用于比较两个对象引用，而不是使用 `==`，这不是正确比较引用的方式：'
- en: '[PRE54]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Tip
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Never forget to pair `New<Reference Type>Ref()` with `Delete<Reference Type>Ref()`.
    Failure to do so results in a memory leak.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要忘记将 `New<Reference Type>Ref()` 与 `Delete<Reference Type>Ref()` 配对使用。不这样做会导致内存泄漏。
- en: Weak references
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弱引用
- en: Weak references are the last kind of reference available in JNI. They are similar
    to Global references in that they can be kept between JNI calls and shared between
    threads. However, unlike Global references, they do not prevent garbage collection.
    Thus, this kind of reference must be used with care as it can become invalid at
    any moment, unless you create a Global or Local reference from them before use
    each time you need it (and release it right after!).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 弱引用是 JNI 中可用的最后一种引用类型。它们类似于全局引用，可以在 JNI 调用之间保留并在线程之间共享。但是，与全局引用不同，它们不会阻止垃圾回收。因此，必须谨慎使用这种引用类型，因为它可能在任何时刻变为无效，除非在每次需要时从中创建全局或本地引用（并在使用后立即释放）。
- en: Tip
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'When used appropriately, Weak references are useful to prevent memory leaks.
    If you have already done some Android development, you may already know one of
    the most common leaks: keeping a "hard" reference to an Activity from a background
    thread (typically, an `AsyncTask`) to notify the Activity later on when processing
    is over. Indeed, the Activity might be destroyed (because the user rotated the
    screen, for example) before a notification is sent. When using a Weak reference,
    the Activity can still be garbage collected and memory freed.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当适当使用时，弱引用对于防止内存泄漏是有用的。如果您已经进行了一些 Android 开发，可能已经知道最常见的泄漏之一：从后台线程（通常是 `AsyncTask`）保留对
    Activity 的“硬”引用，以便在处理结束后稍后通知 Activity。确实，Activity 可能在发送通知之前被销毁（例如，因为用户旋转了屏幕）。使用弱引用时，Activity
    仍然可以被垃圾回收并释放内存。
- en: '`NewWeakGlobalRef()` and `DeleteWeakGlobalRef()` are the only methods necessary
    to create and delete a Weak reference:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewWeakGlobalRef()` 和 `DeleteWeakGlobalRef()` 是创建和删除弱引用所必需的唯一方法：'
- en: '[PRE55]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: These methods return a `jweak` reference, which can be cast to the input object
    if needed (for example, if you create a reference to `jclass`, then the returned
    `jweak` can be cast into `jclass` or `jobject`).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you should not use it directly but rather pass it to `NewGlobalRef()`
    or `NewLocalRef()` and use their result as usual. To ensure a local or Global
    reference issued from a Weak reference is valid, simply check whether the reference
    returned by `NewGlobalRef()` or `NewLocalRef()` is `NULL`. Once you are finished
    with the object, you can delete the Global or Local reference. Restart the process
    every time you work with that Weak object again. For example:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To check whether a Weak reference itself points to an object, compare `jweak`
    to `NULL` using `IsSameObject()` (do not use `==`):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Do not try to check the Weak reference state before creating a Global or Local
    reference because the pointed object might be collected concurrently.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prior to Android 2.2 Froyo, Weak references simply did not exist. Until Android
    4.0 Ice Cream Sandwich, they could not be used in JNI calls except `NewGlobalRef()`
    or `NewLocalRef()`. Although this is not an obligation anymore, using weak references
    directly in other JNI calls should be considered a bad practice.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the subject, have a look at the JNI specification at
    [http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/jniTOC.html](http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/jniTOC.html).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Managing Java arrays
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one last type of data we have not talked about yet: **arrays**. Arrays
    have a specific place in Java as well as in JNI. They have their proper types
    and APIs, although Java arrays are also objects at their root.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: In this part, we will improve our store by letting users enter a set of values
    simultaneously in an entry. This set is going to be communicated to the native
    store as a Java array, which in turn is going to be stored as a classic C array.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `Store_Part8`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – handling Java arrays in native Store
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To help us handle operations on arrays, let's download a helper library, **Google
    Guava** (release 18.0 at the time of writing this book) available at [http://code.google.com/p/guava-libraries/](http://code.google.com/p/guava-libraries/).
    Guava offers many useful methods to deal with primitives and arrays, and perform
    "pseudo-functional" programming.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Copy `guava jar` in the project `libs` directory. Open the **Properties** project
    and go to **Java Build Path** | **Libraries**. Reference Guava jar by clicking
    on the **Add JARs...** button and validate.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `StoreType.java` enumeration and add three new values: `IntegerArray`,
    `StringArray`, and `ColorArray`:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Open `Store.java` and add new methods to retrieve and save `int`, `String`,
    and `Color` arrays:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Edit `StoreActivity.java` to connect native methods to the GUI.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `onGetValue()` method so that it retrieves an array from the store
    depending on its type, concatenates its values with a semicolon separator (thanks
    to Guava joiners), and finally, displays them:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Improve `onSetValue()` to convert a list of values into an array before transmitting
    it to `Store` (thanks to the Guava transformation feature):'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Write a helper method `stringToList()` to help you convert a string into a
    list of the target type:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In `jni/Store.h`, add the new array types to the `StoreType` enumeration. Also,
    declare the new fields `mIntegerArray`, `mStringArray`, and `mColorArray` in the
    `StoreValue` union. Store arrays are represented as raw C arrays (that is, a pointer):'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We also need to remember the length of these arrays. Enter this information
    in a new field `mLength` in `StoreEntry`:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In `jni/Store.cpp`, insert cases in `releaseEntryValue()` for the new arrays
    types. Indeed, allocated arrays have to be freed when the corresponding entry
    is released. As colors are Java objects, delete the Global references saved within
    each array item, else garbage collection will never happen (causing a memory leak):'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Regenerate the JNI header `jni/com_packtpub_Store.h` with `Javah`. In `jni/com_packtpub_Store.cpp`,
    implement all these new methods. To do so, first add the `csdtint` include.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Then, cache the `String` and `Color` JNI Classes to be able to create, in the
    following steps, object arrays of these types. Classes are accessible by reflection
    from `JNIEnv` itself, and are retrievable from the `JavaVM` given to `JNI_OnLoad()`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to check whether the found classes are null in case they cannot be
    loaded. If that happens, an exception is raised by the VM so that we can return
    immediately:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Write a `getIntegerArray()` implementation. A JNI array of integers is represented
    with the `jintArray` type. If an `int` is equivalent to `jint`, an `int*` array
    is absolutely not equivalent to `jintArray`. The first is a pointer to a memory
    buffer, whereas the second is a reference to an object.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Thus, to return `jintArray` here, instantiate a new Java integer array with
    the `NewIntArray()` JNI API method. Then, use `SetIntArrayRegion()` to copy the
    native `int` buffer content into `jintArray`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'To save a Java array in native code, the inverse operation `GetIntArrayRegion()`
    exists. The only way to allocate a suitable memory buffer is to measure the array
    size with `GetArrayLength()`:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Java object arrays are different than Java primitive arrays. They are instantiated
    with a class type (here, the cached `String jclass`) because Java arrays are monotype.
    Object arrays themselves are represented with the `jobjectArray` type and can
    be created with the `NewObjectArray()` JNI API method.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Unlike primitive arrays, it is not possible to work on all elements at the same
    time. Instead, objects are set one by one with `SetObjectArrayElement()`. Here,
    the native array is filled with `String` objects stored on the native side, which
    keeps Global references to them. So there is no need to delete or create any reference
    here except the reference to the newly allocated string.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In `setStringArray()`, array elements are retrieved one by one with `GetObjectArrayElement()`.
    Returned references are local and should be made global to store them safely on
    the native side.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Implement the same operations for colors, starting with `getColorArray()`. Since
    strings and colors are both objects on the Java side, the returned array can be
    created in the same way with `NewObjectArray()`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'Place each `Color` reference saved inside the array using the JNI method `SetObjectArrayElement()`.
    Since colors have been stored on the native side as global Java references, no
    Local reference needs to be created or deleted:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In `setColorArray()`, color elements are also retrieved one by one with `GetObjectArrayElement()`.
    Here, again, returned references are local and should be made global to store
    them safely on the native side:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '*What just happened?*'
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We transmitted Java arrays from the Java to the native side and vice versa.
    Java arrays are Java objects that can only be manipulated through a dedicated
    JNI API. They cannot be cast into native C/C++ arrays and are not usable the same
    way.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how to leverage the `JNI_OnLoad()` callback to cache JNI class descriptors.
    Class descriptors, of type `jclass` (which is also `jobject` behind the scenes),
    are equivalent to `Class<?>` in Java. They allow to define the type of array we
    want, a bit like the reflection API in Java. We will come back to this subject
    in the next chapter.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Primitive arrays
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Primitives array types available are `jbooleanArray`, `jbyteArray`, `jcharArray`,
    `jdoubleArray`, `jfloatArray`, `jlongArray`, and `jshortArray`. These types represent
    references to real Java arrays.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'These arrays can be manipulated with several methods provided by JNI:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数组可以使用JNI提供的几种方法进行操作：
- en: '`New<Primitive>Array()` to create a new Java array:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`New<Primitive>Array()`创建一个新的Java数组：'
- en: '[PRE74]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`GetArrayLength()` retrieves the length of an array:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetArrayLength()`检索数组的长度：'
- en: '[PRE75]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`Get<Primitive>ArrayElements()` retrieves a whole array into a memory buffer
    allocated by JNI. The last parameter `isCopy`, when not null, indicates whether
    an array has been internally copied by JNI or it has returned buffer points to
    the real Java string memory:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get<Primitive>ArrayElements()`将整个数组检索到由JNI分配的内存缓冲区中。最后一个参数`isCopy`，当不为null时，指示JNI是否已内部复制数组，还是返回的缓冲区指向真正的Java字符串内存：'
- en: '[PRE76]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '`Release<Primitive>ArrayElements()` releases the memory buffer allocated by
    `Get<Primitive>ArrayElements()`. Always use both in pairs. The last parameter
    mode is related to the `isCopy` parameter and indicates the following:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Release<Primitive>ArrayElements()`释放由`Get<Primitive>ArrayElements()`分配的内存缓冲区。始终成对使用。最后一个参数模式与`isCopy`参数相关，并指示以下内容：'
- en: If 0, then JNI should copy the modified array back into the initial Java array
    and tell JNI to release its temporary memory buffer. This is the most common flag.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果为0，则JNI应将修改后的数组复制回初始Java数组，并告诉JNI释放其临时内存缓冲区。这是最常见的标志。
- en: If `JNI_COMMIT`, then JNI should copy the modified array back into the initial
    array but without releasing the memory. That way, the client code can transmit
    the result back to Java while still pursuing its work on the memory buffer.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`JNI_COMMIT`，则JNI应将修改后的数组复制回初始数组，但不释放内存。这样，客户端代码可以在仍在处理内存缓冲区时将结果传输回Java。
- en: If `JNI_ABORT`, then JNI must discard any change made in the memory buffer and
    leave the Java array unchanged. This will not work correctly if the temporary
    native memory buffer is not a copy.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`JNI_ABORT`，则JNI必须放弃对内存缓冲区所做的任何更改，并保持Java数组不变。如果临时本机内存缓冲区不是副本，则这将无法正常工作。
- en: '[PRE77]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`Get<Primitive>ArrayRegion()` retrieves all or part of an array into a memory
    buffer allocated by the client code. For example for integers:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get<Primitive>ArrayRegion()`将数组的全部或部分检索到由客户端代码分配的内存缓冲区中。例如对于整数：'
- en: '[PRE78]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '`Set<Primitive>ArrayRegion()` initializes all or part of a Java array from
    a native buffer managed by the client code. For example for integers:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Set<Primitive>ArrayRegion()`从客户端代码管理的本机缓冲区初始化Java数组的全部或部分。例如对于整数：'
- en: '[PRE79]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '`Get<Primitive>ArrayCritical()` and `Release<Primitive>ArrayCritical()` are
    similar to `Get<Primitive>ArrayElements()` and `Release<Primitive>ArrayElements()`
    but are only available to provide a direct access to the target array (instead
    of a copy). In exchange, the caller must not perform blocking or JNI calls and
    should not hold the array for a long time (like a critical section with threads).
    Not that the same two methods are featured for all primitives:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get<Primitive>ArrayCritical()`和`Release<Primitive>ArrayCritical()`类似于`Get<Primitive>ArrayElements()`和`Release<Primitive>ArrayElements()`，但仅可提供对目标数组的直接访问（而不是副本）。作为交换，调用者不得执行阻塞或JNI调用，并且不应长时间持有数组（例如使用线程的关键部分）。请注意，所有原语都具有相同的两种方法：'
- en: '[PRE80]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Have a go hero – handling other array types
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试处理其他数组类型
- en: 'With the knowledge freshly acquired, you can implement store methods for other
    array types: `jbooleanArray`, `jbyteArray`, `jcharArray`, `jdoubleArray`, `jfloatArray`,
    `jlongArray`, and `jshortArray`.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚获得的知识，您可以为其他数组类型实现存储方法：`jbooleanArray`，`jbyteArray`，`jcharArray`，`jdoubleArray`，`jfloatArray`，`jlongArray`和`jshortArray`。
- en: 'As an example, you can write the `setBooleanArray()` method for the `jbooleanArray`
    type using `GetBooleanArrayElements()` and `ReleaseBooleanArrayElements()` instead
    of `GetBooleanArrayRegion()`. The result should look like the following, with
    both methods called in a pair with `memcpy()` in between:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以编写`setBooleanArray()`方法，用`GetBooleanArrayElements()`和`ReleaseBooleanArrayElements()`代替`GetBooleanArrayRegion()`来处理`jbooleanArray`类型。结果应该如下所示，两种方法在中间调用`memcpy()`：
- en: '[PRE81]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Note
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `Store_Part8_Full`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目在本书中以`Store_Part8_Full`的名称提供。
- en: Object arrays
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象数组
- en: Object arrays are named `jobjectArray` in JNI and represent a reference to a
    Java Object array. Objects arrays are specific because unlike primitive arrays,
    each array element is a reference to an object. As a consequence, a new Global
    reference is automatically registered each time an object is inserted in the array.
    That way, when native calls end, references do not get garbage collected. Note
    that object arrays cannot be converted to "native" arrays like primitives.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 对象数组在JNI中被命名为`jobjectArray`，表示对Java对象数组的引用。对象数组是特殊的，因为与原始数组不同，每个数组元素都是对对象的引用。因此，每次将对象插入数组时，都会自动注册一个新的全局引用。这样，当本机调用结束时，引用不会被垃圾回收。请注意，对象数组不能像原始数组那样转换为“本机”数组。
- en: 'Object arrays can be manipulated with several methods provided by JNI:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 对象数组可以使用JNI提供的几种方法进行操作：
- en: '`NewObjectArray()` creates a new object array instance:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NewObjectArray()`创建一个新的对象数组实例：'
- en: '[PRE82]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '`GetArrayLength()` retrieves the length of an array (same method as primitives):'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetArrayLength()`检索数组的长度（与原语相同的方法）：'
- en: '[PRE83]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`GetObjectArrayElement()` retrieves one single object reference from a Java
    array. The returned reference is Local:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetObjectArrayElement()`从Java数组中检索单个对象引用。返回的引用是本地的：'
- en: '[PRE84]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '`SetObjectArrayElement()` puts one single object reference into a Java array.
    A Global reference is created implicitly:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SetObjectArrayElement()`将单个对象引用放入Java数组中。全局引用会隐式创建：'
- en: '[PRE85]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: See [http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html](http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html)
    for a more exhaustive list of JNI functions.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 有关JNI函数更详尽的列表，请参阅[http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html](http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html)。
- en: Raising and checking Java exceptions
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引发和检查Java异常
- en: Error handling in the Store project is not really satisfying. If the requested
    key cannot be found or if the retrieved value type does not match the requested
    type, a default value is returned. Do not even try with a Color entry. We definitely
    need a way to indicate that an error occurred! And what better way to indicate
    an error than an exception?
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在Store项目中的错误处理并不令人满意。如果找不到请求的键，或者检索到的值类型与请求的类型不匹配，则会返回默认值。甚至不要尝试使用颜色条目。我们绝对需要一种方式来指示发生了错误！有什么比异常更好的方式来指示错误呢？
- en: JNI provides the necessary API to raise an exception at the JVM level. These
    exceptions are the ones you can then catch in Java. They have nothing in common,
    neither the syntax nor the flow, with the usual C++ exceptions you can find in
    other programs (we will see more about them in [Chapter 9](ch09.html "Chapter 9. Porting
    Existing Libraries to Android"), *Porting Existing Libraries to Android*).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: JNI提供了在JVM级别引发异常所需的API。这些异常是你可以在Java中捕获的异常。它们与通常在其他程序中找到的C++异常既不具有相似之处，也不具有相似的语法或流程（我们将在[第9章](ch09.html
    "第9章。将现有库移植到Android")中详细了解它们，*将现有库移植到Android*）。
- en: In this part, we will see how to raise JNI exceptions from the native to the
    Java side.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，我们将看到如何从本地端向Java端引发JNI异常。
- en: Note
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `Store_Part9`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的项目名称为`Store_Part9`。
- en: Time for action – raising & catching exceptions in native Store
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-在本地Store中引发和捕获异常
- en: 'Create the Java exception `com.packtpub.exception.InvalidTypeException` of
    type `Exception` as follows:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建类型为`Exception`的Java异常`com.packtpub.exception.InvalidTypeException`如下：
- en: '[PRE86]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Repeat the operation for two other exceptions: `NotExistingKeyException` of
    type `Exception` and `StoreFullException` of type `RuntimeException`.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 对另外两个异常重复操作：类型为`Exception`的`NotExistingKeyException`和类型为`RuntimeException`的`StoreFullException`。
- en: 'Open `Store.java` and declare thrown exceptions on `getInteger()` in class
    `Store` (`StoreFullException` is `RuntimeException` and does not need declaration):'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Store.java`并在`Store`类的`getInteger()`上声明抛出的异常（`StoreFullException`是`RuntimeException`，不需要声明）：
- en: '[PRE87]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Repeat the operation for all other getter prototypes (strings, colors, and so
    on).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有其他getter原型（字符串、颜色等）重复操作。
- en: 'These exceptions need to be caught. Catch `NotExistingKeyException` and `InvalidTypeException`
    in `onGetValue()`:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些异常需要被捕获。在`onGetValue()`中捕获`NotExistingKeyException`和`InvalidTypeException`：
- en: '[PRE88]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Catch `StoreFullException` in `onSetValue()` in case the entry cannot be inserted
    because the store capacity is exhausted:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onSetValue()`中捕获`StoreFullException`，以防存储容量耗尽时无法插入条目：
- en: '[PRE89]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Open `jni/Store.h` created in previous parts and define three new helper methods
    to throw exceptions:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前创建的`jni/Store.h`文件，并定义三个新的辅助方法来抛出异常：
- en: '[PRE90]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Edit the `jni/Store.cpp` file to throw `NotExistingKeyException` and `InvalidTypeException`
    when getting an inappropriate entry from the store. A good place to raise them
    is when checking an entry with `isEntryValid()`:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`jni/Store.cpp`文件，在从存储中获取不合适的条目时抛出`NotExistingKeyException`和`InvalidTypeException`。引发它们的好地方是在使用`isEntryValid()`检查条目时：
- en: '[PRE91]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '`StoreFullException` is obviously raised when a new entry is inserted. Modify
    `allocateEntry()` in the same file to check entry insertions:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当插入新条目时，显然会引发`StoreFullException`。修改同一文件中的`allocateEntry()`以检查条目插入：
- en: '[PRE92]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Implement `throwNotExistingException()`. To throw a Java exception, the first
    task is to find the corresponding class (like with the Java reflection API). Since
    we can assume these exceptions will not be raised frequently, we can keep from
    caching class reference. Then, raise the exception with `ThrowNew()`. Once we
    no longer need the exception class reference, we can get rid of it with `DeleteLocalRef`():'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`throwNotExistingException()`。要引发Java异常，第一步是找到相应的类（就像使用Java反射API一样）。由于我们可以假设这些异常不会经常引发，我们可以避免缓存类引用。然后，使用`ThrowNew()`引发异常。一旦不再需要异常类引用，就可以使用`DeleteLocalRef`将其清除：
- en: '[PRE93]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Repeat the operation for the two other exceptions. The code is identical (even
    to throw a runtime exception) and only the class name changes.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 对另外两个异常重复操作。代码是相同的（甚至抛出运行时异常），只有类名不同。
- en: '*What just happened?*'
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: Launch the application and try to get an entry with a non-existing key. Repeat
    the operation with an entry, which exists in the store but with a different type
    than the one selected in the GUI. In both cases, there is an error message. Try
    to save more than 16 references in the store and you will get an error again.
    In each case, an exception has been raised on the native side and caught on the
    Java side.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序并尝试获取一个不存在的键的条目。重复操作，使用存储中存在但与GUI中选择的类型不同的条目。在这两种情况下都会出现错误消息。尝试在存储中保存超过16个引用，你将再次收到错误消息。在每种情况下，都会在本地端引发异常并在Java端捕获。
- en: Raising exceptions in native code is not a complex task, but it is not trivial
    either. An exception is instantiated with a class descriptor of type `jclass`.
    This class descriptor is required by JNI to instantiate the proper kind of exception.
    JNI exceptions are not declared on JNI method prototypes since they are not related
    to C++ exceptions (exceptions which cannot be declared in C anyway). This explains
    why we have not regenerated the JNI header to accommodate the changes in the `Store.java
    file`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地代码中引发异常并不是一项复杂的任务，但也不是微不足道的。异常是使用`jclass`类型的类描述符实例化的。这个类描述符是JNI实例化适当类型的异常所需的。JNI异常不会在JNI方法原型中声明，因为它们与C++异常无关（无论如何C中都不能声明异常）。这就解释了为什么我们没有重新生成JNI头文件来适应`Store.java`文件中的更改。
- en: Executing code in Exception state
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在异常状态下执行代码
- en: 'Once an exception is raised, be really careful with the JNI call you make.
    Indeed, any subsequent call fails until either of the following events occur:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦引发异常，就要非常小心你所做的JNI调用。实际上，任何后续调用都会失败，直到发生以下事件之一：
- en: The method is returned and an exception is propagated.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法被返回，异常被传播。
- en: 'The exception is cleared. Clearing an exception means that the exception is
    handled and thus not propagated to Java. For example:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Only a few JNI methods are still safe to call after an exception is raised:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '| `DeleteGlobalRef` | `PopLocalFrame` |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
- en: '| `DeleteLocalRef` | `PushLocalFrame` |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
- en: '| `DeleteWeakGlobalRef` | `Release<Primitive>ArrayElements` |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
- en: '| `ExceptionCheck` | `ReleasePrimitiveArrayCritical` |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
- en: '| `ExceptionClear` | `ReleaseStringChars` |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
- en: '| `ExceptionDescribe` | `ReleaseStringCritical` |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
- en: '| `ExceptionOccurred` | `ReleaseStringUTFChars` |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
- en: '| `MonitorExit` |   |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
- en: Do not try to call any other JNI method. Native code should clean its resources
    and give control back to Java as soon as possible (or handle the exception itself).
    Indeed, JNI exceptions have nothing in common with C++ exceptions. Their execution
    flow is completely different. When a Java exception is raised from native code,
    the latter can still pursue its processing. However, as soon as native call returns
    hand back to the Java VM, the latter propagates the exception as usual. In other
    words, JNI exceptions raised from native code affect Java code only (and JNI calls
    others then the one listed previously).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling API
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JNI offers several methods to manage exceptions among which:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '`ThrowNew()` to raise the exception itself, allocating a new instance:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '`Throw()` to raise an exception that has already been allocated (for example,
    to rethrow):'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '`ExceptionCheck()` to check whether an exception is pending, whoever raised
    it (native code or a Java callback). A simple `jboolean` is returned, which makes
    it appropriate for simple checks:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '`ExceptionOccurred()` to retrieve a `jthrowable` reference to the raised exception:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '`ExceptionDescribe()` is equivalent to `printStackTrace()` in Java:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'An exception can be marked as caught on the native side with `ExceptionClear()`:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: It is essential to learn how to use these methods to write robust code, especially
    when calling back Java from native code. We will learn more about this subject
    in the next chapter.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to make Java communicate with C/C++. Android is
    now almost bilingual! Java can call C/C++ code with any type of data or object.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: We first initialized a native JNI library using the `JNI_OnLoad` hook. Then,
    we converted Java Strings inside native code and saw the difference between Modified
    UTF-8 and UTF-16 character encoding. We also passed Java primitives to native
    code. Each of these primitives has their C/C++ equivalent type they can be cast
    to.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: We also handled Java object references in native code using Global references
    and learned the difference between these and Local references. The first must
    be carefully deleted to ensure proper garbage collection, while the latter has
    native method scope and must be managed with care as their number is limited by
    default.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed how to manage Java arrays in native code so that we could
    access their content as native arrays. Arrays may or may not be copied by the
    VM when manipulated in native code. This performance penalty has to be taken into
    account.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we raised and checked Java exceptions in native code. We saw that they
    have a different flows from the standard C++ exceptions. When an exception occurs,
    only a few cleaning JNI methods are safe to call. JNI exceptions are JVM-level
    exceptions, which means their flow is completely different from standard C++ exceptions.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: However, there is still more to come. Any Java object, method, or field can
    be called or retrieved by native code. Let's see how to call Java from C/C++ code
    in the next chapter.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL

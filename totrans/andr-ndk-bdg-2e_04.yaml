- en: Chapter 4. Calling Java Back from Native Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*To reach its full potential, JNI allows calling back Java code from C/C++.
    "Back" because native code is first invoked from Java, which in turn calls it
    back. Such calls are performed through a reflective API, which allows doing almost
    anything that can be done directly in Java.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Another important matter to consider with JNI is threading. Native code can
    be run on a Java thread, managed by the Dalvik VM, and also from a native thread
    created with standard POSIX primitives. Obviously, a native thread cannot call
    JNI code unless it is turned into a managed Java thread! Programming with JNI
    necessitates knowledge of all these subtleties. This chapter will guide you through
    the main ones.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*The last topic, which is specific to Android and not JNI, other: the Android-specific
    Bitmap API aims at giving full processing power to graphics applications running
    on these tiny (but powerful) devices.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Android NDK also proposes a new API to access natively an important type
    of object: bitmaps. The Bitmap API, which is Android-specific, gives full processing
    power to graphics applications running on these tiny (but powerful) devices.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `Store` project we started in the previous chapter is going to be our canvas
    to demonstrate JNI callbacks and synchronization. To illustrate Bitmap processing,
    we are going to create a new project that decodes a device's camera feed inside
    native code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, in this chapter, we are going to learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Call Java back from native code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attach a native thread to the Dalvik VM and handle synchronization with Java
    threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process Java bitmaps in native code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to make Java and C/C++ communicate
    and synchronize reciprocally.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Java back from native code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we discovered how to get a Java class descriptor with
    the JNI method `FindClass()`. However, we can get much more! Actually, if you
    are a regular Java developer, this should remind you of something: the Java Reflection
    API. JNI is similar in that it can modify Java object fields, run Java methods,
    and access static members, but from native code!'
  prefs: []
  type: TYPE_NORMAL
- en: For this last part with the `Store` project, let's enhance our store application
    so that it notifies Java when an entry has been successfully inserted.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `Store_Part10`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – determining JNI method signatures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s define a Java interface that native C/C++ code will call back through
    JNI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `StoreListener.java`, which contains an interface defining a few callbacks,
    one for integers, one for strings, and one for colors, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Open `Store.java` and make a few changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare a member delegate `StoreListener`, to which success callbacks are sent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the `Store` constructor to inject the delegate listener, which is going
    to be `StoreActivity`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, implement the `StoreListener` interface and its corresponding methods,
    which simply forwards calls to the delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Open `StoreActivity.java` and implement the `StoreListener` interface in `PlaceholderFragment`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, change the `Store` construction accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When a success callback is received, a simple toast message is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Open a terminal in the `Store` project's directory and run the `javap` command
    to determine method signatures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![Time for action – determining JNI method signatures](img/9645_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Calling back Java methods with the JNI API requires **descriptors**, as we will
    see in the next part. To determine a Java method descriptor, we need a **signature**.
    Indeed, methods in Java can be **overloaded**, which means that there can be two
    methods with the same name but different parameters. This is why a signature is
    required.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can determine a method''s signature with `javap`, a JDK utility to disassemble
    `.class` files. This signature can then be given to the JNI Reflection API. Formally
    speaking, a signature is declared in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For example, the signature for the method `boolean myFunction(android.view.View
    pView, int pIndex)` would be `(Landroid/view/View;I)Z`. Another example, `(I)V`,
    means an integer is expected and a void is returned. A last example, `(Ljava/lang/String;)V`,
    means a String is passed in parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the various types available in JNI with their
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Java type | Native type | Native array type | Type code | Array type code
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean` | `jboolean` | `jbooleanArray` | `Z` | `[Z` |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | `jbyte` | `jbyteArray` | `B` | `[B` |'
  prefs: []
  type: TYPE_TB
- en: '| `char` | `jchar` | `jcharArray` | `C` | `[C` |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | `jdouble` | `jdoubleArray` | `D` | `[D` |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | `jfloat` | `jfloatArray` | `F` | `[F` |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | `jint` | `jintArray` | `I` | `[I` |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | `jlong` | `jlongArray` | `J` | `[J` |'
  prefs: []
  type: TYPE_TB
- en: '| `Short` | `jshort` | `jshortArray` | `S` | `[S` |'
  prefs: []
  type: TYPE_TB
- en: '| `Object` | `jobject` | `jobjectArray` | `L` | `[L` |'
  prefs: []
  type: TYPE_TB
- en: '| `String` | `jstring` | `N/A` | `L` | `[L` |'
  prefs: []
  type: TYPE_TB
- en: '| `Class` | `jclass` | `N/A` | `L` | `[L` |'
  prefs: []
  type: TYPE_TB
- en: '| `Throwable` | `jthrowable` | `N/A` | `L` | `[L` |'
  prefs: []
  type: TYPE_TB
- en: '| `void` | `void` | `N/A` | `V` | `N/A` |'
  prefs: []
  type: TYPE_TB
- en: All these values correspond to the one dumped by `javap`. For more information
    about descriptors and signatures, have a look at the Oracle documentation at [http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the proper signature, we can start calling Java from C/C++.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – calling back Java from native code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s continue our `Store` by calling back the interface we defined from native
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `com_packtpub_store_Store.cpp`, declare method descriptors with type `jmethodID`
    for each callback, which is going to be cached:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, cache all the callback descriptors in `JNI_OnLoad()`. This can be done
    in two main steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Getting a Class descriptor with the JNI method `FindClass()`. One can find
    a class descriptor, thanks to its absolute package path, here: `com./packtpub/store/Store`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieving a method descriptor from the class descriptor with `GetMethodID()`.
    To differentiate several overloaded methods, the signatures retrieved earlier
    with `javap` must be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Notify the Java Store (that is, `pThis`) when an integer is successfully inserted
    in `setInteger()`. To invoke a Java method on a Java object, simply use `CallVoidMethod()`
    (which means that the called Java method returns void). To do so, we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An object instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method signature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effective parameters to pass, if applicable (here, an integer value)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeat the operation for strings. There is no need to generate a Global reference
    when allocating the returned Java string as it is used immediately in the Java
    callback. We can also destroy the Local reference to this string right after usage,
    but JNI will take care of that when returning from the native callback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, repeat the operation for colors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Launch the application and insert an integer, a string, or color entry. A successful
    message is displayed with the inserted value. The native code called the Java
    side thanks to the JNI Reflection API. This API is not only useful to execute
    a Java method, it is also the only way to process `jobject` parameters passed
    to a native method. However, if calling C/C++ code from Java is rather easy, performing
    Java operations from C/C++ is a bit more involving!
  prefs: []
  type: TYPE_NORMAL
- en: 'Although a bit repetitive and verbose, calling any Java method should always
    be as trivial as this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieve the class descriptor from those we want to call methods (here, the
    `Store` Java object):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve the method descriptors for the callback we want to call (such as the
    `Method` class in Java). These method descriptors are retrieved from the class
    descriptor, which owns it (like a `Class` in Java):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Optionally, cache the descriptors so that they can be used immediately in future
    native calls. Again, `JNI_OnLoad()` makes it easy to cache JNI descriptors before
    any native call is made. Descriptors whose names end with `Id`, such as `jmethodID`,
    can be freely cached. They are not references that can be leaked, or have to be
    made global on the opposite to `jclass` descriptors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Caching descriptors is definitely good practice, as retrieving Fields or Methods
    through the JNI reflection may cause some overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoke methods with the necessary parameters on an object. The same method
    descriptor can be reused on any object instance of the corresponding class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Whatever method you need to call on a Java object, the same process always applies.
  prefs: []
  type: TYPE_NORMAL
- en: More on the JNI Reflection API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you know the Reflection API, you know most of the JNI. Here are some of
    the provided methods that may be useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FindClass()` retrieves a (Local) reference to a `Class` descriptor object
    according to its absolute path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`GetObjectClass()` has the same purpose, except that `FindClass()` finds class
    definitions according to their absolute path, whereas the other finds the class
    directly from an object instance (such as `getClass()` in Java):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following methods allow you to retrieve JNI descriptors for methods and
    fields, and either static or instance members. These descriptors are IDs and not
    references to Java objects. There is no need to turn them into Global references.
    These methods require the method or field name and a signature to differentiate
    overloads. Constructor descriptors are retrieved in the same way as methods, except
    that their name is always `<init>` and they have a void return value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a second set of methods to retrieve field values using their corresponding
    descriptors. There is one getter and one setter method per primitive type, plus
    another for objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The same goes for methods according to their return values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Variants of these methods exist with an `A` and `V` postfix. The behavior is
    identical, except that arguments are specified respectively using a `va_list`
    (that is, variable argument list) or `jvalue` array (`jvalue` being a union of
    all JNI types):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Have a look at `jni.h` in the Android NDK `include` directory to see all the
    possibilities by the JNI reflective API.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging JNI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal of JNI calls is often performance. Thus, JNI does not perform advanced
    checking when its API methods are invoked. Hopefully, there exists an **extended
    checking** mode, which performs advanced checks and gives feedback in the Android
    Logcat.
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate it, run the following command from a command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The extended checking mode is available for applications started after this
    flag is set, until it is set to `0`, or until the device is rebooted. For rooted
    devices, the whole device can be started with this mode with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If everything works properly, a message **Late-enabling – Xcheck:jni** appears
    in the Logcat when your application starts. Then, check the Logcat regularly to
    find its JNI warning or error.
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging JNI](img/9645_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Synchronizing Java and native threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parallel programming is a mainstream subject nowadays. Android makes no exception
    since the introduction of multicore processors. You can do the threading entirely
    on the Java side (with the Java Thread and Concurrency APIs), on the native side
    (with the **POSIX PThread** API, which is provided by the NDK), and, more interestingly,
    between the Java and native side using JNI.
  prefs: []
  type: TYPE_NORMAL
- en: In this part, we will create a background thread, the watcher, which keeps a
    constant eye on what is inside the data store. It iterates through all entries
    and then sleeps for a fixed amount of time. When the watcher thread finds a key
    of a specific type predefined in the code, it acts accordingly. For this first
    part, we are just going to clip integer values to a predefined range.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, threads need synchronization. The native thread is going to access
    and update the store only when a user understands the UI thread, and does not
    modify it. The native thread is created in C/C++ but the UI thread is a Java thread.
    We are going to use JNI monitors to synchronize both of them.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – allocating an object with JNI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s define a background Watcher that will use an object shared between Java
    and C/C++ as a lock:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Store.java`, add two new methods to start and stop a watcher thread. These
    methods respectively return and take a `long` as parameter. This value helps us
    hold a native pointer on the Java side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file, `StoreThreadSafe.java`. The `StoreThreadSafe` class inherits
    from the `Store` class and aims at making the `Store` instances thread-safe using
    `synchronized` Java blocks. Declare a static member field `LOCK` of type `Object`
    and define a default constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `Store` methods, such as `getCount()`, `getInteger()`, and `setInteger()`
    using Java blocks synchronized with the `LOCK` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Do the same for all other methods, such as `getString()`, `setString()`, `getColor()`,
    `setColor()`, etc., and the `stopWatcher()` method. Do not override the `onSuccess`
    callbacks and the `startWatcher()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Do *not* override the `onSuccess` callbacks and the `startWatcher()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `StoreActivity.java` and replace the previous `Store` instance with an
    instance of `StoreThreadSafe`. Also, create a member field of type `long` to hold
    a native pointer to the watcher thread. When the fragment is resumed, start the
    watcher thread and save its pointer. When the fragment is paused, stop the watcher
    thread with the previously saved pointer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit `jni/Store.h` and include a new header `pthread.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The watcher works on a `Store` instance updated at regular intervals of time.
    It needs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The instance of the `Store` structure it watches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `JavaVM`, which is the only object safely shareable among threads and from
    which `JNIEnv` can be safely retrieved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Java object to synchronize on (corresponding to the `LOCK` object we defined
    on the Java side)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `pthread` variable dedicated to native thread management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An indicator to stop the watcher thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, define three methods to start and stop the watcher thread, run its
    main loop, and process an entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Refresh the JNI header file `jni/com_packtpub_Store.h` with `javah`. You should
    see two new methods, `Java_com_packtpub_store_Store_startWatcher()` and `Java_com_packtpub_store_Store_stopWatcher()`,
    in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `com_packtpub_store_Store.cpp`, create a new static variable `gLock` that
    is going to hold the Java synchronization object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an instance of the `Object` class in `JNI_OnLoad()` using the JNI Reflection
    API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, find its `Object` constructor with `GetMethodID()`. Constructors in JNI
    are named `<init>` and have no result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, invoke the constructor to create an instance and make it global.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, remove local references when they become useless:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the created `Object` instance in the `StoreThreadSafe.LOCK` field. This
    object is going to be used during the lifetime of the application to synchronize:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, retrieve the `StoreThreadSafe` class and its `LOCK` field using the JNI
    Reflection methods `FindClass()` and `GetStaticFieldId()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, save the value into the `LOCK` static field with the JNI method `SetStaticObjectField()`,
    which requires a field signature (such as methods)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, remove the local reference to the `StoreThreadSafe` class when it
    becomes useless:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `startWatcher()`, which calls the corresponding method defined earlier.
    It requires `JavaVM`, which can be retrieved from the `JNIEnv` object with `GetJavaVM()`.
    The pointer (that is, the memory address) to the created `Store` is returned as
    a `long` value to the Java side, which can then store it for alter use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Terminate by implementing `stopWatcher()`, which casts the given `long` value
    back to a native pointer. Pass it to the corresponding method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used JNI to allocate a Java object from native code and save it in a static
    Java field. This example shows the power of the JNI Reflection API; almost anything
    that can be done in Java, can be done from native code with JNI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allocate Java objects, JNI provides the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NewObject()` to instantiate a Java object using the specified constructor
    method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Variants of this method exist with an `A` and `V` postfix. Behavior is identical,
    except that arguments are specified respectively using a `va_list` or a `jvalue`
    array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`AllocObject()` allocates a new object but does not invoke its constructor.
    A possible usage would be the allocation of many of the objects, which does not
    require initialization to get some performance gains. Use it only if you know
    what you are doing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the previous chapter, we used static variables for the native store because
    its life cycle was tied to the application. We want to remember values until the
    application exits. If a user leaves the activity and comes back to it later, values
    are still available while the process remains alive.
  prefs: []
  type: TYPE_NORMAL
- en: For the watcher thread we used a different strategy because its life cycle is
    tied to the activity. When the activity gains focus, the thread is created and
    started. When activity loses focus, the thread is stopped and destroyed. Since
    this thread may need time to stop, several occurrences may run temporarily at
    the same time (if you turn the screen quickly multiple times in the `Store` example).
  prefs: []
  type: TYPE_NORMAL
- en: Thus, it is not safe to use static variables as it could be concurrently overwritten
    (leading to a memory leak), or, even worse, released (leading to memory corruption).
    These kind of problems can also arise when an activity starts another one. In
    that case, `onStop()` and `onDestroy()` of the first activity occurs after `onCreate()`
    and `onStart()` of the second activity, as defined in the Android Activity life
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, a better solution to handle this situation is to allow the Java side
    to manage the native memory. In our example, a pointer to a native structure allocated
    on the native side is returned to the Java side as a `long` value. Any further
    JNI calls must be performed with this pointer as a parameter. This pointer can
    then be given back to the native side when the life cycle of this piece of data
    ends.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use of a `long` value (represented on 64-bit) to save a native pointer is
    necessary in order to remain compatible with 64-bit versions of Android (with
    64-bit memory addresses) that arrived with Android Lollipop.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, use native static variables with care. If your variables are tied
    to the application life cycle, static variables are fine. If your variables are
    tied to the activity lifecycle, you should allocate an instance of them in your
    activity and manage them from there to avoid problems.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a shared lock between the Java and the native side, let's continue
    our example by implementing the Watcher thread.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – running and synchronizing a thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a native thread using the POSIX PThread API and attach it to
    the VM:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Store.cpp`, include `unistd.h`, which gives access to the `sleep()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Implement `startWatcher()`. This method is executed from the UI thread. To do
    so, first instantiate and initialize a `StoreWatcher` structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, initialize and launch a native thread with the `pthread` POSIX API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, initialize and launch a native thread with the PThread POSIX API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pthread_attr_init()` initializes the necessary data structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pthread_create()` starts the thread'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `stopWatcher()`, which turns off the running indicator to request
    the watcher thread to stop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Implement the thread's main loop in `runWatcher()`. Here, we are not on the
    UI thread anymore, but on the watcher thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So first, attach the thread as a daemon to the Dalvik VM using `AttachCurrentThreadAsDaemon()`.
    This operation returns `JNIEnv` from the given `JavaVM`. This gives us direct
    access to the Java side from this new thread. Remember that `JNIEnv` is thread-specific
    and cannot be shared between threads directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, make this thread loop and take a nap for a few seconds during each iteration
    using `sleep()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: While in a loop iteration, delimit a critical section (where only one thread
    can go at the same time) with JNI methods `MonitorEnter()` and `MonitorExit()`.
    These methods require an object to synchronize on (like a `synchronized` block
    in Java).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, you can safely:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the thread should be stopped, and leave the loop in that case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process each entry from the store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Before exiting, detach the thread when it is going to end and exit. It is very
    important to always detach an attached thread so that the Dalvik or ART VM stop
    managing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, terminate the thread using the `pthread_exit()` API method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, write the `processEntry()` method, which does nothing more than check
    the boundaries of integer entries and limit them to the arbitrary range `[-100000,100000]`.
    You can also process any of the other entries you wish:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Compile and run the application in Debug mode using the Eclipse Java debugger
    (not the native one). When the application starts, a native background thread
    is created and attached to the Dalvik VM. You can see it in the **Debug** view.
    Then, the UI thread and the native background thread are synchronized together
    with the JNI Monitor API to handle concurrency issues properly. Finally, when
    leaving the application, the background thread is detached and destroyed. Thus,
    it disappears from the **Debug** view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/9645_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, from the `Store` interface on your Android device, define a key and enter
    an integer value greater than `100,000`. Wait a few seconds and retrieve the value
    using the same key. It should appear clamped to `100,000` by the Watcher thread.
    This Watcher looks for each value in the store and changes it if needed.
  prefs: []
  type: TYPE_NORMAL
- en: The Watcher is running on a native thread (that is, not created directly by
    the Java VM). The NDK allows creating native threads using the PThread POSIX API.
    This API is a standard used commonly on Unix systems for multithreading. It defines
    a set of functions and data structures, all prefixed with `pthread_`, to create
    not only threads, but also **Mutexes** (which stands for Mutual Exclusion) or
    **Condition** **variables** (to make a thread wait for a specific condition).
  prefs: []
  type: TYPE_NORMAL
- en: The PThread API is a whole subject in itself and is outside the scope of this
    book. You will need to know it to master native multithreading on Android. For
    more information on this subject, have a look at [https://computing.llnl.gov/tutorials/pthreads/](https://computing.llnl.gov/tutorials/pthreads/)
    and [http://randu.org/tutorials/threads/](http://randu.org/tutorials/threads/).
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing Java and C/C++ with JNI Monitors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the Java side, we synchronize threads using `synchronized` blocks with an
    arbitrary lock object. Java also allows methods, whether native or not, to be
    `synchronized`. The lock object, in that case, is implicitly the one on which
    native methods are defined. For example, we could define a native method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This would not have worked in our case, since there is a single static instance
    of the store on the native side. We need a single static instance of our lock
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that the pattern used here, that is, making `StoreThreadSafe` inherit
    from the `Store` class, override its methods and use static variables, should
    not be considered specifically as the best practice. It has been used for simplicity
    purposes in this book because the `Store` and the `lock` object are static.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the native side, synchronization is performed with a JNI monitor, which
    is equivalent to the `synchronized` keyword in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MonitorEnter()` delimits the start of a critical section. The monitor is associated
    with an object, which can be considered as a kind of identifier. Only one thread
    at a time can go inside the section defined by this object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`MonitorExit()` delimits the end of a critical section. It must be called,
    along with `MonitorEnter()`, to ensure the monitor is released and other threads
    can go:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Because Java threads are based on POSIX primitives internally, it is also possible
    to implement thread synchronization entirely natively with the POSIX API. You
    can find more information about it at [https://computing.llnl.gov/tutorials/pthreads/](https://computing.llnl.gov/tutorials/pthreads/).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java and C/C++ are different languages with similar, but somewhat different
    semantics. Thus, always be careful not to expect C/C++ to behave like Java. As
    an example, the volatile has a different semantic in Java and C/C++, since both
    follow a different memory model.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching and detaching native threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, the Dalvik VM is unaware of the native threads that run in the
    same process. In return, the native threads cannot access the VM either... unless
    it is attached to it. The attachment is handled in JNI with the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AttachCurrentThread()` to tell the VM to manage the current thread. Once attached,
    a pointer to the `JNIEnv` for the current thread is returned at the specified
    location:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`AttachCurrentThreadAsDaemon()` to attach a thread as a daemon. Java specification
    defines that the JVM does not have to wait for a daemon thread to exit before
    leaving, the opposite to normal threads. This distinction has no real meaning
    on Android, since an application can be killed at any time by the system:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`DetachCurrentThread()` indicates to the VM that a thread does not need to
    be managed anymore. An attached thread like the Watcher thread must be eventually
    unattached before exiting. Dalvik detects threads that are not detached and reacts
    by aborting and leaving a dirty crash dump in your logs! When getting detached,
    any monitor held is released, and any waiting thread is notified:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Android 2.0, a technique to make sure a thread is systematically detached
    is to bind a destructor callback to the native thread with `pthread_key_create()`
    and call `DetachCurrentThread()` in it. A `JNIEnv` instance can be saved into
    thread local storage with `pthread_setspecific()` to pass it as an argument to
    the destructor.
  prefs: []
  type: TYPE_NORMAL
- en: After a thread is attached, the **ClassLoader** JNI uses Java classes to correspond
    to the first object it finds on the call stack. For purely native threads, no
    `ClassLoader` might be found. In that case, JNI uses the system `ClassLoader`,
    which might not be able to find your own application classes, that is, `FindClass()`
    fails. In that case, either cache the necessary JNI elements globally in `JNI_OnLoad()`
    or share an application class loader with the needing thread.
  prefs: []
  type: TYPE_NORMAL
- en: Processing bitmaps natively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android NDK proposes an API dedicated to bitmap processing, which gives
    direct access to the surface of Android bitmaps. This API is specific to Android
    and is not related to the JNI specification. However, bitmaps are Java objects
    and will need to be treated as such in native code.
  prefs: []
  type: TYPE_NORMAL
- en: To see more concretely how bitmaps can be modified from native code, let's try
    to decode a camera feed from native code. Raw video frames recorded on Android
    are generally encoded in a specific format, **YUV**, which is not compatible with
    classic RGB images. This is a situation where native code comes to the rescue
    to help us decode such images. In the following example, we are going to extract
    each color component (that is, red, green, and blue) into a separate bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `LiveCamera`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – decoding a camera's feed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write the necessary Java code to record and display pictures in a fresh
    new project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new hybrid Java/C++ project as shown in [Chapter 2](ch02.html "Chapter 2. Starting
    a Native Android Project"), *Starting a Native Android Project*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `LiveCamera`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main package is `com.packtpub.livecamera`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main activity is `LiveCameraActivity`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main activity layout name is `activity_livecamera`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the **Blank Activity** template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once created, turn the project into a native project as already seen. In the
    `AndroidManifest.xml` file, request access permission to the camera. Then, set
    the activity style to `fullscreen` and its orientation to `landscape`. Landscape
    orientation avoids most camera orientation problems that are met on Android devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `activity_livecamera.xml` layout as follows. It represents a 2x2
    grid containing one `TextureView` and three `ImageView` elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `LiveCameraActivity.java` and implement it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, extend `SurfaceTextureListener`, which is going to help us initialize
    and close the camera feed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, extend the `PreviewCallback` interface to listen for new camera frames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Do not forget to load the native static library, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a few member variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mCamera` is the Android camera API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mTextureView` displays the raw camera feed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mVideoSource` captures camera frames into a byte buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mImageViewR`, `G`, and `B` display processed images, one for each color component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mImageR`, `G`, and `B` are the bitmaps backing the `ImageView` (the "back
    buffers")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In `onCreate()`, specify the layout defined in the previous step.
  prefs: []
  type: TYPE_NORMAL
- en: Then, retrieve the views to show images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, listen for `TextureView` events with `setSurfaceTextureListener()`.
    You can ignore some of the callbacks that are not necessary in this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `onSurfaceTextureAvailable()` callback in `LiveCameraActivity.java` is triggered
    after the `TextureView` surface is created. This is the place where surface dimensions
    and pixel formats get known.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, open the Android camera and set up `TextureView` as its preview target.
    Listen for new camera frames with `setPreviewCallbackWithBuffer()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Then, call `findBestResolution()`, which we will implement next to find a suitable
    resolution for the camera feed. Set up the latter accordingly with the `YCbCr_420_SP`
    format (which should be the default on Android).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, set up the video buffer and the bitmaps that display camera frames:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, enqueue the video frame buffer and start the camera preview:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Still in `LiveCameraActivity.java`, implement `findBestResolution()`. An Android
    camera can support various resolutions, which are highly dependent on the device.
    As there is no rule on what could be the default resolution, we need to look for
    a suitable one. Here, we select the biggest resolution that fits the display surface,
    or the default one if none can be found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Release the camera when the `TextureView` surface is destroyed in `onSurfaceTextureDestroyed()`,
    as it is a shared resource. Bitmap buffers can also be recycled and nullified
    to ease garbage collector work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Finally, decode raw video frames in `onPreviewFrame()`. This handler is triggered
    by the `Camera` class each time a new frame is ready.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Raw video bytes are passed to the native method `decode()`, along with the backing
    bitmap, and a filter to select each color component.
  prefs: []
  type: TYPE_NORMAL
- en: Once decoded, invalidate the surface to redraw it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, "re-enqueue" the raw video buffer to request the capture of a new video
    frame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We captured live images from our device's camera thanks to the Android Camera
    API. After setting up the camera capture format and definition, we created all
    the necessary capture buffer and output images to display onscreen. Captures are
    saved in a buffer enqueued by the application when it requires a new frame. Then,
    this buffer is given with a bitmap to a native method, which we will write in
    the next section. Finally, the output image is displayed onscreen.
  prefs: []
  type: TYPE_NORMAL
- en: The video feed is encoded in the YUV NV21 format. YUV is a color format originally
    invented in the old days of electronics to make black and white video receivers
    compatible with color transmissions and is still commonly used nowadays. The default
    frame format is guaranteed by the Android specification to be **YCbCr 420 SP**
    (or **NV21**) on Android.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although YCbCr 420 SP is the default video format on Android, the emulator only
    supports YCbCr 422 SP. This defect should not cause much trouble as it basically
    swaps colors. This problem should not occur on real devices.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our live image is captured, let's process it on the native side.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – processing pictures with the Bitmap API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s continue our application by decoding and filtering images on the native
    side by the color channel:'
  prefs: []
  type: TYPE_NORMAL
- en: Create native C source, `jni/CameraDecoder.c` (not a C++ file, so that we can
    see the difference with JNI code written in C++).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include `android/bitmap.h`, which defines the NDK bitmap processing API and
    `stdlib.h` (not `cstdlib` as this file is written in C):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Write a few utility macros to help decode a video.
  prefs: []
  type: TYPE_NORMAL
- en: '`toInt()` converts a jbyte to an integer, erasing all useless bits with a mask'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max()` gets the maximum between two values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clamp()` clamps a value inside a defined interval'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color()` builds an ARGB color from each color component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Implement the native method `decode()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, retrieve bitmap information and check whether its pixel format is a 32-bit
    RGBA. Then, lock it to allow drawing operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, gain access to the input video frame content passed as a Java byte
    array with `GetPrimitiveArrayCritical()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Decode the raw video frame into the output bitmap. The video frame is encoded
    in the YUV format, which is quite different from RGB. The YUV format encodes a
    color in three components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One luminance component, that is, the grayscale representation of a color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two chrominance components, which encode the color information (also called
    **Cb** and **Cr** as they represent the blue-difference and red-difference).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many frame formats based on YUV colors. Here, we convert frames by
    following the YCbCr 420 SP (or NV21) format. This kind of image frame is composed
    of a buffer of 8-bit Y luminance samples, followed by a second buffer of interleaved
    8-bit V and U chrominance samples. The VU buffer is subsampled, which means that
    there are less U and V samples compared to Y samples (1 U sample and 1 V sample
    for 4 Y samples). The following algorithm processes each pixel and converts each
    YUV pixel to RGB using the appropriate formula (see `http://www.fourcecc.org/fccyvrgb.php`
    for more information):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: To finish, release the Java byte buffer acquired earlier and unlock the backing
    bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Instead of relying on a naming convention to find native methods, JNI allows
    native methods to be registered manually in `JNI_OnLoad()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, define a table that describes the native methods to register their name,
    signature, and address. Here, only `decode()` needs to be specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in `JNI_OnLoad()`, find the Java on which the native method `decode()`
    is declared (here, `LiveCameraActivity`), and tell JNI which method to use with
    `RegisterNatives()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the `Application.mk` makefile as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the `Android.mk` makefile as follows (link it to the `jnigraphics` module,
    which defines the Android Bitmap API):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compile and run the application. The raw video feed is displayed in the top-left
    corner without any transformation. The raw video frame is decoded in native code
    and each color channel is extracted into three Java bitmaps. These bitmaps are
    displayed inside three `ImageView` elements in each of the corners of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/9645_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The algorithm used to decode the YUV frame originates from the Ketai open source
    project, an image and sensor processing library for Android. See [http://ketai.googlecode.com/](http://ketai.googlecode.com/)
    for more information. Beware that YUV to RGB is an expensive operation that is
    likely to remain a point of contention in your program (**RenderScript**, which
    we will discover in [Chapter 10](ch10.html "Chapter 10. Intensive Computing with
    RenderScript"), *Intensive Computing with RenderScript*, can help in that task).
  prefs: []
  type: TYPE_NORMAL
- en: The code presented here is far from being optimal (the decoding algorithm can
    be optimized, the video frames, captured with multiple buffers, memory accesses
    can be reduced, and code can be multithreaded) but it gives an overview of how
    bitmap can be processed natively with the NDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'Native code is given direct access to the bitmap surface thanks to the Android
    NDK Bitmap API defined in the `jnigraphics` module. This API, which can be considered
    as an Android specific extension to JNI, defines the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AndroidBitmap_getInfo()` to retrieve bitmap information. The returned value
    is negative when a problem occurs, or else `0`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Bitmap information is retrieved in the `AndroidBitmapInfo` structure, which
    is defined as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '`AndroidBitmap_lockPixels()` gives exclusive access to the bitmap while processing
    it. The returned value is negative when a problem occurs, or else `0`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '`AndroidBitmap_unlockPixels()` releases the exclusive lock on the bitmap. The
    returned value is negative when a problem occurs, or else `0`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Drawing operations on any bitmap occurs systematically in three main steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the bitmap surface is acquired.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, bitmap pixels are modified. Here, video pixels are converted to RGB and
    written to the bitmap surface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the bitmap surface is released.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bitmaps must be systematically locked and then unlocked when accessed natively.
    Drawing operations must occur imperatively between a lock/unlock pair. Have a
    look at the `bitmap.h` header file for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Registering native methods manually
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our store example, native method prototypes have been generated automatically
    by `Javah` using a specific name and parameter convention. The Dalvik VM can then
    load them at runtime by "guessing" their names. However, this convention is easy
    to break and has no runtime flexibility. Hopefully, JNI lets you manually register
    native methods that are going to be called from Java. And what better place than
    `JNI_OnLoad()` to do that?
  prefs: []
  type: TYPE_NORMAL
- en: 'Registration is performed with the following JNI method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '`jclass` is a reference to the Java class hosting the native method. We will
    see more about it through this chapter and the next one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`methods` is an array of `JNINativeMethod`, a structure describing the native
    methods to register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nMethods` indicates how many methods are described inside the `methods` array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `JNINativeMethod` structure is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The first and second elements are `name` and `signature` of the corresponding
    Java method, and the third parameter `fnPtr`, is a pointer to the corresponding
    method on the native side. That way, you can get rid of `javah` and its annoying
    naming convention and choose at runtime which method to call.
  prefs: []
  type: TYPE_NORMAL
- en: JNI in C versus JNI in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The NDK allows writing applications in either C (like our `LiveCamera` example)
    or C++ (like our `Store` example). So does JNI.
  prefs: []
  type: TYPE_NORMAL
- en: 'C is not an object-oriented language but C++ is. This is why you do not write
    JNI in C like in C++. In C, `JNIEnv` is in fact a structure containing function
    pointers. Of course, when `JNIEnv` is given to you, all these pointers are initialized
    so that you can call them a bit like an object. However, this parameter, which
    is implicit in an object-oriented language, is given as the first parameter in
    C (`env` in the following code). Also, `JNIEnv` needs to be dereferenced the first
    time to run a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The C++ code is more natural and simple. This parameter is implicit, and there
    is no need to dereference `JNIEnv`, as methods are not declared as function pointers
    anymore, but as real member methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Thus, despite being really similar, you do not write JNI code in C in exactly
    the same way you write it in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to JNI, Java and C/C++ can be tightly integrated together. Android is
    now fully bilingual! Java can call C/C++ code with any type of data or object,
    and native code can call Java back.
  prefs: []
  type: TYPE_NORMAL
- en: We also discovered how to call Java code from native code with the JNI Reflection
    API. Practically any Java operation can be performed from native code thanks to
    it. However, for best performance, class, method, or field descriptors must be
    cached.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how to attach and detach a thread to the VM and synchronize Java
    and native threads together with JNI monitors. Multithreaded code is probably
    one of the most difficult subjects in programming. Do it with care!
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we also natively processed bitmaps thanks to JNI, and decoded a video
    feed by hand. However, an expensive conversion is needed from the default YUV
    format (which should be supported on every device according to Android specifications)
    to RGB.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with native code on Android, JNI is almost always in the way. It
    is a verbose and very technical API, not to mention cumbersome, which requires
    care. Its subtleties would require a whole book for an in-depth understanding.
    Instead, this chapter has given you the essential knowledge to integrate your
    own C/C++ module in your own Java application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to create a fully native application, which
    completely gets rid of JNI.
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 7. Playing Sound with OpenSL ES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Multimedia is not only about graphics, it is also about sound and music. Applications
    in this domain are among the most popular in the Android market. Indeed, music
    has always been a strong engine for mobile device sales and music lovers are a
    target of choice. This is why an OS like Android could probably not go far without
    some musical talent! Open Sound Library for Embedded Systems, more frequently
    called OpenSL ES, is the pendant of OpenGL for sound. Although rather low-levewl,
    it is a first-class API for all sound-related tasks, either input or output.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When talking about sound on Android, we should distinguish Java from the native
    world. Indeed, both sides feature completely different APIs: **MediaPlayer**,
    **SoundPool**, **AudioTrack**, and **JetPlayer** on one hand, and **OpenSL ES**
    on the other hand:'
  prefs: []
  type: TYPE_NORMAL
- en: MediaPlayer is more high level and easy to use. It handles not only music but
    also video. It is the way to go when a simple file playback is sufficient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SoundPool and AudioTrack are more low level and closer to low latency when playing
    sound. AudioTrack is the most flexible but also complex to use. It allows sound
    buffer modifications on the fly (by hand!).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JetPlayer is more dedicated to the playback of MIDI files. This API can be interesting
    for dynamic musing synthesis in a multimedia application or game (see the JetBoy
    example provided with Android SDK).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenSL ES aims at offering a cross-platform API to manage audio on embedded
    systems; in other words, the OpenGL ES for audio. Like GLES, its specification
    is led by the Khronos group. On Android, OpenSL ES is in fact implemented on top
    of the AudioTrack API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenSL ES was first released on Android 2.3 Gingerbread and was not available
    in previous releases (Android 2.2 and lower). While there is a profusion of APIs
    in Java, OpenSL ES is the only one provided on the native side and is exclusively
    available on it.
  prefs: []
  type: TYPE_NORMAL
- en: However, OpenSL ES is still immature. The OpenSL specification is still incompletely
    supported and several limitations shall be expected. In addition, the OpenSL specification
    is implemented in its version 1.0.1 on Android, although version 1.1 is already
    out. Thus, some breaking changes can be expected in the future since the OpenSL
    ES implementation is still evolving.
  prefs: []
  type: TYPE_NORMAL
- en: 3D Audio features are available through OpenSL ES only for devices whose system
    is compiled with the appropriate profile. Indeed, the current OpenSL ES specification
    provides three different profiles, Game, Music, and Phone for different types
    of devices. At the time this book is written, none of these profiles are supported.
  prefs: []
  type: TYPE_NORMAL
- en: However, OpenSL ES has qualities. First, it may be easier to integrate in the
    architecture of a native application, since it is itself written in C/C++. It
    does not have to carry a garbage collector on its back. Native code is not interpreted
    and can be optimized in-depth through assembly code. These are some of the many
    reasons to consider it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is an introduction to the musical capabilities of OpenSL ES on
    the Android NDK. We are about to discover how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize OpenSL ES on Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play background music
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play sounds with a sound buffer queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Record sounds and play them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audio and, more specifically, real-time audio is a highly technical subject.
    This chapter covers the basics to embed sound and music in your own applications.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing OpenSL ES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenSL will not be very useful if we do not initialize it first. As usual, this
    step requires some boilerplate code. The verbosity of OpenSL does not improve
    the situation. Let's start this chapter by creating a new `SoundManager` to wrap
    OpenSL ES-related logic.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `DroidBlaster_Part10`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating OpenSL ES engine and output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a new manager dedicated to sounds:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file `jni/SoundManager.hpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, include the OpenSL ES standard header `SLES/OpenSLES.h`. The two latter
    define objects and methods and are specifically created for Android. Then, create
    the `SoundManager` class to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize OpenSL ES with the `start()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop the sound and release OpenSL ES with the `stop()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two main kinds of pseudo-object structures (that is, containing function
    pointers applied on the structure itself, such as a C++ object with this) in OpenSL
    ES:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Objects**: These are represented by `SLObjectItf`, which provides a few common
    methods to get allocated resources and object interfaces. This could be roughly
    compared to an object in Java.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interfaces**: These give access to object features. There can be several
    interfaces for an object. Depending on the host device, some interfaces may or
    may not be available. These are very roughly comparable to interfaces in Java.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `SoundManager`, declare two `SLObjectItf` instances, one for the OpenSL
    ES engine and an other for the speakers. Engines are available through a `SLEngineItf`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `SoundManager` in `jni/SoundManager.cpp` with its constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the method `start()`, which is going to create an OpenSL Engine object
    and an `Output Mix` object. We need three variables per object to initialize:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number of interfaces to support for each object (`engineMixIIDCount` and
    `outputMixIIDCount`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array of all the interfaces objects should support (`engineMixIIDs` and `outputMixIIDs`),
    for example `SL_IID_ENGINE` for the engine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array of Boolean values to indicate whether the interface is required or
    optional for the program (`engineMixReqs` and `outputMixReqs`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue the method `start()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the OpenSL ES engine object (that is, the basic type `SLObjectItf`)
    with the `slCreateEngine()` method. When we create an OpenSL ES object, the specific
    interfaces we are going to use have to be indicated. Here, we request the `SL_IID_ENGINE`
    interface, which allows creating other OpenSL ES objects. The engine is the central
    object of the OpenSL ES API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, invoke `Realize()` on the engine object. Any OpenSL ES object needs to
    be *realized* to allocate the required internal resources before use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, retrieve `SLEngineItf`-specific interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The engine interface gives us the possibility to instantiate an audio output
    mix with the `CreateOutputMix()` method. The audio output mix defined here delivers
    sound to the default speakers. It is autonomous (the played sound is sent automatically
    to the speaker), so there is no need to request any specific interface here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the `stop()` method to destroy what has been created in `start()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit `jni/DroidBlaster.hpp` and embed our new `SoundManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create, start, and stop the sound service in `jni/DroidBlaster.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, link to `libOpenSLES.so` in the `jni/Android.mk` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Run the application and check that no error is logged. We initialized the OpenSL
    ES library, which gives us access to efficient sound handling primitives directly
    from the native code. The current code does not perform anything apart from initialization.
    No sound comes out of the speakers yet.
  prefs: []
  type: TYPE_NORMAL
- en: The entry point to OpenSL ES here is `SLEngineItf`, which is mainly an OpenSL
    ES object factory. It can create a channel to an output device (a speaker or anything
    else), as well as sound players or recorders (and even more!), as we will see
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `SLOutputMixItf` is the object representing the audio output. Generally,
    this will be the device speaker or headset. Although the OpenSL ES specification
    allows enumerating the available output (and also input) devices, NDK implementation
    is not mature enough to obtain or select a proper one (`SLAudioIODeviceCapabilitiesItf`,
    the official interface to obtain such information). So, when dealing with output
    and input device selection (only input device for recorders needs to be specified
    currently), it is preferable to stick to default values, `SL_DEFAULTDEVICEID_AUDIOINPUT`
    and `SL_DEFAULTDEVICEID_AUDIOOUTPUT` defined in `SLES/OpenSLES.h`.
  prefs: []
  type: TYPE_NORMAL
- en: The current Android NDK implementation allows only one engine per application
    (this should not be an issue) and, at most, 32 created objects. Beware, however,
    that the creation of any object can fail, as this is dependent on the available
    system resources.
  prefs: []
  type: TYPE_NORMAL
- en: More on OpenSL ES philosophy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OpenSL ES is different from its graphics compatriot GLES, partly because it
    does not have a long history to carry. It is constructed on (more or less) an
    object-oriented principle based on objects and interfaces. The following definitions
    come from the official specification:'
  prefs: []
  type: TYPE_NORMAL
- en: An **object** is an abstraction of a set of resources, assigned for a well-defined
    set of tasks, and the state of these resources. An object has a type determined
    on its creation. The object type determines the set of tasks that an object can
    perform. This can be considered similar to a class in C++.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **interface** is an abstraction of a set of related features that a certain
    object provides. An interface includes a set of methods, which are functions of
    the interface. An interface also has a type, which determines the exact set of
    methods of the interface. We can define the interface itself as a combination
    of its type and the object to which it is related.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **interface ID** identifies an interface type. This identifier is used within
    the source code to refer to the interface type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An OpenSL ES object is set up in a few steps as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating it through a build method (which usually belongs to the engine).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Realizing it to allocate the necessary resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieving object interfaces. A basic object only has a very limited set of
    operations (`Realize()`, `Resume()`, `Destroy()`, and so on). Interfaces give
    access to real object features and describes what operations can be performed
    on an object, for example, a `Play` interface to play or pause a sound.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Any interfaces can be requested but only the one supported by the object is
    going to be successfully retrieved. You cannot retrieve the record interface for
    an audio player because it returns (sometimes annoyingly!) `SL_RESULT_FEATURE_UNSUPPORTED`
    (error code 12). In technical terms, an OpenSL ES interface is a structure containing
    function pointers (initialized by the OpenSL ES implementation) with a self-parameter
    to simulate C++ objects and `this`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Realize()`, `Resume()`, and so on are object methods that can be applied
    on an `SLObjectItf` object. The approach is identical for interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: For more detailed information on what OpenSL ES can provide, refer to the specification
    on the Khronos website [http://www.khronos.org/opensles](http://www.khronos.org/opensles),
    as well as the OpenSL ES documentation in the Android NDK docs directory. Android
    implementation does not fully respect the specification, at least for now. So,
    do not be disappointed when discovering that only a limited subset of the specification
    (especially sample codes) works on Android.
  prefs: []
  type: TYPE_NORMAL
- en: Playing music files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenSL ES is initialized, but the only thing coming out of speakers is silence!
    So what about finding a nice piece of **Background Music** (**BGM**) and playing
    it natively with Android NDK? OpenSL ES provides the necessary stuff to read music
    files such as MP3 files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `DroidBlaster_Part11`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – playing background music
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s open and play an MP3 music file with OpenSL ES:'
  prefs: []
  type: TYPE_NORMAL
- en: 'MP3 files are opened by OpenSL using a POSIX file descriptor pointing to the
    chosen file. Improve `jni/ResourceManager.cpp` created in the previous chapters
    by defining a new structure `ResourceDescriptor` and appending a new method `descriptor()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `jni/ResourceManager.cpp`. Of course, makes use of the asset manager
    API to open the descriptor and fill a `ResourceDescriptor` structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Go back to `jni/SoundManager.hpp` and define two methods `playBGM()` and `stopBGM()`
    to play/stop a background MP3 file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare an OpenSL ES object for the music player, along with the following
    interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SLPlayItf` plays and stops music files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SLSeekItf` controls position and looping'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Start implementing `jni/SoundManager.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include `Resource.hpp` to get access to asset file descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize new members in the constructor and update `stop()` to stop the background
    music automatically (or some users are not going to be happy!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Implement `playBGM()` to enrich the manager with playback features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, describe our audio setup through two main structures, `SLDataSource`
    and `SLDataSink`. The first describes the audio input channel and the second,
    the audio output channel.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we configure the data source as a MIME source so that the file type gets
    detected automatically from the file descriptor. The file descriptor is, of course,
    opened with a call to `ResourceManager::descriptor()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data sink (that is, the destination channel) is configured with the `OutputMix`
    object created in the first part of this chapter while initializing the OpenSL
    ES engine (and refers to the default audio output, that is, speakers or headset):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create the OpenSL ES audio player. As always, with OpenSL ES objects,
    instantiate it through the engine first and then realize it. Two interfaces, `SL_IID_PLAY`
    and `SL_IID_SEEK`, are imperatively required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Finally, using the `play` and `seek` interfaces, switch the playback in loop
    mode (that is, the music keeps playing) from the track's beginning (that is, `0`
    milliseconds) until its end (`SL_TIME_UNKNOWN`), and then start playing (`SetPlayState()`
    with `SL_PLAYSTATE_PLAYING`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Terminate with the last method `stopBGM()` to stop and destroy the player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a resource pointing to the music file in `jni/DroidBlaster.hpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in `jni/DroidBlaster.cpp`, start playing the music right after `SoundManager`
    is started:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Copy an MP3 file into the `droidblaster`'s `assets` directory and name it `bgm.mp3`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The BGM file is provided with this book in the `DroidBlaster_Part11/assets`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We discovered how to play a music clip from an MP3 file. Playback loops until
    the game is terminated. When using a MIME data source, the file type is auto-detected.
    Several formats are currently supported in Gingerbread, including Wave PCM, Wave
    alaw, Wave ulaw, MP3, Ogg Vorbis, and so on. The MIDI playback is currently not
    supported. Have a look at `$ANDROID_NDK/docs/opensles/index.html` for more information.
  prefs: []
  type: TYPE_NORMAL
- en: The way the sample code is presented here is typical of how OpenSL ES works.
    The OpenSL ES engine object, which is basically an object factory, creates an
    `AudioPlayer`. In its raw state, this object cannot do much. First, it needs to
    be realized to allocate the necessary resources. However, that is not enough.
    It needs to retrieve the right interfaces, like the `SL_IID_PLAY` interface to
    change the audio player state to playing/stopped. Then, the OpenSL API can be
    effectively used.
  prefs: []
  type: TYPE_NORMAL
- en: That is quite some work, taking into account result verification (as any call
    is susceptible to fail), which kind of clutters the code. Getting inside this
    API can take a little bit more time than usual, but once understood, these concepts
    become rather easy to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: You may be surprised to see that `startBGM()` and `stopBGM()` recreates and
    destroys the audio player respectively. The reason is that there is currently
    no way to change an MIME data source without completely recreating the OpenSL
    ES `AudioPlayer` object. So, although this technique is fine to play a long clip,
    it is not suitable to play a short sound dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Playing sounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The technique presented to play BGM from a MIME source is very practical but,
    sadly, not flexible enough. Recreating an `AudioPlayer` object is not necessary
    and accessing asset files each time is not good in terms of efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: So, when it comes to playing sounds quickly in response to an event and generating
    them dynamically, we need to use a sound buffer queue. Each sound is preloaded
    or generated in a memory buffer, and placed into a queue when the playback is
    requested. No need to access a file at runtime!
  prefs: []
  type: TYPE_NORMAL
- en: A sound buffer, in the current OpenSL ES Android implementation, can contain
    PCM data. **Pulse Code Modulation** (**PCM**) is a data format dedicated to the
    representation of digital sounds. It is the format used in CD and in some Wave
    files. A PCM can be Mono (the same sound on all speakers) or Stereo (different
    sounds for left and right speakers if available).
  prefs: []
  type: TYPE_NORMAL
- en: 'PCM is not compressed and is not efficient in terms of storage (just compare
    a musical CD with a data CD full of MP3). However, this format is lossless and
    offers the best quality. Quality depends on the sampling rate: analog sounds are
    represented digitally as a series of measure (that is, `sample`) of the sound
    signal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A sound sample at 44100 Hz (that is 44100 measures per second) has better quality
    but also takes place more than a sound sampled at 16000 Hz. Also, each measure
    can be represented with a more or less fine degree of precision (the encoding).
    On current Android implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Sounds can use 8000 Hz, 11025 Hz, 12000 Hz, 16000 Hz, 22050 Hz, 24000 Hz, 32000
    Hz, 44100 Hz, or 48000 Hz sampling,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Samples can be encoded on 8-bit unsigned or 16-bit signed (finer precision)
    in **little-endian** or **big-endian**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following step-by-step tutorial, we will use a raw PCM file encoded over
    16-bit in little-endian.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `DroidBlaster_Part12`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating and playing a sound buffer queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use OpenSL ES to play an explosion sound stored in a memory buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `jni/Resource.hpp` again to add a new method `getLength()`, which provides
    the size in bytes of an `asset` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement this method in `jni/Resource.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Create `jni/Sound.hpp` to manage a sound buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a method `load()` to load a PCM file and `unload()` to release it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, define the appropriate getters. Hold the raw sound data in a buffer along
    with its size. The sound is loaded from a `Resource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Sound loading implementation done in `jni/Sound.cpp` is quite simple; it creates
    a buffer with the same size as the PCM file and loads all the raw file content
    in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `jni/SoundQueue.hpp` to encapsulate the creation of a player object
    and its queue. Create three methods to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the `queue` when the application starts to allocate OpenSL resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finalize the `queue` to release OpenSL resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play a sound buffer of a predefined length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A sound queue can be manipulated through the `SLPlayItf` and `SLBufferQueueItf`
    interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `jni/SoundQueue.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Write `initialize()`, beginning with `SLDataSource` and `SLDataSink` to describe
    the input and output channel. Use a `SLDataFormat_PCM` data format (instead of
    `SLDataFormat_MIME`), which includes sampling, encoding, and endianness information.
    Sounds need to be mono (that is, only one sound channel for both left and right
    speakers when available). The queue is created with the Android-specific extension
    `SLDataLocator_AndroidSimpleBufferQueue()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create and realize the sound player. We are going to need its `SL_IID_PLAY`
    and `SL_IID_BUFFERQUEUE` interface, available thanks to the data locator configured
    in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, start the queue by setting it in the playing state. This does not
    actually mean that a sound is played. The queue is empty so that would not be
    possible. However, if a sound gets enqueued, it is automatically played:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'OpenSL ES objects need to be released when we no longer need them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, write `playSound()`, which first stops any sound being played and
    then enqueue the new sound buffer to be played. This is the simplest strategy
    to play a sound immediately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Open `jni/SoundManager.hpp` and include the newly created headers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create two new methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`registerSound()` to load and manage a new sound buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playSound()` to send a sound buffer to the sound play queue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a `SoundQueue` array so that up to four sounds may be played simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sound buffers are stored in a fixed-size C++ array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the constructor in `jni/SoundManager.cpp` and create a new destructor
    to release resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `start()` to initialize the `SoundQueue` instances. Then, load sound
    resources registered with `registerSound()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finalize the `SoundQueue` instances when the application stops to release OpenSL
    ES resources. Also, release the sound buffers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Save and cache the sounds in `registerSound()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, write `playSound()`, which sends the buffer to play to a `SoundQueue`.
    Use a simple round-robin strategy to play several sounds simultaneously. Send
    each new sound to play next in the queue (which is more likely to be available).
    Obviously, this playing strategy is suboptimal for sounds of various lengths:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We will play a sound when the DroidBlaster ship collides with an asteroid. Since
    the collision is not yet managed (see [Chapter 10](ch10.html "Chapter 10. Intensive
    Computing with RenderScript"), *Intensive Computing with RenderScript* for collision
    handling with **Box2D**), we will simply play a sound when the ship is initialized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To do so, in `jni/Ship.hpp`, retrieve a reference to `SoundManager` in the
    constructor and a collision sound buffer to play in `registerShip()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `jni/Ship.cpp`, after having stored all the necessary references,
    play the sound when the ship is initialized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In `jni/DroidBlaster.hpp`, define a reference to a file, which contains a collision
    sound:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in `jni/DroidBlaster.cpp`, register the new sound and pass it to the
    `Ship` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We discovered how to preload sounds in a buffer and play them as needed. What
    differentiates the sound playing technique from the BGM one seen earlier is the
    use of a buffer queue. A buffer queue is exactly what its name reveals: a **First
    In, First Out** (**FIFO**) collection of sound buffers played one after the other.
    Buffers are enqueued for playback when all the previous buffers are played.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Buffers can be recycled. This technique is essential in combination with streaming
    files: two or more buffers are filled and sent to the queue. When the first buffer
    has finished playing, the second one starts while the first buffer is filled with
    new data. As soon as possible, the first buffer is enqueued before the queue gets
    empty. This process repeats forever until the playback is over. In addition, buffers
    are raw data and can thus be processed or filtered on the fly.'
  prefs: []
  type: TYPE_NORMAL
- en: In the present tutorial, because `DroidBlaster` does not need to play more than
    one sound at once and no form of streaming is necessary, the buffer queue size
    is simply set to one buffer (step 7, `dataLocatorIn.numBuffers = 1;`). In addition,
    we want new sounds to pre-empt older ones, which explains why the queue is systematically
    cleared. Your OpenSL ES architecture should, of course, be adapted to your needs.
    If it becomes necessary to play several sounds simultaneously, several audio players
    (and therefore buffer queues) should be created.
  prefs: []
  type: TYPE_NORMAL
- en: Sound buffers are stored in the PCM format, which does not self-describe its
    internal format. Sampling, encoding, and other format information needs to be
    selected in the application code. Although this is fine for most of them, a solution,
    if that is not flexible enough, can be to load a Wave file, which contains all
    the necessary header information.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A great open source tool to filter and sequence sounds is **Audacity**. It allows
    altering the sampling rate and modifying channels (Mono/Stereo). Audacity is able
    to export as well as import sound as raw PCM data.
  prefs: []
  type: TYPE_NORMAL
- en: Using callbacks to detect sound queue events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to detect when a sound has finished playing using callbacks.
    A callback can be set up by calling the `RegisterCallback()` method on a queue
    (but other types of objects can also register callbacks). For example, the callback
    can receive this, that is, a `SoundManager` self-reference, to allow processing
    with any contextual information if needed. Although this is facultative, an event
    mask is set up to ensure that the callback is called only when the `SL_PLAYEVENT_HEADATEND`
    (player has finished playing the buffer) event is triggered. A few others play
    events are available in `OpenSLES.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, when a buffer finishes playing, a message is logged. Operations such as,
    enqueuing a new buffer (to handle streaming for example) can be performed.
  prefs: []
  type: TYPE_NORMAL
- en: Low latency on Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Callbacks are like system interruptions or application events, their processing
    must be short and fast. If advanced processing is necessary, it should not be
    performed inside the callback but on another thread- native threads being perfect
    candidates.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, callbacks are emitted on a system thread, different than the one requesting
    OpenSL ES services (that is, the `NativeActivity` native thread in our case).
    Of course, with threads, arises the problem of thread-safety when accessing your
    own variables from the callback. Although protecting code with mutexes is tempting,
    they are not the best way to deal with real-time audio. Their effect on scheduling
    (**inversion of priority** issues for example) can cause glitches during playback.
  prefs: []
  type: TYPE_NORMAL
- en: So, prefer using thread-safe techniques, like a lock-free queue to communicate
    with callbacks. Lock-free techniques can be implemented using GCC built-in atomic
    functions such as `__sync_fetch_and_add()` (which does not require any include
    file). For more information about atomic operations with the Android NDK, have
    a look at, `${ANDROID_NDK}/docs/ANDROID-ATOMICS.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although proper lock-free code is essential to achieve low-latency on Android,
    another important point to consider is that not all Android platforms and devices
    are suited for it! Indeed, low latency support came quite late in Android, starting
    from OS Version 4.1/4.2\. If you are in the need for low latency, you can check
    its support with the following piece of Java code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: However, beware! Many devices, even with the latest system versions, cannot
    achieve low latencies because of driver issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you know that the target platform supports low-latency, take care of using
    the proper sampling rate and buffer size. Indeed, the Android audio system provides
    a "fast path", which does not apply any resampling, when using the optimal configuration.
    To do so, from API level 17 or higher, use `android.media.AudioManager.getProperty()`
    from the Java side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: For more information on this subject, have a look at the *High Performance*
    *Audio* talk at [https://developers.google.com/events/io/sessions/325993827](https://developers.google.com/events/io/sessions/325993827).
  prefs: []
  type: TYPE_NORMAL
- en: Recording sounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android devices are all about interactions. Interactions can come not only from
    touches and sensors, but also from audio input. Most Android devices provide a
    microphone to record sound and allow an application such as the Android desktop
    search to offer vocal features to record queries.
  prefs: []
  type: TYPE_NORMAL
- en: If the sound input is available, OpenSL ES gives native access to the sound
    recorder. It collaborates with a buffer queue to take data from the input device
    and fill an output sound buffer from it. The setup is pretty similar to what has
    been done with `AudioPlayer`, except that data source and data sink are permuted.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – recording and playing a sound
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To discover how recording works, record a sound when an application starts
    and play it when it has finished recording. Turning `SoundManager` into a recorder
    can be done in four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Using status `startSoundRecorder()` to initialize the sound recorder. Invoke
    it right after `startSoundPlayer()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With void `recordSound()`, start recording a sound buffer with device micro.
    Invoke this method at instances such as when the application is activated in `onActivate()`
    after the background music playback starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new callback static `void callback_recorder(SLAndroidSimpleBufferQueueItf,
    void*)` to be notified of the record queue events. You have to register this callback
    so that it is triggered when a recorder event happens. Here, we are interested
    in buffer full events, that is, when the sound recording is finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`void playRecordedSound()` to play a sound once recorded. Play it at instances
    such as when the sound has finished being recorded in `callback_recorder()`. This
    is not technically correct because of potential race conditions but is fine for
    an illustration.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `DroidBlaster_PartRecorder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going any further, recording requires a specific Android permission
    and, of course, an appropriate Android device (you would not like an application
    to record your secret conversations behind your back!). This authorization has
    to be requested in the Android manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Creating and releasing the recorder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sounds are recorded with a recorder object created from the OpenSL ES engine,
    as usual. The recorder offers two interesting interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SLRecordItf`: This interface is used to start and stop recording. The identifier
    is `SL_IID_RECORD`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SLAndroidSImpleBufferQueueItf`: This manages a sound queue for the recorder.
    This is an Android extension provided by NDK because the current OpenSL ES 1.0.1
    specification does not support recording to a queue. The identifier is `SL_IID_ANDROIDSIMPLEBUFFERQUEUE`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the recorder, you will need to declare your audio source and sink,
    similar to the following one. The data source is not a sound but a default recorder
    device (such as a microphone). On the other hand, the data sink (that is, the
    output channel) is not a speaker but a sound buffer in the PCM format (with the
    requested sampling, encoding, and endianness). The Android extension `SLDataLocator_AndroidSimpleBufferQueue`
    must be used to work with a recorder since the standard OpenSL buffer queues will
    not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When an application ends, do not forget to release the recorder object as all
    other OpenSL objects.
  prefs: []
  type: TYPE_NORMAL
- en: Recording a sound
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To record a sound, you need to create a sound buffer with an appropriate size
    according to the duration of your recording. You can adapt the `Sound` class to
    allow the creation of an empty buffer with a given size. The size depends on the
    sampling rate. For example, for a record of `2` seconds with a sampling rate of
    `44100` Hz and `16`-bit quality, the sound buffer size would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In `recordSound()`, first stop the recorder, thanks to `SLRecordItf`, to ensure
    it is not already recording. Then, clear the queue to ensure your record buffer
    is used immediately. Finally, you can enqueue a new buffer and start recording:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is perfectly possible to enqueue new sound buffers so that any current recording
    is processed to its end. This allows creating a continuous chain of recording
    or, in other words, streaming the recording. The sound being enqueued will be
    processed only once the previous is filled.
  prefs: []
  type: TYPE_NORMAL
- en: Recording a callback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You eventually need to know when your sound buffer has finished recording.
    To do so, register a callback triggered when a recorder event happens (for example,
    a buffer has been filled). An event mask should be set to ensure that callback
    is called only when a buffer has been filled (`SL_RECORDEVENT_BUFFER_FULL`). A
    few others are available in `OpenSLES.h`, but not all are supported (`SL_RECORDEVENT_HEADATLIMIT`,
    and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Finally, when `callback_recorder()` is triggered, stop recording and play the
    recorded buffer with `playRecordedSound()`. The recorded buffer needs to be enqueued
    in the audio player's queue for playback, as we did in the previous section. You
    can use a specific `SoundQueue` to play the sound for simplicity purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In summary, we saw in this chapter how to initialize OpenSL ES on Android. The
    engine object is the main entry point to manage all OpenSL objects. Objects in
    OpenSL follow a specific lifecycle of creation, realization, and destruction.
    Then, we saw how to play background music from an encoded file and in-memory sounds
    with a sound buffer queue. Finally, we discovered how to record and then play
    a sound in a way that is thread-safe and non-blocking.
  prefs: []
  type: TYPE_NORMAL
- en: Do you prefer OpenSL ES over Java APIs? If all you need is a nice high-level
    API, Java APIs may suit your requirements better. If you need finer playback or
    recording control, there is no significant difference between low-level Java APIs
    and OpenSL ES. In this case, the choice should be architectural. If your code
    is mainly Java, you should probably go with Java.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to reuse an existing sound-related library, optimize the performance,
    or perform intense computations, such as sound filtering on the fly, OpenSL ES
    is probably the right choice. OpenSL ES is also the way to go to low-latency,
    although Android is not quite there yet (fragmentations, device-specific issues,
    and so on). At the least, this verbose API is probably the one that is going to
    give the best performance. There is no garbage collector overhead and aggressive
    optimization is favored in the native code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever choice you make, know that the Android NDK has a lot more to offer.
    After dealing with [Chapter 6](ch06.html "Chapter 6. Rendering Graphics with OpenGL
    ES"), *Rendering Graphics with OpenGL ES* and [Chapter 7](ch07.html "Chapter 7. Playing
    Sound with OpenSL ES"), *Playing Sound with OpenSL ES*, the next chapter will
    take care of handling input natively: keyboard, touches, and sensors.'
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 9. Porting Existing Libraries to Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*There are two main reasons why one would be interested in the Android NDK:
    first, for performance, and, second, for portability. In the previous chapters,
    we saw how to access the main native Android APIs from native code for efficiency
    purposes. In this chapter, we will bring the whole C/C++ ecosystem to Android,
    well, at least discovering the path, as decades of C/C++ development would be
    difficult to fit the limited memory of mobile devices anyway! Indeed, C and C++
    are still some of the most widely used programming languages nowadays.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*In previous NDK releases, portability was limited due to the partial support
    of C++, especially **Exceptions** and **Run-Time Type** Information (**RTTI**,
    a basic C++ reflection mechanism to get data types at runtime such as `instanceof`
    in Java). Any library requiring them could not be ported without modifying their
    code or installing a custom NDK (the **Crystax NDK**, rebuilt by the community
    from official sources, and available at [http://www.crystax.net/](http://www.crystax.net/)).
    Hopefully, many of these restrictions have been lifted since (except wide character
    support).*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although not necessarily difficult, porting an existing library is not a trivial
    process. A few APIs might be missed (despite good POSIX support), some `#define`
    directives have to be tweaked, some dependencies have to be ported, as well as
    dependencies of dependencies. Some libraries will be easy to port, while some
    other will involve more effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, in order to port existing code to Android, we are going to
    learn how to do the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: Activate the **Standard Template Library** (**STL**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port the **Box2D** physics engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prebuild and use the **Boost** framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover more in-depth how to write NDK module **Makefiles**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should understand the native building process
    and know how to use Makefiles appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Activating the Standard Template Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Standard Template Library is a normalized library of containers, iterators,
    algorithms, and helper classes to ease most common programming operations, such
    as dynamic arrays, associative arrays, strings, sorting, and so on. This library
    gained recognition among developers over the years and is widely spread. Developing
    in C++ without the STL is like coding with one hand behind your back!
  prefs: []
  type: TYPE_NORMAL
- en: In this first part, let's embed GNU STL in DroidBlaster to ease collection management.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Resulting project is provided with this book under the name `DroidBlaster_Part16`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – activating GNU STL in DroidBlaster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s activate and make use of the STL in DroidBlaster. Edit the `jni/Application.mk`
    file beside `jni/Android.mk` and write the following content. That''s it! Your
    application is now STL-enabled, thanks to this single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In only a single line of code, we have activated GNU STL in the `Application.mk`
    file! This STL implementation, selected through the `APP_STL` variable, replaces
    the default NDK C/C++ runtime. The following three STL implementations are currently
    supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GNU STL** (more commonly **libstdc++**), the official GCC STL: This is often
    the preferred choice when using the STL on an NDK project. Exceptions and RTTI
    are supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**STLport** (a multiplatform STL): This implementation is not actively maintained
    and lacks some features. Choose it as a last resort. Exceptions and RTTI are supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Libc++**: This is part of LLVM (the technology behind the Clang compiler)
    and aims to provide a functional C++ 11 runtime. Note that this library is now
    becoming the default STL on OS-X and may gain popularity in the future. Exceptions
    and RTTI are supported. Libc++ support is still incomplete and experimental. Libc++
    is often chosen in conjunction with the Clang compiler (read more about this in
    the *Mastering module Makefiles* section).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Android also provides two other C++ runtimes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**System**: This is the default NDK runtime when no STL implementation is activated.
    Its code name is **Bionic** and it provides a minimalist set of headers (`cstdint`,
    `cstdio`, `cstring`, and so on). Bionic does not provide STL features, as well
    as exceptions and **run-time type information** (**RTTI**). For more details about
    its limitations, have a look at `$ANDROID_NDK/docs/system/libc/OVERVIEW.html`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gabi**: This is similar to the System runtime, except that it supports exceptions
    and RTTI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will see in the part dedicated to **Boost** in this chapter how to enable
    exceptions and RTTI during compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each runtime is linkable either statically or dynamically (at the notable exception
    of the default system C/C++ runtime). Dynamically loaded runtimes are posts fixed
    with `_shared`, and statically loaded ones with `_static`. The full list of runtime
    identifiers you can pass to `APP_STL` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`system`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gabi++_static` and `gabi++_shared`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stlport_static` and `stlport_shared`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gnustl_static` and `gnustl_shared`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c++_static` and `c++_shared`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that shared libraries need to be loaded manually at runtime. If you
    forget to load a shared library, an error is raised at runtime as soon as dependent
    libraries modules are loaded. As the compiler cannot predict in advance which
    functions are going to be called, libraries are loaded entirely in memory, even
    if most of their contents remain unused.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, static libraries are in fact loaded with dependent libraries.
    Indeed, static libraries do not really exist as such at runtime. Their content
    is copied into dependent libraries at compile time when they are linked. Since
    the linker knows precisely which part of the library gets called from the embedding
    module, it can strip its code and keep only what is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Stripping** is the process of discarding unnecessary symbols from binaries.
    This helps reducing (potentially a lot!) binary size after linkage. This can be
    somewhat compared to the Proguard shrinking post processing in Java.'
  prefs: []
  type: TYPE_NORMAL
- en: However, linking results in binary code duplication if a static library is included
    more than once. Such a situation can potentially lead to a waste of memory or,
    more worryingly, issues related to, for example, global variable duplication.
    However, static C++ constructors in shared libraries are called only once.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that you should avoid using static libraries that are included more
    than once in a project unless you know what you are doing.
  prefs: []
  type: TYPE_NORMAL
- en: Another point to consider is that Java applications can load shared libraries
    only, which can themselves be linked against either shared or static libraries.
    For example, the main library of `NativeActivity` is a shared library, specified
    through the `android.app.lib_name` manifest property. Shared libraries referenced
    from another library must be loaded manually before. The NDK does not do it itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shared libraries can be loaded easily, using `System.loadLibrary()` in a JNI
    applications, but `NativeActivity` are "transparent" activities. So, if you decide
    to use shared libraries, the only solution is to write your own Java activity,
    inheriting from `NativeActivity` and invoking the appropriate `loadLibrary()`
    directives. For instance, below is what DroidBlaster activity would look like,
    if we were using `gnustl_shared` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you prefer to load your native library directly from native code, you can
    use the system call `dlopen()`, which is also provided by the NDK.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the STL is enabled, let's employ it in DroidBlaster.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – read files with STL stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use the STL to read resources from the SD card instead of the application
    asset directory, as shown in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, enabling the STL is useless if we do not actively use it in our code.
    Let's take advantage of this opportunity to switch from asset files to external
    files (on a `sdcard` or internal memory).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the existing file, `jni/Resource.hpp`, and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Include the `fstream` and `string` STL headers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a `std::string` object for the file name and replace the Asset management
    members with an `std::ifstream` object (that is, an input file stream).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the `getPath()` method to return a C string from the new `string` member.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remove the `descriptor()` method and the `ResourceDescriptor` class (descriptors
    work with the Asset API only) , as shown in the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the corresponding implementation file `jni/Resource.cpp`. Replace the
    previous implementation, based on the asset management API with STL streams and
    strings. Files will be opened in binary mode, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To read the file length, we can use the `stat()` POSIX primitive from the `sys/stat.h`
    header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use STL string comparison operator to compare two `Resource`
    objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: These changes to the reading system should be almost transparent, except for
    the BGM, whose content was played through an asset file descriptor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we need to provide a real file. So, in `jni/SoundService.cpp`, change
    the data source by replacing the `SLDataLocator_AndroidFD` structure with `SLDataLocation_URI`,
    as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `AndroidManifest.xml` file, add the permission to read SD card files
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Copy all asset resources from the asset directory to your device SD card (or
    internal memory, depending on your device) in `/sdcard/droidblaster`.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how to access binary files located on the SD card with STL streams.
    We have also switched the OpenSL ES player from a file descriptor to a file name
    locator. The file name itself is created here from an STL string. STL strings
    are a real benefit as they allow us to get rid of complex C string manipulation
    primitives.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Almost all Android devices can store files in an additional storage location
    mounted in directory `/sdcard`. ""Almost"" is the important word here. Since the
    first Android G1, the meaning of ""sdcard"" has changed. Some recent devices have
    an external storage that is in fact internal (for example, flash memory on some
    tablets), and some others have a second storage location at their disposal (although
    in most cases, the second storage is mounted inside `/sdcard`). Moreover, the
    `/sdcard` path itself is not engraved into the marble. So, to detect safely the
    additional storage location, the only solution is to rely on JNI by calling `android.os.Environment.getExternalStorageDirectory()`.
    You can also check that storage is available with `getExternalStorageState()`.
    Note that the word ""External"" in API method name is here for historical reasons
    only. Also, the permission `WRITE_EXTERNAL_STORAGE` in manifest is required.
  prefs: []
  type: TYPE_NORMAL
- en: The STL provides much more features than Files and Strings. The most popular
    among them are probably STL containers. Let's see some usage examples in DroidBlaster.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – using STL containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now replace raw arrays with standard STL containers by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `jni/GraphicsManager.hpp` header and include the headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Vector`, which defines an STL container encapsulating C arrays (with a few
    more interesting features such as dynamic resizing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map`, which encapsulates the equivalent of a Java HashMap (that is, an associative
    array)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, remove the `textureResource` member in the `TextureProperties` structure.
    Use a `map` container instead of a raw array for `mTextures` (prefixed with the
    `std` namespace). The first parameter is the key type and the second the value
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, replace all the other raw arrays with a `vector`, as shown in the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit `jni/GraphicsManager.cpp` and initialize the new STL containers in the
    constructor initialization list as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `vector::push_back()` method to insert components into the `mComponents`
    list when they get registered, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In `start()`, we can iterate through the vector using an iterator to initialize
    each registered component, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In `stop()`, we can iterate through the map (with second representing entry''s
    value) and vector collections to release each allocated OpenGL resource this time,
    as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Also iterate over components stored to render them in `update()`, as shown
    in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Since textures are expensive resources, use the `map` to check if a texture
    has already been loaded before loading and caching a new instance, as shown in
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the defined `vector` objects to save shaders and vertex buffers. Use `push_back()`
    again to add an element to the vector, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, open `jni/SpriteBatch.hpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here again, include and use `vector` objects instead of raw arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In `jni/SpriteBatch.cpp`, replace the usage of raw arrays with vectors, as
    shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'During the loading and drawing process, loop over the `vector`. You can use
    an `iterator` (here in `load()`), as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, declare a `std::vector` in `jni/Asteroid.hpp` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the vector to insert and iterate over bodies in `jni/Asteroid.cpp`, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There has been a use of STL containers throughout the application to replace
    raw C arrays. For example, we have managed a set of `Asteroid` game objects inside
    an STL container vector instead of a raw C array. We have also replaced the texture
    cache using an STL map container. STL containers have many advantages, such as
    automatically handling memory management (array resizing operations and so on),
    to alleviate our burden.
  prefs: []
  type: TYPE_NORMAL
- en: STL is definitely a huge improvement that avoids repetitive and error-prone
    code. Many open source libraries require it and it can now be ported without much
    trouble. More documentation about it can be found at [http://www.cplusplus.com/reference/stl](http://www.cplusplus.com/reference/stl)
    and on SGI's website (publisher of the first STL) at [http://www.sgi.com/tech/stl](http://www.sgi.com/tech/stl).
  prefs: []
  type: TYPE_NORMAL
- en: 'When developing for performance, standard STL containers are not always the
    best choice, especially in terms of memory management and allocation. Indeed,
    STL is an all-purpose library, written for common cases. Alternative libraries
    might be considered for performance-critical code. A few examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EASTL**: This is an STL replacement developed by Electronic Arts with gaming
    in mind. An extract is available in the repository at [https://github.com/paulhodge/EASTL](https://github.com/paulhodge/EASTL).
    A must-read paper detailing EASTL technical details can be found on the Open Standards
    website at [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bitsquid Foundation library**: This is another STL replacement targeting
    games and can be found at [https://bitbucket.org/bitsquid/foundation/](https://bitbucket.org/bitsquid/foundation/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RDESTL**: This is an open source subset of the STL, based on the EASTL technical
    paper, which was published several years before EASTL code release. The code repository
    can be found at [http://code.google.com/p/rdestl/](http://code.google.com/p/rdestl/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google SparseHash**: This is for a high performance associative array library
    (note that RDESTL is also quite good at that).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is far from exhaustive. Just define your exact needs to make the most appropriate
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: STL is still the best choice for most applications or libraries. Before going
    away from it, profile your source code and make sure it is really necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Porting Box2D to Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the STL in our basket, we are ready to port almost any library to Android.
    Actually, many third-party libraries are already ported and many more are coming.
    However, when nothing is available, you have to rely on our own skills.
  prefs: []
  type: TYPE_NORMAL
- en: To see how to handle this situation, we are now going to port Box2D with the
    NDK. Box2D is a highly popular physics simulation engine initiated by Erin Catto
    in 2006\. Many 2D games, either amateur or professional like Angry Birds, embed
    this powerful open source library. It is available in several languages, including
    Java, though its primary language is C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Box2D is an answer to the complex subject, that is, physics simulation. Maths,
    numerical integration, software optimization, and so on are some of the multiple
    techniques applied to simulate rigid body movements and collisions in a 2D environment.
    Bodies are the essential element of Box2D and are characterized by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A geometrical **shape** (polygons, circles, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physics properties (such as **density**, **friction**, **restitution**, and
    so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Movement **constraints** and **joints** (to link bodies together and restrict
    their movement)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these bodies are orchestrated inside a *World* that steps simulation according
    to time.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that you know the very basics of Box2D, let's port and integrate it
    in DroidBlaster to simulate collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Resulting project is provided with this book under the name `DroidBlaster_Part17`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – compiling Box2D on Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s port Box2D on the Android NDK following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Box2D 2.3.1 archive is provided with this book in directory `Libraries/box2d`.
  prefs: []
  type: TYPE_NORMAL
- en: Unzip Box2D source archive (2.3.1 in this book) into `${ANDROID_NDK}/sources/`
    (beware directory must be named `box2d`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and open an `Android.mk` file in the root of the `box2d` directory.
  prefs: []
  type: TYPE_NORMAL
- en: First, save the current directory inside the `LOCAL_PATH` variable. This step
    is always necessary because an NDK build system may switch to another directory
    at any time during compilation.
  prefs: []
  type: TYPE_NORMAL
- en: After this, list all Box2D source files to compile, as shown in the following.
    We are interested in source file name only, which can be found in `${ANDROID_NDK}/sources/box2d/Box2D/Box2D`.
    Use the `LS_CPP` helper function to avoid copying each filename.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, write the Box2D module definition for a static library. First, call the
    `$(CLEAR_VARS)` script. This script has to be included before any module definition
    to remove any potential change made by other modules, and to avoid any unwanted
    side effects. Then, define the following settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Module name in `LOCAL_MODULE`: The module name is suffixed with _static to
    avoid a name collision with the shared version we are going to define right after.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module source files in `LOCAL_SRC_FILES` (using `BOX2D_CPP` defined previously).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Header file directory exported to client modules in `LOCAL_EXPORT_C_INCLUDES`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Header file used internally for module compilation in `LOCAL_C_INCLUDES`. Here,
    the headers used for Box2D compilation and the headers needed for the client module
    are the same (and are often the same in other libraries). So, reuse `LOCAL_EXPORT_C_INCLUDES`,
    as defined previously, in the following way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Android.mk` archive is provided in the `Libraries/box2d` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open DroidBlaster `Android.mk` and link against `box2d_static` by appending
    it to `LOCAL_STATIC_LIBRARIES`. Indicate which `Android.mk` module file to include
    with the `import-module` directive. Remember that modules are found, thanks to
    the `NDK_MODULE_PATH` variable, which points by default to `${ANDROID_NDK}/sources`,
    as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Optionally, activate include file resolution in Eclipse if you see warnings
    about Box2D including files. To do so, in Eclipse **Project properties**, navigate
    to **the C/C++ General/Paths and Symbols** section and then the **Includes** tab,
    and add the Box2d directory `${env_var:ANDROID_NDK}/sources/box2d`.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Launch the DroidBlaster compilation. Box2D is compiled without errors. We have
    ported our second open source library (after `libpng`) to Android thanks to the
    NDK! We can finally reuse one of the many wheels already created by the community!
    Porting a native library to Android involves mainly writing an `Android.mk` module
    makefile to describe source files, dependencies, compilation flags, and so on,
    as we have done until now for our main module DroidBlaster.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen some of the most essential variables to use in a module, and they
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LOCAL_MODULE`: This declares a unique module name where the final library
    name depends on its value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_SRC_FILES`: This lists all the files to compile relative to the module''s
    root'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_C_INCLUDES`: This defines `include` file directories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_EXPORT_C_INCLUDES`: This defines `include` file directories but for
    including modules this time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The order to build Box2D module build is given by one of the following directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BUILD_STATIC_LIBRARY`: This compiles the module as a static library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BUILD_SHARED_LIBRARY`: This also compiles the module but as a shared library
    this time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A module can be compiled as a static or shared library in the same way as the
    STL. Compilation is performed dynamically (that is, on-demand) each time a client
    application imports the module or changes its compilation settings. Hopefully,
    the NDK is able to compile sources incrementally.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create a module for a header only library, such as parts of Boost or GLM
    (a library for OpenGL ES matrix calculations), define a module without `LOCAL_SRC_FILES`
    defined. Only `LOCAL_MODULE` and `LOCAL_EXPORT_C_INCLUDES` are necessary.
  prefs: []
  type: TYPE_NORMAL
- en: From the client `Android.mk` perspective (that is `the DroidBlaster` makefile
    in our case), the NDK `import-module` directive triggers, roughly speaking, include
    sub-module `Android.mk` files. Without it, the NDK will not be able to discover
    dependent modules, compile them, and include their headers. All the modules, the
    main module as well as the sub-modules, are produced in `<PROJECT_DIR>/libs`,
    and intermediate binary files are in `<PROJECT_DIR>/obj` for the main application
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `import-module` directive should be located at the end of the file to avoid
    altering module definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the three ways to link against "sub-module" libraries in
    the main `Android.mk` Makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: Static libraries must be listed in the `LOCAL_STATIC_LIBRARIES` variable (as
    we have done for Box2D)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared libraries need to be listed in the `LOCAL_SHARED_LIBRARIES` variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared system libraries should be listed in `LOCAL_LDLIBS` (as we have done
    for OpenGL ES, for example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information about Makefiles, see the *Mastering module Makefiles* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing a Makefile is an important part of the porting process. However, it
    is not always sufficient. Porting a library can be slightly more involved, depending
    on its originating platforms. For example, a piece code already ported to iOS
    is often easier to port to Android. In more complex cases, it may become necessary
    to patch code to make it behave properly on Android. When you are condemned to
    such a hard and non-trivial task, which is honestly quite frequent, always consider
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure required libraries exist, and port them first if not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look for the main configuration header file if one is provided with your library
    (as this is often the case). It is a good place to tweak enabled or disabled features,
    remove unwanted dependencies, or define new Macros.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give attention to system-related macros (that is, `#ifdef _LINUX` ...), which
    are one of the first places to look for changes to make in the code. Generally,
    one will need to define macros, such as `_ANDROID_`, and insert them where appropriate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comment non-essential code to check if the library can compile and if its core
    features can possibly work. Indeed, do not bother fixing everything if you are
    unsure yet whether it will work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hopefully, Box2D was not tight to a specific platform, as it relies mainly on
    pure C/C++ computation and not on external APIs. In such cases, porting code becomes
    much easier. Now that Box2D is compiled, let's run it in our own code.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – running Box2D physics engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s rewrite the DroidBlaster physics engine with Box2D with the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `jni/PhysicsManager.hpp` header and insert the Box2D `include` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a constant `PHYSICS_SCALE` to convert the body position from physics
    to game coordinates. Indeed, Box2D uses its own scale for a better precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, replace `PhysicsBody` with a new structure, `PhysicsCollision`, that
    will indicate which bodies entered in collision, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Then, make `PhysicsManager` inherit from `b2ContactListener`. A contact listener
    gets notified about new collisions each time the simulation is updated. Our `PhysicsManager`
    inherits one of its method's named `BeginContact()`, used to react to collisions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will need three more methods, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loadBody()` to create a new entity within the physics engine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loadTarget()` to create an entity that moves toward a target (our spaceship)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start()` to initialize the engine when the game starts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, define member variables, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mWorld` represents the whole Box2D simulation which contains all the bodies
    we are going to create'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mBodies` is the list of all the physics entities we have registered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mLocations` contains a copy of the `b2Body` position in game coordinates (instead
    of physics coordinates which have a different scale)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mBoundsBodyObj` defines the boundaries in which our space ship will be able
    to move'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Implement `jni/PhysicsManager.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iteration constants determine the simulation accuracy. Here, Box2D is going
    to handle mainly collisions and simple movements. So, fixing velocity and position
    iterations to `6` and `2`, respectively, is sufficient (more about their meaning
    a bit later).
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the new `PhysicsManager` members and let it listen to collision
    events with `SetContactListener()` on the `mWorld` object, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize Box2D world boundaries when the game starts. These boundaries match
    the display window size converted into *physics system coordinates*. Indeed, the
    physics system uses its own predefined scale to preserve float-point value accuracy.
    We need four edges to define these boundaries, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Initialize and register asteroid or ship physics bodies in `loadBody()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The body definition describes a dynamic body (as opposed to static), awake (that
    is, actively simulated by Box2D), and which cannot rotate (a property especially
    important for polygon shapes, meaning that it is always pointing upward).
  prefs: []
  type: TYPE_NORMAL
- en: Also note how we save a `PhysicsCollision` self-reference in the `userData`
    field, in order to access it later inside Box2D callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the body shape, which we approximate to a circle. Note that Box2D requires
    a half dimension, from the object''s center to its borders, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Body fixture is the "glue" that ties together body definition, shape, and physical
    properties. We also use it to set the body's category and mask, and to filter
    collisions between objects (for instance, asteroids can collide with the ship
    but not between themselves in DroidBlaster). One bit represents one category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, effectively instantiate your `body` inside the Box2D physical world,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `loadTarget()` method that creates a Box2D mouse joint to simulate
    spaceship movements. Such a `Joint` defines an empty target toward which the body
    (here specified in parameter) moves, like a kind of elastic. The settings used
    here (`maxForce`, `dampingRatio`, and `frequencyHz`) control how the ship reacts
    and can be determined by tweaking them, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Write the `update()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, clear any collision flag buffered in `BeginContact()` during previous
    iteration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, perform simulation by calling `Step()`. The time period specifies how
    much time must be simulated. Iterations constants determine simulation accuracy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, loop over all of the physics bodies to extract their coordinates,
    convert them from Box2D to game coordinates, and store the result into our own
    `Location` object, as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finish with the `BeginContact()` method inherited by `b2ContactListener`. This
    callback notifies new collisions between bodies, two at a time (named `A` and
    `B`). Event information is stored in a `b2contact` structure, which contains various
    properties, such as friction, restitution, and the two bodies, involved through
    their fixture. These fixtures contain in themselves a reference to our own `PhysicsCollision`.
    We can use the following link to switch the `PhysicsCollision` collision flag
    when Box2D detects one contact:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In `jni/Asteroid.hpp`, replace the usage of `PhysicsBody` with Box2D `b2Body`
    structure, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In `jni/Asteroid.cpp`, scale constants and boundaries to the physics coordinate
    system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, update the way an asteroid body is registered. Register physics properties
    with a category and mask. Here, asteroids are declared as belonging to category
    1 (`0X1` in hexadecimal notation), and only bodies in group 2 (`0X2` in hexadecimal)
    are considered when evaluating collisions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace and update the remaining code to accommodate the use of the new `b2Body`
    structure instead of the `PhysicsBody` one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, also update `spawn()` code to initialize the `PhysicsBody`, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Open `jni/Ship.hpp` to turn it into a Box2D body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new `b2Body` parameter to the `registerShip()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, define the following two additional methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`update()`, which contains some new game logic to destroy the ship when it
    collides with asteroids'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isDestroyed()` to indicate if the ship has been destroyed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Declare the following necessary variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mBody` to manage the ship representation in Box2D'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mDestroyed` and `mLives` for the game logic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Declare a few new constants in `jni/Ship.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, initialize the new member variables properly. Note that you don''t need
    to play the collision sound anymore in `initialize()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In `update()`, check if the ship body has collided with an asteroid. To do so,
    check the `PhysicsCollision` structure stored in the ship `b2Body` custom user
    data. Remember that its content is set in the `PhysicsManager::BeginContact()`
    method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the ship collides, we can decrease its life and play a collision sound.
  prefs: []
  type: TYPE_NORMAL
- en: If it has no more life, we can start playing a destruction animation. The body
    should be inactive when this happens to avoid further collision with asteroids.
  prefs: []
  type: TYPE_NORMAL
- en: 'When ship is fully destroyed, we can save its state so that the game loop can
    act appropriately, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Update the `jni/MoveableBody.hpp` component so that it returns a `b2Body` structure
    in `registerMoveableBody()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following two new members:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mBody` for the physical body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mTarget` for the mouse joint:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Adapt `jni/MoveableBody.cpp` constants to the new scale and initialize new
    members in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, set up and update the `physicsbody` so that it follows the ship''s target.
    The target moves according to user input, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, edit `jni/DroidBlaster.cpp` and change the ship registration code
    to accommodate the new changes, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to start the `PhysicsManager` in `onActivate()`, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Terminate by updating and checking ship state in `onStep()`. When it is destroyed,
    exit the game loop as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have created a physical simulation using the Box2D physics engine. More
    specifically, we have seen how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Box2D world to describe the physical simulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a physical representation of entities (ships and asteroids)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step a simulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter and detect collisions between entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract simulation state (that is, coordinates) to feed the graphical representation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Box2D uses its own allocators to optimize memory management. So, to create and
    destroy Box2D objects, one needs to systematically use the provided factory methods
    (`CreateX()`, `DestroyX()`). Most of the time, Box2D will manage memory automatically
    for you. When an object is destroyed, all related *child objects* get destroyed
    (for instance, the bodies are destroyed when the world is destroyed). But, if
    you need to get rid of your objects earlier, and thus manually, always destroy
    the bodies.
  prefs: []
  type: TYPE_NORMAL
- en: Box2D is a complex piece of code and is quite hard to tune properly. Let's dive
    a bit deeper into the way its world is described and how to handle collision.
  prefs: []
  type: TYPE_NORMAL
- en: Diving into the Box2D world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The central point of access in Box2D is the `b2World` object, which stores
    a collection of physical bodies to simulate. A Box2D body is composed of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`b2BodyDef`: This defines the body type (`b2_staticBody, b2_dynamicBody`, and
    so on) and initial properties, such as its position, angle (in radians), and so
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b2Shape`: This is used for collision detection and to derive body mass from
    its density. It can be a `b2PolygonShape`, `b2CircleShape`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b2FixtureDef`: This links together a body shape, a body definition, and its
    physical properties, such as density.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b2Body`: This is a body instance in the world (that is, one per game object).
    It is created from a body definition, a shape, and a fixture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bodies are characterized by a few physical properties, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shape**: This represents a circle in DroidBlaster, although a polygon or
    box could also be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Density**: This is expressed in kg/m2 to compute body mass depending on its
    shape and size. Value should be greater or equal to `0.0`. A bowling ball has
    a bigger density than a soccer ball.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Friction**: This indicates how much a body slides on another (for example,
    a car on a road or on an icy path). Values are typically in the range `0.0` to
    `1.0`, where `0.0` implies no friction and `1.0` implies strong friction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Restitution**: This indicates how much a body reacts to a collision, for
    example, a bouncing ball. Value `0.0` means no restitution and `1.0` means full
    restitution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When running, bodies are subject to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Forces**: This makes bodies move linearly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Torques**: This represents rotational force applied on a body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Damping**: This is similar to friction, although it does not only occur when
    a body is in contact with another. Consider it as the effect of drag slowing down
    a body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Box2D is tuned for worlds containing objects at a scale from `0.1` to `10` (unit
    in meters). When used outside this range, again, numerical approximation can make
    simulation inaccurate. Thus, it is very necessary to scale coordinates from the
    Box2D referential, where objects should to be kept in the (rough) range [`0.1`,
    `10`], and to the game, or directly to the graphics referential. This is why we
    have defined `SCALE_FACTOR` to scale coordinate transformation.
  prefs: []
  type: TYPE_NORMAL
- en: More on collision detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several ways of detecting and handling collisions exist in Box2D. The most basic
    one consists of checking all contacts stored in the world or in a body after they
    are updated. However, this can result in missed contacts that happen surreptitiously
    during Box2D internal iterations.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better way we have seen to detect contacts is the `b2ContactListener`, which
    can be registered on the world object. The following four callbacks can be overridden:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BeginContact (b2Contact)`: This detects when two bodies enter in collision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EndContact(b2Contact)`: This is a counterpart of `BeginContact()`, which indicates
    when bodies are not in collision any more. A call to `BeginContact()` is always
    followed by a matching `EndContact()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PreSolve (b2Contact, b2Manifold)`: This is called after a collision is detected
    but before collision resolution, that is, before impulse resulting from the collision
    is computed. The `b2Manifold` structure holds information about contact points,
    normals, and so on in a single place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PostSolve(b2Contact, b2ContactImpulse)`: This is called after actual impulse
    (that is, physical reaction) has been computed by Box2D.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two callbacks are interesting to trigger game logic (for example,
    entity destruction). The last two are interesting to alter physics simulation
    (more specifically to ignore some collisions by *disabling* a contact) while it
    is being computed, or to get more accurate details about it. For instance, use
    `PreSolve()` to create a one-sided platform to which an entity collides only when
    it falls from above (not when it jumps from below). Use `PostSolve()` to detect
    collision strength and calculate damages accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The `PreSolve()` and `PostSolve()` methods can be called several times between
    `BeginContact()` and `EndContact()`, which can be called themselves from zero
    to several times during one world update. A contact can begin during one simulation
    step and terminate after several steps. In that case, event-solving callbacks
    occur continuously during "in-between" steps. As many collisions can occur while
    stepping simulation. Thus, callbacks can be called a lot of times and should be
    as efficient as possible.
  prefs: []
  type: TYPE_NORMAL
- en: When analyzing collisions inside the `BeginContact()` callback, we buffered
    a collision flag. This is necessary because Box2D reuses the `b2Contact` parameter
    passed when a callback is triggered. In addition, as these callbacks are called
    while simulation is computed, physics bodies cannot be destroyed at that instant,
    only after simulation stepping is over. Thus, it is highly advised to copy any
    information gathered there for `postprocessing` (for example, to destroy entities).
  prefs: []
  type: TYPE_NORMAL
- en: Collision modes and filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I would like to point out that Box2D offers a so-called `bullet` mode that
    can be activated on a body definition using corresponding Boolean member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The bullet mode is necessary for fast moving objects like bullets! By default,
    Box2D uses **Discrete Collision Detection**, which considers bodies at their final
    position for collision detection, missing any body located between initial and
    final positions. However, for a fast moving body, the whole path followed should
    be considered. This is more formally called **Continuous Collision Detection**
    (**CCD**). Obviously, CCD is expensive and should be used with parsimony. Please
    refer to the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collision modes and filtering](img/9645_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We sometimes want to detect when bodies overlap without generating collisions
    (like a car reaching the finish line): this is called a sensor. A sensor can be
    easily set by setting the `isSensor` Boolean member to `true` in the fixture as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: A sensor can be queried with a listener through `BeginContact()` and `EndContact()`
    or by using the `IsTouching()` shortcut on a `b2Contact` class.
  prefs: []
  type: TYPE_NORMAL
- en: Another important aspect of collision is not colliding or, more precisely, filtering
    collisions. A kind of filtering can be performed in `PreSolve()` by disabling
    contacts. This is the most flexible and powerful solution, but also the most complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, as we have seen it, filtering can be performed in a more simple way by
    using a categories and masks technique. Each body is assigned one or more category
    (each being represented by one bit in a short integer, the `categoryBits` member)
    and a mask describing categories of the body they can collide with (each filtered
    category being represented by a bit set to 0, the `maskBits` member), as shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collision modes and filtering](img/9645_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding figure, `Body A` is in categories `1` and `3`, and collides
    with bodies in categories `2` and `4`, which is the case for this poor `Body B`,
    unless its mask filters collision with `Body A` categories (that is, `1` and `3`).
    In other words, both bodies A and B must agree to collide!
  prefs: []
  type: TYPE_NORMAL
- en: 'Box2D also has a notion of collision groups. A body has a collision group set
    to any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Positive integer**: This means others bodies with the same collision group
    value can collide'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Negative integer**: This means others bodies with the same collision group
    value are filtered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using collision groups could have also been a solution to avoid collision between
    asteroids in DroidBlaster, although it is less flexible than categories and masks.
    Note that groups are filtered before categories.
  prefs: []
  type: TYPE_NORMAL
- en: A more flexible solution than category and group filters is the `b2ContactFilter`
    class. This class has a `ShouldCollide(b2Fixture, b2Fixture)` method that you
    can customize to perform your own filtering. Actually, category/group filtering
    are themselves implemented that way.
  prefs: []
  type: TYPE_NORMAL
- en: Going further with Box2D
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This short introduction to Box2D gives you only an overview of what Box2D is
    capable of! The following non-exhaustive list has been left in the shadow:'
  prefs: []
  type: TYPE_NORMAL
- en: Joints to link two bodies together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Raycasting** to query a physics world (for example, which location is a gun
    pointing toward)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contact properties: normals, impulses, manifolds, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Box2D has now a little brother called **LiquidFun**, which is used to simulate
    fluids. You can download and see it in action at [http://google.github.io/liquidfun/](http://google.github.io/liquidfun/).
  prefs: []
  type: TYPE_NORMAL
- en: Box2D has a really nice documentation with useful information that can be found
    at [http://www.box2d.org/manual.html](http://www.box2d.org/manual.html). Moreover,
    Box2D is packaged with a test bed directory (in `Box2D/Testbed/Tests`) featuring
    many use cases. Have a look at them to get a better understanding of its capabilities.
    Because physics simulations can sometimes be rather tricky, I also encourage you
    to visit Box2D forum, which is quite active, at [http://www.box2d.org/forum/](http://www.box2d.org/forum/).
  prefs: []
  type: TYPE_NORMAL
- en: Prebuilding Boost on Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If STL is the most common framework among C++ programs, Boost probably comes
    second. A real Swiss army knife! This toolkit contains a profusion of utilities
    to handle most common needs, and even more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most Boost features are provided as header-only code, which means that we do
    not need to compile it. Including headers is enough of an advantage to use it.
    This is the case of the most popular features of Boost: **Smart Pointers**, a
    reference-counting pointer class that handles memory allocation and de-allocation
    automatically. They avoid most memory leaks and pointer misuse for almost free.'
  prefs: []
  type: TYPE_NORMAL
- en: However, a few parts of Boost require compilation first, such as the threading
    or the unit test library. We are now going to see how to build them with the Android
    NDK and compile a unit test executable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Resulting project is provided with this book under the name `DroidBlaster_Part18`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – prebuilding Boost static library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s prebuild Boost for Android as a static library with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download Boost from [http://www.boost.org/](http://www.boost.org/) (Version
    1.55.0, in this book). Unzip the archive into `${ANDROID_NDK}/sources`. Name the
    directory `boost`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a command line window and go to the `boost` directory. Launch `bootstrap.bat`
    on Windows or .`/bootstrap.sh` on Linux and Mac OS X to build **b2**. This program,
    previously named **BJam**, is a custom building tool similar to **Make**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Boost 1.55.0 archive is provided with this book in the `Libraries/boost` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the NDK build command in DroidBlaster to generate verbose compilation
    logs. To do so, in Eclipse **Project properties**, navigate to the **C/C++ Build**
    section. There, you should see the following build command: `ndk-build NDK_DEBUG=1`.
    Change it to `build NDK_DEBUG=0 V=1` to compile in release mode with verbose logs.'
  prefs: []
  type: TYPE_NORMAL
- en: Rebuild DroidBlaster (you might need to clean your project first). If you look,
    for example, at the following compilation extract, you should see some logs similar
    to the extract below. This log, although barely readable, gives all the information
    about the commands run to build DroidBlaster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The toolchain used to build DroidBlaster (`arm-linux-androideabi-4.6`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system on which DroidBlaster is built (`linux-x86_64`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiler executable (`arm-linux-androideabi-g++`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The archiver executable (`arm-linux-androideabi-ar`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also all the compilation flags passed to them (here for ARM processors)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the following as an inspiration source to determine `Boost` compilation
    flags (in this flag soup!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `boost` directory, open the `tools/build/v2/user-config.jam` file. This
    file, like its name suggests, is a configuration file that can be set up to customize
    `Boost` compilation. Initial content contains only comments and can be erased.
    Start including the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Compilation is performed statically. **BZip** is deactivated because it is
    unavailable, by default, on Android (we could however compile it separately):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Retrieve the `android_ndk` environment variable which points to the NDK location
    on disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare what we could call a "configuration" `android4.6_armeabi`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, reconfigure Boost to use the NDK ARM GCC toolchain (`g++`, `ar`, and `ranlib`)
    in static mode, the archiver being in charge of creating the static library. We
    can use the information found in the log in step 2 to fill their respective paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sysroot` directive indicates which Android API release to compile and
    link against. The specified directory, located in the NDK, contains `include`
    files and libraries specific to this release, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Boost needs exceptions and RTTI. Enable them with the `–fexceptions` and `–frtti`
    flags, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'A few options have to be defined to tweak `Boost` compilation. This is where
    we can take inspiration from the compilation flags discovered in step 2, such
    as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-march=armv5te` to specify the target platform'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-mthumb`, which indicates that generated code should use thumb instructions
    (`-marm` could also be used to use ARM instructions instead)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-0s` to enable compiler optimizations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-DNDEBUG` to request compilation in release mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also include or tweak additional ones, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: -`D__arm__`, `-D__ARM_ARCH_5__`, and so on, which help to determine the target
    platform from code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-DANDROID`, `-D__ANDROID__`, which help to determine the target OS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-DBOOST_ASIO_DISABLE_STD_ATOMIC` to disable the use `std::atomic`, which is
    buggy on Android (something that can be learnt only through (bad) "experience"…).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: From a terminal pointing located in the boost directory, launch the compilation
    using the following command line. We need to exclude the **Python** module, which
    requires additional libraries not available on the NDK by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Final static libraries are generated in `android-armeabi/lib/`.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat the same steps for the ArmV7 and X86 platforms, creating a new configuration
    for each of them. The staging directory must be `armeabi-v7a` for ArmV7 and `android-x86`
    for X86.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Final `user-config.jam` is provided with this book in the `Libraries/boost`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have customized the Boost configuration to use the raw Android GCC toolchain
    as a standalone compiler (that is, without the NDK wrappers). We have declared
    various flags to adapt compilation to Android target platforms. Then, we have
    built Boost manually using its dedicated building tool `b2`. Now, every time Boost
    is updated or modified, code has to be manually compiled again with `b2`.
  prefs: []
  type: TYPE_NORMAL
- en: We have also forced NDK-Build to generate verbose logs with the `V=1` argument.
    This is helpful to either troubleshoot compilation issues or to get feedback on
    what and how NDK-Build is compiling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have enabled release compilation mode, that is, with code optimizations,
    by switching `NDK_DEBUG` to `0`. This could have also been done by setting `APP_OPTIM
    := release` in `jni/Application.mk`. There are five main optimization levels in
    GCC, and they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-O0**: This disables any optimization. This is automatically set by the NDK
    when `APP_OPTIM` is set to `debug` (more about this in the last part about Makefiles
    in this chapter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-O1**: This allows basic optimizations without increasing compilation time
    too much. These optimizations do not require any speed-space tradeoffs, which
    mean that they produce faster code without increasing executable size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-O2**: This allows advanced optimization (including `-O1`), but at the expense
    of compilation time. Like `–O1`, these optimizations do not require speed-space
    tradeoffs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-O3**: This performs aggressive optimizations (including `-O2`), which can
    increase executable size, such as **function inlining**. This is generally profitable
    but, sometimes, counterproductive (for example, increasing memory usage can also
    increase cache misses).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-Os**: This optimizes compiled code size (a subset of `–O2`) before speed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although `-Os` or `–O2` is generally the way to go for release mode, `-O3` can
    also be considered for performance-critical code. The `-0x` flags being shortcuts
    for the various GCC optimization flags, enabling `–O2` and appending additional
    "fine-grain" flags (for example, `-finline-functions`), are an option too. Whatever
    option you choose, the best way to find the best choice is simply by performing
    benchmarking! To get more information about the numerous GCC optimization options,
    have a look at [http://gcc.gnu.org/](http://gcc.gnu.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Boost module is prebuilt, we can embed any of its libraries in
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – compiling an executable linked to Boost
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use the Boost unit test library to build our own unit test executable
    through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Still in the `boost` directory, create a new `Android.mk` file to declare the
    newly prebuilt libraries as Android modules and make them available to NDK applications.
    This file needs to contain one module declaration per library. For example, define
    one module `boost_unit_test_framework`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LOCAL_SRC_FILES` reference the static library `libboost_unit_test_framework.a`
    we have built with b2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `$(TARGET_ARCH_ABI)` variable to determine the right path to use, which
    depends on the target platform. Its value can be `armeabi`, `armeabi-v7a`, or
    `x86`. If you compile DroidBlaster for X86, the NDK will look for `libboost_unit_test_framework.a`
    in `androidx86/lib`.
  prefs: []
  type: TYPE_NORMAL
- en: '`LOCAL_EXPORT_C_INCLUDES` automatically appends boost root directory to the
    include file directory list of the including module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Indicate that this module is a prebuilt library with the `$(PREBUILT_STATIC_LIBRARY)`
    directive:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: More modules can be declared in the same file with the same set of lines (for
    example, `boost_thread`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Final `user-config.jam` is provided with this book in the `Libraries/boost`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the `DroidBlaster` project and create a new directory `test` containing
    the unit test file `test/Test.cpp`. Write a test to check the behavior, for example,
    of the `TimeManager`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To include Boost in an application, we need to link it with an STL implementation
    supporting exceptions and RTTI. Enable them globally in the `Application.mk` file,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Finally, open DroidBlaster `jni/Android.mk` and create a second module named
    `DroidBlaster_test` before the `import-module` section. This module compiles the
    additional `test/Test.cpp` test file and must be linked to the Boost unit test
    library. Build this module as an executable, and not a shared library, with `$(BUILD_EXECUTABLE)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, import the `Boost` module itself in the import-module section, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the project. If you look into the `libs` folder, you should see one `droidblaster_test`
    file in addition to the shared library. This is an executable file that we can
    run on an emulator or a rooted device (given you have the right to deploy and
    change permission on a file). Deploy this file and run it (here on an Arm V7 emulator
    instance):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '![Time for action – compiling an executable linked to Boost](img/9645_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have created a fully native executable using a Boost prebuilt module and
    can run it on Android. Boost prebuilt static libraries have been "published" from
    the Boost `Android.mk` module file in the `Boost` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, there exist four main ways to build a native library. We have already
    seen `BUILD_STATIC_LIBRARY` and `BUILD_SHARED_LIBRARY` in the Box2D part. Two
    more options coexist, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PREBUILT_STATIC_LIBRARY` to use an existing (that is, prebuilt) binary static
    library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PREBUILT_SHARED_LIBRARY` to use an existing binary shared library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These directives indicate that libraries are ready for linking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the main module file, as we have seen for Box2D, submodules linked need
    to be listed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LOCAL_SHARED_LIBRARIES` for shared libraries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_STATIC_LIBRARIES` for static libraries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same rule applies whether the library is prebuilt or not. Modules, whether
    they are static, shared, prebuilt, or built on-demand, must be imported in the
    final main module using the NDK `import-module` directive.
  prefs: []
  type: TYPE_NORMAL
- en: When a prebuilt library is linked to a main module, source files are not necessary.
    Include files are obviously still required. Thus, prebuilt libraries are an appropriate
    choice if you want to provide a library to third parties without releasing sources.
    On the other hand, on-demand compilation allows tweaking compilation flags on
    all included libraries (such as optimization flags, the ARM mode, and so on) from
    your main `Application.mk` project file.
  prefs: []
  type: TYPE_NORMAL
- en: To properly link with Boost, we have also enabled exceptions and RTTI on the
    whole project. Exceptions and RTTI are activated very easily by appending `-fexceptions`
    and `-frtti` to either the `APP_CPPFLAGS` directive in the `Application.mk` file
    or the `LOCAL_CPPFLAGS` file of the concerned library. By default, Android compiles
    with `-fno-exceptions` and `-fno-rtti` flags.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, exceptions have the reputation of making the compiled code bigger and
    less efficient. They prevent the compiler from performing some clever optimizations.
    However, whether exceptions are worse than error checking, or even no check at
    all, is a highly debatable question. In fact, Google's engineers dropped them
    in the first releases because GCC 3.x generated a poor exception handling code
    for ARM processors. However, the build chain now uses GCC 4.x, which does not
    suffer from this flaw. Compared to manual error checking and handling of exceptional
    cases, this penalty might not be so significant most of the time. Thus, the choice
    of exceptions is up to you (and your embedded libraries)!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Exception handling in C++ is not easy and imposes a strict discipline! They
    must be used strictly for exceptional cases and require carefully designed code.
    Have a look at the **Resource Acquisition Is Initialization** (**RAII**) idiom
    to properly handle them. For more information, have a look at [http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization](http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization).
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, Boost provides much more interesting features than unit tests. Discover
    its full richness in its official documentation at [http://www.boost.org/doc/libs](http://www.boost.org/doc/libs).
    Beware, Boost is subject to regular breaking changes or bugs on Android since
    it is not very actively maintained and tested on that platform. Be prepared to
    investigate and fix problems directly in its code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen in practice how to write module Makefiles, let's learn
    more about them.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering module Makefiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android Makefiles are an essential piece of the NDK building process. Thus,
    to build and manage a project properly, it is important to understand the way
    they work.
  prefs: []
  type: TYPE_NORMAL
- en: Makefile variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Compilation settings are defined through a set of predefined NDK variables.
    We have already seen the three most important ones: `LOCAL_PATH, LOCAL_MODULE`,
    and `LOCAL_SRC_FILES`, but many others exist. We can differentiate the following
    four types of variables, each with a different prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LOCAL_` variables: These are dedicated to individual module compilation and
    are defined in `Android.mk` files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APP_` variables: These refer to application-wide options and are set in `Application.mk`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NDK_` variables: These are mainly internal variables that usually refer to
    environment variables (for example, `NDK_ROOT`, `NDK_APP_CFLAGS,` or `NDK_APP_CPPFLAGS`).
    There are two notable exceptions: `NDK_TOOLCHAIN_VERSION` and `NDK_APPLICATION_MK`.
    The latter can be passed to the NDK-Build in parameter to define a different `Application.mk`
    location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PRIVATE_` prefixed variables: These are for NDK internal use only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table contains a non-exhaustive list of `LOCAL` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `LOCAL_PATH` | To specify the root location of source files. Must be defined
    at the beginning of the `Android.mk` file before `include $(CLEAR_VARS)`. |'
  prefs: []
  type: TYPE_TB
- en: '| `LOCAL_MODULE` | To define module name, it must be unique among all modules.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `LOCAL_MODULE_FILENAME` | To override default name of the compiled module,
    which is:`- lib<module name>.so` for shared libraries.`- lib<module name>.a` for
    static libraries.No custom file extensions can be specified so that `.so` or`.a`
    remains appended. |'
  prefs: []
  type: TYPE_TB
- en: '| `LOCAL_SRC_FILES` | To define the list of source files to compile, each separated
    by a space and relative to `LOCAL_PATH`. |'
  prefs: []
  type: TYPE_TB
- en: '| `LOCAL_C_INCLUDES` | To specify header file directories for both C and C++
    languages. The directory can be relative to the `${ANDROID_NDK}` directory, but
    unless you need to include a specific NDK file, you are advised to use absolute
    paths (which can be built from Makefile variables such as `$(LOCAL_PATH)`). |'
  prefs: []
  type: TYPE_TB
- en: '| `LOCAL_CPP_EXTENSION` | To change default C++ file extension, that is, `.cpp`
    (for example, `.cc` or `.cxx`). A list of file extensions separated by a space,
    can be specified. Extensions are necessary for GCC to determine which file is
    related to which language. |'
  prefs: []
  type: TYPE_TB
- en: '| `LOCAL_CFLAGS`, `LOCAL_CPPFLAGS`, `LOCAL_LDLIBS` | To specify any options,
    flags, or macro-definitions for compilation and linking. The first one works for
    both C and C++, the second one is for C++ only, and the last one is for the linker.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `LOCAL_SHARED_LIBRARIES`, `LOCAL_STATIC_LIBRARIES` | To declare a dependency
    with other modules (not system libraries), shared and static modules, respectively.
    `LOCAL_SHARED_LIBRARIES` manage dependencies whereas `LOCAL_LDLIBS` should be
    used for declaring system libraries. |'
  prefs: []
  type: TYPE_TB
- en: '| `LOCAL_ARM_MODE`, `LOCAL_ARM_NEON`, `LOCAL_DISABLE_NO_EXECUTE`, `LOCAL_FILTER_ASM`
    | Advanced variables dealing with processors and assembler/binary code generation.
    They are not necessary for most programs. |'
  prefs: []
  type: TYPE_TB
- en: '| `LOCAL_EXPORT_C_INCLUDES`, `LOCAL_EXPORT_CFLAGS`, `LOCAL_EXPORT_CPPFLAGS`,
    `LOCAL_EXPORT_LDLIBS` | To define additional options or flags in import modules
    that should be appended to client module options. For example, if a module A defines`LOCAL_EXPORT_LDLIBS
    := -llog`because it needs an Android logging module. Then, module B, that depends
    on module A, will be automatically linked to `–llog`.`LOCAL_EXPORT_` variables
    are not used when compiling the module that exports them. If required, they also
    need to be specified in their `LOCAL` counterpart. |'
  prefs: []
  type: TYPE_TB
- en: Documentation about these variables can be found at `${ANDROID_NDK}/docs/ANDROID-MK.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table contains a non-exhaustive list of the `APP` variables (all
    are optional):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `APP_PROJECT_PATH` | To specify the root of your application project. |'
  prefs: []
  type: TYPE_TB
- en: '| `APP_MODULES` | The list of modules to compile with their identifier. Dependent
    modules are also included. This can be used, for example, to force the generation
    of a static library. |'
  prefs: []
  type: TYPE_TB
- en: '| `APP_OPTIM` | Set to `release` or `debug` to adapt compilation settings to
    the type of build you want. When not specified explicitly, the NDK determines
    the build type using the debuggable flag in the AndroidManifest. |'
  prefs: []
  type: TYPE_TB
- en: '| `APP_CFLAGS``APP_CPPFLAGS``APP_LDFLAGS` | To globally specify any options,
    flags, or macro-definitions for compilation and linking. The first one works for
    both C and C++, the second one is for C++ only, and the last one is for the linker.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `APP_BUILD_SCRIPT` | To redefine the location of the Android.mk file (by
    default in project''s `jni` directory). |'
  prefs: []
  type: TYPE_TB
- en: '| `APP_ABI` | List of ABI (that is, "CPU architectures") supported by the application,
    separated by a space. Currently supported values are `armeabi`, `armeabi-v7a`,
    `x86`, mips, or `all`. Each module is recompiled once per ABI. So, the more ABI
    you support, the more time it will get to build. |'
  prefs: []
  type: TYPE_TB
- en: '| `APP_PLATFORM` | Name of the target Android platform. This information is
    found by default in the `project.properties` file. |'
  prefs: []
  type: TYPE_TB
- en: '| `APP_STL` | The C++ runtime to use. Possible values are `system`, `gabi++_static`,
    `gabi++_shared`, `stlport_static`, `stlport_shared`, `gnustl_static`, `gnustl_shared`,
    `c++_static`, and `c++_shared`. |'
  prefs: []
  type: TYPE_TB
- en: Documentation about these variables can be found at `${ANDROID_NDK}/docs/APPLICATION-MK.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling C++ 11 support and the Clang compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `NDK_TOOLCHAIN_VERSION` variable can be redefined in the `Application.mk`
    file to explicitly select the compilation toolchain. Possible values for the NDK
    R10 are `4.6` (now deprecated), `4.8`, and `4.9`, which simply correspond to GCC
    versions. Possible version numbers might change in future releases of the NDK.
    To find them, have a look at the `$ANDROID_NDK/toolchains` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Android NDK provides C++ 11 support, starting with the GCC 4.8 toolchain.
    You can enable it by appending the `-std=c++11` compilation flag and activating
    GNU STL (STL Port is not supported and Libc++ only partially supported at the
    time this book was written) to get proper C++11 support. The following is an example
    of `an Android.mk` extract with C++11 activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Switching to GCC4.8 and C++11 might not feel like a breeze. Indeed, the compiler,
    let's say, is a bit less permissive than before. In case you run into trouble
    when compiling legacy code with this new toolchain, try the `–fpermissive` flag
    (or rewrite your code!).
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, beware, although C++11 support is quite large, you might still encounter
    a few problems or missing features.
  prefs: []
  type: TYPE_NORMAL
- en: To enable Clang, the LLVM-based compiler (famous for being used by Apple), in
    place of GCC, simply set `NDK_TOOLCHAIN_VERSION` to `clang`. You can also specify
    compiler version, such as `clang3.4` or `clang3.5`. Again, possible version numbers
    might change in future releases of the NDK. To find them, have a look at the `$ANDROID_NDK/toolchains`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Makefile Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Makefile is a real language with programming instructions and functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Makefiles can be broken down into several sub-Makefiles, included with the
    `include` instruction. Variable initialization comes in the following two flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple affectation (`operator :=`), which expands variables at the time they
    are initialized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursive affectation (`operator =`), which re-evaluates the affected expression
    each time it is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following conditional and loop instructions are available: `ifdef/endif`,
    `ifeq/endif`, `ifndef/endif`, `and for…in/do/done`. For example, to display a
    message only when a variable is defined, do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'More advanced stuff, such as functional `if`, `and`, `or`, and so on, are at
    your disposal, but are rarely used. Makefiles also provide some useful built-in
    functions, which are given in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `$(info <message>)` | Allows printing messages to the standard output. This
    is the most essential tool when writing Makefiles! Variables inside information
    messages are allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| `$(warning <message>)`, `$(error <message>)` | Allows printing a warning
    or a fatal error that stops compilation. These messages can be parsed by Eclipse.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `$(foreach <variable>`, `<list>`, `<operation>)` | Performs an operation
    on a list of variables. Each element of the list is expanded in the first argument
    variable, before the operation is applied to it. |'
  prefs: []
  type: TYPE_TB
- en: '| `$(shell <command>)` | Executes a command outside of Make. This brings all
    the power of Unix Shell into Makefiles but is heavily system-dependent. Avoid
    it if possible. |'
  prefs: []
  type: TYPE_TB
- en: '| `$(wildcard <pattern>)` | Selects files and directory names according to
    a pattern. |'
  prefs: []
  type: TYPE_TB
- en: '| `$(call <function>)` | Allows evaluating a function or macro. One macro we
    have seen is `my-dir`, which returns the directory path of the last executed Makefile.
    This is why `LOCAL_PATH := $(call my-dir)` is systematically written at the beginning
    of each `Android.mk` file to save in the current Makefile directory. |'
  prefs: []
  type: TYPE_TB
- en: 'Custom functions can easily be written with the `call` directive. These functions
    look somewhat similar to recursively affected variables, except that the arguments
    can be defined: `$(1)` for first argument, `$(2)` for second argument, and so
    on. A call to a function can be performed in a single line, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings and files manipulation functions are available too, as shown in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `$(join <str1>, <str2>)` | Concatenates two strings. |'
  prefs: []
  type: TYPE_TB
- en: '| `$(subst <from>,``<replacement>,<string>)`,`$(patsubst <pattern>,``<replacement>,<string>)`
    | Replaces each occurrence of a substring by another. The second one is more powerful
    because it allows using patterns (which must start with "%"). |'
  prefs: []
  type: TYPE_TB
- en: '| `$(filter <patterns>, <text>)``$(filter-out <patterns>, <text>)` | Filter
    strings from a text matching patterns. This is useful for filtering files. For
    example, the following line filters any C file:`$(filter %.c, $(my_source_list))`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `$(strip <string>)` | Removes any unnecessary whitespace. |'
  prefs: []
  type: TYPE_TB
- en: '| `$(addprefix <prefix>,<list>)`,`$(addsuffix <suffix>, <list>)` | Append a
    prefix and suffix, respectively, to each element of the list, each element being
    separated by a space. |'
  prefs: []
  type: TYPE_TB
- en: '| `$(basename <path1>, <path2>, ...)` | Returns a string from which file extensions
    are removed. |'
  prefs: []
  type: TYPE_TB
- en: '| `$(dir <path1>, <path2>)`,`$(notdir <path1>, <path2>)` | Extracts the directory
    and the filename in a path respectively. |'
  prefs: []
  type: TYPE_TB
- en: '| `$(realpath <path1>, <path2>, ...)`,`$(abspath <path1>, <path2>, ...)` |
    Return both canonical paths of each path argument, except that the second one
    does not evaluate symbolic links. |'
  prefs: []
  type: TYPE_TB
- en: This is just really an overview of what Makefiles are capable of. For more information,
    refer to the full Makefile documentation available at [http://www.gnu.org/software/make/manual/make.html](http://www.gnu.org/software/make/manual/make.html).
    If you are allergic to Makefiles, have a look at CMake. CMake is a simplified
    Make system, already building many open source libraries on the market. A port
    of CMake on Android is available at [http://code.google.com/p/android-cmake](http://code.google.com/p/android-cmake).
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – mastering Makefiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can play in a variety of ways with Makefiles:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the affectation operator. For example, write down the following piece of
    code, which uses the `:= operator`, in your `Android.mk` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Watch the result when launching compilation. Then, perform the same using `=`.
    Print current optimization mode. Use `APP_OPTIM` and the internal variable, `NDK_APP_CFLAGS`,
    and observe the difference between the `release` and `debug` modes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that variables are properly defined, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to use the `foreach` instruction to print the list of files and directories
    inside the project''s root directory and its `jni` folder (and make sure to use
    recursive affectation):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to create a macro to log a message to the standard output and its time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, test the `my-dir` macro-behavior, to understand why `LOCAL_PATH :=
    $(call my-dir)` is systematically written at the beginning of each `Android.mk`
    file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: CPU Architectures (ABI)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Compiled native C/C++ code on current Android ARM devices follows an **Application
    Binary Interface** (**ABI**). An ABI specifies the binary code format (instruction
    set, calling conventions, and so on). GCC translates code into this binary format.
    ABIs are thus strongly related to processors. The target ABI can be selected in
    the `Application.mk` file with the `APP_ABI` variable. There exist five main ABIs
    supported on Android, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**thumb**: This is the default option, which should be compatible with all
    ARM devices. Thumb is a special instruction set which encodes instructions on
    16 bit, instead of 32 bit, to improve code size (useful for devices with constrained
    memory). The instruction set is severely restricted compared to ArmEABI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**armeabi** (Or Arm v5): This should run on all ARM devices. Instructions are
    encoded on 32 bit but may be more concise than Thumb code. Arm v5 does not support
    advanced extensions such as floating point acceleration and is thus slower than
    Arm v7.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**armeabi-v7a**: This supports extensions such as Thumb-2 (similar to Thumb
    but with additional 32-bit instructions) and VFP, plus some optional extensions,
    such as NEON. Code compiled for Arm V7 will not run on Arm V5 processors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**x86**: This is for "*PC-like*" architectures (that is, Intel/AMD) and, more
    specifically, Intel Atom processors. This ABI provides specific extensions, such
    as MMX or SSE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mips**: This is for MIPS processors developed by Imagination Technologies
    (which also produce the PowerVR graphics processors). Only a few devices exist
    at the time this book was written.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, the compiled binaries of each ABI are embedded in the APK. The most
    appropriate is selected at installation time. Google Play also supports the upload
    of different APKs for each ABI to limit application size.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced instruction sets (NEON, VFP, SSE, MSA)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are reading this book, code performance is probably one of your main
    criteria. To achieve this, ARM created a SIMD instruction set (acronym Single
    Instruction Multiple Data, that is, process several data in parallel with one
    instruction) called NEON, which has been introduced along with the VFP (floating
    point accelerated) unit. NEON is not available on all chips (for example, Nvidia
    Tegra 2 does not support it), but is quite popular in intensive multimedia applications.
    They are also a good way to compensate the weak VFP unit of some processors (for
    example, Cortex-A8).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A NEON code can be written in a separate assembler file in a dedicated `asm
    volatile` block with assembler instructions, or in a C/C++ file or as intrinsics
    (NEON instructions encapsulated in a GCC C routine). Intrinsics should be used
    with much care as GCC is often unable to generate efficient machine code (or requires
    lots of tricky hints). Writing real assembler code is generally advised.
  prefs: []
  type: TYPE_NORMAL
- en: 'X86 CPUs have their own set of extensions that are different from the ARM ones:
    MMX, SSE, SSE2, and SSE3\. SSE instruction sets are the Intel equivalent of NEON
    SIMS instructions. The latest SSE4 instructions are generally not supported on
    current X86 processors. Obviously, SSE and NEON are not compatible, which means
    that a code specifically written for NEON needs to be rewritten for SSE and reciprocally.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android provides a `cpu-features.h` API (with the `android_getCpuFamily()`and
    `android_getCpuFeatures()` methods) to detect available features on the host device
    at runtime. It helps in detecting the CPU (ARM, X86) and its capabilities (ArmV7
    support, NEON, VFP, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: NEON, SSE, and modern processors in general are not easy to master. The Internet
    is full of examples to get inspiration from. Reference technical documentation
    can be found on the ARM website at [http://infocenter.arm.com/](http://infocenter.arm.com/)
    and the Intel developer manuals at [http://www.intel.com/](http://www.intel.com/).
  prefs: []
  type: TYPE_NORMAL
- en: MIPS also has its own SIMD instruction set named MSA. It provides features such
    as vector arithmetics and branching operations, or conversion between integer
    and floating-point values. For more information, have a look at [http://www.imgtec.com/mips/architectures/simd.asp](http://www.imgtec.com/mips/architectures/simd.asp).
  prefs: []
  type: TYPE_NORMAL
- en: 'All this stuff is interesting but it does not answer the question you are probably
    asking yourself: how hard it is to port code from ARM to X86 (or reciprocally)?
    The answer is "it depends":'
  prefs: []
  type: TYPE_NORMAL
- en: If you use pure C/C++ native code, without specific instruction set, code should
    be portable simply by appending `x86` or `mips` to the `APP_ABI` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your code contains assembly code, you will need to rewrite the corresponding
    part for other ABI or provide a fallback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your code contains specific instruction sets such as NEON (using C/C++ intrinsics
    or assembly code), you will need to rewrite corresponding part for other ABIs
    or provide a fallback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your code depends on specific memory alignment, you might need to use explicit
    alignment. Indeed, when you compile a data structure, the compiler might use padding
    to align data in memory appropriately for faster memory accesses. However, alignment
    requirements are different depending on the ABI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, 64-bit variables on ARM are aligned to 8, which means, for example,
    that double must have a memory address, which is a multiple of 8\. X86 memory
    can be more densely packed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data alignment is not an issue the vast majority of the time, except if you
    explicitly depend on data location (for example, if you use serialization). Even
    if you have no alignment issues, it is always interesting to tweak or optimize
    structure layouts to avoid useless padding and get better performances.
  prefs: []
  type: TYPE_NORMAL
- en: So, most of the time, porting code from one ABI to another should be rather
    simple. In specific cases, provide fallbacks when specific CPU features or assembly
    code is necessary. Finally, beware, some memory alignment issues might arise in
    some rare cases.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have seen in the Prebuilding Boost part, each ABI has its own compilation
    flags to optimize compilation. Although the default GCC options used by the NDK
    are an appropriate basis, tweaking them can improve efficiency and performance.
    For example, you can use `-mtune=atom -mssse3 -mfpmath=sse` to optimize release
    code on X86 platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduced a fundamental aspect of the NDK: portability. Thanks
    to the recent improvements in the building toolchain, the Android NDK can now
    take advantage of the vast C/C++ ecosystem. It unlocks the door of a productive
    environment, where code is shared with other platforms with the aim of creating
    new cutting-edge applications efficiently.'
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, you learned how to activate the STL with a simple flag in
    the NDK makefile system. We have ported the Box2D library into an NDK module that
    is reusable among Android projects. You also saw how to prebuild Boost using the
    raw NDK toolchain, without any wrapper. We have enabled exceptions and RTTI and
    discovered in depth how to write module makefiles.
  prefs: []
  type: TYPE_NORMAL
- en: We have highlighted the path toward the creation of professional applications
    using the NDK as a leverage. But do not expect all C/C++ libraries to be ported
    so easily. Talking about paths, we are almost at the end. At least, this was the
    last chapter about DroidBlaster.
  prefs: []
  type: TYPE_NORMAL
- en: The next and last chapters will introduce RenderScript, an advanced technology
    to maximize your Android app performance.
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 10. Intensive Computing with RenderScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*If the NDK is one of the best tools to get a high performance on Android.
    It gives low-level access to the machine, gives you control on memory allocation,
    provides access to advanced CPU instruction-sets, and even more.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*This power comes with a price: to get maximum performance on a key piece of
    code, ones need to optimize code for the many devices and platforms in the world.
    Sometimes, it is more appropriate to use CPU SIMD instructions, and other times,
    to perform computation on the GPU. You had better be experienced and have plenty
    of devices and time in front of you! This is the reason Google introduced RenderScript
    on Android.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**RenderScript** is a programming language specific to Android written with
    one goal in mind: *performance*. Let''s be clear, applications cannot be entirely
    written in RenderScript. However, the critical parts, requiring intensive computations,
    should be! RenderScript can be executed from either Java or C/C++.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss these basics and concentrate our effort on
    its NDK binding. We will create a new project to demonstrate RenderScript capabilities
    by filtering images. More precisely, we will see how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Execute the predefined **Intrinsics**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create your own custom **Kernels**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine Intrinsics and Kernels together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to create your own RenderScript
    programs and bind them into your native code.
  prefs: []
  type: TYPE_NORMAL
- en: What is RenderScript ?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RenderScript was introduced in Honeycomb in 2011 with a strong focus on graphics
    capabilities, hence the name. The graphics engine part of RenderScript has, however,
    been deprecated since Android 4.1 JellyBean. Although it has kept its name, RenderScript
    has deeply evolved to emphasize its "compute engine". It is similar to technologies
    such as OpenCL and CUDA, with an emphasis on portability and usability.
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, RenderScript tries to abstract hardware specificities from
    the programmer and extract the maximum raw power from it. Instead of taking the
    least common denominator, it optimizes code according to the platform it executes
    on at runtime. The final code can run on either the CPU or GPU, with an advantage
    of automatic parallelization managed by RenderScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'The RenderScript framework is composed of a few elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A C-like language based on C99, which provides variables, functions, structures,
    and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **low level virtual machine** (**LLVM**) based compiler on the developer machine
    that produces intermediate code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A RenderScript library and runtime that translates intermediate code to machine
    code only when the final program runs on the device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Java and NDK binding API to execute and chain computation tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Computation tasks are obviously the center of RenderScript. There are two kinds
    of tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Kernels, which are user-created scripts that perform a computation task using
    the RenderScript language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intrinsics, which are built-in Kernels to perform some common tasks such as
    blurring pixels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernels and Intrinsics can be combined together, the output of a program being
    linked to the input of another. From the complex graphs of computation tasks emerge
    fast and powerful programs.
  prefs: []
  type: TYPE_NORMAL
- en: However, for the moment, let's see what Intrinsics are and how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Executing a predefined Intrinsic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RenderScript provides a few built-in functions, mainly dedicated to Image processing,
    called Intrinsics. With these, blending images, such as in Photoshop, blurring
    them, or even decoding raw YUV images from the camera, (see [Chapter 4](ch04.html
    "Chapter 4. Calling Java Back from Native Code"), *Calling Java Back from Native
    Code*, for a slower alternative) becomes simple and highly efficient. Indeed,
    Intrinsics are highly optimized and can be considered as one of the best implementations
    in their domain.
  prefs: []
  type: TYPE_NORMAL
- en: To see how Intrinsics work, let's create a new project that takes an input image
    and applies a blur effect to it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `RenderScript_Part1`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a Java UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a new Java project with a JNI module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new hybrid Java/C++ project as shown in [Chapter 2](ch02.html "Chapter 2. Starting
    a Native Android Project"), *Starting a Native Android Project*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `RenderScript`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main package is `com.packtpub.renderscript`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minSdkVersion` is 9 and `targetSdkVersion` is 19.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the `android.permission.WRITE_EXTERNAL_STORAGE` permission in the `AndroidManifest.xml`
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn the project into a native project as already seen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the native source and header files that have been created by ADT.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name the main Activity `RenderScriptActivity` and its layout `activity_renderscript.xml`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Define the `project.properties` file as follows. These lines activate the `RenderScript`
    support library, which allows porting code to older devices until API 8:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify `res/activity_renderscript.xml` to make it look as follows. We will
    need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `SeekBar` to define the blur radius
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Button` to apply the blur effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two `ImageView` elements to display the image before and after the effect is
    applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Implement `RenderScriptActivity` as shown below.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the `RSSupport` module, which is the `RenderScript` support library, and
    the `renderscript` module, which we are about to create in a static block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in `onCreate()`, load a 32-bit bitmap from an image placed in `drawable`
    resources (here, named `picture`) and create a second empty bitmap of the same
    size. Assign these bitmaps to their respective `ImageView` component. Also, define
    `OnClickListener` on the **Blur** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a native function, `blur`, which takes in the parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application cache directory for the `RenderScript` runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source and destination bitmaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The blur effect radius to determine the blur strength
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call this method from the `onClick()` handler using the seek bar value to determine
    the blur radius. The radius must be in the range [`0`, `25`].
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Time for action – running RenderScript Blur intrinsic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create the native module that will generate our new effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file `jni/ RenderScript.cpp`. We will need the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`android/bitmap.h` header to manipulate bitmaps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jni.h` for JNI strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RenderScript.h`, which is the main `RenderScript` header file. This is the
    only one you should need. RenderScript is written in C++ and is defined in the
    `android::RSC` namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Write two utility methods to lock and unlock Android bitmaps as seen in [Chapter
    4](ch04.html "Chapter 4. Calling Java Back from Native Code"), *Calling Java Back
    from Native Code*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Implement the native method `blur()` using the JNI convention.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, instantiate the RS class. This class is the main interface, which controls
    RenderScript initialization, resource management, and object creation. Wrap it
    with the `sp` helper class provided by RenderScript, which represents a smart
    pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize it with the cache directory given in parameter, converting the string
    appropriately with JNI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Lock the bitmaps we are working on using the utility methods we just wrote:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now comes the interesting part. Create a RenderScript **Allocation** from the
    source bitmap. This `ALLOCATION` represents the whole input memory area whose
    dimensions are defined by `Type`. The Allocation is composed of "individual" **Elements**;
    in our case, 32-bit RGBA pixels are defined as `Element::RGBA_8888`. Since the
    bitmap is not used as a texture, we have no need for **Mipmaps** (see [Chaper
    6](ch06.html "Chapter 6. Rendering Graphics with OpenGL ES"), *Rendering Graphics
    with OpenGL ES*, about OpenGL ES for more information).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat the same operation for the output `ALLOCATION` created from the output
    bitmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Create a `ScriptIntrinsicBlur` instance and the kind of elements it works on,
    which is again RGBA pixels. An Intrinsic is a predefined RenderScript function,
    which implements a common operation, such as a blur effect in our case. The **Blur
    Intrinsic** takes a radius as an input parameter. Set it with `setRadius()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, specify the blur Intrinsic input, that is the source Allocation with `setInput()`.
  prefs: []
  type: TYPE_NORMAL
- en: Apply the Intrinsic on each of its elements with `forEach()` and save it to
    the output Allocation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, copy the result to the destination bitmap with `copy2DRangeTo()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to unlock the bitmap after the effect is applied!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Create a `jni/Application.mk` file targeting the `ArmEABI V7` and `X86` platforms.
    Indeed, RenderScript currently does not support older `ArmEABI V5`. `STLPort`,
    and is also required by the RenderScript native library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Create a `jni/Android.mk` file defining our `renderscript` module and listing
    `RenderScript.cpp` for compilation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make `LOCAL_C_INCLUDES` point to the appropriate RenderScript, including the
    file directory in the NDK platform directory. Also, append the RenderScript precompiled
    libraries directory to `LOCAL_LDFLAG`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, link against `dl`, `log`, and `RScpp_static`, which are required for
    RenderScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the project, increase the `SeekBar` value, and click on the **Blur** button.
    The output `ImageView` should display the filtered picture as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/9645_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We embedded the RenderScript compatibility library in our project, giving us
    access to RenderScript down to the API 8 Froyo. On older devices, RenderScript
    is "emulated" on the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you decide to use RenderScript from the NDK but do not want to use the compatibility
    library, you will need to embed the RenderScript runtime manually. To do so, remove
    all the stuff we added in the `project.properties` file in step 2 and include
    the following piece of code at the end of your `Android.mk` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we executed our first RenderScript Intrinsic that applies a blur effect
    as efficiently as possible. Intrinsic execution follows a simple and repetitive
    pattern that you will see repeatedly:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the input and output memory areas are exclusively available, for
    example, by locking bitmaps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create or reuse the appropriate input and output Allocation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and set up the Intrinsic parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the input Allocation and apply the Intrinsic to an output Allocation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the result from the output Allocation to the target memory area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To understand this process better, let''s dive a bit more into the way RenderScript
    works. RenderScript follows a simple model. It takes some data as the input and
    processes it to an output memory area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/9645_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As a computing solution, RenderScript works with any type of data stored in-memory.
    This is an Allocation. An Allocation is composed of individual Elements. For an
    Allocation pointing to a bitmap, an element would typically be a pixel (which
    is itself a set of 4 `uchar` values). Among the large list of Elements available,
    we can cite:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Possible Allocation Elements |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| `U8`, `U8_2`, `U8_3`, `U8_4` | `I8`, `I8_2`, `I8_3`, `I8_4` | `RGBA_8888`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `U16`, `U16_2`, `U16_3`, `U16_4` | `I16`, `I16_2`¸ `I16_3`, `I16_4` | `RGB_565`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `U32`, `U32_2`, `U32_3`, `U32_4` | `I32`, `I32_2`¸ `I32_3`¸ `I32_4` | `RGB_888`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `U64`, `U64_2`, `U64_3`, `U64_4` | `I64`, `I64_2`, `I64_3`, `I64_4` | `A_8`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `F32`, `F32_2`, `F32_3`, `F32_4` | `F64`, `F64_2`, `F64_3`¸ `F64_4` | `YUV`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `MATRIX_2X2` | `MATRIX_3X3` | `MATRIX_4X4` |'
  prefs: []
  type: TYPE_TB
- en: '`U` = unsigned integer, `I` = signed integer, `F` = float'
  prefs: []
  type: TYPE_NORMAL
- en: '`8`, `16`, `32`, `64` = byte count. For example `I8` = 8-bits signed `int`
    (that is, a signed char)'
  prefs: []
  type: TYPE_NORMAL
- en: '`_2`, `_3`, `_4` = Number of elements for vectors (`I8_3` means vector of 3
    signed int)'
  prefs: []
  type: TYPE_NORMAL
- en: '`A_8` represents an Alpha channel (with each pixel represented as an unsigned
    char).'
  prefs: []
  type: TYPE_NORMAL
- en: Internally, Elements are described with a **DataType** (such as `UNSIGNED_8`
    for an unsigned char) and a **DataKind** (such as `PIXEL_RGBA` for a pixel). The
    DataKind is used with something called **Samplers** for graphics data that is
    interpreted on the GPU (see [Chapter 6](ch06.html "Chapter 6. Rendering Graphics
    with OpenGL ES"), *Rendering Graphics with OpenGL ES*, about OpenGL ES to better
    understand what is a Sampler). DataType and DataKind are for more advanced usage
    and should be transparent to you most of the time. You can have a look at the
    full list of elements at [http://developer.android.com/reference/android/renderscript/Element.html](http://developer.android.com/reference/android/renderscript/Element.html).
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the type of input/output Element is not enough. Their number is also
    essential, as this determines the whole Allocation size. This is the role of `Type`,
    which can be set up with 1 dimension, 2 dimensions (typically for bitmaps), or
    3 dimensions. Some other information is also supported, such as the YUV format
    (NV21 being the default in Android as seen in [Chapter 4](ch04.html "Chapter 4. Calling
    Java Back from Native Code"), *Calling Java Back from Native Code*). So, in other
    words, `Type` describes a multi-dimensional array.
  prefs: []
  type: TYPE_NORMAL
- en: Allocations have a specific flag to control how Mipmaps are generated. By default,
    most Allocations will not need one (`RS_ALLOCATION_MIPMAP_NONE`). However, when
    used as the input of a graphics texture, Mipmaps are either created in script
    memory (`RS_ALLOCATION_MIPMAP_FULL`) or when uploaded to the GPU (`RS_ALLOCATION_MIPMAP_ON_SYNC_TO_TEXTURE`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we create the Allocation from a Type and an Element, we can take care
    of creating and setting up Intrinsics. RenderScript provides a few of them, which
    are not many, but mainly focused on image processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Intrinsic | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '| To blend two Allocations together, for example, two images (we will see additive
    blending in the last part of this chapter). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '| To apply a blur effect on a Bitmap. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '| To apply a color matrix to an Allocation (for example, to adjust image hue,
    change colors, and so on). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '| To apply a convolve matrix of size 3 to an Allocation (many image filters
    can be implemented with a convolve matrix, including blurring). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '| This is the same as `ScriptIntrinsicConvolve3x3` but with a matrix of size
    5. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '| This is used to apply a histogram filter (for example, to improve the image
    contrast). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '| This is used to apply a "Lookup Table" per channel (for example, to translate
    a given red value in a pixel to another predefined value in the table). |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '| This is used to resize a 2D Allocation (for example, to scale an image).
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '| To translate YUV images coming, for example, from a camera to an RGB image
    (like we did in [Chapter 4](ch04.html "Chapter 4. Calling Java Back from Native
    Code"), *Calling Java Back from Native Code*). The binding of this Intrinsic in
    the NDK is bugged and, thus, unusable at the time this book was written. If you
    really need it, apply it from Java. |'
  prefs: []
  type: TYPE_TB
- en: Each of these Intrinsics requires its own specific parameters (for example,
    the radius for a blur effect). Full Intrinsics documentation can be found at [http://developer.android.com/reference/android/renderscript/package-summary.html](http://developer.android.com/reference/android/renderscript/package-summary.html).
  prefs: []
  type: TYPE_NORMAL
- en: Intrinsics require an input and output Allocation. It is technically possible
    to use an input as an output if the kind of function applied is appropriate. This
    is not the case, for example, `ScriptIntrinsicBlur` as a blurred pixel could be
    written at the same time it is read to blur other pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Once Allocations are set, an Intrinsic is applied and performs its work. After
    that, the result must be copied to the output memory area with one of the `copy***To()`
    methods (`copy2DRangeTo()` for a bitmap, which has two dimensions or `copy2DStridedTo()`
    if there are gaps in the target area). Data copying is a prerequisite step before
    making use of the computation result.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some problems have been reported on some devices when the size of an image Allocation
    was not a multiple of 4\. This will probably remind you of OpenGL textures, which
    have the same requirements. So, try to stick with dimensions that are multiples
    of 4.
  prefs: []
  type: TYPE_NORMAL
- en: Although the Intrinsics provided by RenderScript are really useful, you may
    want more flexibility. Maybe you need your own custom image filter, or a blur
    effect of more than 25 pixels, or maybe you do not want to process images at all.
    Then, RenderScript Kernels might be the right answer for you.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom Kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RenderScript gives you the ability to develop small custom "scripts" instead
    of the built-in Intrinsics. These programs are called Kernels and are written
    in a C-like language. They are compiled to an intermediate language by the RenderScript
    LLVM-based compiler at build time. Finally, they are translated to machine code
    at runtime. RenderScript takes care of platform-dependent optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now see how to create such a Kernel by implementing a custom image effect
    that filters pixels according to their luminosity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `RenderScript_Part2`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – writing a luminance threshold filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's append a new component to our UI and implement the new image filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new **Threshold** `SeekBar` and `Button` in `res/activity_renderscript.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Edit `RenderScriptActivity` and bind the **Threshold** `SeekBar` and `Button`
    to a new native method `threshold()`. This method is similar to `blur()`, except
    that it takes a threshold float parameter in the range [`0`, `100`].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write our own `jni/threshold.rs` filter using the RenderScript
    language. First, use pragma directives to declare:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The script language version (currently, only `1` is possible)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java package name the script is associated with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Then, declare an input parameter `thresholdValue` of type `float`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We also to need two constant vectors of 3 floats (`float3`):'
  prefs: []
  type: TYPE_NORMAL
- en: The first value represents a `BLACK` color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second value a predefined `LUMINANCE_VECTOR`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the root function of the script named `threshold()`. It takes a vector
    of 4 unsigned char, that is, an RGBA pixel in input, and returns a new one in
    output. Prepend `__attribute__((kernel))` to indicate that this function is the
    main script function, that is, the "Kernel''s Root". The function works as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It converts the input pixel from a vector of char, with each color component
    in the range [`0`, `255`], to a vector of float value with each component in the
    range [`0.0`, `1.0`]. This is the role of the function `rsUnpackColor8888()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a float vector, some of the many mathematical functions provided
    by RenderScript can be applied. Here, a dot product with a predefined luminosity
    vector for the RGBA color space returns the relative luminosity of a pixel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this information, the function checks whether a pixel's luminosity is sufficient
    according to the given threshold. If not, the pixel is set to black.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it converts a pixel's color from a float vector to an unsigned char
    vector with `rsPackColor8888()`. This value will then be copied by RenderScript
    into the final Bitmap as we will see.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: To compile our new `threshold.rs` script, list it in the `Android.mk` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'During the compilation process, `ScriptC_threshold.h` and `ScriptC_threshold.cpp`
    is generated in `obj/local/armeabi-v7a/objs-debug/renderscript`. These files contain
    the code to bind our code with the **Threshold Kernel** executed by RenderScript.
    So, we also need to append the directory to the `LOCAL_C_INCLUDES` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Include the generated header in `jni/RenderScript.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Then, implement the new method `threshold()`, respecting the JNI naming convention.
    This method is similar to `blur()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, instead of instantiating a predefined Intrinsic, we instantiate a Kernel
    generated by RenderScript. This Kernel is named `ScriptC_threshold` according
    to our RenderScript filename.
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter `thresholdValue` defined in our script can be initialized
    with `set_thresholdValue()` generated by RenderScript. Then, the main method `threshold()`
    can be applied using the generated method `forEach_threshold()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the Kernel has been applied, the result can be copied on the target bitmap,
    such as with Intrinsics, using `copy2DRangeTo()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the project, increase the new `SeekBar`, and click on the **Threshold**
    button. The output `ImageView` should display the filtered picture with only luminous
    pixels as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/9645_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have written and compiled our first RenderScript Kernel. Kernel scripts
    have a `.rs` extension and are written in a language inspired by C99\. Their content
    starts with pragma definitions that bring additional "meta" information about
    them: the language version (which can be only 1) and the Java package. We can
    also use them to tweak the floating point precision for calculations with pragma
    directives `(#pragma rs_fp_full, #pragma rs_fp_relaxed`, or `#pragma rs_fp_imprecise`).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Java package is important for the RenderScript runtime, which needs to resolve
    compiled Kernels during execution. When using the RenderScript Compatibility library,
    scripts compiled with the NDK (that is stored in the `jni` folder) might not get
    resolved. In that case, a possible solution is to make a copy of the `.rs` files
    in the Java `src` folder in the appropriate package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kernels are, in a way similar, to Intrinsics. Indeed, once compiled, the same
    process applies to them: creating the allocations, the Kernel, setting everything
    up, applying, and finally, copying the result. When executed, a Kernel function
    is applied on each Element of the input and returned in the corresponding output
    allocation Element, in parallel.'
  prefs: []
  type: TYPE_NORMAL
- en: You can set up a Kernel through the NDK binding API and an additional binding
    layer (more commonly called the **reflected** layer), which is generated at compile
    time. Each compiled script is "reflected" by a C++ class, whose name is defined
    according to the script filename prefixed with `ScriptC_`. The final code is generated
    in the **eponym** header and the source files in the `obj` directory, one for
    each per ABI. The reflected classes are your only interface with the script file,
    as a kind of wrapper. They perform some runtime checks on the kind of Allocation
    passed in the input or output of the Kernel to ensure their Element type matches
    what is declared in the script file. Have a look at the generated `ScriptC_threshold.cpp`
    in the project `obj` directory for a concrete example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kernel input parameters are passed from the reflected layer to the script file
    through global variables. Global variables correspond to all the non-`static`
    and non-`const` variables, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: They are declared outside functions such as a C variable. Global variables are
    made available in the reflected layer through setters. In our project, the `thresholdValue`
    global variable is passed through the generated method `set_thresholdValue()`.
    Variables do not have to be primitive types. They can also be pointers, in which
    case the reflected method name is prefixed with `bind_`. and expects an Allocation.
    Getters are also provided in the generated classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, static variables, declared in the same scope as global variables,
    are not accessible in the NDK reflected layer and cannot be modified outside of
    the script. When marked `const`, they are obviously treated as constants, like
    the luminance vector in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The main Kernel functions, more commonly called **root functions**, are declared
    like a C function except that they are marked with `__attribute__((kernel))`.
    They take as parameter the Element type of the input Allocation and return the
    type of Element of the output Allocation. Both the input parameter and return
    value are optional but at least one of them must be present. In our example, the
    input parameter and the output return value is a pixel Element (that is, a vector
    of 4 unsigned char; 1 byte for each color channel):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'RenderScript root functions can be also given additional index parameters that
    represent Element position (or "coordinates") within its Allocation. For example,
    we can declare two additional `uint32_t` parameters to get pixel Element coordinates
    in `threshold()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple root functions with different names can be declared in one script.
    After compilation, they are reflected in the generated class as functions prefixed
    with `forEach_`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Before `__attribute__((kernel))` was introduced, RenderScript files could only
    contain one main function named root. This form is still allowed nowadays. Such
    functions take a pointer to the input, output Allocation in parameters, and do
    not allow return values. So the `threshold()` function rewritten as a traditional
    root method would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the `root()` function, a script can also contain an `init()`
    function with no parameter and return value. This function is called only once
    when the script is instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, the possibilities of the RenderScript language are more limited
    and constrained than traditional C. We cannot:'
  prefs: []
  type: TYPE_NORMAL
- en: Allocate resources directly. The memory must be allocated by the client application
    before running the Kernel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write low-level assembly code or do fancy C stuff. However, hopefully, plenty
    of familiar elements of the C language are available, such as `struct`, `typedef`,
    `enum` and so on; even pointers!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use C libraries or runtime. However, RenderScript provides a full "runtime"
    library with plenty of math, conversion, atomic functions, and so on. Have a look
    at [http://developer.android.com/guide/topics/renderscript/reference.html](http://developer.android.com/guide/topics/renderscript/reference.html)
    for more details about them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A method provided by RenderScript that you may find particularly useful is `rsDebug()`,
    which prints debug log to ADB.
  prefs: []
  type: TYPE_NORMAL
- en: Even with those limitations, RenderScript constraints are still quite relaxed.
    A consequence is that some scripts might not benefit from maximum acceleration,
    for example, on the GPU, which is quite restricting. To overcome this issue, a
    limited subset of RenderScript called **FilterScript** was designed to favor optimization
    and compatibility. Consider it if you need maximum performance.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the RenderScript language capabilities, have a look
    at [http://developer.android.com/guide/topics/renderscript/advanced.html](http://developer.android.com/guide/topics/renderscript/advanced.html).
  prefs: []
  type: TYPE_NORMAL
- en: Combining scripts together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Unity is strength* could not be truer than with RenderScript. Intrinsics and
    Kernels alone are powerful features. However, combined together, they give its
    full strength to the RenderScript framework.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now see how to combine the **Blur** and **Luminosity** threshold filters
    together with a blending Intrinsic to create a great-looking image effect.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting project is provided with this book under the name `RenderScript_Part3`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – combining Intrinsics and scripts together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's improve our project to apply a new combined filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new **Combine** `Button` in `res/activity_renderscript.xml`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Bind the **Combine** button to a new native method `combine()`, which has the
    parameters of both `blur()` and `threshold()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit `jni/RenderScript.cpp` and add the new `combine()` method, following the
    JNI convention again. The method performs similarly to what we saw previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The RenderScript engine is initialized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitmaps are locked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The appropriate Allocation is created for the input and output bitmaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need a temporary memory area to store the result of computations.
    Let''s create a temporary allocation backed by a memory buffer `tmpBuffer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the Kernels and Intrinsics we need for the combined filter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Threshold` Kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Blur` Intrinsic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An additional `Blend` Intrinsic that does not require parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, combine the multiple filters together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, apply the Threshold filter and save the result into the temporary allocation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, apply the Blur filter on the temporary Allocation and save the result
    in the target bitmap Allocation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, blend both the source and the filtered bitmap using an additive operation
    to create the final image. Blending can be done "in-place", without an additional
    Allocation, since each pixel is read and written only once (to the opposite of
    the blur filter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, save the result and free resources. All values wrapped in a `sp<>`
    (that is, a smart pointer) template, such as `tmpAlloc`, are freed automatically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the project, tweak the `SeekBar` components, and click on the **Combine**
    button. The output `ImageView` should display a "remastered" picture, where the
    luminous parts are highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/9645_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We chained multiple Intrinsics and Kernels together to apply a **Combine** filter
    to an image. Such a chain is easy to put in place; we basically need to connect
    the output Allocation of one script to the input Allocation of the next. Copying
    data to the output memory area is really only necessary at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's really sad but script grouping features are not yet available on the Android
    NDK API, only on the Java side. With the script grouping feature, a full "graph"
    of scripts can be defined allowing RenderScript to optimize the code further.
    If you need this feature, then you can either wait or go back to Java.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, Allocations can be reused if necessary in multiple scripts, to avoid
    allocating useless memory. It is even possible to reuse the same Allocation in
    input and output, if the script allows "in-place" modifications. This is not the
    case, for example, of the **Blur** filter, which would rewrite blurred pixels
    while they are read to blur other pixels, resulting in weird visual artefacts.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Speaking of reuse, it is good practice to reuse RenderSript objects (that is
    the RS context object, Intrinsics, Kernels, and so on) between executions. This
    is even more important if you repeatedly perform a computation, such as processing
    images from the camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'Memory is an important aspect of RenderScript performance. Used badly, it can
    decrease efficiency. In our project, we provided a pointer to the Allocations
    we created it. This means that the Allocations we created in our project are "backed"
    with native memory, in our case, the bitmap content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: However, data can also be copied before processing from the input memory area
    into the allocation using the `copy***From()` methods, which are the pendant of
    the `copy***To()` methods. This is especially useful with the Java binding side,
    which does not always allow the use of "backed Allocation". The NDK binding is
    more flexible and input data copying can be avoided most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: RenderScript provides others mechanisms to communicate data from a script. The
    first ones are the methods `rsSendToClient()` and `rsSendToClientBlocking()`.
    They allow a script to communicate a "command", optionally with some data, to
    the calling side. The latter method is obviously a bit more dangerous in terms
    of performances, and should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Data can also be communicated through pointers. Pointers are dynamic memory
    that allows bi-directional communication between the Kernel and the caller. As
    indicated previously, they are reflected in the generated classes with a method
    prefixed with `bind_`. The appropriate getters and setters should be generated
    in the reflected layer at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: However, the NDK RenderScript framework does not reflect structures declared
    in RenderScript files yet. So declaring a pointer to `struct` defined in a script
    file will not work for now. Pointers to primitive types work using Allocations
    though. Thus, expect annoying limitations on the NDK side on this subject.
  prefs: []
  type: TYPE_NORMAL
- en: Let's end on the subject of memory by saying that in case you need more than
    one input or output Allocations for a script, there is a solution, an `rs_allocation`,
    which represents an Allocation reflected through a getter and setter. You can
    have as many of them as you want. Then, you can access dimensions and elements
    through the `rsAllocationGetDim*()`, `rsGetElementAt*()`, `rsSetElementAt*()`
    methods, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `threshold()` method could be rewritten the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that since we do not pass an input Allocation in parameter, return one
    as usual
  prefs: []
  type: TYPE_NORMAL
- en: The `for` loops are not implicit like it would be with an Allocation passed
    in parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `threshold()` function cannot be a Kernel root. It is perfectly possible
    to use input Allocation in conjunction with `rs_allocation` though.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the Kernel would be called in the following way. Note how the method
    that applies the effect is prefixed with `invoked_` (instead of `forEach_`). This
    is because the `threshold()` function is not a Kernel root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: For more information about the RenderScript language capabilities, have a look
    at [http://developer.android.com/guide/topics/renderscript/advanced.html](http://developer.android.com/guide/topics/renderscript/advanced.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced RenderScript, an advanced technology to parallelize
    intensive computation tasks. More specifically, we saw how to use predefined RenderScript
    built-in Intrinsics, which are currently mainly dedicated to image processing.
    We also discovered how to implement our own Kernels with the RenderScript custom
    language inspired by C. Finally, we saw an example of an Intrinsics and Kernels
    combination to perform computations that are more complex.
  prefs: []
  type: TYPE_NORMAL
- en: RenderScript is available from either the Java or the native side. However,
    let's be clear, apart from the exception of Allocations backed by memory buffers
    (a rather important feature for performance though), RenderScript is still more
    useable through its Java API. Grouping is not available, `struct` is not reflected
    yet, and some other features are still buggy (for example YUV Intrinsics).
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, RenderScript aims at giving tremendous computing power to the developers
    who neither have the time nor the knowledge to follow the native path. Thus, the
    NDK is not well-served yet. Although that will probably change in the future,
    you should be ready to keep at least parts of your RenderScript code on the Java
    side.
  prefs: []
  type: TYPE_NORMAL

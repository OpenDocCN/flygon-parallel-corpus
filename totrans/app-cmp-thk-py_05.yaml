- en: '*Chapter 4*: Understanding Logical Reasoning'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore logical reasoning processes such as conditional
    statements, algorithmic reasoning, and Boolean logic. We will explore inductive
    and deductive reasoning before delving deeper into some logic operators. We will
    also learn about logic errors, how to identify them, and how to correct them.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we will be looking at writing algorithms using logic to solve computational
    thinking problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the importance of logical reasoning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Boolean logic and operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying logic errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When solving computational thinking problems, logical reasoning is necessary.
    We all know that programming code has steps that are followed linearly. Imagine
    we have 10 lines of code. If we do not apply logical reasoning, the code reads
    one line at a time—reads the first line, reads the second line, and so on until
    the last one. Using logical reasoning allows us to compare things before moving
    on, return to a previous line of code, and much more. Throughout this chapter,
    we will learn about logical reasoning in order to create algorithms that address
    problems in efficient ways using logic operators.
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand logical reasoning, we will begin by defining logic in
    general, then how to use logic when designing and writing algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the latest version of Python to run the codes in this chapter.
    You will find the full source code used in this chapter here: [https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter04](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter04)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the importance of logical reasoning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we worked through [*Chapter 3*](B15413_03_Final_SK_ePub.xhtml#_idTextAnchor056),
    *Understanding* *Algorithms and Algorithmic Thinking*, we learned how to design
    some basic algorithms while solving computational thinking problems.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will understand how important logical reasoning is and how
    to apply the types of logical reasoning with the help of examples.
  prefs: []
  type: TYPE_NORMAL
- en: As we write algorithms, we'll need to use logical reasoning to create these
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In simple terms, **logical reasoning** is the set of steps followed to reach
    a conclusion. In computational thinking, when we design algorithms, the systematic
    set of steps we follow are part of the algorithm. The way a computer reads those
    algorithms depends on how we write that algorithm. There are two types of logical
    reasoning arguments, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inductive reasoning**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deductive reasoning**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we define those in more depth, let's look at why logical reasoning is
    so important and why order matters when we create algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: In order to analyze a problem and provide an algorithm that helps us tackle
    the problem, we need to understand what logical reasoning is first. Logic can
    be daunting for some, but we use it every day subconsciously.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a simple example. Say you take a shower every morning and go to
    work. *Well, would you get dressed for work before the shower?* No, because that
    would make absolutely no sense. Logically, you'd have to shower first before you
    put on your clothes for work. Now, I've skipped a ton of steps here, but those
    steps are logical steps. Other examples of logic include following recipes, using
    an umbrella if it's raining (or not), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we'll weave in and out of logical reasoning and designing
    algorithms using **logical operators**. A logical operator allows a program to
    make decisions. We use those too in everyday life without realizing it. For example,
    if it's sunny and warm, we may want to go biking, but not if it's sunny and cold.
    The *and* here is a logical operator.
  prefs: []
  type: TYPE_NORMAL
- en: We take a lot of things into consideration when we're making decisions. In computational
    thinking, especially in algorithm design, we need to consider those things and
    provide a way for the program to test those conditions. We will delve deeper into
    logical operators later in this chapter. For now, let's look more closely at the
    types of logical reasoning and how to apply them.
  prefs: []
  type: TYPE_NORMAL
- en: Applying inductive reasoning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we talk about inductive reasoning, we're really working backward. Inductive
    reasoning starts from a conclusion, which may be true or not, and works backward
    to create the code using the existing data. Let's look at a simple problem first.
  prefs: []
  type: TYPE_NORMAL
- en: Solving an inductive reasoning sample problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have a budget of $150 for buying supplies: art pencils and erasers. The
    art pencils are $1.75 each and the erasers are $1.50 each.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, in computational thinking, we decompose the problem first, then we
    identify the pattern, then we generalize that pattern, and then we create the
    algorithm. So, let's recognize that pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at what we know so far and name some variables:'
  prefs: []
  type: TYPE_NORMAL
- en: The total budget is $150.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cost of pencils is $1.75 each.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cost of erasers is $1.50 each.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's denote the number of pencils by *p*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's denote the number of erasers by *n*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that when we get to that algorithm, we may want to rename those variables.
    But for now, since we're going to look at mathematical algorithms first, we'll
    keep the simple variables.
  prefs: []
  type: TYPE_NORMAL
- en: We can do this in one inequality. *Why an inequality and not an equation?* Because
    our total may not be exactly $150\. But it can't be *more* than $150 because that's
    all the money we have.
  prefs: []
  type: TYPE_NORMAL
- en: Because this is a simple problem, we're identifying and generalizing that pattern
    in one move.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the number of pencils times the cost plus the number of erasers times the
    cost is less than or equal to $150:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/Formula_B15413_04_001.png)'
  prefs: []
  type: TYPE_IMG
- en: Now let's talk about the algorithm design. Maybe this is something I buy regularly
    because I run art classes. I'm going to go off that scenario. Maybe my employer
    gives me at most $150, but depending on what I used before, I may need more pencils
    than erasers and vice versa. So, I need a program that I can use and reuse at
    the beginning of every term. *Was this part of my problem?* No, this was an ill-defined
    problem. So, I'm adapting the problem based on a set of particular needs. In short,
    I'm defining the problem I want to solve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: As a side note for an inductive and deductive reasoning dilemma, it is important
    to understand that conditional statements, such as the `if`/`then` statements
    we use often in programming, are usually associated with deductive reasoning.
    We can go into a debate about whether or not they can be inductive, but the truth
    is, inductive reasoning problems will use deductive reasoning. We will look in
    depth at deductive reasoning statements in the next section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, I want the program to ask me how many pencils I want or I want it to ask
    me how many erasers I want. It all depends! Let''s look at what the program should
    do for us. The following steps show us this:'
  prefs: []
  type: TYPE_NORMAL
- en: Ask whether your input will be pencils or erasers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose an inequality to use based on the input provided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify how many of the pencils or erasers are possible (given the input).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give a total cost for the number of pencils and erasers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please note that, as always, there are a lot of ways to arrive at the same answers
    in Python. While some of these programs are longer than what I would normally
    present, since we're learning both computational thinking and Python programming,
    it's important to show steps that are easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: For this particular program, we're going to need to import the math functions
    so that we can round down. *Why do we need to do that?* Well, we can't buy parts
    of erasers and pencils, only whole pencils and whole erasers. So, if the program
    says we can buy 19.5 pencils, that really means we can only purchase 19 pencils.
  prefs: []
  type: TYPE_NORMAL
- en: The `math.floor()` function allows us to round that number down to 19 with the
    simple function. We will explore more of the `math` functions as we go along in
    this book. Before we leave this quick topic, you should know that the `math` module
    in Python has built-in functions that align with the C language functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the problem. Take a look at the following written program:'
  prefs: []
  type: TYPE_NORMAL
- en: ch4_inductiveP1.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that the preceding program will run the lines of code in order (sequentially).
    So, if a user inputs `erasers` first, then the first `if` statement and the nested
    `if` statement are ignored. If the user enters `pencils` first, then the algorithm
    runs normally from the first `if` statement and goes through the remaining conditions.
    Here''s what the program does, in order:'
  prefs: []
  type: TYPE_NORMAL
- en: Asks the user to input whether they are buying pencils or erasers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user enters pencils, then the program asks how many pencils they'll purchase.
    Then, it calculates the number of erasers they can afford to buy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user enters a number of pencils that is too large, they'll get a message
    that they can't afford that amount.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user enters erasers, then the program asks how many erasers they'll purchase,
    then calculates the number of pencils the user can afford to buy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user enters a number of erasers that is too large, they'll get a message
    that they can't afford that amount.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user enters neither pencils nor erasers, they'll get a message to run
    the program again and enter one of those two options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding is an oversimplified inductive reasoning problem. Some inductive
    reasoning problems will ask that you look at data, make some probable conclusions,
    and then write a program to test those conclusions. In the process of learning
    logical reasoning, we are essentially training ourselves to look at decisions
    and how to process them in a way that a program can return the output we are looking
    for.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note here that there are multiple ways to look at problems
    and prepare solutions. While I prefer decision trees and flow-charts, other programmers
    and developers work more mathematically. Yet others like to write down what the
    program needs to do in simple sentences and/or paragraphs. The point of this process
    is to allow us to create a program that produces the necessary output and is easy
    to follow logically by both the programmers and developers and the computer running
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at deductive reasoning.
  prefs: []
  type: TYPE_NORMAL
- en: Applying deductive reasoning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're now at the section of this chapter that focuses on deductive reasoning.
    Even when I was a mathematics student, I found deductive reasoning fascinating.
    I quickly learned that mathematics taught us how to follow arguments logically
    in geometry and I fell in love with all things logic and truth tables.
  prefs: []
  type: TYPE_NORMAL
- en: Logic is taught using proofs and inductive and deductive reasoning. Truth tables
    help us analyze conditions. In truth tables, some things are assumed. For example,
    a statement is either true or false. The other statement is true or false. A combination
    of those statements depends on whether or not the statements are true or false.
  prefs: []
  type: TYPE_NORMAL
- en: Alright, that's a bit complicated. Before I move on to explain deductive reasoning,
    let's look at a quick truth table and the logic process it contains.
  prefs: []
  type: TYPE_NORMAL
- en: Truth tables were critical when I first started coding. They helped me understand
    the coding processes and how to work with conditions. Not every programmer or
    coder uses these tables, but I find them helpful, even if not used explicitly
    in the decision-making process. Let's look at one now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have a statement or condition `p` and that condition is `True`.
    Let''s say that we have another statement or condition `q` and that it is also
    `True`. In truth tables, we use the symbol ¬ to denote *NOT*. So, ¬ `p` ¬ is `False`
    and ¬ `q` is also `False`. That''s because if `p` is `True`, then *NOT* `p` is
    *NOT* `True`, in other words, `False`. The symbol ![](image/AND_symbol.png) is
    used for *AND*, so `p` *AND* `q` is written as `p ![](image/AND_symbol1.png) q`.
    The symbol `![](image/OR_symbol.png)` is used for *OR*, so `p` *OR* `q` is written
    as `p ![](image/OR_symbol.png) q`. In table format, our truth table looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Truth table'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.1_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Truth table
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing a truth table and understanding all the possible conditions can take
    time, but the process is similar to what we go through in logical reasoning when
    writing algorithms for problems. Now, let's take a closer look at deductive reasoning.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first define what deductive reasoning is. **Deductive reasoning** is the
    process of going from a statement or hypothesis to a conclusion. Because deductive
    reasoning is what we use in algorithmic design, for the most part, we will need
    to define some terms associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with conditional statements.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about conditional statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Conditional statements** are if/then statements. Here are a few logical arguments
    using conditional statements:'
  prefs: []
  type: TYPE_NORMAL
- en: If it rains, then I'll use an umbrella.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If I drink water, then I won't be thirsty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If my dog needs to go out, then he stands by the door.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a quadrilateral has four right angles, then it is a rectangle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the preceding statements are examples of conditional statements. The first
    part of the statement is called the **hypothesis**. The second part of the statement
    is the **conclusion**. In the statement *If it rains, then I'll use an umbrella*,
    the hypothesis is *it rains* and the conclusion is *use an umbrella*. We do not
    include *if* or *then* in the hypotheses and conclusions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, as you saw in the example in the *Applying inductive reasoning*
    section, we use `if`/`then` statements when writing algorithms often. Here are
    some of the logical statements we use in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if`: When using `if` statements, we ask whether a condition is met, then do
    something based on that true or false condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if-else`: When using `if-else` statements, we test one condition and do something,
    but if that condition is not met, then we do something else.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if-elif-else`: When using `if-elif-else` statements, we have one condition;
    if that''s not met, we test another condition—that is, the **else if** (**elif**)
    condition—otherwise, we do something else.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the preceding statements can be nested. I can test one condition, then
    another, then another. I can have multiple `elif` statements between `if` and
    `else`, and so on. Let's look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: if statements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s look at a program that only uses one `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: ch4_ifStatement.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, the preceding code is a simple program, and one that only checks one condition.
    We could add conditions to test whether `number` is equal to `100`. We can add
    another one if `number` is larger than `100`, and so on. In this case, we only
    cared if `number` was below `100`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we input the number `53`, we''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we input the number `100`, we won''t get any message at all and the program
    will end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you see, the program doesn't have anything to add. The condition wasn't met,
    so it ended. That's why `if-else` statements can come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: if-else statements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s look at the previous algorithm and add an `else` statement. The previous
    program only checked whether the number provided was less than `100`. If we add
    an `else` statement, we can print something else on the screen for all numbers
    greater than or equal to `100`. Take a look at the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: ch4_if-elseStatement.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding program now prints out a message regardless of what number the
    user gives as input. Let''s test out `100` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `100` is included in the large numbers category because our
    condition is that the numbers are less than `100`. That means `100` is not included
    in the condition. Testing conditions is how we arrive at conclusions in Python.
    We write algorithms that gather information from the program itself or user input,
    then it tests conditions to make decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following chart diagram shows the flow chart for `if-else` decision-making.
    We''ll look at additional flowcharts when looking at `if-elif-else` statements
    and nested statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – if-else statement decision flowchart'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.2_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – if-else statement decision flowchart
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding diagram, this is a binary decision. The statement
    will be tested to check whether it's **True** or **False**. If **True**, an action
    happens; otherwise, another action happens. For our number program, if the number
    was under `100`, one message is printed; otherwise, another message, `I guess
    you like large numbers`, is printed on the screen. Now, let's add multiple conditions.
  prefs: []
  type: TYPE_NORMAL
- en: if-elif-else statements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An `if-elif-else` statement is a simplification of a multi-condition statement—that
    is, you can have multiple `elif` statements. As mentioned earlier, **elif** stands
    for **else if**. Let''s change our program up a bit. We''ll allow the user to
    input a number between `1` and `20`. Here''s what we''ll program the algorithm
    to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Ask for a number between `1` and `20`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test whether the number is between `1` and `10` and print a message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test whether the number is between `11` and `20` and print a message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print an error message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's take a look at how we'd program this. We need to remember a few things
    before we write this algorithm. To check numbers between `1` and `10` easily,
    we need to check that the number is less than `10`. That means `10` is not included.
  prefs: []
  type: TYPE_NORMAL
- en: Our `elif` statement would then check for numbers under `21`, since it will
    only include numbers we haven't tested yet. That is, if the user inputs `12`,
    the first condition isn't met, so it moves to the second condition. Yes, that
    would include all numbers under `21`, but keep in mind that if the number had
    been less than `10`, it will have already met a condition and the program would
    have printed the right message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if the condition isn''t met, we need to let users know they wrote
    a number that''s not between `1` and `20`. The following program demonstrates
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: ch4_if-elif-elseStatement.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to test this with a number under `10`. If we run the program with
    the number `8`, we see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the program with the number `10`, we see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if we run the program with the number `21`, this is what we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, each condition provides us with the answer for that given condition.
    Here''s the flowchart for `if-elif-else` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – if-elif-else statements decision flowchart'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.3_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – if-elif-else statements decision flowchart
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding diagram, `elif` just presents a new test. If
    **True**, we follow the action from the algorithm. If **False**, we move on to
    the `else` statement. That said, we can have multiple `elif` conditions. That
    means we can continue to test conditions one after the other unless and until
    we reach an `else` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding nested statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another type of logic statement we use in Python has to do with nested statements.
    In nested conditions, the `if` statement that is nested is only followed if the
    previous `if` statement is **True**. This is easier to understand with an example.
    Let''s go back to our `if-elif-else` statement and add some nested conditions.
    We had previously asked the user to give a number between `1` and `20`. Now, let''s
    say we want to subdivide the conditions further using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: ch4_nestedStatements.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the code has a message for any time we enter
    numbers that do not meet the guidelines. For example, the input requested is between
    `1` and `20`. *But what happens if the user types 0 or 21, or another number not
    in that range?* Then, the `print()` statement provides a message that asks the
    user to run the program again.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, you can see that we have `if` statements, `elif` statements,
    nested `if` and `else` statements, and so on. Let''s see a few test cases that
    test a few conditions to see what our program says:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we input `4`, the following output is seen:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When we input `6`, we see the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When we input `11`, we get this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When we input `18`, we get the following output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding test cases, we have more outputs based on
    the conditions given in the program. While this was a simple number program, we
    can use similar logic when we are solving more complex problems.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say you run an online store. The selections a user makes for items are
    going to be used in similar algorithms, albeit much more complex ones. The algorithm
    tests the conditions, such as items selected, quantities selected, and so on to
    apply totals, coupons, and much more. That's why logic and logical reasoning is
    so important in programming.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as mentioned previously, the logical processing we use can be different
    for individual programmers. However, regardless of preference, logical reasoning
    and logical processing are absolutely necessary when we are writing algorithms.
    Rather than diving into the writing, we process problems, look at the decision-making
    and which steps need to happen, and then we design the algorithm. That logical
    process is critical to creating effective algorithms. We will continue to look
    at logical reasoning throughout this book as we analyze problems, even if we don't
    explicitly state so.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about logical reasoning and its two types—inductive
    and deductive reasoning. We also learned about the conditional statements that
    will come in handy while coding.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the algorithms we write can be simplified using Boolean logic and operators,
    which is what we'll take a look at in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Boolean logic and operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boolean logic refers to the operators, namely, `and`, `or`, and `not` in Python.
    You'll recall seeing this in the brief discussion on truth tables earlier in this
    chapter. As we'll see next, we use the same logical processing when writing the
    algorithms, even if the tables are not explicitly stated or used. When solving
    computational thinking problems, we sometimes have to meet multiple conditions
    at once. Let's look at this using just language for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s sort some fruit. If the fruit is round and orange, green, or yellow,
    it will be sorted into **group 1**. If the fruit is not round, but is orange,
    green, or yellow, it will be sorted into **group 2**. If the fruit doesn''t match
    those requirements, it goes into **group 3**. Let''s simplify these groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Group 1**: Round AND (orange OR green OR yellow)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Group 2**: Not round AND (orange OR green OR yellow)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Group 3**: All other fruit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I know I stated the round condition first. But if you take a look at *groups
    1* and *2*, the fruits need to be tested for those colors for both conditions—that
    is, if that condition is not met for color, it doesn''t matter whether the fruit
    is round or not, it goes in *group 3*. So, here''s what I''d write for an algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Test whether fruit is orange, green, or yellow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If yes, test whether round, and sort into *group 1* or *2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If no, sort into *group 3*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, if we had a mandarin orange, that falls under *group 1*. If we had a banana,
    it would be in *group 2*. If we had strawberries, they would be in *group 3*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we were going to write this, we'd need to make sure we've added the
    characteristics of the fruits so that we can test them against something. We will
    be looking at something like that in further chapters of this book, but for now,
    to simplify some of the learning, we'll create a similar algorithm but with numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on too much, let''s take a quick look at the basic operators
    in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Basic Python operators'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.4_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Basic Python operators
  prefs: []
  type: TYPE_NORMAL
- en: We'll go deeper into these operators when we get to *Section 2*, *Applying Python
    and Computational Thinking*, and take a deeper look at the Python programming
    language. However, we will need to use some of these for the next algorithm. First,
    let's look at the `and` operator.
  prefs: []
  type: TYPE_NORMAL
- en: The and operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand the `and` operator better, it's best to look at a mathematical
    algorithm. Let's ask for a number and test whether that number is larger than
    `100` and a multiple of `2`. To test whether a number is a multiple of `2`, we
    use the **modulo operator** (**mod**). The symbol for `mod` is `%` in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, looking at the code, if `number % 2 == 0`, then the number is divisible
    by `2`. If `number % 2 == 1`, then it is not divisible by `2`. We use the equal
    (`==`) operator or not equal (`!=`) operator to complete these conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: ch4_andOperator.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, I know we''ve talked about different ways to write algorithms. *Did I
    need to use an AND operator for this one?* Probably not. I could have just written
    it as nested statements, `if-elif-else` statements, and so on. Some test cases
    and the results of the algorithm are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we input `104`, we see the following output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When we input `80`, we see the following output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When we input `31`, we get the following output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the previous test cases, the program tests our cases and
    provides the printed messages based on the conditions met. Now, let's take a look
    at the `or` operator.
  prefs: []
  type: TYPE_NORMAL
- en: The or operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in the fruit example earlier in this chapter, we checked whether the
    color of the fruit was orange, green, or yellow. That's how an `or` operator works.
    We check for something or the other. This time, we're going to look at some `True`
    and `False` statements. Let's say that variable `A` is `True` and variable `B`
    is `False`. If we were to use an `or` operator to check the result of `A` or `B`,
    then our answer would be `True`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Why is that?* Because no matter what, the result will be either `True` or
    `False`, which is a `True` statement. *Confused?* Logic can be confusing. Let''s
    go ahead and test `A` `and` `B` as well as `A or B` in the following program to
    help you visualize this:'
  prefs: []
  type: TYPE_NORMAL
- en: ch4_orOperator.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, I added some conditions so that we'd get printouts and you could see that
    the logic I stated was right, but we didn't need to do all of this. We could have
    just printed `C` and `D`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this program, this is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `A and B` is `False` because one of the statements is `False`,
    which means the whole thing is `False`. `A or B` is `True` because one of them
    is `True`, so the condition is `True`. Now, let's look at the last operator (for
    now), the **not** operator.
  prefs: []
  type: TYPE_NORMAL
- en: The not operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `not` operator lets us test the opposite of things. So, if `A` is set as
    `True`, then `not A` is `False`. It''s as simple as that. Let''s look at a few
    examples through the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: ch4_notOperator.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: From the previous code, we've talked about the first printed statement here.
    Since `A` is `True`, `not` `A` is `False`. For the second `print` statement, we
    expect that result to be `True` because `B` is `False`. Now, we did the `A and
    B` and `A or B` statements previously. We know that `A and B` is `False`, so `not`
    `(A and B)` is `True`. We also know `A or B` is `True`, so `not` `(A or B)` is
    `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at what the program prints:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It prints the following for `not A`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for `not B`, it prints the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, for `not (A and B)`, it prints the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, for `not (A or B)`, it prints the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this section, you have learned about a few of the Boolean operators. With
    Boolean operators, we can write algorithms that test cases for us and provide
    outputs based on those cases. As mentioned, a program will run based on the instructions
    we write in the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: By writing our algorithms using these operators, we can ensure that conditions
    are applied only in the circumstances we want them to apply. Rather than having
    a program run on incorrect conditions, we can include statements and prompts to
    help produce the right outcomes. For example, if an input for distance is accidentally
    entered as negative, a Boolean statement could have checked conditions and provided
    the person with feedback within the program, then run again. Using Boolean operators
    provides clear logical processes and allows better and clearer algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've taken a look at the basic operators, it's important that we also
    look at errors. Identifying logic errors can help us avoid pitfalls in our algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying logic errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we talk too much about logic errors, let's talk about why it's important
    to keep them in mind. In Python, not all errors lead to a failed or crashed program.
    Some logic errors will allow a program to run entirely without crashing at all
    or alerting the user of an error. Those errors are hard to identify.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some logic errors that can get us in trouble, but keep in mind that
    there are many ways to incorporate logic errors into our programs accidentally:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the wrong variable in an equation or statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the wrong operator to test conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the wrong indentation when checking for conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The one I am the guiltiest of is switching my variables, but I do also make
    mistakes in indentation often. Usually, those get identified more often when I
    try to run the program, because the program may fail to run in some instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple algorithm that contains an error in a formula.
    In this first algorithm, the goal is to get the total cost after buying a number
    of orders of fries from a restaurant at a cost of $1.50 each:'
  prefs: []
  type: TYPE_NORMAL
- en: ch4_Error1.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding program, the program will run without problems/errors
    and show the following output for `12` orders of fries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we''re paying attention, we''ll realize that the cost for 12 orders
    of fries is too high at $144\. That''s because there is an error in our algorithm.
    The algorithm should contain the `total = cost * number` formula, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ch4_Error1_fixed.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve fixed that formula, the output is correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `$18.0` seems a lot more reasonable for 12 orders of fries at
    $1.50 each.
  prefs: []
  type: TYPE_NORMAL
- en: Errors in formulas can be difficult to find, especially if the program runs
    without alerting to the error. If we have a large algorithm with multiple formulas,
    finding those errors can become cumbersome and a lengthy process. The best recommendation
    for this is to test your algorithm at every step of the process you can. That
    way, finding errors becomes a simpler task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now take a look at an error when testing conditions. Much like errors
    in formula, errors in condition testing may be hard to spot, as the program may
    just run anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: ch4_Error2.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, there is an error in the algorithm that causes us to
    get incorrect feedback when entering some odd numbers. Take a look at the second
    `elif` statement. That `or` will produce an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this program, we get an output. Let''s run it with the number `99`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the problem here is that `99` is not an even number. Somewhere in the
    algorithm, we introduced an error in the conditions. In this case, instead of
    using an `and` operator, we used `or`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we replace the `or` with `and`, we can run the program again:'
  prefs: []
  type: TYPE_NORMAL
- en: ch4_Error2_fixed.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `99` as the input, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the program with `98` as the input, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, unless we're paying attention, we can miss errors in our conditions
    and logical operators. Because the program is able to run with these errors in
    our algorithm, catching where exactly we made the mistake is harder to do than
    when we incorporate errors that stop the program from running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s take a look at an indentation error using the same code for
    the condition testing. This time, with an indentation error added, we have the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: ch4_Error3.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we can''t run the program. The second `elif` statement is indented
    incorrectly. When we try to run the program, we get an `Invalid Syntax` error
    message. Clicking **OK** on the message will take us to the code and the indentation
    error is highlighted, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Indentation error'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.5_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – Indentation error
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `print()` code below the `elif` statement is also indented incorrectly.
    Once we fix those two errors, we can run the code, as we did previously in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating errors into our algorithms is a common mistake. As you can see
    from the previous examples, identifying some of the errors can be hard to do,
    since the program may be running as if there is no problem.
  prefs: []
  type: TYPE_NORMAL
- en: I may not have caught many errors with conditions in my algorithms, but that
    may just be because I never realized there was a mistake to begin with. That's
    one of the reasons why it's really important to run various instances of our programs
    to ensure that the results we get make sense. We will be discussing more errors
    as we look at programs and computational thinking problems throughout this book.
    In the meantime, test your programs and test them often. Triple check your math,
    your indentations, and your logic.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed inductive and deductive reasoning, logical reasoning,
    logical operators, and Boolean logic. As we discussed, most of the algorithm designs
    fall under deductive reasoning. We learned how to use statements, such as `if`,
    `if-else`, `if-elif-else`, and nested statements, to write programs that test
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we learned that some errors are difficult to identify, so it is
    important to verify our programs and test them often.
  prefs: []
  type: TYPE_NORMAL
- en: After going through this chapter, you are now better equipped to write algorithms
    using logical reasoning. You also have the understanding to apply inductive and
    deductive reasoning when designing and planning algorithms and use Boolean logic
    and operators in your algorithms. You are now also able to test your algorithms
    for errors by identifying possible mistakes such as indentation errors, conditional
    errors, and formula errors.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be taking a deeper dive deeper into problem analysis,
    using the computational thinking elements to break down problems so that we can
    create meaningful and useful algorithms.
  prefs: []
  type: TYPE_NORMAL

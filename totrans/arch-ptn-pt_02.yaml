- en: Part I. Building an Architecture to Support Domain Modeling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most developers have never seen a domain model, only a data model.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: Cyrille Martraire, DDD EU 2017
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Most developers we talk to about architecture have a nagging sense that things
    could be better. They are often trying to rescue a system that has gone wrong
    somehow, and are trying to put some structure back into a ball of mud. They know
    that their business logic shouldn’t be spread all over the place, but they have
    no idea how to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve found that many developers, when asked to design a new system, will immediately
    start to build a database schema, with the object model treated as an afterthought.
    This is where it all starts to go wrong. Instead, *behavior should come first
    and drive our storage requirements.* After all, our customers don’t care about
    the data model. They care about what the system *does*; otherwise they’d just
    use a spreadsheet.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the book looks at how to build a rich object model through
    TDD (in [Chapter 1](ch01.xhtml#chapter_01_domain_model)), and then we’ll show
    how to keep that model decoupled from technical concerns. We show how to build
    persistence-ignorant code and how to create stable APIs around our domain so that
    we can refactor aggressively.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we present four key design patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: The [Repository pattern](ch02.xhtml#chapter_02_repository), an abstraction over
    the idea of persistent storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Service Layer](ch04.xhtml#chapter_04_service_layer) pattern to clearly
    define where our use cases begin and end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Unit of Work pattern](ch06.xhtml#chapter_06_uow) to provide atomic operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Aggregate pattern](ch07.xhtml#chapter_07_aggregate) to enforce the integrity
    of our data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’d like a picture of where we’re going, take a look at [Figure I-1](#part1_components_diagram),
    but don’t worry if none of it makes sense yet! We introduce each box in the figure,
    one by one, throughout this part of the book.
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp p101](Images/apwp_p101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure I-1\. A component diagram for our app at the end of [Part I](#part1)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We also take a little time out to talk about [coupling and abstractions](ch03.xhtml#chapter_03_abstractions),
    illustrating it with a simple example that shows how and why we choose our abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three appendices are further explorations of the content from Part I:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Appendix B](app02.xhtml#appendix_project_structure) is a write-up of the infrastructure
    for our example code: how we build and run the Docker images, where we manage
    configuration info, and how we run different types of tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Appendix C](app03.xhtml#appendix_csvs) is a “proof is in the pudding” kind
    of content, showing how easy it is to swap out our entire infrastructure—the Flask
    API, the ORM, and Postgres—for a totally different I/O model involving a CLI and
    CSVs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, [Appendix D](app04.xhtml#appendix_django) may be of interest if you’re
    wondering how these patterns might look if using Django instead of Flask and SQLAlchemy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

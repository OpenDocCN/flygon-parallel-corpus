- en: Chapter 1\. Domain Modeling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter looks into how we can model business processes with code, in a
    way that’s highly compatible with TDD. We’ll discuss *why* domain modeling matters,
    and we’ll look at a few key patterns for modeling domains: Entity, Value Object,
    and Domain Service.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-1](#maps_chapter_01_notext) is a simple visual placeholder for our
    Domain Model pattern. We’ll fill in some details in this chapter, and as we move
    on to other chapters, we’ll build things around the domain model, but you should
    always be able to find these little shapes at the core.'
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 0101](Images/apwp_0101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-1\. A placeholder illustration of our domain model
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: What Is a Domain Model?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the [introduction](preface02.xhtml#introduction), we used the term *business
    logic layer* to describe the central layer of a three-layered architecture. For
    the rest of the book, we’re going to use the term *domain model* instead. This
    is a term from the DDD community that does a better job of capturing our intended
    meaning (see the next sidebar for more on DDD).
  prefs: []
  type: TYPE_NORMAL
- en: The *domain* is a fancy way of saying *the problem you’re trying to solve.*
    Your authors currently work for an online retailer of furniture. Depending on
    which system you’re talking about, the domain might be purchasing and procurement,
    or product design, or logistics and delivery. Most programmers spend their days
    trying to improve or automate business processes; the domain is the set of activities
    that those processes support.
  prefs: []
  type: TYPE_NORMAL
- en: A *model* is a map of a process or phenomenon that captures a useful property.
    Humans are exceptionally good at producing models of things in their heads. For
    example, when someone throws a ball toward you, you’re able to predict its movement
    almost unconsciously, because you have a model of the way objects move in space.
    Your model isn’t perfect by any means. Humans have terrible intuitions about how
    objects behave at near-light speeds or in a vacuum because our model was never
    designed to cover those cases. That doesn’t mean the model is wrong, but it does
    mean that some predictions fall outside of its domain.
  prefs: []
  type: TYPE_NORMAL
- en: The domain model is the mental map that business owners have of their businesses.
    All business people have these mental maps—they’re how humans think about complex
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: You can tell when they’re navigating these maps because they use business speak.
    Jargon arises naturally among people who are collaborating on complex systems.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you, our unfortunate reader, were suddenly transported light years
    away from Earth aboard an alien spaceship with your friends and family and had
    to figure out, from first principles, how to navigate home.
  prefs: []
  type: TYPE_NORMAL
- en: In your first few days, you might just push buttons randomly, but soon you’d
    learn which buttons did what, so that you could give one another instructions.
    “Press the red button near the flashing doohickey and then throw that big lever
    over by the radar gizmo,” you might say.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within a couple of weeks, you’d become more precise as you adopted words to
    describe the ship’s functions: “Increase oxygen levels in cargo bay three” or
    “turn on the little thrusters.” After a few months, you’d have adopted language
    for entire complex processes: “Start landing sequence” or “prepare for warp.”
    This process would happen quite naturally, without any formal effort to build
    a shared glossary.'
  prefs: []
  type: TYPE_NORMAL
- en: So it is in the mundane world of business. The terminology used by business
    stakeholders represents a distilled understanding of the domain model, where complex
    ideas and processes are boiled down to a single word or phrase.
  prefs: []
  type: TYPE_NORMAL
- en: When we hear our business stakeholders using unfamiliar words, or using terms
    in a specific way, we should listen to understand the deeper meaning and encode
    their hard-won experience into our software.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to use a real-world domain model throughout this book, specifically
    a model from our current employment. MADE.com is a successful furniture retailer.
    We source our furniture from manufacturers all over the world and sell it across
    Europe.
  prefs: []
  type: TYPE_NORMAL
- en: When you buy a sofa or a coffee table, we have to figure out how best to get
    your goods from Poland or China or Vietnam and into your living room.
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, we have separate systems that are responsible for buying stock,
    selling stock to customers, and shipping goods to customers. A system in the middle
    needs to coordinate the process by allocating stock to a customer’s orders; see
    [Figure 1-2](#allocation_context_diagram).
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 0102](Images/apwp_0102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-2\. Context diagram for the allocation service
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For the purposes of this book, we’re imagining that the business decides to
    implement an exciting new way of allocating stock. Until now, the business has
    been presenting stock and lead times based on what is physically available in
    the warehouse. If and when the warehouse runs out, a product is listed as “out
    of stock” until the next shipment arrives from the manufacturer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the innovation: if we have a system that can keep track of all our shipments
    and when they’re due to arrive, we can treat the goods on those ships as real
    stock and part of our inventory, just with slightly longer lead times. Fewer goods
    will appear to be out of stock, we’ll sell more, and the business can save money
    by keeping lower inventory in the domestic warehouse.'
  prefs: []
  type: TYPE_NORMAL
- en: But allocating orders is no longer a trivial matter of decrementing a single
    quantity in the warehouse system. We need a more complex allocation mechanism.
    Time for some domain modeling.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Domain Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the domain model takes time, and patience, and Post-it notes.
    We have an initial conversation with our business experts and agree on a glossary
    and some rules for the first minimal version of the domain model. Wherever possible,
    we ask for concrete examples to illustrate each rule.
  prefs: []
  type: TYPE_NORMAL
- en: We make sure to express those rules in the business jargon (the *ubiquitous
    language* in DDD terminology). We choose memorable identifiers for our objects
    so that the examples are easier to talk about.
  prefs: []
  type: TYPE_NORMAL
- en: '[“Some Notes on Allocation”](#allocation_notes) shows some notes we might have
    taken while having a conversation with our domain experts about allocation.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing Domain Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re not going to show you how TDD works in this book, but we want to show
    you how we would construct a model from this business conversation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what one of our first tests might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A first test for allocation (test_batches.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The name of our unit test describes the behavior that we want to see from the
    system, and the names of the classes and variables that we use are taken from
    the business jargon. We could show this code to our nontechnical coworkers, and
    they would agree that this correctly describes the behavior of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is a domain model that meets our requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '*First cut of a domain model for batches (model.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_domain_modeling_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`OrderLine` is an immutable dataclass with no behavior.^([2](ch01.xhtml#idm45714909924296))'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_domain_modeling_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We’re not showing imports in most code listings, in an attempt to keep them
    clean. We’re hoping you can guess that this came via `from dataclasses import
    dataclass`; likewise, `typing.Optional` and `datetime.date`. If you want to double-check
    anything, you can see the full working code for each chapter in its branch (e.g.,
    [chapter_01_domain_model](https://github.com/python-leap/code/tree/chapter_01_domain_model)).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_domain_modeling_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Type hints are still a matter of controversy in the Python world. For domain
    models, they can sometimes help to clarify or document what the expected arguments
    are, and people with IDEs are often grateful for them. You may decide the price
    paid in terms of readability is too high.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our implementation here is trivial: a `Batch` just wraps an integer `available_quantity`,
    and we decrement that value on allocation. We’ve written quite a lot of code just
    to subtract one number from another, but we think that modeling our domain precisely
    will pay off.^([3](ch01.xhtml#idm45714909749608))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write some new failing tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Testing logic for what we can allocate (test_batches.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There’s nothing too unexpected here. We’ve refactored our test suite so that
    we don’t keep repeating the same lines of code to create a batch and a line for
    the same SKU; and we’ve written four simple tests for a new method `can_allocate`.
    Again, notice that the names we use mirror the language of our domain experts,
    and the examples we agreed upon are directly written into code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement this straightforwardly, too, by writing the `can_allocate`
    method of `Batch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A new method in the model (model.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we can manage the implementation by just incrementing and decrementing
    `Batch.available_quantity`, but as we get into `deallocate()` tests, we’ll be
    forced into a more intelligent solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '*This test is going to require a smarter model (test_batches.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this test, we’re asserting that deallocating a line from a batch has no
    effect unless the batch previously allocated the line. For this to work, our `Batch`
    needs to understand which lines have been allocated. Let’s look at the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The domain model now tracks allocations (model.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 1-3](#model_diagram) shows the model in UML.'
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 0103](Images/apwp_0103.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-3\. Our model in UML
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’re getting somewhere! A batch now keeps track of a set of allocated
    `OrderLine` objects. When we allocate, if we have enough available quantity, we
    just add to the set. Our `available_quantity` is now a calculated property: purchased
    quantity minus allocated quantity.'
  prefs: []
  type: TYPE_NORMAL
- en: Yes, there’s plenty more we could do. It’s a little disconcerting that both
    `allocate()` and `deallocate()` can fail silently, but we have the basics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Incidentally, using a set for `._allocations` makes it simple for us to handle
    the last test, because items in a set are unique:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Last batch test! (test_batches.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'At the moment, it’s probably a valid criticism to say that the domain model
    is too trivial to bother with DDD (or even object orientation!). In real life,
    any number of business rules and edge cases crop up: customers can ask for delivery
    on specific future dates, which means we might not want to allocate them to the
    earliest batch. Some SKUs aren’t in batches, but ordered on demand directly from
    suppliers, so they have different logic. Depending on the customer’s location,
    we can allocate to only a subset of warehouses and shipments that are in their
    region—except for some SKUs we’re happy to deliver from a warehouse in a different
    region if we’re out of stock in the home region. And so on. A real business in
    the real world knows how to pile on complexity faster than we can show on the
    page!'
  prefs: []
  type: TYPE_NORMAL
- en: But taking this simple domain model as a placeholder for something more complex,
    we’re going to extend our simple domain model in the rest of the book and plug
    it into the real world of APIs and databases and spreadsheets. We’ll see how sticking
    rigidly to our principles of encapsulation and careful layering will help us to
    avoid a ball of mud.
  prefs: []
  type: TYPE_NORMAL
- en: Dataclasses Are Great for Value Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve used `line` liberally in the previous code listings, but what is a line?
    In our business language, an *order* has multiple *line* items, where each line
    has a SKU and a quantity. We can imagine that a simple YAML file containing order
    information might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Order info as YAML*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that while an order has a *reference* that uniquely identifies it, a
    *line* does not. (Even if we add the order reference to the `OrderLine` class,
    it’s not something that uniquely identifies the line itself.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever we have a business concept that has data but no identity, we often
    choose to represent it using the *Value Object* pattern. A *value object* is any
    domain object that is uniquely identified by the data it holds; we usually make
    them immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '*OrderLine is a value object*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: One of the nice things that dataclasses (or namedtuples) give us is *value equality*,
    which is the fancy way of saying, “Two lines with the same `orderid`, `sku`, and
    `qty` are equal.”
  prefs: []
  type: TYPE_NORMAL
- en: '*More examples of value objects*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'These value objects match our real-world intuition about how their values work.
    It doesn’t matter *which* £10 note we’re talking about, because they all have
    the same value. Likewise, two names are equal if both the first and last names
    match; and two lines are equivalent if they have the same customer order, product
    code, and quantity. We can still have complex behavior on a value object, though.
    In fact, it’s common to support operations on values; for example, mathematical
    operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Math with value objects*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Value Objects and Entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An order line is uniquely identified by its order ID, SKU, and quantity; if
    we change one of those values, we now have a new line. That’s the definition of
    a value object: any object that is identified only by its data and doesn’t have
    a long-lived identity. What about a batch, though? That *is* identified by a reference.'
  prefs: []
  type: TYPE_NORMAL
- en: We use the term *entity* to describe a domain object that has long-lived identity.
    On the previous page, we introduced a `Name` class as a value object. If we take
    the name Harry Percival and change one letter, we have the new `Name` object Barry
    Percival.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be clear that Harry Percival is not equal to Barry Percival:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A name itself cannot change…*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'But what about Harry as a *person*? People do change their names, and their
    marital status, and even their gender, but we continue to recognize them as the
    same individual. That’s because humans, unlike names, have a persistent *identity*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*But a person can!*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Entities, unlike values, have *identity equality*. We can change their values,
    and they are still recognizably the same thing. Batches, in our example, are entities.
    We can allocate lines to a batch, or change the date that we expect it to arrive,
    and it will still be the same entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We usually make this explicit in code by implementing equality operators on
    entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Implementing equality operators (model.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Python’s `__eq__` magic method defines the behavior of the class for the `==`
    operator.^([5](ch01.xhtml#idm45714912460744))
  prefs: []
  type: TYPE_NORMAL
- en: For both entity and value objects, it’s also worth thinking through how `__hash__`
    will work. It’s the magic method Python uses to control the behavior of objects
    when you add them to sets or use them as dict keys; you can find more info [in
    the Python docs](https://oreil.ly/YUzg5).
  prefs: []
  type: TYPE_NORMAL
- en: For value objects, the hash should be based on all the value attributes, and
    we should ensure that the objects are immutable. We get this for free by specifying
    `@frozen=True` on the dataclass.
  prefs: []
  type: TYPE_NORMAL
- en: For entities, the simplest option is to say that the hash is `None`, meaning
    that the object is not hashable and cannot, for example, be used in a set. If
    for some reason you decide you really do want to use set or dict operations with
    entities, the hash should be based on the attribute(s), such as `.reference`,
    that defines the entity’s unique identity over time. You should also try to somehow
    make *that* attribute read-only.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is tricky territory; you shouldn’t modify `__hash__` without also modifying
    `__eq__`. If you’re not sure what you’re doing, further reading is suggested.
    [“Python Hashes and Equality”](https://oreil.ly/vxkgX) by our tech reviewer Hynek
    Schlawack is a good place to start.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not Everything Has to Be an Object: A Domain Service Function'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve made a model to represent batches, but what we actually need to do is
    allocate order lines against a specific set of batches that represent all our
    stock.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it just isn’t a thing.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: Eric Evans, Domain-Driven Design
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evans discusses the idea of Domain Service operations that don’t have a natural
    home in an entity or value object.^([6](ch01.xhtml#idm45714912441224)) A thing
    that allocates an order line, given a set of batches, sounds a lot like a function,
    and we can take advantage of the fact that Python is a multiparadigm language
    and just make it a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we might test-drive such a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Testing our domain service (test_allocate.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And our service might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A standalone function for our domain service (model.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Python’s Magic Methods Let Us Use Our Models with Idiomatic Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may or may not like the use of `next()` in the preceding code, but we’re
    pretty sure you’ll agree that being able to use `sorted()` on our list of batches
    is nice, idiomatic Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it work, we implement `__gt__` on our domain model:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Magic methods can express domain semantics (model.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That’s lovely.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions Can Express Domain Concepts Too
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have one final concept to cover: exceptions can be used to express domain
    concepts too. In our conversations with domain experts, we’ve learned about the
    possibility that an order cannot be allocated because we are *out of stock*, and
    we can capture that by using a *domain exception*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Testing out-of-stock exception (test_allocate.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We won’t bore you too much with the implementation, but the main thing to note
    is that we take care in naming our exceptions in the ubiquitous language, just
    as we do our entities, value objects, and services:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Raising a domain exception (model.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 1-4](#maps_chapter_01_withtext) is a visual representation of where
    we’ve ended up.'
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 0104](Images/apwp_0104.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-4\. Our domain model at the end of the chapter
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: That’ll probably do for now! We have a domain service that we can use for our
    first use case. But first we’ll need a database…
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch01.xhtml#idm45714910064936-marker)) DDD did not originate domain modeling.
    Eric Evans refers to the 2002 book *Object Design* by Rebecca Wirfs-Brock and
    Alan McKean (Addison-Wesley Professional), which introduced responsibility-driven
    design, of which DDD is a special case dealing with the domain. But even that
    is too late, and OO enthusiasts will tell you to look further back to Ivar Jacobson
    and Grady Booch; the term has been around since the mid-1980s.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch01.xhtml#idm45714909924296-marker)) In previous Python versions, we
    might have used a namedtuple. You could also check out Hynek Schlawack’s excellent
    [attrs](https://pypi.org/project/attrs).
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch01.xhtml#idm45714909749608-marker)) Or perhaps you think there’s not
    enough code? What about some sort of check that the SKU in the `OrderLine` matches
    `Batch.sku`? We saved some thoughts on validation for [Appendix E](app05.xhtml#appendix_validation).
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch01.xhtml#idm45714913069480-marker)) It is appalling. Please, please
    don’t do this. —Harry
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch01.xhtml#idm45714912460744-marker)) The `__eq__` method is pronounced
    “dunder-EQ.” By some, at least.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch01.xhtml#idm45714912441224-marker)) Domain services are not the same
    thing as the services from the [service layer](ch04.xhtml#chapter_04_service_layer),
    although they are often closely related. A domain service represents a business
    concept or process, whereas a service-layer service represents a use case for
    your application. Often the service layer will call a domain service.
  prefs: []
  type: TYPE_NORMAL

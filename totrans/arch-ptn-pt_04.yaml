- en: Chapter 2\. Repository Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s time to make good on our promise to use the dependency inversion principle
    as a way of decoupling our core logic from infrastructural concerns.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll introduce the *Repository* pattern, a simplifying abstraction over data
    storage, allowing us to decouple our model layer from the data layer. We’ll present
    a concrete example of how this simplifying abstraction makes our system more testable
    by hiding the complexities of the database.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-1](#maps_chapter_02) shows a little preview of what we’re going to
    build: a `Repository` object that sits between our domain model and the database.'
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 0201](Images/apwp_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Before and after the Repository pattern
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The code for this chapter is in the chapter_02_repository branch [on GitHub](https://oreil.ly/6STDu).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Persisting Our Domain Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.xhtml#chapter_01_domain_model) we built a simple domain
    model that can allocate orders to batches of stock. It’s easy for us to write
    tests against this code because there aren’t any dependencies or infrastructure
    to set up. If we needed to run a database or an API and create test data, our
    tests would be harder to write and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, at some point we’ll need to put our perfect little model in the hands
    of users and contend with the real world of spreadsheets and web browsers and
    race conditions. For the next few chapters we’re going to look at how we can connect
    our idealized domain model to external state.
  prefs: []
  type: TYPE_NORMAL
- en: We expect to be working in an agile manner, so our priority is to get to a minimum
    viable product as quickly as possible. In our case, that’s going to be a web API.
    In a real project, you might dive straight in with some end-to-end tests and start
    plugging in a web framework, test-driving things outside-in.
  prefs: []
  type: TYPE_NORMAL
- en: But we know that, no matter what, we’re going to need some form of persistent
    storage, and this is a textbook, so we can allow ourselves a tiny bit more bottom-up
    development and start to think about storage and databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some Pseudocode: What Are We Going to Need?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we build our first API endpoint, we know we’re going to have some code
    that looks more or less like the following.
  prefs: []
  type: TYPE_NORMAL
- en: '*What our first API endpoint will look like*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We’ve used Flask because it’s lightweight, but you don’t need to be a Flask
    user to understand this book. In fact, we’ll show you how to make your choice
    of framework a minor detail.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll need a way to retrieve batch info from the database and instantiate our
    domain model objects from it, and we’ll also need a way of saving them back to
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: '*What? Oh, “gubbins” is a British word for “stuff.” You can just ignore that.
    It’s pseudocode, OK?*'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the DIP to Data Access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the [introduction](preface02.xhtml#introduction), a layered
    architecture is a common approach to structuring a system that has a UI, some
    logic, and a database (see [Figure 2-2](#layered_architecture2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 0202](Images/apwp_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Layered architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Django’s Model-View-Template structure is closely related, as is Model-View-Controller
    (MVC). In any case, the aim is to keep the layers separate (which is a good thing),
    and to have each layer depend only on the one below it.
  prefs: []
  type: TYPE_NORMAL
- en: But we want our domain model to have *no dependencies whatsoever*.^([1](ch02.xhtml#idm45714911718280))
    We don’t want infrastructure concerns bleeding over into our domain model and
    slowing our unit tests or our ability to make changes.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, as discussed in the introduction, we’ll think of our model as being
    on the “inside,” and dependencies flowing inward to it; this is what people sometimes
    call *onion architecture* (see [Figure 2-3](#onion_architecture)).
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 0203](Images/apwp_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. Onion architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Reminder: Our Model'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s remind ourselves of our domain model (see [Figure 2-4](#model_diagram_reminder)):
    an allocation is the concept of linking an `OrderLine` to a `Batch`. We’re storing
    the allocations as a collection on our `Batch` object.'
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 0103](Images/apwp_0103.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-4\. Our model
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s see how we might translate this to a relational database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The “Normal” ORM Way: Model Depends on ORM'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These days, it’s unlikely that your team members are hand-rolling their own
    SQL queries. Instead, you’re almost certainly using some kind of framework to
    generate SQL for you based on your model objects.
  prefs: []
  type: TYPE_NORMAL
- en: These frameworks are called *object-relational mappers* (ORMs) because they
    exist to bridge the conceptual gap between the world of objects and domain modeling
    and the world of databases and relational algebra.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important thing an ORM gives us is *persistence ignorance*: the idea
    that our fancy domain model doesn’t need to know anything about how data is loaded
    or persisted. This helps keep our domain clean of direct dependencies on particular
    database technologies.^([3](ch02.xhtml#idm45714911660872))'
  prefs: []
  type: TYPE_NORMAL
- en: 'But if you follow the typical SQLAlchemy tutorial, you’ll end up with something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*SQLAlchemy “declarative” syntax, model depends on ORM (orm.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You don’t need to understand SQLAlchemy to see that our pristine model is now
    full of dependencies on the ORM and is starting to look ugly as hell besides.
    Can we really say this model is ignorant of the database? How can it be separate
    from storage concerns when our model properties are directly coupled to database
    columns?
  prefs: []
  type: TYPE_NORMAL
- en: 'Inverting the Dependency: ORM Depends on Model'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Well, thankfully, that’s not the only way to use SQLAlchemy. The alternative
    is to define your schema separately, and to define an explicit *mapper* for how
    to convert between the schema and our domain model, what SQLAlchemy calls a [classical
    mapping](https://oreil.ly/ZucTG):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Explicit ORM mapping with SQLAlchemy Table objects (orm.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_repository_pattern_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The ORM imports (or “depends on” or “knows about”) the domain model, and not
    the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_repository_pattern_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We define our database tables and columns by using SQLAlchemy’s abstractions.^([4](ch02.xhtml#idm45714911304232))
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_repository_pattern_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: When we call the `mapper` function, SQLAlchemy does its magic to bind our domain
    model classes to the various tables we’ve defined.
  prefs: []
  type: TYPE_NORMAL
- en: The end result will be that, if we call `start_mappers`, we will be able to
    easily load and save domain model instances from and to the database. But if we
    never call that function, our domain model classes stay blissfully unaware of
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: This gives us all the benefits of SQLAlchemy, including the ability to use `alembic`
    for migrations, and the ability to transparently query using our domain classes,
    as we’ll see.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re first trying to build your ORM config, it can be useful to write
    tests for it, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Testing the ORM directly (throwaway tests) (test_orm.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_repository_pattern_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t used pytest, the `session` argument to this test needs explaining.
    You don’t need to worry about the details of pytest or its fixtures for the purposes
    of this book, but the short explanation is that you can define common dependencies
    for your tests as “fixtures,” and pytest will inject them to the tests that need
    them by looking at their function arguments. In this case, it’s a SQLAlchemy database
    session.
  prefs: []
  type: TYPE_NORMAL
- en: You probably wouldn’t keep these tests around—as you’ll see shortly, once you’ve
    taken the step of inverting the dependency of ORM and domain model, it’s only
    a small additional step to implement another abstraction called the Repository
    pattern, which will be easier to write tests against and will provide a simple
    interface for faking out later in tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we’ve already achieved our objective of inverting the traditional dependency:
    the domain model stays “pure” and free from infrastructure concerns. We could
    throw away SQLAlchemy and use a different ORM, or a totally different persistence
    system, and the domain model doesn’t need to change at all.'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on what you’re doing in your domain model, and especially if you stray
    far from the OO paradigm, you may find it increasingly hard to get the ORM to
    produce the exact behavior you need, and you may need to modify your domain model.^([5](ch02.xhtml#idm45714910455640))
    As so often happens with architectural decisions, you’ll need to consider a trade-off.
    As the Zen of Python says, “Practicality beats purity!”
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, though, our API endpoint might look something like the following,
    and we could get it to work just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Using SQLAlchemy directly in our API endpoint*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Introducing the Repository Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Repository* pattern is an abstraction over persistent storage. It hides
    the boring details of data access by pretending that all of our data is in memory.
  prefs: []
  type: TYPE_NORMAL
- en: If we had infinite memory in our laptops, we’d have no need for clumsy databases.
    Instead, we could just use our objects whenever we liked. What would that look
    like?
  prefs: []
  type: TYPE_NORMAL
- en: '*You have to get your data from somewhere*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Even though our objects are in memory, we need to put them *somewhere* so we
    can find them again. Our in-memory data would let us add new objects, just like
    a list or a set. Because the objects are in memory, we never need to call a `.save()`
    method; we just fetch the object we care about and modify it in memory.
  prefs: []
  type: TYPE_NORMAL
- en: The Repository in the Abstract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest repository has just two methods: `add()` to put a new item in
    the repository, and `get()` to return a previously added item.^([6](ch02.xhtml#idm45714910766952))
    We stick rigidly to using these methods for data access in our domain and our
    service layer. This self-imposed simplicity stops us from coupling our domain
    model to the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what an abstract base class (ABC) for our repository would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The simplest possible repository (repository.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_repository_pattern_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python tip: `@abc.abstractmethod` is one of the only things that makes ABCs
    actually “work” in Python. Python will refuse to let you instantiate a class that
    does not implement all the `abstractmethods` defined in its parent class.^([7](ch02.xhtml#idm45714910910392))'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_repository_pattern_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`raise NotImplementedError` is nice, but it’s neither necessary nor sufficient.
    In fact, your abstract methods can have real behavior that subclasses can call
    out to, if you really want.'
  prefs: []
  type: TYPE_NORMAL
- en: What Is the Trade-Off?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You know they say economists know the price of everything and the value of nothing?
    Well, programmers know the benefits of everything and the trade-offs of nothing.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: Rich Hickey
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whenever we introduce an architectural pattern in this book, we’ll always ask,
    “What do we get for this? And what does it cost us?”
  prefs: []
  type: TYPE_NORMAL
- en: Usually, at the very least, we’ll be introducing an extra layer of abstraction,
    and although we may hope it will reduce complexity overall, it does add complexity
    locally, and it has a cost in terms of the raw numbers of moving parts and ongoing
    maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: The Repository pattern is probably one of the easiest choices in the book, though,
    if you’re already heading down the DDD and dependency inversion route. As far
    as our code is concerned, we’re really just swapping the SQLAlchemy abstraction
    (`session.query(Batch)`) for a different one (`batches_repo.get`) that we designed.
  prefs: []
  type: TYPE_NORMAL
- en: We will have to write a few lines of code in our repository class each time
    we add a new domain object that we want to retrieve, but in return we get a simple
    abstraction over our storage layer, which we control. The Repository pattern would
    make it easy to make fundamental changes to the way we store things (see [Appendix C](app03.xhtml#appendix_csvs)),
    and as we’ll see, it is easy to fake out for unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the Repository pattern is so common in the DDD world that, if you
    do collaborate with programmers who have come to Python from the Java and C# worlds,
    they’re likely to recognize it. [Figure 2-5](#repository_pattern_diagram) illustrates
    the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 0205](Images/apwp_0205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-5\. Repository pattern
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As always, we start with a test. This would probably be classified as an integration
    test, since we’re checking that our code (the repository) is correctly integrated
    with the database; hence, the tests tend to mix raw SQL with calls and assertions
    on our own code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Unlike the ORM tests from earlier, these tests are good candidates for staying
    part of your codebase longer term, particularly if any parts of your domain model
    mean the object-relational map is nontrivial.
  prefs: []
  type: TYPE_NORMAL
- en: '*Repository test for saving an object (test_repository.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_repository_pattern_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`repo.add()` is the method under test here.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_repository_pattern_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We keep the `.commit()` outside of the repository and make it the responsibility
    of the caller. There are pros and cons for this; some of our reasons will become
    clearer when we get to [Chapter 6](ch06.xhtml#chapter_06_uow).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_repository_pattern_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the raw SQL to verify that the right data has been saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next test involves retrieving batches and allocations, so it’s more complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Repository test for retrieving a complex object (test_repository.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_repository_pattern_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This tests the read side, so the raw SQL is preparing data to be read by the
    `repo.get()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_repository_pattern_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll spare you the details of `insert_batch` and `insert_allocation`; the point
    is to create a couple of batches, and, for the batch we’re interested in, to have
    one existing order line allocated to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_repository_pattern_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: And that’s what we verify here. The first `assert ==` checks that the types
    match, and that the reference is the same (because, as you remember, `Batch` is
    an entity, and we have a custom `*eq*` for it).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_repository_pattern_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: So we also explicitly check on its major attributes, including `._allocations`,
    which is a Python set of `OrderLine` value objects.
  prefs: []
  type: TYPE_NORMAL
- en: Whether or not you painstakingly write tests for every model is a judgment call.
    Once you have one class tested for create/modify/save, you might be happy to go
    on and do the others with a minimal round-trip test, or even nothing at all, if
    they all follow a similar pattern. In our case, the ORM config that sets up the
    `._allocations` set is a little complex, so it merited a specific test.
  prefs: []
  type: TYPE_NORMAL
- en: 'You end up with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A typical repository (repository.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And now our Flask endpoint might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Using our repository directly in our API endpoint*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Building a Fake Repository for Tests Is Now Trivial!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s one of the biggest benefits of the Repository pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A simple fake repository using a set (repository.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Because it’s a simple wrapper around a `set`, all the methods are one-liners.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a fake repo in tests is really easy, and we have a simple abstraction
    that’s easy to use and reason about:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Example usage of fake repository (test_api.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see this fake in action in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Building fakes for your abstractions is an excellent way to get design feedback:
    if it’s hard to fake, the abstraction is probably too complicated.'
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Port and What Is an Adapter, in Python?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We don’t want to dwell on the terminology too much here because the main thing
    we want to focus on is dependency inversion, and the specifics of the technique
    you use don’t matter too much. Also, we’re aware that different people use slightly
    different definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Ports and adapters came out of the OO world, and the definition we hold onto
    is that the *port* is the *interface* between our application and whatever it
    is we wish to abstract away, and the *adapter* is the *implementation* behind
    that interface or abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Now Python doesn’t have interfaces per se, so although it’s usually easy to
    identify an adapter, defining the port can be harder. If you’re using an abstract
    base class, that’s the port. If not, the port is just the duck type that your
    adapters conform to and that your core application expects—the function and method
    names in use, and their argument names and types.
  prefs: []
  type: TYPE_NORMAL
- en: Concretely, in this chapter, `AbstractRepository` is the port, and `SqlAlchemyRepository`
    and `FakeRepository` are the adapters.
  prefs: []
  type: TYPE_NORMAL
- en: Wrap-Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bearing the Rich Hickey quote in mind, in each chapter we summarize the costs
    and benefits of each architectural pattern we introduce. We want to be clear that
    we’re not saying every single application needs to be built this way; only sometimes
    does the complexity of the app and domain make it worth investing the time and
    effort in adding these extra layers of indirection.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, [Table 2-1](#chapter_02_repository_tradeoffs) shows some
    of the pros and cons of the Repository pattern and our persistence-ignorant model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-1\. Repository pattern and persistence ignorance: the trade-offs'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pros | Cons |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: We have a simple interface between persistent storage and our domain model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s easy to make a fake version of the repository for unit testing, or to swap
    out different storage solutions, because we’ve fully decoupled the model from
    infrastructure concerns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the domain model before thinking about persistence helps us focus on
    the business problem at hand. If we ever want to radically change our approach,
    we can do that in our model, without needing to worry about foreign keys or migrations
    until later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our database schema is really simple because we have complete control over how
    we map our objects to tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: An ORM already buys you some decoupling. Changing foreign keys might be hard,
    but it should be pretty easy to swap between MySQL and Postgres if you ever need
    to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining ORM mappings by hand requires extra work and extra code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any extra layer of indirection always increases maintenance costs and adds a
    “WTF factor” for Python programmers who’ve never seen the Repository pattern before.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-6](#domain_model_tradeoffs_diagram) shows the basic thesis: yes,
    for simple cases, a decoupled domain model is harder work than a simple ORM/ActiveRecord
    pattern.^([8](ch02.xhtml#idm45714904022136))'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If your app is just a simple CRUD (create-read-update-delete) wrapper around
    a database, then you don’t need a domain model or a repository.
  prefs: []
  type: TYPE_NORMAL
- en: But the more complex the domain, the more an investment in freeing yourself
    from infrastructure concerns will pay off in terms of the ease of making changes.
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 0206](Images/apwp_0206.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-6\. Domain model trade-offs as a diagram
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Our example code isn’t complex enough to give more than a hint of what the
    right-hand side of the graph looks like, but the hints are there. Imagine, for
    example, if we decide one day that we want to change allocations to live on the
    `OrderLine` instead of on the `Batch` object: if we were using Django, say, we’d
    have to define and think through the database migration before we could run any
    tests. As it is, because our model is just plain old Python objects, we can change
    a `set()` to being a new attribute, without needing to think about the database
    until later.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll be wondering, how do we instantiate these repositories, fake or real?
    What will our Flask app actually look like? You’ll find out in the next exciting
    installment, [the Service Layer pattern](ch04.xhtml#chapter_04_service_layer).
  prefs: []
  type: TYPE_NORMAL
- en: But first, a brief digression.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch02.xhtml#idm45714911718280-marker)) I suppose we mean “no stateful dependencies.”
    Depending on a helper library is fine; depending on an ORM or a web framework
    is not.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch02.xhtml#idm45714911705432-marker)) Mark Seemann has [an excellent blog
    post](https://oreil.ly/LpFS9) on the topic.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch02.xhtml#idm45714911660872-marker)) In this sense, using an ORM is already
    an example of the DIP. Instead of depending on hardcoded SQL, we depend on an
    abstraction, the ORM. But that’s not enough for us—not in this book!
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch02.xhtml#idm45714911304232-marker)) Even in projects where we don’t
    use an ORM, we often use SQLAlchemy alongside Alembic to declaratively create
    schemas in Python and to manage migrations, connections, and sessions.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch02.xhtml#idm45714910455640-marker)) Shout-out to the amazingly helpful
    SQLAlchemy maintainers, and to Mike Bayer in particular.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch02.xhtml#idm45714910766952-marker)) You may be thinking, “What about
    `list` or `delete` or `update`?” However, in an ideal world, we modify our model
    objects one at a time, and delete is usually handled as a soft-delete—i.e., `batch.cancel()`.
    Finally, update is taken care of by the Unit of Work pattern, as you’ll see in
    [Chapter 6](ch06.xhtml#chapter_06_uow).
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch02.xhtml#idm45714910910392-marker)) To really reap the benefits of ABCs
    (such as they may be), be running helpers like `pylint` and `mypy`.
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch02.xhtml#idm45714904022136-marker)) Diagram inspired by a post called
    [“Global Complexity, Local Simplicity”](https://oreil.ly/fQXkP) by Rob Vens.
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 2\. Repository Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 仓储模式
- en: It’s time to make good on our promise to use the dependency inversion principle
    as a way of decoupling our core logic from infrastructural concerns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候兑现我们使用依赖倒置原则来将核心逻辑与基础设施问题解耦的承诺了。
- en: We’ll introduce the *Repository* pattern, a simplifying abstraction over data
    storage, allowing us to decouple our model layer from the data layer. We’ll present
    a concrete example of how this simplifying abstraction makes our system more testable
    by hiding the complexities of the database.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将引入*仓储*模式，这是对数据存储的简化抽象，允许我们将模型层与数据层解耦。我们将通过一个具体的例子来展示这种简化的抽象如何通过隐藏数据库的复杂性使我们的系统更具可测试性。
- en: '[Figure 2-1](#maps_chapter_02) shows a little preview of what we’re going to
    build: a `Repository` object that sits between our domain model and the database.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-1](#maps_chapter_02)显示了我们将要构建的一个小预览：一个`Repository`对象，位于我们的领域模型和数据库之间。'
- en: '![apwp 0201](Images/apwp_0201.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![apwp 0201](Images/apwp_0201.png)'
- en: Figure 2-1\. Before and after the Repository pattern
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-1. 仓储模式之前和之后
- en: Tip
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The code for this chapter is in the chapter_02_repository branch [on GitHub](https://oreil.ly/6STDu).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码在GitHub的chapter_02_repository分支中。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Persisting Our Domain Model
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化我们的领域模型
- en: In [Chapter 1](ch01.xhtml#chapter_01_domain_model) we built a simple domain
    model that can allocate orders to batches of stock. It’s easy for us to write
    tests against this code because there aren’t any dependencies or infrastructure
    to set up. If we needed to run a database or an API and create test data, our
    tests would be harder to write and maintain.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml#chapter_01_domain_model)中，我们构建了一个简单的领域模型，可以将订单分配给库存批次。我们很容易对这段代码编写测试，因为没有任何依赖或基础设施需要设置。如果我们需要运行数据库或API并创建测试数据，我们的测试将更难编写和维护。
- en: Sadly, at some point we’ll need to put our perfect little model in the hands
    of users and contend with the real world of spreadsheets and web browsers and
    race conditions. For the next few chapters we’re going to look at how we can connect
    our idealized domain model to external state.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们总有一天需要把我们完美的小模型交到用户手中，并应对电子表格、Web浏览器和竞争条件的现实世界。在接下来的几章中，我们将看看如何将我们理想化的领域模型连接到外部状态。
- en: We expect to be working in an agile manner, so our priority is to get to a minimum
    viable product as quickly as possible. In our case, that’s going to be a web API.
    In a real project, you might dive straight in with some end-to-end tests and start
    plugging in a web framework, test-driving things outside-in.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望以敏捷的方式工作，因此我们的优先任务是尽快实现最小可行产品。在我们的情况下，这将是一个Web API。在一个真实的项目中，你可能会直接进行一些端到端的测试，并开始插入一个Web框架，从外到内进行测试驱动。
- en: But we know that, no matter what, we’re going to need some form of persistent
    storage, and this is a textbook, so we can allow ourselves a tiny bit more bottom-up
    development and start to think about storage and databases.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们知道，无论如何，我们都需要某种形式的持久存储，这是一本教科书，所以我们可以允许自己多一点自下而上的开发，并开始考虑存储和数据库。
- en: 'Some Pseudocode: What Are We Going to Need?'
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些伪代码：我们需要什么？
- en: When we build our first API endpoint, we know we’re going to have some code
    that looks more or less like the following.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建我们的第一个API端点时，我们知道我们将会有一些看起来更或多少像以下的代码。
- en: '*What our first API endpoint will look like*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们的第一个API端点将是什么样子*'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We’ve used Flask because it’s lightweight, but you don’t need to be a Flask
    user to understand this book. In fact, we’ll show you how to make your choice
    of framework a minor detail.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Flask是因为它很轻量，但你不需要是Flask用户才能理解这本书。事实上，我们将向你展示如何使你选择的框架成为一个细节。
- en: We’ll need a way to retrieve batch info from the database and instantiate our
    domain model objects from it, and we’ll also need a way of saving them back to
    the database.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法从数据库中检索批次信息，并从中实例化我们的领域模型对象，我们还需要一种将它们保存回数据库的方法。
- en: '*What? Oh, “gubbins” is a British word for “stuff.” You can just ignore that.
    It’s pseudocode, OK?*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*什么？哦，“gubbins”是一个英国词，意思是“东西”。你可以忽略它。这是伪代码，好吗？*'
- en: Applying the DIP to Data Access
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用DIP到数据访问
- en: As mentioned in the [introduction](preface02.xhtml#introduction), a layered
    architecture is a common approach to structuring a system that has a UI, some
    logic, and a database (see [Figure 2-2](#layered_architecture2)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如[介绍](preface02.xhtml#introduction)中提到的，分层架构是一种常见的系统结构方法，该系统具有UI、一些逻辑和数据库（见[图2-2](#layered_architecture2)）。
- en: '![apwp 0202](Images/apwp_0202.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![apwp 0202](Images/apwp_0202.png)'
- en: Figure 2-2\. Layered architecture
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-2. 分层架构
- en: Django’s Model-View-Template structure is closely related, as is Model-View-Controller
    (MVC). In any case, the aim is to keep the layers separate (which is a good thing),
    and to have each layer depend only on the one below it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Django的模型-视图-模板结构是密切相关的，就像模型-视图-控制器（MVC）一样。无论如何，目标是保持各层分离（这是一件好事），并且使每一层仅依赖于其下面的一层。
- en: But we want our domain model to have *no dependencies whatsoever*.^([1](ch02.xhtml#idm45714911718280))
    We don’t want infrastructure concerns bleeding over into our domain model and
    slowing our unit tests or our ability to make changes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们希望我们的领域模型*完全没有任何依赖*。我们不希望基础设施问题渗入我们的领域模型，从而减慢我们的单元测试或我们进行更改的能力。
- en: Instead, as discussed in the introduction, we’ll think of our model as being
    on the “inside,” and dependencies flowing inward to it; this is what people sometimes
    call *onion architecture* (see [Figure 2-3](#onion_architecture)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，正如在介绍中讨论的那样，我们将把我们的模型视为“内部”，并将依赖项向内流动；这就是人们有时称之为*洋葱架构*的东西（见[图2-3](#onion_architecture)）。
- en: '![apwp 0203](Images/apwp_0203.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![apwp 0203](Images/apwp_0203.png)'
- en: Figure 2-3\. Onion architecture
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-3. 洋葱架构
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Reminder: Our Model'
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提醒：我们的模型
- en: 'Let’s remind ourselves of our domain model (see [Figure 2-4](#model_diagram_reminder)):
    an allocation is the concept of linking an `OrderLine` to a `Batch`. We’re storing
    the allocations as a collection on our `Batch` object.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们的领域模型（见[图2-4](#model_diagram_reminder)）：分配是将“OrderLine”链接到“Batch”的概念。我们将分配存储为我们“Batch”对象的集合。
- en: '![apwp 0103](Images/apwp_0103.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![apwp 0103](Images/apwp_0103.png)'
- en: Figure 2-4\. Our model
  id: totrans-35
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-4。我们的模型
- en: Let’s see how we might translate this to a relational database.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将其转换为关系数据库。
- en: 'The “Normal” ORM Way: Model Depends on ORM'
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “正常”的ORM方式：模型依赖于ORM
- en: These days, it’s unlikely that your team members are hand-rolling their own
    SQL queries. Instead, you’re almost certainly using some kind of framework to
    generate SQL for you based on your model objects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，您的团队成员不太可能手工编写自己的SQL查询。相反，您几乎肯定是在基于模型对象生成SQL的某种框架上使用。
- en: These frameworks are called *object-relational mappers* (ORMs) because they
    exist to bridge the conceptual gap between the world of objects and domain modeling
    and the world of databases and relational algebra.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些框架被称为“对象关系映射器”（ORMs），因为它们存在的目的是弥合对象和领域建模世界与数据库和关系代数世界之间的概念差距。
- en: 'The most important thing an ORM gives us is *persistence ignorance*: the idea
    that our fancy domain model doesn’t need to know anything about how data is loaded
    or persisted. This helps keep our domain clean of direct dependencies on particular
    database technologies.^([3](ch02.xhtml#idm45714911660872))'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ORM给我们最重要的东西是“持久性无知”：即我们的精巧领域模型不需要知道如何加载或持久化数据。这有助于保持我们的领域不受特定数据库技术的直接依赖。^([3](ch02.xhtml#idm45714911660872))
- en: 'But if you follow the typical SQLAlchemy tutorial, you’ll end up with something
    like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您遵循典型的SQLAlchemy教程，最终会得到类似于这样的东西：
- en: '*SQLAlchemy “declarative” syntax, model depends on ORM (orm.py)*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的“声明性”语法，模型依赖于ORM（orm.py）
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You don’t need to understand SQLAlchemy to see that our pristine model is now
    full of dependencies on the ORM and is starting to look ugly as hell besides.
    Can we really say this model is ignorant of the database? How can it be separate
    from storage concerns when our model properties are directly coupled to database
    columns?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您无需了解SQLAlchemy就能看到我们的原始模型现在充满了对ORM的依赖，并且看起来非常丑陋。我们真的能说这个模型对数据库一无所知吗？当我们的模型属性直接耦合到数据库列时，它怎么能与存储问题分离？
- en: 'Inverting the Dependency: ORM Depends on Model'
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反转依赖关系：ORM依赖于模型
- en: 'Well, thankfully, that’s not the only way to use SQLAlchemy. The alternative
    is to define your schema separately, and to define an explicit *mapper* for how
    to convert between the schema and our domain model, what SQLAlchemy calls a [classical
    mapping](https://oreil.ly/ZucTG):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这并不是使用SQLAlchemy的唯一方式。另一种方法是分别定义架构，并定义一个显式的*映射器*，用于在架构和我们的领域模型之间进行转换，SQLAlchemy称之为[经典映射](https://oreil.ly/ZucTG)：
- en: '*Explicit ORM mapping with SQLAlchemy Table objects (orm.py)*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SQLAlchemy Table对象显式ORM映射（orm.py）
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](Images/1.png)](#co_repository_pattern_CO1-1)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_repository_pattern_CO1-1)'
- en: The ORM imports (or “depends on” or “knows about”) the domain model, and not
    the other way around.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ORM导入（或“依赖”或“了解”）领域模型，而不是相反。
- en: '[![2](Images/2.png)](#co_repository_pattern_CO1-2)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_repository_pattern_CO1-2)'
- en: We define our database tables and columns by using SQLAlchemy’s abstractions.^([4](ch02.xhtml#idm45714911304232))
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用SQLAlchemy的抽象来定义我们的数据库表和列。^([4](ch02.xhtml#idm45714911304232))
- en: '[![3](Images/3.png)](#co_repository_pattern_CO1-3)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_repository_pattern_CO1-3)'
- en: When we call the `mapper` function, SQLAlchemy does its magic to bind our domain
    model classes to the various tables we’ve defined.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`mapper`函数时，SQLAlchemy会通过其魔术将我们的领域模型类绑定到我们定义的各种表上。
- en: The end result will be that, if we call `start_mappers`, we will be able to
    easily load and save domain model instances from and to the database. But if we
    never call that function, our domain model classes stay blissfully unaware of
    the database.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果将是，如果我们调用`start_mappers`，我们将能够轻松地从数据库加载和保存领域模型实例。但如果我们从未调用该函数，我们的领域模型类将幸福地不知道数据库的存在。
- en: This gives us all the benefits of SQLAlchemy, including the ability to use `alembic`
    for migrations, and the ability to transparently query using our domain classes,
    as we’ll see.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们带来了SQLAlchemy的所有好处，包括能够使用`alembic`进行迁移，并且能够透明地使用我们的领域类进行查询，我们将会看到。
- en: 'When you’re first trying to build your ORM config, it can be useful to write
    tests for it, as in the following example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当您首次尝试构建ORM配置时，编写测试可能会很有用，如以下示例所示：
- en: '*Testing the ORM directly (throwaway tests) (test_orm.py)*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 直接测试ORM（一次性测试）（test_orm.py）
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](Images/1.png)](#co_repository_pattern_CO2-1)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_repository_pattern_CO2-1)'
- en: If you haven’t used pytest, the `session` argument to this test needs explaining.
    You don’t need to worry about the details of pytest or its fixtures for the purposes
    of this book, but the short explanation is that you can define common dependencies
    for your tests as “fixtures,” and pytest will inject them to the tests that need
    them by looking at their function arguments. In this case, it’s a SQLAlchemy database
    session.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有使用pytest，需要解释此测试的`session`参数。您无需担心pytest或其固定装置的细节，但简单的解释是，您可以将测试的常见依赖项定义为“固定装置”，pytest将通过查看其函数参数将它们注入到需要它们的测试中。在这种情况下，它是一个SQLAlchemy数据库会话。
- en: You probably wouldn’t keep these tests around—as you’ll see shortly, once you’ve
    taken the step of inverting the dependency of ORM and domain model, it’s only
    a small additional step to implement another abstraction called the Repository
    pattern, which will be easier to write tests against and will provide a simple
    interface for faking out later in tests.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能不会保留这些测试，因为很快您将看到，一旦您采取了反转ORM和领域模型的步骤，实现另一个称为存储库模式的抽象只是一个小的额外步骤，这将更容易编写测试，并将为以后的测试提供一个简单的接口。
- en: 'But we’ve already achieved our objective of inverting the traditional dependency:
    the domain model stays “pure” and free from infrastructure concerns. We could
    throw away SQLAlchemy and use a different ORM, or a totally different persistence
    system, and the domain model doesn’t need to change at all.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们已经实现了我们颠倒传统依赖的目标：领域模型保持“纯粹”并且不受基础设施问题的影响。我们可以放弃SQLAlchemy并使用不同的ORM，或者完全不同的持久性系统，领域模型根本不需要改变。
- en: Depending on what you’re doing in your domain model, and especially if you stray
    far from the OO paradigm, you may find it increasingly hard to get the ORM to
    produce the exact behavior you need, and you may need to modify your domain model.^([5](ch02.xhtml#idm45714910455640))
    As so often happens with architectural decisions, you’ll need to consider a trade-off.
    As the Zen of Python says, “Practicality beats purity!”
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您在领域模型中所做的工作，特别是如果您偏离OO范式，您可能会发现越来越难以使ORM产生您需要的确切行为，并且您可能需要修改您的领域模型。^([5](ch02.xhtml#idm45714910455640))就像经常发生的架构决策一样，您需要考虑权衡。正如Python之禅所说：“实用性胜过纯粹！”
- en: 'At this point, though, our API endpoint might look something like the following,
    and we could get it to work just fine:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，此时我们的API端点可能看起来像下面这样，并且我们可以让它正常工作：
- en: '*Using SQLAlchemy directly in our API endpoint*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*在我们的API端点直接使用SQLAlchemy*'
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Introducing the Repository Pattern
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入存储库模式
- en: The *Repository* pattern is an abstraction over persistent storage. It hides
    the boring details of data access by pretending that all of our data is in memory.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*存储库*模式是对持久性存储的抽象。它通过假装我们所有的数据都在内存中来隐藏数据访问的无聊细节。'
- en: If we had infinite memory in our laptops, we’d have no need for clumsy databases.
    Instead, we could just use our objects whenever we liked. What would that look
    like?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的笔记本电脑有无限的内存，我们就不需要笨拙的数据库了。相反，我们可以随时使用我们的对象。那会是什么样子？
- en: '*You have to get your data from somewhere*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*你必须从某处获取你的数据*'
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Even though our objects are in memory, we need to put them *somewhere* so we
    can find them again. Our in-memory data would let us add new objects, just like
    a list or a set. Because the objects are in memory, we never need to call a `.save()`
    method; we just fetch the object we care about and modify it in memory.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的对象在内存中，但我们需要将它们放在*某个地方*，以便我们可以再次找到它们。我们的内存中的数据可以让我们添加新对象，就像列表或集合一样。因为对象在内存中，我们永远不需要调用`.save()`方法；我们只需获取我们关心的对象并在内存中修改它。
- en: The Repository in the Abstract
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象中的存储库
- en: 'The simplest repository has just two methods: `add()` to put a new item in
    the repository, and `get()` to return a previously added item.^([6](ch02.xhtml#idm45714910766952))
    We stick rigidly to using these methods for data access in our domain and our
    service layer. This self-imposed simplicity stops us from coupling our domain
    model to the database.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的存储库只有两种方法：`add()`用于将新项目放入存储库，`get()`用于返回先前添加的项目。^([6](ch02.xhtml#idm45714910766952))我们严格遵守在我们的领域和服务层中使用这些方法进行数据访问。这种自我施加的简单性阻止了我们将领域模型与数据库耦合。
- en: 'Here’s what an abstract base class (ABC) for our repository would look like:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们存储库的抽象基类（ABC）会是什么样子：
- en: '*The simplest possible repository (repository.py)*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*最简单的存储库（repository.py）*'
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](Images/1.png)](#co_repository_pattern_CO3-1)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_repository_pattern_CO3-1)'
- en: 'Python tip: `@abc.abstractmethod` is one of the only things that makes ABCs
    actually “work” in Python. Python will refuse to let you instantiate a class that
    does not implement all the `abstractmethods` defined in its parent class.^([7](ch02.xhtml#idm45714910910392))'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Python提示：`@abc.abstractmethod`是Python中使抽象基类实际“工作”的少数几件事之一。Python将拒绝让您实例化未实现其父类中定义的所有`abstractmethods`的类。^([7](ch02.xhtml#idm45714910910392))
- en: '[![2](Images/2.png)](#co_repository_pattern_CO3-2)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_repository_pattern_CO3-2)'
- en: '`raise NotImplementedError` is nice, but it’s neither necessary nor sufficient.
    In fact, your abstract methods can have real behavior that subclasses can call
    out to, if you really want.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`raise NotImplementedError`很好，但既不是必要的也不是充分的。实际上，如果您真的想要，您的抽象方法可以具有子类可以调用的真实行为。'
- en: What Is the Trade-Off?
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这是一种权衡吗？
- en: You know they say economists know the price of everything and the value of nothing?
    Well, programmers know the benefits of everything and the trade-offs of nothing.
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你知道他们说经济学家知道一切的价格，但对任何价值一无所知吗？嗯，程序员知道一切的好处，但对任何权衡一无所知。
- en: '>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: Rich Hickey
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Rich Hickey
- en: Whenever we introduce an architectural pattern in this book, we’ll always ask,
    “What do we get for this? And what does it cost us?”
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们在本书中引入一个架构模式时，我们总是会问：“我们从中得到了什么？以及我们付出了什么代价？”
- en: Usually, at the very least, we’ll be introducing an extra layer of abstraction,
    and although we may hope it will reduce complexity overall, it does add complexity
    locally, and it has a cost in terms of the raw numbers of moving parts and ongoing
    maintenance.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们至少会引入一个额外的抽象层，尽管我们可能希望它会减少整体复杂性，但它确实会增加局部复杂性，并且在移动部件的原始数量和持续维护方面会有成本。
- en: The Repository pattern is probably one of the easiest choices in the book, though,
    if you’re already heading down the DDD and dependency inversion route. As far
    as our code is concerned, we’re really just swapping the SQLAlchemy abstraction
    (`session.query(Batch)`) for a different one (`batches_repo.get`) that we designed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库模式可能是本书中最容易的选择之一，尽管如果您已经在走领域驱动设计和依赖反转的路线。就我们的代码而言，我们实际上只是将SQLAlchemy抽象（`session.query(Batch)`）替换为我们设计的另一个抽象（`batches_repo.get`）。
- en: We will have to write a few lines of code in our repository class each time
    we add a new domain object that we want to retrieve, but in return we get a simple
    abstraction over our storage layer, which we control. The Repository pattern would
    make it easy to make fundamental changes to the way we store things (see [Appendix C](app03.xhtml#appendix_csvs)),
    and as we’ll see, it is easy to fake out for unit tests.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们添加一个新的领域对象想要检索时，我们将不得不在我们的存储库类中写入几行代码，但作为回报，我们得到了一个简单的抽象层，我们可以控制。存储库模式将使我们能够轻松地对存储方式进行根本性的更改（参见[附录C](app03.xhtml#appendix_csvs)），正如我们将看到的，它很容易为单元测试伪造出来。
- en: In addition, the Repository pattern is so common in the DDD world that, if you
    do collaborate with programmers who have come to Python from the Java and C# worlds,
    they’re likely to recognize it. [Figure 2-5](#repository_pattern_diagram) illustrates
    the pattern.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，存储库模式在DDD世界中是如此常见，以至于，如果你与从Java和C#世界转到Python的程序员合作，他们可能会认识它。[图2-5](#repository_pattern_diagram)说明了这种模式。
- en: '![apwp 0205](Images/apwp_0205.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![apwp 0205](Images/apwp_0205.png)'
- en: Figure 2-5\. Repository pattern
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-5. 存储库模式
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As always, we start with a test. This would probably be classified as an integration
    test, since we’re checking that our code (the repository) is correctly integrated
    with the database; hence, the tests tend to mix raw SQL with calls and assertions
    on our own code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，我们从测试开始。这可能被归类为集成测试，因为我们正在检查我们的代码（存储库）是否与数据库正确集成；因此，测试往往会在我们自己的代码上混合原始SQL调用和断言。
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Unlike the ORM tests from earlier, these tests are good candidates for staying
    part of your codebase longer term, particularly if any parts of your domain model
    mean the object-relational map is nontrivial.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的ORM测试不同，这些测试是长期留在代码库中的好选择，特别是如果领域模型的任何部分意味着对象关系映射是非平凡的。
- en: '*Repository test for saving an object (test_repository.py)*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*保存对象的存储库测试（test_repository.py）*'
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](Images/1.png)](#co_repository_pattern_CO4-1)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](Images/1.png)'
- en: '`repo.add()` is the method under test here.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`repo.add()`是这里测试的方法。'
- en: '[![2](Images/2.png)](#co_repository_pattern_CO4-2)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](Images/2.png)'
- en: We keep the `.commit()` outside of the repository and make it the responsibility
    of the caller. There are pros and cons for this; some of our reasons will become
    clearer when we get to [Chapter 6](ch06.xhtml#chapter_06_uow).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`.commit()`放在存储库之外，并将其作为调用者的责任。这样做有利有弊；当我们到达[第6章](ch06.xhtml#chapter_06_uow)时，我们的一些原因将变得更加清晰。
- en: '[![3](Images/3.png)](#co_repository_pattern_CO4-3)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](Images/3.png)'
- en: We use the raw SQL to verify that the right data has been saved.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用原始SQL来验证已保存正确的数据。
- en: 'The next test involves retrieving batches and allocations, so it’s more complex:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试涉及检索批次和分配，所以它更复杂：
- en: '*Repository test for retrieving a complex object (test_repository.py)*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*检索复杂对象的存储库测试（test_repository.py）*'
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](Images/1.png)](#co_repository_pattern_CO5-1)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](Images/1.png)'
- en: This tests the read side, so the raw SQL is preparing data to be read by the
    `repo.get()`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试是读取方面的，因此原始SQL正在准备数据以供`repo.get()`读取。
- en: '[![2](Images/2.png)](#co_repository_pattern_CO5-2)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](Images/2.png)'
- en: We’ll spare you the details of `insert_batch` and `insert_allocation`; the point
    is to create a couple of batches, and, for the batch we’re interested in, to have
    one existing order line allocated to it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不详细介绍`insert_batch`和`insert_allocation`；重点是创建一对批次，并且对我们感兴趣的批次，有一个现有的订单行分配给它。
- en: '[![3](Images/3.png)](#co_repository_pattern_CO5-3)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](Images/3.png)'
- en: And that’s what we verify here. The first `assert ==` checks that the types
    match, and that the reference is the same (because, as you remember, `Batch` is
    an entity, and we have a custom `*eq*` for it).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在这里验证的。第一个`assert ==`检查类型是否匹配，并且引用是否相同（因为你记得，`Batch`是一个实体，我们为它有一个自定义的`*eq*`）。
- en: '[![4](Images/4.png)](#co_repository_pattern_CO5-5)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](Images/4.png)'
- en: So we also explicitly check on its major attributes, including `._allocations`,
    which is a Python set of `OrderLine` value objects.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们还明确检查它的主要属性，包括`._allocations`，它是`OrderLine`值对象的Python集合。
- en: Whether or not you painstakingly write tests for every model is a judgment call.
    Once you have one class tested for create/modify/save, you might be happy to go
    on and do the others with a minimal round-trip test, or even nothing at all, if
    they all follow a similar pattern. In our case, the ORM config that sets up the
    `._allocations` set is a little complex, so it merited a specific test.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否费心为每个模型编写测试都是一个判断调用。一旦你为创建/修改/保存测试了一个类，你可能会很高兴地继续做其他类的最小往返测试，甚至什么都不做，如果它们都遵循相似的模式。在我们的情况下，设置`._allocations`集的ORM配置有点复杂，所以它值得一个特定的测试。
- en: 'You end up with something like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终会得到这样的东西：
- en: '*A typical repository (repository.py)*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*典型的存储库（repository.py）*'
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And now our Flask endpoint might look something like the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的Flask端点可能看起来像下面这样：
- en: '*Using our repository directly in our API endpoint*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*直接在API端点中使用我们的存储库*'
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Building a Fake Repository for Tests Is Now Trivial!
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为测试构建一个假存储库现在变得轻而易举！
- en: 'Here’s one of the biggest benefits of the Repository pattern:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是存储库模式最大的好处之一：
- en: '*A simple fake repository using a set (repository.py)*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用集合的简单假存储库（repository.py）*'
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Because it’s a simple wrapper around a `set`, all the methods are one-liners.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它是一个围绕`set`的简单包装器，所有方法都是一行代码。
- en: 'Using a fake repo in tests is really easy, and we have a simple abstraction
    that’s easy to use and reason about:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中使用假存储库真的很容易，而且我们有一个简单易用且易于理解的抽象：
- en: '*Example usage of fake repository (test_api.py)*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*假存储库的示例用法（test_api.py）*'
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You’ll see this fake in action in the next chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在下一章中看到这个假存储库的实际应用。
- en: Tip
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Building fakes for your abstractions is an excellent way to get design feedback:
    if it’s hard to fake, the abstraction is probably too complicated.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的抽象构建假对象是获得设计反馈的一个绝佳方式：如果很难伪造，那么这个抽象可能太复杂了。
- en: What Is a Port and What Is an Adapter, in Python?
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是端口，什么是适配器，在Python中？
- en: We don’t want to dwell on the terminology too much here because the main thing
    we want to focus on is dependency inversion, and the specifics of the technique
    you use don’t matter too much. Also, we’re aware that different people use slightly
    different definitions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想在这里过多地纠缠术语，因为我们想要专注于依赖反转，您使用的技术的具体细节并不太重要。此外，我们知道不同的人使用略有不同的定义。
- en: Ports and adapters came out of the OO world, and the definition we hold onto
    is that the *port* is the *interface* between our application and whatever it
    is we wish to abstract away, and the *adapter* is the *implementation* behind
    that interface or abstraction.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 端口和适配器来自OO世界，我们坚持的定义是*端口*是我们的应用程序与我们希望抽象的任何东西之间的*接口*，*适配器*是该接口或抽象背后的*实现*。
- en: Now Python doesn’t have interfaces per se, so although it’s usually easy to
    identify an adapter, defining the port can be harder. If you’re using an abstract
    base class, that’s the port. If not, the port is just the duck type that your
    adapters conform to and that your core application expects—the function and method
    names in use, and their argument names and types.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Python本身没有接口，因此虽然通常很容易识别适配器，但定义端口可能更难。如果您使用抽象基类，那就是端口。如果没有，端口就是您的适配器符合并且您的核心应用程序期望的鸭子类型——使用的函数和方法名称，以及它们的参数名称和类型。
- en: Concretely, in this chapter, `AbstractRepository` is the port, and `SqlAlchemyRepository`
    and `FakeRepository` are the adapters.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中，`AbstractRepository`是端口，`SqlAlchemyRepository`和`FakeRepository`是适配器。
- en: Wrap-Up
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Bearing the Rich Hickey quote in mind, in each chapter we summarize the costs
    and benefits of each architectural pattern we introduce. We want to be clear that
    we’re not saying every single application needs to be built this way; only sometimes
    does the complexity of the app and domain make it worth investing the time and
    effort in adding these extra layers of indirection.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记Rich Hickey的话，在每一章中，我们总结介绍的每种架构模式的成本和收益。我们想要明确的是，我们并不是说每个应用程序都需要以这种方式构建；只有在应用程序和领域的复杂性使得值得投入时间和精力来添加这些额外的间接层时，才会这样。
- en: With that in mind, [Table 2-1](#chapter_02_repository_tradeoffs) shows some
    of the pros and cons of the Repository pattern and our persistence-ignorant model.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，[表2-1](#chapter_02_repository_tradeoffs)显示了存储库模式和我们的持久性无关模型的一些优缺点。
- en: 'Table 2-1\. Repository pattern and persistence ignorance: the trade-offs'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-1\. 存储库模式和持久性无知：权衡
- en: '| Pros | Cons |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 优点 | 缺点 |'
- en: '| --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: We have a simple interface between persistent storage and our domain model.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在持久存储和我们的领域模型之间有一个简单的接口。
- en: It’s easy to make a fake version of the repository for unit testing, or to swap
    out different storage solutions, because we’ve fully decoupled the model from
    infrastructure concerns.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很容易为单元测试制作存储库的虚假版本，或者交换不同的存储解决方案，因为我们已经完全将模型与基础设施问题解耦。
- en: Writing the domain model before thinking about persistence helps us focus on
    the business problem at hand. If we ever want to radically change our approach,
    we can do that in our model, without needing to worry about foreign keys or migrations
    until later.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在考虑持久性之前编写领域模型有助于我们专注于手头的业务问题。如果我们想要彻底改变我们的方法，我们可以在模型中做到这一点，而无需担心外键或迁移直到以后。
- en: Our database schema is really simple because we have complete control over how
    we map our objects to tables.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的数据库模式非常简单，因为我们完全控制了如何将对象映射到表。
- en: '|'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: An ORM already buys you some decoupling. Changing foreign keys might be hard,
    but it should be pretty easy to swap between MySQL and Postgres if you ever need
    to.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ORM已经为您购买了一些解耦。更改外键可能很困难，但如果有必要，应该很容易在MySQL和Postgres之间进行切换。
- en: Maintaining ORM mappings by hand requires extra work and extra code.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动维护ORM映射需要额外的工作和额外的代码。
- en: Any extra layer of indirection always increases maintenance costs and adds a
    “WTF factor” for Python programmers who’ve never seen the Repository pattern before.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何额外的间接层都会增加维护成本，并为以前从未见过存储库模式的Python程序员增加“WTF因素”。
- en: '|'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[Figure 2-6](#domain_model_tradeoffs_diagram) shows the basic thesis: yes,
    for simple cases, a decoupled domain model is harder work than a simple ORM/ActiveRecord
    pattern.^([8](ch02.xhtml#idm45714904022136))'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-6](#domain_model_tradeoffs_diagram)显示了基本的论点：是的，对于简单情况，解耦的领域模型比简单的ORM/ActiveRecord模式更难工作。^([8](ch02.xhtml#idm45714904022136))'
- en: Tip
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If your app is just a simple CRUD (create-read-update-delete) wrapper around
    a database, then you don’t need a domain model or a repository.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序只是一个简单的围绕数据库的CRUD（创建-读取-更新-删除）包装器，那么您不需要领域模型或存储库。
- en: But the more complex the domain, the more an investment in freeing yourself
    from infrastructure concerns will pay off in terms of the ease of making changes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，领域越复杂，从基础设施问题中解放自己的投资将在进行更改方面产生更大的回报。
- en: '![apwp 0206](Images/apwp_0206.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![apwp 0206](Images/apwp_0206.png)'
- en: Figure 2-6\. Domain model trade-offs as a diagram
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-6\. 领域模型权衡的图表
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our example code isn’t complex enough to give more than a hint of what the
    right-hand side of the graph looks like, but the hints are there. Imagine, for
    example, if we decide one day that we want to change allocations to live on the
    `OrderLine` instead of on the `Batch` object: if we were using Django, say, we’d
    have to define and think through the database migration before we could run any
    tests. As it is, because our model is just plain old Python objects, we can change
    a `set()` to being a new attribute, without needing to think about the database
    until later.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例代码并不复杂，无法给出图表右侧的更多提示，但提示已经存在。例如，想象一下，如果有一天我们决定要将分配更改为存在于`OrderLine`而不是`Batch`对象上：如果我们正在使用Django，我们必须在运行任何测试之前定义并思考数据库迁移。因为我们的模型只是普通的Python对象，所以我们可以将`set()`更改为一个新属性，而无需考虑数据库直到以后。
- en: You’ll be wondering, how do we instantiate these repositories, fake or real?
    What will our Flask app actually look like? You’ll find out in the next exciting
    installment, [the Service Layer pattern](ch04.xhtml#chapter_04_service_layer).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，我们如何实例化这些存储库，是虚拟的还是真实的？我们的Flask应用实际上会是什么样子？在下一个激动人心的部分中，[服务层模式](ch04.xhtml#chapter_04_service_layer)中会有答案。
- en: But first, a brief digression.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们稍作偏离一下。
- en: ^([1](ch02.xhtml#idm45714911718280-marker)) I suppose we mean “no stateful dependencies.”
    Depending on a helper library is fine; depending on an ORM or a web framework
    is not.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.xhtml#idm45714911718280-marker)) 我想我们的意思是“不依赖有状态的依赖关系”。依赖于辅助库是可以的；依赖ORM或Web框架则不行。
- en: ^([2](ch02.xhtml#idm45714911705432-marker)) Mark Seemann has [an excellent blog
    post](https://oreil.ly/LpFS9) on the topic.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.xhtml#idm45714911705432-marker)) Mark Seemann在这个主题上有一篇[优秀的博客文章](https://oreil.ly/LpFS9)。
- en: ^([3](ch02.xhtml#idm45714911660872-marker)) In this sense, using an ORM is already
    an example of the DIP. Instead of depending on hardcoded SQL, we depend on an
    abstraction, the ORM. But that’s not enough for us—not in this book!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.xhtml#idm45714911660872-marker)) 从这个意义上讲，使用ORM已经是DIP的一个例子。我们不依赖硬编码的SQL，而是依赖于ORM这种抽象。但对我们来说还不够——至少在这本书中不够！
- en: ^([4](ch02.xhtml#idm45714911304232-marker)) Even in projects where we don’t
    use an ORM, we often use SQLAlchemy alongside Alembic to declaratively create
    schemas in Python and to manage migrations, connections, and sessions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.xhtml#idm45714911304232-marker)) 即使在我们不使用ORM的项目中，我们经常会在Python中使用SQLAlchemy和Alembic来声明性地创建模式，并管理迁移、连接和会话。
- en: ^([5](ch02.xhtml#idm45714910455640-marker)) Shout-out to the amazingly helpful
    SQLAlchemy maintainers, and to Mike Bayer in particular.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch02.xhtml#idm45714910455640-marker)) 向SQLAlchemy的维护者表示感谢，特别是向Mike Bayer表示感谢。
- en: ^([6](ch02.xhtml#idm45714910766952-marker)) You may be thinking, “What about
    `list` or `delete` or `update`?” However, in an ideal world, we modify our model
    objects one at a time, and delete is usually handled as a soft-delete—i.e., `batch.cancel()`.
    Finally, update is taken care of by the Unit of Work pattern, as you’ll see in
    [Chapter 6](ch06.xhtml#chapter_06_uow).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch02.xhtml#idm45714910766952-marker)) 你可能会想，“那`list`或`delete`或`update`呢？”然而，在理想的世界中，我们一次修改一个模型对象，删除通常是以软删除的方式处理——即`batch.cancel()`。最后，更新由工作单元模式处理，你将在[第6章](ch06.xhtml#chapter_06_uow)中看到。
- en: ^([7](ch02.xhtml#idm45714910910392-marker)) To really reap the benefits of ABCs
    (such as they may be), be running helpers like `pylint` and `mypy`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch02.xhtml#idm45714910910392-marker)) 要真正享受ABCs（尽管它们可能如此），请运行诸如`pylint`和`mypy`之类的辅助工具。
- en: ^([8](ch02.xhtml#idm45714904022136-marker)) Diagram inspired by a post called
    [“Global Complexity, Local Simplicity”](https://oreil.ly/fQXkP) by Rob Vens.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch02.xhtml#idm45714904022136-marker)) 图表灵感来自Rob Vens的一篇名为“全局复杂性，本地简单性”的帖子。

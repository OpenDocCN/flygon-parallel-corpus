- en: 'Chapter 3\. A Brief Interlude: On Coupling and Abstractions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Allow us a brief digression on the subject of abstractions, dear reader. We’ve
    talked about *abstractions* quite a lot. The Repository pattern is an abstraction
    over permanent storage, for example. But what makes a good abstraction? What do
    we want from abstractions? And how do they relate to testing?
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The code for this chapter is in the chapter_03_abstractions branch [on GitHub](https://oreil.ly/k6MmV):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A key theme in this book, hidden among the fancy patterns, is that we can use
    simple abstractions to hide messy details. When we’re writing code for fun, or
    in a kata,^([1](ch03.xhtml#idm45714903927544)) we get to play with ideas freely,
    hammering things out and refactoring aggressively. In a large-scale system, though,
    we become constrained by the decisions made elsewhere in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we’re unable to change component A for fear of breaking component B, we
    say that the components have become *coupled*. Locally, coupling is a good thing:
    it’s a sign that our code is working together, each component supporting the others,
    all of them fitting in place like the gears of a watch. In jargon, we say this
    works when there is high *cohesion* between the coupled elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Globally, coupling is a nuisance: it increases the risk and the cost of changing
    our code, sometimes to the point where we feel unable to make any changes at all.
    This is the problem with the Ball of Mud pattern: as the application grows, if
    we’re unable to prevent coupling between elements that have no cohesion, that
    coupling increases superlinearly until we are no longer able to effectively change
    our systems.'
  prefs: []
  type: TYPE_NORMAL
- en: We can reduce the degree of coupling within a system ([Figure 3-1](#coupling_illustration1))
    by abstracting away the details ([Figure 3-2](#coupling_illustration2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 0301](Images/apwp_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Lots of coupling
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![apwp 0302](Images/apwp_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. Less coupling
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In both diagrams, we have a pair of subsystems, with one dependent on the other.
    In [Figure 3-1](#coupling_illustration1), there is a high degree of coupling between
    the two; the number of arrows indicates lots of kinds of dependencies between
    the two. If we need to change system B, there’s a good chance that the change
    will ripple through to system A.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 3-2](#coupling_illustration2), though, we have reduced the degree
    of coupling by inserting a new, simpler abstraction. Because it is simpler, system
    A has fewer kinds of dependencies on the abstraction. The abstraction serves to
    protect us from change by hiding away the complex details of whatever system B
    does—we can change the arrows on the right without changing the ones on the left.
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting State Aids Testability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s see an example. Imagine we want to write code for synchronizing two file
    directories, which we’ll call the *source* and the *destination*:'
  prefs: []
  type: TYPE_NORMAL
- en: If a file exists in the source but not in the destination, copy the file over.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a file exists in the source, but it has a different name than in the destination,
    rename the destination file to match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a file exists in the destination but not in the source, remove it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our first and third requirements are simple enough: we can just compare two
    lists of paths. Our second is trickier, though. To detect renames, we’ll have
    to inspect the content of files. For this, we can use a hashing function like
    MD5 or SHA-1\. The code to generate a SHA-1 hash from a file is simple enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Hashing a file (sync.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to write the bit that makes decisions about what to do—the business
    logic, if you will.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have to tackle a problem from first principles, we usually try to write
    a simple implementation and then refactor toward better design. We’ll use this
    approach throughout the book, because it’s how we write code in the real world:
    start with a solution to the smallest part of the problem, and then iteratively
    make the solution richer and better designed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first hackish approach looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Basic sync algorithm (sync.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Fantastic! We have some code and it *looks* OK, but before we run it on our
    hard drive, maybe we should test it. How do we go about testing this sort of thing?
  prefs: []
  type: TYPE_NORMAL
- en: '*Some end-to-end tests (test_sync.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Wowsers, that’s a lot of setup for two simple cases! The problem is that our
    domain logic, “figure out the difference between two directories,” is tightly
    coupled to the I/O code. We can’t run our difference algorithm without calling
    the `pathlib`, `shutil`, and `hashlib` modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'And the trouble is, even with our current requirements, we haven’t written
    enough tests: the current implementation has several bugs (the `shutil.move()`
    is wrong, for example). Getting decent coverage and revealing these bugs means
    writing more tests, but if they’re all as unwieldy as the preceding ones, that’s
    going to get real painful real quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: On top of that, our code isn’t very extensible. Imagine trying to implement
    a `--dry-run` flag that gets our code to just print out what it’s going to do,
    rather than actually do it. Or what if we wanted to sync to a remote server, or
    to cloud storage?
  prefs: []
  type: TYPE_NORMAL
- en: Our high-level code is coupled to low-level details, and it’s making life hard.
    As the scenarios we consider get more complex, our tests will get more unwieldy.
    We can definitely refactor these tests (some of the cleanup could go into pytest
    fixtures, for example) but as long as we’re doing filesystem operations, they’re
    going to stay slow and be hard to read and write.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the Right Abstraction(s)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What could we do to rewrite our code to make it more testable?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to think about what our code needs from the filesystem. Reading
    through the code, we can see that three distinct things are happening. We can
    think of these as three distinct *responsibilities* that the code has:'
  prefs: []
  type: TYPE_NORMAL
- en: We interrogate the filesystem by using `os.walk` and determine hashes for a
    series of paths. This is similar in both the source and the destination cases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We decide whether a file is new, renamed, or redundant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We copy, move, or delete files to match the source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember that we want to find *simplifying abstractions* for each of these responsibilities.
    That will let us hide the messy details so we can focus on the interesting logic.^([2](ch03.xhtml#idm45714903333384))
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this chapter, we’re refactoring some gnarly code into a more testable structure
    by identifying the separate tasks that need to be done and giving each task to
    a clearly defined actor, along similar lines to [the `duckduckgo` example](preface02.xhtml#ddg_example).
  prefs: []
  type: TYPE_NORMAL
- en: 'For steps 1 and 2, we’ve already intuitively started using an abstraction,
    a dictionary of hashes to paths. You may already have been thinking, “Why not
    build up a dictionary for the destination folder as well as the source, and then
    we just compare two dicts?” That seems like a nice way to abstract the current
    state of the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What about moving from step 2 to step 3? How can we abstract out the actual
    move/copy/delete filesystem interaction?
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll apply a trick here that we’ll employ on a grand scale later in the book.
    We’re going to separate *what* we want to do from *how* to do it. We’re going
    to make our program output a list of commands that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now we could write tests that just use two filesystem dicts as inputs, and we
    would expect lists of tuples of strings representing actions as outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of saying, “Given this actual filesystem, when I run my function, check
    what actions have happened,” we say, “Given this *abstraction* of a filesystem,
    what *abstraction* of filesystem actions will happen?”
  prefs: []
  type: TYPE_NORMAL
- en: '*Simplified inputs and outputs in our tests (test_sync.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Implementing Our Chosen Abstractions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That’s all very well, but how do we *actually* write those new tests, and how
    do we change our implementation to make it all work?
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to isolate the clever part of our system, and to be able to test
    it thoroughly without needing to set up a real filesystem. We’ll create a “core”
    of code that has no dependencies on external state and then see how it responds
    when we give it input from the outside world (this kind of approach was characterized
    by Gary Bernhardt as [Functional Core, Imperative Shell](https://oreil.ly/wnad4),
    or FCIS).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start off by splitting the code to separate the stateful parts from the
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'And our top-level function will contain almost no logic at all; it’s just an
    imperative series of steps: gather inputs, call our logic, apply outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Split our code into three (sync.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_a_brief_interlude__on_coupling__span_class__keep_together__and_abstractions__span__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the first function we factor out, `read_paths_and_hashes()`, which isolates
    the I/O part of our application.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_a_brief_interlude__on_coupling__span_class__keep_together__and_abstractions__span__CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Here is where carve out the functional core, the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to build up the dictionary of paths and hashes is now trivially easy
    to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A function that just does I/O (sync.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `determine_actions()` function will be the core of our business logic,
    which says, “Given these two sets of hashes and filenames, what should we copy/move/delete?”.
    It takes simple data structures and returns simple data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A function that just does business logic (sync.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Our tests now act directly on the `determine_actions()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Nicer-looking tests (test_sync.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Because we’ve disentangled the logic of our program—the code for identifying
    changes—from the low-level details of I/O, we can easily test the core of our
    code.
  prefs: []
  type: TYPE_NORMAL
- en: With this approach, we’ve switched from testing our main entrypoint function,
    `sync()`, to testing a lower-level function, `determine_actions()`. You might
    decide that’s fine because `sync()` is now so simple. Or you might decide to keep
    some integration/acceptance tests to test that `sync()`. But there’s another option,
    which is to modify the `sync()` function so it can be unit tested *and* end-to-end
    tested; it’s an approach Bob calls *edge-to-edge testing*.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Edge to Edge with Fakes and Dependency Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we start writing a new system, we often focus on the core logic first,
    driving it with direct unit tests. At some point, though, we want to test bigger
    chunks of the system together.
  prefs: []
  type: TYPE_NORMAL
- en: 'We *could* return to our end-to-end tests, but those are still as tricky to
    write and maintain as before. Instead, we often write tests that invoke a whole
    system together but fake the I/O, sort of *edge to edge*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Explicit dependencies (sync.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_a_brief_interlude__on_coupling__span_class__keep_together__and_abstractions__span__CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Our top-level function now exposes two new dependencies, a `reader` and a `filesystem`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_a_brief_interlude__on_coupling__span_class__keep_together__and_abstractions__span__CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We invoke the `reader` to produce our files dict.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_a_brief_interlude__on_coupling__span_class__keep_together__and_abstractions__span__CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We invoke the `filesystem` to apply the changes we detect.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although we’re using dependency injection, there is no need to define an abstract
    base class or any kind of explicit interface. In this book, we often show ABCs
    because we hope they help you understand what the abstraction is, but they’re
    not necessary. Python’s dynamic nature means we can always rely on duck typing.
  prefs: []
  type: TYPE_NORMAL
- en: '*Tests using DI*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_a_brief_interlude__on_coupling__span_class__keep_together__and_abstractions__span__CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Bob *loves* using lists to build simple test doubles, even though his coworkers
    get mad. It means we can write tests like `assert *foo* not in database`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_a_brief_interlude__on_coupling__span_class__keep_together__and_abstractions__span__CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Each method in our `FakeFileSystem` just appends something to the list so we
    can inspect it later. This is an example of a spy object.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this approach is that our tests act on the exact same function
    that’s used by our production code. The disadvantage is that we have to make our
    stateful components explicit and pass them around. David Heinemeier Hansson, the
    creator of Ruby on Rails, famously described this as “test-induced design damage.”
  prefs: []
  type: TYPE_NORMAL
- en: In either case, we can now work on fixing all the bugs in our implementation;
    enumerating tests for all the edge cases is now much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Why Not Just Patch It Out?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point you may be scratching your head and thinking, “Why don’t you just
    use `mock.patch` and save yourself the effort?"”
  prefs: []
  type: TYPE_NORMAL
- en: We avoid using mocks in this book and in our production code too. We’re not
    going to enter into a Holy War, but our instinct is that mocking frameworks, particularly
    monkeypatching, are a code smell.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we like to clearly identify the responsibilities in our codebase, and
    to separate those responsibilities into small, focused objects that are easy to
    replace with a test double.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can see an example in [Chapter 8](ch08.xhtml#chapter_08_events_and_message_bus),
    where we `mock.patch()` out an email-sending module, but eventually we replace
    that with an explicit bit of dependency injection in [Chapter 13](ch13.xhtml#chapter_13_dependency_injection).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have three closely related reasons for our preference:'
  prefs: []
  type: TYPE_NORMAL
- en: Patching out the dependency you’re using makes it possible to unit test the
    code, but it does nothing to improve the design. Using `mock.patch` won’t let
    your code work with a `--dry-run` flag, nor will it help you run against an FTP
    server. For that, you’ll need to introduce abstractions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tests that use mocks *tend* to be more coupled to the implementation details
    of the codebase. That’s because mock tests verify the interactions between things:
    did we call `shutil.copy` with the right arguments? This coupling between code
    and test *tends* to make tests more brittle, in our experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overuse of mocks leads to complicated test suites that fail to explain the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Designing for testability really means designing for extensibility. We trade
    off a little more complexity for a cleaner design that admits novel use cases.
  prefs: []
  type: TYPE_NORMAL
- en: We view TDD as a design practice first and a testing practice second. The tests
    act as a record of our design choices and serve to explain the system to us when
    we return to the code after a long absence.
  prefs: []
  type: TYPE_NORMAL
- en: Tests that use too many mocks get overwhelmed with setup code that hides the
    story we care about.
  prefs: []
  type: TYPE_NORMAL
- en: Steve Freeman has a great example of overmocked tests in his talk [“Test-Driven
    Development”](https://oreil.ly/jAmtr). You should also check out this PyCon talk,
    [“Mocking and Patching Pitfalls”](https://oreil.ly/s3e05), by our esteemed tech
    reviewer, Ed Jung, which also addresses mocking and its alternatives. And while
    we’re recommending talks, don’t miss Brandon Rhodes talking about [“Hoisting Your
    I/O”](https://oreil.ly/oiXJM), which really nicely covers the issues we’re talking
    about, using another simple example.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In this chapter, we’ve spent a lot of time replacing end-to-end tests with
    unit tests. That doesn’t mean we think you should never use E2E tests! In this
    book we’re showing techniques to get you to a decent test pyramid with as many
    unit tests as possible, and with the minimum number of E2E tests you need to feel
    confident. Read on to [“Recap: Rules of Thumb for Different Types of Test”](ch05.xhtml#types_of_test_rules_of_thumb)
    for more details.'
  prefs: []
  type: TYPE_NORMAL
- en: Wrap-Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ll see this idea come up again and again in the book: we can make our systems
    easier to test and maintain by simplifying the interface between our business
    logic and messy I/O. Finding the right abstraction is tricky, but here are a few
    heuristics and questions to ask yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: Can I choose a familiar Python data structure to represent the state of the
    messy system and then try to imagine a single function that can return that state?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where can I draw a line between my systems, where can I carve out a [seam](https://oreil.ly/zNUGG)
    to stick that abstraction in?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a sensible way of dividing things into components with different responsibilities?
    What implicit concepts can I make explicit?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the dependencies, and what is the core business logic?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practice makes less imperfect! And now back to our regular programming…
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch03.xhtml#idm45714903927544-marker)) A code kata is a small, contained
    programming challenge often used to practice TDD. See [“Kata—The Only Way to Learn
    TDD”](https://oreil.ly/vhjju) by Peter Provost.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch03.xhtml#idm45714903333384-marker)) If you’re used to thinking in terms
    of interfaces, that’s what we’re trying to define here.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch03.xhtml#idm45714902198776-marker)) Which is not to say that we think
    the London school people are wrong. Some insanely smart people work that way.
    It’s just not what we’re used to.
  prefs: []
  type: TYPE_NORMAL

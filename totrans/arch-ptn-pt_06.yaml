- en: 'Chapter 4\. Our First Use Case: Flask API and Service Layer'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back to our allocations project! [Figure 4-1](#maps_service_layer_before) shows
    the point we reached at the end of [Chapter 2](ch02.xhtml#chapter_02_repository),
    which covered the Repository pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 0401](Images/apwp_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-1\. Before: we drive our app by talking to repositories and the domain
    model'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this chapter, we discuss the differences between orchestration logic, business
    logic, and interfacing code, and we introduce the *Service Layer* pattern to take
    care of orchestrating our workflows and defining the use cases of our system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll also discuss testing: by combining the Service Layer with our repository
    abstraction over the database, we’re able to write fast tests, not just of our
    domain model but of the entire workflow for a use case.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-2](#maps_service_layer_after) shows what we’re aiming for: we’re
    going to add a Flask API that will talk to the service layer, which will serve
    as the entrypoint to our domain model. Because our service layer depends on the
    `AbstractRepository`, we can unit test it by using `FakeRepository` but run our
    production code using `SqlAlchemyRepository`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 0402](Images/apwp_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. The service layer will become the main way into our app
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In our diagrams, we are using the convention that new components are highlighted
    with bold text/lines (and yellow/orange color, if you’re reading a digital version).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The code for this chapter is in the chapter_04_service_layer branch [on GitHub](https://oreil.ly/TBRuy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Connecting Our Application to the Real World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like any good agile team, we’re hustling to try to get an MVP out and in front
    of the users to start gathering feedback. We have the core of our domain model
    and the domain service we need to allocate orders, and we have the repository
    interface for permanent storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s plug all the moving parts together as quickly as we can and then refactor
    toward a cleaner architecture. Here’s our plan:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Flask to put an API endpoint in front of our `allocate` domain service.
    Wire up the database session and our repository. Test it with an end-to-end test
    and some quick-and-dirty SQL to prepare test data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactor out a service layer that can serve as an abstraction to capture the
    use case and that will sit between Flask and our domain model. Build some service-layer
    tests and show how they can use `FakeRepository`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Experiment with different types of parameters for our service layer functions;
    show that using primitive data types allows the service layer’s clients (our tests
    and our Flask API) to be decoupled from the model layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A First End-to-End Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No one is interested in getting into a long terminology debate about what counts
    as an end-to-end (E2E) test versus a functional test versus an acceptance test
    versus an integration test versus a unit test. Different projects need different
    combinations of tests, and we’ve seen perfectly successful projects just split
    things into “fast tests” and “slow tests.”
  prefs: []
  type: TYPE_NORMAL
- en: For now, we want to write one or maybe two tests that are going to exercise
    a “real” API endpoint (using HTTP) and talk to a real database. Let’s call them
    *end-to-end tests* because it’s one of the most self-explanatory names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows a first cut:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A first API test (test_api.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_our_first_use_case___span_class__keep_together__flask_api_and_service_layer__span__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`random_sku()`, `random_batchref()`, and so on are little helper functions
    that generate randomized characters by using the `uuid` module. Because we’re
    running against an actual database now, this is one way to prevent various tests
    and runs from interfering with each other.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_our_first_use_case___span_class__keep_together__flask_api_and_service_layer__span__CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`add_stock` is a helper fixture that just hides away the details of manually
    inserting rows into the database using SQL. We’ll show a nicer way of doing this
    later in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_our_first_use_case___span_class__keep_together__flask_api_and_service_layer__span__CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '*config.py* is a module in which we keep configuration information.'
  prefs: []
  type: TYPE_NORMAL
- en: Everyone solves these problems in different ways, but you’re going to need some
    way of spinning up Flask, possibly in a container, and of talking to a Postgres
    database. If you want to see how we did it, check out [Appendix B](app02.xhtml#appendix_project_structure).
  prefs: []
  type: TYPE_NORMAL
- en: The Straightforward Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing things in the most obvious way, you might get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*First cut of Flask app (flask_app.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So far, so good. No need for too much more of your “architecture astronaut”
    nonsense, Bob and Harry, you may be thinking.
  prefs: []
  type: TYPE_NORMAL
- en: 'But hang on a minute—there’s no commit. We’re not actually saving our allocation
    to the database. Now we need a second test, either one that will inspect the database
    state after (not very black-boxy), or maybe one that checks that we can’t allocate
    a second line if a first should have already depleted the batch:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Test allocations are persisted (test_api.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Not quite so lovely, but that will force us to add the commit.
  prefs: []
  type: TYPE_NORMAL
- en: Error Conditions That Require Database Checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we keep going like this, though, things are going to get uglier and uglier.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to add a bit of error handling. What if the domain raises an
    error, for a SKU that’s out of stock? Or what about a SKU that doesn’t even exist?
    That’s not something the domain even knows about, nor should it. It’s more of
    a sanity check that we should implement at the database layer, before we even
    invoke the domain service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re looking at two more end-to-end tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Yet more tests at the E2E layer (test_api.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_our_first_use_case___span_class__keep_together__flask_api_and_service_layer__span__CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: In the first test, we’re trying to allocate more units than we have in stock.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_our_first_use_case___span_class__keep_together__flask_api_and_service_layer__span__CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: In the second, the SKU just doesn’t exist (because we never called `add_stock`),
    so it’s invalid as far as our app is concerned.
  prefs: []
  type: TYPE_NORMAL
- en: 'And sure, we could implement it in the Flask app too:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Flask app starting to get crufty (flask_app.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: But our Flask app is starting to look a bit unwieldy. And our number of E2E
    tests is starting to get out of control, and soon we’ll end up with an inverted
    test pyramid (or “ice-cream cone model,” as Bob likes to call it).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing a Service Layer, and Using FakeRepository to Unit Test It
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we look at what our Flask app is doing, there’s quite a lot of what we might
    call *orchestration*—fetching stuff out of our repository, validating our input
    against database state, handling errors, and committing in the happy path. Most
    of these things don’t have anything to do with having a web API endpoint (you’d
    need them if you were building a CLI, for example; see [Appendix C](app03.xhtml#appendix_csvs)),
    and they’re not really things that need to be tested by end-to-end tests.
  prefs: []
  type: TYPE_NORMAL
- en: It often makes sense to split out a service layer, sometimes called an *orchestration
    layer* or a *use-case layer*.
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember the `FakeRepository` that we prepared in [Chapter 3](ch03.xhtml#chapter_03_abstractions)?
  prefs: []
  type: TYPE_NORMAL
- en: '*Our fake repository, an in-memory collection of batches (test_services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s where it will come in useful; it lets us test our service layer with
    nice, fast unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Unit testing with fakes at the service layer (test_services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_our_first_use_case___span_class__keep_together__flask_api_and_service_layer__span__CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`FakeRepository` holds the `Batch` objects that will be used by our test.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_our_first_use_case___span_class__keep_together__flask_api_and_service_layer__span__CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Our services module (*services.py*) will define an `allocate()` service-layer
    function. It will sit between our `allocate_endpoint()` function in the API layer
    and the `allocate()` domain service function from our domain model.^([1](ch04.xhtml#idm45714900481752))
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_our_first_use_case___span_class__keep_together__flask_api_and_service_layer__span__CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We also need a `FakeSession` to fake out the database session, as shown in the
    following code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: '*A fake database session (test_services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This fake session is only a temporary solution. We’ll get rid of it and make
    things even nicer soon, in [Chapter 6](ch06.xhtml#chapter_06_uow). But in the
    meantime the fake `.commit()` lets us migrate a third test from the E2E layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A second test at the service layer (test_services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A Typical Service Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll write a service function that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Basic allocation service (services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Typical service-layer functions have similar steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](Images/1.png)](#co_our_first_use_case___span_class__keep_together__flask_api_and_service_layer__span__CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We fetch some objects from the repository.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_our_first_use_case___span_class__keep_together__flask_api_and_service_layer__span__CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We make some checks or assertions about the request against the current state
    of the world.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_our_first_use_case___span_class__keep_together__flask_api_and_service_layer__span__CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We call a domain service.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_our_first_use_case___span_class__keep_together__flask_api_and_service_layer__span__CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: If all is well, we save/update any state we’ve changed.
  prefs: []
  type: TYPE_NORMAL
- en: That last step is a little unsatisfactory at the moment, as our service layer
    is tightly coupled to our database layer. We’ll improve that in [Chapter 6](ch06.xhtml#chapter_06_uow)
    with the Unit of Work pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the essentials of the service layer are there, and our Flask app now looks
    a lot cleaner:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Flask app delegating to service layer (flask_app.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_our_first_use_case___span_class__keep_together__flask_api_and_service_layer__span__CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We instantiate a database session and some repository objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_our_first_use_case___span_class__keep_together__flask_api_and_service_layer__span__CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We extract the user’s commands from the web request and pass them to a domain
    service.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_our_first_use_case___span_class__keep_together__flask_api_and_service_layer__span__CO5-7)'
  prefs: []
  type: TYPE_NORMAL
- en: We return some JSON responses with the appropriate status codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The responsibilities of the Flask app are just standard web stuff: per-request
    session management, parsing information out of POST parameters, response status
    codes, and JSON. All the orchestration logic is in the use case/service layer,
    and the domain logic stays in the domain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can confidently strip down our E2E tests to just two, one for the
    happy path and one for the unhappy path:'
  prefs: []
  type: TYPE_NORMAL
- en: '*E2E tests only happy and unhappy paths (test_api.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve successfully split our tests into two broad categories: tests about web
    stuff, which we implement end to end; and tests about orchestration stuff, which
    we can test against the service layer in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: Why Is Everything Called a Service?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of you are probably scratching your heads at this point trying to figure
    out exactly what the difference is between a domain service and a service layer.
  prefs: []
  type: TYPE_NORMAL
- en: We’re sorry—we didn’t choose the names, or we’d have much cooler and friendlier
    ways to talk about this stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re using two things called a *service* in this chapter. The first is an
    *application service* (our service layer). Its job is to handle requests from
    the outside world and to *orchestrate* an operation. What we mean is that the
    service layer *drives* the application by following a bunch of simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Get some data from the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the domain model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persist any changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the kind of boring work that has to happen for every operation in your
    system, and keeping it separate from business logic helps to keep things tidy.
  prefs: []
  type: TYPE_NORMAL
- en: The second type of service is a *domain service*. This is the name for a piece
    of logic that belongs in the domain model but doesn’t sit naturally inside a stateful
    entity or value object. For example, if you were building a shopping cart application,
    you might choose to build taxation rules as a domain service. Calculating tax
    is a separate job from updating the cart, and it’s an important part of the model,
    but it doesn’t seem right to have a persisted entity for the job. Instead a stateless
    TaxCalculator class or a `calculate_tax` function can do the job.
  prefs: []
  type: TYPE_NORMAL
- en: Putting Things in Folders to See Where It All Belongs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our application gets bigger, we’ll need to keep tidying our directory structure.
    The layout of our project gives us useful hints about what kinds of object we’ll
    find in each file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one way we could organize things:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some subfolders*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_our_first_use_case___span_class__keep_together__flask_api_and_service_layer__span__CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a folder for our domain model. Currently that’s just one file, but
    for a more complex application, you might have one file per class; you might have
    helper parent classes for `Entity`, `ValueObject`, and `Aggregate`, and you might
    add an *exceptions.py* for domain-layer exceptions and, as you’ll see in [Part II](part02.xhtml#part2),
    *commands.py* and *events.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_our_first_use_case___span_class__keep_together__flask_api_and_service_layer__span__CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll distinguish the service layer. Currently that’s just one file called *services.py*
    for our service-layer functions. You could add service-layer exceptions here,
    and as you’ll see in [Chapter 5](ch05.xhtml#chapter_05_high_gear_low_gear), we’ll
    add *unit_of_work.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_our_first_use_case___span_class__keep_together__flask_api_and_service_layer__span__CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Adapters* is a nod to the ports and adapters terminology. This will fill up
    with any other abstractions around external I/O (e.g., a *redis_client.py*). Strictly
    speaking, you would call these *secondary* adapters or *driven* adapters, or sometimes
    *inward-facing* adapters.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_our_first_use_case___span_class__keep_together__flask_api_and_service_layer__span__CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Entrypoints are the places we drive our application from. In the official ports
    and adapters terminology, these are adapters too, and are referred to as *primary*,
    *driving*, or *outward-facing* adapters.
  prefs: []
  type: TYPE_NORMAL
- en: What about ports? As you may remember, they are the abstract interfaces that
    the adapters implement. We tend to keep them in the same file as the adapters
    that implement them.
  prefs: []
  type: TYPE_NORMAL
- en: Wrap-Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding the service layer has really bought us quite a lot:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Flask API endpoints become very thin and easy to write: their only responsibility
    is doing “web stuff,” such as parsing JSON and producing the right HTTP codes
    for happy or unhappy cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve defined a clear API for our domain, a set of use cases or entrypoints
    that can be used by any adapter without needing to know anything about our domain
    model classes—whether that’s an API, a CLI (see [Appendix C](app03.xhtml#appendix_csvs)),
    or the tests! They’re an adapter for our domain too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can write tests in “high gear” by using the service layer, leaving us free
    to refactor the domain model in any way we see fit. As long as we can still deliver
    the same use cases, we can experiment with new designs without needing to rewrite
    a load of tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And our test pyramid is looking good—the bulk of our tests are fast unit tests,
    with just the bare minimum of E2E and integration tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DIP in Action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Figure 4-3](#service_layer_diagram_abstract_dependencies) shows the dependencies
    of our service layer: the domain model and `AbstractRepository` (the port, in
    ports and adapters terminology).'
  prefs: []
  type: TYPE_NORMAL
- en: When we run the tests, [Figure 4-4](#service_layer_diagram_test_dependencies)
    shows how we implement the abstract dependencies by using `FakeRepository` (the
    adapter).
  prefs: []
  type: TYPE_NORMAL
- en: And when we actually run our app, we swap in the “real” dependency shown in
    [Figure 4-5](#service_layer_diagram_runtime_dependencies).
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 0403](Images/apwp_0403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. Abstract dependencies of the service layer
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![apwp 0404](Images/apwp_0404.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4\. Tests provide an implementation of the abstract dependency
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![apwp 0405](Images/apwp_0405.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-5\. Dependencies at runtime
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Wonderful.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s pause for [Table 4-1](#chapter_04_service_layer_tradeoffs), in which we
    consider the pros and cons of having a service layer at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-1\. Service layer: the trade-offs'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pros | Cons |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: We have a single place to capture all the use cases for our application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve placed our clever domain logic behind an API, which leaves us free to
    refactor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have cleanly separated “stuff that talks HTTP” from “stuff that talks allocation.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When combined with the Repository pattern and `FakeRepository`, we have a nice
    way of writing tests at a higher level than the domain layer; we can test more
    of our workflow without needing to use integration tests (read on to [Chapter 5](ch05.xhtml#chapter_05_high_gear_low_gear)
    for more elaboration on this).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: If your app is *purely* a web app, your controllers/view functions can be the
    single place to capture all the use cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s yet another layer of abstraction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting too much logic into the service layer can lead to the *Anemic Domain*
    anti-pattern. It’s better to introduce this layer after you spot orchestration
    logic creeping into your controllers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can get a lot of the benefits that come from having rich domain models by
    simply pushing logic out of your controllers and down to the model layer, without
    needing to add an extra layer in between (aka “fat models, thin controllers”).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'But there are still some bits of awkwardness to tidy up:'
  prefs: []
  type: TYPE_NORMAL
- en: The service layer is still tightly coupled to the domain, because its API is
    expressed in terms of `OrderLine` objects. In [Chapter 5](ch05.xhtml#chapter_05_high_gear_low_gear),
    we’ll fix that and talk about the way that the service layer enables more productive
    TDD.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service layer is tightly coupled to a `session` object. In [Chapter 6](ch06.xhtml#chapter_06_uow),
    we’ll introduce one more pattern that works closely with the Repository and Service
    Layer patterns, the Unit of Work pattern, and everything will be absolutely lovely.
    You’ll see!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch04.xhtml#idm45714900481752-marker)) Service-layer services and domain
    services do have confusingly similar names. We tackle this topic later in [“Why
    Is Everything Called a Service?”](#why_is_everything_a_service).
  prefs: []
  type: TYPE_NORMAL

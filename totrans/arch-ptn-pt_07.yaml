- en: Chapter 5\. TDD in High Gear and Low Gear
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve introduced the service layer to capture some of the additional orchestration
    responsibilities we need from a working application. The service layer helps us
    clearly define our use cases and the workflow for each: what we need to get from
    our repositories, what pre-checks and current state validation we should do, and
    what we save at the end.'
  prefs: []
  type: TYPE_NORMAL
- en: But currently, many of our unit tests operate at a lower level, acting directly
    on the model. In this chapter we’ll discuss the trade-offs involved in moving
    those tests up to the service-layer level, and some more general testing guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: How Is Our Test Pyramid Looking?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s see what this move to using a service layer, with its own service-layer
    tests, does to our test pyramid:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Counting types of tests*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Not bad! We have 15 unit tests, 8 integration tests, and just 2 end-to-end tests.
    That’s already a healthy-looking test pyramid.
  prefs: []
  type: TYPE_NORMAL
- en: Should Domain Layer Tests Move to the Service Layer?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s see what happens if we take this a step further. Since we can test our
    software against the service layer, we don’t really need tests for the domain
    model anymore. Instead, we could rewrite all of the domain-level tests from [Chapter 1](ch01.xhtml#chapter_01_domain_model)
    in terms of the service layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Rewriting a domain test at the service layer (tests/unit/test_services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Why would we want to do that?
  prefs: []
  type: TYPE_NORMAL
- en: Tests are supposed to help us change our system fearlessly, but often we see
    teams writing too many tests against their domain model. This causes problems
    when they come to change their codebase and find that they need to update tens
    or even hundreds of unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: This makes sense if you stop to think about the purpose of automated tests.
    We use tests to enforce that a property of the system doesn’t change while we’re
    working. We use tests to check that the API continues to return 200, that the
    database session continues to commit, and that orders are still being allocated.
  prefs: []
  type: TYPE_NORMAL
- en: If we accidentally change one of those behaviors, our tests will break. The
    flip side, though, is that if we want to change the design of our code, any tests
    relying directly on that code will also fail.
  prefs: []
  type: TYPE_NORMAL
- en: As we get further into the book, you’ll see how the service layer forms an API
    for our system that we can drive in multiple ways. Testing against this API reduces
    the amount of code that we need to change when we refactor our domain model. If
    we restrict ourselves to testing only against the service layer, we won’t have
    any tests that directly interact with “private” methods or attributes on our model
    objects, which leaves us freer to refactor them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Every line of code that we put in a test is like a blob of glue, holding the
    system in a particular shape. The more low-level tests we have, the harder it
    will be to change things.
  prefs: []
  type: TYPE_NORMAL
- en: On Deciding What Kind of Tests to Write
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might be asking yourself, “Should I rewrite all my unit tests, then? Is
    it wrong to write tests against the domain model?” To answer those questions,
    it’s important to understand the trade-off between coupling and design feedback
    (see [Figure 5-1](#test_spectrum_diagram)).
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 0501](Images/apwp_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. The test spectrum
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Extreme programming (XP) exhorts us to “listen to the code.” When we’re writing
    tests, we might find that the code is hard to use or notice a code smell. This
    is a trigger for us to refactor, and to reconsider our design.
  prefs: []
  type: TYPE_NORMAL
- en: We only get that feedback, though, when we’re working closely with the target
    code. A test for the HTTP API tells us nothing about the fine-grained design of
    our objects, because it sits at a much higher level of abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we can rewrite our entire application and, so long as we
    don’t change the URLs or request formats, our HTTP tests will continue to pass.
    This gives us confidence that large-scale changes, like changing the database
    schema, haven’t broken our code.
  prefs: []
  type: TYPE_NORMAL
- en: At the other end of the spectrum, the tests we wrote in [Chapter 1](ch01.xhtml#chapter_01_domain_model)
    helped us to flesh out our understanding of the objects we need. The tests guided
    us to a design that makes sense and reads in the domain language. When our tests
    read in the domain language, we feel comfortable that our code matches our intuition
    about the problem we’re trying to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Because the tests are written in the domain language, they act as living documentation
    for our model. A new team member can read these tests to quickly understand how
    the system works and how the core concepts interrelate.
  prefs: []
  type: TYPE_NORMAL
- en: We often “sketch” new behaviors by writing tests at this level to see how the
    code might look. When we want to improve the design of the code, though, we will
    need to replace or delete these tests, because they are tightly coupled to a particular
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: High and Low Gear
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, when we are adding a new feature or fixing a bug, we don’t
    need to make extensive changes to the domain model. In these cases, we prefer
    to write tests against services because of the lower coupling and higher coverage.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when writing an `add_stock` function or a `cancel_order` feature,
    we can work more quickly and with less coupling by writing tests against the service
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: When starting a new project or when hitting a particularly gnarly problem, we
    will drop back down to writing tests against the domain model so we get better
    feedback and executable documentation of our intent.
  prefs: []
  type: TYPE_NORMAL
- en: The metaphor we use is that of shifting gears. When starting a journey, the
    bicycle needs to be in a low gear so that it can overcome inertia. Once we’re
    off and running, we can go faster and more efficiently by changing into a high
    gear; but if we suddenly encounter a steep hill or are forced to slow down by
    a hazard, we again drop down to a low gear until we can pick up speed again.
  prefs: []
  type: TYPE_NORMAL
- en: Fully Decoupling the Service-Layer Tests from the Domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We still have direct dependencies on the domain in our service-layer tests,
    because we use domain objects to set up our test data and to invoke our service-layer
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: To have a service layer that’s fully decoupled from the domain, we need to rewrite
    its API to work in terms of primitives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our service layer currently takes an `OrderLine` domain object:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Before: allocate takes a domain object (service_layer/services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How would it look if its parameters were all primitive types?
  prefs: []
  type: TYPE_NORMAL
- en: '*After: allocate takes strings and ints (service_layer/services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We rewrite the tests in those terms as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Tests now use primitives in function call (tests/unit/test_services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: But our tests still depend on the domain, because we still manually instantiate
    `Batch` objects. So, if one day we decide to massively refactor how our `Batch`
    model works, we’ll have to change a bunch of tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mitigation: Keep All Domain Dependencies in Fixture Functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We could at least abstract that out to a helper function or a fixture in our
    tests. Here’s one way you could do that, adding a factory function on `FakeRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Factory functions for fixtures are one possibility (tests/unit/test_services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At least that would move all of our tests’ dependencies on the domain into one
    place.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Missing Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We could go one step further, though. If we had a service to add stock, we
    could use that and make our service-layer tests fully expressed in terms of the
    service layer’s official use cases, removing all dependencies on the domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Test for new add_batch service (tests/unit/test_services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In general, if you find yourself needing to do domain-layer stuff directly in
    your service-layer tests, it may be an indication that your service layer is incomplete.
  prefs: []
  type: TYPE_NORMAL
- en: 'And the implementation is just two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A new service for add_batch (service_layer/services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Should you write a new service just because it would help remove dependencies
    from your tests? Probably not. But in this case, we almost definitely would need
    an `add_batch` service one day anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'That now allows us to rewrite *all* of our service-layer tests purely in terms
    of the services themselves, using only primitives, and without any dependencies
    on the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Services tests now use only services (tests/unit/test_services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is a really nice place to be in. Our service-layer tests depend on only
    the service layer itself, leaving us completely free to refactor the model as
    we see fit.
  prefs: []
  type: TYPE_NORMAL
- en: Carrying the Improvement Through to the E2E Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the same way that adding `add_batch` helped decouple our service-layer tests
    from the model, adding an API endpoint to add a batch would remove the need for
    the ugly `add_stock` fixture, and our E2E tests could be free of those hardcoded
    SQL queries and the direct dependency on the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to our service function, adding the endpoint is easy, with just a little
    JSON wrangling and a single function call required:'
  prefs: []
  type: TYPE_NORMAL
- en: '*API for adding a batch (entrypoints/flask_app.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Are you thinking to yourself, POST to */add_batch*? That’s not very RESTful!
    You’re quite right. We’re being happily sloppy, but if you’d like to make it all
    more RESTy, maybe a POST to */batches*, then knock yourself out! Because Flask
    is a thin adapter, it’ll be easy. See [the next sidebar](#types_of_test_rules_of_thumb).
  prefs: []
  type: TYPE_NORMAL
- en: 'And our hardcoded SQL queries from *conftest.py* get replaced with some API
    calls, meaning the API tests have no dependencies other than the API, which is
    also nice:'
  prefs: []
  type: TYPE_NORMAL
- en: '*API tests can now add their own batches (tests/e2e/test_api.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Wrap-Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have a service layer in place, you really can move the majority of
    your test coverage to unit tests and develop a healthy test pyramid.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few things will help along the way:'
  prefs: []
  type: TYPE_NORMAL
- en: Express your service layer in terms of primitives rather than domain objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In an ideal world, you’ll have all the services you need to be able to test
    entirely against the service layer, rather than hacking state via repositories
    or the database. This pays off in your end-to-end tests as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Onto the next chapter!
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](ch05.xhtml#idm45714894903464-marker)) A valid concern about writing tests
    at a higher level is that it can lead to combinatorial explosion for more complex
    use cases. In these cases, dropping down to lower-level unit tests of the various
    collaborating domain objects can be useful. But see also [Chapter 8](ch08.xhtml#chapter_08_events_and_message_bus)
    and [“Optionally: Unit Testing Event Handlers in Isolation with a Fake Message
    Bus”](ch09.xhtml#fake_message_bus).'
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 6\. Unit of Work Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we’ll introduce the final piece of the puzzle that ties together
    the Repository and Service Layer patterns: the *Unit of Work* pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: If the Repository pattern is our abstraction over the idea of persistent storage,
    the Unit of Work (UoW) pattern is our abstraction over the idea of *atomic operations*.
    It will allow us to finally and fully decouple our service layer from the data
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-1](#before_uow_diagram) shows that, currently, a lot of communication
    occurs across the layers of our infrastructure: the API talks directly to the
    database layer to start a session, it talks to the repository layer to initialize
    `SQLAlchemyRepository`, and it talks to the service layer to ask it to allocate.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The code for this chapter is in the chapter_06_uow branch [on GitHub](https://oreil.ly/MoWdZ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![apwp 0601](Images/apwp_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-1\. Without UoW: API talks directly to three layers'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 6-2](#after_uow_diagram) shows our target state. The Flask API now
    does only two things: it initializes a unit of work, and it invokes a service.
    The service collaborates with the UoW (we like to think of the UoW as being part
    of the service layer), but neither the service function itself nor Flask now needs
    to talk directly to the database.'
  prefs: []
  type: TYPE_NORMAL
- en: And we’ll do it all using a lovely piece of Python syntax, a context manager.
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 0602](Images/apwp_0602.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-2\. With UoW: UoW now manages database state'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Unit of Work Collaborates with the Repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s see the unit of work (or UoW, which we pronounce “you-wow”) in action.
    Here’s how the service layer will look when we’re finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Preview of unit of work in action (src/allocation/service_layer/services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_unit_of_work_pattern_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start a UoW as a context manager.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_unit_of_work_pattern_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`uow.batches` is the batches repo, so the UoW provides us access to our permanent
    storage.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_unit_of_work_pattern_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: When we’re done, we commit or roll back our work, using the UoW.
  prefs: []
  type: TYPE_NORMAL
- en: The UoW acts as a single entrypoint to our persistent storage, and it keeps
    track of what objects were loaded and of the latest state.^([1](ch06.xhtml#idm45714894656504))
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us three useful things:'
  prefs: []
  type: TYPE_NORMAL
- en: A stable snapshot of the database to work with, so the objects we use aren’t
    changing halfway through an operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way to persist all of our changes at once, so if something goes wrong, we
    don’t end up in an inconsistent state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple API to our persistence concerns and a handy place to get a repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-Driving a UoW with Integration Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are our integration tests for the UOW:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A basic “round-trip” test for a UoW (tests/integration/test_uow.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_unit_of_work_pattern_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We initialize the UoW by using our custom session factory and get back a `uow`
    object to use in our `with` block.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_unit_of_work_pattern_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The UoW gives us access to the batches repository via `uow.batches`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_unit_of_work_pattern_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We call `commit()` on it when we’re done.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the curious, the `insert_batch` and `get_allocated_batch_ref` helpers look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Helpers for doing SQL stuff (tests/integration/test_uow.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Unit of Work and Its Context Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our tests we’ve implicitly defined an interface for what a UoW needs to
    do. Let’s make that explicit by using an abstract base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Abstract UoW context manager (src/allocation/service_layer/unit_of_work.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_unit_of_work_pattern_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The UoW provides an attribute called `.batches`, which will give us access to
    the batches repository.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_unit_of_work_pattern_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve never seen a context manager, `__enter__` and `__exit__` are the two
    magic methods that execute when we enter the `with` block and when we exit it,
    respectively. They’re our setup and teardown phases.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_unit_of_work_pattern_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll call this method to explicitly commit our work when we’re ready.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_unit_of_work_pattern_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: If we don’t commit, or if we exit the context manager by raising an error, we
    do a `rollback`. (The rollback has no effect if `commit()` has been called. Read
    on for more discussion of this.)
  prefs: []
  type: TYPE_NORMAL
- en: The Real Unit of Work Uses SQLAlchemy Sessions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main thing that our concrete implementation adds is the database session:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The real SQLAlchemy UoW (src/allocation/service_layer/unit_of_work.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_unit_of_work_pattern_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The module defines a default session factory that will connect to Postgres,
    but we allow that to be overridden in our integration tests so that we can use
    SQLite instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_unit_of_work_pattern_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `__enter__` method is responsible for starting a database session and instantiating
    a real repository that can use that session.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_unit_of_work_pattern_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: We close the session on exit.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_unit_of_work_pattern_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we provide concrete `commit()` and `rollback()` methods that use our
    database session.
  prefs: []
  type: TYPE_NORMAL
- en: Fake Unit of Work for Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s how we use a fake UoW in our service-layer tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Fake UoW (tests/unit/test_services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_unit_of_work_pattern_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`FakeUnitOfWork` and `FakeRepository` are tightly coupled, just like the real
    `UnitofWork` and `Repository` classes. That’s fine because we recognize that the
    objects are collaborators.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_unit_of_work_pattern_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the similarity with the fake `commit()` function from `FakeSession` (which
    we can now get rid of). But it’s a substantial improvement because we’re now faking
    out code that we wrote rather than third-party code. Some people say, [“Don’t
    mock what you don’t own”](https://oreil.ly/0LVj3).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_unit_of_work_pattern_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: In our tests, we can instantiate a UoW and pass it to our service layer, rather
    than passing a repository and a session. This is considerably less cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: Using the UoW in the Service Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s what our new service layer looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Service layer using UoW (src/allocation/service_layer/services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_unit_of_work_pattern_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Our service layer now has only the one dependency, once again on an *abstract*
    UoW.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit Tests for Commit/Rollback Behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To convince ourselves that the commit/rollback behavior works, we wrote a couple
    of tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Integration tests for rollback behavior (tests/integration/test_uow.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We haven’t shown it here, but it can be worth testing some of the more “obscure”
    database behavior, like transactions, against the “real” database—that is, the
    same engine. For now, we’re getting away with using SQLite instead of Postgres,
    but in [Chapter 7](ch07.xhtml#chapter_07_aggregate), we’ll switch some of the
    tests to using the real database. It’s convenient that our UoW class makes that
    easy!
  prefs: []
  type: TYPE_NORMAL
- en: Explicit Versus Implicit Commits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we briefly digress on different ways of implementing the UoW pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could imagine a slightly different version of the UoW that commits by default
    and rolls back only if it spots an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A UoW with implicit commit… (src/allocation/unit_of_work.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_unit_of_work_pattern_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Should we have an implicit commit in the happy path?
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_unit_of_work_pattern_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: And roll back only on exception?
  prefs: []
  type: TYPE_NORMAL
- en: 'It would allow us to save a line of code and to remove the explicit commit
    from our client code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*...would save us a line of code (src/allocation/service_layer/services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is a judgment call, but we tend to prefer requiring the explicit commit
    so that we have to choose when to flush state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we use an extra line of code, this makes the software safe by default.
    The default behavior is to *not change anything*. In turn, that makes our code
    easier to reason about because there’s only one code path that leads to changes
    in the system: total success and an explicit commit. Any other code path, any
    exception, any early exit from the UoW’s scope leads to a safe state.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we prefer to roll back by default because it’s easier to understand;
    this rolls back to the last commit, so either the user did one, or we blow their
    changes away. Harsh but simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples: Using UoW to Group Multiple Operations into an Atomic Unit'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are a few examples showing the Unit of Work pattern in use. You can see
    how it leads to simple reasoning about what blocks of code happen together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: Reallocate'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose we want to be able to deallocate and then reallocate orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Reallocate service function*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_unit_of_work_pattern_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: If `deallocate()` fails, we don’t want to call `allocate()`, obviously.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_unit_of_work_pattern_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: If `allocate()` fails, we probably don’t want to actually commit the `deallocate()`
    either.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2: Change Batch Quantity'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our shipping company gives us a call to say that one of the container doors
    opened, and half our sofas have fallen into the Indian Ocean. Oops!
  prefs: []
  type: TYPE_NORMAL
- en: '*Change quantity*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_unit_of_work_pattern_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Here we may need to deallocate any number of lines. If we get a failure at any
    stage, we probably want to commit none of the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Tidying Up the Integration Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have three sets of tests, all essentially pointing at the database:
    *test_orm.py*, *test_repository.py*, and *test_uow.py*. Should we throw any away?'
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE13]*  *You should always feel free to throw away tests if you think they’re
    not going to add value longer term. We’d say that *test_orm.py* was primarily
    a tool to help us learn SQLAlchemy, so we won’t need that long term, especially
    if the main things it’s doing are covered in *test_repository.py*. That last test,
    you might keep around, but we could certainly see an argument for just keeping
    everything at the highest possible level of abstraction (just as we did for the
    unit tests).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This is another example of the lesson from [Chapter 5](ch05.xhtml#chapter_05_high_gear_low_gear):
    as we build better abstractions, we can move our tests to run against them, which
    leaves us free to change the underlying details.*  *# Wrap-Up'
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully we’ve convinced you that the Unit of Work pattern is useful, and that
    the context manager is a really nice Pythonic way of visually grouping code into
    blocks that we want to happen atomically.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is so useful, in fact, that SQLAlchemy already uses a UoW in the
    shape of the `Session` object. The `Session` object in SQLAlchemy is the way that
    your application loads data from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Every time you load a new entity from the database, the session begins to *track*
    changes to the entity, and when the session is *flushed*, all your changes are
    persisted together. Why do we go to the effort of abstracting away the SQLAlchemy
    session if it already implements the pattern we want?
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-1](#chapter_06_uow_tradeoffs) discusses some of the trade-offs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-1\. Unit of Work pattern: the trade-offs'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pros | Cons |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: We have a nice abstraction over the concept of atomic operations, and the context
    manager makes it easy to see, visually, what blocks of code are grouped together
    atomically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have explicit control over when a transaction starts and finishes, and our
    application fails in a way that is safe by default. We never have to worry that
    an operation is partially committed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s a nice place to put all your repositories so client code can access them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you’ll see in later chapters, atomicity isn’t only about transactions; it
    can help us work with events and the message bus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Your ORM probably already has some perfectly good abstractions around atomicity.
    SQLAlchemy even has context managers. You can go a long way just passing a session
    around.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve made it look easy, but you have to think quite carefully about things
    like rollbacks, multithreading, and nested transactions. Perhaps just sticking
    to what Django or Flask-SQLAlchemy gives you will keep your life simpler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'For one thing, the Session API is rich and supports operations that we don’t
    want or need in our domain. Our `UnitOfWork` simplifies the session to its essential
    core: it can be started, committed, or thrown away.'
  prefs: []
  type: TYPE_NORMAL
- en: For another, we’re using the `UnitOfWork` to access our `Repository` objects.
    This is a neat bit of developer usability that we couldn’t do with a plain SQLAlchemy
    `Session`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we’re motivated again by the dependency inversion principle: our service
    layer depends on a thin abstraction, and we attach a concrete implementation at
    the outside edge of the system. This lines up nicely with SQLAlchemy’s own [recommendations](https://oreil.ly/tS0E0):'
  prefs: []
  type: TYPE_NORMAL
- en: Keep the life cycle of the session (and usually the transaction) separate and
    external. The most comprehensive approach, recommended for more substantial applications,
    will try to keep the details of session, transaction, and exception management
    as far as possible from the details of the program doing its work.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: SQLALchemy “Session Basics” Documentation
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ^([1](ch06.xhtml#idm45714894656504-marker)) You may have come across the use
    of the word *collaborators* to describe objects that work together to achieve
    a goal. The unit of work and the repository are a great example of collaborators
    in the object-modeling sense. In responsibility-driven design, clusters of objects
    that collaborate in their roles are called *object neighborhoods*, which is, in
    our professional opinion, totally adorable.*
  prefs: []
  type: TYPE_NORMAL

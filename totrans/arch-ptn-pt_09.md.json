["```py\ngit clone https://github.com/cosmicpython/code.git\ncd code\ngit checkout appendix_csvs\n# or to code along, checkout the previous chapter:\ngit checkout chapter_06_uow\n```", "```py\n[plantuml, apwp_0702, config=plantuml.cfg]\n@startuml\n\nhide empty members\n\npackage \"Service Layer\" as services {\n    class \"allocate()\" as allocate {\n    }\n    hide allocate circle\n    hide allocate members\n}\n\npackage \"Domain Model\" as domain_model {\n\n  class Batch {\n  }\n\n  class \"allocate()\" as allocate_domain_service {\n  }\n    hide allocate_domain_service circle\n    hide allocate_domain_service members\n}\n\npackage repositories {\n\n  class BatchRepository {\n    list()\n  }\n\n}\n\nallocate -> BatchRepository: list all batches\nallocate --> allocate_domain_service: allocate(orderline, batches)\n\n@enduml\n```", "```py\n[plantuml, apwp_0703, config=plantuml.cfg]\n@startuml\n\nhide empty members\n\npackage \"Service Layer\" as services {\n    class \"allocate()\" as allocate {\n    }\n}\n\nhide allocate circle\nhide allocate members\n\npackage \"Domain Model\" as domain_model {\n\n  class Product {\n    allocate()\n  }\n\n  class Batch {\n  }\n}\n\npackage repositories {\n\n  class ProductRepository {\n    get()\n  }\n\n}\n\nallocate -> ProductRepository: get me the product for this sku\nallocate --> Product: product.allocate(orderline)\nProduct o- Batch: has\n\n@enduml\n```", "```py\nclassProduct:def__init__(self,sku:str,batches:List[Batch]):self.sku=sku![1](Images/1.png)self.batches=batches![2](Images/2.png)defallocate(self,line:OrderLine)->str:![3](Images/3.png)try:batch=next(bforbinsorted(self.batches)ifb.can_allocate(line))batch.allocate(line)returnbatch.referenceexceptStopIteration:raiseOutOfStock(f'Out of stock for sku {line.sku}')\n```", "```py\nclass AbstractUnitOfWork(abc.ABC):\n    products: repository.AbstractProductRepository\n\n...\n\nclass AbstractProductRepository(abc.ABC):\n\n    @abc.abstractmethod\n    def add(self, product):\n        ...\n\n    @abc.abstractmethod\n    def get(self, sku) -> model.Product:\n        ...\n```", "```py\ndef add_batch(\n        ref: str, sku: str, qty: int, eta: Optional[date],\n        uow: unit_of_work.AbstractUnitOfWork\n):\n    with uow:\n        product = uow.products.get(sku=sku)\n        if product is None:\n            product = model.Product(sku, batches=[])\n            uow.products.add(product)\n        product.batches.append(model.Batch(ref, sku, qty, eta))\n        uow.commit()\n\ndef allocate(\n        orderid: str, sku: str, qty: int,\n        uow: unit_of_work.AbstractUnitOfWork\n) -> str:\n    line = OrderLine(orderid, sku, qty)\n    with uow:\n        product = uow.products.get(sku=line.sku)\n        if product is None:\n            raise InvalidSku(f'Invalid sku {line.sku}')\n        batchref = product.allocate(line)\n        uow.commit()\n    return batchref\n```", "```py\n[plantuml, apwp_0704, config=plantuml.cfg]\n@startuml\n\nentity Model\ncollections Transaction1\ncollections Transaction2\ndatabase Database\n\nTransaction1 -> Database: get product\nDatabase -> Transaction1: Product(version=3)\nTransaction2 -> Database: get product\nDatabase -> Transaction2: Product(version=3)\nTransaction1 -> Model: Product.allocate()\nModel -> Transaction1: Product(version=4)\nTransaction2 -> Model: Product.allocate()\nModel -> Transaction2: Product(version=4)\nTransaction1 -> Database: commit Product(version=4)\nDatabase -[#green]> Transaction1: OK\nTransaction2 -> Database: commit Product(version=4)\nDatabase -[#red]>x Transaction2: Error! version is already 4\n\n@enduml\n```", "```py\nclassProduct:def__init__(self,sku:str,batches:List[Batch],version_number:int=0):![1](Images/1.png)self.sku=skuself.batches=batchesself.version_number=version_number![1](Images/1.png)defallocate(self,line:OrderLine)->str:try:batch=next(bforbinsorted(self.batches)ifb.can_allocate(line))batch.allocate(line)self.version_number+=1![1](Images/1.png)returnbatch.referenceexceptStopIteration:raiseOutOfStock(f'Out of stock for sku {line.sku}')\n```", "```py\ndef try_to_allocate(orderid, sku, exceptions):\n    line = model.OrderLine(orderid, sku, 10)\n    try:\n        with unit_of_work.SqlAlchemyUnitOfWork() as uow:\n            product = uow.products.get(sku=sku)\n            product.allocate(line)\n            time.sleep(0.2)\n            uow.commit()\n    except Exception as e:\n        print(traceback.format_exc())\n        exceptions.append(e)\n```", "```py\ndeftest_concurrent_updates_to_version_are_not_allowed(postgres_session_factory):sku,batch=random_sku(),random_batchref()session=postgres_session_factory()insert_batch(session,batch,sku,100,eta=None,product_version=1)session.commit()order1,order2=random_orderid(1),random_orderid(2)exceptions=[]# type: List[Exception]try_to_allocate_order1=lambda:try_to_allocate(order1,sku,exceptions)try_to_allocate_order2=lambda:try_to_allocate(order2,sku,exceptions)thread1=threading.Thread(target=try_to_allocate_order1)![1](Images/1.png)thread2=threading.Thread(target=try_to_allocate_order2)![1](Images/1.png)thread1.start()thread2.start()thread1.join()thread2.join()[[version]]=session.execute(\"SELECT version_number FROM products WHERE sku=:sku\",dict(sku=sku),)assertversion==2![2](Images/2.png)[exception]=exceptionsassert'could not serialize access due to concurrent update'instr(exception)![3](Images/3.png)orders=list(session.execute(\"SELECT orderid FROM allocations\"\" JOIN batches ON allocations.batch_id = batches.id\"\" JOIN order_lines ON allocations.orderline_id = order_lines.id\"\" WHERE order_lines.sku=:sku\",dict(sku=sku),))assertlen(orders)==1![4](Images/4.png)withunit_of_work.SqlAlchemyUnitOfWork()asuow:uow.session.execute('select 1')\n```", "```py\nDEFAULT_SESSION_FACTORY = sessionmaker(bind=create_engine(\n    config.get_postgres_uri(),\n    isolation_level=\"REPEATABLE READ\",\n))\n```", "```py\n    def get(self, sku):\n        return self.session.query(model.Product) \\\n                           .filter_by(sku=sku) \\\n                           .with_for_update() \\\n                           .first()\n```", "```py\nread1, read2, write1, write2(fail)\n```", "```py\nread1, write1, read2, write2(succeed)\n```"]
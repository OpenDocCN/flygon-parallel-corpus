- en: Chapter 7\. Aggregates and Consistency Boundaries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。聚合和一致性边界
- en: In this chapter, we’d like to revisit our domain model to talk about invariants
    and constraints, and see how our domain objects can maintain their own internal
    consistency, both conceptually and in persistent storage. We’ll discuss the concept
    of a *consistency boundary* and show how making it explicit can help us to build
    high-performance software without compromising maintainability.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们想重新审视我们的领域模型，讨论不变量和约束，并看看我们的领域对象如何在概念上和持久存储中保持自己的内部一致性。我们将讨论*一致性边界*的概念，并展示如何明确地做出这一点可以帮助我们构建高性能软件，而不会影响可维护性。
- en: '[Figure 7-1](#maps_chapter_06) shows a preview of where we’re headed: we’ll
    introduce a new model object called `Product` to wrap multiple batches, and we’ll
    make the old `allocate()` domain service available as a method on `Product` instead.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-1](#maps_chapter_06)显示了我们的目标：我们将引入一个名为`Product`的新模型对象来包装多个批次，并且我们将使旧的`allocate()`领域服务作为`Product`的方法可用。'
- en: '![apwp 0701](Images/apwp_0701.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![apwp 0701](Images/apwp_0701.png)'
- en: Figure 7-1\. Adding the Product aggregate
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-1\. 添加产品聚合
- en: Why? Let’s find out.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？让我们找出原因。
- en: Tip
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'The code for this chapter is in the appendix_csvs branch [on GitHub](https://oreil.ly/vlnGg):'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码在[GitHub](https://oreil.ly/vlnGg)的appendix_csvs分支中：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Why Not Just Run Everything in a Spreadsheet?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么不只在电子表格中运行所有东西？
- en: What’s the point of a domain model, anyway? What’s the fundamental problem we’re
    trying to address?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型的意义是什么？我们试图解决的根本问题是什么？
- en: Couldn’t we just run everything in a spreadsheet? Many of our users would be
    delighted by that. Business users *like* spreadsheets because they’re simple,
    familiar, and yet enormously powerful.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们难道不能只在电子表格中运行所有东西吗？我们的许多用户会对此感到高兴。业务用户*喜欢*电子表格，因为它们简单、熟悉，但又非常强大。
- en: In fact, an enormous number of business processes do operate by manually sending
    spreadsheets back and forth over email. This “CSV over SMTP” architecture has
    low initial complexity but tends not to scale very well because it’s difficult
    to apply logic and maintain consistency.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，大量的业务流程确实是通过手动在电子邮件中来回发送电子表格来操作的。这种“CSV通过SMTP”架构具有较低的初始复杂性，但往往不容易扩展，因为很难应用逻辑和保持一致性。
- en: Who is allowed to view this particular field? Who’s allowed to update it? What
    happens when we try to order –350 chairs, or 10,000,000 tables? Can an employee
    have a negative salary?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 谁有权查看特定字段？谁有权更新它？当我们尝试订购-350把椅子或者1000万张桌子时会发生什么？员工可以有负薪水吗？
- en: These are the constraints of a system. Much of the domain logic we write exists
    to enforce these constraints in order to maintain the invariants of the system.
    The *invariants* are the things that have to be true whenever we finish an operation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是系统的约束条件。我们编写的许多领域逻辑存在的目的是为了强制执行这些约束条件，以维护系统的不变量。*不变量*是每当我们完成一个操作时必须为真的事物。
- en: Invariants, Constraints, and Consistency
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不变量、约束和一致性
- en: The two words are somewhat interchangeable, but a *constraint* is a rule that
    restricts the possible states our model can get into, while an *invariant* is
    defined a little more precisely as a condition that is always true.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个词在某种程度上是可以互换的，但*约束*是限制我们的模型可能进入的可能状态的规则，而*不变量*更精确地定义为始终为真的条件。
- en: If we were writing a hotel-booking system, we might have the constraint that
    double bookings are not allowed. This supports the invariant that a room cannot
    have more than one booking for the same night.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在编写酒店预订系统，我们可能会有一个约束，即不允许双重预订。这支持了一个不变量，即一个房间在同一天晚上不能有多个预订。
- en: Of course, sometimes we might need to temporarily *bend* the rules. Perhaps
    we need to shuffle the rooms around because of a VIP booking. While we’re moving
    bookings around in memory, we might be double booked, but our domain model should
    ensure that, when we’re finished, we end up in a final consistent state, where
    the invariants are met. If we can’t find a way to accommodate all our guests,
    we should raise an error and refuse to complete the operation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有时我们可能需要暂时*违反*规则。也许我们需要因为贵宾预订而重新安排房间。当我们在内存中移动预订时，我们可能会被双重预订，但我们的领域模型应该确保，当我们完成时，我们最终处于一个一致的状态，其中不变量得到满足。如果我们找不到一种方法来容纳所有客人，我们应该引发错误并拒绝完成操作。
- en: 'Let’s look at a couple of concrete examples from our business requirements;
    we’ll start with this one:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的业务需求中看一些具体的例子；我们将从这个开始：
- en: An order line can be allocated to only one batch at a time.
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 订单行一次只能分配给一个批次。
- en: '>'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: The business
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 商业
- en: This is a business rule that imposes an invariant. The invariant is that an
    order line is allocated to either zero or one batch, but never more than one.
    We need to make sure that our code never accidentally calls `Batch.allocate()`
    on two different batches for the same line, and currently, there’s nothing there
    to explicitly stop us from doing that.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个强加不变量的业务规则。不变量是订单行必须分配给零个或一个批次，但绝不能超过一个。我们需要确保我们的代码永远不会意外地对同一行调用`Batch.allocate()`两个不同的批次，并且目前没有任何东西明确阻止我们这样做。
- en: Invariants, Concurrency, and Locks
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不变量、并发和锁
- en: 'Let’s look at another one of our business rules:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看我们的另一个业务规则：
- en: We can’t allocate to a batch if the available quantity is less than the quantity
    of the order line.
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果可用数量小于订单行的数量，我们就不能分配给批次。
- en: '>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: The business
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 商业
- en: Here the constraint is that we can’t allocate more stock than is available to
    a batch, so we never oversell stock by allocating two customers to the same physical
    cushion, for example. Every time we update the state of the system, our code needs
    to ensure that we don’t break the invariant, which is that the available quantity
    must be greater than or equal to zero.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的约束是我们不能分配超过批次可用数量的库存，因此我们永远不会通过将两个客户分配给同一个实际垫子而超卖库存。每当我们更新系统的状态时，我们的代码需要确保我们不会破坏不变量，即可用数量必须大于或等于零。
- en: In a single-threaded, single-user application, it’s relatively easy for us to
    maintain this invariant. We can just allocate stock one line at a time, and raise
    an error if there’s no stock available.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: This gets much harder when we introduce the idea of *concurrency*. Suddenly
    we might be allocating stock for multiple order lines simultaneously. We might
    even be allocating order lines at the same time as processing changes to the batches
    themselves.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: We usually solve this problem by applying *locks* to our database tables. This
    prevents two operations from happening simultaneously on the same row or same
    table.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: As we start to think about scaling up our app, we realize that our model of
    allocating lines against all available batches may not scale. If we process tens
    of thousands of orders per hour, and hundreds of thousands of order lines, we
    can’t hold a lock over the whole `batches` table for every single one—we’ll get
    deadlocks or performance problems at the very least.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: What Is an Aggregate?
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OK, so if we can’t lock the whole database every time we want to allocate an
    order line, what should we do instead? We want to protect the invariants of our
    system but allow for the greatest degree of concurrency. Maintaining our invariants
    inevitably means preventing concurrent writes; if multiple users can allocate
    `DEADLY-SPOON` at the same time, we run the risk of overallocating.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, there’s no reason we can’t allocate `DEADLY-SPOON` at the
    same time as `FLIMSY-DESK`. It’s safe to allocate two products at the same time
    because there’s no invariant that covers them both. We don’t need them to be consistent
    with each other.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The *Aggregate* pattern is a design pattern from the DDD community that helps
    us to resolve this tension. An *aggregate* is just a domain object that contains
    other domain objects and lets us treat the whole collection as a single unit.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: The only way to modify the objects inside the aggregate is to load the whole
    thing, and to call methods on the aggregate itself.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: As a model gets more complex and grows more entity and value objects, referencing
    each other in a tangled graph, it can be hard to keep track of who can modify
    what. Especially when we have *collections* in the model as we do (our batches
    are a collection), it’s a good idea to nominate some entities to be the single
    entrypoint for modifying their related objects. It makes the system conceptually
    simpler and easy to reason about if you nominate some objects to be in charge
    of consistency for the others.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we’re building a shopping site, the Cart might make a good
    aggregate: it’s a collection of items that we can treat as a single unit. Importantly,
    we want to load the entire basket as a single blob from our data store. We don’t
    want two requests to modify the basket at the same time, or we run the risk of
    weird concurrency errors. Instead, we want each change to the basket to run in
    a single database transaction.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: We don’t want to modify multiple baskets in a transaction, because there’s no
    use case for changing the baskets of several customers at the same time. Each
    basket is a single *consistency boundary* responsible for maintaining its own
    invariants.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: An AGGREGATE is a cluster of associated objects that we treat as a unit for
    the purpose of data changes.
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Eric Evans, Domain-Driven Design blue book
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Per Evans, our aggregate has a root entity (the Cart) that encapsulates access
    to items. Each item has its own identity, but other parts of the system will always
    refer to the Cart only as an indivisible whole.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Just as we sometimes use `*_leading_underscores*` to mark methods or functions
    as “private,” you can think of aggregates as being the “public” classes of our
    model, and the rest of the entities and value objects as “private.”
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an Aggregate
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What aggregate should we use for our system? The choice is somewhat arbitrary,
    but it’s important. The aggregate will be the boundary where we make sure every
    operation ends in a consistent state. This helps us to reason about our software
    and prevent weird race issues. We want to draw a boundary around a small number
    of objects—the smaller, the better, for performance—that have to be consistent
    with one another, and we need to give this boundary a good name.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The object we’re manipulating under the covers is `Batch`. What do we call a
    collection of batches? How should we divide all the batches in the system into
    discrete islands of consistency?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'We *could* use `Shipment` as our boundary. Each shipment contains several batches,
    and they all travel to our warehouse at the same time. Or perhaps we could use
    `Warehouse` as our boundary: each warehouse contains many batches, and counting
    all the stock at the same time could make sense.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Neither of these concepts really satisfies us, though. We should be able to
    allocate `DEADLY-SPOONs` and `FLIMSY-DESKs` at the same time, even if they’re
    in the same warehouse or the same shipment. These concepts have the wrong granularity.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'When we allocate an order line, we’re interested only in batches that have
    the same SKU as the order line. Some sort of concept like `GlobalSkuStock` could
    work: a collection of all the batches for a given SKU.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: It’s an unwieldy name, though, so after some bikeshedding via `SkuStock`, `Stock`,
    `ProductStock`, and so on, we decided to simply call it `Product`—after all, that
    was the first concept we came across in our exploration of the domain language
    back in [Chapter 1](ch01.xhtml#chapter_01_domain_model).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'So the plan is this: when we want to allocate an order line, instead of [Figure 7-2](#before_aggregates_diagram),
    where we look up all the `Batch` objects in the world and pass them to the `allocate()`
    domain service…'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 0702](Images/apwp_0702.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-2\. Before: allocate against all batches using the domain service'
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: …we’ll move to the world of [Figure 7-3](#after_aggregates_diagram), in which
    there is a new `Product` object for the particular SKU of our order line, and
    it will be in charge of all the batches *for that SKU*, and we can call a `.allocate()`
    method on that instead.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 0703](Images/apwp_0703.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-3\. After: ask Product to allocate against its batches'
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s see how that looks in code form:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '*Our chosen aggregate, Product (src/allocation/domain/model.py)*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](Images/1.png)](#co_aggregates_and_consistency_boundaries_CO1-1)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '`Product`’s main identifier is the `sku`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_aggregates_and_consistency_boundaries_CO1-2)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Our `Product` class holds a reference to a collection of `batches` for that
    SKU.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_aggregates_and_consistency_boundaries_CO1-3)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can move the `allocate()` domain service to be a method on the `Product`
    aggregate.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This `Product` might not look like what you’d expect a `Product` model to look
    like. No price, no description, no dimensions. Our allocation service doesn’t
    care about any of those things. This is the power of bounded contexts; the concept
    of a product in one app can be very different from another. See the following
    sidebar for more discussion.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: One Aggregate = One Repository
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you define certain entities to be aggregates, we need to apply the rule
    that they are the only entities that are publicly accessible to the outside world.
    In other words, the only repositories we are allowed should be repositories that
    return aggregates.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The rule that repositories should only return aggregates is the main place where
    we enforce the convention that aggregates are the only way into our domain model.
    Be wary of breaking it!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we’ll switch from `BatchRepository` to `ProductRepository`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '*Our new UoW and repository (unit_of_work.py and repository.py)*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The ORM layer will need some tweaks so that the right batches automatically
    get loaded and associated with `Product` objects. The nice thing is, the Repository
    pattern means we don’t have to worry about that yet. We can just use our `FakeRepository`
    and then feed through the new model into our service layer to see how it looks
    with `Product` as its main entrypoint:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ORM层将需要一些调整，以便正确的批次自动加载并与“Product”对象关联。好处是，存储库模式意味着我们不必担心这个问题。我们可以只使用我们的“FakeRepository”，然后将新模型传递到我们的服务层，看看它作为其主要入口点的“Product”是什么样子：
- en: '*Service layer (src/allocation/service_layer/services.py)*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务层（src/allocation/service_layer/services.py）*'
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What About Performance?
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能如何？
- en: We’ve mentioned a few times that we’re modeling with aggregates because we want
    to have high-performance software, but here we are loading *all* the batches when
    we only need one. You might expect that to be inefficient, but there are a few
    reasons why we’re comfortable here.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次提到，我们正在使用聚合进行建模，因为我们希望拥有高性能的软件，但是在这里，我们加载了*所有*批次，而我们只需要一个。你可能会认为这是低效的，但我们在这里感到舒适的原因有几个。
- en: First, we’re purposefully modeling our data so that we can make a single query
    to the database to read, and a single update to persist our changes. This tends
    to perform much better than systems that issue lots of ad hoc queries. In systems
    that don’t model this way, we often find that transactions slowly get longer and
    more complex as the software evolves.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有意地对我们的数据进行建模，以便我们可以对数据库进行单个查询来读取，并进行单个更新以保存我们的更改。这往往比发出许多临时查询的系统性能要好得多。在不以这种方式建模的系统中，我们经常发现随着软件的发展，事务变得越来越长，越来越复杂。
- en: Second, our data structures are minimal and comprise a few strings and integers
    per row. We can easily load tens or even hundreds of batches in a few milliseconds.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们的数据结构是最小的，每行包括一些字符串和整数。我们可以在几毫秒内轻松加载数十甚至数百个批次。
- en: Third, we expect to have only 20 or so batches of each product at a time. Once
    a batch is used up, we can discount it from our calculations. This means that
    the amount of data we’re fetching shouldn’t get out of control over time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们预计每种产品一次只有大约20个批次左右。一旦批次用完，我们可以从我们的计算中剔除它。这意味着我们获取的数据量不应该随着时间的推移而失控。
- en: If we *did* expect to have thousands of active batches for a product, we’d have
    a couple of options. For one, we could use lazy-loading for the batches in a product.
    From the perspective of our code, nothing would change, but in the background,
    SQLAlchemy would page through data for us. This would lead to more requests, each
    fetching a smaller number of rows. Because we need to find only a single batch
    with enough capacity for our order, this might work pretty well.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们*确实*预计某种产品会有成千上万个活跃的批次，我们将有几个选择。首先，我们可以对产品中的批次使用延迟加载。从我们代码的角度来看，没有任何变化，但在后台，SQLAlchemy会为我们分页数据。这将导致更多的请求，每个请求获取更少的行。因为我们只需要找到一个足够容量的批次来满足我们的订单，这可能效果很好。
- en: If all else failed, we’d just look for a different aggregate. Maybe we could
    split up batches by region or by warehouse. Maybe we could redesign our data access
    strategy around the shipment concept. The Aggregate pattern is designed to help
    manage some technical constraints around consistency and performance. There isn’t
    *one* correct aggregate, and we should feel comfortable changing our minds if
    we find our boundaries are causing performance woes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切都失败了，我们只需寻找一个不同的聚合。也许我们可以按地区或仓库拆分批次。也许我们可以围绕装运概念重新设计我们的数据访问策略。聚合模式旨在帮助管理一些围绕一致性和性能的技术约束。并没有*一个*正确的聚合，如果发现我们的边界导致性能问题，我们应该放心改变我们的想法。
- en: Optimistic Concurrency with Version Numbers
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用版本号进行乐观并发
- en: We have our new aggregate, so we’ve solved the conceptual problem of choosing
    an object to be in charge of consistency boundaries. Let’s now spend a little
    time talking about how to enforce data integrity at the database level.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了我们的新聚合，所以我们解决了选择一个对象负责一致性边界的概念问题。现在让我们花点时间谈谈如何在数据库级别强制执行数据完整性。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This section has a lot of implementation details; for example, some of it is
    Postgres-specific. But more generally, we’re showing one way of managing concurrency
    issues, but it is just one approach. Real requirements in this area vary a lot
    from project to project. You shouldn’t expect to be able to copy and paste code
    from here into production.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分包含了许多实现细节；例如，其中一些是特定于Postgres的。但更一般地，我们展示了一种管理并发问题的方法，但这只是一种方法。这一领域的实际要求在项目之间变化很大。你不应该期望能够将代码从这里复制粘贴到生产环境中。
- en: We don’t want to hold a lock over the entire `batches` table, but how will we
    implement holding a lock over just the rows for a particular SKU?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想在整个“batches”表上持有锁，但是我们如何实现仅在特定SKU的行上持有锁？
- en: One answer is to have a single attribute on the `Product` model that acts as
    a marker for the whole state change being complete and to use it as the single
    resource that concurrent workers can fight over. If two transactions read the
    state of the world for `batches` at the same time, and both want to update the
    `allocations` tables, we force both to also try to update the `version_number`
    in the `products` table, in such a way that only one of them can win and the world
    stays consistent.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案是在“Product”模型上有一个单一属性，作为整个状态变化完成的标记，并将其用作并发工作者可以争夺的单一资源。如果两个事务同时读取“batches”的世界状态，并且都想要更新“allocations”表，我们强制两者也尝试更新“products”表中的“version_number”，以便只有一个可以获胜，世界保持一致。
- en: '[Figure 7-4](#version_numbers_sequence_diagram) illustrates two concurrent
    transactions doing their read operations at the same time, so they see a `Product`
    with, for example, `version=3`. They both call `Product.allocate()` in order to
    modify a state. But we set up our database integrity rules such that only one
    of them is allowed to `commit` the new `Product` with `version=4`, and the other
    update is rejected.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-4](#version_numbers_sequence_diagram)说明了两个并发事务同时进行读取操作，因此它们看到的是一个具有，例如，`version=3`的`Product`。它们都调用`Product.allocate()`来修改状态。但我们设置了数据库完整性规则，只允许其中一个使用`commit`提交带有`version=4`的新`Product`，而另一个更新将被拒绝。'
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Version numbers are just one way to implement optimistic locking. You could
    achieve the same thing by setting the Postgres transaction isolation level to
    `SERIALIZABLE`, but that often comes at a severe performance cost. Version numbers
    also make implicit concepts explicit.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 版本号只是实现乐观锁定的一种方式。你可以通过将Postgres事务隔离级别设置为`SERIALIZABLE`来实现相同的效果，但这通常会带来严重的性能成本。版本号还可以使隐含的概念变得明确。
- en: '![apwp 0704](Images/apwp_0704.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![apwp 0704](Images/apwp_0704.png)'
- en: 'Figure 7-4\. Sequence diagram: two transactions attempting a concurrent update
    on `Product`'
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-4。序列图：两个事务尝试并发更新“Product”
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Implementation Options for Version Numbers
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本号的实现选项
- en: 'There are essentially three options for implementing version numbers:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上有三种实现版本号的选项：
- en: '`version_number` lives in the domain; we add it to the `Product` constructor,
    and `Product.allocate()` is responsible for incrementing it.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`version_number`存在于领域中；我们将其添加到`Product`构造函数中，`Product.allocate()`负责递增它。'
- en: The service layer could do it! The version number isn’t *strictly* a domain
    concern, so instead our service layer could assume that the current version number
    is attached to `Product` by the repository, and the service layer will increment
    it before it does the `commit()`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务层可以做到！版本号并不*严格*是一个领域问题，所以我们的服务层可以假设当前版本号是由存储库附加到`Product`上的，并且服务层在执行`commit()`之前会递增它。
- en: Since it’s arguably an infrastructure concern, the UoW and repository could
    do it by magic. The repository has access to version numbers for any products
    it retrieves, and when the UoW does a commit, it can increment the version number
    for any products it knows about, assuming them to have changed.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这可以说是一个基础设施问题，UoW和存储库可以通过魔法来做到这一点。存储库可以访问它检索的任何产品的版本号，当UoW提交时，它可以递增它所知道的任何产品的版本号，假设它们已经更改。
- en: Option 3 isn’t ideal, because there’s no real way of doing it without having
    to assume that *all* products have changed, so we’ll be incrementing version numbers
    when we don’t have to.^([1](ch07.xhtml#idm45714892121352))
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 选项3并不理想，因为没有真正的方法可以做到这一点，而不必假设*所有*产品都已更改，所以我们将在不必要的时候递增版本号。^([1](ch07.xhtml#idm45714892121352))
- en: Option 2 involves mixing the responsibility for mutating state between the service
    layer and the domain layer, so it’s a little messy as well.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 选项2涉及在服务层和领域层之间混合变更状态的责任，因此也有点混乱。
- en: 'So in the end, even though version numbers don’t *have* to be a domain concern,
    you might decide the cleanest trade-off is to put them in the domain:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终，即使版本号不一定是一个领域关注的问题，你可能会决定最干净的权衡是将它们放在领域中：
- en: '*Our chosen aggregate, Product (src/allocation/domain/model.py)*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们选择的聚合，Product（src/allocation/domain/model.py）*'
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](Images/1.png)](#co_aggregates_and_consistency_boundaries_CO2-1)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_aggregates_and_consistency_boundaries_CO2-1)'
- en: There it is!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！
- en: Tip
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you’re scratching your head at this version number business, it might help
    to remember that the *number* isn’t important. What’s important is that the `Product`
    database row is modified whenever we make a change to the `Product` aggregate.
    The version number is a simple, human-comprehensible way to model a thing that
    changes on every write, but it could equally be a random UUID every time.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对版本号这个业务感到困惑，也许记住*号码*并不重要会有所帮助。重要的是，每当我们对“Product”聚合进行更改时，“Product”数据库行都会被修改。版本号是一种简单的、人类可理解的方式来模拟每次写入时都会发生变化的事物，但它也可以是每次都是一个随机UUID。
- en: Testing for Our Data Integrity Rules
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的数据完整性规则
- en: 'Now to make sure we can get the behavior we want: if we have two concurrent
    attempts to do allocation against the same `Product`, one of them should fail,
    because they can’t both update the version number.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要确保我们可以得到我们想要的行为：如果我们有两个并发尝试针对同一个`Product`进行分配，其中一个应该失败，因为它们不能同时更新版本号。
- en: First, let’s simulate a “slow” transaction using a function that does allocation
    and then does an explicit sleep:^([2](ch07.xhtml#idm45714891984264))
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用一个执行分配然后显式休眠的函数来模拟“慢”事务：^([2](ch07.xhtml#idm45714891984264))
- en: '*time.sleep can reproduce concurrency behavior (tests/integration/test_uow.py)*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*time.sleep可以复制并发行为（tests/integration/test_uow.py）*'
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then we have our test invoke this slow allocation twice, concurrently, using
    threads:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的测试使用线程并发两次调用这个慢分配：
- en: '*An integration test for concurrency behavior (tests/integration/test_uow.py)*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*并发行为的集成测试（tests/integration/test_uow.py）*'
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](Images/1.png)](#co_aggregates_and_consistency_boundaries_CO3-1)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_aggregates_and_consistency_boundaries_CO3-1)'
- en: 'We start two threads that will reliably produce the concurrency behavior we
    want: `read1, read2, write1, write2`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动两个线程，它们将可靠地产生我们想要的并发行为：`read1, read2, write1, write2`。
- en: '[![2](Images/2.png)](#co_aggregates_and_consistency_boundaries_CO3-3)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_aggregates_and_consistency_boundaries_CO3-3)'
- en: We assert that the version number has been incremented only once.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们断言版本号只被递增了一次。
- en: '[![3](Images/3.png)](#co_aggregates_and_consistency_boundaries_CO3-4)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_aggregates_and_consistency_boundaries_CO3-4)'
- en: We can also check on the specific exception if we like.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以检查特定的异常，如果我们愿意的话。
- en: '[![4](Images/4.png)](#co_aggregates_and_consistency_boundaries_CO3-5)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_aggregates_and_consistency_boundaries_CO3-5)'
- en: And we double-check that only one allocation has gotten through.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们再次检查，只有一个分配已经完成。
- en: Enforcing Concurrency Rules by Using Database Transaction Isolation Levels
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过使用数据库事务隔离级别来强制执行并发规则
- en: 'To get the test to pass as it is, we can set the transaction isolation level
    on our session:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试通过，我们可以在会话中设置事务隔离级别：
- en: '*Set isolation level for session (src/allocation/service_layer/unit_of_work.py)*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*为会话设置隔离级别 (src/allocation/service_layer/unit_of_work.py)*'
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Transaction isolation levels are tricky stuff, so it’s worth spending time understanding
    [the Postgres documentation](https://oreil.ly/5vxJA).^([3](ch07.xhtml#idm45714891528632))
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 事务隔离级别是棘手的东西，所以值得花时间了解[Postgres文档](https://oreil.ly/5vxJA)。^([3](ch07.xhtml#idm45714891528632))
- en: 'Pessimistic Concurrency Control Example: SELECT FOR UPDATE'
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 悲观并发控制示例：SELECT FOR UPDATE
- en: 'There are multiple ways to approach this, but we’ll show one. [`SELECT FOR
    UPDATE`](https://oreil.ly/i8wKL) produces different behavior; two concurrent transactions
    will not be allowed to do a read on the same rows at the same time:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以解决这个问题，但我们将展示一种方法。[`SELECT FOR UPDATE`](https://oreil.ly/i8wKL)会产生不同的行为；两个并发事务将不被允许同时对相同的行进行读取。
- en: '`SELECT FOR UPDATE` is a way of picking a row or rows to use as a lock (although
    those rows don’t have to be the ones you update). If two transactions both try
    to `SELECT FOR UPDATE` a row at the same time, one will win, and the other will
    wait until the lock is released. So this is an example of pessimistic concurrency
    control.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT FOR UPDATE`是一种选择行作为锁定的方法（尽管这些行不一定是你要更新的行）。如果两个事务同时尝试`SELECT FOR UPDATE`一行，一个会获胜，另一个会等待直到锁定被释放。因此，这是一种悲观并发控制的例子。'
- en: 'Here’s how you can use the SQLAlchemy DSL to specify `FOR UPDATE` at query
    time:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以使用SQLAlchemy DSL在查询时指定`FOR UPDATE`的方法：
- en: '*SQLAlchemy with_for_update (src/allocation/adapters/repository.py)*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*SQLAlchemy with_for_update (src/allocation/adapters/repository.py)*'
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will have the effect of changing the concurrency pattern from
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将改变并发模式
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: to
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Some people refer to this as the “read-modify-write” failure mode. Read [“PostgreSQL
    Anti-Patterns: Read-Modify-Write Cycles”](https://oreil.ly/uXeZI) for a good overview.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人将这称为“读取-修改-写入”故障模式。阅读[“PostgreSQL反模式：读取-修改-写入周期”](https://oreil.ly/uXeZI)以获得一个很好的概述。
- en: We don’t really have time to discuss all the trade-offs between `REPEATABLE
    READ` and `SELECT FOR UPDATE`, or optimistic versus pessimistic locking in general.
    But if you have a test like the one we’ve shown, you can specify the behavior
    you want and see how it changes. You can also use the test as a basis for performing
    some performance experiments.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的没有时间讨论“REPEATABLE READ”和“SELECT FOR UPDATE”之间的所有权衡，或者乐观与悲观锁定。但是，如果你有一个像我们展示的那样的测试，你可以指定你想要的行为并查看它是如何改变的。你也可以使用测试作为执行一些性能实验的基础。
- en: Wrap-Up
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Specific choices around concurrency control vary a lot based on business circumstances
    and storage technology choices, but we’d like to bring this chapter back to the
    conceptual idea of an aggregate: we explicitly model an object as being the main
    entrypoint to some subset of our model, and as being in charge of enforcing the
    invariants and business rules that apply across all of those objects.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕并发控制的具体选择根据业务情况和存储技术选择而有很大的不同，但我们想把这一章重新带回到聚合的概念上：我们明确地将一个对象建模为我们模型的某个子集的主要入口点，并负责强制执行适用于所有这些对象的不变量和业务规则。
- en: Choosing the right aggregate is key, and it’s a decision you may revisit over
    time. You can read more about it in multiple DDD books. We also recommend these
    three online papers on [effective aggregate design](https://dddcommunity.org/library/vernon_2011)
    by Vaughn Vernon (the “red book” author).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的聚合是关键，这是一个你可能随时间重新考虑的决定。你可以在多本DDD书籍中了解更多。我们还推荐Vaughn Vernon（“红皮书”作者）的这三篇关于[有效聚合设计](https://dddcommunity.org/library/vernon_2011)的在线论文。
- en: '[Table 7-1](#chapter_07_aggregate_tradoffs) has some thoughts on the trade-offs
    of implementing the Aggregate pattern.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[表7-1](#chapter_07_aggregate_tradoffs)对实现聚合模式的权衡有一些想法。'
- en: 'Table 7-1\. Aggregates: the trade-offs'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 表7-1. 聚合：权衡
- en: '| Pros | Cons |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 优点 | 缺点 |'
- en: '| --- | --- |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Python might not have “official” public and private methods, but we do have
    the underscores convention, because it’s often useful to try to indicate what’s
    for “internal” use and what’s for “outside code” to use. Choosing aggregates is
    just the next level up: it lets you decide which of your domain model classes
    are the public ones, and which aren’t.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python可能没有“官方”的公共和私有方法，但我们有下划线约定，因为通常有用的是尝试指示什么是“内部”使用和什么是“外部代码”使用。选择聚合只是更高一级的：它让你决定你的领域模型类中哪些是公共的，哪些不是。
- en: Modeling our operations around explicit consistency boundaries helps us avoid
    performance problems with our ORM.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 围绕显式一致性边界建模我们的操作有助于避免ORM的性能问题。
- en: Putting the aggregate in sole charge of state changes to its subsidiary models
    makes the system easier to reason about, and makes it easier to control invariants.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将聚合单独负责对其子模型的状态更改使系统更容易理解，并使其更容易控制不变量。
- en: '|'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Yet another new concept for new developers to take on. Explaining entities versus
    value objects was already a mental load; now there’s a third type of domain model
    object?
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于新开发人员来说，又是一个新概念。解释实体与值对象已经是一种心理负担；现在又出现了第三种领域模型对象？
- en: Sticking rigidly to the rule that we modify only one aggregate at a time is
    a big mental shift.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格遵守我们一次只修改一个聚合的规则是一个很大的心理转变。
- en: Dealing with eventual consistency between aggregates can be complex.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理聚合之间的最终一致性可能会很复杂。
- en: '|'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Part I Recap
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分总结
- en: Do you remember [Figure 7-5](#recap_components_diagram), the diagram we showed
    at the beginning of [Part I](part01.xhtml#part1) to preview where we were heading?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得[图7-5](#recap_components_diagram)吗？这是我们在[第一部分](part01.xhtml#part1)开始时展示的图表，预览我们的方向的。
- en: '![apwp 0705](Images/apwp_0705.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![apwp 0705](Images/apwp_0705.png)'
- en: Figure 7-5\. A component diagram for our app at the end of Part I
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-5. 第一部分结束时我们应用的组件图
- en: 'So that’s where we are at the end of Part I. What have we achieved? We’ve seen
    how to build a domain model that’s exercised by a set of high-level unit tests.
    Our tests are living documentation: they describe the behavior of our system—the
    rules upon which we agreed with our business stakeholders—in nice readable code.
    When our business requirements change, we have confidence that our tests will
    help us to prove the new functionality, and when new developers join the project,
    they can read our tests to understand how things work.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在第一部分结束时所处的位置。我们取得了什么成就？我们看到了如何构建一个领域模型，通过一组高级单元测试来验证。我们的测试是活的文档：它们描述了我们系统的行为——我们与业务利益相关者达成一致的规则——以易于阅读的代码形式。当我们的业务需求发生变化时，我们有信心我们的测试将帮助我们证明新功能，当新的开发人员加入项目时，他们可以阅读我们的测试来理解事物是如何工作的。
- en: We’ve decoupled the infrastructural parts of our system, like the database and
    API handlers, so that we can plug them into the outside of our application. This
    helps us to keep our codebase well organized and stops us from building a big
    ball of mud.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解耦了系统的基础部分，如数据库和API处理程序，以便我们可以将它们插入到我们应用程序的外部。这有助于我们保持我们的代码库组织良好，并阻止我们构建一个大泥球。
- en: By applying the dependency inversion principle, and by using ports-and-adapters-inspired
    patterns like Repository and Unit of Work, we’ve made it possible to do TDD in
    both high gear and low gear and to maintain a healthy test pyramid. We can test
    our system edge to edge, and the need for integration and end-to-end tests is
    kept to a minimum.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用依赖反转原则，并使用端口和适配器启发的模式，如存储库和工作单元，我们已经使得在高档和低档都可以进行TDD，并保持一个健康的测试金字塔。我们可以对我们的系统进行端到端的测试，对集成和端到端测试的需求保持最低限度。
- en: Lastly, we’ve talked about the idea of consistency boundaries. We don’t want
    to lock our entire system whenever we make a change, so we have to choose which
    parts are consistent with one another.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们谈到了一致性边界的概念。我们不希望在进行更改时锁定整个系统，因此我们必须选择哪些部分彼此一致。
- en: For a small system, this is everything you need to go and play with the ideas
    of domain-driven design. You now have the tools to build database-agnostic domain
    models that represent the shared language of your business experts. Hurrah!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个小系统来说，这就是你需要去尝试领域驱动设计理念的一切。现在你有了工具来构建与数据库无关的领域模型，代表了你的业务专家的共享语言。万岁！
- en: Note
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: At the risk of laboring the point—we’ve been at pains to point out that each
    pattern comes at a cost. Each layer of indirection has a price in terms of complexity
    and duplication in our code and will be confusing to programmers who’ve never
    seen these patterns before. If your app is essentially a simple CRUD wrapper around
    a database and isn’t likely to be anything more than that in the foreseeable future,
    *you don’t need these patterns*. Go ahead and use Django, and save yourself a
    lot of bother.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 冒着重复的风险，我们一再强调每个模式都有成本。每一层间接性都会在我们的代码中产生复杂性和重复，并且对于从未见过这些模式的程序员来说会很困惑。如果你的应用本质上只是一个简单的CRUD包装器，围绕数据库，未来也不太可能成为其他东西，*你不需要这些模式*。继续使用Django，省去很多麻烦。
- en: 'In Part II, we’ll zoom out and talk about a bigger topic: if aggregates are
    our boundary, and we can update only one at a time, how do we model processes
    that cross consistency boundaries?'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分中，我们将放大并讨论一个更大的话题：如果聚合是我们的边界，我们只能一次更新一个，那么我们如何建模跨一致性边界的过程呢？
- en: ^([1](ch07.xhtml#idm45714892121352-marker)) Perhaps we could get some ORM/SQLAlchemy
    magic to tell us when an object is dirty, but how would that work in the generic
    case—for example, for a `CsvRepository`?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch07.xhtml#idm45714892121352-marker))也许我们可以通过ORM/SQLAlchemy魔术告诉我们对象何时是脏的，但在通用情况下，这将如何工作——例如对于`CsvRepository`？
- en: ^([2](ch07.xhtml#idm45714891984264-marker)) `time.sleep()` works well in our
    use case, but it’s not the most reliable or efficient way to reproduce concurrency
    bugs. Consider using semaphores or similar synchronization primitives shared between
    your threads to get better guarantees of behavior.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch07.xhtml#idm45714891984264-marker))`time.sleep()`在我们的用例中效果很好，但它并不是再现并发错误最可靠或高效的方式。考虑使用信号量或类似的同步原语，在线程之间共享，以获得更好的行为保证。
- en: ^([3](ch07.xhtml#idm45714891528632-marker)) If you’re not using Postgres, you’ll
    need to read different documentation. Annoyingly, different databases all have
    quite different definitions. Oracle’s `SERIALIZABLE` is equivalent to Postgres’s
    `REPEATABLE READ`, for example.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch07.xhtml#idm45714891528632-marker))如果你没有使用Postgres，你需要阅读不同的文档。令人恼火的是，不同的数据库都有相当不同的定义。例如，Oracle的`SERIALIZABLE`等同于Postgres的`REPEATABLE
    READ`。

- en: Chapter 8\. Events and the Message Bus
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we’ve spent a lot of time and energy on a simple problem that we could
    easily have solved with Django. You might be asking if the increased testability
    and expressiveness are *really* worth all the effort.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, though, we find that it’s not the obvious features that make a
    mess of our codebases: it’s the goop around the edge. It’s reporting, and permissions,
    and workflows that touch a zillion objects.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example will be a typical notification requirement: when we can’t allocate
    an order because we’re out of stock, we should alert the buying team. They’ll
    go and fix the problem by buying more stock, and all will be well.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: For a first version, our product owner says we can just send the alert by email.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how our architecture holds up when we need to plug in some of the
    mundane stuff that makes up so much of our systems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by doing the simplest, most expeditious thing, and talk about why
    it’s exactly this kind of decision that leads us to the Big Ball of Mud.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Then we’ll show how to use the *Domain Events* pattern to separate side effects
    from our use cases, and how to use a simple *Message Bus* pattern for triggering
    behavior based on those events. We’ll show a few options for creating those events
    and how to pass them to the message bus, and finally we’ll show how the Unit of
    Work pattern can be modified to connect the two together elegantly, as previewed
    in [Figure 8-1](#message_bus_diagram).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 0801](Images/apwp_0801.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. Events flowing through the system
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The code for this chapter is in the chapter_08_events_and_message_bus branch
    [on GitHub](https://oreil.ly/M-JuL):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Avoiding Making a Mess
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So. Email alerts when we run out of stock. When we have new requirements like
    ones that *really* have nothing to do with the core domain, it’s all too easy
    to start dumping these things into our web controllers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: First, Let’s Avoid Making a Mess of Our Web Controllers
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a one-off hack, this *might* be OK:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '*Just whack it in the endpoint—what could go wrong? (src/allocation/entrypoints/flask_app.py)*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: …but it’s easy to see how we can quickly end up in a mess by patching things
    up like this. Sending email isn’t the job of our HTTP layer, and we’d like to
    be able to unit test this new feature.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: And Let’s Not Make a Mess of Our Model Either
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assuming we don’t want to put this code into our web controllers, because we
    want them to be as thin as possible, we may look at putting it right at the source,
    in the model:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '*Email-sending code in our model isn’t lovely either (src/allocation/domain/model.py)*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: But that’s even worse! We don’t want our model to have any dependencies on infrastructure
    concerns like `email.send_mail`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: This email-sending thing is unwelcome *goop* messing up the nice clean flow
    of our system. What we’d like is to keep our domain model focused on the rule
    “You can’t allocate more stuff than is actually available.”
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The domain model’s job is to know that we’re out of stock, but the responsibility
    of sending an alert belongs elsewhere. We should be able to turn this feature
    on or off, or to switch to SMS notifications instead, without needing to change
    the rules of our domain model.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Or the Service Layer!
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The requirement “Try to allocate some stock, and send an email if it fails”
    is an example of workflow orchestration: it’s a set of steps that the system has
    to follow to achieve a goal.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve written a service layer to manage orchestration for us, but even here
    the feature feels out of place:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '*And in the service layer, it’s out of place (src/allocation/service_layer/services.py)*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Catching an exception and reraising it? It could be worse, but it’s definitely
    making us unhappy. Why is it so hard to find a suitable home for this code?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Single Responsibility Principle
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Really, this is a violation of the *single responsibility principle* (SRP).^([1](ch08.xhtml#idm45714890821688))
    Our use case is allocation. Our endpoint, service function, and domain methods
    are all called `allocate`, not `allocate_and_send_mail_if_out_of_stock`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Rule of thumb: if you can’t describe what your function does without using
    words like “then” or “and,” you might be violating the SRP.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: One formulation of the SRP is that each class should have only a single reason
    to change. When we switch from email to SMS, we shouldn’t have to update our `allocate()`
    function, because that’s clearly a separate responsibility.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: To solve the problem, we’re going to split the orchestration into separate steps
    so that the different concerns don’t get tangled up.^([2](ch08.xhtml#idm45714890815656))
    The domain model’s job is to know that we’re out of stock, but the responsibility
    of sending an alert belongs elsewhere. We should be able to turn this feature
    on or off, or to switch to SMS notifications instead, without needing to change
    the rules of our domain model.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: We’d also like to keep the service layer free of implementation details. We
    want to apply the dependency inversion principle to notifications so that our
    service layer depends on an abstraction, in the same way as we avoid depending
    on the database by using a unit of work.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: All Aboard the Message Bus!
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The patterns we’re going to introduce here are *Domain Events* and the *Message
    Bus*. We can implement them in a few ways, so we’ll show a couple before settling
    on the one we like most.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The Model Records Events
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, rather than being concerned about emails, our model will be in charge
    of recording *events*—facts about things that have happened. We’ll use a message
    bus to respond to events and invoke a new operation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Events Are Simple Dataclasses
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *event* is a kind of *value object*. Events don’t have any behavior, because
    they’re pure data structures. We always name events in the language of the domain,
    and we think of them as part of our domain model.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'We could store them in *model.py*, but we may as well keep them in their own
    file (this might be a good time to consider refactoring out a directory called
    *domain* so that we have *domain/model.py* and *domain/events.py*):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '*Event classes (src/allocation/domain/events.py)*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](Images/1.png)](#co_events_and_the_message_bus_CO1-1)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a number of events, we’ll find it useful to have a parent class
    that can store common attributes. It’s also useful for type hints in our message
    bus, as you’ll see shortly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_events_and_the_message_bus_CO1-2)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '`dataclasses` are great for domain events too.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The Model Raises Events
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When our domain model records a fact that happened, we say it *raises* an event.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what it will look like from the outside; if we ask `Product` to allocate
    but it can’t, it should *raise* an event:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '*Test our aggregate to raise events (tests/unit/test_product.py)*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](Images/1.png)](#co_events_and_the_message_bus_CO2-1)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Our aggregate will expose a new attribute called `.events` that will contain
    a list of facts about what has happened, in the form of `Event` objects.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the model looks like on the inside:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '*The model raises a domain event (src/allocation/domain/model.py)*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](Images/1.png)](#co_events_and_the_message_bus_CO3-1)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Here’s our new `.events` attribute in use.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_events_and_the_message_bus_CO3-2)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Rather than invoking some email-sending code directly, we record those events
    at the place they occur, using only the language of the domain.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_events_and_the_message_bus_CO3-3)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: We’re also going to stop raising an exception for the out-of-stock case. The
    event will do the job the exception was doing.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-69
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We’re actually addressing a code smell we had until now, which is that we were
    [using exceptions for control flow](https://oreil.ly/IQB51). In general, if you’re
    implementing domain events, don’t raise exceptions to describe the same domain
    concept. As you’ll see later when we handle events in the Unit of Work pattern,
    it’s confusing to have to reason about events and exceptions together.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The Message Bus Maps Events to Handlers
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A message bus basically says, “When I see this event, I should invoke the following
    handler function.” In other words, it’s a simple publish-subscribe system. Handlers
    are *subscribed* to receive events, which we publish to the bus. It sounds harder
    than it is, and we usually implement it with a dict:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '*Simple message bus (src/allocation/service_layer/messagebus.py)*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that the message bus as implemented doesn’t give us concurrency because
    only one handler will run at a time. Our objective isn’t to support parallel threads
    but to separate tasks conceptually, and to keep each UoW as small as possible.
    This helps us to understand the codebase because the “recipe” for how to run each
    use case is written in a single place. See the following sidebar.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 1: The Service Layer Takes Events from the Model and Puts Them on the
    Message Bus'
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our domain model raises events, and our message bus will call the right handlers
    whenever an event happens. Now all we need is to connect the two. We need something
    to catch events from the model and pass them to the message bus—the *publishing*
    step.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to do this is by adding some code into our service layer:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '*The service layer with an explicit message bus (src/allocation/service_layer/services.py)*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](Images/1.png)](#co_events_and_the_message_bus_CO4-1)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: We keep the `try/finally` from our ugly earlier implementation (we haven’t gotten
    rid of *all* exceptions yet, just `OutOfStock`).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_events_and_the_message_bus_CO4-3)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: But now, instead of depending directly on an email infrastructure, the service
    layer is just in charge of passing events from the model up to the message bus.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: That already avoids some of the ugliness that we had in our naive implementation,
    and we have several systems that work like this one, in which the service layer
    explicitly collects events from aggregates and passes them to the message bus.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 2: The Service Layer Raises Its Own Events'
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another variant on this that we’ve used is to have the service layer in charge
    of creating and raising events directly, rather than having them raised by the
    domain model:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '*Service layer calls messagebus.handle directly (src/allocation/service_layer/services.py)*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](Images/1.png)](#co_events_and_the_message_bus_CO5-1)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, we commit even if we fail to allocate because the code is simpler
    this way and it’s easier to reason about: we always commit unless something goes
    wrong. Committing when we haven’t changed anything is safe and keeps the code
    uncluttered.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Again, we have applications in production that implement the pattern in this
    way. What works for you will depend on the particular trade-offs you face, but
    we’d like to show you what we think is the most elegant solution, in which we
    put the unit of work in charge of collecting and raising events.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 3: The UoW Publishes Events to the Message Bus'
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The UoW already has a `try/finally`, and it knows about all the aggregates
    currently in play because it provides access to the repository. So it’s a good
    place to spot events and pass them to the message bus:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '*The UoW meets the message bus (src/allocation/service_layer/unit_of_work.py)*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](Images/1.png)](#co_events_and_the_message_bus_CO6-1)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: We’ll change our commit method to require a private `._commit()` method from
    subclasses.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_events_and_the_message_bus_CO6-2)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: After committing, we run through all the objects that our repository has seen
    and pass their events to the message bus.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_events_and_the_message_bus_CO6-4)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: That relies on the repository keeping track of aggregates that have been loaded
    using a new attribute, `.seen`, as you’ll see in the next listing.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Are you wondering what happens if one of the handlers fails? We’ll discuss error
    handling in detail in [Chapter 10](ch10.xhtml#chapter_10_commands).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '*Repository tracks aggregates that pass through it (src/allocation/adapters/repository.py)*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](Images/1.png)](#co_events_and_the_message_bus_CO7-1)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: For the UoW to be able to publish new events, it needs to be able to ask the
    repository for which `Product` objects have been used during this session. We
    use a `set` called `.seen` to store them. That means our implementations need
    to call `super().__init__()`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_events_and_the_message_bus_CO7-2)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The parent `add()` method adds things to `.seen`, and now requires subclasses
    to implement `._add()`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_events_and_the_message_bus_CO7-3)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, `.get()` delegates to a `._get()` function, to be implemented by
    subclasses, in order to capture objects seen.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The use of `*._underscorey()*` methods and subclassing is definitely not the
    only way you could implement these patterns. Have a go at the [Exercise for the
    Reader](#get_rid_of_commit) in this chapter and experiment with some alternatives.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'After the UoW and repository collaborate in this way to automatically keep
    track of live objects and process their events, the service layer can be totally
    free of event-handling concerns:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '*Service layer is clean again (src/allocation/service_layer/services.py)*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We do also have to remember to change the fakes in the service layer and make
    them call `super()` in the right places, and to implement underscorey methods,
    but the changes are minimal:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '*Service-layer fakes need tweaking (tests/unit/test_services.py)*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You might be starting to worry that maintaining these fakes is going to be a
    maintenance burden. There’s no doubt that it is work, but in our experience it’s
    not a lot of work. Once your project is up and running, the interface for your
    repository and UoW abstractions really don’t change much. And if you’re using
    ABCs, they’ll help remind you when things get out of sync.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Wrap-Up
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Domain events give us a way to handle workflows in our system. We often find,
    listening to our domain experts, that they express requirements in a causal or
    temporal way—for example, “When we try to allocate stock but there’s none available,
    then we should send an email to the buying team.”
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The magic words “When X, then Y” often tell us about an event that we can make
    concrete in our system. Treating events as first-class things in our model helps
    us make our code more testable and observable, and it helps isolate concerns.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: And [Table 8-1](#chapter_08_events_and_message_bus_tradeoffs) shows the trade-offs
    as we see them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-1\. Domain events: the trade-offs'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '| Pros | Cons |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: A message bus gives us a nice way to separate responsibilities when we have
    to take multiple actions in response to a request.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event handlers are nicely decoupled from the “core” application logic, making
    it easy to change their implementation later.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain events are a great way to model the real world, and we can use them as
    part of our business language when modeling with stakeholders.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The message bus is an additional thing to wrap your head around; the implementation
    in which the unit of work raises events for us is *neat* but also magic. It’s
    not obvious when we call `commit` that we’re also going to go and send email to
    people.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s more, that hidden event-handling code executes *synchronously*, meaning
    your service-layer function doesn’t finish until all the handlers for any events
    are finished. That could cause unexpected performance problems in your web endpoints
    (adding asynchronous processing is possible but makes things even *more* confusing).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More generally, event-driven workflows can be confusing because after things
    are split across a chain of multiple handlers, there is no single place in the
    system where you can understand how a request will be fulfilled.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更一般地说，基于事件驱动的工作流可能会令人困惑，因为在事物被分割到多个处理程序链之后，系统中就没有一个单一的地方可以理解请求将如何被满足。
- en: You also open yourself up to the possibility of circular dependencies between
    your event handlers, and infinite loops.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还会面临事件处理程序之间的循环依赖和无限循环的可能性。
- en: '|'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Events are useful for more than just sending email, though. In [Chapter 7](ch07.xhtml#chapter_07_aggregate)
    we spent a lot of time convincing you that you should define aggregates, or boundaries
    where we guarantee consistency. People often ask, “What should I do if I need
    to change multiple aggregates as part of a request?” Now we have the tools we
    need to answer that question.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 事件不仅仅用于发送电子邮件。在[第7章](ch07.xhtml#chapter_07_aggregate)中，我们花了很多时间说服你应该定义聚合，或者我们保证一致性的边界。人们经常问，“如果我需要在一个请求的过程中更改多个聚合，我该怎么办？”现在我们有了回答这个问题所需的工具。
- en: If we have two things that can be transactionally isolated (e.g., an order and
    a product), then we can make them *eventually consistent* by using events. When
    an order is canceled, we should find the products that were allocated to it and
    remove the allocations.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有两个可以在事务上隔离的事物（例如，订单和产品），那么我们可以通过使用事件使它们*最终一致*。当订单被取消时，我们应该找到为其分配的产品并移除这些分配。
- en: In [Chapter 9](ch09.xhtml#chapter_09_all_messagebus), we’ll look at this idea
    in more detail as we build a more complex workflow with our new message bus.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](ch09.xhtml#chapter_09_all_messagebus)中，我们将更详细地研究这个想法，因为我们将使用我们的新消息总线构建一个更复杂的工作流。
- en: ^([1](ch08.xhtml#idm45714890821688-marker)) This principle is the *S* in [SOLID](https://oreil.ly/AIdSD).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch08.xhtml#idm45714890821688-marker))这个原则是[SOLID](https://oreil.ly/AIdSD)中的*S*。
- en: ^([2](ch08.xhtml#idm45714890815656-marker)) Our tech reviewer Ed Jung likes
    to say that the move from imperative to event-based flow control changes what
    used to be *orchestration* into *choreography*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch08.xhtml#idm45714890815656-marker))我们的技术审阅员Ed Jung喜欢说，从命令式到基于事件的流程控制的转变将以前的*编排*变成了*编舞*。

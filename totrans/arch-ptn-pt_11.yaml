- en: Chapter 8\. Events and the Message Bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we’ve spent a lot of time and energy on a simple problem that we could
    easily have solved with Django. You might be asking if the increased testability
    and expressiveness are *really* worth all the effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, though, we find that it’s not the obvious features that make a
    mess of our codebases: it’s the goop around the edge. It’s reporting, and permissions,
    and workflows that touch a zillion objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example will be a typical notification requirement: when we can’t allocate
    an order because we’re out of stock, we should alert the buying team. They’ll
    go and fix the problem by buying more stock, and all will be well.'
  prefs: []
  type: TYPE_NORMAL
- en: For a first version, our product owner says we can just send the alert by email.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how our architecture holds up when we need to plug in some of the
    mundane stuff that makes up so much of our systems.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by doing the simplest, most expeditious thing, and talk about why
    it’s exactly this kind of decision that leads us to the Big Ball of Mud.
  prefs: []
  type: TYPE_NORMAL
- en: Then we’ll show how to use the *Domain Events* pattern to separate side effects
    from our use cases, and how to use a simple *Message Bus* pattern for triggering
    behavior based on those events. We’ll show a few options for creating those events
    and how to pass them to the message bus, and finally we’ll show how the Unit of
    Work pattern can be modified to connect the two together elegantly, as previewed
    in [Figure 8-1](#message_bus_diagram).
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 0801](Images/apwp_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. Events flowing through the system
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The code for this chapter is in the chapter_08_events_and_message_bus branch
    [on GitHub](https://oreil.ly/M-JuL):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding Making a Mess
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So. Email alerts when we run out of stock. When we have new requirements like
    ones that *really* have nothing to do with the core domain, it’s all too easy
    to start dumping these things into our web controllers.
  prefs: []
  type: TYPE_NORMAL
- en: First, Let’s Avoid Making a Mess of Our Web Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a one-off hack, this *might* be OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Just whack it in the endpoint—what could go wrong? (src/allocation/entrypoints/flask_app.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: …but it’s easy to see how we can quickly end up in a mess by patching things
    up like this. Sending email isn’t the job of our HTTP layer, and we’d like to
    be able to unit test this new feature.
  prefs: []
  type: TYPE_NORMAL
- en: And Let’s Not Make a Mess of Our Model Either
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assuming we don’t want to put this code into our web controllers, because we
    want them to be as thin as possible, we may look at putting it right at the source,
    in the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Email-sending code in our model isn’t lovely either (src/allocation/domain/model.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: But that’s even worse! We don’t want our model to have any dependencies on infrastructure
    concerns like `email.send_mail`.
  prefs: []
  type: TYPE_NORMAL
- en: This email-sending thing is unwelcome *goop* messing up the nice clean flow
    of our system. What we’d like is to keep our domain model focused on the rule
    “You can’t allocate more stuff than is actually available.”
  prefs: []
  type: TYPE_NORMAL
- en: The domain model’s job is to know that we’re out of stock, but the responsibility
    of sending an alert belongs elsewhere. We should be able to turn this feature
    on or off, or to switch to SMS notifications instead, without needing to change
    the rules of our domain model.
  prefs: []
  type: TYPE_NORMAL
- en: Or the Service Layer!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The requirement “Try to allocate some stock, and send an email if it fails”
    is an example of workflow orchestration: it’s a set of steps that the system has
    to follow to achieve a goal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve written a service layer to manage orchestration for us, but even here
    the feature feels out of place:'
  prefs: []
  type: TYPE_NORMAL
- en: '*And in the service layer, it’s out of place (src/allocation/service_layer/services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Catching an exception and reraising it? It could be worse, but it’s definitely
    making us unhappy. Why is it so hard to find a suitable home for this code?
  prefs: []
  type: TYPE_NORMAL
- en: Single Responsibility Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Really, this is a violation of the *single responsibility principle* (SRP).^([1](ch08.xhtml#idm45714890821688))
    Our use case is allocation. Our endpoint, service function, and domain methods
    are all called `allocate`, not `allocate_and_send_mail_if_out_of_stock`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Rule of thumb: if you can’t describe what your function does without using
    words like “then” or “and,” you might be violating the SRP.'
  prefs: []
  type: TYPE_NORMAL
- en: One formulation of the SRP is that each class should have only a single reason
    to change. When we switch from email to SMS, we shouldn’t have to update our `allocate()`
    function, because that’s clearly a separate responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: To solve the problem, we’re going to split the orchestration into separate steps
    so that the different concerns don’t get tangled up.^([2](ch08.xhtml#idm45714890815656))
    The domain model’s job is to know that we’re out of stock, but the responsibility
    of sending an alert belongs elsewhere. We should be able to turn this feature
    on or off, or to switch to SMS notifications instead, without needing to change
    the rules of our domain model.
  prefs: []
  type: TYPE_NORMAL
- en: We’d also like to keep the service layer free of implementation details. We
    want to apply the dependency inversion principle to notifications so that our
    service layer depends on an abstraction, in the same way as we avoid depending
    on the database by using a unit of work.
  prefs: []
  type: TYPE_NORMAL
- en: All Aboard the Message Bus!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The patterns we’re going to introduce here are *Domain Events* and the *Message
    Bus*. We can implement them in a few ways, so we’ll show a couple before settling
    on the one we like most.
  prefs: []
  type: TYPE_NORMAL
- en: The Model Records Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, rather than being concerned about emails, our model will be in charge
    of recording *events*—facts about things that have happened. We’ll use a message
    bus to respond to events and invoke a new operation.
  prefs: []
  type: TYPE_NORMAL
- en: Events Are Simple Dataclasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *event* is a kind of *value object*. Events don’t have any behavior, because
    they’re pure data structures. We always name events in the language of the domain,
    and we think of them as part of our domain model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could store them in *model.py*, but we may as well keep them in their own
    file (this might be a good time to consider refactoring out a directory called
    *domain* so that we have *domain/model.py* and *domain/events.py*):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Event classes (src/allocation/domain/events.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_events_and_the_message_bus_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a number of events, we’ll find it useful to have a parent class
    that can store common attributes. It’s also useful for type hints in our message
    bus, as you’ll see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_events_and_the_message_bus_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`dataclasses` are great for domain events too.'
  prefs: []
  type: TYPE_NORMAL
- en: The Model Raises Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When our domain model records a fact that happened, we say it *raises* an event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what it will look like from the outside; if we ask `Product` to allocate
    but it can’t, it should *raise* an event:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Test our aggregate to raise events (tests/unit/test_product.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_events_and_the_message_bus_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Our aggregate will expose a new attribute called `.events` that will contain
    a list of facts about what has happened, in the form of `Event` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the model looks like on the inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The model raises a domain event (src/allocation/domain/model.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_events_and_the_message_bus_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s our new `.events` attribute in use.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_events_and_the_message_bus_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than invoking some email-sending code directly, we record those events
    at the place they occur, using only the language of the domain.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_events_and_the_message_bus_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We’re also going to stop raising an exception for the out-of-stock case. The
    event will do the job the exception was doing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We’re actually addressing a code smell we had until now, which is that we were
    [using exceptions for control flow](https://oreil.ly/IQB51). In general, if you’re
    implementing domain events, don’t raise exceptions to describe the same domain
    concept. As you’ll see later when we handle events in the Unit of Work pattern,
    it’s confusing to have to reason about events and exceptions together.
  prefs: []
  type: TYPE_NORMAL
- en: The Message Bus Maps Events to Handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A message bus basically says, “When I see this event, I should invoke the following
    handler function.” In other words, it’s a simple publish-subscribe system. Handlers
    are *subscribed* to receive events, which we publish to the bus. It sounds harder
    than it is, and we usually implement it with a dict:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Simple message bus (src/allocation/service_layer/messagebus.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that the message bus as implemented doesn’t give us concurrency because
    only one handler will run at a time. Our objective isn’t to support parallel threads
    but to separate tasks conceptually, and to keep each UoW as small as possible.
    This helps us to understand the codebase because the “recipe” for how to run each
    use case is written in a single place. See the following sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 1: The Service Layer Takes Events from the Model and Puts Them on the
    Message Bus'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our domain model raises events, and our message bus will call the right handlers
    whenever an event happens. Now all we need is to connect the two. We need something
    to catch events from the model and pass them to the message bus—the *publishing*
    step.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to do this is by adding some code into our service layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The service layer with an explicit message bus (src/allocation/service_layer/services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_events_and_the_message_bus_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We keep the `try/finally` from our ugly earlier implementation (we haven’t gotten
    rid of *all* exceptions yet, just `OutOfStock`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_events_and_the_message_bus_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: But now, instead of depending directly on an email infrastructure, the service
    layer is just in charge of passing events from the model up to the message bus.
  prefs: []
  type: TYPE_NORMAL
- en: That already avoids some of the ugliness that we had in our naive implementation,
    and we have several systems that work like this one, in which the service layer
    explicitly collects events from aggregates and passes them to the message bus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 2: The Service Layer Raises Its Own Events'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another variant on this that we’ve used is to have the service layer in charge
    of creating and raising events directly, rather than having them raised by the
    domain model:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Service layer calls messagebus.handle directly (src/allocation/service_layer/services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_events_and_the_message_bus_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, we commit even if we fail to allocate because the code is simpler
    this way and it’s easier to reason about: we always commit unless something goes
    wrong. Committing when we haven’t changed anything is safe and keeps the code
    uncluttered.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, we have applications in production that implement the pattern in this
    way. What works for you will depend on the particular trade-offs you face, but
    we’d like to show you what we think is the most elegant solution, in which we
    put the unit of work in charge of collecting and raising events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 3: The UoW Publishes Events to the Message Bus'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The UoW already has a `try/finally`, and it knows about all the aggregates
    currently in play because it provides access to the repository. So it’s a good
    place to spot events and pass them to the message bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The UoW meets the message bus (src/allocation/service_layer/unit_of_work.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_events_and_the_message_bus_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll change our commit method to require a private `._commit()` method from
    subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_events_and_the_message_bus_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: After committing, we run through all the objects that our repository has seen
    and pass their events to the message bus.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_events_and_the_message_bus_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: That relies on the repository keeping track of aggregates that have been loaded
    using a new attribute, `.seen`, as you’ll see in the next listing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Are you wondering what happens if one of the handlers fails? We’ll discuss error
    handling in detail in [Chapter 10](ch10.xhtml#chapter_10_commands).
  prefs: []
  type: TYPE_NORMAL
- en: '*Repository tracks aggregates that pass through it (src/allocation/adapters/repository.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_events_and_the_message_bus_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: For the UoW to be able to publish new events, it needs to be able to ask the
    repository for which `Product` objects have been used during this session. We
    use a `set` called `.seen` to store them. That means our implementations need
    to call `super().__init__()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_events_and_the_message_bus_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The parent `add()` method adds things to `.seen`, and now requires subclasses
    to implement `._add()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_events_and_the_message_bus_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, `.get()` delegates to a `._get()` function, to be implemented by
    subclasses, in order to capture objects seen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The use of `*._underscorey()*` methods and subclassing is definitely not the
    only way you could implement these patterns. Have a go at the [Exercise for the
    Reader](#get_rid_of_commit) in this chapter and experiment with some alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the UoW and repository collaborate in this way to automatically keep
    track of live objects and process their events, the service layer can be totally
    free of event-handling concerns:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Service layer is clean again (src/allocation/service_layer/services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We do also have to remember to change the fakes in the service layer and make
    them call `super()` in the right places, and to implement underscorey methods,
    but the changes are minimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Service-layer fakes need tweaking (tests/unit/test_services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You might be starting to worry that maintaining these fakes is going to be a
    maintenance burden. There’s no doubt that it is work, but in our experience it’s
    not a lot of work. Once your project is up and running, the interface for your
    repository and UoW abstractions really don’t change much. And if you’re using
    ABCs, they’ll help remind you when things get out of sync.
  prefs: []
  type: TYPE_NORMAL
- en: Wrap-Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Domain events give us a way to handle workflows in our system. We often find,
    listening to our domain experts, that they express requirements in a causal or
    temporal way—for example, “When we try to allocate stock but there’s none available,
    then we should send an email to the buying team.”
  prefs: []
  type: TYPE_NORMAL
- en: The magic words “When X, then Y” often tell us about an event that we can make
    concrete in our system. Treating events as first-class things in our model helps
    us make our code more testable and observable, and it helps isolate concerns.
  prefs: []
  type: TYPE_NORMAL
- en: And [Table 8-1](#chapter_08_events_and_message_bus_tradeoffs) shows the trade-offs
    as we see them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 8-1\. Domain events: the trade-offs'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pros | Cons |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: A message bus gives us a nice way to separate responsibilities when we have
    to take multiple actions in response to a request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event handlers are nicely decoupled from the “core” application logic, making
    it easy to change their implementation later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain events are a great way to model the real world, and we can use them as
    part of our business language when modeling with stakeholders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The message bus is an additional thing to wrap your head around; the implementation
    in which the unit of work raises events for us is *neat* but also magic. It’s
    not obvious when we call `commit` that we’re also going to go and send email to
    people.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s more, that hidden event-handling code executes *synchronously*, meaning
    your service-layer function doesn’t finish until all the handlers for any events
    are finished. That could cause unexpected performance problems in your web endpoints
    (adding asynchronous processing is possible but makes things even *more* confusing).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More generally, event-driven workflows can be confusing because after things
    are split across a chain of multiple handlers, there is no single place in the
    system where you can understand how a request will be fulfilled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You also open yourself up to the possibility of circular dependencies between
    your event handlers, and infinite loops.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Events are useful for more than just sending email, though. In [Chapter 7](ch07.xhtml#chapter_07_aggregate)
    we spent a lot of time convincing you that you should define aggregates, or boundaries
    where we guarantee consistency. People often ask, “What should I do if I need
    to change multiple aggregates as part of a request?” Now we have the tools we
    need to answer that question.
  prefs: []
  type: TYPE_NORMAL
- en: If we have two things that can be transactionally isolated (e.g., an order and
    a product), then we can make them *eventually consistent* by using events. When
    an order is canceled, we should find the products that were allocated to it and
    remove the allocations.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](ch09.xhtml#chapter_09_all_messagebus), we’ll look at this idea
    in more detail as we build a more complex workflow with our new message bus.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch08.xhtml#idm45714890821688-marker)) This principle is the *S* in [SOLID](https://oreil.ly/AIdSD).
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch08.xhtml#idm45714890815656-marker)) Our tech reviewer Ed Jung likes
    to say that the move from imperative to event-based flow control changes what
    used to be *orchestration* into *choreography*.
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 10\. Commands and Command Handler
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we talked about using events as a way of representing
    the inputs to our system, and we turned our application into a message-processing
    machine.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: To achieve that, we converted all our use-case functions to event handlers.
    When the API receives a POST to create a new batch, it builds a new `BatchCreated`
    event and handles it as if it were an internal event. This might feel counterintuitive.
    After all, the batch *hasn’t* been created yet; that’s why we called the API.
    We’re going to fix that conceptual wart by introducing commands and showing how
    they can be handled by the same message bus but with slightly different rules.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The code for this chapter is in the chapter_10_commands branch [on GitHub](https://oreil.ly/U_VGa):'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Commands and Events
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like events, *commands* are a type of message—instructions sent by one part
    of a system to another. We usually represent commands with dumb data structures
    and can handle them in much the same way as events.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The differences between commands and events, though, are important.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Commands are sent by one actor to another specific actor with the expectation
    that a particular thing will happen as a result. When we post a form to an API
    handler, we are sending a command. We name commands with imperative mood verb
    phrases like “allocate stock” or “delay shipment.”
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Commands capture *intent*. They express our wish for the system to do something.
    As a result, when they fail, the sender needs to receive error information.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '*Events* are broadcast by an actor to all interested listeners. When we publish
    `BatchQuantityChanged`, we don’t know who’s going to pick it up. We name events
    with past-tense verb phrases like “order allocated to stock” or “shipment delayed.”'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: We often use events to spread the knowledge about successful commands.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Events capture *facts* about things that happened in the past. Since we don’t
    know who’s handling an event, senders should not care whether the receivers succeeded
    or failed. [Table 10-1](#events_vs_commands_table) recaps the differences.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-1\. Events versus commands
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Event | Command |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| Named | Past tense | Imperative mood |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| Error handling | Fail independently | Fail noisily |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| Sent to | All listeners | One recipient |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: What kinds of commands do we have in our system right now?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '*Pulling out some commands (src/allocation/domain/commands.py)*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](Images/1.png)](#co_commands_and_command_handler_CO1-1)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '`commands.Allocate` will replace `events.AllocationRequired`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_commands_and_command_handler_CO1-2)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '`commands.CreateBatch` will replace `events.BatchCreated`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_commands_and_command_handler_CO1-3)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '`commands.ChangeBatchQuantity` will replace `events.BatchQuantityChanged`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Differences in Exception Handling
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just changing the names and verbs is all very well, but that won’t change the
    behavior of our system. We want to treat events and commands similarly, but not
    exactly the same. Let’s see how our message bus changes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '*Dispatch events and commands differently (src/allocation/service_layer/messagebus.py)*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](Images/1.png)](#co_commands_and_command_handler_CO2-1)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: It still has a main `handle()` entrypoint that takes a `message`, which may
    be a command or an event.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_commands_and_command_handler_CO2-2)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: We dispatch events and commands to two different helper functions, shown next.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we handle events:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '*Events cannot interrupt the flow (src/allocation/service_layer/messagebus.py)*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](Images/1.png)](#co_commands_and_command_handler_CO3-1)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Events go to a dispatcher that can delegate to multiple handlers per event.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_commands_and_command_handler_CO3-2)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: It catches and logs errors but doesn’t let them interrupt message processing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'And here’s how we do commands:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '*Commands reraise exceptions (src/allocation/service_layer/messagebus.py)*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](Images/1.png)](#co_commands_and_command_handler_CO4-1)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The command dispatcher expects just one handler per command.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_commands_and_command_handler_CO4-3)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: If any errors are raised, they fail fast and will bubble up.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_commands_and_command_handler_CO4-2)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '`return result` is only temporary; as mentioned in [“A Temporary Ugly Hack:
    The Message Bus Has to Return Results”](ch09.xhtml#temporary_ugly_hack), it’s
    a temporary hack to allow the message bus to return the batch reference for the
    API to use. We’ll fix this in [Chapter 12](ch12.xhtml#chapter_12_cqrs).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'We also change the single `HANDLERS` dict into different ones for commands
    and events. Commands can have only one handler, according to our convention:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '*New handlers dicts (src/allocation/service_layer/messagebus.py)*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Discussion: Events, Commands, and Error Handling'
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many developers get uncomfortable at this point and ask, “What happens when
    an event fails to process? How am I supposed to make sure the system is in a consistent
    state?” If we manage to process half of the events during `messagebus.handle`
    before an out-of-memory error kills our process, how do we mitigate problems caused
    by the lost messages?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the worst case: we fail to handle an event, and the system
    is left in an inconsistent state. What kind of error would cause this? Often in
    our systems we can end up in an inconsistent state when only half an operation
    is completed.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could allocate three units of `DESIRABLE_BEANBAG` to a customer’s
    order but somehow fail to reduce the amount of remaining stock. This would cause
    an inconsistent state: the three units of stock are both allocated *and* available,
    depending on how you look at it. Later, we might allocate those same beanbags
    to another customer, causing a headache for customer support.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: In our allocation service, though, we’ve already taken steps to prevent that
    happening. We’ve carefully identified *aggregates* that act as consistency boundaries,
    and we’ve introduced a *UoW* that manages the atomic success or failure of an
    update to an aggregate.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when we allocate stock to an order, our consistency boundary is
    the `Product` aggregate. This means that we can’t accidentally overallocate: either
    a particular order line is allocated to the product, or it is not—there’s no room
    for inconsistent states.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: By definition, we don’t require two aggregates to be immediately consistent,
    so if we fail to process an event and update only a single aggregate, our system
    can still be made eventually consistent. We shouldn’t violate any constraints
    of the system.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: With this example in mind, we can better understand the reason for splitting
    messages into commands and events. When a user wants to make the system do something,
    we represent their request as a *command*. That command should modify a single
    *aggregate* and either succeed or fail in totality. Any other bookkeeping, cleanup,
    and notification we need to do can happen via an *event*. We don’t require the
    event handlers to succeed in order for the command to be successful.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at another example (from a different, imaginary projet) to see why
    not.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we are building an ecommerce website that sells expensive luxury goods.
    Our marketing department wants to reward customers for repeat visits. We will
    flag customers as VIPs after they make their third purchase, and this will entitle
    them to priority treatment and special offers. Our acceptance criteria for this
    story reads as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using the techniques we’ve already discussed in this book, we decide that we
    want to build a new `History` aggregate that records orders and can raise domain
    events when rules are met. We will structure the code like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '*VIP customer (example code for a different project)*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](Images/1.png)](#co_commands_and_command_handler_CO5-1)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The `History` aggregate captures the rules indicating when a customer becomes
    a VIP. This puts us in a good place to handle changes when the rules become more
    complex in the future.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_commands_and_command_handler_CO5-2)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Our first handler creates an order for the customer and raises a domain event
    `OrderCreated`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_commands_and_command_handler_CO5-3)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Our second handler updates the `History` object to record that an order was
    created.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_commands_and_command_handler_CO5-4)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we send an email to the customer when they become a VIP.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Using this code, we can gain some intuition about error handling in an event-driven
    system.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: In our current implementation, we raise events about an aggregate *after* we
    persist our state to the database. What if we raised those events *before* we
    persisted, and committed all our changes at the same time? That way, we could
    be sure that all the work was complete. Wouldn’t that be safer?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: What happens, though, if the email server is slightly overloaded? If all the
    work has to complete at the same time, a busy email server can stop us from taking
    money for orders.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: What happens if there is a bug in the implementation of the `History` aggregate?
    Should we fail to take your money just because we can’t recognize you as a VIP?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: By separating out these concerns, we have made it possible for things to fail
    in isolation, which improves the overall reliability of the system. The only part
    of this code that *has* to complete is the command handler that creates an order.
    This is the only part that a customer cares about, and it’s the part that our
    business stakeholders should prioritize.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we’ve deliberately aligned our transactional boundaries to the start
    and end of the business processes. The names that we use in the code match the
    jargon used by our business stakeholders, and the handlers we’ve written match
    the steps of our natural language acceptance criteria. This concordance of names
    and structure helps us to reason about our systems as they grow larger and more
    complex.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Recovering from Errors Synchronously
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hopefully we’ve convinced you that it’s OK for events to fail independently
    from the commands that raised them. What should we do, then, to make sure we can
    recover from errors when they inevitably occur?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need is to know *when* an error has occurred, and for that
    we usually rely on logs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look again at the `handle_event` method from our message bus:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '*Current handle function (src/allocation/service_layer/messagebus.py)*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we handle a message in our system, the first thing we do is write a log
    line to record what we’re about to do. For our `CustomerBecameVIP` use case, the
    logs might read as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because we’ve chosen to use dataclasses for our message types, we get a neatly
    printed summary of the incoming data that we can copy and paste into a Python
    shell to re-create the object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: When an error occurs, we can use the logged data to either reproduce the problem
    in a unit test or replay the message into the system.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Manual replay works well for cases where we need to fix a bug before we can
    re-process an event, but our systems will *always* experience some background
    level of transient failure. This includes things like network hiccups, table deadlocks,
    and brief downtime caused by deployments.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: For most of those cases, we can recover elegantly by trying again. As the proverb
    says, “If at first you don’t succeed, retry the operation with an exponentially
    increasing back-off period.”
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '*Handle with retry (src/allocation/service_layer/messagebus.py)*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](Images/1.png)](#co_commands_and_command_handler_CO6-1)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Tenacity is a Python library that implements common patterns for retrying.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_commands_and_command_handler_CO6-2)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Here we configure our message bus to retry operations up to three times, with
    an exponentially increasing wait between attempts.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Retrying operations that might fail is probably the single best way to improve
    the resilience of our software. Again, the Unit of Work and Command Handler patterns
    mean that each attempt starts from a consistent state and won’t leave things half-finished.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 重试可能会失败的操作可能是改善软件弹性的最佳方法。再次，工作单元和命令处理程序模式意味着每次尝试都从一致的状态开始，并且不会留下半成品。
- en: Warning
  id: totrans-103
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: At some point, regardless of `tenacity`, we’ll have to give up trying to process
    the message. Building reliable systems with distributed messages is hard, and
    we have to skim over some tricky bits. There are pointers to more reference materials
    in the [epilogue](afterword01.xhtml#epilogue_1_how_to_get_there_from_here).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，无论`tenacity`如何，我们都必须放弃尝试处理消息。构建可靠的分布式消息系统很困难，我们必须略过一些棘手的部分。在[结语](afterword01.xhtml#epilogue_1_how_to_get_there_from_here)中有更多参考资料的指针。
- en: Wrap-Up
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this book we decided to introduce the concept of events before the concept
    of commands, but other guides often do it the other way around. Making explicit
    the requests that our system can respond to by giving them a name and their own
    data structure is quite a fundamental thing to do. You’ll sometimes see people
    use the name *Command Handler* pattern to describe what we’re doing with Events,
    Commands, and Message Bus.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们决定在介绍命令的概念之前先介绍事件的概念，但其他指南通常是相反的。通过为系统可以响应的请求命名并为它们提供自己的数据结构，是一件非常基本的事情。有时你会看到人们使用“命令处理程序”模式来描述我们在事件、命令和消息总线中所做的事情。
- en: '[Table 10-2](#chapter_10_commands_and_events_tradeoffs) discusses some of the
    things you should think about before you jump on board.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[表10-2](#chapter_10_commands_and_events_tradeoffs)讨论了在你加入之前应该考虑的一些事情。'
- en: 'Table 10-2\. Splitting commands and events: the trade-offs'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 表10-2。分割命令和事件：权衡利弊
- en: '| Pros | Cons |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 优点 | 缺点 |'
- en: '| --- | --- |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Treating commands and events differently helps us understand which things have
    to succeed and which things we can tidy up later.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将命令和事件区分对待有助于我们理解哪些事情必须成功，哪些事情可以稍后整理。
- en: '`CreateBatch` is definitely a less confusing name than `BatchCreated`. We are
    being explicit about the intent of our users, and explicit is better than implicit,
    right?'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateBatch`绝对比`BatchCreated`更清晰。我们明确了用户的意图，而明确比隐含更好，对吧？'
- en: '|'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The semantic differences between commands and events can be subtle. Expect bikeshedding
    arguments over the differences.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令和事件之间的语义差异可能是微妙的。对于这些差异可能会有很多争论。
- en: We’re expressly inviting failure. We know that sometimes things will break,
    and we’re choosing to handle that by making the failures smaller and more isolated.
    This can make the system harder to reason about and requires better monitoring.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们明确地邀请失败。我们知道有时会出现问题，我们选择通过使失败变得更小更隔离来处理这些问题。这可能会使系统更难以理解，并需要更好的监控。
- en: '|'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: In [Chapter 11](ch11.xhtml#chapter_11_external_events) we’ll talk about using
    events as an integration pattern.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](ch11.xhtml#chapter_11_external_events)中，我们将讨论使用事件作为集成模式。

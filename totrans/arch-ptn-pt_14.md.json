["```py\ngit clone https://github.com/cosmicpython/code.git\ncd code\ngit checkout chapter_11_external_events\n# or to code along, checkout the previous chapter:\ngit checkout chapter_10_commands\n```", "```py\n[plantuml, apwp_1102, config=plantuml.cfg]\n@startuml Batches Context Diagram\n!include images/C4_Context.puml\n\nSystem(batches, \"Batches\", \"Knows about available stock\")\nPerson(customer, \"Customer\", \"Wants to buy furniture\")\nSystem(orders, \"Orders\", \"Knows about customer orders\")\nSystem(warehouse, \"Warehouse\", \"Knows about shipping instructions\")\n\nRel_R(customer, orders, \"Places order with\")\nRel_D(orders, batches, \"Reserves stock with\")\nRel_D(batches, warehouse, \"Sends instructions to\")\n\n@enduml\n```", "```py\n[plantuml, apwp_1103, config=plantuml.cfg]\n@startuml\n\nactor Customer\nentity Orders\nentity Batches\nentity Warehouse\ndatabase CRM\n\n== Reservation ==\n\n  Customer -> Orders: Add product to basket\n  Orders -> Batches: Reserve stock\n\n== Purchase ==\n\n  Customer -> Orders: Place order\n  activate Orders\n  Orders -> Batches: Confirm reservation\n  Batches -> Warehouse: Dispatch goods\n  Orders -> CRM: Update customer record\n  deactivate Orders\n\n@enduml\n```", "```py\n[plantuml, apwp_1104, config=plantuml.cfg]\n@startuml\n\nactor w as \"Warehouse worker\"\nentity Warehouse\nentity Batches\nentity Orders\ndatabase CRM\n\n  w -> Warehouse: Report stock damage\n  activate Warehouse\n  Warehouse -> Batches: Decrease available stock\n  Batches -> Batches: Reallocate orders\n  Batches -> Orders: Update order status\n  Orders -> CRM: Update order history\n  deactivate Warehouse\n\n@enduml\n```", "```py\n[plantuml, apwp_1105, config=plantuml.cfg]\n@startuml\n\nactor Customer\nentity Orders\nentity Batches\n\nCustomer -> Orders: Place order\nOrders -[#red]x Batches: Confirm reservation\nhnote right: network error\nOrders --> Customer: ???\n\n@enduml\n```", "```py\n[plantuml, apwp_1106, config=plantuml.cfg]\n\n@startuml\n\nRedis -> MessageBus : BatchQuantityChanged event\n\ngroup BatchQuantityChanged Handler + Unit of Work 1\n    MessageBus -> Domain_Model : change batch quantity\n    Domain_Model -> MessageBus : emit Allocate command(s)\nend\n\ngroup Allocate Handler + Unit of Work 2 (or more)\n    MessageBus -> Domain_Model : allocate\n    Domain_Model -> MessageBus : emit Allocated event(s)\nend\n\nMessageBus -> Redis : publish to line_allocated channel\n@enduml\n```", "```py\ndeftest_change_batch_quantity_leading_to_reallocation():# start with two batches and an order allocated to one of them ![1](Images/1.png)orderid,sku=random_orderid(),random_sku()earlier_batch,later_batch=random_batchref('old'),random_batchref('newer')api_client.post_to_add_batch(earlier_batch,sku,qty=10,eta='2011-01-02')![2](Images/2.png)api_client.post_to_add_batch(later_batch,sku,qty=10,eta='2011-01-02')response=api_client.post_to_allocate(orderid,sku,10)![2](Images/2.png)assertresponse.json()['batchref']==earlier_batchsubscription=redis_client.subscribe_to('line_allocated')![3](Images/3.png)# change quantity on allocated batch so it's less than our order ![1](Images/1.png)redis_client.publish_message('change_batch_quantity',{![3](Images/3.png)'batchref':earlier_batch,'qty':5})# wait until we see a message saying the order has been reallocated ![1](Images/1.png)messages=[]forattemptinRetrying(stop=stop_after_delay(3),reraise=True):![4](Images/4.png)withattempt:message=subscription.get_message(timeout=1)ifmessage:messages.append(message)print(messages)data=json.loads(messages[-1]['data'])assertdata['orderid']==orderidassertdata['batchref']==later_batch\n```", "```py\nr=redis.Redis(**config.get_redis_host_and_port())defmain():orm.start_mappers()pubsub=r.pubsub(ignore_subscribe_messages=True)pubsub.subscribe('change_batch_quantity')![1](Images/1.png)forminpubsub.listen():handle_change_batch_quantity(m)defhandle_change_batch_quantity(m):logging.debug('handling %s',m)data=json.loads(m['data'])![2](Images/2.png)cmd=commands.ChangeBatchQuantity(ref=data['batchref'],qty=data['qty'])![2](Images/2.png)messagebus.handle(cmd,uow=unit_of_work.SqlAlchemyUnitOfWork())\n```", "```py\nr=redis.Redis(**config.get_redis_host_and_port())defpublish(channel,event:events.Event):![1](Images/1.png)logging.debug('publishing: channel=%s, event=%s',channel,event)r.publish(channel,json.dumps(asdict(event)))\n```", "```py\n@dataclass\nclass Allocated(Event):\n    orderid: str\n    sku: str\n    qty: int\n    batchref: str\n```", "```py\nclass Product:\n    ...\n    def allocate(self, line: OrderLine) -> str:\n        ...\n\n            batch.allocate(line)\n            self.version_number += 1\n            self.events.append(events.Allocated(\n                orderid=line.orderid, sku=line.sku, qty=line.qty,\n                batchref=batch.reference,\n            ))\n            return batch.reference\n```", "```py\nHANDLERS = {\n    events.Allocated: [handlers.publish_allocated_event],\n    events.OutOfStock: [handlers.send_out_of_stock_notification],\n}  # type: Dict[Type[events.Event], List[Callable]]\n```", "```py\ndef publish_allocated_event(\n        event: events.Allocated, uow: unit_of_work.AbstractUnitOfWork,\n):\n    redis_eventpublisher.publish('line_allocated', event)\n```"]
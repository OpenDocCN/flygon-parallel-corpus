["```py\ngit clone https://github.com/cosmicpython/code.git\ncd code\ngit checkout chapter_13_dependency_injection\n# or to code along, checkout the previous chapter:\ngit checkout chapter_12_cqrs\n```", "```py\ndef allocate(\n        cmd: commands.Allocate, uow: unit_of_work.AbstractUnitOfWork\n):\n```", "```py\n    uow = FakeUnitOfWork()\n    messagebus.handle([...], uow)\n```", "```py\nclass SqlAlchemyUnitOfWork(AbstractUnitOfWork):\n\n    def __init__(self, session_factory=DEFAULT_SESSION_FACTORY):\n        self.session_factory = session_factory\n        ...\n```", "```py\ndeftest_rolls_back_uncommitted_work_by_default(sqlite_session_factory):uow=unit_of_work.SqlAlchemyUnitOfWork(sqlite_session_factory)![1](Images/1.png)\n```", "```py\nfromallocation.adaptersimportemail,redis_eventpublisher![1](Images/1.png)...defsend_out_of_stock_notification(event:events.OutOfStock,uow:unit_of_work.AbstractUnitOfWork,):email.send(![2](Images/2.png)'stock@made.com',f'Out of stock for {event.sku}',)\n```", "```py\n    with mock.patch(\"allocation.adapters.email.send\") as mock_send_mail:\n        ...\n```", "```py\ndef send_out_of_stock_notification(\n        event: events.OutOfStock, send_mail: Callable,\n):\n    send_mail(\n        'stock@made.com',\n        f'Out of stock for {event.sku}',\n    )\n```", "```py\n# existing allocate function, with abstract uow dependencydefallocate(cmd:commands.Allocate,uow:unit_of_work.AbstractUnitOfWork):line=OrderLine(cmd.orderid,cmd.sku,cmd.qty)withuow:...# bootstrap script prepares actual UoWdefbootstrap(..):uow=unit_of_work.SqlAlchemyUnitOfWork()# prepare a version of the allocate fn with UoW dependency captured in a closureallocate_composed=lambdacmd:allocate(cmd,uow)# or, equivalently (this gets you a nicer stack trace)defallocate_composed(cmd):returnallocate(cmd,uow)# alternatively with a partialimportfunctoolsallocate_composed=functools.partial(allocate,uow=uow)![1](Images/1.png)# later at runtime, we can call the partial function, and it will have# the UoW already boundallocate_composed(cmd)\n```", "```py\ndef send_out_of_stock_notification(\n        event: events.OutOfStock, send_mail: Callable,\n):\n    send_mail(\n        'stock@made.com',\n        ...\n\n# prepare a version of the send_out_of_stock_notification with dependencies\nsosn_composed  = lambda event: send_out_of_stock_notification(event, email.send_mail)\n\n...\n# later, at runtime:\nsosn_composed(event)  # will have email.send_mail already injected in\n```", "```py\n# we replace the old `def allocate(cmd, uow)` with:classAllocateHandler:def__init__(self,uow:unit_of_work.AbstractUnitOfWork):![2](Images/2.png)self.uow=uowdef__call__(self,cmd:commands.Allocate):![1](Images/1.png)line=OrderLine(cmd.orderid,cmd.sku,cmd.qty)withself.uow:# rest of handler method as before...# bootstrap script prepares actual UoWuow=unit_of_work.SqlAlchemyUnitOfWork()# then prepares a version of the allocate fn with dependencies already injectedallocate=AllocateHandler(uow)...# later at runtime, we can call the handler instance, and it will have# the UoW already injectedallocate(cmd)\n```", "```py\ndefbootstrap(start_orm:bool=True,![1](Images/1.png)uow:unit_of_work.AbstractUnitOfWork=unit_of_work.SqlAlchemyUnitOfWork(),![2](Images/2.png)send_mail:Callable=email.send,publish:Callable=redis_eventpublisher.publish,)->messagebus.MessageBus:ifstart_orm:orm.start_mappers()![1](Images/1.png)dependencies={'uow':uow,'send_mail':send_mail,'publish':publish}injected_event_handlers={![3](Images/3.png)event_type:[inject_dependencies(handler,dependencies)forhandlerinevent_handlers]forevent_type,event_handlersinhandlers.EVENT_HANDLERS.items()}injected_command_handlers={![3](Images/3.png)command_type:inject_dependencies(handler,dependencies)forcommand_type,handlerinhandlers.COMMAND_HANDLERS.items()}returnmessagebus.MessageBus(![4](Images/4.png)uow=uow,event_handlers=injected_event_handlers,command_handlers=injected_command_handlers,)\n```", "```py\ndefinject_dependencies(handler,dependencies):params=inspect.signature(handler).parameters![1](Images/1.png)deps={name:dependencyforname,dependencyindependencies.items()![2](Images/2.png)ifnameinparams}returnlambdamessage:handler(message,**deps)![3](Images/3.png)\n```", "```py\nclassMessageBus:![1](Images/1.png)def__init__(self,uow:unit_of_work.AbstractUnitOfWork,event_handlers:Dict[Type[events.Event],List[Callable]],![2](Images/2.png)command_handlers:Dict[Type[commands.Command],Callable],![2](Images/2.png)):self.uow=uowself.event_handlers=event_handlersself.command_handlers=command_handlersdefhandle(self,message:Message):![3](Images/3.png)self.queue=[message]![4](Images/4.png)whileself.queue:message=self.queue.pop(0)ifisinstance(message,events.Event):self.handle_event(message)elifisinstance(message,commands.Command):self.handle_command(message)else:raiseException(f'{message} was not an Event or Command')\n```", "```py\ndefhandle_event(self,event:events.Event):forhandlerinself.event_handlers[type(event)]:![1](Images/1.png)try:logger.debug('handling event %s with handler %s',event,handler)handler(event)![2](Images/2.png)self.queue.extend(self.uow.collect_new_events())exceptException:logger.exception('Exception handling event %s',event)continuedefhandle_command(self,command:commands.Command):logger.debug('handling command %s',command)try:handler=self.command_handlers[type(command)]![1](Images/1.png)handler(command)![2](Images/2.png)self.queue.extend(self.uow.collect_new_events())exceptException:logger.exception('Exception handling command %s',command)raise\n```", "```py\n-from allocation import views +from allocation import bootstrap, views  app = Flask(__name__) -orm.start_mappers() ![1](Images/1.png)+bus = bootstrap.bootstrap()  @app.route(\"/add_batch\", methods=['POST']) @@ -19,8 +16,7 @@ def add_batch():\n cmd = commands.CreateBatch( request.json['ref'], request.json['sku'], request.json['qty'], eta, ) -    uow = unit_of_work.SqlAlchemyUnitOfWork() ![2](Images/2.png)-    messagebus.handle(cmd, uow) +    bus.handle(cmd) ![3](Images/3.png) return 'OK', 201\n```", "```py\n@pytest.fixturedefsqlite_bus(sqlite_session_factory):bus=bootstrap.bootstrap(start_orm=True,![1](Images/1.png)uow=unit_of_work.SqlAlchemyUnitOfWork(sqlite_session_factory),![2](Images/2.png)send_mail=lambda*args:None,![3](Images/3.png)publish=lambda*args:None,![3](Images/3.png))yieldbusclear_mappers()deftest_allocations_view(sqlite_bus):sqlite_bus.handle(commands.CreateBatch('sku1batch','sku1',50,None))sqlite_bus.handle(commands.CreateBatch('sku2batch','sku2',50,date.today()))...assertviews.allocations('order1',sqlite_bus.uow)==[{'sku':'sku1','batchref':'sku1batch'},{'sku':'sku2','batchref':'sku2batch'},]\n```", "```py\ndefbootstrap_test_app():returnbootstrap.bootstrap(start_orm=False,![1](Images/1.png)uow=FakeUnitOfWork(),![2](Images/2.png)send_mail=lambda*args:None,![3](Images/3.png)publish=lambda*args:None,![3](Images/3.png))\n```", "```py\nuow:unit_of_work.AbstractUnitOfWork,![1](Images/1.png)send_mail:Callable,![2](Images/2.png)publish:Callable,![2](Images/2.png)\n```", "```py\nclass AbstractNotifications(abc.ABC):\n\n    @abc.abstractmethod\n    def send(self, destination, message):\n        raise NotImplementedError\n\n...\n\nclass EmailNotifications(AbstractNotifications):\n\n    def __init__(self, smtp_host=DEFAULT_HOST, port=DEFAULT_PORT):\n        self.server = smtplib.SMTP(smtp_host, port=port)\n        self.server.noop()\n\n    def send(self, destination, message):\n        msg = f'Subject: allocation service notification\\n{message}'\n        self.server.sendmail(\n            from_addr='allocations@example.com',\n            to_addrs=[destination],\n            msg=msg\n        )\n```", "```py\n def bootstrap(\n     start_orm: bool = True,\n     uow: unit_of_work.AbstractUnitOfWork = unit_of_work.SqlAlchemyUnitOfWork(),\n-    send_mail: Callable = email.send,\n+    notifications: AbstractNotifications = EmailNotifications(),\n     publish: Callable = redis_eventpublisher.publish,\n ) -> messagebus.MessageBus:\n```", "```py\nclass FakeNotifications(notifications.AbstractNotifications):\n\n    def __init__(self):\n        self.sent = defaultdict(list)  # type: Dict[str, List[str]]\n\n    def send(self, destination, message):\n        self.sent[destination].append(message)\n...\n```", "```py\n    def test_sends_email_on_out_of_stock_error(self):\n        fake_notifs = FakeNotifications()\n        bus = bootstrap.bootstrap(\n            start_orm=False,\n            uow=FakeUnitOfWork(),\n            notifications=fake_notifs,\n            publish=lambda *args: None,\n        )\n        bus.handle(commands.CreateBatch(\"b1\", \"POPULAR-CURTAINS\", 9, None))\n        bus.handle(commands.Allocate(\"o1\", \"POPULAR-CURTAINS\", 10))\n        assert fake_notifs.sent['stock@made.com'] == [\n            f\"Out of stock for POPULAR-CURTAINS\",\n        ]\n```", "```py\nversion: \"3\"\n\nservices:\n\n  redis_pubsub:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    image: allocation-image\n    ...\n\n  api:\n    image: allocation-image\n    ...\n\n  postgres:\n    image: postgres:9.6\n    ...\n\n  redis:\n    image: redis:alpine\n    ...\n\n  mailhog:\n    image: mailhog/mailhog\n    ports:\n      - \"11025:1025\"\n      - \"18025:8025\"\n```", "```py\n@pytest.fixturedefbus(sqlite_session_factory):bus=bootstrap.bootstrap(start_orm=True,uow=unit_of_work.SqlAlchemyUnitOfWork(sqlite_session_factory),notifications=notifications.EmailNotifications(),![1](Images/1.png)publish=lambda*args:None,)yieldbusclear_mappers()defget_email_from_mailhog(sku):![2](Images/2.png)host,port=map(config.get_email_host_and_port().get,['host','http_port'])all_emails=requests.get(f'http://{host}:{port}/api/v2/messages').json()returnnext(mforminall_emails['items']ifskuinstr(m))deftest_out_of_stock_email(bus):sku=random_sku()bus.handle(commands.CreateBatch('batch1',sku,9,None))![3](Images/3.png)bus.handle(commands.Allocate('order1',sku,10))email=get_email_from_mailhog(sku)assertemail['Raw']['From']=='allocations@example.com'![4](Images/4.png)assertemail['Raw']['To']==['stock@made.com']assertf'Out of stock for {sku}'inemail['Raw']['Data']\n```"]
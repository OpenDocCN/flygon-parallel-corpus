- en: Chapter 13\. Dependency Injection (and Bootstrapping)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency injection (DI) is regarded with suspicion in the Python world. And
    we’ve managed *just fine* without it so far in the example code for this book!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore some of the pain points in our code that lead
    us to consider using DI, and we’ll present some options for how to do it, leaving
    it to you to pick which you think is most Pythonic.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also add a new component to our architecture called *bootstrap.py*; it
    will be in charge of dependency injection, as well as some other initialization
    stuff that we often need. We’ll explain why this sort of thing is called a *composition
    root* in OO languages, and why *bootstrap script* is just fine for our purposes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-1](#bootstrap_chapter_before_diagram) shows what our app looks like
    without a bootstrapper: the entrypoints do a lot of initialization and passing
    around of our main dependency, the UoW.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you haven’t already, it’s worth reading [Chapter 3](ch03.xhtml#chapter_03_abstractions)
    before continuing with this chapter, particularly the discussion of functional
    versus object-oriented dependency management.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 1301](Images/apwp_1301.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-1\. Without bootstrap: entrypoints do a lot'
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Tip
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The code for this chapter is in the chapter_13_dependency_injection branch
    [on GitHub](https://oreil.ly/-B7e6):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Figure 13-2](#bootstrap_chapter_after_diagram) shows our bootstrapper taking
    over those responsibilities.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 1302](Images/apwp_1302.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: Figure 13-2\. Bootstrap takes care of all that in one place
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Implicit Versus Explicit Dependencies
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on your particular brain type, you may have a slight feeling of unease
    at the back of your mind at this point. Let’s bring it out into the open. We’ve
    shown you two ways of managing dependencies and testing them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'For our database dependency, we’ve built a careful framework of explicit dependencies
    and easy options for overriding them in tests. Our main handler functions declare
    an explicit dependency on the UoW:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '*Our handlers have an explicit dependency on the UoW (src/allocation/service_layer/handlers.py)*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And that makes it easy to swap in a fake UoW in our service-layer tests:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '*Service-layer tests against a fake UoW: (tests/unit/test_services.py)*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The UoW itself declares an explicit dependency on the session factory:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '*The UoW depends on a session factory (src/allocation/service_layer/unit_of_work.py)*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We take advantage of it in our integration tests to be able to sometimes use
    SQLite instead of Postgres:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '*Integration tests against a different DB (tests/integration/test_uow.py)*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO1-1)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests swap out the default Postgres `session_factory` for a SQLite
    one.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Aren’t Explicit Dependencies Totally Weird and Java-y?
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you’re used to the way things normally happen in Python, you’ll be thinking
    all this is a bit weird. The standard way to do things is to declare our dependency
    implicitly by simply importing it, and then if we ever need to change it for tests,
    we can monkeypatch, as is Right and True in dynamic languages:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '*Email sending as a normal import-based dependency (src/allocation/service_layer/handlers.py)*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO2-1)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Hardcoded import
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO2-2)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Calls specific email sender directly
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Why pollute our application code with unnecessary arguments just for the sake
    of our tests? `mock.patch` makes monkeypatching nice and easy:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '*mock dot patch, thank you Michael Foord (tests/unit/test_handlers.py)*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The trouble is that we’ve made it look easy because our toy example doesn’t
    send real email (`email.send_mail` just does a `print`), but in real life, you’d
    end up having to call `mock.patch` for *every single test* that might cause an
    out-of-stock notification. If you’ve worked on codebases with lots of mocks used
    to prevent unwanted side effects, you’ll know how annoying that mocky boilerplate
    gets.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: And you’ll know that mocks tightly couple us to the implementation. By choosing
    to monkeypatch `email.send_mail`, we are tied to doing `import email`, and if
    we ever want to do `from email import send_mail`, a trivial refactor, we’d have
    to change all our mocks.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: So it’s a trade-off. Yes, declaring explicit dependencies is unnecessary, strictly
    speaking, and using them would make our application code marginally more complex.
    But in return, we’d get tests that are easier to write and manage.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of that, declaring an explicit dependency is an example of the dependency
    inversion principle—rather than having an (implicit) dependency on a *specific*
    detail, we have an (explicit) dependency on an *abstraction*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Explicit is better than implicit.
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The Zen of Python
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The explicit dependency is more abstract (src/allocation/service_layer/handlers.py)*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'But if we do change to declaring all these dependencies explicitly, who will
    inject them, and how? So far, we’ve really been dealing with only passing the
    UoW around: our tests use `FakeUnitOfWork`, while Flask and Redis eventconsumer
    entrypoints use the real UoW, and the message bus passes them onto our command
    handlers. If we add real and fake email classes, who will create them and pass
    them on?'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: That’s extra (duplicated) cruft for Flask, Redis, and our tests. Moreover, putting
    all the responsibility for passing dependencies to the right handler onto the
    message bus feels like a violation of the SRP.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we’ll reach for a pattern called *Composition Root* (a bootstrap script
    to you and me),^([1](ch13.xhtml#idm45714881770184)) and we’ll do a bit of “manual
    DI” (dependency injection without a framework). See [Figure 13-3](#bootstrap_new_image).^([2](ch13.xhtml#idm45714881767896))
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp 1303](Images/apwp_1303.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: Figure 13-3\. Bootstrapper between entrypoints and message bus
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Preparing Handlers: Manual DI with Closures and Partials'
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One way to turn a function with dependencies into one that’s ready to be called
    later with those dependencies *already injected* is to use closures or partial
    functions to compose the function with its dependencies:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '*Examples of DI using closures or partial functions*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO3-1)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The difference between closures (lambdas or named functions) and `functools.partial`
    is that the former use [late binding of variables](https://docs.python-guide.org/writing/gotchas/#late-binding-closures),
    which can be a source of confusion if any of the dependencies are mutable.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the same pattern again for the `send_out_of_stock_notification()` handler,
    which has different dependencies:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '*Another closure and partial functions example*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: An Alternative Using Classes
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Closures and partial functions will feel familiar to people who’ve done a bit
    of functional programming. Here’s an alternative using classes, which may appeal
    to others. It requires rewriting all our handler functions as classes, though:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '*DI using classes*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO4-2)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The class is designed to produce a callable function, so it has a `*call*` method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO4-1)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: But we use the `init` to declare the dependencies it requires. This sort of
    thing will feel familiar if you’ve ever made class-based descriptors, or a class-based
    context manager that takes arguments.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Use whichever you and your team feel more comfortable with.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: A Bootstrap Script
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want our bootstrap script to do the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Declare default dependencies but allow us to override them
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do the “init” stuff that we need to get our app started
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject all the dependencies into our handlers
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give us back the core object for our app, the message bus
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s a first cut:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '*A bootstrap function (src/allocation/bootstrap.py)*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO5-1)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '`orm.start_mappers()` is our example of initialization work that needs to be
    done once at the beginning of an app. We also see things like setting up the `logging`
    module.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO5-2)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: We can use the argument defaults to define what the normal/production defaults
    are. It’s nice to have them in a single place, but sometimes dependencies have
    some side effects at construction time, in which case you might prefer to default
    them to `None` instead.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO5-4)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: We build up our injected versions of the handler mappings by using a function
    called `inject_dependencies()`, which we’ll show next.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_dependency_injection__and_bootstrapping__CO5-6)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: We return a configured message bus ready for use.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we inject dependencies into a handler function by inspecting it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '*DI by inspecting function signatures (src/allocation/bootstrap.py)*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO6-1)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: We inspect our command/event handler’s arguments.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO6-2)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: We match them by name to our dependencies.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO6-3)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: We inject them as kwargs to produce a partial.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Message Bus Is Given Handlers at Runtime
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our message bus will no longer be static; it needs to have the already-injected
    handlers given to it. So we turn it from being a module into a configurable class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '*MessageBus as a class (src/allocation/service_layer/messagebus.py)*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO7-1)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The message bus becomes a class…
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO7-2)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: …which is given its already-dependency-injected handlers.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO7-4)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The main `handle()` function is substantially the same, with just a few attributes
    and methods moved onto `self`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_dependency_injection__and_bootstrapping__CO7-5)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Using `self.queue` like this is not thread-safe, which might be a problem if
    you’re using threads, because the bus instance is global in the Flask app context
    as we’ve written it. Just something to watch out for.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: What else changes in the bus?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '*Event and command handler logic stays the same (src/allocation/service_layer/messagebus.py)*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO8-1)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '`handle_event` and `handle_command` are substantially the same, but instead
    of indexing into a static `EVENT_HANDLERS` or `COMMAND_HANDLERS` dict, they use
    the versions on `self`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO8-2)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Instead of passing a UoW into the handler, we expect the handlers to already
    have all their dependencies, so all they need is a single argument, the specific
    event or command.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Using Bootstrap in Our Entrypoints
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our application’s entrypoints, we now just call `bootstrap.bootstrap()`
    and get a message bus that’s ready to go, rather than configuring a UoW and the
    rest of it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '*Flask calls bootstrap (src/allocation/entrypoints/flask_app.py)*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO9-1)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: We no longer need to call `start_orm()`; the bootstrap script’s initialization
    stages will do that.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO9-2)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: We no longer need to explicitly build a particular type of UoW; the bootstrap
    script defaults take care of it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO9-3)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: And our message bus is now a specific instance rather than the global module.^([3](ch13.xhtml#idm45714880379080))
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Initializing DI in Our Tests
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In tests, we can use `bootstrap.bootstrap()` with overridden defaults to get
    a custom message bus. Here’s an example in an integration test:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '*Overriding bootstrap defaults (tests/integration/test_views.py)*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO10-1)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: We do still want to start the ORM…
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO10-2)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: …because we’re going to use a real UoW, albeit with an in-memory database.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO10-3)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: But we don’t need to send email or publish, so we make those noops.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'In our unit tests, in contrast, we can reuse our `FakeUnitOfWork`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '*Bootstrap in unit test (tests/unit/test_handlers.py)*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO11-1)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: No need to start the ORM…
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO11-2)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: …because the fake UoW doesn’t use one.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO11-3)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: We want to fake out our email and Redis adapters too.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: So that gets rid of a little duplication, and we’ve moved a bunch of setup and
    sensible defaults into a single place.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Building an Adapter “Properly”: A Worked Example'
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To really get a feel for how it all works, let’s work through an example of
    how you might “properly” build an adapter and do dependency injection for it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'At the moment, we have two types of dependencies:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '*Two types of dependencies (src/allocation/service_layer/messagebus.py)*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO12-1)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The UoW has an abstract base class. This is the heavyweight option for declaring
    and managing your external dependency. We’d use this for the case when the dependency
    is relatively complex.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO12-2)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Our email sender and pub/sub publisher are defined as functions. This works
    just fine for simple dependencies.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the things we find ourselves injecting at work:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: An S3 filesystem client
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A key/value store client
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `requests` session object
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most of these will have more-complex APIs that you can’t capture as a single
    function: read and write, GET and POST, and so on.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Even though it’s simple, let’s use `send_mail` as an example to talk through
    how you might define a more complex dependency.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Define the Abstract and Concrete Implementations
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll imagine a more generic notifications API. Could be email, could be SMS,
    could be Slack posts one day.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '*An ABC and a concrete implementation (src/allocation/adapters/notifications.py)*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We change the dependency in the bootstrap script:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '*Notifications in message bus (src/allocation/bootstrap.py)*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Make a Fake Version for Your Tests
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We work through and define a fake version for unit testing:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '*Fake notifications (tests/unit/test_handlers.py)*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And we use it in our tests:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '*Tests change slightly (tests/unit/test_handlers.py)*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Figure Out How to Integration Test the Real Thing
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we test the real thing, usually with an end-to-end or integration test.
    We’ve used [MailHog](https://github.com/mailhog/MailHog) as a real-ish email server
    for our Docker dev environment:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '*Docker-compose config with real fake email server (docker-compose.yml)*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In our integration tests, we use the real `EmailNotifications` class, talking
    to the MailHog server in the Docker cluster:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '*Integration test for email (tests/integration/test_email.py)*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO13-1)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: We use our bootstrapper to build a message bus that talks to the real notifications
    class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO13-2)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: We figure out how to fetch emails from our “real” email server.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO13-3)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO13-3)'
- en: We use the bus to do our test setup.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用总线来进行测试设置。
- en: '[![4](Images/4.png)](#co_dependency_injection__and_bootstrapping__CO13-4)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_dependency_injection__and_bootstrapping__CO13-4)'
- en: Against all the odds, this actually worked, pretty much at the first go!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 出乎意料的是，这实际上非常顺利地完成了！
- en: And that’s it really.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。
- en: Wrap-Up
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Once you have more than one adapter, you’ll start to feel a lot of pain from
    passing dependencies around manually, unless you do some kind of *dependency injection.*
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了多个适配器，除非你进行某种*依赖注入*，否则手动传递依赖关系会让你感到很痛苦。
- en: Setting up dependency injection is just one of many typical setup/initialization
    activities that you need to do just once when starting your app. Putting this
    all together into a *bootstrap script* is often a good idea.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 设置依赖注入只是在启动应用程序时需要做的许多典型设置/初始化活动之一。将所有这些放在一个*引导脚本*中通常是一个好主意。
- en: The bootstrap script is also good as a place to provide sensible default configuration
    for your adapters, and as a single place to override those adapters with fakes
    for your tests.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 引导脚本也是一个很好的地方，可以为适配器提供合理的默认配置，并且作为一个单一的地方，可以用虚假的适配器覆盖测试。
- en: A dependency injection framework can be useful if you find yourself needing
    to do DI at multiple levels—if you have chained dependencies of components that
    all need DI, for example.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己需要在多个级别进行DI，例如，如果你有一系列组件的链式依赖需要DI，那么依赖注入框架可能会很有用。
- en: This chapter also presented a worked example of changing an implicit/simple
    dependency into a “proper” adapter, factoring out an ABC, defining its real and
    fake implementations, and thinking through integration testing.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还提供了一个实际示例，将隐式/简单的依赖关系改变为“适当”的适配器，将ABC分离出来，定义其真实和虚假的实现，并思考集成测试。
- en: These were the last patterns we wanted to cover, which brings us to the end
    of [Part II](part02.xhtml#part2). In [the epilogue](afterword01.xhtml#epilogue_1_how_to_get_there_from_here),
    we’ll try to give you some pointers for applying these techniques in the Real
    World^(TM).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们想要覆盖的最后几个模式，这将我们带到了[第二部分](part02.xhtml#part2)的结尾。在[结语](afterword01.xhtml#epilogue_1_how_to_get_there_from_here)中，我们将尝试为您提供一些在现实世界中应用这些技术的指导。
- en: ^([1](ch13.xhtml#idm45714881770184-marker)) Because Python is not a “pure” OO
    language, Python developers aren’t necessarily used to the concept of needing
    to *compose* a set of objects into a working application. We just pick our entrypoint
    and run code from top to bottom.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch13.xhtml#idm45714881770184-marker)) 因为Python不是一个“纯”面向对象的语言，Python开发人员并不一定习惯于需要将一组对象*组合*成一个工作应用程序的概念。我们只是选择我们的入口点，然后从上到下运行代码。
- en: ^([2](ch13.xhtml#idm45714881767896-marker)) Mark Seemann calls this [*Pure DI*](https://oreil.ly/iGpDL)
    or sometimes *Vanilla DI*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '^([2](ch13.xhtml#idm45714881767896-marker)) Mark Seemann将这称为[*Pure DI*](https://oreil.ly/iGpDL)，有时也称为*Vanilla
    DI*。 '
- en: ^([3](ch13.xhtml#idm45714880379080-marker)) However, it’s still a global in
    the `flask_app` module scope, if that makes sense. This may cause problems if
    you ever find yourself wanting to test your Flask app in-process by using the
    Flask Test Client instead of using Docker as we do. It’s worth researching [Flask
    app factories](https://oreil.ly/_a6Kl) if you get into this.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch13.xhtml#idm45714880379080-marker)) 但是，如果有意义的话，它仍然是`flask_app`模块范围内的全局变量。如果你想要使用Flask测试客户端而不是像我们一样使用Docker来测试你的Flask应用程序，这可能会导致问题。如果你遇到这种情况，值得研究[Flask应用程序工厂](https://oreil.ly/_a6Kl)。

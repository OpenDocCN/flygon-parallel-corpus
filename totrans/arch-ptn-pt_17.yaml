- en: Epilogue
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What Now?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Phew! We’ve covered a lot of ground in this book, and for most of our audience
    all of these ideas are new. With that in mind, we can’t hope to make you experts
    in these techniques. All we can really do is show you the broad-brush ideas, and
    just enough code for you to go ahead and write something from scratch.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The code we’ve shown in this book isn’t battle-hardened production code: it’s
    a set of Lego blocks that you can play with to make your first house, spaceship,
    and skyscraper.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: That leaves us with two big tasks. We want to talk about how to start applying
    these ideas for real in an existing system, and we need to warn you about some
    of the things we had to skip. We’ve given you a whole new arsenal of ways to shoot
    yourself in the foot, so we should discuss some basic firearms safety.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: How Do I Get There from Here?
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chances are that a lot of you are thinking something like this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: “OK Bob and Harry, that’s all well and good, and if I ever get hired to work
    on a green-field new service, I know what to do. But in the meantime, I’m here
    with my big ball of Django mud, and I don’t see any way to get to your nice, clean,
    perfect, untainted, simplistic model. Not from here.”
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: We hear you. Once you’ve already *built* a big ball of mud, it’s hard to know
    how to start improving things. Really, we need to tackle things step by step.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first: what problem are you trying to solve? Is the software too
    hard to change? Is the performance unacceptable? Have you got weird, inexplicable
    bugs?'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Having a clear goal in mind will help you to prioritize the work that needs
    to be done and, importantly, communicate the reasons for doing it to the rest
    of the team. Businesses tend to have pragmatic approaches to technical debt and
    refactoring, so long as engineers can make a reasoned argument for fixing things.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Making complex changes to a system is often an easier sell if you link it to
    feature work. Perhaps you’re launching a new product or opening your service to
    new markets? This is the right time to spend engineering resources on fixing the
    foundations. With a six-month project to deliver, it’s easier to make the argument
    for three weeks of cleanup work. Bob refers to this as *architecture tax*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Separating Entangled Responsibilities
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the beginning of the book, we said that the main characteristic of a big
    ball of mud is homogeneity: every part of the system looks the same, because we
    haven’t been clear about the responsibilities of each component. To fix that,
    we’ll need to start separating out responsibilities and introducing clear boundaries.
    One of the first things we can do is to start building a service layer ([Figure E-1](#collaboration_app_model)).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![apwp ep01](Images/apwp_ep01.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: Figure E-1\. Domain of a collaboration system
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This was the system in which Bob first learned how to break apart a ball of
    mud, and it was a doozy. There was logic *everywhere*—in the web pages, in manager
    objects, in helpers, in fat service classes that we’d written to abstract the
    managers and helpers, and in hairy command objects that we’d written to break
    apart the services.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: If you’re working in a system that’s reached this point, the situation can feel
    hopeless, but it’s never too late to start weeding an overgrown garden. Eventually,
    we hired an architect who knew what he was doing, and he helped us get things
    back under control.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by working out the *use cases* of your system. If you have a user interface,
    what actions does it perform? If you have a backend processing component, maybe
    each cron job or Celery job is a single use case. Each of your use cases needs
    to have an imperative name: Apply Billing Charges, Clean Abandoned Accounts, or
    Raise Purchase Order, for example.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: In our case, most of our use cases were part of the manager classes and had
    names like Create Workspace or Delete Document Version. Each use case was invoked
    from a web frontend.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'We aim to create a single function or class for each of these supported operations
    that deals with *orchestrating* the work to be done. Each use case should do the
    following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是为每个支持的操作创建一个单独的函数或类，用于*编排*要执行的工作。每个用例应执行以下操作：
- en: Start its own database transaction if needed
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如有需要，启动自己的数据库事务
- en: Fetch any required data
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取所需的任何数据
- en: Check any preconditions (see the Ensure pattern in [Appendix E](app05.xhtml#appendix_validation))
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查任何前提条件（请参阅[附录E]中的确保模式（app05.xhtml#appendix_validation））
- en: Update the domain model
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新领域模型
- en: Persist any changes
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化任何更改
- en: Each use case should succeed or fail as an atomic unit. You might need to call
    one use case from another. That’s OK; just make a note of it, and try to avoid
    long-running database transactions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用例应作为一个原子单元成功或失败。您可能需要从另一个用例中调用一个用例。没问题；只需做个记录，并尽量避免长时间运行的数据库事务。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: One of the biggest problems we had was that manager methods called other manager
    methods, and data access could happen from the model objects themselves. It was
    hard to understand what each operation did without going on a treasure hunt across
    the codebase. Pulling all the logic into a single method, and using a UoW to control
    our transactions, made the system easier to reason about.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到的最大问题之一是管理器方法调用其他管理器方法，并且数据访问可以发生在模型对象本身。很难在不跨越整个代码库进行寻宝之旅的情况下理解每个操作的含义。将所有逻辑汇总到一个方法中，并使用UoW来控制我们的事务，使系统更容易理解。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: It’s fine if you have duplication in the use-case functions. We’re not trying
    to write perfect code; we’re just trying to extract some meaningful layers. It’s
    better to duplicate some code in a few places than to have use-case functions
    calling one another in a long chain.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在用例函数中存在重复，也没关系。我们不是要编写完美的代码；我们只是试图提取一些有意义的层。在几个地方重复一些代码要比让用例函数在长链中相互调用要好。
- en: This is a good opportunity to pull any data-access or orchestration code out
    of the domain model and into the use cases. We should also try to pull I/O concerns
    (e.g., sending email, writing files) out of the domain model and up into the use-case
    functions. We apply the techniques from [Chapter 3](ch03.xhtml#chapter_03_abstractions)
    on abstractions to keep our handlers unit testable even when they’re performing
    I/O.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的机会，可以将任何数据访问或编排代码从领域模型中提取出来，并放入用例中。我们还应该尝试将I/O问题（例如发送电子邮件、写文件）从领域模型中提取出来，并放入用例函数中。我们应用[第3章](ch03.xhtml#chapter_03_abstractions)中关于抽象的技术，以便在执行I/O时保持我们的处理程序可单元测试。
- en: These use-case functions will mostly be about logging, data access, and error
    handling. Once you’ve done this step, you’ll have a grasp of what your program
    actually *does*, and a way to make sure each operation has a clearly defined start
    and finish. We’ll have taken a step toward building a pure domain model.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用例函数主要涉及日志记录、数据访问和错误处理。完成此步骤后，您将了解程序实际*执行*的操作，并且有一种方法来确保每个操作都有明确定义的开始和结束。我们将迈出一步，朝着构建纯领域模型迈进。
- en: Read *Working Effectively with Legacy Code* by Michael C. Feathers (Prentice
    Hall) for guidance on getting legacy code under test and starting separating responsibilities.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读Michael C. Feathers的《与遗留代码有效地工作》（Prentice Hall）以获取有关对遗留代码进行测试和开始分离责任的指导。
- en: Identifying Aggregates and Bounded Contexts
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别聚合和有界上下文
- en: Part of the problem with the codebase in our case study was that the object
    graph was highly connected. Each account had many workspaces, and each workspace
    had many members, all of whom had their own accounts. Each workspace contained
    many documents, which had many versions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例研究中，代码库的一部分问题是对象图高度连接。每个帐户都有许多工作空间，每个工作空间都有许多成员，所有这些成员都有自己的帐户。每个工作空间包含许多文档，每个文档都有许多版本。
- en: You can’t express the full horror of the thing in a class diagram. For one thing,
    there wasn’t really a single account related to a user. Instead, there was a bizarre
    rule requiring you to enumerate all of the accounts associated to the user via
    the workspaces and take the one with the earliest creation date.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法在类图中表达事物的全部恐怖。首先，实际上并没有一个与用户相关的单个帐户。相反，有一个奇怪的规则要求您通过工作空间枚举与用户关联的所有帐户，并选择创建日期最早的帐户。
- en: Every object in the system was part of an inheritance hierarchy that included
    `SecureObject` and `Version`. This inheritance hierarchy was mirrored directly
    in the database schema, so that every query had to join across 10 different tables
    and look at a discriminator column just to tell what kind of objects you were
    working with.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中的每个对象都是继承层次结构的一部分，其中包括`SecureObject`和`Version`。这种继承层次结构直接在数据库模式中进行了镜像，因此每个查询都必须跨越10个不同的表进行连接，并查看鉴别器列，以便确定正在处理的对象的类型。
- en: 'The codebase made it easy to “dot” your way through these objects like so:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 代码库使得可以像这样“点”穿过这些对象：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Building a system this way with Django ORM or SQLAlchemy is easy but is to be
    avoided. Although it’s *convenient*, it makes it very hard to reason about performance
    because each property might trigger a lookup to the database.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Django ORM或SQLAlchemy构建系统很容易，但应该避免。尽管这很*方便*，但很难理解性能，因为每个属性可能触发对数据库的查找。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Aggregates are a *consistency boundary*. In general, each use case should update
    a single aggregate at a time. One handler fetches one aggregate from a repository,
    modifies its state, and raises any events that happen as a result. If you need
    data from another part of the system, it’s totally fine to use a read model, but
    avoid updating multiple aggregates in a single transaction. When we choose to
    separate code into different aggregates, we’re explicitly choosing to make them
    *eventually consistent* with one another.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合是*一致性边界*。一般来说，每个用例应一次只更新一个聚合。一个处理程序从存储库中获取一个聚合，修改其状态，并引发任何作为结果发生的事件。如果您需要来自系统其他部分的数据，完全可以使用读取模型，但要避免在单个事务中更新多个聚合。当我们选择将代码分离为不同的聚合时，我们明确选择使它们*最终一致*。
- en: 'A bunch of operations required us to loop over objects this way—for example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一堆操作需要我们以这种方式循环遍历对象，例如：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Or even recurse over collections of folders and documents:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以递归遍历文件夹和文档的集合：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These operations *killed* performance, but fixing them meant giving up our single
    object graph. Instead, we began to identify aggregates and to break the direct
    links between objects.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作*严重*影响了性能，但修复它们意味着放弃我们的单个对象图。相反，我们开始识别聚合并打破对象之间的直接链接。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We talked about the infamous `SELECT N+1` problem in [Chapter 12](ch12.xhtml#chapter_12_cqrs),
    and how we might choose to use different techniques when reading data for queries
    versus reading data for commands.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第12章](ch12.xhtml#chapter_12_cqrs)中谈到了臭名昭著的`SELECT N+1`问题，以及在查询数据和命令数据时可能选择使用不同的技术。
- en: Mostly we did this by replacing direct references with identifiers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们通过用标识符替换直接引用来实现这一点。
- en: 'Before aggregates:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在聚合之前：
- en: '![apwp ep02](Images/apwp_ep02.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![apwp ep02](Images/apwp_ep02.png)'
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After modeling with aggregates:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 建模后：
- en: '![apwp ep03](Images/apwp_ep03.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![apwp ep03](Images/apwp_ep03.png)'
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Bidirectional links are often a sign that your aggregates aren’t right. In our
    original code, a `Document` knew about its containing `Folder`, and the `Folder`
    had a collection of `Documents`. This makes it easy to traverse the object graph
    but stops us from thinking properly about the consistency boundaries we need.
    We break apart aggregates by using references instead. In the new model, a `Document`
    had reference to its `parent_folder` but had no way to directly access the `Folder`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链接通常表明您的聚合不正确。在我们的原始代码中，`Document`知道其包含的`Folder`，而`Folder`有一组`Documents`。这使得遍历对象图很容易，但阻止我们正确思考我们需要的一致性边界。我们通过使用引用来拆分聚合。在新模型中，`Document`引用其`parent_folder`，但无法直接访问`Folder`。
- en: If we needed to *read* data, we avoided writing complex loops and transforms
    and tried to replace them with straight SQL. For example, one of our screens was
    a tree view of folders and documents.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要*读取*数据，我们会避免编写复杂的循环和转换，并尝试用直接的SQL替换它们。例如，我们的一个屏幕是文件夹和文档的树形视图。
- en: This screen was *incredibly* heavy on the database, because it relied on nested
    `for` loops that triggered a lazy-loaded ORM.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个屏幕在数据库上非常重，因为它依赖于触发延迟加载的ORM的嵌套`for`循环。
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: We use this same technique in [Chapter 11](ch11.xhtml#chapter_11_external_events),
    where we replace a nested loop over ORM objects with a simple SQL query. It’s
    the first step in a CQRS approach.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第11章](ch11.xhtml#chapter_11_external_events)中使用了相同的技术，用一个简单的SQL查询替换了对ORM对象的嵌套循环。这是CQRS方法的第一步。
- en: After a lot of head-scratching, we replaced the ORM code with a big, ugly stored
    procedure. The code looked horrible, but it was much faster and helped to break
    the links between `Folder` and `Document`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 经过长时间的思考，我们用一个又大又丑的存储过程替换了ORM代码。代码看起来很糟糕，但速度要快得多，并有助于打破`Folder`和`Document`之间的联系。
- en: When we needed to *write* data, we changed a single aggregate at a time, and
    we introduced a message bus to handle events. For example, in the new model, when
    we locked an account, we could first query for all the affected workspaces via
    `SELECT *id* FROM *workspace* WHERE *account_id* = ?`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要*写入*数据时，我们逐个更改单个聚合，并引入消息总线来处理事件。例如，在新模型中，当我们锁定一个账户时，我们可以首先查询所有受影响的工作空间。通过`SELECT
    *id* FROM *workspace* WHERE *account_id* = ?`。
- en: 'We could then raise a new command for each workspace:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以为每个工作空间提出一个新的命令：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: An Event-Driven Approach to Go to Microservices via Strangler Pattern
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Strangler模式实现微服务的事件驱动方法
- en: The *Strangler Fig* pattern involves creating a new system around the edges
    of an old system, while keeping it running. Bits of old functionality are gradually
    intercepted and replaced, until the old system is left doing nothing at all and
    can be switched off.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*Strangler Fig*模式涉及在旧系统的边缘创建一个新系统，同时保持其运行。逐渐拦截和替换旧功能，直到旧系统完全无事可做，可以关闭。'
- en: 'When building the availability service, we used a technique called *event interception*
    to move functionality from one place to another. This is a three-step process:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建可用性服务时，我们使用了一种称为*事件拦截*的技术，将功能从一个地方移动到另一个地方。这是一个三步过程：
- en: Raise events to represent the changes happening in a system you want to replace.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引发事件来表示系统中发生的变化。
- en: Build a second system that consumes those events and uses them to build its
    own domain model.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个消耗这些事件并使用它们构建自己领域模型的第二个系统。
- en: Replace the older system with the new.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用新的系统替换旧的系统。
- en: We used event interception to move from [Figure E-2](#strangler_before)…
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用事件拦截从[图E-2](#strangler_before)移动…
- en: '![apwp ep04](Images/apwp_ep04.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![apwp ep04](Images/apwp_ep04.png)'
- en: 'Figure E-2\. Before: strong, bidirectional coupling based on XML-RPC'
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图E-2。之前：基于XML-RPC的强大的双向耦合
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: to [Figure E-3](#strangler_after).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到[图E-3](#strangler_after)。
- en: '![apwp ep05](Images/apwp_ep05.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![apwp ep05](Images/apwp_ep05.png)'
- en: 'Figure E-3\. After: loose coupling with asynchronous events (you can find a
    high-resolution version of this diagram at cosmicpython.com)'
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图E-3。之后：与异步事件的松散耦合（您可以在cosmicpython.com找到此图的高分辨率版本）
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Practically, this was a several month-long project. Our first step was to write
    a domain model that could represent batches, shipments, and products. We used
    TDD to build a toy system that could answer a single question: “If I want N units
    of HAZARDOUS_RUG, how long will they take to be delivered?”'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这是一个长达几个月的项目。我们的第一步是编写一个可以表示批次、装运和产品的领域模型。我们使用TDD构建了一个玩具系统，可以回答一个问题：“如果我想要N个单位的HAZARDOUS_RUG，它们需要多长时间才能被交付？”
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: When deploying an event-driven system, start with a “walking skeleton.” Deploying
    a system that just logs its input forces us to tackle all the infrastructural
    questions and start working in production.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署事件驱动系统时，从“walking skeleton”开始。部署一个只记录其输入的系统迫使我们解决所有基础设施问题，并开始在生产中工作。
- en: Once we had a working domain model, we switched to building out some infrastructural
    pieces. Our first production deployment was a tiny system that could receive a
    `batch_created` event and log its JSON representation. This is the “Hello World”
    of event-driven architecture. It forced us to deploy a message bus, hook up a
    producer and consumer, build a deployment pipeline, and write a simple message
    handler.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了一个可行的领域模型，我们就转而构建一些基础设施。我们的第一个生产部署是一个可以接收`batch_created`事件并记录其JSON表示的小型系统。这是事件驱动架构的“Hello
    World”。它迫使我们部署消息总线，连接生产者和消费者，构建部署管道，并编写一个简单的消息处理程序。
- en: Given a deployment pipeline, the infrastructure we needed, and a basic domain
    model, we were off. A couple months later, we were in production and serving real
    customers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有了部署管道、我们需要的基础设施和一个基本的领域模型，我们就开始了。几个月后，我们投入生产并为真正的客户提供服务。
- en: Convincing Your Stakeholders to Try Something New
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 说服利益相关者尝试新事物
- en: If you’re thinking about carving a new system out of a big ball of mud, you’re
    probably suffering problems with reliability, performance, maintainability, or
    all three simultaneously. Deep, intractable problems call for drastic measures!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在考虑从一个庞大的泥球中切割出一个新系统，你可能正在遭受可靠性、性能、可维护性或三者同时出现的问题。深层次的、棘手的问题需要采取激烈的措施！
- en: We recommend *domain modeling* as a first step. In many overgrown systems, the
    engineers, product owners, and customers no longer speak the same language. Business
    stakeholders speak about the system in abstract, process-focused terms, while
    developers are forced to speak about the system as it physically exists in its
    wild and chaotic state.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议首先进行*领域建模*。在许多庞大的系统中，工程师、产品所有者和客户不再使用相同的语言交流。业务利益相关者用抽象的、流程为中心的术语谈论系统，而开发人员被迫谈论系统在其野生和混乱状态下的实际存在。
- en: Figuring out how to model your domain is a complex task that’s the subject of
    many decent books in its own right. We like to use interactive techniques like
    event storming and CRC modeling, because humans are good at collaborating through
    play. *Event modeling* is another technique that brings engineers and product
    owners together to understand a system in terms of commands, queries, and events.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 弄清楚如何对领域进行建模是一个复杂的任务，这是许多不错的书籍的主题。我们喜欢使用诸如事件风暴和CRC建模之类的互动技术，因为人类擅长通过玩耍来合作。*事件建模*是另一种技术，它将工程师和产品所有者聚集在一起，以命令、查询和事件的方式来理解系统。
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Check out *www.eventmodeling.org* and *www.eventstorming.org* for some great
    guides to visual modeling of systems with events.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 查看*www.eventmodeling.org*和*www.eventstorming.org*，了解一些关于使用事件进行系统可视化建模的很好的指南。
- en: The goal is to be able to talk about the system by using the same ubiquitous
    language, so that you can agree on where the complexity lies.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是能够通过使用相同的通用语言来谈论系统，这样你就可以就复杂性所在达成一致。
- en: We’ve found a lot of value in treating domain problems as TDD kata. For example,
    the first code we wrote for the availability service was the batch and order line
    model. You can treat this as a lunchtime workshop, or as a spike at the beginning
    of a project. Once you can demonstrate the value of modeling, it’s easier to make
    the argument for structuring the project to optimize for modeling.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现将领域问题视为TDD kata非常有价值。例如，我们为可用性服务编写的第一行代码是批处理和订单行模型。你可以将其视为午餐时间的研讨会，或者作为项目开始时的一个突发事件。一旦你能够证明建模的价值，就更容易为优化项目结构提出论点。
- en: Questions Our Tech Reviewers Asked That We Couldn’t Work into Prose
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的技术审阅者提出的问题，我们无法融入散文中
- en: 'Here are some questions we heard during drafting that we couldn’t find a good
    place to address elsewhere in the book:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在起草过程中听到的一些问题，我们无法在书中其他地方找到一个好地方来解决：
- en: Do I need to do all of this at once? Can I just do a bit at a time?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要一次做完所有这些吗？我可以一次只做一点吗？
- en: No, you can absolutely adopt these techniques bit by bit. If you have an existing
    system, we recommend building a service layer to try to keep orchestration in
    one place. Once you have that, it’s much easier to push logic into the model and
    push edge concerns like validation or error handling to the entrypoints.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不，你绝对可以逐步采用这些技术。如果你有一个现有的系统，我们建议建立一个服务层，试图将编排保持在一个地方。一旦你有了这个，将逻辑推入模型并将边缘关注点（如验证或错误处理）推入入口点就容易得多。
- en: It’s worth having a service layer even if you still have a big, messy Django
    ORM because it’s a way to start understanding the boundaries of operations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你仍然有一个庞大混乱的Django ORM，也值得拥有一个服务层，因为这是开始理解操作边界的一种方式。
- en: Extracting use cases will break a lot of my existing code; it’s too tangled
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 提取用例将破坏我现有的大量代码；它太混乱了
- en: Just copy and paste. It’s OK to cause more duplication in the short term. Think
    of this as a multistep process. Your code is in a bad state now, so copy and paste
    it to a new place and then make that new code clean and tidy.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 只需复制粘贴。在短期内造成更多的重复是可以的。把这看作一个多步过程。你的代码现在处于糟糕的状态，所以将其复制粘贴到一个新的地方，然后使新代码变得干净整洁。
- en: Once you’ve done that, you can replace uses of the old code with calls to your
    new code and finally delete the mess. Fixing large codebases is a messy and painful
    process. Don’t expect things to get instantly better, and don’t worry if some
    bits of your application stay messy.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你做到了这一点，你可以用新代码替换旧代码的使用，最终删除混乱。修复庞大的代码库是一个混乱而痛苦的过程。不要指望事情会立即变得更好，如果你的应用程序的某些部分保持混乱，也不要担心。
- en: Do I need to do CQRS? That sounds weird. Can’t I just use repositories?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要做CQRS吗？那听起来很奇怪。我不能只是使用存储库吗？
- en: Of course you can! The techniques we’re presenting in this book are intended
    to make your life *easier*. They’re not some kind of ascetic discipline with which
    to punish yourself.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当然可以！我们在这本书中提出的技术旨在让你的生活变得*更轻松*。它们不是一种用来惩罚自己的苦行修行。
- en: In our first case-study system, we had a lot of *View Builder* objects that
    used repositories to fetch data and then performed some transformations to return
    dumb read models. The advantage is that when you hit a performance problem, it’s
    easy to rewrite a view builder to use custom queries or raw SQL.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个案例研究系统中，我们有很多*视图构建器*对象，它们使用存储库来获取数据，然后执行一些转换以返回愚蠢的读取模型。优点是，当您遇到性能问题时，很容易重写视图构建器以使用自定义查询或原始SQL。
- en: How should use cases interact across a larger system? Is it a problem for one
    to call another?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 用例在一个更大的系统中如何交互？一个调用另一个会有问题吗？
- en: This might be an interim step. Again, in the first case study, we had handlers
    that would need to invoke other handlers. This gets *really* messy, though, and
    it’s much better to move to using a message bus to separate these concerns.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个临时步骤。同样，在第一个案例研究中，我们有一些处理程序需要调用其他处理程序。然而，这会变得非常混乱，最好的方法是使用消息总线来分离这些关注点。
- en: Generally, your system will have a single message bus implementation and a bunch
    of subdomains that center on a particular aggregate or set of aggregates. When
    your use case has finished, it can raise an event, and a handler elsewhere can
    run.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您的系统将有一个单一的消息总线实现和一堆以特定聚合或一组聚合为中心的子域。当您的用例完成时，它可以引发一个事件，然后其他地方的处理程序可以运行。
- en: Is it a code smell for a use case to use multiple repositories/aggregates, and
    if so, why?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个用例使用多个存储库/聚合，这是一种代码异味吗？如果是，为什么？
- en: An aggregate is a consistency boundary, so if your use case needs to update
    two aggregates atomically (within the same transaction), then your consistency
    boundary is wrong, strictly speaking. Ideally you should think about moving to
    a new aggregate that wraps up all the things you want to change at the same time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合是一致性边界，所以如果你的用例需要在同一个事务中原子地更新两个聚合，那么严格来说你的一致性边界是错误的。理想情况下，你应该考虑将其移动到一个新的聚合中，该聚合将同时更改所有你想要更改的内容。
- en: If you’re actually updating only one aggregate and using the other(s) for read-only
    access, then that’s *fine*, although you could consider building a read/view model
    to get you that data instead—it makes things cleaner if each use case has only
    one aggregate.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您实际上只更新一个聚合并使用其他聚合进行只读访问，那么这是可以的，尽管您可以考虑构建一个读取/视图模型来获取这些数据——如果每个用例只有一个聚合，这样做会使事情变得更清晰。
- en: If you do need to modify two aggregates, but the two operations don’t have to
    be in the same transaction/UoW, then consider splitting the work out into two
    different handlers and using a domain event to carry information between the two.
    You can read more in [these papers on aggregate design](https://oreil.ly/sufKE)
    by Vaughn Vernon.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实需要修改两个聚合，但这两个操作不必在同一个事务/UoW中，那么考虑将工作拆分成两个不同的处理程序，并使用领域事件在两者之间传递信息。您可以在[Vaughn
    Vernon的这些聚合设计论文](https://oreil.ly/sufKE)中阅读更多内容。
- en: What if I have a read-only but business-logic-heavy system?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我有一个只读但业务逻辑复杂的系统呢？
- en: View models can have complex logic in them. In this book, we’ve encouraged you
    to separate your read and write models because they have different consistency
    and throughput requirements. Mostly, we can use simpler logic for reads, but that’s
    not always true. In particular, permissions and authorization models can add a
    lot of complexity to our read side.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型中可能包含复杂的逻辑。在本书中，我们鼓励您将读取模型和写入模型分开，因为它们具有不同的一致性和吞吐量要求。大多数情况下，我们可以对读取使用更简单的逻辑，但并非总是如此。特别是，权限和授权模型可能会给我们的读取端增加很多复杂性。
- en: We’ve written systems in which the view models needed extensive unit tests.
    In those systems, we split a *view builder* from a *view fetcher*, as in [Figure E-4](#view_builder_diagram).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了需要进行广泛单元测试的视图模型的系统。在这些系统中，我们将*视图构建器*与*视图获取器*分开，如[图E-4](#view_builder_diagram)所示。
- en: '![apwp ep06](Images/apwp_ep06.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![apwp ep06](Images/apwp_ep06.png)'
- en: Figure E-4\. A view builder and view fetcher (you can find a high-resolution
    version of this diagram at cosmicpython.com)
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图E-4. 视图构建器和视图获取器（您可以在cosmicpython.com找到此图的高分辨率版本）
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: + This makes it easy to test the view builder by giving it mocked data (e.g.,
    a list of dicts). “Fancy CQRS” with event handlers is really a way of running
    our complex view logic whenever we write so that we can avoid running it when
    we read.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: + 这使得通过提供模拟数据（例如，字典列表）来测试视图构建器变得很容易。“Fancy CQRS”与事件处理程序实际上是一种在写入时运行我们复杂的视图逻辑的方法，以便我们在读取时避免运行它。
- en: Do I need to build microservices to do this stuff?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要构建微服务来做这些事情吗？
- en: Egads, no! These techniques predate microservices by a decade or so. Aggregates,
    domain events, and dependency inversion are ways to control complexity in large
    systems. It just so happens that when you’ve built a set of use cases and a model
    for a business process, moving it to its own service is relatively easy, but that’s
    not a requirement.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 天哪，不！这些技术早在十年前就出现了微服务。聚合、领域事件和依赖反转是控制大型系统复杂性的方法。恰好当您构建了一组用例和业务流程模型时，将其移动到自己的服务相对容易，但这并不是必需的。
- en: I’m using Django. Can I still do this?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用Django。我还能做到这一点吗？
- en: 'We have an entire appendix just for you: [Appendix D](app04.xhtml#appendix_django)!'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为您准备了整个附录：[附录D](app04.xhtml#appendix_django)!
- en: Footguns
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚枪
- en: OK, so we’ve given you a whole bunch of new toys to play with. Here’s the fine
    print. Harry and Bob do not recommend that you copy and paste our code into a
    production system and rebuild your automated trading platform on Redis pub/sub.
    For reasons of brevity and simplicity, we’ve hand-waved a lot of tricky subjects.
    Here’s a list of things we think you should know before trying this for real.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们给了你一堆新玩具来玩。这是详细说明。Harry和Bob不建议您将我们的代码复制粘贴到生产系统中，并在Redis pub/sub上重建您的自动交易平台。出于简洁和简单起见，我们对许多棘手的主题进行了手波。在尝试这个之前，这是我们认为您应该知道的一些事情的清单。
- en: Reliable messaging is hard
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠的消息传递很困难
- en: Redis pub/sub is not reliable and shouldn’t be used as a general-purpose messaging
    tool. We picked it because it’s familiar and easy to run. At MADE, we run Event
    Store as our messaging tool, but we’ve had experience with RabbitMQ and Amazon
    EventBridge.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Redis pub/sub不可靠，不应作为通用消息工具使用。我们选择它是因为它熟悉且易于运行。在MADE，我们将Event Store作为我们的消息工具，但我们也有RabbitMQ和Amazon
    EventBridge的经验。
- en: 'Tyler Treat has some excellent blog posts on his site *bravenewgeek.com*; you
    should read at least read [“You Cannot Have Exactly-Once Delivery”](https://oreil.ly/pcstD)
    and [“What You Want Is What You Don’t: Understanding Trade-Offs in Distributed
    Messaging”](https://oreil.ly/j8bmF).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Tyler Treat在他的网站*bravenewgeek.com*上有一些优秀的博客文章；您至少应该阅读[“您无法实现精确一次交付”](https://oreil.ly/pcstD)和[“您想要的是您不想要的：理解分布式消息传递中的权衡”](https://oreil.ly/j8bmF)。
- en: We explicitly choose small, focused transactions that can fail independently
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们明确选择了可以独立失败的小型、专注的交易
- en: In [Chapter 8](ch08.xhtml#chapter_08_events_and_message_bus), we update our
    process so that *deallocating* an order line and *reallocating* the line happen
    in two separate units of work. You will need monitoring to know when these transactions
    fail, and tooling to replay events. Some of this is made easier by using a transaction
    log as your message broker (e.g., Kafka or EventStore). You might also look at
    the [Outbox pattern](https://oreil.ly/sLfnp).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.xhtml#chapter_08_events_and_message_bus)中，我们更新了我们的流程，以便*释放*订单行和*重新分配*行发生在两个单独的工作单元中。您将需要监控以了解这些事务失败的时间，并使用工具重放事件。使用交易日志作为您的消息代理（例如Kafka或EventStore）可以使其中一些变得更容易。您还可以查看[Outbox模式](https://oreil.ly/sLfnp)。
- en: We don’t discuss idempotency
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有讨论幂等性
- en: We haven’t given any real thought to what happens when handlers are retried.
    In practice you will want to make handlers idempotent so that calling them repeatedly
    with the same message will not make repeated changes to state. This is a key technique
    for building reliability, because it enables us to safely retry events when they
    fail.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有认真考虑处理程序重试时会发生什么。在实践中，您将希望使处理程序幂等，这样重复调用它们不会对状态进行重复更改。这是构建可靠性的关键技术，因为它使我们能够在事件失败时安全地重试事件。
- en: There’s a lot of good material on idempotent message handling, try starting
    with [“How to Ensure Idempotency in an Eventual Consistent DDD/CQRS Application”](https://oreil.ly/yERzR)
    and [“(Un)Reliability in Messaging”](https://oreil.ly/Ekuhi).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 关于幂等消息处理有很多好的材料，可以从[“如何确保在最终一致的DDD/CQRS应用程序中的幂等性”](https://oreil.ly/yERzR)和[“消息传递中的（不）可靠性”](https://oreil.ly/Ekuhi)开始阅读。
- en: Your events will need to change their schema over time
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您的事件将需要随时间改变其模式
- en: 'You’ll need to find some way of documenting your events and sharing schema
    with consumers. We like using JSON schema and markdown because it’s simple but
    there is other prior art. Greg Young wrote an entire book on managing event-driven
    systems over time: *Versioning in an Event Sourced System* (Leanpub).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要找到一种方式来记录您的事件并与消费者共享模式。我们喜欢使用JSON模式和markdown，因为它简单易懂，但也有其他先前的技术。Greg Young写了一整本关于随时间管理事件驱动系统的书籍：*事件驱动系统中的版本控制*（Leanpub）。
- en: More Required Reading
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多必读书籍
- en: 'A few more books we’d like to recommend to help you on your way:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想推荐一些书籍，以帮助您更好地理解：
- en: '*Clean Architectures in Python* by Leonardo Giordani (Leanpub), which came
    out in 2019, is one of the few previous books on application architecture in Python.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Leonardo Giordani（Leanpub）在2019年出版的《Python中的干净架构》是Python应用架构的少数几本先前的书籍之一。
- en: '*Enterprise Integration Patterns* by Gregor Hohpe and Bobby Woolf (Addison-Wesley
    Professional) is a pretty good start for messaging patterns.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gregor Hohpe和Bobby Woolf（Addison-Wesley Professional）的*企业集成模式*是消息模式的一个很好的起点。
- en: '*Monolith to Microservices* by Sam Newman (O’Reilly), and Newman’s first book,
    *Building Microservices* (O’Reilly). The Strangler Fig pattern is mentioned as
    a favorite, along with many others. These are good to check out if you’re thinking
    of moving to microservices, and they’re also good on integration patterns and
    the considerations of async messaging-based integration.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sam Newman的*从单体到微服务*（O'Reilly）和Newman的第一本书*构建微服务*（O'Reilly）。Strangler Fig模式被提及为一个喜欢的模式，还有许多其他模式。如果您正在考虑转向微服务，这些都是值得一看的，它们也对集成模式和异步消息传递的考虑非常有帮助。
- en: Wrap-Up
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Phew! That’s a lot of warnings and reading suggestions; we hope we haven’t scared
    you off completely. Our goal with this book is to give you just enough knowledge
    and intuition for you to start building some of this for yourself. We would love
    to hear how you get on and what problems you’re facing with the techniques in
    your own systems, so why not get in touch with us over at *www.cosmicpython.com*?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这是很多警告和阅读建议；我们希望我们没有完全吓到您。我们撰写本书的目标是为您提供足够的知识和直觉，让您能够开始为自己构建一些东西。我们很乐意听听您的进展以及您在自己系统中使用这些技术时遇到的问题，所以为什么不通过*www.cosmicpython.com*与我们联系呢？

- en: Appendix B. A Template Project Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Around [Chapter 4](ch04.xhtml#chapter_04_service_layer), we moved from just
    having everything in one folder to a more structured tree, and we thought it might
    be of interest to outline the moving parts.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The code for this appendix is in the appendix_project_structure branch [on
    GitHub](https://oreil.ly/1rDRC):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The basic folder structure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Project tree*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_a_template_project_structure_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Our *docker-compose.yml* and our *Dockerfile* are the main bits of configuration
    for the containers that run our app, and they can also run the tests (for CI).
    A more complex project might have several Dockerfiles, although we’ve found that
    minimizing the number of images is usually a good idea.^([1](app02.xhtml#idm45714878530264))
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_a_template_project_structure_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *Makefile* provides the entrypoint for all the typical commands a developer
    (or a CI server) might want to run during their normal workflow: `make build`,
    `make test`, and so on.^([2](app02.xhtml#idm45714878525288)) This is optional.
    You could just use `docker-compose` and `pytest` directly, but if nothing else,
    it’s nice to have all the “common commands” in a list somewhere, and unlike documentation,
    a Makefile is code so it has less tendency to become out of date.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_a_template_project_structure_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: All the source code for our app, including the domain model, the Flask app,
    and infrastructure code, lives in a Python package inside *src*,^([3](app02.xhtml#idm45714878490136))
    which we install using `pip install -e` and the *setup.py* file. This makes imports
    easy. Currently, the structure within this module is totally flat, but for a more
    complex project, you’d expect to grow a folder hierarchy that includes *domain_model/*,
    *infrastructure/*, *services/*, and *api/*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_a_template_project_structure_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Tests live in their own folder. Subfolders distinguish different test types
    and allow you to run them separately. We can keep shared fixtures (*conftest.py*)
    in the main tests folder and nest more specific ones if we wish. This is also
    the place to keep *pytest.ini*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The [pytest docs](https://oreil.ly/QVb9Q) are really good on test layout and
    importability.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a few of these files and concepts in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Env Vars, 12-Factor, and Config, Inside and Outside Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic problem we’re trying to solve here is that we need different config
    settings for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Running code or tests directly from your own dev machine, perhaps talking to
    mapped ports from Docker containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running on the containers themselves, with “real” ports and hostnames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different container environments (dev, staging, prod, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration through environment variables as suggested by the [12-factor manifesto](https://12factor.net/config)
    will solve this problem, but concretely, how do we implement it in our code and
    our containers?
  prefs: []
  type: TYPE_NORMAL
- en: Config.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever our application code needs access to some config, it’s going to get
    it from a file called *config.py*. Here are a couple of examples from our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Sample config functions (src/allocation/config.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_a_template_project_structure_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use functions for getting the current config, rather than constants available
    at import time, because that allows client code to modify `os.environ` if it needs
    to.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_a_template_project_structure_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '*config.py* also defines some default settings, designed to work when running
    the code from the developer’s local machine.^([4](app02.xhtml#idm45714878393496))'
  prefs: []
  type: TYPE_NORMAL
- en: An elegant Python package called [*environ-config*](https://github.com/hynek/environ-config)
    is worth looking at if you get tired of hand-rolling your own environment-based
    config functions.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Don’t let this config module become a dumping ground that is full of things
    only vaguely related to config and that is then imported all over the place. Keep
    things immutable and modify them only via environment variables. If you decide
    to use a [bootstrap script](ch13.xhtml#chapter_13_dependency_injection), you can
    make it the only place (other than tests) that config is imported to.
  prefs: []
  type: TYPE_NORMAL
- en: Docker-Compose and Containers Config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use a lightweight Docker container orchestration tool called *docker-compose*.
    It’s main configuration is via a YAML file (sigh):^([5](app02.xhtml#idm45714878387176))
  prefs: []
  type: TYPE_NORMAL
- en: '*docker-compose config file (docker-compose.yml)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_a_template_project_structure_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: In the *docker-compose* file, we define the different *services* (containers)
    that we need for our app. Usually one main image contains all our code, and we
    can use it to run our API, our tests, or any other service that needs access to
    the domain model.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_a_template_project_structure_CO3-7)'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll probably have other infrastructure services, including a database. In
    production you might not use containers for this; you might have a cloud provider
    instead, but *docker-compose* gives us a way of producing a similar service for
    dev or CI.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_a_template_project_structure_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `environment` stanza lets you set the environment variables for your containers,
    the hostnames and ports as seen from inside the Docker cluster. If you have enough
    containers that information starts to be duplicated in these sections, you can
    use `environment_file` instead. We usually call ours *container.env*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_a_template_project_structure_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Inside a cluster, *docker-compose* sets up networking such that containers are
    available to each other via hostnames named after their service name.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_a_template_project_structure_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pro tip: if you’re mounting volumes to share source folders between your local
    dev machine and the container, the `PYTHONDONTWRITEBYTECODE` environment variable
    tells Python to not write *.pyc* files, and that will save you from having millions
    of root-owned files sprinkled all over your local filesystem, being all annoying
    to delete and causing weird Python compiler errors besides.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_a_template_project_structure_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Mounting our source and test code as `volumes` means we don’t need to rebuild
    our containers every time we make a code change.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_a_template_project_structure_CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The `ports` section allows us to expose the ports from inside the containers
    to the outside world^([6](app02.xhtml#idm45714878116600))—these correspond to
    the default ports we set in *config.py*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Inside Docker, other containers are available through hostnames named after
    their service name. Outside Docker, they are available on `localhost`, at the
    port defined in the `ports` section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Your Source as a Package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All our application code (everything except tests, really) lives inside an
    *src* folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The src folder*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_a_template_project_structure_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Subfolders define top-level module names. You can have multiple if you like.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_a_template_project_structure_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: And *setup.py* is the file you need to make it pip-installable, shown next.
  prefs: []
  type: TYPE_NORMAL
- en: '*pip-installable modules in three lines (src/setup.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That’s all you need. `packages=` specifies the names of subfolders that you
    want to install as top-level modules. The `name` entry is just cosmetic, but it’s
    required. For a package that’s never actually going to hit PyPI, it’ll do fine.^([7](app02.xhtml#idm45714878054648))
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dockerfiles are going to be very project-specific, but here are a few key stages
    you’ll expect to see:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Our Dockerfile (Dockerfile)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_a_template_project_structure_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Installing system-level dependencies
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_a_template_project_structure_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Installing our Python dependencies (you may want to split out your dev from
    prod dependencies; we haven’t here, for simplicity)
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_a_template_project_structure_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Copying and installing our source
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_a_template_project_structure_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Optionally configuring a default startup command (you’ll probably override this
    a lot from the command line)
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: One thing to note is that we install things in the order of how frequently they
    are likely to change. This allows us to maximize Docker build cache reuse. I can’t
    tell you how much pain and frustration underlies this lesson. For this and many
    more Python Dockerfile improvement tips, check out [“Production-Ready Docker Packaging”](https://pythonspeed.com/docker).
  prefs: []
  type: TYPE_NORMAL
- en: Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our tests are kept alongside everything else, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Tests folder tree*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Nothing particularly clever here, just some separation of different test types
    that you’re likely to want to run separately, and some files for common fixtures,
    config, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There’s no *src* folder or *setup.py* in the test folders because we usually
    haven’t needed to make tests pip-installable, but if you have difficulties with
    import paths, you might find it helps.
  prefs: []
  type: TYPE_NORMAL
- en: Wrap-Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are our basic building blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: Source code in an *src* folder, pip-installable using *setup.py*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some Docker config for spinning up a local cluster that mirrors production as
    far as possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration via environment variables, centralized in a Python file called
    *config.py*, with defaults allowing things to run *outside* containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Makefile for useful command-line, um, commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We doubt that anyone will end up with *exactly* the same solutions we did, but
    we hope you find some inspiration here.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](app02.xhtml#idm45714878530264-marker)) Splitting out images for production
    and testing is sometimes a good idea, but we’ve tended to find that going further
    and trying to split out different images for different types of application code
    (e.g., Web API versus pub/sub client) usually ends up being more trouble than
    it’s worth; the cost in terms of complexity and longer rebuild/CI times is too
    high. YMMV.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](app02.xhtml#idm45714878525288-marker)) A pure-Python alternative to Makefiles
    is [Invoke](http://www.pyinvoke.org), worth checking out if everyone on your team
    knows Python (or at least knows it better than Bash!).
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](app02.xhtml#idm45714878490136-marker)) [“Testing and Packaging”](https://hynek.me/articles/testing-packaging)
    by Hynek Schlawack provides more information on *src* folders.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](app02.xhtml#idm45714878393496-marker)) This gives us a local development
    setup that “just works” (as much as possible). You may prefer to fail hard on
    missing environment variables instead, particularly if any of the defaults would
    be insecure in production.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](app02.xhtml#idm45714878387176-marker)) Harry is a bit YAML-weary. It’s
    *everywhere*, and yet he can never remember the syntax or how it’s supposed to
    indent.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](app02.xhtml#idm45714878116600-marker)) On a CI server, you may not be
    able to expose arbitrary ports reliably, but it’s only a convenience for local
    dev. You can find ways of making these port mappings optional (e.g., with *docker-compose.override.yml*).
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](app02.xhtml#idm45714878054648-marker)) For more *setup.py* tips, see [this
    article on packaging](https://oreil.ly/KMWDz) by Hynek.
  prefs: []
  type: TYPE_NORMAL

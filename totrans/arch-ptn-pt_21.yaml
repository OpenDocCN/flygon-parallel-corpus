- en: Appendix D. Repository and Unit of Work Patterns with Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose you wanted to use Django instead of SQLAlchemy and Flask. How might
    things look? The first thing is to choose where to install it. We put it in a
    separate package next to our main allocation code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE0]*  *###### Tip'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this appendix is in the appendix_django branch [on GitHub](https://oreil.ly/A-I76):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Repository Pattern with Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used a plug-in called [`pytest-django`](https://github.com/pytest-dev/pytest-django)
    to help with test database management.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rewriting the first repository test was a minimal change—just rewriting some
    raw SQL with a call to the Django ORM/QuerySet language:'
  prefs: []
  type: TYPE_NORMAL
- en: '*First repository test adapted (tests/integration/test_repository.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The second test is a bit more involved since it has allocations, but it is
    still made up of familiar-looking Django code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Second repository test is more involved (tests/integration/test_repository.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how the actual repository ends up looking:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A Django repository (src/allocation/adapters/repository.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the implementation relies on the Django models having some
    custom methods for translating to and from our domain model.^([1](app04.xhtml#idm45714875556456))
  prefs: []
  type: TYPE_NORMAL
- en: Custom Methods on Django ORM Classes to Translate to/from Our Domain Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Those custom methods look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Django ORM with custom methods for domain model conversion (src/djangoproject/alloc/models.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_repository_and_unit_of_work__span_class__keep_together__patterns_with_django__span__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: For value objects, `objects.get_or_create` can work, but for entities, you probably
    need an explicit try-get/except to handle the upsert.^([2](app04.xhtml#idm45714875265208))
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_repository_and_unit_of_work__span_class__keep_together__patterns_with_django__span__CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve shown the most complex example here. If you do decide to do this, be aware
    that there will be boilerplate! Thankfully it’s not very complex boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_repository_and_unit_of_work__span_class__keep_together__patterns_with_django__span__CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Relationships also need some careful, custom handling.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As in [Chapter 2](ch02.xhtml#chapter_02_repository), we use dependency inversion.
    The ORM (Django) depends on the model and not the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: Unit of Work Pattern with Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The tests don’t change too much:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Adapted UoW tests (tests/integration/test_uow.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_repository_and_unit_of_work__span_class__keep_together__patterns_with_django__span__CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Because we had little helper functions in these tests, the actual main bodies
    of the tests are pretty much the same as they were with SQLAlchemy.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_repository_and_unit_of_work__span_class__keep_together__patterns_with_django__span__CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `pytest-django` `mark.django_db(transaction=True)` is required to test our
    custom transaction/rollback behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'And the implementation is quite simple, although it took me a few tries to
    find which invocation of Django’s transaction magic would work:'
  prefs: []
  type: TYPE_NORMAL
- en: '*UoW adapted for Django (src/allocation/service_layer/unit_of_work.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_repository_and_unit_of_work__span_class__keep_together__patterns_with_django__span__CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`set_autocommit(False)` was the best way to tell Django to stop automatically
    committing each ORM operation immediately, and to begin a transaction.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_repository_and_unit_of_work__span_class__keep_together__patterns_with_django__span__CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Then we use the explicit rollback and commits.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_repository_and_unit_of_work__span_class__keep_together__patterns_with_django__span__CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'One difficulty: because, unlike with SQLAlchemy, we’re not instrumenting the
    domain model instances themselves, the `commit()` command needs to explicitly
    go through all the objects that have been touched by every repository and manually
    update them back to the ORM.'
  prefs: []
  type: TYPE_NORMAL
- en: 'API: Django Views Are Adapters'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Django *views.py* file ends up being almost identical to the old *flask_app.py*,
    because our architecture means it’s a very thin wrapper around our service layer
    (which didn’t change at all, by the way):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Flask app → Django views (src/djangoproject/alloc/views.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Why Was This All So Hard?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OK, it works, but it does feel like more effort than Flask/SQLAlchemy. Why is
    that?
  prefs: []
  type: TYPE_NORMAL
- en: The main reason at a low level is because Django’s ORM doesn’t work in the same
    way. We don’t have an equivalent of the SQLAlchemy classical mapper, so our `ActiveRecord`
    and our domain model can’t be the same object. Instead we have to build a manual
    translation layer behind the repository. That’s more work (although once it’s
    done, the ongoing maintenance burden shouldn’t be too high).
  prefs: []
  type: TYPE_NORMAL
- en: Because Django is so tightly coupled to the database, you have to use helpers
    like `pytest-django` and think carefully about test databases, right from the
    very first line of code, in a way that we didn’t have to when we started out with
    our pure domain model.
  prefs: []
  type: TYPE_NORMAL
- en: But at a higher level, the entire reason that Django is so great is that it’s
    designed around the sweet spot of making it easy to build CRUD apps with minimal
    boilerplate. But the entire thrust of our book is about what to do when your app
    is no longer a simple CRUD app.
  prefs: []
  type: TYPE_NORMAL
- en: At that point, Django starts hindering more than it helps. Things like the Django
    admin, which are so awesome when you start out, become actively dangerous if the
    whole point of your app is to build a complex set of rules and modeling around
    the workflow of state changes. The Django admin bypasses all of that.
  prefs: []
  type: TYPE_NORMAL
- en: What to Do If You Already Have Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So what should you do if you want to apply some of the patterns in this book
    to a Django app? We’d say the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Repository and Unit of Work patterns are going to be quite a lot of work.
    The main thing they will buy you in the short term is faster unit tests, so evaluate
    whether that benefit feels worth it in your case. In the longer term, they decouple
    your app from Django and the database, so if you anticipate wanting to migrate
    away from either of those, Repository and UoW are a good idea.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Service Layer pattern might be of interest if you’re seeing a lot of duplication
    in your *views.py*. It can be a good way of thinking about your use cases separately
    from your web endpoints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can still theoretically do DDD and domain modeling with Django models,
    tightly coupled as they are to the database; you may be slowed by migrations,
    but it shouldn’t be fatal. So as long as your app is not too complex and your
    tests not too slow, you may be able to get something out of the *fat models* approach:
    push as much logic down to your models as possible, and apply patterns like Entity,
    Value Object, and Aggregate. However, see the following caveat.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that said, [word in the Django community](https://oreil.ly/Nbpjj) is that
    people find that the fat models approach runs into scalability problems of its
    own, particularly around managing interdependencies between apps. In those cases,
    there’s a lot to be said for extracting out a business logic or domain layer to
    sit between your views and forms and your *models.py*, which you can then keep
    as minimal as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Steps Along the Way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose you’re working on a Django project that you’re not sure is going to
    get complex enough to warrant the patterns we recommend, but you still want to
    put a few steps in place to make your life easier, both in the medium term and
    if you want to migrate to some of our patterns later. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: One piece of advice we’ve heard is to put a *logic.py* into every Django app
    from day one. This gives you a place to put business logic, and to keep your forms,
    views, and models free of business logic. It can become a stepping-stone for moving
    to a fully decoupled domain model and/or service layer later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A business-logic layer might start out working with Django model objects and
    only later become fully decoupled from the framework and work on plain Python
    data structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the read side, you can get some of the benefits of CQRS by putting reads
    into one place, avoiding ORM calls sprinkled all over the place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When separating out modules for reads and modules for domain logic, it may be
    worth decoupling yourself from the Django apps hierarchy. Business concerns will
    cut across them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We’d like to give a shout-out to David Seddon and Ashia Zawaduk for talking
    through some of the ideas in this appendix. They did their best to stop us from
    saying anything really stupid about a topic we don’t really have enough personal
    experience of, but they may have failed.
  prefs: []
  type: TYPE_NORMAL
- en: For more thoughts and actual lived experience dealing with existing applications,
    refer to the [epilogue](afterword01.xhtml#epilogue_1_how_to_get_there_from_here).
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](app04.xhtml#idm45714875556456-marker)) The DRY-Python project people have
    built a tool called [mappers](https://mappers.readthedocs.io/en/latest) that looks
    like it might help minimize boilerplate for this sort of thing.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](app04.xhtml#idm45714875265208-marker)) `@mr-bo-jangles` suggested you
    might be able to use [`update_or_create`](https://oreil.ly/HTq1r), but that’s
    beyond our Django-fu.*
  prefs: []
  type: TYPE_NORMAL

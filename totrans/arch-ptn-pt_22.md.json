["```py\nfromschemaimportAnd,Schema,Use@dataclassclassAllocate(Command):_schema=Schema({![1](Images/1.png)'orderid':int,sku:str,qty:And(Use(int),lambdan:n>0)},ignore_extra_keys=True)orderid:strsku:strqty:int@classmethoddeffrom_json(cls,data):![2](Images/2.png)data=json.loads(data)returncls(**_schema.validate(data))\n```", "```py\ndefcommand(name,**fields):![1](Images/1.png)schema=Schema(And(Use(json.loads),fields),ignore_extra_keys=True)![2](Images/2.png)cls=make_dataclass(name,fields.keys())cls.from_json=lambdas:cls(**schema.validate(s))![3](Images/3.png)returnclsdefgreater_than_zero(x):returnx>0quantity=And(Use(int),greater_than_zero)![4](Images/4.png)Allocate=command(![5](Images/5.png)orderid=int,sku=str,qty=quantity)AddStock=command(sku=str,qty=quantity\n```", "```py\nclass MessageBus:\n\n    def handle_message(self, name: str, body: str):\n        try:\n            message_type = next(mt for mt in EVENT_HANDLERS if mt.__name__ == name)\n            message = message_type.from_json(body)\n            self.handle([message])\n        except StopIteration:\n            raise KeyError(f\"Unknown message name {name}\")\n        except ValidationError as e:\n            logging.error(\n                f'invalid message of type {name}\\n'\n                f'{body}\\n'\n                f'{e}'\n            )\n            raise e\n```", "```py\n@app.route(\"/change_quantity\", methods=['POST'])\ndef change_batch_quantity():\n    try:\n        bus.handle_message('ChangeBatchQuantity', request.body)\n    except ValidationError as e:\n        return bad_request(e)\n    except exceptions.InvalidSku as e:\n        return jsonify({'message': str(e)}), 400\n\ndef bad_request(e: ValidationError):\n    return e.code, 400\n```", "```py\ndef handle_change_batch_quantity(m, bus: messagebus.MessageBus):\n    try:\n        bus.handle_message('ChangeBatchQuantity', m)\n    except ValidationError:\n       print('Skipping invalid message')\n    except exceptions.InvalidSku as e:\n        print(f'Unable to change stock for missing sku {e}')\n```", "```py\n{\n  \"orderid\": \"superman\",\n  \"sku\": \"zygote\",\n  \"qty\": -1\n}\n```", "```py\n\"\"\"\nThis module contains preconditions that we apply to our handlers.\n\"\"\"classMessageUnprocessable(Exception):![1](Images/1.png)def__init__(self,message):self.message=messageclassProductNotFound(MessageUnprocessable):![2](Images/2.png)\"\"\"\"\n   This exception is raised when we try to perform an action on a product\n   that doesn't exist in our database.\n   \"\"\"\"def__init__(self,message):super().__init__(message)self.sku=message.skudefproduct_exists(event,uow):![3](Images/3.png)product=uow.products.get(event.sku)ifproductisNone:raiseProductNotFound(event)\n```", "```py\n# services.py\n\nfrom allocation import ensure\n\ndef allocate(event, uow):\n    line = mode.OrderLine(event.orderid, event.sku, event.qty)\n    with uow:\n        ensure.product_exists(uow, event)\n\n        product = uow.products.get(line.sku)\n        product.allocate(line)\n        uow.commit()\n```", "```py\nclass SkipMessage (Exception):\n    \"\"\"\"\n This exception is raised when a message can't be processed, but there's no\n incorrect behavior. For example, we might receive the same message multiple\n times, or we might receive a message that is now out of date.\n \"\"\"\"\n\n    def __init__(self, reason):\n        self.reason = reason\n\ndef batch_is_new(self, event, uow):\n    batch = uow.batches.get(event.batchid)\n    if batch is not None:\n        raise SkipMessage(f\"Batch with id {event.batchid} already exists\")\n```", "```py\nclass MessageBus:\n\n    def handle_message(self, message):\n        try:\n           ...\n       except SkipMessage as e:\n           logging.warn(f\"Skipping message {message.id} because {e.reason}\")\n```"]
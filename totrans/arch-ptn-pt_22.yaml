- en: Appendix E. Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we’re teaching and talking about these techniques, one question that
    comes up over and over is “Where should I do validation? Does that belong with
    my business logic in the domain model, or is that an infrastructural concern?”
  prefs: []
  type: TYPE_NORMAL
- en: 'As with any architectural question, the answer is: it depends!'
  prefs: []
  type: TYPE_NORMAL
- en: The most important consideration is that we want to keep our code well separated
    so that each part of the system is simple. We don’t want to clutter our code with
    irrelevant detail.
  prefs: []
  type: TYPE_NORMAL
- en: What Is Validation, Anyway?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When people use the word *validation*, they usually mean a process whereby they
    test the inputs of an operation to make sure that they match certain criteria.
    Inputs that match the criteria are considered *valid*, and inputs that don’t are
    *invalid*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the input is invalid, the operation can’t continue but should exit with
    some kind of error. In other words, validation is about creating *preconditions*.
    We find it useful to separate our preconditions into three subtypes: syntax, semantics,
    and pragmatics.'
  prefs: []
  type: TYPE_NORMAL
- en: Validating Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In linguistics, the *syntax* of a language is the set of rules that govern the
    structure of grammatical sentences. For example, in English, the sentence “Allocate
    three units of `TASTELESS-LAMP` to order twenty-seven” is grammatically sound,
    while the phrase “hat hat hat hat hat hat wibble” is not. We can describe grammatically
    correct sentences as *well formed*.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does this map to our application? Here are some examples of syntactic rules:'
  prefs: []
  type: TYPE_NORMAL
- en: An `Allocate` command must have an order ID, a SKU, and a quantity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quantity is a positive integer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A SKU is a string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are rules about the shape and structure of incoming data. An `Allocate`
    command without a SKU or an order ID isn’t a valid message. It’s the equivalent
    of the phrase “Allocate three to.”
  prefs: []
  type: TYPE_NORMAL
- en: We tend to validate these rules at the edge of the system. Our rule of thumb
    is that a message handler should always receive only a message that is well-formed
    and contains all required information.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to put your validation logic on the message type itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Validation on the message class (src/allocation/commands.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_validation_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The [`schema` library](https://pypi.org/project/schema) lets us describe the
    structure and validation of our messages in a nice declarative way.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_validation_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `from_json` method reads a string as JSON and turns it into our message
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can get repetitive, though, since we need to specify our fields twice,
    so we might want to introduce a helper library that can unify the validation and
    declaration of our message types:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A command factory with schema (src/allocation/commands.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_validation_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `command` function takes a message name, plus kwargs for the fields of the
    message payload, where the name of the kwarg is the name of the field and the
    value is the parser.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_validation_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `make_dataclass` function from the dataclass module to dynamically
    create our message type.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_validation_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We patch the `from_json` method onto our dynamic dataclass.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_validation_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We can create reusable parsers for quantity, SKU, and so on to keep things DRY.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_validation_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a message type becomes a one-liner.
  prefs: []
  type: TYPE_NORMAL
- en: This comes at the expense of losing the types on your dataclass, so bear that
    trade-off in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Postel’s Law and the Tolerant Reader Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Postel’s law*, or the *robustness principle*, tells us, “Be liberal in what
    you accept, and conservative in what you emit.” We think this applies particularly
    well in the context of integration with our other systems. The idea here is that
    we should be strict whenever we’re sending messages to other systems, but as lenient
    as possible when we’re receiving messages from others.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, our system *could* validate the format of a SKU. We’ve been using
    made-up SKUs like `UNFORGIVING-CUSHION` and `MISBEGOTTEN-POUFFE`. These follow
    a simple pattern: two words, separated by dashes, where the second word is the
    type of product and the first word is an adjective.'
  prefs: []
  type: TYPE_NORMAL
- en: Developers *love* to validate this kind of thing in their messages, and reject
    anything that looks like an invalid SKU. This causes horrible problems down the
    line when some anarchist releases a product named `COMFY-CHAISE-LONGUE` or when
    a snafu at the supplier results in a shipment of `CHEAP-CARPET-2`.
  prefs: []
  type: TYPE_NORMAL
- en: Really, as the allocation system, it’s *none of our business* what the format
    of a SKU might be. All we need is an identifier, so we can simply describe it
    as a string. This means that the procurement system can change the format whenever
    they like, and we won’t care.
  prefs: []
  type: TYPE_NORMAL
- en: This same principle applies to order numbers, customer phone numbers, and much
    more. For the most part, we can ignore the internal structure of strings.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, developers *love* to validate incoming messages with tools like JSON
    Schema, or to build libraries that validate incoming messages and share them among
    systems. This likewise fails the robustness test.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine, for example, that the procurement system adds new fields to the
    `ChangeBatchQuantity` message that record the reason for the change and the email
    of the user responsible for the change.
  prefs: []
  type: TYPE_NORMAL
- en: Since these fields don’t matter to the allocation service, we should simply
    ignore them. We can do that in the `schema` library by passing the keyword arg
    `ignore_extra_keys=True`.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern, whereby we extract only the fields we care about and do minimal
    validation of them, is the Tolerant Reader pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Validate as little as possible. Read only the fields you need, and don’t overspecify
    their contents. This will help your system stay robust when other systems change
    over time. Resist the temptation to share message definitions between systems:
    instead, make it easy to define the data you depend on. For more info, see Martin
    Fowler’s article on the [Tolerant Reader pattern](https://oreil.ly/YL_La).'
  prefs: []
  type: TYPE_NORMAL
- en: Validating at the Edge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we said that we want to avoid cluttering our code with irrelevant details.
    In particular, we don’t want to code defensively inside our domain model. Instead,
    we want to make sure that requests are known to be valid before our domain model
    or use-case handlers see them. This helps our code stay clean and maintainable
    over the long term. We sometimes refer to this as *validating at the edge of the
    system*.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to keeping your code clean and free of endless checks and asserts,
    bear in mind that invalid data wandering through your system is a time bomb; the
    deeper it gets, the more damage it can do, and the fewer tools you have to respond
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in [Chapter 8](ch08.xhtml#chapter_08_events_and_message_bus), we said
    that the message bus was a great place to put cross-cutting concerns, and validation
    is a perfect example of that. Here’s how we might change our bus to perform validation
    for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Validation*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how we might use that method from our Flask API endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '*API bubbles up validation errors (src/allocation/flask_app.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s how we might plug it in to our asynchronous message processor:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Validation errors when handling Redis messages (src/allocation/redis_pubsub.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that our entrypoints are solely concerned with how to get a message from
    the outside world and how to report success or failure. Our message bus takes
    care of validating our requests and routing them to the correct handler, and our
    handlers are exclusively focused on the logic of our use case.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you receive an invalid message, there’s usually little you can do but log
    the error and continue. At MADE we use metrics to count the number of messages
    a system receives, and how many of those are successfully processed, skipped,
    or invalid. Our monitoring tools will alert us if we see spikes in the numbers
    of bad messages.
  prefs: []
  type: TYPE_NORMAL
- en: Validating Semantics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While syntax is concerned with the structure of messages, *semantics* is the
    study of *meaning* in messages. The sentence “Undo no dogs from ellipsis four”
    is syntactically valid and has the same structure as the sentence “Allocate one
    teapot to order five,"” but it is meaningless.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read this JSON blob as an `Allocate` command but can’t successfully
    execute it, because it’s *nonsense*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A meaningless message*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We tend to validate semantic concerns at the message-handler layer with a kind
    of contract-based programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Preconditions (src/allocation/ensure.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_validation_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use a common base class for errors that mean a message is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_validation_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Using a specific error type for this problem makes it easier to report on and
    handle the error. For example, it’s easy to map `ProductNotFound` to a 404 in
    Flask.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_validation_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`product_exists` is a precondition. If the condition is `False`, we raise an
    error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This keeps the main flow of our logic in the service layer clean and declarative:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Ensure calls in services (src/allocation/services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can extend this technique to make sure that we apply messages idempotently.
    For example, we want to make sure that we don’t insert a batch of stock more than
    once.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we get asked to create a batch that already exists, we’ll log a warning
    and continue to the next message:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Raise SkipMessage exception for ignorable events (src/allocation/services.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Introducing a `SkipMessage` exception lets us handle these cases in a generic
    way in our message bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The bus now knows how to skip (src/allocation/messagebus.py)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of pitfalls to be aware of here. First, we need to be sure
    that we’re using the same UoW that we use for the main logic of our use case.
    Otherwise, we open ourselves to irritating concurrency bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we should try to avoid putting *all* our business logic into these precondition
    checks. As a rule of thumb, if a rule *can* be tested inside our domain model,
    then it *should* be tested in the domain model.
  prefs: []
  type: TYPE_NORMAL
- en: Validating Pragmatics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Pragmatics* is the study of how we understand language in context. After we
    have parsed a message and grasped its meaning, we still need to process it in
    context. For example, if you get a comment on a pull request saying, “I think
    this is very brave,” it may mean that the reviewer admires your courage—unless
    they’re British, in which case, they’re trying to tell you that what you’re doing
    is insanely risky, and only a fool would attempt it. Context is everything.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once you’ve validated the syntax and semantics of your commands at the edges
    of your system, the domain is the place for the rest of your validation. Validation
    of pragmatics is often a core part of your business rules.
  prefs: []
  type: TYPE_NORMAL
- en: In software terms, the pragmatics of an operation are usually managed by the
    domain model. When we receive a message like “allocate three million units of
    `SCARCE-CLOCK` to order 76543,” the message is *syntactically* valid and *semantically*
    valid, but we’re unable to comply because we don’t have the stock available.
  prefs: []
  type: TYPE_NORMAL

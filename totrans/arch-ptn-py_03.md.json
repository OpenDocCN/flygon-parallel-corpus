["```py\n[plantuml, apwp_0102]\n@startuml Allocation Context Diagram\n!include images/C4_Context.puml\n\nSystem(systema, \"Allocation\", \"Allocates stock to customer orders\")\n\nPerson(customer, \"Customer\", \"Wants to buy furniture\")\nPerson(buyer, \"Buying Team\", \"Needs to purchase furniture from suppliers\")\n\nSystem(procurement, \"Purchasing\", \"Manages workflow for buying stock from suppliers\")\nSystem(ecom, \"E-commerce\", \"Sells goods online\")\nSystem(warehouse, \"Warehouse\", \"Manages workflow for shipping goods to customers.\")\n\nRel(buyer, procurement, \"Uses\")\nRel(procurement, systema, \"Notifies about shipments\")\nRel(customer, ecom, \"Buys from\")\nRel(ecom, systema, \"Asks for stock levels\")\nRel(ecom, systema, \"Notifies about orders\")\nRel_R(systema, warehouse, \"Sends instructions to\")\nRel_U(warehouse, customer, \"Dispatches goods to\")\n\n@enduml\n```", "```py\ndef test_allocating_to_a_batch_reduces_the_available_quantity():\n    batch = Batch(\"batch-001\", \"SMALL-TABLE\", qty=20, eta=date.today())\n    line = OrderLine('order-ref', \"SMALL-TABLE\", 2)\n\n    batch.allocate(line)\n\n    assert batch.available_quantity == 18\n```", "```py\n@dataclass(frozen=True)![1](Images/1.png)![2](Images/2.png)classOrderLine:orderid:strsku:strqty:intclassBatch:def__init__(self,ref:str,sku:str,qty:int,eta:Optional[date]![2](Images/2.png)):self.reference=refself.sku=skuself.eta=etaself.available_quantity=qtydefallocate(self,line:OrderLine):self.available_quantity-=line.qty![3](Images/3.png)\n```", "```py\ndef make_batch_and_line(sku, batch_qty, line_qty):\n    return (\n        Batch(\"batch-001\", sku, batch_qty, eta=date.today()),\n        OrderLine(\"order-123\", sku, line_qty)\n    )\n\ndef test_can_allocate_if_available_greater_than_required():\n    large_batch, small_line = make_batch_and_line(\"ELEGANT-LAMP\", 20, 2)\n    assert large_batch.can_allocate(small_line)\n\ndef test_cannot_allocate_if_available_smaller_than_required():\n    small_batch, large_line = make_batch_and_line(\"ELEGANT-LAMP\", 2, 20)\n    assert small_batch.can_allocate(large_line) is False\n\ndef test_can_allocate_if_available_equal_to_required():\n    batch, line = make_batch_and_line(\"ELEGANT-LAMP\", 2, 2)\n    assert batch.can_allocate(line)\n\ndef test_cannot_allocate_if_skus_do_not_match():\n    batch = Batch(\"batch-001\", \"UNCOMFORTABLE-CHAIR\", 100, eta=None)\n    different_sku_line = OrderLine(\"order-123\", \"EXPENSIVE-TOASTER\", 10)\n    assert batch.can_allocate(different_sku_line) is False\n```", "```py\n    def can_allocate(self, line: OrderLine) -> bool:\n        return self.sku == line.sku and self.available_quantity >= line.qty\n```", "```py\ndef test_can_only_deallocate_allocated_lines():\n    batch, unallocated_line = make_batch_and_line(\"DECORATIVE-TRINKET\", 20, 2)\n    batch.deallocate(unallocated_line)\n    assert batch.available_quantity == 20\n```", "```py\nclass Batch:\n    def __init__(\n        self, ref: str, sku: str, qty: int, eta: Optional[date]\n    ):\n        self.reference = ref\n        self.sku = sku\n        self.eta = eta\n        self._purchased_quantity = qty\n        self._allocations = set()  # type: Set[OrderLine]\n\n    def allocate(self, line: OrderLine):\n        if self.can_allocate(line):\n            self._allocations.add(line)\n\n    def deallocate(self, line: OrderLine):\n        if line in self._allocations:\n            self._allocations.remove(line)\n\n    @property\n    def allocated_quantity(self) -> int:\n        return sum(line.qty for line in self._allocations)\n\n    @property\n    def available_quantity(self) -> int:\n        return self._purchased_quantity - self.allocated_quantity\n\n    def can_allocate(self, line: OrderLine) -> bool:\n        return self.sku == line.sku and self.available_quantity >= line.qty\n```", "```py\n[plantuml, apwp_0103, config=plantuml.cfg]\n\nleft to right direction\nhide empty members\n\nclass Batch {\n    reference\n    sku\n    eta\n    _purchased_quantity\n    _allocations\n}\n\nclass OrderLine {\n    orderid\n    sku\n    qty\n}\n\nBatch::_allocations o-- OrderLine\n```", "```py\ndef test_allocation_is_idempotent():\n    batch, line = make_batch_and_line(\"ANGULAR-DESK\", 20, 2)\n    batch.allocate(line)\n    batch.allocate(line)\n    assert batch.available_quantity == 18\n```", "```py\nOrder_reference: 12345\nLines:\n  - sku: RED-CHAIR\n    qty: 25\n  - sku: BLU-CHAIR\n    qty: 25\n  - sku: GRN-CHAIR\n    qty: 25\n```", "```py\n@dataclass(frozen=True)\nclass OrderLine:\n    orderid: OrderReference\n    sku: ProductReference\n    qty: Quantity\n```", "```py\nfrom dataclasses import dataclass\nfrom typing import NamedTuple\nfrom collections import namedtuple\n\n@dataclass(frozen=True)\nclass Name:\n    first_name: str\n    surname: str\n\nclass Money(NamedTuple):\n    currency: str\n    value: int\n\nLine = namedtuple('Line', ['sku', 'qty'])\n\ndef test_equality():\n    assert Money('gbp', 10) == Money('gbp', 10)\n    assert Name('Harry', 'Percival') != Name('Bob', 'Gregory')\n    assert Line('RED-CHAIR', 5) == Line('RED-CHAIR', 5)\n```", "```py\nfiver = Money('gbp', 5)\ntenner = Money('gbp', 10)\n\ndef can_add_money_values_for_the_same_currency():\n    assert fiver + fiver == tenner\n\ndef can_subtract_money_values():\n    assert tenner - fiver == fiver\n\ndef adding_different_currencies_fails():\n    with pytest.raises(ValueError):\n        Money('usd', 10) + Money('gbp', 10)\n\ndef can_multiply_money_by_a_number():\n    assert fiver * 5 == Money('gbp', 25)\n\ndef multiplying_two_money_values_is_an_error():\n    with pytest.raises(TypeError):\n        tenner * fiver\n```", "```py\ndef test_name_equality():\n    assert Name(\"Harry\", \"Percival\") != Name(\"Barry\", \"Percival\")\n```", "```py\nclass Person:\n\n    def __init__(self, name: Name):\n        self.name = name\n\ndef test_barry_is_harry():\n    harry = Person(Name(\"Harry\", \"Percival\"))\n    barry = harry\n\n    barry.name = Name(\"Barry\", \"Percival\")\n\n    assert harry is barry and barry is harry\n```", "```py\nclass Batch:\n    ...\n\n    def __eq__(self, other):\n        if not isinstance(other, Batch):\n            return False\n        return other.reference == self.reference\n\n    def __hash__(self):\n        return hash(self.reference)\n```", "```py\ndef test_prefers_current_stock_batches_to_shipments():\n    in_stock_batch = Batch(\"in-stock-batch\", \"RETRO-CLOCK\", 100, eta=None)\n    shipment_batch = Batch(\"shipment-batch\", \"RETRO-CLOCK\", 100, eta=tomorrow)\n    line = OrderLine(\"oref\", \"RETRO-CLOCK\", 10)\n\n    allocate(line, [in_stock_batch, shipment_batch])\n\n    assert in_stock_batch.available_quantity == 90\n    assert shipment_batch.available_quantity == 100\n\ndef test_prefers_earlier_batches():\n    earliest = Batch(\"speedy-batch\", \"MINIMALIST-SPOON\", 100, eta=today)\n    medium = Batch(\"normal-batch\", \"MINIMALIST-SPOON\", 100, eta=tomorrow)\n    latest = Batch(\"slow-batch\", \"MINIMALIST-SPOON\", 100, eta=later)\n    line = OrderLine(\"order1\", \"MINIMALIST-SPOON\", 10)\n\n    allocate(line, [medium, earliest, latest])\n\n    assert earliest.available_quantity == 90\n    assert medium.available_quantity == 100\n    assert latest.available_quantity == 100\n\ndef test_returns_allocated_batch_ref():\n    in_stock_batch = Batch(\"in-stock-batch-ref\", \"HIGHBROW-POSTER\", 100, eta=None)\n    shipment_batch = Batch(\"shipment-batch-ref\", \"HIGHBROW-POSTER\", 100, eta=tomorrow)\n    line = OrderLine(\"oref\", \"HIGHBROW-POSTER\", 10)\n    allocation = allocate(line, [in_stock_batch, shipment_batch])\n    assert allocation == in_stock_batch.reference\n```", "```py\ndef allocate(line: OrderLine, batches: List[Batch]) -> str:\n    batch = next(\n        b for b in sorted(batches) if b.can_allocate(line)\n    )\n    batch.allocate(line)\n    return batch.reference\n```", "```py\nclass Batch:\n    ...\n\n    def __gt__(self, other):\n        if self.eta is None:\n            return False\n        if other.eta is None:\n            return True\n        return self.eta > other.eta\n```", "```py\ndef test_raises_out_of_stock_exception_if_cannot_allocate():\n    batch = Batch('batch1', 'SMALL-FORK', 10, eta=today)\n    allocate(OrderLine('order1', 'SMALL-FORK', 10), [batch])\n\n    with pytest.raises(OutOfStock, match='SMALL-FORK'):\n        allocate(OrderLine('order2', 'SMALL-FORK', 1), [batch])\n```", "```py\nclass OutOfStock(Exception):\n    pass\n\ndef allocate(line: OrderLine, batches: List[Batch]) -> str:\n    try:\n        batch = next(\n        ...\n    except StopIteration:\n        raise OutOfStock(f'Out of stock for sku {line.sku}')\n```"]
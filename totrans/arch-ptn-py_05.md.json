["```py\ngit clone https://github.com/cosmicpython/code.git\ngit checkout chapter_03_abstractions\n```", "```py\n[ditaa,apwp_0301]\n+--------+      +--------+\n| System | ---> | System |\n|   A    | ---> |   B    |\n|        | ---> |        |\n|        | ---> |        |\n|        | ---> |        |\n+--------+      +--------+\n```", "```py\n[ditaa,apwp_0302]\n+--------+                           +--------+\n| System |      /-------------\\      | System |\n|   A    | ---> |             | ---> |   B    |\n|        | ---> | Abstraction | ---> |        |\n|        |      |             | ---> |        |\n|        |      \\-------------/      |        |\n+--------+                           +--------+\n```", "```py\nBLOCKSIZE = 65536\n\ndef hash_file(path):\n    hasher = hashlib.sha1()\n    with path.open(\"rb\") as file:\n        buf = file.read(BLOCKSIZE)\n        while buf:\n            hasher.update(buf)\n            buf = file.read(BLOCKSIZE)\n    return hasher.hexdigest()\n```", "```py\nimport hashlib\nimport os\nimport shutil\nfrom pathlib import Path\n\ndef sync(source, dest):\n    # Walk the source folder and build a dict of filenames and their hashes\n    source_hashes = {}\n    for folder, _, files in os.walk(source):\n        for fn in files:\n            source_hashes[hash_file(Path(folder) / fn)] = fn\n\n    seen = set()  # Keep track of the files we've found in the target\n\n    # Walk the target folder and get the filenames and hashes\n    for folder, _, files in os.walk(dest):\n        for fn in files:\n            dest_path = Path(folder) / fn\n            dest_hash = hash_file(dest_path)\n            seen.add(dest_hash)\n\n            # if there's a file in target that's not in source, delete it\n            if dest_hash not in source_hashes:\n                dest_path.remove()\n\n            # if there's a file in target that has a different path in source,\n            # move it to the correct path\n            elif dest_hash in source_hashes and fn != source_hashes[dest_hash]:\n                shutil.move(dest_path, Path(folder) / source_hashes[dest_hash])\n\n    # for every file that appears in source but not target, copy the file to\n    # the target\n    for src_hash, fn in source_hashes.items():\n        if src_hash not in seen:\n            shutil.copy(Path(source) / fn, Path(dest) / fn)\n```", "```py\ndef test_when_a_file_exists_in_the_source_but_not_the_destination():\n    try:\n        source = tempfile.mkdtemp()\n        dest = tempfile.mkdtemp()\n\n        content = \"I am a very useful file\"\n        (Path(source) / 'my-file').write_text(content)\n\n        sync(source, dest)\n\n        expected_path = Path(dest) /  'my-file'\n        assert expected_path.exists()\n        assert expected_path.read_text() == content\n\n    finally:\n        shutil.rmtree(source)\n        shutil.rmtree(dest)\n\ndef test_when_a_file_has_been_renamed_in_the_source():\n    try:\n        source = tempfile.mkdtemp()\n        dest = tempfile.mkdtemp()\n\n        content = \"I am a file that was renamed\"\n        source_path = Path(source) / 'source-filename'\n        old_dest_path = Path(dest) / 'dest-filename'\n        expected_dest_path = Path(dest) / 'source-filename'\n        source_path.write_text(content)\n        old_dest_path.write_text(content)\n\n        sync(source, dest)\n\n        assert old_dest_path.exists() is False\n        assert expected_dest_path.read_text() == content\n\n    finally:\n        shutil.rmtree(source)\n        shutil.rmtree(dest)\n```", "```py\nsource_files = {'hash1': 'path1', 'hash2': 'path2'}\ndest_files = {'hash1': 'path1', 'hash2': 'pathX'}\n```", "```py\n(\"COPY\", \"sourcepath\", \"destpath\"),\n(\"MOVE\", \"old\", \"new\"),\n```", "```py\n    def test_when_a_file_exists_in_the_source_but_not_the_destination():\n        src_hashes = {'hash1': 'fn1'}\n        dst_hashes = {}\n        expected_actions = [('COPY', '/src/fn1', '/dst/fn1')]\n        ...\n\n    def test_when_a_file_has_been_renamed_in_the_source():\n        src_hashes = {'hash1': 'fn1'}\n        dst_hashes = {'hash1': 'fn2'}\n        expected_actions == [('MOVE', '/dst/fn2', '/dst/fn1')]\n        ...\n```", "```py\ndefsync(source,dest):# imperative shell step 1, gather inputssource_hashes=read_paths_and_hashes(source)![1](Images/1.png)dest_hashes=read_paths_and_hashes(dest)![1](Images/1.png)# step 2: call functional coreactions=determine_actions(source_hashes,dest_hashes,source,dest)![2](Images/2.png)# imperative shell step 3, apply outputsforaction,*pathsinactions:ifaction=='copy':shutil.copyfile(*paths)ifaction=='move':shutil.move(*paths)ifaction=='delete':os.remove(paths[0])\n```", "```py\ndef read_paths_and_hashes(root):\n    hashes = {}\n    for folder, _, files in os.walk(root):\n        for fn in files:\n            hashes[hash_file(Path(folder) / fn)] = fn\n    return hashes\n```", "```py\ndef determine_actions(src_hashes, dst_hashes, src_folder, dst_folder):\n    for sha, filename in src_hashes.items():\n        if sha not in dst_hashes:\n            sourcepath = Path(src_folder) / filename\n            destpath = Path(dst_folder) / filename\n            yield 'copy', sourcepath, destpath\n\n        elif dst_hashes[sha] != filename:\n            olddestpath = Path(dst_folder) / dst_hashes[sha]\n            newdestpath = Path(dst_folder) / filename\n            yield 'move', olddestpath, newdestpath\n\n    for sha, filename in dst_hashes.items():\n        if sha not in src_hashes:\n            yield 'delete', dst_folder / filename\n```", "```py\ndef test_when_a_file_exists_in_the_source_but_not_the_destination():\n    src_hashes = {'hash1': 'fn1'}\n    dst_hashes = {}\n    actions = determine_actions(src_hashes, dst_hashes, Path('/src'), Path('/dst'))\n    assert list(actions) == [('copy', Path('/src/fn1'), Path('/dst/fn1'))]\n...\n\ndef test_when_a_file_has_been_renamed_in_the_source():\n    src_hashes = {'hash1': 'fn1'}\n    dst_hashes = {'hash1': 'fn2'}\n    actions = determine_actions(src_hashes, dst_hashes, Path('/src'), Path('/dst'))\n    assert list(actions) == [('move', Path('/dst/fn2'), Path('/dst/fn1'))]\n```", "```py\ndefsync(reader,filesystem,source_root,dest_root):![1](Images/1.png)source_hashes=reader(source_root)![2](Images/2.png)dest_hashes=reader(dest_root)forsha,filenameinsrc_hashes.items():ifshanotindest_hashes:sourcepath=source_root/filenamedestpath=dest_root/filenamefilesystem.copy(destpath,sourcepath)![3](Images/3.png)elifdest_hashes[sha]!=filename:olddestpath=dest_root/dest_hashes[sha]newdestpath=dest_root/filenamefilesystem.move(olddestpath,newdestpath)forsha,filenameindst_hashes.items():ifshanotinsource_hashes:filesystem.delete(dest_root/filename)\n```", "```py\nclassFakeFileSystem(list):![1](Images/1.png)defcopy(self,src,dest):![2](Images/2.png)self.append(('COPY',src,dest))defmove(self,src,dest):self.append(('MOVE',src,dest))defdelete(self,dest):self.append(('DELETE',src,dest))deftest_when_a_file_exists_in_the_source_but_not_the_destination():source={\"sha1\":\"my-file\"}dest={}filesystem=FakeFileSystem()reader={\"/source\":source,\"/dest\":dest}synchronise_dirs(reader.pop,filesystem,\"/source\",\"/dest\")assertfilesystem==[(\"COPY\",\"/source/my-file\",\"/dest/my-file\")]deftest_when_a_file_has_been_renamed_in_the_source():source={\"sha1\":\"renamed-file\"}dest={\"sha1\":\"original-file\"}filesystem=FakeFileSystem()reader={\"/source\":source,\"/dest\":dest}synchronise_dirs(reader.pop,filesystem,\"/source\",\"/dest\")assertfilesystem==[(\"MOVE\",\"/dest/original-file\",\"/dest/renamed-file\")]\n```"]
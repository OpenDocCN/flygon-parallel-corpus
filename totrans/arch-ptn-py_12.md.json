["```py\ngit clone https://github.com/cosmicpython/code.git\ncd code\ngit checkout chapter_09_all_messagebus\n# or to code along, checkout the previous chapter:\ngit checkout chapter_08_events_and_message_bus\n```", "```py\n[ditaa, apwp_0903]\n+----------+    /----\\      +------------+       +--------------------+\n| Batch    |--> |RULE| -->  | Deallocate | ----> | AllocationRequired |\n| Quantity |    \\----/      +------------+-+     +--------------------+-+\n| Changed  |                  | Deallocate | ----> | AllocationRequired |\n+----------+                  +------------+-+     +--------------------+-+\n                                | Deallocate | ----> | AllocationRequired |\n                                +------------+       +--------------------+\n```", "```py\n@dataclass\nclass BatchCreated(Event):\n    ref: str\n    sku: str\n    qty: int\n    eta: Optional[date] = None\n\n...\n\n@dataclass\nclass AllocationRequired(Event):\n    orderid: str\n    sku: str\n    qty: int\n```", "```py\ndef add_batch(\n        event: events.BatchCreated, uow: unit_of_work.AbstractUnitOfWork\n):\n    with uow:\n        product = uow.products.get(sku=event.sku)\n        ...\n\ndef allocate(\n        event: events.AllocationRequired, uow: unit_of_work.AbstractUnitOfWork\n) -> str:\n    line = OrderLine(event.orderid, event.sku, event.qty)\n    ...\n\ndef send_out_of_stock_notification(\n        event: events.OutOfStock, uow: unit_of_work.AbstractUnitOfWork,\n):\n    email.send(\n        'stock@made.com',\n        f'Out of stock for {event.sku}',\n    )\n```", "```py\n def add_batch(\n-        ref: str, sku: str, qty: int, eta: Optional[date],\n-        uow: unit_of_work.AbstractUnitOfWork\n+        event: events.BatchCreated, uow: unit_of_work.AbstractUnitOfWork\n ):\n     with uow:\n-        product = uow.products.get(sku=sku)\n+        product = uow.products.get(sku=event.sku)\n     ...\n\n def allocate(\n-        orderid: str, sku: str, qty: int,\n-        uow: unit_of_work.AbstractUnitOfWork\n+        event: events.AllocationRequired, uow: unit_of_work.AbstractUnitOfWork\n ) -> str:\n-    line = OrderLine(orderid, sku, qty)\n+    line = OrderLine(event.orderid, event.sku, event.qty)\n     ...\n\n+\n+def send_out_of_stock_notification(\n+        event: events.OutOfStock, uow: unit_of_work.AbstractUnitOfWork,\n+):\n+    email.send(\n     ...\n```", "```py\ndefhandle(event:events.Event,uow:unit_of_work.AbstractUnitOfWork):![1](Images/1.png)queue=[event]![2](Images/2.png)whilequeue:event=queue.pop(0)![3](Images/3.png)forhandlerinHANDLERS[type(event)]:![3](Images/3.png)handler(event,uow=uow)![4](Images/4.png)queue.extend(uow.collect_new_events())![5](Images/5.png)\n```", "```py\n-from . import messagebus ![1](Images/1.png)-  class AbstractUnitOfWork(abc.ABC): @@ -23,13 +21,11 @@ class AbstractUnitOfWork(abc.ABC):  def commit(self): self._commit() -        self.publish_events() ![2](Images/2.png)-    def publish_events(self): +    def collect_new_events(self):\n for product in self.products.seen: while product.events: -                event = product.events.pop(0) -                messagebus.handle(event) +                yield product.events.pop(0) ![3](Images/3.png)\n```", "```py\nclass TestAddBatch:\n\n     def test_for_new_product(self):\n         uow = FakeUnitOfWork()\n-        services.add_batch(\"b1\", \"CRUNCHY-ARMCHAIR\", 100, None, uow)\n+        messagebus.handle(\n+            events.BatchCreated(\"b1\", \"CRUNCHY-ARMCHAIR\", 100, None), uow\n+        )\n         assert uow.products.get(\"CRUNCHY-ARMCHAIR\") is not None\n         assert uow.committed\n\n...\n\n class TestAllocate:\n\n     def test_returns_allocation(self):\n         uow = FakeUnitOfWork()\n-        services.add_batch(\"batch1\", \"COMPLICATED-LAMP\", 100, None, uow)\n-        result = services.allocate(\"o1\", \"COMPLICATED-LAMP\", 10, uow)\n+        messagebus.handle(\n+            events.BatchCreated(\"batch1\", \"COMPLICATED-LAMP\", 100, None), uow\n+        )\n+        result = messagebus.handle(\n+            events.AllocationRequired(\"o1\", \"COMPLICATED-LAMP\", 10), uow\n+        )\n         assert result == \"batch1\"\n```", "```py\n def handle(event: events.Event, uow: unit_of_work.AbstractUnitOfWork):\n+    results = []\n     queue = [event]\n     while queue:\n         event = queue.pop(0)\n         for handler in HANDLERS[type(event)]:\n-            handler(event, uow=uow)\n+            results.append(handler(event, uow=uow))\n             queue.extend(uow.collect_new_events())\n+    return results\n```", "```py\n @app.route(\"/allocate\", methods=['POST']) def allocate_endpoint(): try: -        batchref = services.allocate( -            request.json['orderid'], ![1](Images/1.png)-            request.json['sku'], -            request.json['qty'], -            unit_of_work.SqlAlchemyUnitOfWork(), +        event = events.AllocationRequired( ![2](Images/2.png)+            request.json['orderid'], request.json['sku'], request.json['qty'],\n ) +        results = messagebus.handle(event, unit_of_work.SqlAlchemyUnitOfWork()) ![3](Images/3.png)+        batchref = results.pop(0)\n except InvalidSku as e:\n```", "```py\n[plantuml, apwp_0904, config=plantuml.cfg]\n@startuml\nAPI -> MessageBus : BatchQuantityChanged event\n\ngroup BatchQuantityChanged Handler + Unit of Work 1\n    MessageBus -> Domain_Model : change batch quantity\n    Domain_Model -> MessageBus : emit AllocationRequired event(s)\nend\n\ngroup AllocationRequired Handler + Unit of Work 2 (or more)\n    MessageBus -> Domain_Model : allocate\nend\n\n@enduml\n```", "```py\n@dataclass\nclass BatchQuantityChanged(Event):\n    ref: str\n    qty: int\n```", "```py\nclassTestChangeBatchQuantity:deftest_changes_available_quantity(self):uow=FakeUnitOfWork()messagebus.handle(events.BatchCreated(\"batch1\",\"ADORABLE-SETTEE\",100,None),uow)[batch]=uow.products.get(sku=\"ADORABLE-SETTEE\").batchesassertbatch.available_quantity==100![1](Images/1.png)messagebus.handle(events.BatchQuantityChanged(\"batch1\",50),uow)assertbatch.available_quantity==50![1](Images/1.png)deftest_reallocates_if_necessary(self):uow=FakeUnitOfWork()event_history=[events.BatchCreated(\"batch1\",\"INDIFFERENT-TABLE\",50,None),events.BatchCreated(\"batch2\",\"INDIFFERENT-TABLE\",50,date.today()),events.AllocationRequired(\"order1\",\"INDIFFERENT-TABLE\",20),events.AllocationRequired(\"order2\",\"INDIFFERENT-TABLE\",20),]foreinevent_history:messagebus.handle(e,uow)[batch1,batch2]=uow.products.get(sku=\"INDIFFERENT-TABLE\").batchesassertbatch1.available_quantity==10assertbatch2.available_quantity==50messagebus.handle(events.BatchQuantityChanged(\"batch1\",25),uow)# order1 or order2 will be deallocated, so we'll have 25 - 20assertbatch1.available_quantity==5![2](Images/2.png)# and 20 will be reallocated to the next batchassertbatch2.available_quantity==30![2](Images/2.png)\n```", "```py\ndef change_batch_quantity(\n        event: events.BatchQuantityChanged, uow: unit_of_work.AbstractUnitOfWork\n):\n    with uow:\n        product = uow.products.get_by_batchref(batchref=event.ref)\n        product.change_batch_quantity(ref=event.ref, qty=event.qty)\n        uow.commit()\n```", "```py\nclass AbstractRepository(abc.ABC):\n    ...\n\n    def get(self, sku) -> model.Product:\n        ...\n\n    def get_by_batchref(self, batchref) -> model.Product:\n        product = self._get_by_batchref(batchref)\n        if product:\n            self.seen.add(product)\n        return product\n\n    @abc.abstractmethod\n    def _add(self, product: model.Product):\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def _get(self, sku) -> model.Product:\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def _get_by_batchref(self, batchref) -> model.Product:\n        raise NotImplementedError\n    ...\n\nclass SqlAlchemyRepository(AbstractRepository):\n    ...\n\n    def _get(self, sku):\n        return self.session.query(model.Product).filter_by(sku=sku).first()\n\n    def _get_by_batchref(self, batchref):\n        return self.session.query(model.Product).join(model.Batch).filter(\n            orm.batches.c.reference == batchref,\n        ).first()\n```", "```py\nclass FakeRepository(repository.AbstractRepository):\n    ...\n\n    def _get(self, sku):\n        return next((p for p in self._products if p.sku == sku), None)\n\n    def _get_by_batchref(self, batchref):\n        return next((\n            p for p in self._products for b in p.batches\n            if b.reference == batchref\n        ), None)\n```", "```py\nclass Product:\n    ...\n\n    def change_batch_quantity(self, ref: str, qty: int):\n        batch = next(b for b in self.batches if b.reference == ref)\n        batch._purchased_quantity = qty\n        while batch.available_quantity < 0:\n            line = batch.deallocate_one()\n            self.events.append(\n                events.AllocationRequired(line.orderid, line.sku, line.qty)\n            )\n...\n\nclass Batch:\n    ...\n\n    def deallocate_one(self) -> OrderLine:\n        return self._allocations.pop()\n```", "```py\nHANDLERS = {\n    events.BatchCreated: [handlers.add_batch],\n    events.BatchQuantityChanged: [handlers.change_batch_quantity],\n    events.AllocationRequired: [handlers.allocate],\n    events.OutOfStock: [handlers.send_out_of_stock_notification],\n\n}  # type: Dict[Type[events.Event], List[Callable]]\n```", "```py\nclass FakeUnitOfWorkWithFakeMessageBus(FakeUnitOfWork):\n\n    def __init__(self):\n        super().__init__()\n        self.events_published = []  # type: List[events.Event]\n\n    def publish_events(self):\n        for product in self.products.seen:\n            while product.events:\n                self.events_published.append(product.events.pop(0))\n```", "```py\ndef test_reallocates_if_necessary_isolated():\n    uow = FakeUnitOfWorkWithFakeMessageBus()\n\n    # test setup as before\n    event_history = [\n        events.BatchCreated(\"batch1\", \"INDIFFERENT-TABLE\", 50, None),\n        events.BatchCreated(\"batch2\", \"INDIFFERENT-TABLE\", 50, date.today()),\n        events.AllocationRequired(\"order1\", \"INDIFFERENT-TABLE\", 20),\n        events.AllocationRequired(\"order2\", \"INDIFFERENT-TABLE\", 20),\n    ]\n    for e in event_history:\n        messagebus.handle(e, uow)\n    [batch1, batch2] = uow.products.get(sku=\"INDIFFERENT-TABLE\").batches\n    assert batch1.available_quantity == 10\n    assert batch2.available_quantity == 50\n\n    messagebus.handle(events.BatchQuantityChanged(\"batch1\", 25), uow)\n\n    # assert on new events emitted rather than downstream side-effects\n    [reallocation_event] = uow.events_published\n    assert isinstance(reallocation_event, events.AllocationRequired)\n    assert reallocation_event.orderid in {'order1', 'order2'}\n    assert reallocation_event.sku == 'INDIFFERENT-TABLE'\n```"]
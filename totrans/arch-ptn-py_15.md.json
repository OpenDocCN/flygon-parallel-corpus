["```py\ngit clone https://github.com/cosmicpython/code.git\ncd code\ngit checkout chapter_12_cqrs\n# or to code along, checkout the previous chapter:\ngit checkout chapter_11_external_events\n```", "```py\ndef test_allocating_to_a_batch_reduces_the_available_quantity():\n    batch = Batch(\"batch-001\", \"SMALL-TABLE\", qty=20, eta=date.today())\n    line = OrderLine('order-ref', \"SMALL-TABLE\", 2)\n\n    batch.allocate(line)\n\n    assert batch.available_quantity == 18\n\n...\n\ndef test_cannot_allocate_if_available_smaller_than_required():\n    small_batch, large_line = make_batch_and_line(\"ELEGANT-LAMP\", 2, 20)\n    assert small_batch.can_allocate(large_line) is False\n```", "```py\n@pytest.mark.usefixtures('postgres_db')\n@pytest.mark.usefixtures('restart_api')\ndef test_happy_path_returns_202_and_batch_is_allocated():\n    orderid = random_orderid()\n    sku, othersku = random_sku(), random_sku('other')\n    earlybatch = random_batchref(1)\n    laterbatch = random_batchref(2)\n    otherbatch = random_batchref(3)\n    api_client.post_to_add_batch(laterbatch, sku, 100, '2011-01-02')\n    api_client.post_to_add_batch(earlybatch, sku, 100, '2011-01-01')\n    api_client.post_to_add_batch(otherbatch, othersku, 100, None)\n\n    r = api_client.post_to_allocate(orderid, sku, qty=3)\n    assert r.status_code == 202\n\n    r = api_client.get_allocation(orderid)\n    assert r.ok\n    assert r.json() == [\n        {'sku': sku, 'batchref': earlybatch},\n    ]\n\n@pytest.mark.usefixtures('postgres_db')\n@pytest.mark.usefixtures('restart_api')\ndef test_unhappy_path_returns_400_and_error_message():\n    unknown_sku, orderid = random_sku(), random_orderid()\n    r = api_client.post_to_allocate(\n        orderid, unknown_sku, qty=20, expect_success=False,\n    )\n    assert r.status_code == 400\n    assert r.json()['message'] == f'Invalid sku {unknown_sku}'\n\n    r = api_client.get_allocation(orderid)\n    assert r.status_code == 404\n```", "```py\nfromallocationimportviews...@app.route(\"/allocations/<orderid>\",methods=['GET'])defallocations_view_endpoint(orderid):uow=unit_of_work.SqlAlchemyUnitOfWork()result=views.allocations(orderid,uow)![1](Images/1.png)ifnotresult:return'not found',404returnjsonify(result),200\n```", "```py\nfrom allocation.service_layer import unit_of_work\n\ndef allocations(orderid: str, uow: unit_of_work.SqlAlchemyUnitOfWork):\n    with uow:\n        results = list(uow.session.execute(\n            'SELECT ol.sku, b.reference'\n            ' FROM allocations AS a'\n            ' JOIN batches AS b ON a.batch_id = b.id'\n            ' JOIN order_lines AS ol ON a.orderline_id = ol.id'\n            ' WHERE ol.orderid = :orderid',\n            dict(orderid=orderid)\n        ))\n    return [{'sku': sku, 'batchref': batchref} for sku, batchref in results]\n```", "```py\ndeftest_allocations_view(sqlite_session_factory):uow=unit_of_work.SqlAlchemyUnitOfWork(sqlite_session_factory)messagebus.handle(commands.CreateBatch('sku1batch','sku1',50,None),uow)![1](Images/1.png)messagebus.handle(commands.CreateBatch('sku2batch','sku2',50,today),uow)messagebus.handle(commands.Allocate('order1','sku1',20),uow)messagebus.handle(commands.Allocate('order1','sku2',20),uow)# add a spurious batch and order to make sure we're getting the right onesmessagebus.handle(commands.CreateBatch('sku1batch-later','sku1',50,today),uow)messagebus.handle(commands.Allocate('otherorder','sku1',30),uow)messagebus.handle(commands.Allocate('otherorder','sku2',10),uow)assertviews.allocations('order1',uow)==[{'sku':'sku1','batchref':'sku1batch'},{'sku':'sku2','batchref':'sku2batch'},]\n```", "```py\nfromallocationimportunit_of_workdefallocations(orderid:str,uow:unit_of_work.AbstractUnitOfWork):withuow:products=uow.products.for_order(orderid=orderid)![1](Images/1.png)batches=[bforpinproductsforbinp.batches]![2](Images/2.png)return[{'sku':b.sku,'batchref':b.reference}forbinbatchesiforderidinb.orderids![3](Images/3.png)]\n```", "```py\nclass Batch:\n    ...\n\n    @property\n    def orderids(self):\n        return {l.orderid for l in self._allocations}\n```", "```py\nfrom allocation import unit_of_work, model\n\ndef allocations(orderid: str, uow: unit_of_work.AbstractUnitOfWork):\n    with uow:\n        batches = uow.session.query(model.Batch).join(\n            model.OrderLine, model.Batch._allocations\n        ).filter(\n            model.OrderLine.orderid == orderid\n        )\n        return [\n            {'sku': b.sku, 'batchref': b.batchref}\n            for b in batches\n        ]\n```", "```py\ndef allocations(orderid: str, uow: unit_of_work.SqlAlchemyUnitOfWork):\n    with uow:\n        results = list(uow.session.execute(\n            'SELECT sku, batchref FROM allocations_view WHERE orderid = :orderid',\n            dict(orderid=orderid)\n        ))\n        ...\n```", "```py\nallocations_view = Table(\n    'allocations_view', metadata,\n    Column('orderid', String(255)),\n    Column('sku', String(255)),\n    Column('batchref', String(255)),\n)\n```", "```py\nEVENT_HANDLERS = {\n    events.Allocated: [\n        handlers.publish_allocated_event,\n        handlers.add_allocation_to_read_model\n    ],\n```", "```py\ndef add_allocation_to_read_model(\n        event: events.Allocated, uow: unit_of_work.SqlAlchemyUnitOfWork,\n):\n    with uow:\n        uow.session.execute(\n            'INSERT INTO allocations_view (orderid, sku, batchref)'\n            ' VALUES (:orderid, :sku, :batchref)',\n            dict(orderid=event.orderid, sku=event.sku, batchref=event.batchref)\n        )\n        uow.commit()\n```", "```py\nevents.Deallocated: [\n    handlers.remove_allocation_from_read_model,\n    handlers.reallocate\n],\n\n...\n\ndef remove_allocation_from_read_model(\n        event: events.Deallocated, uow: unit_of_work.SqlAlchemyUnitOfWork,\n):\n    with uow:\n        uow.session.execute(\n            'DELETE FROM allocations_view '\n            ' WHERE orderid = :orderid AND sku = :sku',\n```", "```py\n[plantuml, apwp_1202, config=plantuml.cfg]\n@startuml\nactor User order 1\nboundary Flask order 2\nparticipant MessageBus order 3\nparticipant \"Domain Model\" as Domain order 4\nparticipant View order 9\ndatabase DB order 10\n\nUser -> Flask: POST to allocate Endpoint\nFlask -> MessageBus : Allocate Command\n\ngroup UoW/transaction 1\n    MessageBus -> Domain : allocate()\n    MessageBus -> DB: commit write model\nend\n\ngroup UoW/transaction 2\n    Domain -> MessageBus : raise Allocated event(s)\n    MessageBus -> DB : update view model\nend\n\nFlask -> User: 202 OK\n\nUser -> Flask: GET allocations endpoint\nFlask -> View: get allocations\nView -> DB: SELECT on view model\nDB -> View: some allocations\nView -> Flask: some allocations\nFlask -> User: some allocations\n\n@enduml\n```", "```py\ndef add_allocation_to_read_model(event: events.Allocated, _):\n    redis_eventpublisher.update_readmodel(event.orderid, event.sku, event.batchref)\n\ndef remove_allocation_from_read_model(event: events.Deallocated, _):\n    redis_eventpublisher.update_readmodel(event.orderid, event.sku, None)\n```", "```py\ndef update_readmodel(orderid, sku, batchref):\n    r.hset(orderid, sku, batchref)\n\ndef get_readmodel(orderid):\n    return r.hgetall(orderid)\n```", "```py\ndef allocations(orderid):\n    batches = redis_eventpublisher.get_readmodel(orderid)\n    return [\n        {'batchref': b.decode(), 'sku': s.decode()}\n        for s, b in batches.items()\n    ]\n```"]
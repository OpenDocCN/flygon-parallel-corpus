- en: Chapter 13\. Dependency Injection (and Bootstrapping)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。依赖注入（和引导）
- en: Dependency injection (DI) is regarded with suspicion in the Python world. And
    we’ve managed *just fine* without it so far in the example code for this book!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入（DI）在Python世界中备受怀疑。迄今为止，我们在本书的示例代码中一直*很好*地没有使用它！
- en: In this chapter, we’ll explore some of the pain points in our code that lead
    us to consider using DI, and we’ll present some options for how to do it, leaving
    it to you to pick which you think is most Pythonic.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨代码中的一些痛点，这些痛点导致我们考虑使用DI，并提出一些如何实现它的选项，让您选择最符合Python风格的方式。
- en: We’ll also add a new component to our architecture called *bootstrap.py*; it
    will be in charge of dependency injection, as well as some other initialization
    stuff that we often need. We’ll explain why this sort of thing is called a *composition
    root* in OO languages, and why *bootstrap script* is just fine for our purposes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将向我们的架构添加一个名为*bootstrap.py*的新组件；它将负责依赖注入，以及我们经常需要的一些其他初始化工作。我们将解释为什么这种东西在面向对象语言中被称为*组合根*，以及为什么*引导脚本*对我们的目的来说是完全合适的。
- en: '[Figure 13-1](#bootstrap_chapter_before_diagram) shows what our app looks like
    without a bootstrapper: the entrypoints do a lot of initialization and passing
    around of our main dependency, the UoW.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-1](#bootstrap_chapter_before_diagram)显示了我们的应用程序在没有引导程序的情况下的样子：入口点做了很多初始化和传递我们的主要依赖项UoW。'
- en: Tip
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you haven’t already, it’s worth reading [Chapter 3](ch03.xhtml#chapter_03_abstractions)
    before continuing with this chapter, particularly the discussion of functional
    versus object-oriented dependency management.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，建议在继续本章之前阅读[第3章](ch03.xhtml#chapter_03_abstractions)，特别是功能与面向对象依赖管理的讨论。
- en: '![apwp 1301](Images/apwp_1301.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![apwp 1301](Images/apwp_1301.png)'
- en: 'Figure 13-1\. Without bootstrap: entrypoints do a lot'
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-1。没有引导：入口点做了很多事情
- en: Tip
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'The code for this chapter is in the chapter_13_dependency_injection branch
    [on GitHub](https://oreil.ly/-B7e6):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码位于GitHub上的chapter_13_dependency_injection分支中[（https://oreil.ly/-B7e6）](https://oreil.ly/-B7e6)：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Figure 13-2](#bootstrap_chapter_after_diagram) shows our bootstrapper taking
    over those responsibilities.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-2](#bootstrap_chapter_after_diagram)显示了我们的引导程序接管了这些责任。'
- en: '![apwp 1302](Images/apwp_1302.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![apwp 1302](Images/apwp_1302.png)'
- en: Figure 13-2\. Bootstrap takes care of all that in one place
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-2。引导程序在一个地方处理所有这些
- en: Implicit Versus Explicit Dependencies
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式依赖与显式依赖
- en: Depending on your particular brain type, you may have a slight feeling of unease
    at the back of your mind at this point. Let’s bring it out into the open. We’ve
    shown you two ways of managing dependencies and testing them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您特定的大脑类型，您可能在心中略感不安。让我们把它公开化。我们向您展示了两种管理依赖项并对其进行测试的方式。
- en: 'For our database dependency, we’ve built a careful framework of explicit dependencies
    and easy options for overriding them in tests. Our main handler functions declare
    an explicit dependency on the UoW:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的数据库依赖，我们建立了一个明确的依赖关系框架，并提供了易于在测试中覆盖的选项。我们的主处理程序函数声明了对UoW的明确依赖：
- en: '*Our handlers have an explicit dependency on the UoW (src/allocation/service_layer/handlers.py)*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们的处理程序对UoW有明确的依赖（src/allocation/service_layer/handlers.py）*'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And that makes it easy to swap in a fake UoW in our service-layer tests:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得在我们的服务层测试中轻松替换虚假UoW成为可能：
- en: '*Service-layer tests against a fake UoW: (tests/unit/test_services.py)*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*针对虚假UoW的服务层测试：（tests/unit/test_services.py）*'
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The UoW itself declares an explicit dependency on the session factory:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: UoW本身声明了对会话工厂的明确依赖：
- en: '*The UoW depends on a session factory (src/allocation/service_layer/unit_of_work.py)*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*UoW依赖于会话工厂（src/allocation/service_layer/unit_of_work.py）*'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We take advantage of it in our integration tests to be able to sometimes use
    SQLite instead of Postgres:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用它在我们的集成测试中，有时可以使用SQLite而不是Postgres：
- en: '*Integration tests against a different DB (tests/integration/test_uow.py)*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*针对不同数据库的集成测试（tests/integration/test_uow.py）*'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO1-1)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO1-1)'
- en: Integration tests swap out the default Postgres `session_factory` for a SQLite
    one.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试将默认的Postgres `session_factory`替换为SQLite。
- en: Aren’t Explicit Dependencies Totally Weird and Java-y?
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式依赖完全奇怪和Java风格吗？
- en: 'If you’re used to the way things normally happen in Python, you’ll be thinking
    all this is a bit weird. The standard way to do things is to declare our dependency
    implicitly by simply importing it, and then if we ever need to change it for tests,
    we can monkeypatch, as is Right and True in dynamic languages:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您习惯于Python中通常发生的事情，您可能会觉得这有点奇怪。标准做法是通过简单导入隐式声明我们的依赖，然后如果我们需要在测试中更改它，我们可以进行monkeypatch，这在动态语言中是正确和正确的：
- en: '*Email sending as a normal import-based dependency (src/allocation/service_layer/handlers.py)*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*电子邮件发送作为正常的基于导入的依赖（src/allocation/service_layer/handlers.py）*'
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO2-1)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO2-1)'
- en: Hardcoded import
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 硬编码导入
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO2-2)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO2-2)'
- en: Calls specific email sender directly
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 直接调用特定的电子邮件发送器
- en: 'Why pollute our application code with unnecessary arguments just for the sake
    of our tests? `mock.patch` makes monkeypatching nice and easy:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的测试，为什么要用不必要的参数污染我们的应用程序代码？`mock.patch`使得monkeypatch变得简单而容易：
- en: '*mock dot patch, thank you Michael Foord (tests/unit/test_handlers.py)*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*模拟点补丁，谢谢Michael Foord（tests/unit/test_handlers.py）*'
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The trouble is that we’ve made it look easy because our toy example doesn’t
    send real email (`email.send_mail` just does a `print`), but in real life, you’d
    end up having to call `mock.patch` for *every single test* that might cause an
    out-of-stock notification. If you’ve worked on codebases with lots of mocks used
    to prevent unwanted side effects, you’ll know how annoying that mocky boilerplate
    gets.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，我们让它看起来很容易，因为我们的玩具示例不发送真正的电子邮件（`email.send_mail`只是`print`），但在现实生活中，您最终将不得不为*每个可能引起缺货通知的测试*调用`mock.patch`。如果您曾经在大量使用模拟以防止不需要的副作用的代码库上工作过，您将知道那些模拟的样板代码有多讨厌。
- en: And you’ll know that mocks tightly couple us to the implementation. By choosing
    to monkeypatch `email.send_mail`, we are tied to doing `import email`, and if
    we ever want to do `from email import send_mail`, a trivial refactor, we’d have
    to change all our mocks.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您会知道模拟将我们紧密耦合到实现。通过选择对`email.send_mail`进行monkeypatch，我们将绑定到执行`import email`，如果我们想要执行`from
    email import send_mail`，一个微不足道的重构，我们将不得不更改所有我们的模拟。
- en: So it’s a trade-off. Yes, declaring explicit dependencies is unnecessary, strictly
    speaking, and using them would make our application code marginally more complex.
    But in return, we’d get tests that are easier to write and manage.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此这是一个权衡。是的，严格来说，声明显式依赖是不必要的，并且使用它们会使我们的应用代码稍微更复杂。但作为回报，我们将获得更容易编写和管理的测试。
- en: 'On top of that, declaring an explicit dependency is an example of the dependency
    inversion principle—rather than having an (implicit) dependency on a *specific*
    detail, we have an (explicit) dependency on an *abstraction*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，声明显式依赖是依赖倒置原则的一个例子 - 而不是对*特定*细节的（隐式）依赖，我们对*抽象*有一个（显式）依赖：
- en: Explicit is better than implicit.
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 显式胜于隐式。
- en: '>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: The Zen of Python
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Python的禅意
- en: '*The explicit dependency is more abstract (src/allocation/service_layer/handlers.py)*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*显式依赖更抽象（src/allocation/service_layer/handlers.py）*'
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'But if we do change to declaring all these dependencies explicitly, who will
    inject them, and how? So far, we’ve really been dealing with only passing the
    UoW around: our tests use `FakeUnitOfWork`, while Flask and Redis eventconsumer
    entrypoints use the real UoW, and the message bus passes them onto our command
    handlers. If we add real and fake email classes, who will create them and pass
    them on?'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们改为显式声明所有这些依赖关系，谁会注入它们，以及如何注入？到目前为止，我们真的只是在传递UoW：我们的测试使用`FakeUnitOfWork`，而Flask和Redis事件消费者入口使用真正的UoW，并且消息总线将它们传递给我们的命令处理程序。如果我们添加真实和假的电子邮件类，谁会创建它们并传递它们？
- en: That’s extra (duplicated) cruft for Flask, Redis, and our tests. Moreover, putting
    all the responsibility for passing dependencies to the right handler onto the
    message bus feels like a violation of the SRP.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于Flask、Redis和我们的测试来说是额外的（重复的）累赘。此外，将所有传递依赖项到正确处理程序的责任都放在消息总线上，感觉像是违反了SRP。
- en: Instead, we’ll reach for a pattern called *Composition Root* (a bootstrap script
    to you and me),^([1](ch13.xhtml#idm45714881770184)) and we’ll do a bit of “manual
    DI” (dependency injection without a framework). See [Figure 13-3](#bootstrap_new_image).^([2](ch13.xhtml#idm45714881767896))
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将寻找一种称为*组合根*（对我们来说是引导脚本）的模式，^([1](ch13.xhtml#idm45714881770184))，我们将进行一些“手动DI”（无需框架的依赖注入）。请参阅[图13-3](#bootstrap_new_image)。^([2](ch13.xhtml#idm45714881767896))
- en: '![apwp 1303](Images/apwp_1303.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![apwp 1303](Images/apwp_1303.png)'
- en: Figure 13-3\. Bootstrapper between entrypoints and message bus
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-3。入口点和消息总线之间的引导程序
- en: 'Preparing Handlers: Manual DI with Closures and Partials'
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备处理程序：使用闭包和部分函数进行手动DI
- en: 'One way to turn a function with dependencies into one that’s ready to be called
    later with those dependencies *already injected* is to use closures or partial
    functions to compose the function with its dependencies:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将具有依赖关系的函数转换为一个准备好以后使用这些依赖项*已注入*的函数的方法之一是使用闭包或部分函数将函数与其依赖项组合起来：
- en: '*Examples of DI using closures or partial functions*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用闭包或部分函数进行DI的示例*'
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO3-1)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO3-1)'
- en: The difference between closures (lambdas or named functions) and `functools.partial`
    is that the former use [late binding of variables](https://docs.python-guide.org/writing/gotchas/#late-binding-closures),
    which can be a source of confusion if any of the dependencies are mutable.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包（lambda或命名函数）和`functools.partial`之间的区别在于前者使用[变量的延迟绑定](https://docs.python-guide.org/writing/gotchas/#late-binding-closures)，如果任何依赖项是可变的，这可能会导致混淆。
- en: 'Here’s the same pattern again for the `send_out_of_stock_notification()` handler,
    which has different dependencies:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`send_out_of_stock_notification()`处理程序的相同模式，它具有不同的依赖项：
- en: '*Another closure and partial functions example*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*另一个闭包和部分函数的例子*'
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: An Alternative Using Classes
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类的替代方法
- en: 'Closures and partial functions will feel familiar to people who’ve done a bit
    of functional programming. Here’s an alternative using classes, which may appeal
    to others. It requires rewriting all our handler functions as classes, though:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些有一些函数式编程经验的人来说，闭包和部分函数会让人感到熟悉。这里有一个使用类的替代方法，可能会吸引其他人。尽管如此，它需要将所有我们的处理程序函数重写为类：
- en: '*DI using classes*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用类进行DI*'
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO4-2)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO4-2)'
- en: The class is designed to produce a callable function, so it has a `*call*` method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 该类旨在生成可调用函数，因此它具有`*call*`方法。
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO4-1)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO4-1)'
- en: But we use the `init` to declare the dependencies it requires. This sort of
    thing will feel familiar if you’ve ever made class-based descriptors, or a class-based
    context manager that takes arguments.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们使用`init`来声明它需要的依赖项。如果您曾经制作过基于类的描述符，或者接受参数的基于类的上下文管理器，这种事情会让您感到熟悉。
- en: Use whichever you and your team feel more comfortable with.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您和您的团队感觉更舒适的那个。
- en: A Bootstrap Script
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导脚本
- en: 'We want our bootstrap script to do the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的引导脚本执行以下操作：
- en: Declare default dependencies but allow us to override them
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明默认依赖项，但允许我们覆盖它们
- en: Do the “init” stuff that we need to get our app started
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 做我们需要启动应用程序的“init”工作
- en: Inject all the dependencies into our handlers
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有依赖项注入到我们的处理程序中
- en: Give us back the core object for our app, the message bus
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给我们返回应用程序的核心对象，消息总线
- en: 'Here’s a first cut:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一步：
- en: '*A bootstrap function (src/allocation/bootstrap.py)*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个引导函数（src/allocation/bootstrap.py）*'
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO5-1)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO5-1)'
- en: '`orm.start_mappers()` is our example of initialization work that needs to be
    done once at the beginning of an app. We also see things like setting up the `logging`
    module.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`orm.start_mappers()`是我们需要在应用程序开始时执行一次的初始化工作的示例。我们还看到一些设置`logging`模块的事情。'
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO5-2)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO5-2)'
- en: We can use the argument defaults to define what the normal/production defaults
    are. It’s nice to have them in a single place, but sometimes dependencies have
    some side effects at construction time, in which case you might prefer to default
    them to `None` instead.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用参数默认值来定义正常/生产默认值。将它们放在一个地方很好，但有时依赖项在构建时会产生一些副作用，这种情况下，您可能更喜欢将它们默认为`None`。
- en: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO5-4)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO5-4)'
- en: We build up our injected versions of the handler mappings by using a function
    called `inject_dependencies()`, which we’ll show next.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用一个名为`inject_dependencies()`的函数来构建我们注入的处理程序映射的版本，接下来我们将展示它。
- en: '[![4](Images/4.png)](#co_dependency_injection__and_bootstrapping__CO5-6)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_dependency_injection__and_bootstrapping__CO5-6)'
- en: We return a configured message bus ready for use.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回一个配置好的消息总线，可以立即使用。
- en: 'Here’s how we inject dependencies into a handler function by inspecting it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们通过检查将依赖项注入处理程序函数的方法：
- en: '*DI by inspecting function signatures (src/allocation/bootstrap.py)*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过检查函数签名进行DI（src/allocation/bootstrap.py）*'
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO6-1)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO6-1)'
- en: We inspect our command/event handler’s arguments.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查我们的命令/事件处理程序的参数。
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO6-2)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO6-2)'
- en: We match them by name to our dependencies.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按名称将它们与我们的依赖项匹配。
- en: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO6-3)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO6-3)'
- en: We inject them as kwargs to produce a partial.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将它们作为kwargs注入以产生一个partial。
- en: Message Bus Is Given Handlers at Runtime
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息总线在运行时被赋予处理程序
- en: 'Our message bus will no longer be static; it needs to have the already-injected
    handlers given to it. So we turn it from being a module into a configurable class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的消息总线将不再是静态的；它需要已经注入的处理程序。因此，我们将其从模块转换为可配置的类：
- en: '*MessageBus as a class (src/allocation/service_layer/messagebus.py)*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*MessageBus作为一个类（src/allocation/service_layer/messagebus.py）*'
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO7-1)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO7-1)'
- en: The message bus becomes a class…
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 消息总线变成了一个类...
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO7-2)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO7-2)'
- en: …which is given its already-dependency-injected handlers.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '...它已经注入了依赖项。'
- en: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO7-4)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO7-4)'
- en: The main `handle()` function is substantially the same, with just a few attributes
    and methods moved onto `self`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的`handle()`函数基本相同，只是一些属性和方法移到了`self`上。
- en: '[![4](Images/4.png)](#co_dependency_injection__and_bootstrapping__CO7-5)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_dependency_injection__and_bootstrapping__CO7-5)'
- en: Using `self.queue` like this is not thread-safe, which might be a problem if
    you’re using threads, because the bus instance is global in the Flask app context
    as we’ve written it. Just something to watch out for.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样使用`self.queue`是不线程安全的，如果您使用线程可能会有问题，因为我们已经将总线实例在Flask应用程序上下文中全局化了。这是需要注意的问题。
- en: What else changes in the bus?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 总线中还有什么变化？
- en: '*Event and command handler logic stays the same (src/allocation/service_layer/messagebus.py)*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*事件和命令处理逻辑保持不变（src/allocation/service_layer/messagebus.py）*'
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO8-1)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO8-1)'
- en: '`handle_event` and `handle_command` are substantially the same, but instead
    of indexing into a static `EVENT_HANDLERS` or `COMMAND_HANDLERS` dict, they use
    the versions on `self`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle_event`和`handle_command`基本相同，但是不再索引静态的`EVENT_HANDLERS`或`COMMAND_HANDLERS`字典，而是使用`self`上的版本。'
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO8-2)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO8-2)'
- en: Instead of passing a UoW into the handler, we expect the handlers to already
    have all their dependencies, so all they need is a single argument, the specific
    event or command.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再将UoW传递给处理程序，我们期望处理程序已经具有了所有它们的依赖项，因此它们只需要一个参数，即特定的事件或命令。
- en: Using Bootstrap in Our Entrypoints
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的入口点中使用Bootstrap
- en: 'In our application’s entrypoints, we now just call `bootstrap.bootstrap()`
    and get a message bus that’s ready to go, rather than configuring a UoW and the
    rest of it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用程序的入口点中，我们现在只需调用`bootstrap.bootstrap()`，就可以得到一个准备就绪的消息总线，而不是配置UoW和其他内容：
- en: '*Flask calls bootstrap (src/allocation/entrypoints/flask_app.py)*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*Flask调用bootstrap（src/allocation/entrypoints/flask_app.py）*'
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO9-1)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO9-1)'
- en: We no longer need to call `start_orm()`; the bootstrap script’s initialization
    stages will do that.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要调用`start_orm()`；启动脚本的初始化阶段会处理这个问题。
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO9-2)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO9-2)'
- en: We no longer need to explicitly build a particular type of UoW; the bootstrap
    script defaults take care of it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要显式构建特定类型的UoW；启动脚本的默认值会处理这个问题。
- en: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO9-3)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO9-3)'
- en: And our message bus is now a specific instance rather than the global module.^([3](ch13.xhtml#idm45714880379080))
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的消息总线是一个特定的实例，而不是全局模块。^([3](ch13.xhtml#idm45714880379080))
- en: Initializing DI in Our Tests
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的测试中初始化DI
- en: 'In tests, we can use `bootstrap.bootstrap()` with overridden defaults to get
    a custom message bus. Here’s an example in an integration test:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我们可以使用`bootstrap.bootstrap()`并覆盖默认值以获得自定义消息总线。以下是集成测试中的一个示例：
- en: '*Overriding bootstrap defaults (tests/integration/test_views.py)*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*覆盖引导默认值（tests/integration/test_views.py）*'
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO10-1)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO10-1)'
- en: We do still want to start the ORM…
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实希望启动ORM…
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO10-2)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO10-2)'
- en: …because we’re going to use a real UoW, albeit with an in-memory database.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: …因为我们将使用真实的UoW，尽管使用的是内存数据库。
- en: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO10-3)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO10-3)'
- en: But we don’t need to send email or publish, so we make those noops.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不需要发送电子邮件或发布，所以我们将它们设置为noops。
- en: 'In our unit tests, in contrast, we can reuse our `FakeUnitOfWork`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的单元测试中，相反，我们可以重用我们的`FakeUnitOfWork`：
- en: '*Bootstrap in unit test (tests/unit/test_handlers.py)*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*在单元测试中引导（tests/unit/test_handlers.py）*'
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO11-1)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO11-1)'
- en: No need to start the ORM…
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要启动ORM…
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO11-2)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO11-2)'
- en: …because the fake UoW doesn’t use one.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: …因为虚假的UoW不使用它。
- en: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO11-3)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO11-3)'
- en: We want to fake out our email and Redis adapters too.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也想伪造我们的电子邮件和Redis适配器。
- en: So that gets rid of a little duplication, and we’ve moved a bunch of setup and
    sensible defaults into a single place.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就消除了一些重复，并且我们将一堆设置和合理的默认值移到了一个地方。
- en: 'Building an Adapter “Properly”: A Worked Example'
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “正确”构建适配器的示例
- en: To really get a feel for how it all works, let’s work through an example of
    how you might “properly” build an adapter and do dependency injection for it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正了解它是如何工作的，让我们通过一个示例来演示如何“正确”构建适配器并进行依赖注入。
- en: 'At the moment, we have two types of dependencies:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有两种类型的依赖关系：
- en: '*Two types of dependencies (src/allocation/service_layer/messagebus.py)*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*两种类型的依赖关系（src/allocation/service_layer/messagebus.py）*'
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO12-1)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO12-1)'
- en: The UoW has an abstract base class. This is the heavyweight option for declaring
    and managing your external dependency. We’d use this for the case when the dependency
    is relatively complex.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: UoW有一个抽象基类。这是声明和管理外部依赖关系的重量级选项。当依赖关系相对复杂时，我们将使用它。
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO12-2)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO12-2)'
- en: Our email sender and pub/sub publisher are defined as functions. This works
    just fine for simple dependencies.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的电子邮件发送器和发布/订阅发布者被定义为函数。这对于简单的依赖关系完全有效。
- en: 'Here are some of the things we find ourselves injecting at work:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在工作中发现自己注入的一些东西：
- en: An S3 filesystem client
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个S3文件系统客户端
- en: A key/value store client
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个键/值存储客户端
- en: A `requests` session object
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`requests`会话对象
- en: 'Most of these will have more-complex APIs that you can’t capture as a single
    function: read and write, GET and POST, and so on.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 其中大多数将具有更复杂的API，无法将其捕获为单个函数：读取和写入，GET和POST等等。
- en: Even though it’s simple, let’s use `send_mail` as an example to talk through
    how you might define a more complex dependency.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它很简单，但让我们以`send_mail`为例，讨论如何定义更复杂的依赖关系。
- en: Define the Abstract and Concrete Implementations
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义抽象和具体实现
- en: We’ll imagine a more generic notifications API. Could be email, could be SMS,
    could be Slack posts one day.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将想象一个更通用的通知API。可能是电子邮件，可能是短信，也可能是Slack帖子。
- en: '*An ABC and a concrete implementation (src/allocation/adapters/notifications.py)*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个ABC和一个具体的实现（src/allocation/adapters/notifications.py）*'
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We change the dependency in the bootstrap script:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在引导脚本中更改了依赖项：
- en: '*Notifications in message bus (src/allocation/bootstrap.py)*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*消息总线中的通知（src/allocation/bootstrap.py）*'
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Make a Fake Version for Your Tests
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为您的测试创建一个虚假版本
- en: 'We work through and define a fake version for unit testing:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过并为单元测试定义一个虚假版本：
- en: '*Fake notifications (tests/unit/test_handlers.py)*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚假通知（tests/unit/test_handlers.py）*'
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And we use it in our tests:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 并在我们的测试中使用它：
- en: '*Tests change slightly (tests/unit/test_handlers.py)*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*测试稍作更改（tests/unit/test_handlers.py）*'
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Figure Out How to Integration Test the Real Thing
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弄清楚如何集成测试真实的东西
- en: 'Now we test the real thing, usually with an end-to-end or integration test.
    We’ve used [MailHog](https://github.com/mailhog/MailHog) as a real-ish email server
    for our Docker dev environment:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们测试真实的东西，通常使用端到端或集成测试。我们在Docker开发环境中使用[MailHog](https://github.com/mailhog/MailHog)作为真实的电子邮件服务器：
- en: '*Docker-compose config with real fake email server (docker-compose.yml)*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*具有真实虚假电子邮件服务器的Docker-compose配置（docker-compose.yml）*'
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In our integration tests, we use the real `EmailNotifications` class, talking
    to the MailHog server in the Docker cluster:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的集成测试中，我们使用真正的`EmailNotifications`类，与Docker集群中的MailHog服务器通信：
- en: '*Integration test for email (tests/integration/test_email.py)*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*电子邮件的集成测试（tests/integration/test_email.py）*'
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO13-1)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_dependency_injection__and_bootstrapping__CO13-1)'
- en: We use our bootstrapper to build a message bus that talks to the real notifications
    class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用我们的引导程序构建一个与真实通知类交互的消息总线。
- en: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO13-2)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_dependency_injection__and_bootstrapping__CO13-2)'
- en: We figure out how to fetch emails from our “real” email server.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们弄清楚如何从我们的“真实”电子邮件服务器中获取电子邮件。
- en: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO13-3)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_dependency_injection__and_bootstrapping__CO13-3)'
- en: We use the bus to do our test setup.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用总线来进行测试设置。
- en: '[![4](Images/4.png)](#co_dependency_injection__and_bootstrapping__CO13-4)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_dependency_injection__and_bootstrapping__CO13-4)'
- en: Against all the odds, this actually worked, pretty much at the first go!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 出乎意料的是，这实际上非常顺利地完成了！
- en: And that’s it really.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。
- en: Wrap-Up
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Once you have more than one adapter, you’ll start to feel a lot of pain from
    passing dependencies around manually, unless you do some kind of *dependency injection.*
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了多个适配器，除非你进行某种*依赖注入*，否则手动传递依赖关系会让你感到很痛苦。
- en: Setting up dependency injection is just one of many typical setup/initialization
    activities that you need to do just once when starting your app. Putting this
    all together into a *bootstrap script* is often a good idea.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 设置依赖注入只是在启动应用程序时需要做的许多典型设置/初始化活动之一。将所有这些放在一个*引导脚本*中通常是一个好主意。
- en: The bootstrap script is also good as a place to provide sensible default configuration
    for your adapters, and as a single place to override those adapters with fakes
    for your tests.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 引导脚本也是一个很好的地方，可以为适配器提供合理的默认配置，并且作为一个单一的地方，可以用虚假的适配器覆盖测试。
- en: A dependency injection framework can be useful if you find yourself needing
    to do DI at multiple levels—if you have chained dependencies of components that
    all need DI, for example.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己需要在多个级别进行DI，例如，如果你有一系列组件的链式依赖需要DI，那么依赖注入框架可能会很有用。
- en: This chapter also presented a worked example of changing an implicit/simple
    dependency into a “proper” adapter, factoring out an ABC, defining its real and
    fake implementations, and thinking through integration testing.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还提供了一个实际示例，将隐式/简单的依赖关系改变为“适当”的适配器，将ABC分离出来，定义其真实和虚假的实现，并思考集成测试。
- en: These were the last patterns we wanted to cover, which brings us to the end
    of [Part II](part02.xhtml#part2). In [the epilogue](afterword01.xhtml#epilogue_1_how_to_get_there_from_here),
    we’ll try to give you some pointers for applying these techniques in the Real
    World^(TM).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们想要覆盖的最后几个模式，这将我们带到了[第二部分](part02.xhtml#part2)的结尾。在[结语](afterword01.xhtml#epilogue_1_how_to_get_there_from_here)中，我们将尝试为您提供一些在现实世界中应用这些技术的指导。
- en: ^([1](ch13.xhtml#idm45714881770184-marker)) Because Python is not a “pure” OO
    language, Python developers aren’t necessarily used to the concept of needing
    to *compose* a set of objects into a working application. We just pick our entrypoint
    and run code from top to bottom.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch13.xhtml#idm45714881770184-marker)) 因为Python不是一个“纯”面向对象的语言，Python开发人员并不一定习惯于需要将一组对象*组合*成一个工作应用程序的概念。我们只是选择我们的入口点，然后从上到下运行代码。
- en: ^([2](ch13.xhtml#idm45714881767896-marker)) Mark Seemann calls this [*Pure DI*](https://oreil.ly/iGpDL)
    or sometimes *Vanilla DI*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '^([2](ch13.xhtml#idm45714881767896-marker)) Mark Seemann将这称为[*Pure DI*](https://oreil.ly/iGpDL)，有时也称为*Vanilla
    DI*。 '
- en: ^([3](ch13.xhtml#idm45714880379080-marker)) However, it’s still a global in
    the `flask_app` module scope, if that makes sense. This may cause problems if
    you ever find yourself wanting to test your Flask app in-process by using the
    Flask Test Client instead of using Docker as we do. It’s worth researching [Flask
    app factories](https://oreil.ly/_a6Kl) if you get into this.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch13.xhtml#idm45714880379080-marker)) 但是，如果有意义的话，它仍然是`flask_app`模块范围内的全局变量。如果你想要使用Flask测试客户端而不是像我们一样使用Docker来测试你的Flask应用程序，这可能会导致问题。如果你遇到这种情况，值得研究[Flask应用程序工厂](https://oreil.ly/_a6Kl)。

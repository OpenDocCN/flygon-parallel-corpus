- en: Chapter 3. Advanced Playbooks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。高级playbooks
- en: 'The playbooks that we have looked at so far are simple and just run a number
    of modules in order. Ansible allows much more control over the execution of your
    playbook. Using the following techniques, you should be able to perform even the
    most complex deployments:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的playbooks都很简单，只是按顺序运行了一些模块。Ansible允许更多地控制playbook的执行。使用以下技术，你应该能够执行甚至最复杂的部署：
- en: Running operations in parallel
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行运行操作
- en: Looping
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环
- en: Conditional execution
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件执行
- en: Task delegation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务委派
- en: Extra variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外变量
- en: Finding files with variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量查找文件
- en: Environment variables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量
- en: External data lookups
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部数据查找
- en: Storing data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储数据
- en: Processing data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理数据
- en: Debugging playbooks
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试playbooks
- en: Running operations in parallel
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行运行操作
- en: By default, Ansible will only fork up to five times, so it will only run an
    operation on five different machines at once. If you have a large number of machines,
    or you have lowered this maximum fork value, then you may want to launch things
    asynchronously. Ansible's method for performing this is to launch the task and
    then poll for it to complete. This allows Ansible to start the job across all
    the required machines while still using the maximum forks.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ansible最多只会分叉五次，因此一次只会在五台不同的机器上运行一个操作。如果你有大量的机器，或者你已经降低了最大分叉值，那么你可能希望异步启动任务。Ansible执行此操作的方法是启动任务，然后轮询以等待其完成。这允许Ansible在所有所需的机器上启动作业，同时仍然使用最大分叉。
- en: To run an operation in parallel, use the `async` and `poll` keywords. The `async`
    keyword triggers Ansible to run the job in parallel, and its value will be the
    maximum time that Ansible will wait for the command to complete. The value of
    `poll` indicates to Ansible how often to poll to check if the command has been
    completed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要并行运行操作，请使用`async`和`poll`关键字。`async`关键字触发Ansible并行运行任务，并且它的值将是Ansible等待命令完成的最长时间。`poll`的值表示Ansible轮询检查命令是否已完成的频率。
- en: 'If you wanted to run `updatedb` across an entire cluster of machines, it might
    look like the following code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在整个机群上运行`updatedb`，代码可能如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will notice that when you run the previous example on more than five machines,
    the `yum` module acts differently to the `command` module. The `yum` module will
    run on the first five machines, then the next five, and so on. The `command` module,
    however, will run across all the machines and indicate the status once complete.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在超过五台机器上运行前面的例子时，你会注意到`yum`模块的行为与`command`模块不同。`yum`模块将在前五台机器上运行，然后在下一个五台机器上运行，依此类推。然而，`command`模块将在所有机器上运行，并在完成后指示状态。
- en: If your command starts a daemon that eventually listens on a port, you can start
    it without polling so that Ansible does not check for it to complete. You can
    then carry on with other actions and check for completion later using the `wait_for`
    module. To configure Ansible to not wait for the job to complete, set the value
    of `poll` to `0`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的命令启动了最终监听端口的守护进程，你可以启动它而不轮询，这样Ansible就不会检查它是否完成。然后你可以继续其他操作，并稍后使用`wait_for`模块检查完成情况。要配置Ansible不等待任务完成，将`poll`的值设置为`0`。
- en: Finally, if your task takes an extremely long time to run, you can tell Ansible
    to wait for the job as long as it takes. To do this, set the value of `async`
    to `0`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你的任务运行时间非常长，你可以告诉Ansible等待任务完成的时间。为此，将`async`的值设置为`0`。
- en: 'You will want to use Ansible''s polling in the following situations:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，你将想要使用Ansible的轮询：
- en: You have a long-running task that may hit the timeout
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个可能会超时的长时间任务
- en: You need to run an operation across a large number of machines
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要在大量机器上运行一个操作
- en: You have an operation for which you don't need to wait to complete
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个不需要等待完成的操作
- en: 'There are also a few situations where you should not use `async` or `poll`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些情况，你不应该使用`async`或`poll`：
- en: If your job acquires locks that prevent other things from running
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的任务获取了锁，阻止其他任务运行
- en: Your job only takes a short time to run
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的任务只需要很短的时间运行
- en: Looping
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: Ansible allows you to repeat a module several times with different inputs, for
    example, if you had several files that should have similar permissions set. This
    can save you a lot of repetition and allows you to iterate over facts and variables.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible允许你多次重复使用一个模块，例如，如果你有几个应该设置相似权限的文件。这可以节省大量重复工作，并允许你迭代facts和variables。
- en: To do this, you can use the `with_items` key on an action and set the value
    to the list of items that you are going to iterate over. This will create a variable
    for the module named `item`, which will be set to each item in turn as your module
    is iterated over. Some modules such as `yum` will optimize this so that instead
    of doing a separate transaction for each package, they will operate on all of
    them at once.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，你可以在操作上使用`with_items`关键字，并将值设置为你要迭代的项目列表。这将为模块创建一个名为`item`的变量，该变量将被设置为模块迭代时依次设置的每个项目。一些模块，如`yum`，将对此进行优化，以便它们不会为每个软件包执行单独的事务，而是一次性操作所有软件包。
- en: 'Using `with_items`, the code looks like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`with_items`，代码如下：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In addition to looping over fixed items, or a variable, Ansible also provides
    us a tool called **lookup plugins**. These plugins allow you to tell Ansible to
    fetch the data from somewhere externally. For example, you might want to find
    all the files that match a particular pattern, and then upload them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了循环固定的项目或变量之外，Ansible还为我们提供了一个称为**lookup插件**的工具。这些插件允许你告诉Ansible从外部某处获取数据。例如，你可能想要找到所有匹配特定模式的文件，然后上传它们。
- en: 'In this example, we upload all the public keys in a directory and then assemble
    them into an `authorized_keys` file for the root user, as shown in the following
    example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们上传目录中的所有公钥，然后将它们组合成root用户的`authorized_keys`文件，如下例所示：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Repeating modules can be used in the following situations:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下情况下使用重复模块：
- en: Repeating a module many times with similar settings
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating over all the values of a list
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating many files for later use with the `assemble` module to combine into
    one large file
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying a directory of files when combined with the `with_fileglob` lookup plugin
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional execution
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some modules, such as the `copy` module, provide mechanisms to configure it
    to skip the execution of the module. You can also configure your own skip conditions
    that will only execute the module if they resolve to `true`. This can be handy
    if your servers use different packaging systems or have different filesystem layouts.
    It can also be used with the `set_fact` module to allow you to compute many different
    things.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: To skip a module, you can use the `when` key; this lets you provide a condition.
    If the condition you set resolves to false, then the module will be skipped. The
    value that you assign to `when` is a Python expression. You can use any of the
    variables or facts available to you at this point.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to process some of the items in the list depending on a condition,
    then simply use the `when` clause. The `when` clause is processed separately for
    each item in the list; the item being processed is available as a variable using
    `{{ item }}`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The following code is an example showing how to choose between `apt` and `yum`
    for both Debian and Red Hat systems.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There is also a third clause to print a message and fail if the OS is not recognized.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This feature can be used to pause at a particular point and will wait for the
    user intervention to continue. Normally, when Ansible encounters an error, it
    will simply stop what it is doing without running any handlers. With this feature,
    you can add the `pause` module with a condition on it that triggers in unexpected
    situations. This way the `pause` module will be ignored in a normal situation;
    however, in unexpected circumstances, it will allow the user to intervene and
    continue when it is safe to do so. The task would look like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are numerous uses of skipping actions; here are a few of them:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Working around differences in operating systems
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prompting a user and only then performing actions that they request
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving performance by avoiding a module that you know won't change anything
    but may take a while to do so
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refusing to alter systems that have a particular file present
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking if custom scripts have already been run
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task delegation
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible, by default, runs its tasks all at once on the configured machine. This
    is great when you have a whole bunch of separate machines to configure, or if
    each of your machines is responsible for communicating its status to the other
    remote machines. However, if you need to perform an action on a different host
    than the one Ansible is operating on, you can use a delegation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Ansible can be configured to run a task on a different host other than the one
    that is being configured using the `delegate_to` key. The module will still run
    once for every machine, but instead of running on the target machine, it will
    run on the delegated host. The facts available will be the ones applicable to
    the current host. Here, we show a playbook that will use the `get_url` option
    to download the configuration from a bunch of web servers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you are delegating to the `localhost`, you can use a shortcut when defining
    the action that automatically uses the local machine. If you define the key of
    the action line as `local_action`, then the delegation to `localhost` is implied.
    If we were to have used this in the previous example, it would be slightly shorter
    and will look like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Delegation is not limited to the local machine. You can delegate to any host
    that is in the inventory. Some other reasons why you might want to delegate are:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Removing a host from a load balancer before deployment
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing DNS to direct traffic away from a server you are about to change
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an iSCSI volume on a storage device
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an external server to check whether access outside the network works
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外部服务器检查网络外部访问是否正常工作
- en: Extra variables
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外变量
- en: You may have seen in our template example in the previous chapter that we used
    a variable named `group_names`. This is one of the magic variables that are provided
    by Ansible itself. At the time of writing, there are seven such variables, which
    are described in the upcoming sections.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经在上一章的模板示例中看到我们使用了一个名为`group_names`的变量。这是Ansible本身提供的魔术变量之一。在撰写本文时，有七个这样的变量，这些变量将在接下来的章节中描述。
- en: The hostvars variable
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: hostvars变量
- en: The `hostvars` variable allows you to retrieve variables of all the hosts that
    the current play has dealt with. If the `setup` module hasn't yet been run on
    that managed host in the current play, only its variables will be available. You
    can access it like you would access other complex variables, such as `${hostvars.hostname.fact}`,
    so to get the Linux distribution running on a server named `ns1`, it would be
    `${hostvars.ns1.ansible_distribution}`. The following example sets a variable
    called zone master to the server named `ns1`. It then calls the `template` module,
    which would use this to set the masters for each zone.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`hostvars`变量允许您检索当前play已处理的所有主机的变量。如果在当前play中尚未在受管主机上运行`setup`模块，则只有其变量可用。您可以像访问其他复杂变量一样访问它，例如`${hostvars.hostname.fact}`，因此要获取名为`ns1`的服务器上运行的Linux发行版，它将是`${hostvars.ns1.ansible_distribution}`。以下示例将一个名为zone
    master的变量设置为名为`ns1`的服务器。然后调用`template`模块，该模块将使用此设置每个区域的主服务器。'
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using `hostvars`, you can further abstract templates from your environment.
    If you nest your variable calls, then instead of placing an IP address in the
    variable section of the play, you can add the hostname. To find the address of
    a machine named in the `the_machine` variable you would use, `{{ hostvars.[the_machine].default_ipv4.address
    }}`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`hostvars`，您可以进一步将模板与环境分离。如果您嵌套变量调用，那么在play的变量部分放置IP地址的地方，您可以添加主机名。要查找名为`the_machine`变量中的机器的地址，您可以使用`{{
    hostvars.[the_machine].default_ipv4.address }}`。
- en: The groups variable
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: groups变量
- en: The `groups` variable contains a list of all hosts in the inventory grouped
    by the inventory group. This lets you get access to all the hosts that you have
    configured. This is potentially a very powerful tool. It allows you to iterate
    across a whole group and for every host apply an action to the current machine.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`groups`变量包含按清单组分组的所有主机的列表。这使您可以访问您配置的所有主机。这是一个潜力非常强大的工具。它允许您在整个组中进行迭代，并对每个主机应用当前机器的操作。'
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `groups` variable does not contain the actual hosts in the group; it contains
    strings representing their names in the inventory. This means you have to use
    nested variable expansion to get to the `hostvars` variable, if needed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`groups`变量不包含组中的实际主机；它包含表示其在清单中的名称的字符串。这意味着如果需要，您必须使用嵌套变量扩展来访问`hostvars`变量。'
- en: 'You can even use this variable to create the `known_hosts` files for all of
    your machines containing the `host` keys of all the other machines. This would
    allow you to then SSH from one machine to another without confirming the identity
    of the remote host. It would also handle removing machines when they leave service
    or updating them when they are replaced. The following is a template for a `known_hosts`
    file that does this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以使用此变量为包含所有其他机器的`host`密钥的所有机器创建`known_hosts`文件。这将允许您从一台机器SSH到另一台机器，而无需确认远程主机的身份。它还将在机器离开服务或更换机器时处理删除机器或更新机器。以下是执行此操作的`known_hosts`文件的模板：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The playbook that uses this template would look like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此模板的playbook将如下所示：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The group_names variable
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: group_names变量
- en: The `group_names` variable contains a list of strings with the names of all
    the groups the current host is in. This is not only useful for debugging, but
    also for conditionals detecting group membership. This was used in the last chapter
    to set up a nameserver.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`group_names`变量包含当前主机所在的所有组的名称列表。这不仅对于调试很有用，而且对于检测组成员资格的条件也很有用。这在上一章中用于设置域名服务器。'
- en: 'This variable is mostly useful for skipping a task or in a template as a condition.
    For instance, if you had two configurations for the SSH daemon, one secure and
    one less secure, but you only wanted the secure configuration on the machines
    in the secure group, you would do it like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此变量主要用于跳过任务或在模板中作为条件。例如，如果SSH守护程序有两种配置，一种安全，一种不太安全，但您只想在安全组中的机器上使用安全配置，您可以这样做：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the previous example, we used the `set_fact` module to set the fact for each
    case, and then used the `copy` module. We could have used the `copy` module in
    place of the `set_facts` modules and used one fewer task. The reason this was
    done is that the `set_fact` module runs locally and the `copy` module runs remotely.
    When you use the `set_facts` module first and only call the `copy` module once,
    the copies are made on all the machines in parallel. If you used two `copy` modules
    with conditions, then each would execute on the relevant machines separately.
    Since `copy` is the longer task of the two, it benefits the most from running
    in parallel.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们使用`set_fact`模块为每种情况设置事实，然后使用`copy`模块。我们本可以在`set_facts`模块的位置使用`copy`模块，并少使用一个任务。之所以这样做是因为`set_fact`模块在本地运行，而`copy`模块在远程运行。当您首先使用`set_facts`模块并仅调用一次`copy`模块时，副本将并行在所有机器上制作。如果使用两个带条件的`copy`模块，那么每个都将在相关机器上单独执行。由于`copy`是这两个任务中较长的任务，因此它最能从并行运行中受益。
- en: The inventory_hostname variable
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: inventory_hostname变量
- en: The `inventory_hostname` variable stores the hostname of the server as recorded
    in the inventory. You should use this if you have chosen not to run the `setup`
    module on the current host, or if for various reasons, the value detected by the
    `setup` module is not correct. This is useful when you are doing the initial setup
    of the machine and changing the hostname.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`inventory_hostname`变量存储了在清单中记录的服务器的主机名。如果你选择不在当前主机上运行`setup`模块，或者由于各种原因，`setup`模块检测到的值不正确，你应该使用这个。当你正在进行机器的初始设置并更改主机名时，这很有用。'
- en: The inventory_hostname_short variable
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: inventory_hostname_short变量
- en: The `inventory_hostname_short` variable is the same as the previous variable;
    however, it only includes the characters up to the first dot. So for `host.example.com`,
    it would return `host`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`inventory_hostname_short`变量与前一个变量相同；但是，它只包括第一个点之前的字符。因此对于`host.example.com`，它将返回`host`。'
- en: The inventory_dir variable
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: inventory_dir变量
- en: The `inventory_dir` variable is the path name of the directory containing the
    inventory file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`inventory_dir`变量是包含清单文件的目录的路径名。'
- en: The inventory_file variable
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: inventory_file变量
- en: The `inventory_file` variable is the same as the previous one, except that it
    also includes the filename.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`inventory_file`变量与前一个变量相同，只是它还包括文件名。'
- en: Finding files with variables
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用变量查找文件
- en: 'All modules can take variables as part of their arguments by dereferencing
    them with `{{` and `}}`. You can use this to load a particular file based on a
    variable. For example, you might want to select a different `config` file for
    NRPE (a Nagios check daemon) based on the architecture in use. Here is how that
    would look:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模块都可以通过解引用`{{`和`}}`将变量作为其参数的一部分。你可以使用这个基于变量加载特定文件。例如，你可能想要根据使用的架构选择不同的`config`文件用于NRPE（Nagios检查守护程序）。以下是它的样子：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the `copy` and the `template` modules, you can also configure Ansible to
    look for a set of files, and it finds them using the first one. This lets you
    configure a file to look for; if that file is not found, a second will be used,
    and so on until the end of the list is reached. If the file is not found, then
    the module will fail. The feature is triggered using the `first_available_file`
    key, and referencing `{{ item }}` in the action. The following code is an example
    of this feature:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`copy`和`template`模块中，你还可以配置Ansible查找一组文件，并且它会使用找到的第一个文件。这让你可以配置一个要查找的文件；如果找不到该文件，将使用第二个文件，依此类推直到列表末尾。如果找不到文件，那么模块将失败。该功能使用`first_available_file`键触发，并在操作中引用`{{
    item }}`。以下代码是此功能的示例：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Remember that you can run the setup module from the Ansible command-line tool.
    This comes in handy when you are making heavy use of variables in your playbooks
    or templates. To check what facts will be available for a particular play, simply
    copy the value of the host pattern and run the following command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 记住你可以从Ansible命令行工具运行setup模块。当你在playbooks或模板中大量使用变量时，这非常方便。要检查特定play可用的事实，只需复制主机模式的值并运行以下命令：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: On a CentOS x86_64 machine, this configuration will first look for the `RedHat-x86_64.cfg`
    file upon navigating through `files/apache/`. If that file does not exist, it
    will look for the `default-x86_64.cfg` file upon navigating through `file/apache/`,
    and finally if nothing exists, it'll try and use `default.cfg`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS x86_64机器上，这个配置将首先在通过`files/apache/`导航时查找`RedHat-x86_64.cfg`文件。如果该文件不存在，它将在通过`file/apache/`导航时查找`default-x86_64.cfg`文件，最后如果什么都不存在，它将尝试使用`default.cfg`。
- en: Environment variables
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境变量
- en: Often, Unix commands take advantage of certain environment variables. Prevalent
    examples of this are C makefiles, installers, and the AWS command-line tools.
    Fortunately, Ansible makes this really easy. If you want to upload a file on the
    remote machine to Amazon S3, you can set the Amazon access key as follows. You
    will also see that we install EPEL so that we can install pip, and pip is used
    to install the AWS tools.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Unix命令利用某些环境变量。这些的普遍例子是C makefiles、安装程序和AWS命令行工具。幸运的是，Ansible使这变得非常容易。如果你想要在远程机器上上传文件到Amazon
    S3，你可以设置Amazon访问密钥如下。你还会看到我们安装EPEL以便安装pip，而pip用于安装AWS工具。
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Internally, Ansible sets the environment variable into the Python code; this
    means any module that already uses environment variables can take advantage of
    the ones set here. If you write your own modules, you should consider if certain
    arguments would be better used as environment variables instead of arguments.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Ansible将环境变量设置到Python代码中；这意味着任何已经使用环境变量的模块都可以利用这里设置的变量。如果你编写自己的模块，你应该考虑某些参数是否最好作为环境变量而不是参数来使用。
- en: 'Some Ansible modules, such as `get_url`, `yum`, and `apt`, will also use environment
    variables to set their proxy server. Some of the other situations where you might
    want to set environment variables are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Ansible模块，如`get_url`、`yum`和`apt`，也会使用环境变量来设置它们的代理服务器。你可能希望设置环境变量的其他情况包括：
- en: Running application installers
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行应用程序安装程序
- en: Adding extra items to the path when using the `shell` module
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用`shell`模块时将额外项添加到路径
- en: Loading libraries from a place not included in the system library search path
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从系统库搜索路径中未包含的位置加载库
- en: Using an `LD_PRELOAD` hack while running a module
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行模块时使用`LD_PRELOAD`黑客
- en: External data lookups
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部数据查找
- en: Ansible introduced the lookup plugins in version 0.9\. These plugins allow Ansible
    to fetch data from outside sources. Ansible provides several plugins, but you
    can also write your own. This really opens the doors and allows you to be flexible
    in your configuration.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible在0.9版中引入了查找插件。这些插件允许Ansible从外部源获取数据。Ansible提供了几个插件，但你也可以编写自己的插件。这真的打开了大门，让你在配置中更加灵活。
- en: 'Lookup plugins are written in Python and run on the controlling machine. They
    are executed in two different ways: direct calls and `with_*` keys. Direct calls
    are useful when you want to use them like you would use variables. Using the `with_*`
    keys is useful when you want to use them as loops. In an earlier section, we covered
    `with_fileglob`, which is an example of this.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 查找插件是用Python编写的，并在控制机器上运行。它们以两种不同的方式执行：直接调用和`with_*`键。直接调用在您想像变量一样使用它们时很有用。使用`with_*`键在您想要将它们用作循环时很有用。在前面的部分中，我们介绍了`with_fileglob`，这是一个示例。
- en: In the next example, we use a lookup plugin directly to get the `http_proxy`
    value from `environment` and send it through to the configured machine. This makes
    sure that the machines we are configuring will use the same proxy server to download
    the file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们直接使用查找插件从`environment`中获取`http_proxy`的值，并将其发送到配置的机器。这确保我们正在配置的机器将使用相同的代理服务器下载文件。
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can also use lookup plugins in the variable section. This doesn't immediately
    lookup the result and put it in the variable as you might assume; instead, it
    stores it as a macro and looks it up every time you use it. This is good to know
    if you are using something, the value of which might change over time.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在变量部分使用查找插件。这不会立即查找结果并将其放入变量中，而是将其存储为宏，并在每次使用时查找。如果您使用的值可能随时间变化，这是很重要的。
- en: Using lookup plugins in the `with_*` form will allow you to iterate over things
    you wouldn't normally be able to. You can use any plugin like this, but ones that
    return a list are most useful. In the following code, we show how to dynamically
    register a `webapp` farm.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`with_*`形式中使用查找插件将允许您迭代通常无法迭代的内容。您可以使用任何此类插件，但返回列表的插件最有用。在下面的代码中，我们展示了如何动态注册`webapp`
    farm。
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you were using this example, you would append a task to create each as a
    virtual machine and then a new play to configure each of them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用此示例，您将附加一个任务来创建每个虚拟机，然后创建一个新的play来配置它们。
- en: 'Situations where lookup plugins are useful are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 查找插件有用的情况如下：
- en: Copying a whole directory of Apache config to a `conf.d` style directory
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将整个Apache配置目录复制到`conf.d`样式目录
- en: Using environment variables to adjust what the playbooks does
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用环境变量来调整playbook的操作
- en: Getting configuration from DNS TXT records
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从DNS TXT记录获取配置
- en: Fetching the output of a command into a variable
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将命令的输出获取到一个变量中
- en: Storing results
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储结果
- en: Almost every module outputs something, even the `debug` module. Most of the
    time, the only variable used is the one named `changed`. The `changed` variable
    helps Ansible decide whether to run handlers or not and which color to print the
    output in. However, if you wish to, you can store the returned values and use
    them later in the playbook. In this example, we look at the mode in the `/tmp`
    directory and create a new directory named `/tmp/subtmp` with the same mode as
    shown here.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个模块都会输出一些内容，即使是`debug`模块也是如此。大多数情况下，唯一使用的变量是名为`changed`的变量。`changed`变量帮助Ansible决定是否运行处理程序，以及输出的颜色。但是，如果您希望，可以存储返回的值并在以后的playbook中使用它们。在这个例子中，我们查看`/tmp`目录中的模式，并创建一个名为`/tmp/subtmp`的新目录，其模式与此处显示的相同。
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Some modules, such as the `file` module in the previous example, can be configured
    to simply give information. By combining this with the register feature, you can
    create playbooks that can examine the environment and calculate how to proceed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一些模块，例如前面示例中的`file`模块，可以配置为仅提供信息。通过结合注册功能，您可以创建可以检查环境并计算如何进行的playbook。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Combining the register feature and the `set_fact` module allows you to perform
    data processing on data you receive back from the modules. This allows you to
    compute values and perform data processing on these values. This makes your playbooks
    even smarter and more flexible than ever.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 结合注册功能和`set_fact`模块允许您对从模块返回的数据进行数据处理。这使您能够计算值并对这些值执行数据处理。这使您的playbook比以往更加智能和灵活。
- en: 'Register allows you to make your own facts about hosts from modules already
    available to you. This can be useful in many different circumstances:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注册允许您根据您已经可用的模块为主机创建自己的事实。这在许多不同的情况下都很有用：
- en: Getting a list of files in a remote directory and downloading them all with
    fetch
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取远程目录中的文件列表并使用fetch下载它们
- en: Running a task when a previous task changes, before the handlers run
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前一个任务更改时运行任务，然后运行处理程序
- en: Getting the contents of the remote host SSH key and building a `known_hosts`
    file
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取远程主机SSH密钥的内容并构建`known_hosts`文件
- en: Processing data
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数据
- en: 'Ansible uses Jinja2 filters to allow you to transform data in ways that aren''t
    possible with basic templates. We use filters when the data available to us in
    our playbooks is not in the format we want, or require further complex processing
    before it can be used with modules or templates. Filters can be used anywhere
    we would normally use a variable, such as in templates, as arguments to modules,
    and in conditionals. Filters are used by providing the variable name, a pipe character,
    and then the filter name. We can use multiple filter names separated with pipe
    characters to use multiple pipes, which are then applied left to right. Here is
    an example where we ensure that all users are created with lowercase usernames:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible使用Jinja2过滤器允许您以基本模板无法实现的方式转换数据。当playbooks中可用的数据不是我们想要的格式，或者在可以与模块或模板一起使用之前需要进一步的复杂处理时，我们使用过滤器。过滤器可以用于我们通常使用变量的任何地方，例如在模板中，作为模块的参数以及在条件语句中。通过提供变量名称、管道字符，然后是过滤器名称来使用过滤器。我们可以使用多个过滤器名称，用管道字符分隔，以使用多个管道，然后从左到右应用。下面是一个示例，我们确保所有用户都使用小写用户名创建：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here are a few popular filters that you may find useful:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些您可能会发现有用的流行过滤器：
- en: '| Filter | Description |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 过滤器 | 描述 |'
- en: '| --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `min` | When the argument is a list it returns only the smallest value. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `min` | 当参数是一个列表时，它只返回最小值。 |'
- en: '| `max` | When the argument is a list it returns only the largest value. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `max` | 当参数是一个列表时，仅返回最大值。|'
- en: '| `random` | When the argument is a list it picks a random item from the list.
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `random` | 当参数是一个列表时，它会从列表中随机选择一个项目。|'
- en: '| `changed` | When used on a variable created with the register keyword, it
    returns `true` if the task changed anything; otherwise, it returns `false`. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `changed` | 当在使用register关键字创建的变量上使用时，如果任务更改了任何内容，则返回`true`；否则返回`false`。|'
- en: '| `failed` | When used on a variable created with the register keyword, it
    returns `true` if the task failed; otherwise, it returns `false`. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `failed` | 当在使用register关键字创建的变量上使用时，如果任务失败，则返回`true`；否则返回`false`。|'
- en: '| `skipped` | When used on a variable created with the register keyword, it
    returns `true` if the task changed anything; otherwise, it returns `false`. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `skipped` | 当在使用register关键字创建的变量上使用时，如果任务更改了任何内容，则返回`true`；否则返回`false`。|'
- en: '| `default(X)` | If the variable does not exist, then the value of X will be
    used instead. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `default(X)` | 如果变量不存在，则将使用X的值。|'
- en: '| `unique` | When the argument is a list, return a list without any duplicate
    items. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `unique` | 当参数是一个列表时，返回一个没有重复项的列表。|'
- en: '| `b64decode` | Convert the base64 encoded string in the variable to its binary
    representation. This is useful with the slurp modules, as it returns its data
    as a base64 encoded string. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `b64decode` | 将变量中的base64编码字符串转换为其二进制表示。这在与slurp模块一起使用时非常有用，因为它将其数据作为base64编码的字符串返回。|'
- en: '| `replace(X, Y)` | Return a copy of the string with any occurrences of `X`
    replaced by `Y`. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `replace(X, Y)` | 返回一个将字符串中任何出现的`X`替换为`Y`的副本。|'
- en: '| `join(X)` | When the variable is a list, return a string with all the entries
    separated by `X`. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `join(X)` | 当变量是一个列表时，返回一个所有条目由`X`分隔的字符串。|'
- en: Debugging playbooks
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试playbooks
- en: There are a few ways in which you can debug a playbook. Ansible includes both
    a verbose mode and a `debug` module specifically for debugging. You can also use
    modules such as `fetch` and `get_url` for help. These debugging techniques can
    also be used to examine how modules behave when you wish to learn how to use them.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以调试playbook。Ansible包括冗长模式和专门用于调试的`debug`模块。您还可以使用`fetch`和`get_url`等模块进行帮助。这些调试技术也可以用于检查模块在您希望学习如何使用它们时的行为。
- en: The debug module
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试模块
- en: Using the `debug` module is really quite simple. It takes two optional arguments,
    `msg` and `fail.msg` to set the message that will be printed by the module and
    `fail`, if set to `yes`, indicates a failure to Ansible, which will cause it to
    stop processing the playbook for that host. We used this module earlier in the
    skipping modules section to bail out of a playbook if the operating system was
    not recognized.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`debug`模块非常简单。它接受两个可选参数，`msg`和`fail.msg`，用于设置模块将打印的消息和`fail`，如果设置为`yes`，则表示对Ansible的失败，这将导致它停止处理该主机的playbook。我们在前面的跳过模块部分中使用了此模块，以便在操作系统未被识别时退出playbook。
- en: 'In the following example, we will show how to use the `debug` module to list
    all the interfaces available on the machine:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将展示如何使用`debug`模块列出机器上所有可用的接口：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code gives the following output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码给出了以下输出：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, the `debug` module is easy to use to see the current value of
    a variable during the play.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`debug`模块很容易用于查看play期间变量的当前值。
- en: The verbose mode
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 冗长模式
- en: 'Your other option for debugging is the verbose option. When running Ansible
    with verbose, it prints out all the values that were returned by each module after
    it runs. This is especially useful if you are using the `register` keyword introduced
    in the previous section. To run `ansible-playbook` in verbose mode, simply add
    `--verbose` to your command line as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 调试的另一个选项是冗长选项。当使用冗长模式运行Ansible时，它会在运行后打印出每个模块返回的所有值。如果您在上一节中使用了`register`关键字，则这将特别有用。要在冗长模式下运行`ansible-playbook`，只需在命令行中添加`--verbose`即可。
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The check mode
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查模式
- en: In addition to the verbose mode, Ansible also includes a check mode and a diff
    mode. You can use the check mode by adding `--check` to the command line, and
    `--diff` to use the diff mode. The check mode instructs Ansible to walk through
    the play without actually making any changes to remote systems. This allows you
    to obtain a listing of the changes that Ansible plans to make to the configured
    system.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了冗长模式，Ansible还包括检查模式和差异模式。您可以通过在命令行中添加`--check`来使用检查模式，并使用`--diff`来使用差异模式。检查模式指示Ansible在实际上不对远程系统进行任何更改的情况下执行play。这允许您获取Ansible计划对配置系统进行的更改的列表。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important here to note that the check mode of Ansible is not perfect.
    Any modules that do not implement the check feature are skipped. Additionally,
    if a module is skipped that provides more variables, or the variables depend on
    a module actually changing something (such as file size), then they will not be
    available. This is an obvious limitation when using the `command` or `shell` modules
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，Ansible的检查模式并不完美。任何不实现检查功能的模块都将被跳过。此外，如果跳过了提供更多变量的模块，或者变量取决于实际更改某些内容的模块（例如文件大小），那么它们将不可用。当使用`command`或`shell`模块时，这是一个明显的限制。
- en: The diff mode shows the changes that are made by the `template` module. This
    limitation is because the `template` file only works with text files. If you were
    to provide a diff of a binary file from the copy module, the result would almost
    be unreadable. The diff mode also works with the check mode to show you the planned
    changes that were not made due to being in check mode.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 差异模式显示了`template`模块所做的更改。这是因为`template`文件只能处理文本文件。如果您要提供来自copy模块的二进制文件的差异，结果几乎无法阅读。差异模式还与检查模式一起工作，以显示由于处于检查模式而未进行的计划更改。
- en: The pause module
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂停模块
- en: Another technique is to use the `pause` module to pause the playbook while you
    examine the configured machine as it runs. This way, you can see changes that
    the modules have made at the current position in the play, and then watch while
    it continues with the rest of the play.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种技术是使用`pause`模块在检查配置的机器运行时暂停playbook。这样，您可以在play的当前位置看到模块所做的更改，然后在其余的play继续执行时观察。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the more advanced details of writing playbooks.
    You should now be able to use features such as delegation, looping, conditionals,
    and fact registration to make your plays much easier to maintain and edit. We
    also looked at how to access information from other hosts, configure the environment
    for a module, and gather data from external sources. Finally, we covered some
    techniques for debugging plays that are not behaving as expected.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了编写playbooks的更高级细节。现在，您应该能够使用委派、循环、条件和事实注册等功能，使您的plays更容易维护和编辑。我们还看了如何从其他主机访问信息，为模块配置环境，并从外部来源收集数据。最后，我们介绍了一些调试plays的技巧，以解决它们的行为与预期不符的问题。
- en: In the next chapter, we will be covering how to use Ansible in a larger environment.
    It will include methods for improving the performance of your playbooks that might
    be taking a long time to execute. We will also cover a few more features that
    make plays maintainable, particularly splitting them into many parts by purpose.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何在更大的环境中使用Ansible。它将包括改进playbooks性能的方法，这些playbooks可能需要很长时间才能执行。我们还将介绍一些使plays易于维护的功能，特别是按目的将它们分成多个部分。

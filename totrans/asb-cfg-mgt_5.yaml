- en: Chapter 5. Custom Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now we have been working solely with the tools provided to us by Ansible.
    This does afford us a lot of power, and make many things possible. However if
    you have something particularly complex or if you find yourself using the script
    module a lot, you will probably want to learn how to extend Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to write modules in Bash scripting or Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the custom modules that you have developed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a script to use an external data source as an inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often when you approach something complex in Ansible, you write a script module.
    The issue with script modules is that you can't process their output, or trigger
    handlers based on their output easily. So, although the script module works in
    some cases, using a module can be better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a module instead of writing a script when:'
  prefs: []
  type: TYPE_NORMAL
- en: You don't want to run the script every single time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to process the output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your script needs to make facts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to send complex variables as arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to start writing modules, you should check out the Ansible repository.
    If you want your module to work with a particular version, you should also switch
    to that version to ensure compatibility. The following commands will set you up
    to develop modules for Ansible 1.3.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Checking out the Ansible code gives you access to a handy script that we will
    use later to test our modules. We will also make this script executable in anticipation
    of its use later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a module in Bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible allows you to write modules in any language that you prefer. Although
    most modules in Ansible work with JSON, you are allowed to use shortcuts if you
    don't have any JSON parsing facilities available. Ansible will hand you arguments
    in their original key value forms, if they were provided in that format. If complex
    arguments are provided, you will receive JSON-encoded data. You could parse this
    using something like jsawk ([https://github.com/micha/jsawk](https://github.com/micha/jsawk))
    or jq ([http://stedolan.github.io/jq/](http://stedolan.github.io/jq/)), but only
    if they are installed on your remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible already has a module that lets you change the hostname of a system,
    but it only works with systemd-based systems. So let''s write one that works with
    the standard `hostname` command. We will start just printing the current hostname
    and then expand the script from there. Here is what that simple module looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you have written Bash scripts before, this should seem extremely basic. Essentially,
    what we are doing is grabbing the hostname and printing it out in a key value
    form. Now that we have written the first cut of the module, we should test it
    out.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the Ansible modules, we use the script that we ran the `chmod` command
    on earlier. This command simply runs your module, records the output, and returns
    it to you. It also shows how Ansible interpreted the output of the module. The
    command that we will use looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the previous command should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Ignore the notice at the top; it does not apply to modules built with bash.
    You can see the raw output that our script sent, which looks exactly the way we
    expected. The test script also gives you the parsed output. In our example, we
    are using the short output format and we can see here that Ansible is correctly
    interpreting it into the JSON that it normally accepts from modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s expand out the module to allow setting the `hostname`. We should write
    it so that it doesn''t make any changes unless required, and lets Ansible know
    whether changes were made or not. This is actually pretty simple for the small
    command that we are writing. The new script should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous script works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We set Bash's exit on error mode, so that we don't have to deal with errors
    from the `hostname` method. Bash will automatically exit on failure with its exit
    code. This will signal Ansible that something went wrong.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We source the argument file. This file is passed from Ansible as the first argument
    to the script. It contains the arguments that were sent to our module. Because
    we are sourcing the file, this can be used to run arbitrary commands; however,
    Ansible can already do this, so it's not that much of a security issue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We collect the old hostname and default `CHANGED` to `False`. This allows us
    to see whether our module needs to perform any changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We check whether we were sent a new hostname to set, and whether that hostname
    is different from the one that is currently set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If both these tests are true, we try to change the hostname, and set `CHANGED`
    to `True`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we output the results and exit. This includes the current hostname
    and whether we made changes or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Changing the hostname on a Unix machine requires root privileges. So while
    testing this script, you need to make sure to run it as the root user. Let''s
    test this script using `sudo` to see whether it works. This is the command you
    will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If `test.example.com` is not the current hostname of the machine, you should
    get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, our output is being parsed correctly, and the module claims
    that changes have been made to the system. You can check this yourself with the
    `hostname` command. Now, run the module for the second time with the same hostname.
    You should see an output that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Again, we see that the output was parsed correctly. This time, however, the
    module claims to not have made any changes, which is what we expect. You can also
    check this with the `hostname` command.
  prefs: []
  type: TYPE_NORMAL
- en: Using a custom module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have written our very first module for Ansible, we should give it
    a go in a playbook. Ansible looks at several places for its modules—first it looks
    at the place specified in the `library` key in its `config` file (`/etc/ansible/ansible.cfg`),
    next it will look at the location specified using the `--module-path` argument
    in the command line, then it will look in the same directory as the playbook for
    a `library` directory containing modules, and finally it will look in the `library`
    directory for any roles that may be set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a playbook that uses our new module and place it in a `library`
    directory in the same place so that we can see it in action. Here is a playbook
    that uses the `hostname` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create a directory named `library` in the same directory as the playbook
    file. Place the `hostname` module inside the library. Your directory layout should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a custom module](graphics/4267_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now when you run the playbook, it will find the `hostname` module in the `library`
    directory and execute it. You should see an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Running it again should change the result from `changed` to `ok`. Congratulations!
    You have now created and executed your very first module. This module is very
    simple right now, but you can extend it to know about the `hostname` file, or
    other methods to configure the hostname at boot time.
  prefs: []
  type: TYPE_NORMAL
- en: Writing modules in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All of the modules that are distributed with Ansible are written in Python.
    Because Ansible is also written in Python, these modules can directly integrate
    with Ansible. Here are a few reasons why you should write modules in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: Modules written in Python can use boilerplate, which reduces the amount of code
    required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python modules can provide documentation to be used by Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arguments to your module are handled automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output is automatically converted to JSON for you
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible upstream only accepts plugins using Python with the boilerplate code
    included
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can still build Python modules without this integration by parsing the arguments
    and outputting JSON yourself. However, with all the things you get for free, it
    would be hard to make a case for it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's build a Python module that lets us change the currently running init level
    of the system. There is a Python module named `pyutmp` that will let us parse
    the `utmp` file. Unfortunately, since Ansible modules have to be contained in
    a single file, we can't use it unless we know it will be installed on the remote
    systems, so we will resort to using the `runlevel` command and parsing its output.
    Setting the run level can be done with the `init` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to figure out what arguments and features the module supports.
    For the sake of simplicity, let''s have our module only accept one argument. We''ll
    use the argument `runlevel` to get the run level the user wants to change to.
    To do this, we will instantiate the `AnsibleModule` class with our data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to implement the actual guts of the module. The module object that
    we created previously provides us with a few shortcuts. There are three shortcuts
    that we will be using in the next step. As there are way too many methods to document
    here, you can see the whole `AnsibleModule` class and all the available helper
    functions in `lib/ansible/module_common.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '`run_command`: This method is used to launch external commands and retrieve
    the return code, the output from `stdout`, and also the output from `stderr`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exit_json`: This method is used to return data to Ansible when the module
    has completed successfully.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fail_json`: This method is used to signal a failure to Ansible, with an error
    message and return code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code actually manages the init level of the system comments to
    explain what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one final thing to add to the boilerplate to let Ansible know that
    it needs to dynamically add the integration code into our module. This is the
    magic that lets us use the `AnsibleModule` class and enables our tight integration
    with Ansible. The boilerplate code needs to be placed right at the bottom of the
    file, with no code afterwards. The code to do this looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test this module the same way you tested the Bash module with the `test-module`
    script. However, you need to be careful, because if you run it with `sudo`, you
    might reboot your machine or alter the init level to something you don''t want.
    This module is probably better tested by using Ansible itself on a remote test
    machine. We follow the same process as described in the *Writing a module in Bash*
    section earlier in this chapter. We create a playbook that uses the module, and
    then place the module in a library directory that has been made in the same directory
    as the playbook. Here is the playbook we need to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now you should be able to try and run this on a remote machine. The first time
    you run it, if the machine is not already in run level 5, you should see it change
    the run level. Then you should be able to run it for a second time to see that
    nothing has changed. You might also want to check to make sure the module fails
    correctly when not run as root.
  prefs: []
  type: TYPE_NORMAL
- en: External inventories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started with Ansible"), *Getting
    Started with Ansible*, we saw how Ansible needs an inventory file, so that it
    knows where its hosts are and how to access them. Ansible also allows you to specify
    a script that allows you to fetch the inventory from another source. External
    inventory scripts can be written in any language that you like as long as they
    output valid JSON.
  prefs: []
  type: TYPE_NORMAL
- en: An external inventory script has to accept two different calls from Ansible.
    If called with `–list`, it must return a list of all the available groups and
    hosts. Additionally, it may be called with `--host`. In this case, the second
    argument will be a hostname and the script is expected to return a list of variables
    for that host. All the outputs are expected in JSON, so you should use a language
    that supports it naturally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a module that takes a CSV file listing all your machines and presents
    this to Ansible as an inventory. This will be handy if you have a **Configuration
    Management Database** (**CMDB**) that allows you to export your machine list as
    CSV, or for someone who keeps records of their machines in a spreadsheet. Additionally,
    it doesn''t require any dependencies outside Python, as a CSV processing module
    is already included with Python. This really just parses the CSV file into the
    right data structures and prints them out as JSON data structures. The following
    is an example CSV file we wish to process; you may wish to customize it for the
    machines in your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This file needs to be converted into two different JSON outputs. When `--list`
    is called, we need to output the whole thing in a form that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And when it is called with the arguments `--host example`, it should return
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the script that opens a file named `machines.csv` and produces the
    dictionary of the groups if `--list` is given: Additionally, when `--host` and
    a hostname are given, it parses that host''s variables and returns them as a dictionary.
    The script is well-commented, so you can see what it is doing. You can run the
    script manually with the `--list` and `--host` arguments to confirm that it behaves
    correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can now use this inventory script to provide the inventory when using Ansible.
    A quick way to test that everything is working correctly is to use the `ping`
    module to test the connection to all the machines. This command will not test
    whether the hosts are in the right groups; if you want to do that, you can use
    the same `ping` module command but instead of running it across all, you can simply
    use the group you would like to test**.** If your inventory file is executable,
    then Ansible will run it and use the output. You can also use a directory and
    Ansible will include all files inside, running them if they are executable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to when you used the `ping` module in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Ansible"), *Getting Started with Ansible*, you should see an output
    that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that you can connect and use Ansible on all the hosts from your
    inventory. You can use the same `-i` argument with `ansible-playbook` to run your
    playbooks with the same inventory.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from writing modules and external inventory script, you can also extend
    the core functionality of Ansible itself. This allows you to include even more
    functionality into Ansible using Python. By writing plugins for Ansible, you can
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add new methods for controlling other machines with connection plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use data from external sources outside Ansible in loops or lookups with lookup
    plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add new filters for use with variables or in templates with filter plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include callbacks that run when certain actions happen inside Ansible with callback
    plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To add extra plugins to your Ansible projects, we create a Python file in the
    plugin directories specified in your `ansible.cfg` file. Alternatively, we can
    add new directories containing our plugins to the list of directories already
    present.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not remove any of the existing directories, as you will be removing plugins
    that provide core Ansible features such as the ones we have mentioned earlier
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: When writing plugins to Ansible, you should focus on making them flexible and
    reusable where possible. This way you end up removing some complexity from your
    playbooks and templates into a few complex Python files. Focusing on re-usability
    of your plugins also means it is possible to submit them back to the Ansible project
    using a GitHub pull request. If you submit your plugins back to Ansible, then
    everybody will be able to take advantage of your plugin, and you would have played
    a part in the development of Ansible itself. More information on contributing
    to Ansible can be found in the `CONTRIBUTORS.md` file in the Ansible source code.
  prefs: []
  type: TYPE_NORMAL
- en: Connection plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Connection plugins are responsible for relaying files to and from the remote
    machine, and executing modules. You will no doubt have already used the SSH, local
    and possibly the winrm plugins with the playbooks used earlier in the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the normal `__init__()` method, connection plugins must implement
    the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `connect()` | This opens the connection to the host we are managing |'
  prefs: []
  type: TYPE_TB
- en: '| `exec_command()` | This executes a command on the managed host |'
  prefs: []
  type: TYPE_TB
- en: '| `put_file()` | This copies a file to the managed host |'
  prefs: []
  type: TYPE_TB
- en: '| `fetch_file()` | This downloads a file from the managed host |'
  prefs: []
  type: TYPE_TB
- en: '| `close()` | This closes the connection to the host we are managing |'
  prefs: []
  type: TYPE_TB
- en: Lookup plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lookup plugins are used in two ways: to include data from outside as a `lookup()`,
    or in the `with_` style to loop over items. You can even combine the two to loop
    over external data as is done in the `with_fileglob` lookup plugin. Several lookup
    plugins have been demonstrated earlier in the book, particularly in *Looping*
    section of [Chapter 3](ch03.html "Chapter 3. Advanced Playbooks"), *Advanced Playbook*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lookup plugins are simple to write, and apart from the normal `__init__()`
    method, they only need you to implement a `run()` method. This method uses the
    `listify_lookup_plugin_terms()` method from the Ansible `utils` package to gather
    the arguments list passed to it, and returns the result. As an example, we will
    now demonstrate a lookup plugin to read data from a JSON encoded file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This can be used either as a lookup plugin to fetch complex data or, if the
    file contains a JSON list, as a loop using `with_jsonfile`. Save the preceding
    example as `jsonfile.py` in one of your lookup plugin directories. You can see
    that we have declared a new class named `LookupModule`; this is what Ansible tries
    to find within your Python file, so you must use this name. We then create a constructor
    (named `__init__`) so that Ansible can create our class. Finally, we make a small
    method that simply opens a JSON file, parses it and returns the result to Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: We should note that this example is really simplified and only looks in the
    current working directory for the file. It could be extended later to look in
    a roles file directory or elsewhere in order to better conform to conventions
    set by other Ansible modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then use this lookup plugin in a playbook like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Filter plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Filter plugins are extensions to the Jinja2 template engine that Ansible uses
    to process variables and generate files from templates. These extensions can be
    used in playbooks to perform data processing on variables, or they can be used
    inside templates to process data before it is included in the file. They simplify
    the processing of data by moving the complexity to a Python file and away from
    the templates or Ansible configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Filter plugins are a little different from other plugins. To implement one,
    you first write a simple function that simply takes the input you need and returns
    the result. Second, you create a class named `FilterModule`, and implement a `filters`
    method on it, which returns a Python dictionary, where the keys are the filter
    names and the values the functions to call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample implementation of a plugin that can be used to calculate the
    minimum number of servers required in any group to avoid a split-brain situation:
    This number in most systems is one greater than 50% of the nodes available.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Simply put, this module counts how many items were in the list passed to it,
    divides it by two, and then adds one. It is all done as integer math, so remainders
    are ignored and everything is done as whole numbers, which suits our purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'This filter can then be used in a playbook or a template. For example, if we
    wanted to configure an Elasticsearch cluster to have a quorum and avoid split-brain
    issues, we will use the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This will get the list of hosts this play is being run on (from the `play_hosts`
    variable), and then calculate how many of those are required to obtain a quorum.
  prefs: []
  type: TYPE_NORMAL
- en: Callback plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Callback plugins are used to provide information about actions that are happening
    in Ansible to external systems. They are automatically activated if they are found
    in the directories specified under the `callback_plugins` directory into Ansible
    configuration. They are often useful when playbooks are being run as automated
    tasks as they can give feedback via other channels than the standard output. Callback
    plugins have a wide variety of uses, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Sending an e-mail at the end of a playbook with the statistics of what changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording a running log of changes being made to `syslog`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notifying a chat channel when a playbook task fails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating a CMDB as changes are made to ensure an accurate view of the configuration
    of every system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alerting an admin when a play has exited early because all hosts have failed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The callback plugins are the most complicated plugins to write because they
    have the ability to hook into most of Ansible''s features. Just because there
    are many options though does not mean you need to implement them all. You only
    need to implement the ones your callback will use. Here is a list of the methods
    you can implement, along with their description:'
  prefs: []
  type: TYPE_NORMAL
- en: '`def on_any(self, *args, **kwargs)`: This is called before any of the other
    callbacks are called. Because the arguments differ from callback to callback,
    it expands its arguments into `args` and `kwargs`. This method is good for logging.
    Using it for anything else can become quite complicated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runner_on_failed(self, host, res, ignore_errors=False)`: This is run after
    a task fails. The `host` argument contains the host on which the task was running,
    `res` contains the task data from the playbook and anything that was returned,
    and `ignore_errors` contains a boolean value specifying whether the playbook indicated
    errors should be ignored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runner_on_ok(self, host, res)`: This runs after a task succeeds or when a
    poll for an async job succeeds. The argument `host` contains the host on which
    the task was running and `res` contains the task data from the playbook and any
    data that was returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runner_on_skipped(self, host, item=None)`: This runs after a task is skipped.
    The argument `host` contains the host on which the task would have run if it were
    not skipped and the `item` argument contains the loop item, which is currently
    being iterated over.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runner_on_unreachable(self, host, res)`:This runs when a host is found to
    be unreachable. The `host` argument contains the unreachable host and `res` contains
    the error message from the connection plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runner_on_no_hosts(self)`: This callback runs when a task is started without
    any hosts. It does not have any variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runner_on_async_poll(self, host, res, jid, clock)`: This runs whenever an
    async job is polled for status. The variable `host` contains the host that is
    being polled, `res` contains details of the polling, `jid` contains the job ID,
    and `clock` contains the amount of time remaining before the job fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runner_on_async_ok(self, host, res, jid)`: This runs when polling has completed
    without an error. The argument `host` contains the host that was being polled,
    `res` holds the results from the task, and `jid` contains the job ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runner_on_async_failed(self, host, res, jid)`: This runs when polling has
    completed with an error. The argument `host` contains the host that was being
    polled, `res` holds the results from the task, and `jid` contains the job ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playbook_on_start(self)`: This callback is executed when a playbook is started
    with `ansible-playbook`. It does not use any variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playbook_on_notify(self, host, handler)`: This callback is run whenever a
    handler is notified. Because this is run when the notify happens and not when
    the handler runs, it may run multiple times for each handler. It has two variables:
    `host` stores the hostname on which the task notified and `handler` stores the
    name of the handler that was notified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playbook_on_no_hosts_matched(self)`: This callback runs if a play starts that
    does not match any host. It does not have any variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playbook_on_no_hosts_remaining(self)`: This callback runs when all the hosts
    in a play have errors and the play is unable to continue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playbook_on_task_start(self, name, is_conditional)`: This callback runs right
    before each task, even if the task is going to be skipped. The `name` variable
    is set to the name of the task, and `is_conditional` is set to the outcome of
    the when clause—`True` if the task will run, and `False` if not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playbook_on_setup(self)`: This callback is executed right before the setup
    module executes across the hosts. It runs once no matter how many hosts are included.
    It does not include any variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playbook_on_play_start(self, name)`: This callback runs at the beginning of
    each play. The `name` variable contains the name of the play that is starting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playbook_on_stats(self, stats)`: This callback runs at the end of a playbook
    right before the stats are to be printed. The `stats` variable contains the details
    of the playbook.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having read this chapter, you should now be able to build modules using either
    Bash or any other languages that you know. You should be able to install modules
    that you have either obtained from the Internet, or written yourself. We also
    covered how to write modules more efficiently using the boilerplate code in Python,
    and we wrote an inventory script that allows you to pull your inventory from an
    external source. Finally we covered adding new features to Ansible itself by writing
    connection, lookup, filter, and callback plugins.
  prefs: []
  type: TYPE_NORMAL
- en: We have tried to cover most of the things you will need when getting to know
    Ansible, but we can't possibly cover everything. If you would like to continue
    learning about Ansible, you can visit the official Ansible documentation at [http://docs.ansible.com/](http://docs.ansible.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ansible project is currently working on a rewrite, which will eventually
    be released as version 2.0\. This book should stay compatible with this version
    and others going forward, but there will be new features that are not covered
    here. In version 2.0 of Ansible, you can expect the following features, which
    may change in the future (as it has not yet been released):'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to recover from failures within a playbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing you to run lots of tasks in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatibility with Python 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier debugging as errors will contain line numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

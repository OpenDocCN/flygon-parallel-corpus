- en: Chapter 5. Controlling Execution Flow – Conditionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Control structures refer to anything and everything that have an effect on
    a program''s execution flow. Control structures are mainly of the following two
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: Conditional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At times, we need to execute code conditionally based on a value of a variable,
    type of platform, or even a result of some other command. There are times when
    we also need to iterate multiple objects, such as list hashes or multilevel variables.
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages and tools use powerful but machine-friendly constructs,
    such as `if else`, `for`, `unless`, `do while`, and so on. However, Ansible stays
    true to its design tenet of being a human-friendly automation language and manages
    to achieve the same with the omnipotent `when` and `with_*` constructs, which
    are closer to the English language. Let's begin to explore how it does so.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using conditional controls with the `when` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using variables and facts to skip subroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying roles selectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conditional control structures in Jinja2 templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conditional control structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Conditional control structures allow Ansible to follow an alternate path, skip
    a task, or select a specific file to import based on certain conditions. In a
    generic programming language, this is done with the help of `if-then`, `else if`,
    `else`, `case` statements. Ansible does this using the "`when`" statement. Some
    example conditions are:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether a certain variable is defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether an earlier command sequence is successful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the task has run before
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether a platform on a target node matches the supported platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether a certain file exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The when statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already used the `when` statement to extract the WordPress archive
    based on the result of another command, which is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be vaguely equivalent to writing a shell snippet, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to checking the preceding code, we could simply write conditions
    based on the result of the task itself, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For the failed statement to work, we need to add the `ignore_errors: True`
    statement to the earlier task that registers the variable. The following flowchart
    depicts the same logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The when statements](graphics/B03800_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fact-based selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Facts are a good source of information to detect platform-specific information
    and make a choice based on it, especially when you have hybrid environments. Based
    on this selection, we could:'
  prefs: []
  type: TYPE_NORMAL
- en: Decide whether to execute a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decide whether to include a task file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decide whether to import a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decide whether to apply a role on the target node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have already used fact-based selection while writing MySQL, where we used
    the fact `ansible_os_family` to:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `vars` file for non-Debian-based systems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include platform-specific tasks for package installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code snippet shows both the use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fact-based selection](graphics/B03800_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Refactoring the MySQL role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our existing MySQL role installs and configures only the server. More often
    than not, all we need to do is just install the MySQL client package and not the
    server. We don't have the ability to selectively do so.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The scenario:**'
  prefs: []
  type: TYPE_NORMAL
- en: We have been tasked to refactor the MySQL role and make it conditionally install
    the MySQL server based on a variable value. By default, it should just install
    MySQL client packages.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean variables could be useful to set up an an on/off switch. We will add
    a variable and set its default value to `false`. This time, we will create a multilevel
    variable or a nested hash.
  prefs: []
  type: TYPE_NORMAL
- en: Multilevel variable dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have been naming variables as `mysql_bind`, `mysql_port`, and so
    on and using an underscore to categorize them. Variables can instead be better
    categorized and organized if you define them with multiple-level dictionaries,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Multilevel variables can then be accessed inside the code as `mysql[''config][''bind'']`
    or `mysql[''config][''port'']`. Let''s now update the `roles/mysql/defaults/main.yml`
    file to use multilevel variables and also create a new Boolean variable `mysql.server`,
    which acts as a flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multilevel variable dictionaries](graphics/B03800_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Additionally, we would have to update files in the `vars` directory in the `mysql`
    role to define the variables with a new style, all tasks, handlers, and templates
    to reference them appropriately. This process is added as part of the text to
    avoid redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: Merging hashes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Multilevel variables or, in essence, dictionaries defined from different locations
    may need to be merged. For example, if we define default configuration parameters
    in the role `default` and then override a few from the `vars` directory in the
    role, the resultant variable `hash` should contain items from the **defaults**
    plus overridden values from **vars**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Merging hashes](graphics/B03800_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, by default, Ansible will replace the dictionary, and in the preceding
    example, instead of getting a merged dictionary, we would lose the user and port
    `vars` as `vars` in the role has higher precedence. This can be avoided by setting
    the `hash_behavior` parameter to `merge` instead of `replace`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This should be set on the Ansible control host and does not require us to restart
    any service.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the MySQL server selectively
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After refactoring the code and adding a flag controlled by a variable, we are
    ready to selectively configure the MySQL server. We have the `mysql.server` variable,
    which takes the Boolean value of `True`/`False`. This variable could be used to
    decide whether to skip server configurations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also add tasks to install the MySQL client package as well as the Python
    bindings required by Ansible''s MySQL module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the package names come from the following variable `hash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By default, the `mysql.server` parameter has been set to `False`. How do we
    enable this only for the database servers? There are plenty of ways we can do
    so. We would choose playbook variables this time, since we have one dedicated
    to DB servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the MySQL server selectively](graphics/B03800_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Conditional control structure in Jinja2 templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible uses Jinja2 as a template engine. Hence, it would be useful for us
    to understand Jinja2 control structures in addition to the ones supported by Ansible
    tasks. Jinja2''s syntax encloses the control structures inside the `{% %}` blocks.
    For conditional control, Jinja2 uses the familiar `if` statements, which have
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Updating the MySQL template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The template that we created earlier to generate the `my.cnf` file assumes
    that all the variables referred in it are defined somewhere. There is a chance
    that this is not always the case, which could result in errors while running Ansible.
    Could we selectively include configuration parameters in the `my.cnf` file? The
    answer is yes. We could check whether a variable is defined and only then, we
    will add it to the file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: Since we are setting the default value for the `mysql['config']['user']` parameter,
    there is no need to check whether it's defined. It's already handled gracefully.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all other parameters, we check whether the variable is defined using a condition,
    such as `if mysql.config.pid is defined`. This would skip the parameter if it's
    not defined rather than throwing an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a task only once
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At times, a specific task in a role may need to be executed only once during
    a playbook execution, even though the role is applied to many hosts. This could
    be achieved with the `run_once` conditional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Since we are using the `run_once` option, the preceding task would run on the
    first host in the inventory that the role is being applied to. All consequent
    hosts would skip this task.
  prefs: []
  type: TYPE_NORMAL
- en: Executing roles conditionally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Nginx role that we created earlier to set up web server supports only Debian-based
    systems. Running this logic on other systems could lead to failure. For example,
    the Nginx role uses the `apt` module to install packages, which would not work
    on RedHat-based systems, which depend on the `yum` package manager. This could
    be avoided by adding the `when` statement with a fact to selectively execute based
    on an OS family. The following is the snippet from the `www.yml` playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Review questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you think you''ve understood the chapter well enough? Try answering the
    following questions to test your understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the replacement for the `if else` statements in Ansible?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you selectively import platform-specific variables?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do Jinja2 templates use `__` and `__` to delimit control structures?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you skip running roles on incompatible platforms?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learnt about how to control execution flow using the `when`
    statements, conditional imports, selective includes, and so on. You also learnt
    how to use variables and facts to selectively skip routines and execute platform-specific
    subroutines. We refactored the MySQL role to start using dictionaries of variables
    to conditionally configure the MySQL server and to use more intelligent templates
    with prechecks for defined variables.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will begin exploring the second type of control structures,
    that is. iterative control structures, where we will start looping arrays and
    hashes.
  prefs: []
  type: TYPE_NORMAL

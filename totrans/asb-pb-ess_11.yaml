- en: Chapter 10. Orchestrating Infrastructure with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Orchestration can mean different things at different times when used in different
    scenarios. The following are some of the orchestration scenarios described:'
  prefs: []
  type: TYPE_NORMAL
- en: Running ad hoc commands in parallel on a group of hosts, for example, using
    a `for` loop to walk over a group of web servers to restart the Apache service.
    This is the crudest form of orchestration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking an orchestration engine to launch another configuration management
    tool to enforce correct ordering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring a multitier application infrastructure in a certain order with the
    ability to have fine-grained control over each step, and the flexibility to move
    back and forth while configuring multiple components. For example, installing
    the database, setting up the web server, coming back to the database, creating
    a schema, going to web servers to start services, and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most real-world scenarios are similar to the last scenario, which involve a
    multitier application stacks and more than one environment, where it's important
    to bring up and update nodes in a certain order, and in a coordinated way. It's
    also useful to actually test that the application is up and running before moving
    on to the next. The workflow to set up the stack for the first time versus pushing
    updates can be different. There can be times when you would not want to update
    all the servers at once, but do them in batches so that downtime is avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Orchestration scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ansible as an infrastructure orchestrating engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing rolling updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tags, limits and patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building tests into playbooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible as an orchestrator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to orchestration of any sort, Ansible really shines over other
    tools. Of course, as the creators of Ansible would say, it's more than a configuration
    management tool, which is true. Ansible can find a place for itself in any of
    the orchestration scenarios discussed earlier. It was designed to manage complex
    multitier deployments. Even if you have your infrastructure being automated with
    other configuration management tools, you can consider Ansible to orchestrate
    those.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss the specific features that Ansible ships with, which are useful
    for orchestration.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple playbooks and ordering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike most other configuration management systems, Ansible supports running
    different playbooks at different times to configure or manage the same infrastructure.
    You can create one playbook to set up the application stack for the first time,
    and another to push updates over time in a certain manner. Another property of
    the playbook is that it can contain more than one play, which allows the separation
    of groups of hosts for each tier in the application stack, and configures them
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-tasks and post-tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have used pre-tasks and post-tasks earlier, which are very relevant while
    orchestrating, as these allow us to execute a task or run validations before and
    after running a play. Let's use the example of updating web servers that are registered
    with the load balancer. Using pre-tasks, a web server can be taken out of a load
    balancer, then the role is applied to the web servers to push updates, followed
    by post-tasks which register the web server back to the load balancer. Moreover,
    if these servers are being monitored by **Nagios**, alerts can be disabled during
    the update process and automatically enabled again using pre-tasks and post-tasks.
    This can avoid the noise that the monitoring tool may generate in the form of
    alerts.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you would like tasks to be selectively run on a certain class of hosts,
    especially the ones outside the current play, the delegation feature of Ansible
    can come in handy. This is relevant to the scenarios discussed previously and
    is commonly used with pre-tasks and post-tasks. For example, before updating a
    web server, it needs to be deregistered from the load balancer. Now, this task
    should be run on the load balancer, which is not part of the play. This dilemma
    can be solved by using the delegation feature. With pre-tasks, a script can be
    launched on the load balancer using the `delegate_to` keyword, which does the
    deregistering part as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Rolling updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is also called batch updates or zero-downtime updates. Let''s assume that
    we have 100 web servers that need to be updated. If we define these in an inventory
    and launch a playbook against them, Ansible will start updating all the hosts
    in parallel. This can also cause downtime. To avoid complete downtime and have
    a seamless update, it would make sense to update them in batches, for example,
    20 at a time. While running a playbook, batch size can be mentioned by using the
    `serial` keyword in the play. Let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While orchestrating, it''s not only essential to configure the applications
    in order, but also to ensure that they are actually started, and functioning as
    expected. Ansible modules, such as `wait_for` and `uri`, help you build that testing
    into the playbooks, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `wait_for` module can be additionally used to test the existence of a file.
    It's also useful when you would like to wait until a service is available before
    proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: Tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible plays map roles to specific hosts. While the plays are run, the entire
    logic that is called from the main task is executed. While orchestrating, we may
    need to just run a part of the tasks based on the phases that we want to bring
    the infrastructure in. One example is a zookeeper cluster, where it's important
    to bring up all the nodes in the cluster at the same time, or in a gap of a few
    seconds. Ansible can orchestrate this easily with a two-phase execution. In the
    first phase, you can install and configure the application on all nodes, but not
    start it. The second phase involves starting the application on all nodes almost
    simultaneously. This can be achieved by tagging individual tasks, for example,
    configure, install, service, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tags](graphics/B03800_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While running a playbook, all tasks with a specific tag can be called using
    `–-tags` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Tags can not only be applied to tasks, but also to the roles, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If a specific task needs to be executed always, even if filtered with a tag,
    use a special tag called `always`. This will make the task execute unless an overriding
    option, such as `--skip-tags always` is used.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns and limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Limits can be used to run tasks on a subset of hosts, which are filtered by
    patterns. For example, the following code would run tasks only on hosts that are
    part of the `db` group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Patterns usually contain a group of hosts to include or exclude. A combination
    of more than one pattern can be specified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Having a colon as separator can be used to filter hosts further. The following
    command would run tasks on all hosts except for the ones that belong to the groups
    `www` and `db`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this usually needs to be enclosed in quotes. In this pattern, we
    used the `all` group, which matches all hosts in the inventory, and can be replaced
    with `*`. That was followed by `!` to exclude hosts in the `db` group. The output
    of this command is as follows, which shows that plays by the name `db` and `www`
    were skipped as no hosts matched due to the filter we used previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Patterns and limits](graphics/B03800_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's now see these orchestration features in action. We will begin by tagging
    the role and do the multiphase execution followed by writing a new playbook to
    manage updates to the WordPress application.
  prefs: []
  type: TYPE_NORMAL
- en: Tagging the roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now start tagging the roles we created earlier. We will create the following
    tags that map to the phases the applications are managed in:'
  prefs: []
  type: TYPE_NORMAL
- en: Install
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of adding tags to the `haproxy` role. Tagging other roles
    is excluded from the text to avoid redundancy. We can either add tags to the tasks
    inside the role or tag the complete roles in a playbook. Let''s begin by tagging
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After tagging tasks in a role, we will additionally tag the roles in the playbooks
    too, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once applied, the tags for our main playbook can be listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the combination of tags and limits gives us a fine-grained control over
    what gets executed in a playbook run, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Creating an orchestration playbook for WordPress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have a site-wide playbook, that is, the `site.yml` file that serves us to
    install and configure the complete WordPress stack. For updating the application
    with zero downtime and deploying new revisions, the `site.yml` file is not the
    ideal playbook though. We would want to follow a workflow that would involve the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the web servers one at a time. This will avoid any downtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before updating, deregister the web server from the haproxy load balancer. This
    will stop the traffic to the web server in order to avoid downtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run roles related to the WordPress application, that is, Nginx, php5-fpm, and
    WordPress.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the web server is running and is listening to port 80.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the server back on haproxy and start sending the traffic again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create a playbook by the name `update.yml`, which does the orchestration
    just as explained earlier and uses most of the features discussed previously in
    this chapter. Here is the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze this code:'
  prefs: []
  type: TYPE_NORMAL
- en: The playbook contains just one play, which runs on the hosts that belong to
    the `www group in` inventory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The serial keyword specifies the batch size, and allows rolling updates with
    zero downtime. In our case, since we have fewer hosts, we chose one web server
    to be updated at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before applying the role, the host is deregistered from the load balancer using
    the pre-tasks section ,which runs a shell command with **socat**. This is run
    on all load balancers using the `delegate` keyword. Socat is a Unix utility similar
    to and more at (nc) but has a richer feature set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After deregistering the host, roles are applied to it; this will update the
    configurations for the web server or deploy new code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once updated, the post-tasks kick in, which first wait until the web server
    is up and listening to port 80, and only after its ready, then it registers it
    back to the load balancer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you think you''ve understood the chapter well enough? Try answering the
    following questions to test your understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: Is it possible to use Ansible to orchestrate another configuration management
    tool?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you achieve zero downtime while deploying applications with Ansible?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `--limit` command do to Ansible playbook?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you run a subset of tasks for a given role in a playbook?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of using pre-tasks and post-tasks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What modules can be used to run tests from playbooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the `always` tag special?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by discussing what orchestration is, what different
    orchestration scenarios are, and how Ansible can fit in. You learned about Ansible's
    set of rich features in the context or orchestration. This includes multi-playbook
    support, pre-tasks and post-tasks, tags and limits, running tests, and a lot more.
    We went on to tag the roles we created earlier and learned how to control what
    portion of code runs on which machines using a combination of tags, patterns,
    and limits. Finally, we created a new playbook to orchestrate the workflow to
    update web servers, which involves zero-downtime deployment, delegation, pre-tasks
    and post-tasks, and tests. You also learned that Ansible can be a good fit in
    any orchestration scenario.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of this book. Before we conclude, on behalf of the
    reviewers, editors, contributors, and rest of the publishing team, I would like
    to thank you for considering this book as a companion in your journey towards
    being an Ansible practitioner.
  prefs: []
  type: TYPE_NORMAL
- en: We hope that by now you have become comfortable with the various primitives
    that Ansible offers to automate common infrastructure tasks, create dynamic roles,
    manage multitier application configurations, zero-downtime deployments, orchestrate
    complex infrastructure, and more. We hope that you will be able to apply the knowledge
    acquired in this book to create effective Ansible playbooks.
  prefs: []
  type: TYPE_NORMAL

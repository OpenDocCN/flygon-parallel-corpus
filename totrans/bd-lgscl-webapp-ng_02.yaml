- en: Personal Trainer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *7 Minute Workout* app has been an excellent opportunity for us to learn
    about Angular. Working through the app, we have covered a number of Angular constructs.
    Still, there are areas such as Angular form support and client-server communication
    that remain unexplored. This is partially due to the fact that 7 Minute Workout,
    from a functional standpoint, has limited touch points with the end user. Interactions
    are limited to starting, stopping, and pausing the workout. Also, the app neither
    consumes nor produces any data (except workout history).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we plan to delve deeper into one of the two aforementioned
    areas, Angular form support. Keeping up with the health and fitness theme (no
    pun intended), we plan to build a *Personal Trainer* app. The new app will be
    an extension to *7 Minute Workout*, allowing us to build our own customized workout
    plans that are not limited to the *7 Minute Workout* plans we already have.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is dedicated to understanding Angular forms and how to put them
    to use as we build out our *Personal Trainer* app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that we will cover in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining Personal Trainer requirements**: Since we are building a new app
    in this chapter, we start with defining the app requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Defining the Personal Trainer model**: Any app design starts with defining
    its model. We define the model for *Personal Trainer*, which is similar to the
    *7 Minute Workout* app built earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Defining the Personal Trainer layout and navigation**: We define the layout,
    navigation patterns, and views for the new app. We also set up a navigation system
    that is integrated with Angular routes and the main view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adding support pages**: Before we focus on the form capability and build
    a Workout component, we build some supporting components for workout and exercise
    listing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Defining the Workout Builder component structure**: We lay out the Workout
    Builder components that we will use to manage workouts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Building forms**: We make extensive use of HTML forms and input elements
    to create custom workouts. In the process, we will learn more about Angular Forms.
    The concepts that we cover include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Form types**: The two types of form that can be built with Angular are template-driven
    and reactive. We''re working with both template-driven and reactive forms in this
    chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ngModel**: This provides two-way data binding for template driven forms and
    allows us to track changes and validate form input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reactive Form Controls**: These include the form builder, form control, form
    group, and form array. These are used to construct forms programmatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data formatting**: These are the CSS classes that permit us to style our
    feedback to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Input validation**: We will learn about the validation capabilities of Angular
    forms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Personal Trainer requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on the notion of managing workouts and exercises, these are some of the
    requirements that our *Personal Trainer* app should fulfill:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to list all available workouts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ability to create and edit a workout. While creating and editing a workout,
    it should have:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to add workout attributes including name, title, description, and
    rest duration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to add/remove multiple exercises for workouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to order exercises in the workout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to save workout data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to list all available exercises.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ability to create and edit an exercise. While creating and editing an exercise,
    it should have:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to add exercise attributes such as name, title, description, and
    procedure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to add pictures for the exercise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to add related videos for the exercise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to add audio clues for the exercise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the requirements seem to be self-explanatory, so let's start with the design
    of the application. As customary, we first need to think about the model that
    can support these requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the code for Personal Trainer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, download the base version of the new *Personal Trainer* app from `checkpoint4.1`
    in the GitHub repository for the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is available on GitHub [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)
    for everyone to download. Checkpoints are implemented as branches in GitHub. The
    branch to download is as follows: `GitHub Branch: checkpoint4.1`. If you are not
    using Git, download the snapshot of Checkpoint 4.1 (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular6byexample/archive/checkpoint4.1.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.1.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code has the complete *7 Minute Workout (Workout Runner)* app. We have
    added some more content to support the new *Personal Trainer* app. Some of the
    relevant updates are:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the new `WorkoutBuilder` feature. This feature contains implementations
    pertaining to *Personal Trainer*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the layout and styles of the app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding some components and HTML templates with placeholder content for *Personal
    Trainer* in the `workout-builder` folder under `trainer/src/app`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a new route to the `WorkoutBuilder` feature. We will cover setting
    up this route within the app in the coming section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we just mentioned, moving the existing  `model.ts` file into the `core` folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss how we will be using the model.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Personal Trainer model in Workout Builder services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Services are useful for sharing data across controllers and other Angular constructs.
    Open the `model.ts` file present in the `core` folder under `app`. In this class,
    we essentially do not have any data, but a blueprint that describes the shape
    of the data. The plan is to use services to expose this model structure.  We have
    already done that in Workout Runner. Now, we will do the same in Workout Builder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `model.ts` file has been moved into the `core` folder as it is shared across
    the *Workout Builder* and *Workout Runner* apps. Note: in `checkpoint4.1` we have
    updated the import statements in `workout-runner.component.ts` , `workout-audio.component.ts`, and `workout-history-tracker-service.ts` to
    reflect this change.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](8eb47c1f-58fe-45dd-9afe-b955ef2080be.xhtml), *Building Our First
    App - 7 Minute Workout*, we reviewed the class definitions in the model file: `Exercise`,
    `ExercisePlan`, and `WorkoutPlan`**.** As we then mentioned, these three classes
    constitute our base model. We will now start using this base model in our new
    app.
  prefs: []
  type: TYPE_NORMAL
- en: That's all on the model design front. The next thing we are going to do is define
    the structure for the new app.
  prefs: []
  type: TYPE_NORMAL
- en: The Personal Trainer layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The skeleton structure of *Personal Trainer* looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/38aaf003-6900-4429-8954-72093475d5d3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This has the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Top Nav: This contains the app branding title and history link.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sub Nav: This has navigation elements that change based on the active component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Left Nav: This contains elements that are dependent upon the active component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Content Area: This is where the main view for our component will display. This
    is where most of the action happens. We will create/edit exercises and workouts
    and show a list of exercises and workouts here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at the source code files; there is a new folder `workout-builder` under
    `trainer/src/app`. It has files for each component that we described previously,
    with some placeholder content. We will be building these components as we go along
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: However, we first need to link up these components within the app. This requires
    us to define the navigation patterns for the Workout Builder app and accordingly
    define the app routes.
  prefs: []
  type: TYPE_NORMAL
- en: Personal Trainer navigation with routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The navigation pattern that we plan to use for the app is the list-detail pattern.
    We will create list pages for the exercises and workouts available in the app.
    Clicking on any list item takes us to the detailed view for the item where we
    can perform all CRUD operations (create/read/update/delete). The following routes
    adhere to this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Route** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `/builder` | This just redirects to **builder/workouts** |'
  prefs: []
  type: TYPE_TB
- en: '| `/builder/workouts` | This lists all the available workouts. It is the landing
    page for *Workout Builder* |'
  prefs: []
  type: TYPE_TB
- en: '| `/builder/workout/new` | This creates a new workout |'
  prefs: []
  type: TYPE_TB
- en: '| `/builder/workout/:id` | This edits an existing workout with the specific
    ID |'
  prefs: []
  type: TYPE_TB
- en: '| `/builder/exercises` | This lists all the available exercises |'
  prefs: []
  type: TYPE_TB
- en: '| `/builder/exercise/new` | This creates a new exercise |'
  prefs: []
  type: TYPE_TB
- en: '| `/builder/exercise/:id` | This edits an existing exercise with the specific
    ID |'
  prefs: []
  type: TYPE_TB
- en: Getting started with Personal Trainer navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, if you look at the route configuration in `app-routing.module.ts`
    in the `src/app` folder, you will find one new route definition, `builder`**:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you run the application, you will see that the start screen shows another
    link, Create a Workout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/91aeb5b5-d0e6-4423-b679-0dd4c8b1d79f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Behind the scenes, we have added another router link for this link into `start.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you click on this link, you will be taken to the following view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c4bb197b-3abd-4895-be6c-ced456c6b230.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, behind the scenes we have added  `workout-builder.component.ts` to the
    `trainer/src/app/workout-builder` folder with the following inline template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And this view is displayed on the screen under the header using the router
    outlet in our `app.component.html` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have wrapped this component (along with the other files we have stubbed out
    for this feature) in a new module named `workout-builder.module.ts:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The only thing that might look different here from the other modules that we
    have created is that we are importing `CommonModule` instead of `BrowserModule`.
    This avoids importing the whole of `BrowserModule` a second time, which would
    generate an error when we get to implementing lazy loading for this module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have added an import for this module to `app.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So, nothing surprising here. Following these patterns, we should now begin to
    think about adding the additional navigation outlined previously for our new feature.
    However, before we jump into doing that, there are a couple of things we need
    to consider.
  prefs: []
  type: TYPE_NORMAL
- en: First, if we start adding our routes to the `app.routing-module.ts` file, then
    the number of routes stored there will grow. These new routes for *Workout Builder*
    will also be intermixed with the routes for *Workout Runner***.** While the number
    of routes we are now adding might seem insignificant, over time this could get
    to be a maintenance problem.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we need to take into consideration that our application now consists
    of two features—*Workout Runner* and *Workout Builder*. We should be thinking
    about ways to separate these features within our application so that they can
    be developed independently of each other.
  prefs: []
  type: TYPE_NORMAL
- en: Put differently, we want **loose coupling** between the features that we build.
    Using this pattern allows us to swap out a feature within our application without
    affecting the other features. For example, somewhere down the line, we may want
    to convert the *Workout Runner* into a mobile app but leave the *Workout Builder*
    intact as a web-based application.
  prefs: []
  type: TYPE_NORMAL
- en: This ability to separate our components from each other is one of the key advantages
    of using the **component design pattern** that Angular implements. Fortunately,
    Angular's router gives us the ability to separate out our routing into logically
    organized **routing configurations** that closely match the features in our application.
  prefs: []
  type: TYPE_NORMAL
- en: In order to accomplish this separation, Angular allows us to use **child routing**,
    where we can isolate the routing for each of our features. In this chapter, we
    will use **child routing** to separate out the routing for *Workout Builder*.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing child routes to Workout Builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular supports our goal of isolating the routing for our new *Workout Builder*
    by providing us with the ability to create a hierarchy of router components within
    our application. We currently have just one router component, which is in the
    root component of our application. But Angular allows us to add what are called
    **child router components** under our root component. This means that one feature
    can be ignorant of the routes the other is using and each is free to adapt its routes
    in response to changes within that feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting back to our application, we can use **child routing** in Angular to
    match the routing for the two features of our application with the code that will
    be using them. So in our application, we can structure the routing into the following
    routing hierarchy for our *Workout Builder* (at this point, we are leaving the
    *Workout Runner* as is to show the before and after comparison):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f4b8f0b2-c5a8-41fc-b7ad-a0b0606092b2.png)'
  prefs: []
  type: TYPE_IMG
- en: With this approach, we can create a logical separation of our routes by feature
    and make them easier to manage and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get started by adding child routing to our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'From this point on in this section, we''ll be adding to the code that we downloaded
    earlier for this chapter. If you want to see the complete code for this next section,
    you can download it from `checkpoint 4.2` in the GitHub repository. If you want
    to work along with us as we build out the code for this section, still be sure
    to add the changes in `styles.css` in the `trainer/src` folder that are part of
    this checkpoint, since we won''t be discussing them here. Also be sure and add
    the files for exercise(s) ,workout(s), and navigation from the `trainer/src/app/workout-builder`
    folder in the repository. At this stage, these are just stub files, which we will
    implement later in this chapter. However, you will need these stub files here
    in order to implement navigation for the *Workout Builder* module. The code is
    available to download on GitHub at [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: `GitHub Branch: checkpoint4.2` . If you are not using Git, download the
    snapshot of `Checkpoint 4.2` (a ZIP file) from the following GitHub location:
    [https://github.com/chandermani/angular6byexample/archive/checkpoint4.2.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.2.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the child routing component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `workout-builder` directory, add a new TypeScript file named `workout-builder.routing.module.ts`
    with the following imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are importing the components we just mentioned; they will
    be part of our *Workout Builder* (exercise, exercises, workout, and workouts).
    Along with those imports, we are also importing `NgModule` from the Angular core
    module and `Routes` and `RouterModule` from the Angular router module. These imports
    will give us the ability to add and export child routes.
  prefs: []
  type: TYPE_NORMAL
- en: We are not using the Angular CLI here because it does not have a standalone
    blueprint for creating a routing module. However, you can have the CLI create
    a routing module at the time that you create a module using the `--routing` option.
    In this case, we already had an existing module created so we couldn't use that
    flag. See [https://github.com/angular/angular-cli/blob/master/docs/documentation/stories/routing.md](https://github.com/angular/angular-cli/blob/master/docs/documentation/stories/routing.md)
    for more details about how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add the following route configuration to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The first configuration, `path: ''builder''`, sets the base URL for the child
    routes so that each of the child routes prepends it. The next configuration identifies
    the `WorkoutBuilder` component as the feature area root component for the child
    components in this file. This means it will be the component in which each of
    the child components is displayed using `router-outlet`. The final configuration
    is a list of one or more children that defines the routing for the child components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to note here is that we have set up `Workouts` as the default for
    the child routes with the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration indicates that if someone navigates to `builder`, they will
    be redirected to the `builder/workouts` route. The `pathMatch: ''full''` setting
    means that the match will only be made if the path after workout/builder is an
    empty string. This prevents the redirection from happening if the routes are something
    else, such as `workout/builder/exercises` or any of the other routes we have configured
    within this file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the following class declaration preceded by an `@NgModule` decorator
    that defines imports and exports for our module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This import is very similar to the one in `app.routing-module.ts`, with one
    difference - instead of `RouterModule.forRoot`, we are using `RouterModule.forChild`.
    The reason for the difference may seem self-explanatory: we are creating child
    routes, not the routes in the root of the application, and this is how we signify
    that. Under the hood, however, there is a significant difference. This is because
    we cannot have more than one router service active in our application. `forRoot`
    creates the router service but `forChild` does not.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the WorkoutBuilder component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We next need to update the `WorkoutBuilder` component to support our new child
    routes. To do so, change the `@Component` decorator for Workout Builder to:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `selector`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `<abe-sub-nav-main>` custom element to the template
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `<router-outlet>` tag to the template
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The decorator should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We are removing the selector because `WorkoutBuilderComponent` will not be embedded
    in the application root, `app.component.ts`. Instead, it will be reached from
    `app.routing-module.ts` through routing. And while it will handle incoming routing
    requests from `app.routes.ts`, it will, in turn, be routing them to the other
    components contained in the Workout Builder feature.
  prefs: []
  type: TYPE_NORMAL
- en: And those components will display their views using the `<router-outlet>` tag
    that we have just added to the `WorkoutBuilder` template. Given that the template
    for `Workout BuilderComponent` will be simple, we are using an inline `template`
    instead of a `templateUrl`.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, for a component's view we recommend using a `templateUrl` that points
    to a separate HTML template file. This is especially true when you anticipate
    that the view will involve more than a few lines of HTML. In that situation, it
    is much easier to work with a view inside its own HTML file.
  prefs: []
  type: TYPE_NORMAL
- en: We are also adding an `<abe-sub-nav-main>` element that will be used to create
    a secondary top-level menu for navigating within the *Workout Builder* feature.
    We'll discuss that a little later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Workout Builder module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s update `WorkoutBuilderModule`.  First, add the following import
    to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It imports the child routing that we just set up. Next, update the `@NgModule`
    decorator to add `workoutBuilderRoutingModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the imports and declarations for the new navigation components
    that can be found in `checkpoint4.2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Updating App Routing module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One last step: return to `app.routing-module.ts` and remove the import of the
    `WorkoutBuilderComponent` and the route definition that points to the builder:`{
    path: ''builder'', component: WorkoutBuilderComponent },`.'
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to leave the import of the `WorkoutBuilderModule`  in `app.module.ts`
    unchanged. We'll discuss removing that in the next section when we cover lazy
    loading.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have area or feature routing that contains child routes, and all the
    routes related to the *Workout Builder* are now separately contained in their
    own routing configuration. This means that we can manage all the routing for *Workout
    Builder* in the `WorkoutBuilderRoutes` component without affecting other parts
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see how the router combines the routes in `app.routes.ts` with the default
    route in `workout-builder.routes.ts`, if we now navigate from the start page to
    the Workout Builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/879d478e-200d-4a7f-9f42-46cda87c2735.png)'
  prefs: []
  type: TYPE_IMG
- en: If we look at the URL in the browser, it is `/builder/workouts`. You'll recall
    that the router link on the start page is `['/builder']`. So how did the router
    take us to this location?
  prefs: []
  type: TYPE_NORMAL
- en: 'It does it this way: when the link is clicked, the Angular router first looks
    to `app-routing.module.ts` for the `builder` path because that file contains the
    configuration for the root routes in our application. The router does not find
    that path because we have removed it from the routes in that file.'
  prefs: []
  type: TYPE_NORMAL
- en: However, `WorkoutBuilderModule` has been imported into our `AppModule` and that
    module in turn imports `workoutBuilderRoutingModule`. The latter file contains
    the child routes that we just configured. The router finds that `builder` is the
    parent route in that file and so it uses that route. It also finds the default
    setting that redirects to the child path `workouts` in the event that the `builder`
    path ends with an empty string, which it does in this case.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the screen, you will see it is displaying the view for `Workouts`
    (and not as previously *Workout Builder*). This means that the router has successfully
    routed the request to `WorkoutsComponent`, which is the component for the default
    route in the child route configuration that we set up in `workoutBuilderRoutingModule`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process of route resolution is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a8a361ee-a043-4814-893c-6eb4cb067fc0.png)'
  prefs: []
  type: TYPE_IMG
- en: One final thought on child routing. When you look at our child routing component, `workout-builder.component.ts`,
    you will see that it has no references to its parent component, `app.component.ts`
    (the `<selector>` tag has been removed, so  `WorkoutBuilderComponent`  is not
    being embedded in the root component). This means that we have successfully encapsulated
    `WorkoutBuilderComponent` (and all of its related components that are imported
    in the `WorkoutBuilderModule`) in a way that will allow us to move all of it elsewhere
    in the application, or even into a new application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time for us to move on to converting our routing for the Workout Builder
    to use lazy loading and building out its navigation menus. If you want to see
    the completed code for this next section, you can download it from the companion
    codebase in `checkpoint 4.3`. Again, if you are working along with us as we build
    the application, be sure and update the `styles.css` file, which we are not discussing
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is also available on GitHub: [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: `GitHub Branch: checkpoint4.3` (folder - `trainer`). If you are not using
    Git, download the snapshot of `Checkpoint 4.3` (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular6byexample/archive/checkpoint4.3.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.3.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading of routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we roll out our application, we expect that our users will be accessing
    the Workout Runner every day (and we know that this will be the case for you!).
    But, we anticipate that they will only occasionally be using the Workout Builder
    to construct their exercises and workout plans. It would, therefore, be nice if
    we could avoid the overhead of loading the Workout Builder when our users are
    just doing their exercises in the Workout Runner. Instead, we would prefer to
    load Workout Builder only on demand when a user wants to add to or update their
    exercises and workout plans. This approach is called **lazy loading**. Lazy loading
    allows us to employ an asynchronous approach when loading our modules. This means
    that we can load just what is required to get the application started and then
    load other modules as we need them.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, when we use the Angular CLI to build and serve our application,
    it uses WebPack's bundling and chunking capabilities to accomplish lazy loading.
    We'll be discussing these capabilities as we work through how to implement lazy
    loading in our application.
  prefs: []
  type: TYPE_NORMAL
- en: So in our *Personal Trainer*, we want to change the application so that it only
    loads the **Workout Builder** on demand. And the Angular router allows us to do
    just that using lazy loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'But before we get started implementing lazy loading, let''s take a look at
    our current application and how it is loading our modules. With the developer
    tools open in the Sources tab, start up the application; when the start page appears
    in your browser, if you look under the webpack node in the source tree, you will
    see that all the files in the application have loaded, including both the *Workout
    Runner* and *Workout Builder* files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a3d91ddd-3613-4e72-af09-10f7c84551a8.png)'
  prefs: []
  type: TYPE_IMG
- en: So, even though we may just want to use the *Workout Runner*, we have to load
    the *Workout Builder* as well. In a way, this makes sense if you think of our
    application as a **Single Page Application** (**SPA**). In order to avoid round
    trips to the server, an SPA will typically load all the resources that will be
    needed to use the application when it is first started up by a user. But in our
    case, the important point is that we do not need the *Workout Builder* when the
    application is first loaded. Instead, we would like to load those resources only
    when the user decides that they want to add or change a workout or exercise.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get started with making that happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, modify `app.routing-module.ts` to add the following route configuration
    for `WorkoutBuilderModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `loadChildren` property is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This configuration provides the information that will be needed to load and
    instantiate `WorkoutBuilderModule`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next go back to `workout-builder-routing.module.ts` and change the `path` property
    to an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We are making this change because we are now setting the path (`builder`) to
    the `WorkoutBuilderRoutes` in the new configuration for them that we added in
    `app.routing-module.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally go back to `app-module.ts`  and remove the `WorkoutBuilderModule` import
    in the `@NgModule` configuration in that file. What this means is that instead
    of loading the **Workout Builder** feature when the application first starts,
    we only load it when a user accesses the route to *Workout Builder*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go build and run the application again using `ng serve`. In the Terminal
    window, you should see something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4ac5d80c-d801-4ec7-acdf-5b4e30f5174e.png)'
  prefs: []
  type: TYPE_IMG
- en: What's interesting here is the last line that shows a separate file for the
    `workout.builder.module` called `workout-builder.module.chunk.js.`. **WebPack**
    has used what is called code splitting to carve out our workout builder module
    into a separate chunk. This chunk will not be loaded in our application until
    it is needed (that is when the router navigates to `WorkoutBuilderModule`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, keeping the Sources tab open in the Chrome developer tools bring up the
    application in the browser again. When the start page loads, only the files related
    to the *Workout Runner* appear and not those related to the *Workout Builder*,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/be994372-be5b-4fb3-bfcc-1aa0a96f2ded.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, if we clear the Network tab and click on the Create a Workout link, we''ll
    see the `workout-builder.module` chunk load:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/adfb8093-199e-4ef7-8afa-984364ffeeec.png)'
  prefs: []
  type: TYPE_IMG
- en: This means that we have achieved encapsulation of our new feature and with asynchronous
    routing we are able to use lazy loading to load all its components only when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Child and asynchronous routing make it straightforward to implement applications
    that allow us to have our cake and eat it too. On one hand, we can build SPAs
    with powerful client-side navigation, while on the other hand we can also encapsulate
    features in separate child routing components and load them only on demand.
  prefs: []
  type: TYPE_NORMAL
- en: This power and flexibility of the Angular router give us the ability to meet
    user expectations by closely mapping our application's behavior and responsiveness
    to the ways they will use the application. In this case, we have leveraged these
    capabilities to achieve what we set out to do: immediately load *Workout Runner *so
    that our users can get to work on their exercises right away, but avoid the overhead
    of loading *Workout Builder *and instead only serve it when a user wants to build
    a workout.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the routing configuration in place in the *Workout Builder*,
    we will turn our attention to building out the sub-level and left navigation;
    this will enable us to use this routing. The next sections cover implementing
    this navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating sub- and side-level navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic idea around integrating sub- and side-level navigation into the app
    is to provide context-aware sub-views that change based on the active view. For
    example, when we are on a list page as opposed to editing an item, we may want
    to show different elements in the navigation. An e-commerce site is a great example
    of this. Imagine Amazon's search result page and product detail page. As the context
    changes from a list of products to a specific product, the navigation elements
    that are loaded also change.
  prefs: []
  type: TYPE_NORMAL
- en: Sub-level navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start by adding sub-level navigation to the *Workout Builder*. We have
    already imported our `SubNavMainComponent` into the *Workout Builder*. But, currently
    it is just displaying placeholder content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/28e60e18-8309-4acd-b151-5b2a584a74ee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll now replace that content with three router links: Home, New Workout,
    and New Exercise.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `sub-nav-main.component.html` file and change the HTML in it to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, rerun the application and you will see the three navigation links. If
    we click on the New Exercise link button, we will be routed to `ExerciseComponent`
    and its view will appear in the Router Outlet in the *Workout Builder* view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0fb35542-d5c7-42b7-bc20-2a5f20ca0b98.png)'
  prefs: []
  type: TYPE_IMG
- en: The New Workout link button will work in a similar fashion; when clicked on,
    it will take the user to the `WorkoutComponent` and display its view in the router
    outlet. Clicking on the Home link button will return the user to the `WorkoutsComponent` and
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Side navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Side-level navigation within the *Workout Builder* will vary depending on the
    child component that we navigate to. For instance, when we first navigate to the
    *Workout Builder*, we are taken to the Workouts screen because the `WorkoutsComponent` route
    is the default route for the *Workout Builder*. That component will need side
    navigation; it will allow us to select to view a list of workouts or a list of
    exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component-based nature of Angular gives us an easy way to implement these
    context-sensitive menus. We can define new components for each of the menus and
    then import them into the components that need them. In this case, we have three
    components that will need side menus: **Workouts**, **Exercises**, and **Workout**.
    The first two of these components can actually use the same menu so we really
    only need two side menu components: `LeftNavMainComponent`, which will be like
    the preceding menu and will be used by the `Exercises` and `Workouts` components,
    and `LeftNavExercisesComponent`, which will contain a list of existing exercises
    and will be used by the `Workouts` component.'
  prefs: []
  type: TYPE_NORMAL
- en: We already have files for the two menu components, including template files,
    and have imported them into `WorkoutBuilderModule`. We will now integrate these
    into the components that need them.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, modify the `workouts.component.html` template to add the selector for
    the menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, replace the placeholder text in the `left-nav-main.component.html` with
    the navigation links to `WorkoutsComponent` and `ExercisesComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application and you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/021d2798-3ff7-47bf-8fe9-e122f98333f0.png)'
  prefs: []
  type: TYPE_IMG
- en: Follow the exact same steps to complete the side menu for the `Exercises` component.
  prefs: []
  type: TYPE_NORMAL
- en: We won't show the code for this menu here, but you can find it in the `workout-builder/exercises`
    folder under `trainer/src/app` in `checkpoint 4.3` of the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the menu for the Workout screen, the steps are the same except that you
    should change `left-nav-exercises.component.html` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We will use this template as the starting point for building out a list of exercises
    that will appear on the left-hand side of the screen and can be selected for inclusion
    in a workout.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing workout and exercise lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even before we start implementing the Workout and Exercise list pages, we need
    a data store for exercise and workout data. The current plan is to have an in-memory
    data store and expose it using an Angular service. In [Chapter 3](cba52e86-29c5-4c51-a34f-5db71de16503.xhtml),
    *Supporting Server Data Persistence*, where we talk about server interaction,
    we will move this data to a server store for long-term persistence. For now, the
    in-memory store will suffice. Let's add the store implementation.
  prefs: []
  type: TYPE_NORMAL
- en: WorkoutService as a workout and exercise repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The plan here is to create a `WorkoutService` instance that is responsible
    for exposing the exercise and workout data across the two applications. The main
    responsibilities of the service include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise-related CRUD operations**: Get all exercises, get a specific exercise
    based on its name, create an exercise, update an exercise, and delete it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Workout-related CRUD operations**: These are similar to the exercise-related
    operations, but targeted toward the workout entity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code is available to download on GitHub at [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample).
    The branch to download is as follows: **GitHub Branch: checkpoint4.4** (folder`trainer`).
    If you are not using Git, download the snapshot of `Checkpoint 4.4` (a ZIP file)
    from the following GitHub location: [https://github.com/chandermani/angular6byexample/archive/checkpoint4.4.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.4.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Again, if you are working along with us as we build the application,
    be sure to update the `styles.css` file, which we are not discussing here. Because
    some of the files in this section are rather long, rather than showing the code
    here, we are also going to suggest at times that you simply copy the files into
    your solution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate `workout-service.ts` in the `trainer/src/core` folder. The code in that
    file should look like the following, except for the implementation of the two
    methods `setupInitialExercises` and `setupInitialWorkouts`, which we have left
    out because of their length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we have mentioned before, the implementation of an Angular service is straightforward.
    Here, we are declaring a class with the name `WorkoutService` and decorating it
    with `@Injectable` . Within the `@Injectable` decorator, we have set the `provided-in`
    property to `CoreModule`.  This registers `WorkoutService` as a provider with
    Angular's **Dependency Injection** framework and makes it available throughout
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: In the class definition, we first create two arrays: one for `Workouts` and
    one for `Exercises`. These arrays are of types `WorkoutPlan` and `Exercise` respectively,
    and we, therefore, need to import `WorkoutPlan` and `Exericse` from `model.ts`
    to get the type definitions for them.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor calls two methods to set up the Workouts and Services List.
    At the moment, we are just using an in-memory store that populates these lists
    with data.
  prefs: []
  type: TYPE_NORMAL
- en: The two methods, `getExercises` and `getWorkouts`, as the names suggest, return
    a list of exercises and workouts respectively. Since we plan to use the in-memory
    store to store workout and exercise data, the `Workouts` and `Exercises` arrays
    store this data. As we go along, we will be adding more functions to the service.
  prefs: []
  type: TYPE_NORMAL
- en: Time to build out the components for the workout and exercise lists!
  prefs: []
  type: TYPE_NORMAL
- en: Workout and exercise list components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, open the `workouts.component.ts` file in the `trainer/src/app/workout-builder/workouts`
    folder and update the imports as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This new code imports the Angular  `Router` as well as `WorkoutService` and
    the `WorkoutPlan` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, replace the class definition with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This code adds a constructor into which we are injecting the `Router` and the
    `WorkoutService`. The `ngOnInit` method then calls the `getWorkouts` method on
    the `WorkoutService` and populates a `workoutList`  array with a list of `WorkoutPlans`
    returned from that method call. We'll use that `workoutList` array to populate
    the list of workout plans that will display in the `Workouts` component's view.
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice that we are putting the code for calling `WorkoutService` into
    the `ngOnInit` method. We want to avoid placing this code in the constructor.
    Eventually, we will be replacing the in-memory store that this service uses with
    a call to an external data store and we do not want the instantiation of our component
    to be affected by this call. Adding these method calls to the constructor would
    also complicate testing the component.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid such unintended side effects, we instead place the code in the `ngOnInit`
    method. This method implements one of Angular's lifecycle hooks, `OnInit`, which
    Angular calls after creating an instance of the service. This way, we rely on
    Angular to call this method in a predictable way that does not affect the instantiation
    of the component.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll make almost identical changes to the `Exercises` component. As with
    the `Workouts` component, this code injects the workout service into our component.
    This time, we then use the workout service to retrieve the exercises.
  prefs: []
  type: TYPE_NORMAL
- en: As it is similar to the `Workouts` component, we won't show that code here.
    Just add it from the `workout-builder/exercises` folder in  `checkpoint 4.4`.
  prefs: []
  type: TYPE_NORMAL
- en: Workout and exercise list views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we need to implement the list views that have so far been empty!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will be updating the code from `checkpoint 4.3` with `checkpoint
    4.4`. So if you are coding along with us, simply follow the steps laid out in
    this section. If you want to see the finished code, then just copy the files from
    `checkpoint 4.4` into your solution.
  prefs: []
  type: TYPE_NORMAL
- en: Workouts list views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get the view working, open `workouts.component.html` and add the following
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We are using one of the Angular core directives, `ngFor`, to loop through the
    list of workouts and display them in a list on the page. We add the `*` sign in
    front of `ngFor` to identify it as an Angular directive. Using a `let` statement,
    we assign `workout` as a local variable that we use to iterate through the workout
    list and identify the values to be displayed for each workout (for example, `workout.title`).
    We then use one of our custom pipes, `orderBy`, to display a list of workouts
    in alphabetical order by title. We are also using another custom pipe, `secondsToTime`,
    to format the time displayed for the total workout duration.
  prefs: []
  type: TYPE_NORMAL
- en: If you are coding along with us, you will need to move the `secondsToTime` pipe
    into the shared folder and include it in the `SharedModule`. Then, add `SharedModule`
    to `WorkoutBuilderModule` as an additional import. That change has already been
    made in `checkpoint 4.4` in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we bind the click event to the following `onSelect` method that we
    add to our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This sets up navigation to the workout details page. This navigation happens
    when we click on an item in the workout list. The selected workout name is passed
    as part of the route`/URL` to the workout detail page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and refresh the builder page (`/builder/workouts`); one workout is
    listed, the 7 Minute Workout. Click on the tile for that workout. You''ll be taken
    to the Workout screen and the workout name, `7MinWorkout`, will appear at the
    end of the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/52e68978-023c-4c2a-baaa-3bdc273eb151.png)The Workout screen'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises list views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to follow the same approach for the `Exercises` list view as we
    did for the `Workouts` list view, except that in this case, we will actually be
    implementing two views: one for the `Exercises` component (which will display
    in the main content area when a user navigates to that component) and one for
    the `LeftNavExercisesComponent` exercises context menu (which will display when
    the user navigates to the `Workouts` component to create or edit a workout).'
  prefs: []
  type: TYPE_NORMAL
- en: For the `Exercises` component, we will follow an approach that is almost identical
    to what we did to display a list of workouts in the `Workouts` component. So,
    we won't show that code here. Just add the files for `exercises.component.ts`
    and `exercises.component.html` from `checkpoint 4.4`.
  prefs: []
  type: TYPE_NORMAL
- en: When you are done copying the files, click on the Exercises link in the left
    navigation to load the 12 exercises that you have already configured in `WorkoutService`.
  prefs: []
  type: TYPE_NORMAL
- en: As with the `Workouts` list, this sets up the navigation to the exercise detail
    page. Clicking on an item in the exercises list takes us to the exercise detail
    page. The selected exercise name is passed as part of the route`/URL` to the exercise
    detail page.
  prefs: []
  type: TYPE_NORMAL
- en: In the final list view, we will add a list of exercises that will display in
    the left context menu for the *Workout Builder* screen. This view is loaded in
    the left navigation when we create or edit a workout. Using Angular's component-based
    approach, we will update the `leftNavExercisesComponent` and its related view
    to provide this functionality. Just add the files for `left-nav-exercises.component.ts`
    and `left-nav-exercises.component.html` from the `trainer/src/app/navigation`
    folder in `checkpoint 4.4`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are done copying those files, click on the New Workout button on the
    sub-navigation menu in the *Workout Builder* and you will now see a list of exercises
    displayed in the left navigation menu—exercises that we have already configured
    in `WorkoutService`.
  prefs: []
  type: TYPE_NORMAL
- en: Time to add the ability to load, save, and update exercise/workout data!
  prefs: []
  type: TYPE_NORMAL
- en: Building a workout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core functionality *Personal Trainer* provides centers around workout and
    exercise building. Everything is there to support these two functions. In this
    section, we focus on building and editing workouts using Angular.
  prefs: []
  type: TYPE_NORMAL
- en: The `WorkoutPlan` model has already been defined, so we are aware of the elements
    that constitute a workout. The *Workout Builder* page facilitates user input and
    lets us build/persist workout data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once complete, the *Workout Builder* page will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/876d3637-e3f8-468e-92e7-6f89cb85c636.png)'
  prefs: []
  type: TYPE_IMG
- en: The page has a left navigation that lists all the exercises that can be added
    to the workout. Clicking on the arrow icon on the right adds the exercise to the
    end of the workout.
  prefs: []
  type: TYPE_NORMAL
- en: The center area is designated for workout building. It consists of exercise
    tiles laid out in order from top to bottom and a form that allows the user to
    provide other details about the workout such as name, title, description, and
    rest duration.
  prefs: []
  type: TYPE_NORMAL
- en: 'This page operates in two modes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create/New: This mode is used for creating a new workout. The URL is `#/ builder/workout/new`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Edit: This mode is used for editing the existing workout. The URL is `#/ builder/workout/:id`,
    where `:id` maps to the name of the workout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this understanding of the page elements and layout, it's time to build
    each of these elements. We will start with left nav (navigation).
  prefs: []
  type: TYPE_NORMAL
- en: Finishing left nav
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the end of the previous section, we updated the left navigation view for
    the `Workout` component to show a list of exercises. Our intention was to let
    the user click on an arrow next to an exercise to add it to the workout. At the
    time, we deferred implementing the `addExercise` method in the `LeftNavExercisesComponent`
    that was bound to that click event. Now, we will go ahead and do that.
  prefs: []
  type: TYPE_NORMAL
- en: We have a couple of options here. The `LeftNavExercisesComponent` is a child
    component of the `WorkoutComponent`, so we can implement child/parent inter-component
    communication to accomplish that. We covered this technique in the previous chapter
    while working on *7 Minute Workout*.
  prefs: []
  type: TYPE_NORMAL
- en: However, adding an exercise to the workout is part of a larger process of building
    the workout and using child/parent inter-component communication would make the
    implementation of the `AddExercise` method differ from the other functionality
    that we will be adding going forward.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, it makes more sense to follow another approach for sharing
    data, one that we can use consistently throughout the process of building a workout.
    That approach involves using a service. As we get into adding the other functionality
    for creating an actual workout, such as save/update logic and implementing the
    other relevant components, the benefits of going down the service route will become
    increasingly clear.
  prefs: []
  type: TYPE_NORMAL
- en: So, we introduce a new service into the picture: `WorkoutBuilderService`. The
    ultimate aim of `WorkoutBuilderService` service is to coordinate between `WorkoutService`
    (which retrieves and persists the workout) and the components (such as `LeftNavExercisesComponent`
    and others we will add later), while the workout is being built, hence reducing
    the amount of code in `WorkoutComponent` to the bare minimum.
  prefs: []
  type: TYPE_NORMAL
- en: Adding WorkoutBuilderService
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`WorkoutBuilderService` monitors the state of the workout that a user of the
    application is building. It:'
  prefs: []
  type: TYPE_NORMAL
- en: Tracks the current workout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a new workout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loads the existing workout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saves the workout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy `workout-builder-service.ts` from the `workout-builder/builder-services` folder
    under `trainer/src/app` in `checkpoint 4.5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is also available for everyone to download on GitHub at [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: `GitHub Branch: checkpoint4.5` (folder—`trainer`). If you are not using
    Git, download the snapshot of `Checkpoint 4.5` (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular6byexample/archive/checkpoint4.5.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.5.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Again, if you are working along with us as we build the application,
    be sure to update the `styles.css` file, which we are not discussing here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While we normally make services available application-wide,  `WorkoutBuilderService`
    will only be used in the *Workout Builder* feature. Therefore, instead of registering
    it with the providers in `AppModule`, we have registered it in the provider array
    of `WorkoutBuilderModule` as follows (after adding it as an import at the top
    of the file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Adding it as a provider here means that it will only be loaded when the *Workout
    Builder* feature is being accessed and it cannot be reached outside this module.
    This means that it can be evolved independently of other modules in the application
    and can be modified without affecting other parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some of the relevant parts of the service.
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkoutBuilderService` needs the type definitions for `WorkoutPlan`, `ExercisePlan`,
    and `WorkoutService`, so we import these into the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`WorkoutBuilderService` has a dependency on `WorkoutService` to provide persistence
    and querying capabilities. We resolve this dependency by injecting `WorkoutService`
    into the constructor for `WorkoutBuilderService`**:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`WorkoutBuilderService` also needs to track the workout being built. We use
    the `buildingWorkout` property for this. The tracking starts when we call the
    `startBuilding` method on the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The basic idea behind this tracking function is to set up a `WorkoutPlan` object
    (`buildingWorkout`) that will be made available to components to manipulate the
    workout details. The `startBuilding` method takes the workout name as a parameter.
    If the name is not provided, it implies we are creating a new workout, and hence
    a new `WorkoutPlan` object is created and assigned; if not, we load the workout
    details by calling `WorkoutService.getWorkout(name)`. In any case, the `buildingWorkout`
    object has the workout being worked on.
  prefs: []
  type: TYPE_NORMAL
- en: The `newWorkout` object signifies whether the workout is new or an existing
    one. It is used to differentiate between save and update situations when the `save`
    method on this service is called.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the methods, `removeExercise`, `addExercise`, and `moveExerciseTo`, are
    self-explanatory and affect the exercise list that is part of the workout (`buildingWorkout`).
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkoutBuilderService` is calling a new method, `getWorkout`, on `WorkoutService`,
    which we have not added yet. Go ahead and copy the `getWorkout` implementation
    from the `workout-service.ts` file in the `services` folder under `trainer/src`
    in `checkpoint 4.5`. We will not dwell on the new service code as the implementation
    is quite simple.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's get back to left nav and implement the remaining functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Adding exercises using ExerciseNav
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add exercises to the workout we are building, we just need to import `WorkoutBuilderService`
    and `ExercisePlan`, inject `WorkoutBuilderService` into the `LeftNavExercisesComponent`,
    and call its `addExercise` method, passing the selected exercise as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Internally, `WorkoutBuilderService.addExercise` updates the `buildingWorkout`
    model data with the new exercise.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding implementation is a classic case of sharing data between independent
    components. The shared service exposes the data in a controlled manner to any
    component that requests it. While sharing data, it is always a good practice to
    expose the state/data using methods instead of directly exposing the data object.
    We can see that in our component and service implementations too. `LeftNavExercisesComponent`
    does not update the workout data directly; in fact, it does not have direct access
    to the workout being built. Instead, it relies upon the service method, `addExercise`,
    to change the current workout's exercise list.
  prefs: []
  type: TYPE_NORMAL
- en: Since the service is shared, there are pitfalls to be aware of. As services
    are injectable through the system, we cannot stop any component from taking dependency
    on any service and calling its functions in an inconsistent manner, leading to
    undesired results or bugs. For example, `WorkoutBuilderService` needs to be initialized
    by calling `startBuilding` before `addExercise` is called. What happens if a component
    calls `addExercise` before the initialization takes place?
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Workout component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `WorkoutComponent` is responsible for managing a workout. This includes
    creating, editing, and viewing the workout. Due to the introduction of `WorkoutBuilderService`,
    the overall complexity of this component will be reduced. Other than the primary
    responsibility of integrating with, exposing, and interacting with its template
    view, we will delegate most of the other work to `WorkoutBuilderService`.
  prefs: []
  type: TYPE_NORMAL
- en: The `WorkoutComponent` is associated with two `routes/views`, namely `/builder/workout/new`
    and `/builder/workout/:id`. These routes handle both creating and editing workout
    scenarios. The first job of the component is to load or create the workout that
    it needs to manipulate.
  prefs: []
  type: TYPE_NORMAL
- en: Route parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: But before we get to building out the `WorkoutComponent`and its associated view,
    we need to touch briefly on the navigation that brings a user to the screen for
    that component. This component handles both creating and editing workout scenarios.
    The first job of the component is to load or create the workout that it needs
    to manipulate. We plan to use Angular's routing framework to pass the necessary
    data to the component, so that it will know whether it is editing an existing
    workout or creating a new one, and in the case of an existing workout, which component
    it should be editing.
  prefs: []
  type: TYPE_NORMAL
- en: How is this done? The `WorkoutComponent` is associated with two routes, namely
    `/builder/workout/new` and `/builder/workout/:id`. The difference in these two
    routes lies in what is at the end of these routes; in one case, it is `/new`,
    and in the other,` /:id`. These are called **route parameters.** The `:id` in
    the second route is a token for a route parameter. The router will convert the
    token to the ID for the workout component. As we saw earlier, this means that
    the URL that will be passed to the component in the case of *7 Minute Workout*
    will be `/builder/workout/7MinuteWorkout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we know that this workout name is the right parameter for the ID? As
    you recall, when we set up the event for handling a click on the Workout tiles
    on the Workouts screen that takes us to the Workout screen, we designated the
    workout name as the parameter for the ID, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are constructing the route using the programmatic interface for the
    router. The `router.navigate` method accepts an array. This is called the **link
    parameters array**. The first item in the array is the path of the route, and
    the second is a route parameter that specifies the ID of the workout. In this
    case, we set the `id` parameter to the workout name. We can also construct the
    same type of URL as part of a router link or simply enter it in the browser to
    get to the Workouts screen and edit a particular workout.
  prefs: []
  type: TYPE_NORMAL
- en: The other of the two routes ends with `/new`. Since this route does not have
    a `token` parameter, the router will simply pass the URL unmodified to the `WorkoutComponent`.
    The `WorkoutComponent` will then need to parse the incoming URL to identify that
    it should be creating a new component.
  prefs: []
  type: TYPE_NORMAL
- en: Route guards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: But before the link takes the user to the `WorkoutComponent`, there is another
    step along the way that we need to consider. The possibility always exists that
    the ID that is passed in the URL for editing a workout could be incorrect or missing.
    In those cases, we do not want the component to load, but instead, we want to
    have the user redirected to another page or back to where they came from.
  prefs: []
  type: TYPE_NORMAL
- en: Angular offers a way to accomplish this result with **route guards**. As the
    name implies, route guards **provide a way to prevent navigation to a route**.
    A route guard can be used to inject custom logic that can do things such as check
    authorization, load data, and make other verifications to determine whether the
    navigation to the component needs to be canceled or not. And all of this is done
    before the component loads so it is never seen if the routing is canceled.
  prefs: []
  type: TYPE_NORMAL
- en: Angular offers several route guards, including `CanActivate`, `CanActivateChild`,
    `CanDeActivate`, `Resolve`, and `CanLoad`**.** At this point, we are interested
    in the `Resolve` route guard**. **The `Resolve` guard will allow us not only to
    check for the existence of a workout, but also to load the data associated with
    a workout before loading the `WorkoutComponent`. The advantage of doing the latter
    is that we avoid the necessity of checking to make sure the data is loaded in
    the `WorkoutComponent` and it eliminates adding conditional logic throughout its
    component template to make sure that the data is there when it is rendered.  This
    will be especially useful when in the next chapter when we start using `observables`
    where we must wait for the observable to complete before we are guaranteed of
    having the data that it will provide. The `Resolve` guard will handle waiting
    for the observable to complete, which means that the `WorkoutComponent` will be
    guaranteed to have the data that it needs before it loads.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the resolve route guard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Resolve` guard allows us to prefetch the data for a workout. In our case,
    what we want to do is use `Resolve` to check the validity of any ID that is passed
    for an existing workout. Specifically, we will run a check on that ID by making
    a call to the `WorkoutBuilderService` to retrieve the Workout Plan and see if
    it exists. If it exists, we will load the data associated with the Workout Plan
    so that it is available to the `WorkoutComponent`; if not we will redirect back
    to the Workouts screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy `workout.resolver.ts` from the `workout-builder/workout` folder under
    `trainer/src/app/workout` in `checkpoint 4.5` and you will see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `WorkoutResolver` is an injectable class that implements
    the `Resolve` interface.  The code injects the `WorkoutBuilderService` and `Router`
    into the class and implements the interface with the `resolve` method. The `resolve`
    method accepts two parameters; `ActivatedRouteSnapshot` and `RouterStateSnapshot`.
    In this case, we are only interested in the first of these two parameters, `ActivatedRouteSnapshot`. 
    It contains a `paramMap` from which we extract the ID parameter for the route.
  prefs: []
  type: TYPE_NORMAL
- en: The `resolve` method then calls the `startBuilding` method of `WorkoutBuildingService` using
    the parameter supplied in the route. If the workout exists, then `resolve` returns
    the data and the navigation proceeds; if not, it re-routes the user to the workouts
    page and returns false. If `new` is passed as an ID, `WorkoutBuilderService` will
    load a new workout and the `Resolve` guard will allow navigation to proceed to
    the `WorkoutComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: The `resolve` method can return a `Promise` , an `Observable,` or a synchronous
    value. If we return an `Observable`,  we will need to make sure that the `Observable`
    completes before proceeding with navigation. In this case, however, we are making
    a synchronous call to a local in-memory data store, so we are just returning a
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the implementation of the `WorkoutResolver`, first make sure to
    import and add it to `WorkoutBuilderModule` as a provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add it to the route configuration for `WorkoutComponent` by updating `workout-builder-routing.module.ts`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we add `WorkoutResolver` to the routing module''s imports.
    Then, we add `resolve { workout: WorkoutResolver }` to the end of the route configuration
    for `workout/new` and `workout/:id` . This instructs the router to use the `WorkoutResolver` resolve
    method and assign its return value to `workout` in the route''s data. This configuration
    means that `WorkoutResolver` will be called prior to the router navigating to `WorkoutComponent`
    and that the workout data will be available to the `WorkoutComponent` when it
    loads. We''ll see how to extract this data in the `WorkoutComponent` in the next
    section.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Workout component continued...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have established the routing that takes us to the `Workout` component,
    let's turn to completing its implementation. So, copy the `workout.component.ts`
    file from the `workout-builder/workout` folder under `trainer/src/app` in `checkpoint
    4.5`. (Also, copy `workout-builder.module.ts` from the `workout-builder` folder.
    We'll discuss the changes in this file a little later when we get to Angular forms.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `workout.component.ts` and you''ll see that we have added a constructor
    that injects `ActivatedRoute` and `WorkoutBuilderService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we have added the following `ngOnInit` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The method subscribes to the `route` and extracts the `workout` from the `route.data`.
    There is no need to check the workout exists because we have already done that
    in the `WorkoutResolver`.
  prefs: []
  type: TYPE_NORMAL
- en: We are subscribing to the `route.data` because as an `ActivatedRoute`, the `route`
    exposes its `data` as an  `Observable`, which can change during the lifetime of
    the component. This gives us the ability to reuse the same component instance
    with different parameters, even though the `OnInit` life cycle event for that
    component is called only once. We'll cover `Observables` in detail in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this code, we have also added a series of methods to the `Workout
    Component` for adding, removing,  and moving a workout. These methods all call
    corresponding methods on the `WorkoutBuilderService` and we will not review them
    in detail here. We've also added an array of `durations` for populating the duration
    drop-down list.
  prefs: []
  type: TYPE_NORMAL
- en: For now, this is enough for the **component** class implementation. Let's update
    the associated `Workout` template.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Workout template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, copy the `workout.component.html` files from the `workout-builder/workout`
    folder under `trainer/src/app` in `checkpoint 4.5`. Run the app, navigate to `/builder/workouts`,
    and double-click on the *7 Minute Workout* tile. This should load the *7 Minute
    Workout* details with a view similar to the one shown at the start of the *Building
    a workout* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the event of any problem, you can refer to the `checkpoint4.5` code in the
    `GitHub repository: Branch: checkpoint4.5` (folder - `trainer`).'
  prefs: []
  type: TYPE_NORMAL
- en: We will be dedicating a lot of time to this view, so let's understand some specifics
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exercise list div (`id="exercise-list"`) lists the exercises that are part
    of the workout in order. We display them as top-to-bottom tiles in the left part
    of the content area. Functionally, this template has:'
  prefs: []
  type: TYPE_NORMAL
- en: The Delete button to delete the exercise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reorder buttons to move the exercise up and down the list, as well as to the
    top and bottom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use `ngFor` to iterate over the list of exercises and display them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that we are using the `*` asterisk in front of `ngFor`,  which
    is shorthand for the `<template>` tag. We are also using `let` to set two local
    variables: `exerisePlan` to identify an item in the list of exercises and `i`
    to set up an index value that we will use to show a number for the exercises as
    they are displayed on the screen. We will also use the index value to manage reordering
    and deleting exercises from the list.'
  prefs: []
  type: TYPE_NORMAL
- en: The second div element for workout data (`id="workout-data"`) contains the HTML
    input element for details such as name, title, and rest duration, and a button
    to save workout changes.
  prefs: []
  type: TYPE_NORMAL
- en: The complete list has been wrapped inside the HTML form element so that we can
    make use of the form-related capabilities that Angular provides. So, what are
    these capabilities?
  prefs: []
  type: TYPE_NORMAL
- en: Angular forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forms are such an integral part of HTML development that any framework that
    targets client-side development just cannot ignore them. Angular provides a small
    but well-defined set of constructs that make standard form-based operations easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we think carefully, any form of interaction boils down to:'
  prefs: []
  type: TYPE_NORMAL
- en: Allowing user inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating those inputs against business rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submitting the data to the backend server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular has something to offer for all the preceding use cases.
  prefs: []
  type: TYPE_NORMAL
- en: For user input, it allows us to create two-way bindings between the form input
    elements and the underlying model, hence avoiding any boilerplate code that we
    may have to write for model input synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: It also provides constructs to validate the input before it can be submitted.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, Angular provides HTTP services for client-server interaction and persisting
    data to the server. We'll cover those services in [Chapter 3](cba52e86-29c5-4c51-a34f-5db71de16503.xhtml),
    *Supporting Server Data Persistence*.
  prefs: []
  type: TYPE_NORMAL
- en: Since the first two use cases are our main focus in this chapter, let's learn
    more about Angular user input and data validation support.
  prefs: []
  type: TYPE_NORMAL
- en: Template-driven and reactive forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular offers two types of forms: **template-driven** and **reactive**. We''ll
    be discussing both types of form in this chapter. Because the Angular team indicates
    that many of us will primarily use **template-driven forms**, that is what we
    will start in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Template-driven forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, **template-driven forms** place the emphasis on developing
    a form within an HTML template and handling most of the logic for the form inputs,
    data validation, saving, and updating in-form directives placed within that template.
    The result is that very little form-related code is required in the component
    class that is associated with the form's template.
  prefs: []
  type: TYPE_NORMAL
- en: '**Template-driven forms** make heavy use of the `ngModel` form directive. We
    will be discussing it in the next sections. It provides two-way data binding for
    form controls, which is a nice feature indeed. It allows us to write much less
    boilerplate code to implement a form. It also helps us to manage the state of
    the form (such as whether the form controls have changed and whether these changes
    have been saved). And, it also gives us the ability to easily construct messages
    that display if the validation requirements for a form control have not been met
    (for example, a required field not provided, email not in the right format, and
    so on).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to use Angular forms in our `Workout` component, we must first add
    some additional configuration. Open  `workout-buider.module.ts` from the `workout-builder`
    folder under `trainer/src/app` in `checkpoint 4.5`. You will see that it imports
    `FormsModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This brings in all that we will need to implement our form, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NgForm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngModel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start using these to build our form.
  prefs: []
  type: TYPE_NORMAL
- en: Using NgForm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our template (`workout.component.html`), we have added the following `form`
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at what we have here. One interesting thing is that we are
    still using a standard `<form>` tag and not a special Angular tag. We've also
    used `#` to define a local variable `f` to which we have assigned `ngForm`. Creating
    this local variable provides us with the convenience of being able to use it for
    form-related activity in other places within the form. For example, you can see
    that we are using it at the end of the opening `form` tag in a parameter, `f.form`,
    which is being passed to the `onSubmit` event bound to `(ngSubmit)`.
  prefs: []
  type: TYPE_NORMAL
- en: That last binding to `(ngSubmit)` should tell us that something different is
    going on here. Even though we did not explicitly add the `NgForm` directive, our
    `<form>` now has additional events such as `ngSubmit` to which we can bind actions.
    How did this happen? Well, this was not triggered by our assigning `ngForm` to
    a local variable. Instead, it happened *automagically* because we imported the
    forms module into `workout-builder.module.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: With that import in place, Angular scanned our template for a `<form>` tag and
    wrapped that `<form>` tag within an `NgForm` directive. The Angular documentation
    indicates that `<form>` elements in the component will be upgraded to use the
    Angular form system. This is important because it means that various capabilities
    of  `NgForm` are now available to use with the form. These include the `ngSubmit`
    event, which signals when a user has triggered a form submission and provides
    the ability to validate the entire form before submitting it.
  prefs: []
  type: TYPE_NORMAL
- en: ngModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the fundamental building blocks for template-driven forms is `ngModel`,
    and you will find it being used throughout our form. One of the primary roles
    of `ngModel` is to support two-way binding between user input and an underlying
    model. With such a setup, changes in the model are reflected in the view, and
    updates to the view too are reflected back on the model. Most of the other directives
    that we have covered so far only support one-way binding from models to views.
    `ngModel` goes both ways. But, be aware that it is only available within `NgForm`
    for use with elements that allow user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you know, we already have a model that we are using for the Workout page,
    `WorkoutPlan`. Here is the `WorkoutPlan` model from `model.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the `?` after `description`. This means that it is an optional
    property in our model and is not required to create a `WorkoutPlan`. In our form,
    this will mean that we will not require that a description be entered and everything
    will work fine without it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `WorkoutPlan` model, we also have a reference to an array made up
    of instances of another type of model: `ExercisePlan`. `ExercisePlan` in turn
    is made up of a number (`duration`) and another model (`Exercise`), which looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The use of these nested classes shows that we can create complex hierarchies
    of models that can all be data-bound within our form using `NgModel`. So throughout
    the form, whenever we need to update one of the values in a `WorkoutPlan` or an
    `ExercisePlan`, we can use `NgModel` to do that (the `WorkoutPlan` model will
    be represented by a local variable named `workout` in the following examples).
  prefs: []
  type: TYPE_NORMAL
- en: Using ngModel with input and textarea
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open `workout-component.html` and look for `ngModel.` It has been applied to
    form elements that allow user data input. These include input, textarea, and select.
    The workout name input setup looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `[(ngModel)]` directive sets up a two-way binding between the
    input control and the `workout.name` model property. The brackets and parentheses
    should each look familiar. Previously, we used them separately from each other:
    the `[]` brackets for property binding and the `()` parentheses for event binding.
    In the latter case, we usually bound the event to a call to a method in the component
    associated with the template. You can see an example of this in the form with
    the button that a user clicks on to remove an exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, the click event is explicitly bound to a method called `removeExercise`
    in our `Workout` component class. But for the `workout.name` input, we do not
    have an explicit binding to a method on the component. So what's going on here
    and how does the update happen without us calling a method on the component? The
    answer to that question is that the combination `[( )]` is shorthand for both
    binding a model property to the input element and wiring up an event that updates
    the model.
  prefs: []
  type: TYPE_NORMAL
- en: Put differently, if we reference a model element in our form, `ngModel` is smart
    enough to know that what we want to do is update that element (`workout.name`
    here) when a user enters or changes the data in the input field to which it is
    bound. Under the hood, Angular creates an update method similar to what we would
    otherwise have to write ourselves. Nice! This approach keeps us from having to
    write repetitive code to update our model.
  prefs: []
  type: TYPE_NORMAL
- en: Angular supports most of the HTML5 input types, including text, number, select,
    radio, and checkbox. This means binding between a model and any of these input
    types just works out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `textarea` element works the same as the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, we bind `textarea` to `workout.description`. Under the hood, `ngModel`
    updates the workout description in our model with every change we type into the
    text area.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test out how this works, why don''t we verify this binding? Add a model
    interpolation expression at the end of any of the linked inputs, such as this
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Open the Workout page, type something in the input, and see how the interpolation
    is updated instantaneously. The magic of two-way binding!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f8286d8e-bfb3-44e6-a448-771693aa1e64.png)'
  prefs: []
  type: TYPE_IMG
- en: Using ngModel with select
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at how `select` has been set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using `ngFor` here to bind to an array, `durations`, which is in the
    `Workout` component class. The array looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `ngFor` component will loop over the array and populate the drop-down values
    with the corresponding values in the array with the title for each item being
    displayed using interpolation, `{{duration.title}}`. And `[(ngModel)]` then binds
    the drop-down selection to the `exercisePlan.duration` in the model.
  prefs: []
  type: TYPE_NORMAL
- en: Notice here that we are binding to the nested model: `ExercisePlan`. And, we
    may have multiple exercises to which we will be applying this binding. With that
    being the case, we have to make use of another Angular form directive—`ngModelGroup`—to
    handle these bindings. `ngModelGroup` will allow us to create a nested group within
    our model that will contain the list of exercises included in the workout and
    then in turn loop over each exercise to bind its duration to the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we will add `ngModelGroup` to the div tag that we have created
    within the form to hold our list of exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'That takes care of creating the nested list of exercises. Now, we have to handle
    the individual exercises within that list, and we can do that by adding another
    `ngModelGroup` to the individual divs that contain each exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using the index in our for loop to dynamically create an individual
    model group for each of our exercises. These model groups will be nested inside
    the first model group that we created. Temporarily, add the tag `<pre>{{ f.value
    | json }}</pre>` to the bottom of the form and you will be able to see the structure
    of this nested model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This is powerful stuff that enables us to create complicated forms with nested
    models, all of which can use `ngModel` for databinding**.**
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed a subtle difference in the two `ngModelGroup` directive
    tags we just introduced. The second of the two is wrapped in angle brackets, `[]`,
    while the first is not. This is because with the first tag we are just naming
    our model group, whereas with the second we are binding it dynamically to each
    exercise's div tag using the index of our for loop.
  prefs: []
  type: TYPE_NORMAL
- en: Like input, select too supports two-way binding. We saw how changing select
    updates a model, but the model-to-template binding may not be apparent. To verify
    that a model to a template binding works, open the *7 Minute Workout* app and
    verify the duration dropdowns. Each one has a value that is consistent with the
    model value (30 seconds).
  prefs: []
  type: TYPE_NORMAL
- en: Angular does an awesome job of keeping the model and view in sync using `ngModel`.
    Change the model and see the view updated; change the view and watch as the model
    is updated instantaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's add validation to our form.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the next section is also available for everyone to download on
    GitHub at [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: `GitHub Branch: checkpoint4.6` (folder—`trainer`). Or if you are not
    using Git, download the snapshot of Checkpoint 4.6 (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular6byexample/archive/checkpoint4.6.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.6.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Again, if you are working along with us as we build the application,
    be sure and update the `styles.css` file, which we are not discussing here.'
  prefs: []
  type: TYPE_NORMAL
- en: Angular validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the saying goes, *never trust user input*. Angular has support for validation,
    including the standard required, min, max, and pattern, as well as custom validators.
  prefs: []
  type: TYPE_NORMAL
- en: ngModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ngModel` is the building block that we will use to implement validation. It
    does two things for us: it maintains the model state and provides a mechanism
    for identifying validation errors and displaying validation messages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, we need to assign `ngModel` to a local variable in all of our
    form controls that we will be validating. In each case, we need to use a unique
    name for this local variable. For example, for workout name we add `#name="ngModel"`
    within the `input` tag for that control along with the HTML 5 `required` attribute.
    The workout name `input` tag should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Continue through the form, assigning `ngModel` to local variables for each of
    the inputs. Also, add the required attribute for all the required fields.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular model state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever we use `NgForm`, every element within our form, including input, text
    area, and select, has some states defined on the associated model. `ngModel` tracks
    these states for us. The states tracked are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pristine`: The value of this is `true` as long as the user does not interact
    with the input. Any update to the `input` field and `ng-pristine` is set to `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dirty`: This is the reverse of `ng-pristine`. This is `true` when the input
    data has been updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`touched`: This is `true` if the control ever had focus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`untouched`: This is `true` if the control has never lost focus. This is just
    the reverse of `ng-touched`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valid`: This is `true` if there are validations defined on the `input` element
    and none of them are failing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invalid`: This is `true` if any of the validations defined on the element
    are failing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pristine``dirty` or `touched``untouched` are useful properties that can help
    us decide when error labels are shown.'
  prefs: []
  type: TYPE_NORMAL
- en: Angular CSS classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on the model state, Angular adds some CSS classes to an input element.
    These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ng-valid`: This is used if the model is valid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-invalid`: This is used if the model is invalid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-pristine`: This is used if the model is pristine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-dirty`: This is used if the model is dirty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-untouched`: This is used when the input is never visited'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-touched`: This is used when the input has focus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To verify it, go back to the `workoutName` input tag and add a template reference
    variable named `spy` inside the `input` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, below the tag, add the following label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Reload the application and click on the New Workout link in the *Workout Builder*.
    Before touching anything on the screen, you will see the following displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f8643209-7e90-4b2f-8665-60fad1fd0777.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add some content into the Name input box and tab away from it. The label changes
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a44e53db-4fdf-4545-8ac7-6a986a1aa973.png)'
  prefs: []
  type: TYPE_IMG
- en: What we are seeing here is Angular changing the CSS classes that apply to this
    control as the user interacts with it. You can also see these changes by inspecting
    the `input` element in the developer console.
  prefs: []
  type: TYPE_NORMAL
- en: 'These CSS class transitions are tremendously useful if we want to apply visual
    clues to the element depending on its state. For example, look at this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This draws a red border around any input control that has invalid data.
  prefs: []
  type: TYPE_NORMAL
- en: As you add more validations to the Workout page, you can observe (in the developer
    console) how these classes are added and removed as the user interacts with the
    `input` element.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of model states and how to use them, let's
    get back to our discussion of validations (before moving on, remove the variable
    name and label that you just added).
  prefs: []
  type: TYPE_NORMAL
- en: Workout validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The workout data needs to be validated for a number of conditions.
  prefs: []
  type: TYPE_NORMAL
- en: After taking the step of adding the local variable references for `ngModel`
    and the required attribute to our `input` fields, we have been able to see how
    `ngModel` tracks changes in the state of these controls and how it toggles the
    CSS styles.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying appropriate validation messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, the input needs to have a value; otherwise, the validation fails. But,
    how can we know if the validation has failed? `ngModel` comes to our rescue here.
    It can provide the validation state of the particular input. And that gives us
    what we need to display an appropriate validation message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the input control for the Workout name. In order to get a
    validation message to display, we have to first modify the input tag to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added a local variable called `#name` and assigned `ngModel` to it.
    This is called a template reference variable and we can use it with the following
    label to display a validation message for the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We are showing the validation message in the event that the name is not provided
    and the control has been touched. To check the first condition, we retrieve the
    `hasError` property of the control and see if the error type is `required`. We
    check to see if the name input has been `touched` because we do not want the message
    to display when the form first loads for a new workout.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that we are using a somewhat more verbose style to identify
    validation errors than is required in this situation. Instead of `name.control.hasError('required')`,
    we could have used `!name. valid` and it would have worked perfectly fine. However,
    using the more verbose approach allows us to identify validation errors with greater
    specificity, which will be essential when we start adding multiple validators
    to our form controls. We'll look at using multiple validators a little later in
    this chapter. For consistency, we'll stick with the more verbose approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the new Workout page (`/builder/workouts/new`) now. Enter a value in the
    name input box and then delete it. The error label appears as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a29cbdcd-9184-49cb-9e78-ab45b6605d97.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding more validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular provides several out-of-the-box validators, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '`required`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minLength`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxLength`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pattern`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the complete list of out-of-the box validators, see the documentation for
    the `Validators` class at [https://angular.io/api/forms/Validators.](https://angular.io/api/forms/Validators)
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve seen how the `required` validator works. Now, let''s look at two of
    the other out-of-the-box validators: `minLength` and `maxLength`. In addition
    to making it required, we want the title of the workout to be between 5 and 20
    characters (we''ll look at the `pattern` validator a little later in this chapter).'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in addition to the `required` attribute we added previously to the title
    input box, we will add the `minLength` attribute and set it to `5`, and add the
    `maxLength` attribute and set it to `20`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add another label with a message that will display when this validation
    is not met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Managing multiple validation messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll see that the conditions for displaying the message now test for the
    length not being zero. This prevents the message from displaying in the event
    that the control is touched but left empty. In that case, the title required message
    should display. This message only displays if nothing is entered in the field
    and we accomplish this by checking explicitly to see if the control''s `hasError`
    type is `required`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are attaching two validators to this input field, we can consolidate
    the check for the input being touched by wrapping both validators in a div tag
    that checks for that condition being met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: What we just did shows how we can attach multiple validations to a single input
    control and also display the appropriate message in the event that one of the
    validation conditions is not met. However, it's pretty clear that this approach
    will not scale for more complicated scenarios. Some inputs contain a lot of validations
    and controlling when a validation message shows up can become complex. As the
    expressions for handling the various displays get more complicated, we may want
    to refactor and move them into a custom directive. Creating a custom directive
    will be covered in detail in [Chapter 4](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml),
    *Angular Directives in Depth*.
  prefs: []
  type: TYPE_NORMAL
- en: Custom validation messages for an exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A workout without any exercise is of no use. There should at least be one exercise
    in the workout and we should validate this restriction.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with exercise count validation is that it is not something that
    the user inputs directly and the framework validates. Nonetheless, we still want
    a mechanism to validate the exercise count in a manner similar to other validations
    on this form.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we will do is add a hidden input box to the form that contains the count
    of the exercises. We will then bind this to `ngModel` and add a pattern validator
    that will check to make sure that there is more than one exercise. We will set
    the value of the input box to the count of the exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will attach a validation message to it similar to what we just did
    with our other validators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We are not using `ngModel` in its true sense here. There is no two-way binding
    involved. We are only interested in using it to do custom validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the new Workout page, add an exercise, and remove it; we should see this
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a46fd29c-0d4f-4157-ba8d-e6d2cd3b5e60.png)'
  prefs: []
  type: TYPE_IMG
- en: What we did here could have been easily done without involving any model validation
    infrastructure. But, by hooking our validation into that infrastructure, we do
    derive some benefits. We can now determine errors with a specific model and errors
    with the overall form in a consistent and familiar manner. Most importantly, if
    our validation fails here, the entire form will be invalidated.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing custom validation the way we just did is not what you would want
    to do very often. Instead, it will usually make more sense to implement this kind
    of complicated logic inside a custom directive. We'll cover creating custom directives
    in detail in [Chapter 4](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml), *Angular
    Directives in Depth*.
  prefs: []
  type: TYPE_NORMAL
- en: One nuisance with our newly implemented `Exercise Count` validation is that
    it shows when the screen for a new `Workout` first appears. With this message,
    we are not able to use `ng-touched` to hide the display. This is because the exercises
    are being added programmatically and the hidden input we are using to track their
    count never changes from untouched as exercises are added or removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this problem, we need an additional value to check when the state of
    the exercise list has been reduced to zero, except when the form is first loaded.
    The only way that situation can happen is if the user adds and then removes exercises
    from a workout to the point that there are no more exercises. So, we''ll add another
    property to our component that we can use to track whether the remove method has
    been called. We call that value `removeTouched` and set its initial value to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the remove method we will set that value to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add `removeTouched` to our validation message conditions, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we open a new workout screen, the validation message will not display.
    But if the user adds and then removes all the exercises, then it will display.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how model validation rolls up into form validation, we need to
    understand what form-level validation has to offer. However, even before that,
    we need to implement saving the workout and calling it from the workout form.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the workout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The workout that we are building needs to be persisted (in-memory only). The
    first thing that we need to do is extend `WorkoutService` and `WorkoutBuilderService`.
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkoutService` needs two new methods, `addWorkout` and `updateWorkout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `addWorkout` method does a basic check on the workout name and then pushes
    the workout into the workout array. Since there is no backing store involved,
    if we refresh the page, the data is lost. We will fix this in the next chapter
    where we persist the data to a server.
  prefs: []
  type: TYPE_NORMAL
- en: The `updateWorkout` method looks for a workout with the same name in the existing
    workouts array and if found, updates and replaces it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We only add one save method to `WorkoutBuilderService` as we are already tracking
    the context in which workout construction is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `save` method calls either `addWorkout` or `updateWorkout` in the `Workout`
    service based on whether a new workout is being created or an existing one is
    being edited.
  prefs: []
  type: TYPE_NORMAL
- en: From a service perspective, that should be enough. Time to integrate the ability
    to save workouts into the `Workout` component and learn more about the form directive!
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at `NgForm` in more detail, let''s add the save method to `Workout`
    to save the workout when the `Save` button is clicked on. Add this code to the
    `Workout` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We check the validation state of the form using its invalid property and then
    call the `WorkoutBuilderService.save` method if the form state is valid.
  prefs: []
  type: TYPE_NORMAL
- en: More on NgForm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forms in Angular have a different role to play as compared to traditional forms
    that post data to the server. If we go back and look again at the form tag, we
    will see that it is missing the standard action attribute. The standard form behavior
    of posting data to the server using full-page post-back does not make sense with
    an SPA framework such as Angular. In Angular, all server requests are made through
    asynchronous invocations originating from directives or services.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, Angular is also turning off the browser's inbuilt validation.
    As you have seen in this chapter, we are still using validation attributes such
    as `required` that look the same as native HTML validation attributes. However,
    as the Angular documentation explains, inside an Angular form "Angular uses directives
    to match these attributes with validator functions in the framework." See  [https://angular.io/guide/form-validation#template-driven-validation](https://angular.io/guide/form-validation#template-driven-validation).
  prefs: []
  type: TYPE_NORMAL
- en: 'The form here plays a different role. When the form encapsulates a set of input
    elements (such as input, textarea, and select) it provides an API for:'
  prefs: []
  type: TYPE_NORMAL
- en: Determining the state of the form, such as whether the form is dirty or pristine
    based on the input controls on it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking validation errors at the form or control level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you still want the standard form behavior, you can add an `ngNoForm` attribute
    to the `form` element, but this will definitely cause a full-page refresh. You
    can also turn on the browser's inbuilt validation by adding the `ngNativeValidate`
    attribute. We'll explore the specifics of the `NgForm` API a little later in this
    chapter when we look at saving the form and implementing validation.
  prefs: []
  type: TYPE_NORMAL
- en: The state of the `FormControl` objects within the form is being monitored by
    `NgForm`. If any of them are invalid, then `NgForm` sets the entire form to invalid.
    In this case, we have been able to use `NgForm` to determine that one or more
    of the `FormControl` objects is invalid and therefore the state of the form as
    a whole is invalid too.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at one more issue before we finish this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the saving of forms and validation messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open a new Workout page and directly click on the Save button. Nothing is saved
    as the form is invalid, but validations on individual form input do not show up
    at all. It now becomes difficult to know what elements have caused validation
    failure. The reason behind this behavior is pretty obvious. If we look at the
    error message binding for the name input element, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Remember that, earlier in the chapter, we explicitly disabled showing validation
    messages until the user has touched the input control. The same issue has come
    back to bite us and we need to fix it now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not have a way to explicitly change the touched state of our controls
    to untouched. Instead, we will resort to a little trickery to get the job done.
    We''ll introduce a new property called `submitted`. Add it at the top of the `Workout`
    class definition and set its initial value to `false`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable will be set to `true` on the Save button click. Update the save
    implementation by adding the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'However, how does this help? Well, there is another part to this fix that requires
    us to change the error message for each of the controls we are validating. The
    expression now changes to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: With this fix, the error message is shown when the control is touched or the
    form submit button is pressed (`submitted` is `true`). This expression fix now
    has to be applied to every validation message where a check appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now open the new Workout page and click on the Save button, we should
    see all validation messages on the input controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/39735e3a-1907-4f9b-b1c6-b619a72a9c98.png)'
  prefs: []
  type: TYPE_IMG
- en: Reactive forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The other type of form that Angular supports is called **reactive** forms. **Reactive
    forms** start with a model that is constructed in a component class. With this
    approach, we use the **form builder API** to create a form in code and associate
    it with a model.
  prefs: []
  type: TYPE_NORMAL
- en: Given the minimal code we have to write to get template-driven forms working,
    why and when should we consider using reactive forms? There are several situations
    in which we might want to use them. These include cases where we want to take
    programmatic control of creating the form. This is especially beneficial, as we
    will see, when we are trying to create form controls dynamically based on data
    we are retrieving from the server.
  prefs: []
  type: TYPE_NORMAL
- en: If our validation gets complicated, it is often easier to handle it in code.
    Using reactive forms, we can keep this complicated logic out of the HTML template,
    making the template syntax simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Another significant advantage of reactive forms is that they make unit-testing
    the form possible, which is not the case with **template-driven forms.** We can
    simply instantiate our form controls in our tests and then test them outside the
    markup on our page.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reactive forms** use three new form directives that we haven''t discussed
    before: `FormGroup`, `FormControl`, and `FormArray`. These directives allow the
    form object that is constructed in code to be tied directly to the HTML markup
    in the template. The form controls that are created in the component class are
    then directly available in the form itself. Technically speaking, this means that
    we don''t need to use `ngModel` (which is integral to template-driven forms) with
    reactive forms (although it can be used). The overall approach is a cleaner and
    less cluttered template with more focus on the code that drives the form. Let''s
    get started with building a reactive form.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with reactive forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll make use of reactive forms to build the form to add and edit Exercises.
    Among other things, this form will allow the user to add links to exercise videos
    on YouTube. And since they can add any number of video links, we will need to
    be able to add controls for these video links dynamically. This challenge will
    present a good test of how effective reactive forms can be in developing more
    complex forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the form will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5dbd17b9-5bcb-41b1-b46d-5f1260402003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To get started, open `workout-builder.module.ts` and add the following `import`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '`ReactiveFormsModule` contains what we will need to build reactive forms.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, copy `exercise-builder-service.ts` from the `workout-builder/builder-services`
    folder under `trainer/src/app` in `checkpoint 4.6` and import it into `workout-builder.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add it as an additional provider to the providers array in that same
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: You will notice here that we also have added `ExerciseResolver` as a provider.
    We won't be covering that here, but you should copy it from the `exercise` folder
    as well and also copy the updated `workout-builder-routing.module.ts`, which adds
    it as a route guard for the navigation to `ExerciseComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open `exercise.component.ts` and add the following import statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This brings in the following, which we will use to construct our form:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FormBuilder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormGroup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormControl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormArray`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we inject `FormBuilder` (as well as `Router`, `ActivatedRoute`, and
    `ExerciseBuilderService`) into the constructor of our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: With these preliminary steps out of the way, we can now go ahead and start building
    out our form.
  prefs: []
  type: TYPE_NORMAL
- en: Using the FormBuilder API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `FormBuilder` API is the foundation for reactive forms. You can think of
    it as a factory for turning out the forms we are constructing in our code. Go
    ahead and add the `ngOnInit` lifecycle hook to your class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: When `ngOnInit` fires, it will extract the data for an existing or new `exercise`
    from the route data that has been retrieved and returned by `ExerciseResolver`.
    This is the same pattern we followed with initializing the `Workout` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the `buildExerciseForm` method by adding the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s examine this code. To start with, we are using the injected instance
    of `FormBuilder` to construct the form and assign it to a local variable, `exerciseForm`.
    Using `formBuilder.group`, we add several form controls to our form. We add each
    of them by a simple key/value mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The left side of the mapping is the name of the `FormControl`, and the right
    is an array containing as its first element the value of the control (in our case,
    the corresponding element on our exercise model) and the second a validator (in
    this case, the out-of-the-box required validator). Nice and neat! It's definitely
    easier to see and reason about our form controls by setting them up outside the
    template.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can not only build up `FormControls` in our form this way but also add `FormControlGroups`
    and `FormControlArray`, which contain `FormControls` within them. This means we
    can create complex forms that contain nested input controls. In our case, as we
    have mentioned, we are going to need to accommodate the possibility of our users
    adding multiple videos to an exercise. We can do this by adding the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'What we are doing here is assigning a `FormArray` to videos, which means we
    can assign multiple controls in this mapping. To construct this new `FormArray`,
    we add the following `addVideoArray` method to our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: This method constructs a `FormControl` for each video; each is then added each
    to a `FormArray` that is assigned to the videos control in our form.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the form model to our HTML view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been working behind the scenes in our class to construct our
    form. The next step is to wire up our form to the view. To do this, we use the
    same controls that we used to build the form in our code: `formGroup`, `formControl`,
    and `formArray`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `exercise.component.html` and add a `form` tag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Within the tag, we are first assigning the `exerciseForm` that we just built
    in code to `formGroup`. This establishes the connection between our coded model
    and the form in the view. We also wire up the `ngSubmit` event to an `onSubmit`
    method in our code (we'll discuss this method a little later).
  prefs: []
  type: TYPE_NORMAL
- en: Adding form controls to our form inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we start constructing the inputs for our form. We''ll start with the
    input for the name of our exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: We assign the name of our coded form control to `formControlName`. This establishes
    the link between the control in our code and the `input` field in the markup.
    Another item of interest here is that we do not use the `required` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Adding validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next thing that we do is add a validation message to the control that will
    display in the event of a validation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this markup is very similar to what we used in template-driven forms
    for validation, except that the syntax for identifying the control is somewhat
    more verbose Again, it checks the state of the `hasError` property of the control
    to make sure it is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait a minute! How can we validate this input? Haven''t we removed the
    required attribute from our tag? This is where the control mappings that we added
    in our code come into play. If you look back at the code for the form model, you
    can see the following mapping for the `name` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The second element in the mapping array assigns the required validator to the
    name form control. This means that we don't have to add anything to our template;
    instead, the form control itself is attached to the template with a required validator.
    The ability to add a validator in our code enables us to conveniently add validators
    outside our template. This is especially useful when it comes to writing custom
    validators with complex logic behind them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dynamic form controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Exercise form that we are building requires that we allow the user to add
    one or more videos to the exercise. Since we don''t know how many videos the user
    may want to add, we will have to build the `input` fields for these videos dynamically
    as the user clicks on the Add Video button. Here''s how it will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/94aa6524-5112-41ea-8ce0-6c9e622cdce8.png)'
  prefs: []
  type: TYPE_IMG
- en: We have already seen the code in our component class that we use to do this.
    Now, let's take a look at how it is implemented in our template.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first use `ngFor` to loop through our list of videos. Then, we assign the
    index in our videos to a local variable, `i`. No surprises so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the loop, we do three things. First, we dynamically add a video `input` field
    for each of the videos currently in our exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add a button to allow the user to delete a video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: We bind a `deleteVideo` method in our component class to the button's `click`
    event and pass to it the index of the video being deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then add a validation message for each of the video `input` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The validation message follows the same pattern for displaying the message that
    we have used elsewhere in this chapter. We drill into the `exerciseFormControls`
    group to find the particular control by its index. Again, the syntax is verbose
    but easy enough to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final step in building out our reactive form is to handle saving the form.
    When we constructed the form tag earlier, we bound the `ngSubmit` event to the
    following `onSubmit` method in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'This method sets `submitted` to `true`, which will trigger the display of any
    validation messages that might have been previously hidden because the form had
    not been touched. It also returns without saving in the event that there are any
    validation errors on the form. If there are none, then it calls the following
    `mapFormValues` method, which assigns the values from our form to the `exercise`
    that will be saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: It then calls the save method in `ExerciseBuilderService` and routes the user
    back to the exercise list screen (remember that any new exercise will not display
    in that list because we have not yet implemented data persistence in our application).
  prefs: []
  type: TYPE_NORMAL
- en: We hope this makes it clear; reactive forms offer many advantages when we are
    trying to build more complicated forms. They allow programming logic to be removed
    from the template. They permit validators to be added to the form programmatically.
    And, they support building forms dynamically at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Custom validators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we'll take a look at one more thing before we conclude this chapter. As
    anyone who has worked on building web forms (either in Angular or any other web
    technology) knows, we are often called on to create validations that are unique
    to the application we are building. Angular provides us with the flexibility to
    enhance our reactive form validation by building custom validators.
  prefs: []
  type: TYPE_NORMAL
- en: In building our exercise form, we need to be sure about what is entered, as
    a name contains only alphanumeric characters and no spaces. This is because when
    we get to storing the exercises in a remote data store, we are going to use the
    name of the exercise as its key. So, in addition to the standard required field
    validator, let's build another validator that checks to make sure that the name
    entered is in alphanumeric form only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a custom control is quite straightforward. In its simplest form, an
    Angular custom validator is a function that takes a control as an input parameter,
    runs the validation check, and returns true or false. So, let''s start by adding
    a TypeScript file with the name `alphanumeric-validator.ts`. In that file, first
    import `FormControl` from `@angular/forms`, then add the following class to that
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The code follows the pattern for creating a validator that we just mentioned.
    The only thing that may be a little surprising is that it returns true when the
    validation fails! As long as you are clear on this one quirk, you should have
    no problem writing your own custom validator.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating a custom validator into our forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So how do we plug our custom validator into our form? If we are using reactive
    forms, the answer is pretty simple. We add it just like a built-in validator when
    we build our form in code. Let''s do that. Open `exercise.component.ts` and first
    add an import for our custom validator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, modify the form builder code to add the validator to the `name` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Since the name control already has a required validator, we add `AlphaNumericValidator`
    as a second validator using an array that contains both validators. The array
    can be used to add any number of validators to a control.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is to incorporate the appropriate validation message for the
    control into our template. Open `workout.component.html` and add the following
    label just below the label that displays the message for the required validator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The exercise screen will now display a validation message if a non-alphanumeric
    value is entered in the name input box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/62930377-9559-4807-8c6f-b86049e996e2.png)'
  prefs: []
  type: TYPE_IMG
- en: As we hope you can see, reactive forms give us the ability to add custom validators
    to our forms in a straightforward manner that allows us to maintain the validation
    logic in our code and easily integrate it into our templates.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that in this chapter, we have not covered how to use custom
    validators in template-driven forms. That is because implementing them requires
    the additional step of building a custom directive. We'll cover that in [Chapter
    4](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml), *Angular Directives in Depth*.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration options for running validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move on from validation, there is one more topic to cover and that
    is configuration options for running the validations. So far, we have been using
    the default option, which runs validation checks on every input event. However,
    you have the choice of configuring them to run either on "blur"(that is when the
    user leaves an input control) or when the form is submitted. You can set this
    configuration at the form level or on a control-by-control basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we might decide that to avoid the complexity of handling missing
    exercises in the workout form, we will set that form to validate only upon submit.
    We can set this by adding the following highlighted assignment of `NgFormOptions`
    to the form tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This instructs Angular to run our validations only upon `submit`. Try it and
    you’ll see that no validations appear when you make entries into the form. Leave
    the form blank and press the Save button, and you will see the validation messages
    appear. Taking this approach, of course, means that there are no visual cues to
    the user regarding validation until they press the Save button.
  prefs: []
  type: TYPE_NORMAL
- en: There are also a couple of other unintended side effects to using this approach
    in our form. The first is that the title no longer updates at the top of the screen
    as we type into the title input box. That value will only be updated when we press
    Save. Second, you will also see a validation message appear if you add one or
    more workouts and then remove all of them. This is because of the special conditions
    we set up for this control, which cause it to fire outside the normal validation
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, maybe we should take a different approach. Angular provides the option
    of implementing more fine-grained control of the validation flow by allowing us
    to make such configurations at the control level using `ngModelOptions`. For example,
    let’s remove the `ngFormOptions` assignment from the form tag and modify the title
    input control to add `ngModelOptions` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll then notice that as you type the title into the input box, it does not
    update the title on the screen until you move off it (which triggers the `updateOn`
    event):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b8ffe1dc-c01d-4c0d-a100-d45672b67cfe.png)'
  prefs: []
  type: TYPE_IMG
- en: As you will remember, the default option caused the title to update with every
    keystroke. This is a contrived example but it illustrates how the differences
    in these configurations work.
  prefs: []
  type: TYPE_NORMAL
- en: 'You probably don’t see the need to use the on blur setting here. But, in case
    where you may be doing validation by calling an external data store, this approach
    could be helpful in limiting the number of calls that are being made. And making
    such remote calls is exactly what we will be doing in [Chapter 4](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml), *Angular
    Directives in Depth*, when we implement a custom directive. The directive will
    be checking for duplicate names that already exist in our remote data store. So,
    let’s remove this configuration from the title input control and place it instead
    on the name input control, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'We also can set the validation timing options within a reactive form. From
    what we have already learned about reactive forms, you will not be surprised to
    learn that we will be applying these settings in our code rather than the template.
    For example, to set them for a form group you use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also apply them to individual form controls and that is what we will
    do in the case of our exercise form. Like the workout form, we will want to be
    able to validate the uniqueness of the name by making a remote call. So, we will
    want to limit the validation checking in a similar manner. We’ll do that by adding
    the following to the code that creates the name form control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are putting the setting, along with the `validators` array, in
    the options object inside a pair of curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a *Personal Trainer* app. The process of converting a specific *7
    Minute Workout* app to a generic *Personal Trainer* app helped us learn a number
    of new concepts. We started the chapter by defining the new app requirements.
    Then, we designed the model as a shared service.
  prefs: []
  type: TYPE_NORMAL
- en: We defined some new views and corresponding routes for the *Personal Trainer*
    app. We also used both child and asynchronous routing to separate out *Workout
    Builder* from the rest of the app.
  prefs: []
  type: TYPE_NORMAL
- en: We then turned our focus to workout building. One of the primary technological
    focuses in this chapter was on Angular forms. The *Workout Builder* employed a
    number of form input elements and we implemented a number of common form scenarios
    using both template-driven and reactive forms. We also explored Angular validation
    in depth, and implemented a custom validator. We also covered configuring the
    timing options for running validation.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is all about client-server interaction. The workouts and exercises
    that we create need to be persisted. In the next chapter, we build a persistence
    layer, which will allow us to save workout and exercise data on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Before we conclude this chapter, here is a friendly reminder. If you have not
    completed the exercise building routine for *Personal Trainer*, go ahead and do
    it. You can always compare your implementation with what has been provided in
    the companion code base. There are also things you can add to the original implementation,
    such as file uploads for the exercise image, and once you are more familiar with
    client-server interaction, a remote check to determine whether the YouTube videos
    actually exist.
  prefs: []
  type: TYPE_NORMAL

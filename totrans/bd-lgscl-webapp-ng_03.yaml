- en: Supporting Server Data Persistence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持服务器数据持久化
- en: It's now time to talk to the server! There is no fun in creating a workout,
    adding exercises, and saving it to later realize that all our efforts are lost
    because the data did not persist anywhere. We need to fix this.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是与服务器交谈的时候了！创建锻炼、添加练习并保存，然后发现所有努力都因数据没有持久化而付诸东流是没有乐趣的。我们需要解决这个问题。
- en: Seldom are applications self-contained. Any consumer app, irrespective of its
    size, has parts that interact with elements outside its boundary. With web-based
    applications, the interaction is mostly with a server. Apps interact with the
    server to authenticate, authorize, store/retrieve data, validate data, and perform
    other such operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有应用是自包含的。无论大小，任何消费者应用程序都有与其边界之外的元素交互的部分。对于基于Web的应用程序，交互主要是与服务器进行的。应用程序与服务器交互以进行身份验证、授权、存储/检索数据、验证数据以及执行其他类似操作。
- en: This chapter explores the constructs that Angular provides for client-server
    interaction. In the process, we add a persistence layer to *Personal Trainer*
    that loads and saves data to a backend server.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了Angular为客户端-服务器交互提供的构造。在这个过程中，我们为*个人健身教练*添加了一个持久化层，用于将数据加载和保存到后端服务器。
- en: 'The topics we cover in this chapter include the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括以下内容：
- en: '**Provisioning a backend to persist workout data**: We set up a MongoLab account
    and use its Data API to access and store workout data.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为持久化锻炼数据设置后端**：我们设置了一个MongoLab账户，并使用其数据API来访问和存储锻炼数据。'
- en: '**Understanding the Angular HttpClient**: The `HttpClient` allows us to interact
    with a server over HTTP. You''ll learn how to make all types of `GET`, `POST`,
    `PUT`, and `DELETE` requests with the `HttpClient`.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解Angular HttpClient**：`HttpClient`允许我们通过HTTP与服务器进行交互。您将学习如何使用`HttpClient`进行各种类型的`GET`、`POST`、`PUT`和`DELETE`请求。'
- en: '**Implementing the loading and saving of workout data**: We use the `HTTPClient`
    to load and store workout data in the MongoLab databases.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现锻炼数据的加载和保存：我们使用`HTTPClient`在MongoLab数据库中加载和存储锻炼数据。
- en: '**Two ways in which we can use the HttpClient''s XMLHttpRequest**: Either Observables
    or with promises.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们可以使用HttpClient的XMLHttpRequest的两种方式**：使用Observables或使用promises。'
- en: '**Using RxJS and Observables**: To subscribe to and query streams of data.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RxJS和Observables：订阅和查询数据流。
- en: '**Using promises**: In this chapter, we will see how to use promises as part
    of HTTP invocation and response.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用promises**：在本章中，我们将看到如何在HTTP调用和响应中使用promises。'
- en: '**Working with cross-domain access**: As we are interacting with a MongoLab
    server in a different domain, you will learn about browser restrictions on cross-domain
    access. You will also learn how JSONP and CORS help us make cross-domain access
    easy and about Angular JSONP support.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理跨域访问**：由于我们与不同域中的MongoLab服务器进行交互，您将了解浏览器对跨域访问的限制。您还将了解JSONP和CORS如何帮助我们轻松实现跨域访问，以及关于Angular
    JSONP支持的内容。'
- en: Let's set the ball rolling.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Angular and server interactions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular和服务器交互
- en: Any client-server interaction typically boils down to sending HTTP requests
    to a server and receiving responses from a server. For heavy JavaScript apps,
    we depend on the AJAX request/response mechanism to communicate with the server.
    To support AJAX-based communication, Angular provides the Angular `HttpClient` module.
    Before we delve into the `HttpClient` module, we need to set up our server platform
    that stores the data and allows us to manage it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 任何客户端-服务器交互通常归结为向服务器发送HTTP请求并从服务器接收响应。对于重型JavaScript应用程序，我们依赖于AJAX请求/响应机制与服务器进行通信。为了支持基于AJAX的通信，Angular提供了Angular
    `HttpClient`模块。在我们深入研究`HttpClient`模块之前，我们需要设置存储数据并允许我们管理数据的服务器平台。
- en: Setting up the persistence store
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置持久化存储
- en: For data persistence, we use a document database called MongoDB ([https://www.mongodb.com/](https://www.mongodb.com/)),
    hosted over MongoLab ([https://www.mlab.com/](https://www.mlab.com/)), as our
    data store. The reason we zeroed in on MongoLab is that it provides an interface
    to interact with the database directly. This saves us the effort of setting up
    server middleware to support MongoDB interaction.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了数据持久性，我们使用了一个名为MongoDB的文档数据库([https://www.mongodb.com/](https://www.mongodb.com/))，它托管在MongoLab([https://www.mlab.com/](https://www.mlab.com/))上作为我们的数据存储。我们选择MongoLab的原因是它提供了一个直接与数据库交互的接口。这样可以节省我们设置服务器中间件以支持MongoDB交互的工作。
- en: It is never a good idea to expose the data store/database directly to the client.
    But in this case, since our primary aim is to learn about Angular and client-server
    interaction, we take this liberty and directly access the MongoDB instance hosted
    in MongoLab. There is also a new breed of apps that are built over **noBackend**
    solutions. In such a setup, frontend developers build apps without the knowledge
    of the exact backend involved. Server interaction is limited to making API calls
    to the backend. If you are interested in knowing more about these noBackend solutions,
    do check out [http://nobackend.org/](http://nobackend.org/).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将数据存储/数据库暴露给客户端从来都不是一个好主意。但在这种情况下，由于我们的主要目标是学习Angular和客户端-服务器交互，我们可以这样做，并直接访问MongoLab托管的MongoDB实例。还有一种新型应用程序是构建在**noBackend**解决方案之上的。在这样的设置中，前端开发人员构建应用程序而不知道确切的后端涉及。服务器交互仅限于向后端发出API调用。如果您对这些noBackend解决方案更感兴趣，请查看[http://nobackend.org/](http://nobackend.org/)。
- en: 'Our first task is to provision an account on MongoLab and create a database:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个任务是在MongoLab上配置一个账户并创建一个数据库：
- en: Go to [https://mlab.com](https://mlab.com) and sign up for an mLab account by
    following the instructions on the website
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[https://mlab.com](https://mlab.com)并按照网站上的说明注册一个mLab账户
- en: Once the account is provisioned, log in and create a new Mongo database by clicking
    on the Create New button on the home page
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦账户配置完成，登录并通过单击主页上的“创建新”按钮创建一个新的Mongo数据库
- en: 'On the database creation screen, you need to make some selections to provision
    the database. See the following screenshot to select the free database tier and
    other options:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据库创建屏幕上，您需要进行一些选择来配置数据库。请参阅以下屏幕截图以选择免费数据库层和其他选项：
- en: '![](Images/f77d00af-d5f5-4a3c-80ec-b4f229c79e75.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f77d00af-d5f5-4a3c-80ec-b4f229c79e75.png)'
- en: Create the database and make a note of the database name that you create
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建数据库并记下您创建的数据库名称
- en: 'Once the database is provisioned, open the database and add two collections
    to it from the Collection tab:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦数据库配置完成，打开数据库并从“集合”选项卡中向其中添加两个集合：
- en: '`exercises`: This stores all *Personal Trainer* exercises'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exercises`：这个集合存储了所有*个人健身教练*的练习'
- en: '`workouts`: This stores all *Personal Trainer* workouts'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workouts`：这个集合存储了所有*个人健身教练*的锻炼'
- en: Collections in the MongoDB world equate to a database table.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB世界中，集合相当于数据库表。
- en: MongoDB belongs to a breed of databases called **document databases**. The central
    concepts here are documents, attributes, and their linkages. And unlike traditional
    databases, the schema is not rigid. We will not be covering what document databases
    are and how to perform data modeling for document-based stores in this book. *Personal
    Trainer* has a limited storage requirement and we manage it using the two previously
    mentioned document collections. We may not even be using the document database
    in its true sense.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB属于一类称为**文档数据库**的数据库。这里的核心概念是文档、属性及其链接。与传统数据库不同，模式并不是固定的。我们不会在本书中涵盖文档数据库是什么以及如何为基于文档的存储执行数据建模。*个人健身教练*有一个有限的存储需求，我们使用两个先前提到的文档集合来管理它。我们甚至可能并没有真正意义上使用文档数据库。
- en: Once the collections are added, add yourself as a user to the database from
    the Users tab.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦集合被添加，从用户选项卡将自己添加为数据库的用户。
- en: 'The next step is to determine the API key for the MongoLab account. The provisioned
    API key has to be appended to every request made to MongoLab. To get the API key,
    perform the following steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是确定MongoLab账户的API密钥。配置的API密钥必须附加到发送到MongoLab的每个请求中。要获取API密钥，请执行以下步骤：
- en: Click on the username (not the account name) in the top-right corner to open
    the user profile.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右上角的用户名（而不是账户名）以打开用户配置文件。
- en: In the section titled API Key, the current API key is displayed; copy it. At
    the same time, click on the button below the API key to Enable Data API access.
    This is disabled by default.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标题为API密钥的部分，当前的API密钥会显示出来；复制它。同时，点击API密钥下面的按钮以启用数据API访问。这是默认禁用的。
- en: The data store schema is complete. We now need to seed these collections.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储架构已经完成。现在我们需要播种这些集合。
- en: Seeding the database
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播种数据库
- en: The *Personal Trainer* app already has a predefined workout and a list of 12
    exercises. We need to seed the collections with this data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*个人健身教练*应用程序已经有一个预定义的锻炼和12个练习的列表。我们需要用这些数据播种集合。'
- en: Open `seed.js` in the `trainer/db` folder for checkpoint 5.1 from the companion
    code base. It contains the seed JSON script and detailed instructions on how to
    seed data into the MongoLab database instance.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从伴随代码库的`trainer/db`文件夹中打开`seed.js`以进行5.1检查点。它包含了播种JSON脚本和如何将数据播种到MongoLab数据库实例的详细说明。
- en: 'Once seeded, the database will have one workout in the workouts collection
    and 12 exercises in the exercises collection. Verify this on the MongoLab site;
    the collections should show the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦种子播下，数据库中将有一个锻炼在锻炼集合中，以及12个练习在练习集合中。在MongoLab网站上验证这一点；集合应该显示如下：
- en: '![](Images/f0da6449-0b07-4221-a218-299189fbad23.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f0da6449-0b07-4221-a218-299189fbad23.png)'
- en: Everything has been set up now, so let's start our discussion of the `HttpClient` module
    and implement workout/exercise persistence for the *Personal Trainer* app.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已经设置好了，让我们开始讨论`HttpClient`模块，并为*个人健身教练*应用程序实现锻炼/练习的持久化。
- en: The basics of the HTTPClient module
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPClient模块的基础知识
- en: At the core of the `HTTPClient` module is the `HttpClient`. It performs HTTP
    requests using `XMLHttpRequest` as the default backend (JSONP is also available,
    as we will see later in this chapter). It supports requests such as `GET`, `POST`,
    `PUT`, and `DELETE`. In this chapter, we will use the `HttpClient` to make all
    of these types of requests. As we will see, the `HttpClient` makes it easy to
    make these calls with a minimal amount of setup and complexity. None of this terminology
    will come as a surprise to anyone who has previously worked with Angular or built
    JavaScript applications that communicate with a backend data store.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`HTTPClient`模块的核心是`HttpClient`。它使用`XMLHttpRequest`作为默认后端执行HTTP请求（如我们将在本章后面看到的，也支持JSONP），支持`GET`、`POST`、`PUT`和`DELETE`等请求。在本章中，我们将使用`HttpClient`来进行所有这些类型的请求。正如我们将看到的，`HttpClient`使得使用最少的设置和复杂性轻松进行这些调用。如果之前曾经使用过Angular或构建过与后端数据存储通信的JavaScript应用程序的人，这些术语都不会让人感到意外。
- en: However, there is a substantial change in the way Angular handles HTTP requests.
    Calling a request now returns an Observable of HTTP responses. It does so by using
    the RxJS library, which is a well-known open source implementation of the asynchronous
    Observable pattern.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Angular处理HTTP请求的方式发生了重大变化。现在调用请求会返回一个HTTP响应的Observable。它通过使用RxJS库来实现，这是一个众所周知的异步Observable模式的开源实现。
- en: You can find the RxJS project on GitHub at [https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS).
    The site indicates that the project is being actively developed by Microsoft in
    collaboration with a community of open source developers. We will not be covering
    the asynchronous Observable pattern in great detail here, and we encourage you
    to visit that site to learn more about the pattern and how RxJS implements it.
    The version of RxJS that Angular is using is beta 5.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到RxJS项目[https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS)。该网站表明该项目正在由微软与一群开源开发人员合作积极开发。我们不会在这里详细介绍异步Observable模式，并鼓励您访问该网站了解有关该模式以及RxJS如何实现它的更多信息。Angular正在使用的RxJS版本是beta
    5。
- en: In the simplest of terms, using Observables allows a developer to think about
    the data that flows through an application as streams of information that the
    application can dip into and use whenever it wants. These streams change over
    time, which allows the application to react to these changes. This quality of
    Observables provides a foundation for **functional reactive programming** (**FRP**),
    which fundamentally shifts the paradigm for building web applications from imperative
    to reactive.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，使用Observables允许开发人员将应用程序中流动的数据视为信息流，应用程序可以随时获取并使用。这些流随时间变化，这使得应用程序能够对这些变化做出反应。Observables的这一特性为**函数式响应式编程**（**FRP**）提供了基础，从而从命令式转变为响应式构建Web应用程序的范式。
- en: The `RxJS` library provides operators that allow you to subscribe to and query
    these data streams. Moreover, you can easily mix and combine them, as we will
    see in this chapter. Another advantage of Observables is that it is easy to cancel
    or unsubscribe from them, making it possible to seamlessly handle errors inline.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`RxJS`库提供了操作符，允许您订阅和查询这些数据流。此外，您可以轻松地混合和组合它们，正如我们将在本章中看到的。Observables的另一个优势是很容易取消订阅，使得能够无缝处理内联错误成为可能。'
- en: While it is still possible to use promises, the default method in Angular uses
    Observables. We will also cover promises in this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中仍然可以使用promises，但默认方法使用Observables。在本章中，我们还将涵盖promises。
- en: Personal Trainer and server integration
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人教练和服务器集成
- en: As described in the previous section, client-server interaction is all about
    asynchronicity. As we alter our *Personal Trainer* app to load data from the server,
    this pattern becomes self-evident.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，客户端-服务器交互涉及异步性。当我们修改我们的*个人教练*应用程序以从服务器加载数据时，这种模式变得不言自明。
- en: In the previous chapter, the initial set of workouts and exercises was hardcoded
    in the `WorkoutService` implementation. Let's see how to load this data from the
    server first.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，`WorkoutService`实现中的初始一组锻炼和练习是硬编码的。让我们先看看如何从服务器加载这些数据。
- en: Loading exercise and workout data
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载练习和锻炼数据
- en: Earlier in this chapter, we seeded our database with a data form, the `seed.js`
    file. We now need to render this data in our views. The MongoLab Data API is going
    to help us here.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们使用数据表单`seed.js`文件为数据库添加了数据。现在我们需要在视图中呈现这些数据。MongoLab数据API将在这方面帮助我们。
- en: The MongoLab Data API uses an API key to authenticate access requests. Every
    request made to the MongoLab endpoints needs to have a query string parameter,
    `apikey=<key>`, where `key` is the API key that we provisioned earlier in the
    chapter. Remember that the key is always provided to a user and associated with
    their account. Avoid sharing your API keys with others.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: MongoLab数据API使用API密钥来验证访问请求。对MongoLab端点的每个请求都需要一个查询字符串参数，`apikey=<key>`，其中`key`是我们在本章前面提供的API密钥。请记住，密钥始终提供给用户并与其帐户关联。避免与他人分享您的API密钥。
- en: 'The API follows a predictable pattern to query and update data. For any MongoDB
    collection, the typical endpoint access pattern is one of the following (given
    here is the base URL: [https://api.mongolab.com/api/1/databases](https://api.mongolab.com/api/1/databases)):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: API遵循可预测的模式来查询和更新数据。对于任何MongoDB集合，典型的端点访问模式是以下之一（这里给出的是基本URL：[https://api.mongolab.com/api/1/databases](https://api.mongolab.com/api/1/databases)）：
- en: '`/<dbname>/collections/<name>?apiKey=<key>`: This has the following requests:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/<dbname>/collections/<name>?apiKey=<key>`：这有以下请求：'
- en: '`GET`: This action gets all objects in the given collection name.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：此操作获取给定集合名称中的所有对象。'
- en: '`POST`: This action adds a new object to the collection name. MongoLab has
    an `_id` property that uniquely identifies the document (object). If not provided
    in the posted data, it is auto-generated.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：此操作将新对象添加到集合名称。MongoLab具有唯一标识文档（对象）的`_id`属性。如果在发布的数据中未提供，则会自动生成。'
- en: '`/<dbname>/collections/<name>/<id>?apiKey=<key>`: This has the following requests:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/<dbname>/collections/<name>/<id>?apiKey=<key>`：这有以下请求：'
- en: '`GET`: This gets a specific document/collection item with a specific ID (a
    match done on the `_id` property) from the collection name.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：这会获取具有特定ID的特定文档/集合项（在集合名称上对`_id`属性进行匹配）。'
- en: '`PUT`: This updates the specific item (`id`) in the collection name.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：这将更新集合名称中特定项目（`id`）。'
- en: '`DELETE`: This deletes the item with a specific ID from the collection name.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：这将从集合名称中删除具有特定ID的项目。'
- en: For more details on the Data API interface, visit the MongoLab Data API documentation
    at [http://docs.mlab.com/data-api](http://docs.mlab.com/data-api).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Data API接口的更多详细信息，请访问MongoLab Data API文档：[http://docs.mlab.com/data-api](http://docs.mlab.com/data-api)。
- en: Now we are in a position to start implementing exercise/workout list pages.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有能力开始实施练习/锻炼列表页面。
- en: 'The code that we are starting with in this chapter is `checkpoint 4.6` (folder:
    `trainer`) in the GitHub repository for this book. It is available on GitHub ([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)).
    Checkpoints are implemented as branches in GitHub. If you are not using Git, download
    the snapshot of checkpoint 4.6 (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular6byexample/tree/checkpoint4.6](https://github.com/chandermani/angular6byexample/tree/checkpoint4.6).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时使用的代码是本书的GitHub存储库中的`checkpoint 4.6`（文件夹：`trainer`）。它在GitHub上可用（[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)）。检查点在GitHub中实现为分支。如果您不使用Git，请从以下GitHub位置下载检查点4.6的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/tree/checkpoint4.6](https://github.com/chandermani/angular6byexample/tree/checkpoint4.6)。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Loading exercise and workout lists from a server
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器加载练习和锻炼列表
- en: 'To pull exercise and workout lists from the MongoLab database, we have to rewrite
    our `WorkoutService` service methods: `getExercises` and `getWorkouts`. But before
    we can do that, we have to set up our service to work with Angular''s HTTPClient
    module.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要从MongoLab数据库中提取练习和锻炼列表，我们必须重写我们的`WorkoutService`服务方法：`getExercises`和`getWorkouts`。但在我们这样做之前，我们必须设置我们的服务以与Angular的HTTPClient模块一起工作。
- en: Adding the HTTPClient module and RxJS to our project
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将HTTPClient模块和RxJS添加到我们的项目
- en: 'The Angular HTTPClient module is included in the Angular bundles that you have
    already installed. To use it, we need to import it into `app.module.ts,` like
    so (make sure that the import follows `BrowserModule`):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Angular HTTPClient模块包含在您已经安装的Angular捆绑包中。要使用它，我们需要将其导入到`app.module.ts`中，就像这样（确保导入跟随`BrowserModule`）：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We also need an external third-party library: **Reactive Extensions for JavaScript**
    (**RxJS**). RxJS implements the Observable pattern and it is used by Angular with
    the HTTPClient module. It is included in the Angular bundles that are already
    part of our project.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个外部第三方库：**JavaScript的响应式扩展**（**RxJS**）。RxJS实现了Observable模式，并且Angular与HTTPClient模块一起使用它。它已经包含在我们项目的Angular捆绑包中。
- en: Updating workout-service to use the HTTPClient module and RxJS
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新workout-service以使用HTTPClient模块和RxJS
- en: 'Open  `workout.service.ts` from `trainer/src/app/core`. In order to use the
    HTTPClient and RxJS within the `WorkoutService`, we need to add the following
    imports to that file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从`trainer/src/app/core`中打开`workout.service.ts`。为了在`WorkoutService`中使用HTTPClient和RxJS，我们需要在该文件中添加以下导入：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We are importing the `HTTPClient` module along with `Observable` from RxJS and
    one additional RxJS operator: `catchError`. We'll see how this operator is used
    as we work through the code in this section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在从RxJS中导入`HTTPClient`模块以及`Observable`，还有一个额外的RxJS操作符：`catchError`。当我们在本节中处理代码时，我们将看到如何使用这个操作符。
- en: 'In the class definition, add the following properties, which include a workout
    property and ones that set the URL for the collections in our Mongo database and
    the key to that database as well as another property: `params`, which sets up
    the API key as a query string for API access:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义中，添加以下属性，包括一个workout属性和设置我们Mongo数据库中集合的URL以及该数据库的密钥的属性，还有另一个属性：`params`，它将API密钥设置为API访问的查询字符串：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Replace the `<dbname>` and `<key>` tokens with the database name and API key
    of the database that we provisioned earlier in the chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 用我们在本章前面提供的数据库名称和API密钥替换`<dbname>`和`<key>`标记。
- en: 'Next, inject the HTTPClient module into the `WorkoutServiceconstructor` using
    the following line of code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下代码将HTTPClient模块注入到`WorkoutServiceconstructor`中：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then change the `getExercises()` method to the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将`getExercises()`方法更改为以下内容：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you are used to working with promises for asynchronous data operations, what
    you see here will look different. Instead of a promise that has a call to `then()`
    chained to it, what happens here is that the `http.get` method returns an Observable from
    the RxJS library. Notice that we are also setting the response to be of type `<ExercisePlan>` to
    make explicit to our upstream callers what type of Observable is being returned
    from our HTTP GET call.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您习惯于使用promise进行异步数据操作，那么您在这里看到的将会有所不同。这里发生的是`http.get`方法返回了RxJS库中的Observable。请注意，我们还设置响应类型为`<ExercisePlan>`，以明确告诉上游调用者我们的HTTP
    GET调用返回的Observable的类型。
- en: Returning an Observable is the default response when using the `HTTPClient`
    module's `get` method. The Observable can, however, be converted to a promise.
    And, as we will see later in this chapter, the option to return JSONP also exists.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`HTTPClient`模块的`get`方法时，返回Observable是默认响应。然而，Observable可以转换为promise。正如我们将在本章后面看到的，还存在返回JSONP的选项。
- en: 'Before we move on, there is one more thing to touch upon in this code. Notice
    that we are using a pipe method to add a `catchError` operator. This operator
    accepts a method, `handleError`, for handling a failed response. The `handleError`
    method takes the failed response as a parameter. We log the error to the console
    and use `Observable.throw` to return the error to the consumer:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，这段代码还有一件事要注意。请注意，我们使用了一个pipe方法来添加一个`catchError`操作符。这个操作符接受一个名为`handleError`的方法，用于处理失败的响应。`handleError`方法将失败的响应作为参数。我们将错误记录到控制台，并使用`Observable.throw`将错误返回给消费者：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To be clear, this is not production code, but it will give us the opportunity
    to show how to write code upstream to handle errors that are generated as part
    of data access.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要清楚的是，这不是生产代码，但它将给我们一个机会展示如何编写上游代码来处理作为数据访问的一部分生成的错误。
- en: It is important to understand that at this stage no data is flowing through
    the Observable until there is a subscription to it. This can bring about a gotcha
    moment for things such as adds and updates if you are not careful to add subscriptions
    to your Observables.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，在这个阶段，直到有人订阅它，Observable中没有数据流动。如果不小心向Observable添加订阅，这可能会带来一些意外的时刻，比如添加和更新。
- en: Modifying getWorkouts() to use the HTTPClient module
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改getWorkouts()以使用HTTPClient模块
- en: 'The change in the code for retrieving workouts is almost identical to that
    for the exercises:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 检索锻炼的代码更改几乎与练习的代码相同：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again we are specifying the type of Observable—in this case `<WorkoutPlan[]>`—that
    will be returned by our HTTP GET call and using `pipe` to add a `catchError` operator.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们正在指定Observable的类型—在这种情况下是`<WorkoutPlan[]>`—它将由我们的HTTP GET调用返回，并使用`pipe`添加`catchError`操作符。
- en: Now that the `getExercises` and `getWorkouts` methods are updated, we need to
    make sure that they work with the upstream callers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`getExercises`和`getWorkouts`方法已经更新，我们需要确保它们与上游调用者一起工作。
- en: Updating the workout/exercise list pages
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新锻炼/练习列表页面
- en: 'The exercise and workout list pages (as well as `LeftNavExercises`) call either
    the `getExercises` or `getWorkouts` method in `model.ts`. In order to get these
    working with the remote calls that are now being made using the `HTTPClient` module,
    we need to modify those calls to subscribe to the Observable that is being returned
    by the `HTTPClient` module. So, update the code in the `ngOnInit` method in `exercises.component.ts`
    to the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 练习和锻炼列表页面（以及`LeftNavExercises`）在`model.ts`中调用`getExercises`或`getWorkouts`方法。为了使它们与现在使用HTTPClient模块进行的远程调用一起工作，我们需要修改这些调用以订阅由`HTTPClient`模块返回的Observable。因此，将`exercises.component.ts`中的`ngOnInit`方法中的代码更新为以下内容：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our method now subscribes to the Observable that is being returned by the `getExercises`
    method; at the point when the response arrives, it assigns the results to `exerciseList`.
    If there is an error, it assigns it to a `console.error` call that displays the
    error in the console. All of this is now being handled asynchronously using the
    `HTTPClient` module with RxJS.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法现在订阅了由`getExercises`方法返回的Observable；在响应到达时，它将结果分配给`exerciseList`。如果出现错误，它将其分配给`console.error`调用，以在控制台中显示错误。所有这些现在都是使用HTTPClient模块和RxJS异步处理的。
- en: Go ahead and make similar changes to the `ngOnInit` methods in `workouts.component.ts`
    and `left-nav-exercises.component.ts`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 继续对`workouts.component.ts`和`left-nav-exercises.component.ts`中的`ngOnInit`方法进行类似的更改。
- en: Refresh the workout/exercise list page and the workout and exercise data will
    be loaded from the database server.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新锻炼/练习列表页面，锻炼和练习数据将从数据库服务器加载。
- en: Look at the complete implementation in checkpoint 5.1 in the GitHub repository
    if you are having difficulty in retrieving/showing data. Note that in this checkpoint,
    we have disabled navigation links to the workout and exercise screens because
    we still have to add the Observable implementation to them. We'll do that in the
    next section. Also remember to replace the database name and API key before you
    run the code from `Checkpoint 5.1`. If you are not using Git, download the snapshot
    of `Checkpoint 5.1` (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular6byexample/tree/checkpoint5.1](https://github.com/chandermani/angular6byexample/tree/checkpoint5.1).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在检索/显示数据时遇到困难，请查看GitHub存储库中检查点5.1中的完整实现。请注意，在此检查点中，我们已禁用了到锻炼和练习屏幕的导航链接，因为我们仍然需要为它们添加Observable实现。我们将在下一节中进行。还记得在运行来自`Checkpoint
    5.1`的代码之前，要替换数据库名称和API密钥。如果您不使用Git，请从以下GitHub位置下载`Checkpoint 5.1`的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/tree/checkpoint5.1](https://github.com/chandermani/angular6byexample/tree/checkpoint5.1)。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: 'This looks good and the lists are loading fine. Well, almost! There is a small
    glitch in the workout list page. We can easily spot it if we look carefully at
    any list item (in fact, there is only one item):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，列表加载得很好。嗯，几乎！锻炼列表页面有一个小故障。如果我们仔细看任何列表项（实际上只有一个）就可以很容易地发现它：
- en: '![](Images/4851c5e6-0779-4132-8184-519d877ee77f.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4851c5e6-0779-4132-8184-519d877ee77f.png)'
- en: The workout duration calculations are not working anymore! What could be the
    reason? We need to look back at how these calculations were implemented. The `WorkoutPlan`
    service (in `model.ts`) defines a `totalWorkoutDuration` method that does the
    math for this.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 锻炼持续时间的计算不再起作用！原因是什么？我们需要回顾一下这些计算是如何实现的。`WorkoutPlan`服务（在`model.ts`中）定义了一个`totalWorkoutDuration`方法来进行这个计算。
- en: The difference is in the workout array that is bound to the view. In the previous
    chapter, we created the array with model objects that were created using the `WorkoutPlan`
    service. But now, since we are retrieving data from the server, we bind a simple
    array of JavaScript objects to the view, which for obvious reasons has no calculation
    logic.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于绑定到视图的锻炼数组。在上一章中，我们创建了一个使用`WorkoutPlan`服务创建的模型对象数组。但现在，由于我们正在从服务器检索数据，我们将一个简单的JavaScript对象数组绑定到视图，这是因为明显的原因没有计算逻辑。
- en: We can fix this problem by mapping a server response to our model class objects
    and returning them to any upstream caller.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将服务器响应映射到我们的模型类对象并将它们返回给任何上游调用者来解决这个问题。
- en: Mapping server data to application models
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将服务器数据映射到应用程序模型
- en: Mapping server data to our model and vice versa may be unnecessary if the model
    and server storage definition match. If we look at the `Exercise` model class
    and the seed data that we have added for the exercise in MongoLab, we will see
    that they do match and hence mapping becomes unnecessary.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型和服务器存储定义匹配，将服务器数据映射到我们的模型和反之可能是不必要的。如果我们看一下`Exercise`模型类和我们在MongoLab中为练习添加的种子数据，我们会发现它们是匹配的，因此映射变得不必要。
- en: 'Mapping a server response to the model data becomes imperative if:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型和服务器存储定义匹配，将服务器响应映射到模型数据变得必要。
- en: Our model defines any methods
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的模型定义了任何方法
- en: A stored model is different from its representation in code
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储的模型与其在代码中的表示不同
- en: The same model class is used to represent data from different sources (this
    can happen for mashups, where we pull data from disparate sources)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的模型类用于表示来自不同来源的数据（这可能发生在混搭中，我们从不同的来源获取数据）
- en: 'The `WorkoutPlan` service is a prime example of an impedance mismatch between
    a model representation and its storage. Look at the following screenshot to understand
    these differences:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutPlan`服务是模型表示和存储之间阻抗不匹配的一个典型例子。看一下下面的截图，了解这些差异：'
- en: '![](Images/df31aa0c-237d-4043-afea-d2c9a6531a3b.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/df31aa0c-237d-4043-afea-d2c9a6531a3b.png)'
- en: 'The two major differences between the model and server data are as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 模型和服务器数据之间的两个主要区别如下：
- en: The model defines the `totalWorkoutDuration` method.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型定义了`totalWorkoutDuration`方法。
- en: The `exercises` array representation also differs. The `exercises` array of
    the model contains the full `Exercise` object, while the server data stores just
    the exercise identifier or name.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exercises`数组的表示也不同。模型的`exercises`数组包含完整的`Exercise`对象，而服务器数据只存储练习标识符或名称。'
- en: This clearly means that loading and saving a workout requires model mapping.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然意味着加载和保存锻炼需要模型映射。
- en: The way we will do this is by adding another operator to transform the Observable
    response object. So far, we have only returned a plain JavaScript object as the
    response. The nice thing is that the pipe method that we used to add error handling
    also allows us to add additional operators that we can use to transform the JavaScript
    object into the `WorkoutPlan` type in our model.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过向Observable响应对象添加另一个操作符来进行此操作。到目前为止，我们只返回了一个普通的JavaScript对象作为响应。好处是，我们用来添加错误处理的pipe方法还允许我们添加额外的操作符，这些操作符可以用来将JavaScript对象转换为我们模型中的`WorkoutPlan`类型。
- en: 'Let''s rewrite the `getWorkouts` method in the `workout-service.ts` file to
    the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`workout-service.ts`文件中的`getWorkouts`方法重写为以下内容：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have added a  `map` operator that transforms this Observable into one made
    up of `WorkoutPlan` objects. Each `WorkoutPlan` object (we have only one at the
    moment) will then have the `totalWorkoutDuration` method that we need.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个`map`操作符，将这个Observable转换为由`WorkoutPlan`对象组成的Observable。每个`WorkoutPlan`对象（目前我们只有一个）将具有我们需要的`totalWorkoutDuration`方法。
- en: Looking at the code you can see that we operate on the JSON results HTTPClient
    response, which is why we are using the `<any>` type. And then we create a typed
    array of `WorkoutPlans` and iterate through the first array using a fat arrow
    `forEach` function, assigning each JavaScript object to a `WorkoutPlan` object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下代码，您会看到我们在JSON结果HTTPClient响应上操作，这就是为什么我们使用`<any>`类型。然后我们创建了一个`WorkoutPlans`的类型数组，并使用一个箭头函数`forEach`函数遍历第一个数组，将每个JavaScript对象分配给一个`WorkoutPlan`对象。
- en: We return the results of these mappings to the callers that subscribe to them,
    `workouts.component.ts` in this case. We have also updated the `catchError` operator
    with a new `handleError` method which you can find in `Checkpoint 5.2`. The callers
    do not need to make any changes to the code they use to subscribe to our workouts
    Observable. Instead, the model mapping can take place at one spot in the application
    and then be used throughout it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些映射的结果返回给订阅它们的调用者，例如`workouts.component.ts`。我们还使用了一个新的`handleError`方法更新了`catchError`操作符，您可以在`Checkpoint
    5.2`中找到。调用者不需要对他们用来订阅我们的workouts Observable的代码进行任何更改。相反，模型映射可以在应用程序的一个地方进行，然后在整个应用程序中使用。
- en: 'If you rerun the application, you will see that the total number of seconds
    now displays properly:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重新运行应用程序，您将看到总秒数现在正确显示：
- en: '![](Images/93bf867c-e80e-46a1-baa0-d5abedd32142.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/93bf867c-e80e-46a1-baa0-d5abedd32142.png)'
- en: 'Checkpoint 5.2 in the GitHub repository contains the working implementation
    for what we have covered so far. The GitHub branch is `checkpoint5.2` (folder:
    `trainer`).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub存储库中的Checkpoint 5.2包含了我们到目前为止所涵盖的工作实现。GitHub分支是`checkpoint5.2`（文件夹：`trainer`）。
- en: Loading exercise and workout data from the server
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器加载练习和锻炼数据
- en: Just as we fixed the `getWorkouts` implementation in `WorkoutService` earlier,
    we can implement other get operations for exercise- and workout-related stuff.
    Copy the service implementation for the `getExercise` and `getWorkout` methods
    of `WorkoutService` from `workout.service.ts` in the `trainer/src/app/core` folder
    in checkpoint 5.2.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前在`WorkoutService`中修复了`getWorkouts`的实现一样，我们可以为与练习和锻炼相关的其他获取操作实现。从检查点5.2中的`trainer/src/app/core`文件夹中的`workout.service.ts`复制`WorkoutService`的`getExercise`和`getWorkout`方法的服务实现。
- en: The `getWorkout` and `getExercise` methods use the name of the workout/exercise
    to retrieve results. Every MongoLab collection item has an `_id` property that
    uniquely identifies the item/entity. In the case of our `Exercise` and `WorkoutPlan`
    objects, we use the name of the exercise for unique identification. Hence, the
    `name` and `_id` property of each object always match.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`getWorkout`和`getExercise`方法使用锻炼/练习的名称来检索结果。每个MongoLab集合项都有一个`_id`属性，用于唯一标识该项/实体。在我们的`Exercise`和`WorkoutPlan`对象的情况下，我们使用练习的名称进行唯一标识。因此，每个对象的`name`和`_id`属性始终匹配。'
- en: 'At this point, we will need to add one more import to `workout.service.ts`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要在`workout.service.ts`中添加一个导入：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This import brings in the `forkJoin` operator, which we will be discussing shortly.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个导入引入了`forkJoin`操作符，我们将很快讨论它。
- en: 'Pay special attention to the implementation of the `getWorkout` method because
    there is a decent amount of data transformation happening due to the model and
    data storage format mismatch. This is how the `getWorkout` method now looks:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意`getWorkout`方法的实现，因为由于模型和数据存储格式不匹配，发生了相当多的数据转换。
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There is a lot happening inside `getWorkout` that we need to understand.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`getWorkout`内部发生了很多事情，我们需要理解。'
- en: 'The `getWorkout` method uses Observable and its `forkJoin` operator to return
    two Observable objects: one that retrieves the `Workout` and another that retrieves
    a list of all the `Exercises`. What is interesting about the `forkJoin` operator
    is that not only does it allow us to return multiple Observable streams, but it
    also waits until both Observable streams have retrieved their data before further
    processing the results. In other words, it enables us to stream the responses
    from multiple concurrent HTTP requests and then operate on the combined results.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`getWorkout`方法使用Observable及其`forkJoin`操作符返回两个Observable对象：一个用于检索`Workout`，另一个用于检索所有`Exercises`的列表。`forkJoin`操作符的有趣之处在于它不仅允许我们返回多个Observable流，而且还会等待直到两个Observable流都检索到它们的数据后才进一步处理结果。换句话说，它使我们能够从多个并发的HTTP请求中流式传输响应，然后对组合结果进行操作。'
- en: Once we have the `Workout` details and the complete list of exercises, we then
    `pipe` the results to the `map` operator (which we saw previously with the code
    for the `Workouts` list), which we use to change the `exercises` array of the
    workout to the correct `Exercise` class object. We do this by searching the `allExercises`
    Observable for the name of the exercise in the `workout.exercises` array returned
    from the server, and then assigning the matching exercise to the workout services
    array. The end result is that we have a complete `WorkoutPlan` object with the
    `exercises` array set up correctly.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`Workout`的详细信息和完整的练习列表，我们就会将结果传递给`map`操作符（我们之前在`Workouts`列表的代码中看到过），我们用它来将锻炼的`exercises`数组更改为正确的`Exercise`类对象。我们通过在从服务器返回的`workout.exercises`数组中搜索`allExercises`
    Observable的练习名称，然后将匹配的练习分配给锻炼服务数组来实现这一点。最终结果是我们有了一个完整的`WorkoutPlan`对象，其中`exercises`数组被正确设置。
- en: These `WorkoutService` changes warrant fixes in upstream callers too. We have
    already fixed the lists of exercises in the `LeftNavExercises` and `Exercises`
    components and the workouts in the `Workouts` component. Now let's fix the `Workout`
    and `Exercise` components along similar lines. The `getWorkout` and `getExercise`
    methods in the workout services are not directly called by these components, but
    by builder services. So we'll have to fix the builder services together with the
    `Workout` and `Exercise` components and the two resolvers—`WorkoutResolver` and
    `ExerciseResolver`—that we have added to the routes for these components.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`WorkoutService`的更改需要在上游调用者中进行修复。我们已经修复了`LeftNavExercises`和`Exercises`组件中的锻炼列表，以及`Workouts`组件中的锻炼。现在让我们以类似的方式修复`Workout`和`Exercise`组件。锻炼服务中的`getWorkout`和`getExercise`方法不是直接由这些组件调用的，而是由构建服务调用的。因此，我们将不得不与`Workout`和`Exercise`组件以及我们为这些组件添加的两个解析器—`WorkoutResolver`和`ExerciseResolver`—一起修复构建服务。
- en: Fixing the builder services
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复构建服务
- en: 'Now that we have `WorkoutService` set up to retrieve a workout from our remote
    data store, we have to modify `WorkoutBuilderService` to be able to retrieve that
    workout as an Observable. The method that pulls the `Workout` details is `startBuilding`.
    In order to do that, we will break the current `startBuilding` method into two
    methods, one for new workouts and one for existing workouts that we have retrieved
    from the server. Here is the code for new workouts:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置好了`WorkoutService`以从远程数据存储库中检索锻炼，我们必须修改`WorkoutBuilderService`以能够将该锻炼作为Observable检索出来。提取`Workout`详情的方法是`startBuilding`。为了做到这一点，我们将当前的`startBuilding`方法分成两个方法，一个用于新的锻炼，一个用于从服务器检索到的现有锻炼。以下是新锻炼的代码：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For existing workouts, we add the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现有的锻炼，我们添加以下代码：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We'll let you make the same fixes in `ExerciseBuilderService`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将允许您在`ExerciseBuilderService`中进行相同的修复。
- en: Updating the resolvers
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新解析器
- en: As we move on to using Observable types with our data access, we are going to
    have to make some adjustments to the resolvers that we have created for the routes
    leading to workout and exercise screens. We start with the `WorkoutResolver` in
    `workout-resolver.ts` that can be found in the `workout` folder.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开始使用Observable类型来访问数据，我们将不得不对我们为通往锻炼和锻炼屏幕的路由创建的解析器进行一些调整。我们从`workout`文件夹中的`workout-resolver.ts`中的`WorkoutResolver`开始。
- en: 'First, add the following imports from RxJs:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从RxJs中添加以下导入：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next update the `resolve` method as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，按照以下方式更新`resolve`方法：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, we have split out the behavior for a new workout (one where
    there is no workout name being passed as a parameter in the URL) and that for
    an existing workout. In the former case, we call `workoutBuilderService.startBuildingExisting`,
    which will return a new `WorkoutPlan`. In the latter case, we call `workoutBuilderService.startBuildingExisting` and pipe
    the results and then map them to return the `workout` unless it is not found,
    in which case we route the user back to the `Workouts` screen.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们已经分离出了新锻炼的行为（在URL参数中没有传递锻炼名称的情况）和现有锻炼的行为。在前一种情况下，我们调用`workoutBuilderService.startBuildingExisting`，它将返回一个新的`WorkoutPlan`。在后一种情况下，我们调用`workoutBuilderService.startBuildingExisting`，然后将结果进行处理，然后将其映射为返回`workout`，除非找不到，这种情况下我们将用户路由回`Workouts`屏幕。
- en: Fixing the Workout and Exercise components
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复锻炼和锻炼组件
- en: 'Once we have fixed the `WorkoutBuilderService` and the `WorkoutResolver`, there
    are actually no further fixes needed in the `WorkoutComponent`. All the work to
    handle the Observables has been done further downstream and all we need to do
    at this stage is subscribe to the route data and retrieve the workout as we have
    already been doing:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们修复了`WorkoutBuilderService`和`WorkoutResolver`，实际上在`WorkoutComponent`中就不需要进一步的修复了。处理Observable的所有工作都已经在下游完成，我们在这个阶段需要做的就是订阅路由数据并像以前一样检索锻炼：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To test the implementation, uncomment the following highlighted code contained
    in the `onSelect` method within `workouts.component.ts`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试实现，取消`workouts.component.ts`中`onSelect`方法中包含的以下突出显示的代码的注释：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then click on any existing workout, such as *7 Minute Workout*, from the list
    of workouts displayed at `/builder/workouts/`. The workout data should load successfully.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后点击`/builder/workouts/`中显示的锻炼列表中的任何现有锻炼，比如*7分钟锻炼*。锻炼数据应该成功加载。
- en: The `ExerciseBuilderService` and `ExerciseResolver` also need fixing. `Checkpoint
    5.2` contains those fixes. You can copy those files or do it yourself and compare
    the implementation. And don't forget to uncomment the code in the `onSelect` method
    in `exercises.component.ts`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExerciseBuilderService`和`ExerciseResolver`也需要修复。`Checkpoint 5.2`包含了这些修复。您可以复制这些文件，或者自己做并比较实现。不要忘记取消`exercises.component.ts`中`onSelect`方法中的代码注释。'
- en: '`Checkpoint 5.2` in the GitHub repository contains the working implementation
    for what we have covered thus far. If you are not using Git, download the snapshot
    of Checkpoint 5.2 (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular6byexample/tree/checkpoint5.2](https://github.com/chandermani/angular6byexample/tree/checkpoint5.2).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub存储库中的`Checkpoint 5.2`包含了我们迄今为止所涵盖的工作实现。如果您不使用Git，请从以下GitHub位置下载`Checkpoint
    5.2`的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/tree/checkpoint5.2](https://github.com/chandermani/angular6byexample/tree/checkpoint5.2)。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: It is now time to fix, create, and update scenarios for the exercises and workouts.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候修复、创建和更新练习和锻炼的场景了。
- en: Performing CRUD on exercises/workouts
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对练习/锻炼执行CRUD操作
- en: When it comes to create, read, update, and delete (CRUD) operations, all save,
    update, and delete methods need to be converted to the Observable pattern.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建、读取、更新和删除（CRUD）操作方面，所有保存、更新和删除方法都需要转换为Observable模式。
- en: Earlier in the chapter, we detailed the endpoint access pattern for CRUD operations
    in a MongoLab collection. Head back to the *Loading exercise and workout data* section
    and revisit the access patterns. We need this now as we plan to create/update
    workouts.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早些时候，我们详细介绍了对MongoLab集合进行CRUD操作的端点访问模式。回到*加载练习和锻炼数据*部分，重新审视访问模式。我们现在需要这个，因为我们计划创建/更新锻炼。
- en: Before we start the implementation, it is important to understand how MongoLab
    identifies a collection item and what our ID generation strategy is. Each collection
    item in MongoDB is uniquely identified in the collection using the `_id` property.
    While creating a new item, either we supply an ID or the server generates one
    itself. Once `_id` is set, it cannot be changed. For our model, we will use the
    `name` property of the exercise/workout as the unique ID and copy the name into
    the `_id` field (hence, there is no autogeneration of `_id`). Also, remember that
    our model classes do not contain this `_id` field; it has to be created before
    saving the record for the first time.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实施之前，了解MongoLab如何标识集合项以及我们的ID生成策略是很重要的。MongoDB中的每个集合项都是使用`_id`属性在集合中唯一标识的。在创建新项时，我们可以提供一个ID，或者服务器自动生成一个ID。一旦设置了`_id`，就不能更改。对于我们的模型，我们将使用练习/训练的`name`属性作为唯一ID，并将名称复制到`_id`字段中（因此，没有自动生成`_id`）。还要记住，我们的模型类不包含这个`_id`字段；在第一次保存记录之前，必须创建它。
- en: Let's fix the workout creation scenario first.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先解决训练创建的情况。
- en: Creating a new workout
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的训练
- en: 'Taking the bottom-up approach, the first thing that needs to be fixed is `WorkoutService`.
    Update the `addWorkout` method as shown in the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 采用自下而上的方法，需要修复的第一件事是`WorkoutService`。按照以下代码更新`addWorkout`方法：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In `getWorkout`, we had to map data from the server model to our client model;
    the reverse has to be done here. First, we create a new array for the exercises,
    `workoutExercises`, and then add to that array a version of the exercises that
    is more compact for server storage. We only want to store the exercise name and
    duration in the exercises array on the server (this array is of type `any` because
    in its compact format it does not conform to the `ExercisePlan` type).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getWorkout`中，我们需要将服务器模型的数据映射到我们的客户端模型；在这里需要做相反的操作。首先，我们为练习创建一个新数组`workoutExercises`，然后向该数组添加练习的一个更紧凑的版本，以便在服务器存储。我们只想在服务器上的练习数组中存储练习名称和持续时间（这个数组的类型是`any`，因为在其紧凑格式中它不符合`ExercisePlan`类型）。
- en: Next, we set up the body of our post by mapping these changes into a JSON object.
    Note that as part of constructing this object, we set the `_id` property as the
    name of the workout to uniquely identify it in the database of the workouts collection.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过将这些更改映射到一个JSON对象来设置我们的post的主体。请注意，作为构造此对象的一部分，我们将`_id`属性设置为训练的名称，以便在训练集合的数据库中唯一标识它。
- en: The simplistic approach of using the *name* of the workout/exercise as a record
    identifier (or `id`) in MongoDB will break for any decent-sized app. Remember
    that we are creating a web-based application that can be accessed simultaneously
    by many users. Since there is always the possibility of two users coming up with
    the same name for a workout/exercise, we need a strong mechanism to make sure
    that names are not duplicated. Another problem with the MongoLab REST API is that
    if there is a duplicate `POST` request with the same `id` field, one will create
    a new document and the second will update it, instead of the second failing. This
    implies that any duplicate checks on the `id` field on the client side still cannot
    safeguard against data loss. In such a scenario, assigning auto generation of
    the `id` value is preferable. In standard cases where we are creating entities,
    unique ID generation is done on the server (mostly by the database). The response
    to when an entity is created then contains the generated ID. In such a case, we
    need to update the model object before we return data to the calling code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MongoDB中的锻炼/练习名称作为记录标识符（或`id`）的简单方法将在任何规模较大的应用程序中出现问题。请记住，我们正在创建一个可以同时被许多用户访问的基于Web的应用程序。由于两个用户可能会想出相同的锻炼/练习名称，我们需要一个强大的机制来确保名称不重复。MongoLab
    REST API的另一个问题是，如果有一个重复的带有相同`id`字段的`POST`请求，一个将创建一个新文档，而第二个将更新它，而不是第二个失败。这意味着客户端对`id`字段的任何重复检查仍然无法防止数据丢失。在这种情况下，自动生成`id`值是可取的。在标准情况下，我们创建实体时，唯一ID生成是在服务器上完成的（主要是由数据库完成）。然后，当实体被创建时，响应包含生成的ID。在这种情况下，我们需要在将数据返回给调用代码之前更新模型对象。
- en: Lastly, we call the `post` method of the `HTTPClient` module, passing the URL
    to connect to, an extra query string parameter (`apiKey`), and the data we are
    sending.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`HTTPClient`模块的`post`方法，传递要连接的URL、额外的查询字符串参数（`apiKey`）和我们要发送的数据。
- en: The last return statement should look familiar, as we use Observables to return
    the workout object as part of the Observable resolution. You need to be sure you add
    `.subscribe` to the Observable chain in order to make it work. We'll do that shortly
    by adding a subscription to the `save` method to `WorkoutComponent`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的返回语句应该看起来很熟悉，因为我们使用Observables来返回锻炼对象作为Observable分辨率的一部分。您需要确保在Observable链中添加`.subscribe`以使其工作。我们将很快通过向`WorkoutComponent`的`save`方法添加一个订阅来实现这一点。
- en: Updating a workout
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新一个锻炼
- en: 'Why not try to implement the update operation? The `updateWorkout` method can
    be fixed in the same manner, the only difference being that the `HTTPClient` module''s
    `put` method is required:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不尝试实现更新操作呢？`updateWorkout`方法可以以相同的方式修复，唯一的区别是需要`HTTPClient`模块的`put`方法。
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding request URL now contains an extra fragment (`workout.name`) that
    denotes the identifier of the collection item that needs to be updated.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的请求URL现在包含了一个额外的片段（`workout.name`），表示需要更新的集合项的标识符。
- en: The MongoLab `PUT` API request creates the document passed in as the request
    body if the document is not found in the collection. While making the `PUT` request,
    make sure that the original record exists. We can do this by making a `GET` request
    for the same document first and confirming that we get a document before we update
    it. We'll leave that for you to implement.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在集合中找不到文档，MongoLab的`PUT` API请求将创建请求体中传递的文档。在进行`PUT`请求时，请确保原始记录存在。我们可以通过首先对同一文档进行`GET`请求并确认我们在更新之前获得了一个文档来实现这一点。我们将让你来实现这一点。
- en: Deleting a workout
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除一个锻炼
- en: 'The last operation that needs to be fixed is deleting the workout. Here is
    a simple implementation where we call the `HTTPClient` module''s `delete` method
    to delete the workout referenced by a specific URL:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 需要修复的最后一个操作是删除锻炼。这里是一个简单的实现，我们调用`HTTPClient`模块的`delete`方法来删除特定URL引用的锻炼：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Fixing the upstream code
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复上游代码
- en: 'With that, it''s now time to fix the `WorkoutBuilderService` and `Workout`
    components. The `save` method of `WorkoutBuilderService` now looks as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，现在是时候修复`WorkoutBuilderService`和`Workout`组件了。`WorkoutBuilderService`的`save`方法现在如下所示：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Most of it looks the same as it was earlier because it is the same! We did not
    have to update this code because we effectively isolated the interaction with
    the external server in our `WorkoutService` component.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分看起来与以前一样，因为它是一样的！我们不必更新此代码，因为我们在`WorkoutService`组件中有效地隔离了与外部服务器的交互。
- en: 'Finally, the save code for the `Workout` component is shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里显示了`Workout`组件的保存代码：
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here we have made a change so that we now subscribe to the save. As you may
    recall from our previous discussions, `subscribe` makes an Observable live so
    that we can complete the save.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们进行了更改，以便现在订阅保存。正如您可能还记得我们之前的讨论，`subscribe`使Observable变为活动状态，以便我们可以完成保存。
- en: And that's it! We can now create new workouts and update existing workouts (we'll
    leave completion of deleting workouts to you). That was not too difficult!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们现在可以创建新的锻炼并更新现有的锻炼（删除锻炼的完成留给您）。这并不太困难！
- en: Let's try it out. Open the new `Workout Builder` page, create a workout, and
    save it. Also try to edit an existing workout. Both scenarios should work seamlessly.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试。打开新的`Workout Builder`页面，创建一个锻炼，并保存它。还尝试编辑现有的锻炼。这两种情况应该可以无缝工作。
- en: Check out `checkpoint 5.3` for an up-to-date implementation if you are having
    issues running your local copy. If you are not using Git, download the snapshot
    of Checkpoint 5.3 (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular6byexample/tree/checkpoint5.3](https://github.com/chandermani/angular2byexample/tree/checkpoint5.3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看`checkpoint 5.3`，如果您在运行本地副本时遇到问题，请使用最新的实现。如果您不使用Git，请从以下GitHub位置下载Checkpoint
    5.3的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/tree/checkpoint5.3](https://github.com/chandermani/angular2byexample/tree/checkpoint5.3)。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: 'Something interesting happens on the network side while we make `POST` or `PUT`
    requests save data. Open the browser''s network log console (*F12*) and see the
    requests being made. The log looks something like the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行`POST`或`PUT`请求保存数据时，网络端发生了一些有趣的事情。打开浏览器的网络日志控制台（*F12*），查看正在进行的请求。日志看起来像下面这样：
- en: '![](Images/fb3766cd-7ab6-48bf-a59c-d80192bca5e8.png)The network log'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](Images/fb3766cd-7ab6-48bf-a59c-d80192bca5e8.png)网络日志
- en: An `OPTIONS` request is made to the same endpoint before the actual `POST` or `PUT` is
    done. The behavior that we witness here is termed as a **prefight request**. This
    happens because we are making a cross-domain request to `api.mongolab.com`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际进行`POST`或`PUT`之前，将向相同的端点发出`OPTIONS`请求。我们在这里见证的行为被称为**预检请求**。这是因为我们正在向`api.mongolab.com`发出跨域请求。
- en: Using promises for HTTP requests
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用承诺进行HTTP请求
- en: The bulk of this chapter has focused on how the Angular `HTTPClient` uses Observables
    as the default for `XMLHttpRequests`. This represents a significant change from
    the way things used to work. Many developers are familiar with using promises
    for asynchronous HTTP requests. With that being the case, Angular continues to
    support promises, but just not as the default choice. A developer has to opt for
    promises in an `XMLHttpRequest` in order to be able to use them.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容都集中在Angular `HTTPClient`如何将Observables作为`XMLHttpRequests`的默认值上。这代表了与以往工作方式的重大变化。许多开发人员习惯于使用promises进行异步HTTP请求。在这种情况下，Angular仍然支持promises，但不作为默认选择。开发人员必须选择在`XMLHttpRequest`中使用promises才能使用它们。
- en: 'For example, if we want to use promises with the `getExercises` method in `WorkoutService`,
    we will have to restructure the command as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要在`WorkoutService`中的`getExercises`方法中使用promises，我们将不得不重构命令如下：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In order to convert this method to use promises, all we have to do is add `.toPromise()`
    to the method chain, a success parameter, `then`, for the promise, and  `catch`
    with a `Promise.reject` pointing to the existing `handleError` method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个方法转换为使用promises，我们所要做的就是在方法链中添加`.toPromise()`，一个成功的参数`then`，用于promise的`catch`和指向现有`handleError`方法的`Promise.reject`。
- en: 'For upstream components, we just have to switch to handling the return value
    as a promise rather than an Observable. So, to use promises in this case, we would
    have to change the code in `Exercises.component.ts` and `LeftNavExercises.component.ts`
    to first add a new property for the error message (we''ll leave it to you as to
    how the error message is displayed on the screen):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上游组件，我们只需要将返回值处理为promise而不是Observable。因此，在这种情况下使用promises，我们需要更改`Exercises.component.ts`和`LeftNavExercises.component.ts`中的代码，首先添加一个新的属性用于错误消息（关于如何在屏幕上显示错误消息，我们将留给您）：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then change the `ngOnInit` method that is calling `WorkoutService` to the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将调用`WorkoutService`的`ngOnInit`方法更改为以下内容：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Of course, the ease with which we can substitute promises for Observables in
    this simple example does not indicate that they are essentially the same. A `then`
    promise returns another promise, which means that you can create successively
    chained promises. In the case of an Observable, a subscription is essentially
    the end of the line and cannot be mapped or subscribed to beyond that point.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们在这个简单的例子中可以轻松地用promises替换Observables，并不意味着它们本质上是相同的。一个`then` promise会返回另一个promise，这意味着您可以创建连续链接的promises。而对于Observable，订阅本质上是终点，不能在那一点之后进行映射或订阅。
- en: If you're familiar with promises, it may be tempting at this stage to stick
    with them and not give Observables a try. After all, much of what we have done
    with Observables in this chapter can be done with promises as well. For example,
    the mapping of two streams of Observables that we did with `getWorkouts` using
    the Observable's `forkJoin` operator can also be done with the promise's `q,all`
    function.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉promises，此时可能会诱人地坚持使用它们，而不尝试使用Observables。毕竟，本章中我们使用Observables所做的许多事情也可以用promises来完成。例如，我们使用Observable的`forkJoin`运算符对`getWorkouts`的两个流进行映射，也可以使用promise的`q,all`函数来完成。
- en: However, you would be selling yourself short if you took that approach. Observables
    open up an exciting new way of doing web development using what is called functional
    reactive programming. They involve a fundamental shift in thinking that treats
    an application's data as a constant stream of information to which the application
    reacts and responds. This shift allows applications to be built with a different
    architecture that makes them faster and more resilient. Observables are at the
    core of Angular in such things as event emitters and the new version of `NgModel`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你采取这种方法，你会卖自己短。Observables开启了一种令人兴奋的新的网页开发方式，使用了所谓的函数式响应式编程。它们涉及一种基本的思维转变，将应用程序的数据视为一种不断流动的信息，应用程序对其做出反应和响应。这种转变使应用程序可以使用不同的架构构建，使其更快速和更具弹性。Observables是Angular的核心，例如事件发射器和新版本的`NgModel`。
- en: While promises are a useful tool to have in your toolkit, we encourage you to
    investigate Observables as you get into developing with Angular. They are part
    of the forward-looking philosophy of Angular and will be useful in future-proofing
    both your applications and your skill set.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的工具包中拥有承诺是一个有用的工具，但是当你开始使用Angular进行开发时，我们鼓励你去研究Observables。它们是Angular前瞻性哲学的一部分，将对未来保护你的应用程序和技能组合都非常有用。
- en: 'Check out the `checkpoint 5.3` file for an up-to-date implementation that includes
    the promises-related code that we covered previously. If you are not using Git,
    download the snapshot of Checkpoint 5.3 (a ZIP file) from the following GitHub
    location: [https://github.com/chandermani/angular6byexample/tree/checkpoint5.3](https://github.com/chandermani/angular6byexample/tree/checkpoint5.3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Be aware that in the next section, we will be reverting to
    the use of Observables for this code. This code can be found in the `checkpoint
    5.4` file.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`checkpoint 5.3`文件，以获取包含我们之前涵盖的与承诺相关的代码的最新实现。如果你不使用Git，请从以下GitHub位置下载Checkpoint
    5.3的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/tree/checkpoint5.3](https://github.com/chandermani/angular6byexample/tree/checkpoint5.3)。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。请注意，在下一节中，我们将恢复使用Observables来进行这段代码。这段代码可以在`checkpoint
    5.4`文件中找到。
- en: The async pipe
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步管道
- en: As we have seen with many of the data operations covered in this chapter, there
    is a fairly common pattern being repeated over and over again. When an Observable
    is returned from an HTTP request, we convert the response to JSON and subscribe
    to it. The subscription then binds the Observable output to a UI element. Wouldn't
    it be nice if we could eliminate this repetitive coding and replace it with a
    simpler way to accomplish what we are wanting to do?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中涵盖的许多数据操作中所看到的，有一个相当常见的模式一次又一次地重复。当从HTTP请求返回一个Observable时，我们将响应转换为JSON并订阅它。然后订阅将Observable输出绑定到UI元素。如果我们能够消除这种重复的编码，并用更简单的方法来实现我们想要做的事情，那不是很好吗？
- en: Not surprisingly, Angular provides us with just the right way to do that. It's
    called the **async pipe**, and it can be used like any other pipe for binding
    to an element on the screen. However, the async pipe is a much more powerful mechanism
    than other pipes. It takes an Observable or a promise as an input and subscribes
    to it automatically. It also handles the teardown of the subscription for an Observable
    without necessitating any further lines of code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，Angular为我们提供了一种正确的方法来做到这一点。它被称为**异步管道**，可以像其他管道一样用于绑定屏幕上的元素。然而，异步管道比其他管道更强大。它接受Observable或承诺作为输入，并自动订阅它。它还处理Observable的订阅拆除，而无需任何额外的代码。
- en: Let's look at an example of this in our application. Let's go back to the `LeftNavExercises`
    component that we were just looking at in the previous section in connection with
    promises. Note that we have converted this component and the `Exercises` component
    from promises back to using Observables.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的应用程序中看一个例子。让我们回到我们刚刚在上一节中与promises相关的`LeftNavExercises`组件。请注意，我们已经将这个组件和`Exercises`组件从promises转换回使用Observables。
- en: 'Check out the `checkpoint 5.4` file for an up-to-date implementation that includes
    the conversion of this code to use Observables once again. If you are not using
    Git, download the snapshot of Checkpoint 5.4 (a ZIP file) from the following GitHub
    location: [https://github.com/chandermani/angular6byexample/tree/checkpoint5.4](https://github.com/chandermani/angular6byexample/tree/checkpoint5.4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`checkpoint 5.4`文件，以获取包括将此代码再次转换为使用Observables的最新实现。如果您没有使用Git，请从以下GitHub位置下载Checkpoint
    5.4的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/tree/checkpoint5.4](https://github.com/chandermani/angular6byexample/tree/checkpoint5.4)。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: 'Then make the following changes in `LeftNavExercises`. First, import Observable
    from RxJs:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`LeftNavExercises`中进行以下更改。首先，从RxJs导入Observable：
- en: '[PRE25]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then change `exerciseList` from an array of exercises to an Observable of the
    same type:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将`exerciseList`从一个练习数组更改为相同类型的Observable：
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next modify the call to `WorkoutService` that gets the exercises to eliminate
    the subscription:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来修改调用`WorkoutService`获取练习的部分，以消除订阅：
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, open `left-nav-exercises.component.html` and add the `async` pipe
    to the `*ngFor` loop, as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开`left-nav-exercises.component.html`并将`async`管道添加到`*ngFor`循环中，如下所示：
- en: '[PRE28]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Refresh the page and you will still see the Exercise list displaying. But this
    time, we have used the `async` pipe to eliminate the need to set up the subscription
    to the Observable. Pretty cool! This is a nice convenience that Angular has added,
    and since we have been spending time in this chapter understanding how Observables
    work with subscriptions, we have a clear idea of what the `async` pipe is now
    handling for us under the hood.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新页面，您仍然会看到练习列表显示。但这一次，我们使用了`async`管道来消除设置对Observable的订阅的需要。非常酷！这是Angular添加的一个很好的便利，因为我们在本章花时间理解了Observable如何与订阅配合工作，现在我们清楚了`async`管道在幕后为我们处理的内容。
- en: We'll leave it to you to implement the same change in the `Exercises` component.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让您在`Exercises`组件中实现相同的更改。
- en: It is important to understand the cross-domain behavior of the HTTP request
    and the constructs that Angular provides to make cross-domain requests.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 了解HTTP请求的跨域行为以及Angular提供的构造来进行跨域请求是很重要的。
- en: Cross-domain access and Angular
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨域访问和Angular
- en: Cross-domain requests are requests made for resources in a different domain.
    Such requests, when originated from JavaScript, have some restrictions imposed
    by the browser; these are called *same-origin policy* restrictions. Such a restriction
    stops the browser from making AJAX requests to domains that are different from
    the script's original source. The source match is done strictly based on a combination
    of protocol, host, and port.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 跨域请求是对不同域中资源的请求。这些请求，当由JavaScript发起时，会受到浏览器施加的一些限制；这些被称为*同源策略*限制。这种限制阻止浏览器向与脚本原始来源不同的域发出AJAX请求。源匹配严格基于协议、主机和端口的组合。
- en: For our own app, the calls to `https://api.mongolab.com` are cross-domain invocations
    as our source code hosting is in a different domain (most probably, something
    like `http://localhost/....`).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们自己的应用程序，对`https://api.mongolab.com`的调用是跨域调用，因为我们的源代码托管在不同的域中（很可能是`http://localhost/....`之类的）。
- en: 'There are some workarounds and some standards that help relax/control cross-domain
    access. We will be exploring two of these techniques as they are the most commonly
    used ones. They are as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些变通方法和一些标准可以帮助放松/控制跨域访问。我们将探讨其中两种技术，因为它们是最常用的。它们如下：
- en: '**JSON with Padding** (**JSONP**)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSONP（JSON with Padding）
- en: '**Cross-Origin Resource Sharing** (**CORS**)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨域资源共享（CORS）
- en: A common way to circumvent this same-origin policy is to use the JSONP technique.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 规避同源策略的常见方法是使用JSONP技术。
- en: Using JSONP to make cross-domain requests
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSONP进行跨域请求
- en: The JSONP mechanism of remote invocation relies on the fact that browsers can
    execute JavaScript files from any domain irrespective of the source of origin
    as long as the script is included via the `<script>` tag.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 远程调用的JSONP机制依赖于浏览器可以执行来自任何域的JavaScript文件，而不管源自何处，只要通过`<script>`标签包含该脚本。
- en: In JSONP, instead of making a direct request to a server, a dynamic `<script>`
    tag is generated, with the `src` attribute set to the server endpoint that needs
    to be invoked. This `<script>` tag, when appended to the browser's DOM, causes
    a request to be made to the target server.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSONP中，不是直接向服务器发出请求，而是生成一个动态的`<script>`标签，其中`src`属性设置为需要调用的服务器端点。当这个`<script>`标签附加到浏览器的DOM时，会导致向目标服务器发出请求。
- en: The server then needs to send a response in a specific format, wrapping the
    response content inside a function invocation code (this extra padding around
    the response data gives this technique the name JSONP).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后服务器需要以特定格式发送响应，将响应内容包装在函数调用代码中（响应数据周围的这些额外填充使得这种技术被称为JSONP）。
- en: The Angular JSONP service hides this complexity and provides an easy API to
    make JSONP requests. The StackBlitz link, [https://stackblitz.com/edit/angular-nxeuxo](https://stackblitz.com/edit/angular-nxeuxo),
    highlights how JSONP requests are made. It uses the *IEX Free Stock API* ([https://iextrading.com/developer/](https://iextrading.com/developer/))
    to get quotes for any stock symbol.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Angular JSONP服务隐藏了这种复杂性，并提供了一个简单的API来进行JSONP请求。StackBlitz链接，[https://stackblitz.com/edit/angular-nxeuxo](https://stackblitz.com/edit/angular-nxeuxo)，突出了如何进行JSONP请求。它使用*IEX
    Free Stock API*（[https://iextrading.com/developer/](https://iextrading.com/developer/)）来获取任何股票符号的报价。
- en: The Angular JSONP service only supports HTTP `GET` requests. Using any other
    HTTP request, such as `POST` or `PUT`, will generate an error.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Angular JSONP服务仅支持HTTP `GET`请求。使用任何其他HTTP请求，如`POST`或`PUT`，将生成错误。
- en: If you look at the StackBlitz project, you will see the familiar pattern for
    component creation that we have followed throughout this book. We will not go
    over this pattern again, but will highlight a few details that are relevant to
    using the Angular JSONP service.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看StackBlitz项目，您将看到我们在整本书中一直遵循的组件创建的熟悉模式。我们不会再次介绍这个模式，但会强调一些与使用Angular JSONP服务相关的细节。
- en: 'First, along with the imports for `FormsModule` and `HttpClientModule`, you
    will need to import `HttpClientJsonpModule` into `app.module.ts` as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，除了导入`FormsModule`和`HttpClientModule`之外，您还需要将`HttpClientJsonpModule`导入到`app.module.ts`中，如下所示：
- en: '[PRE29]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we need to add the following imports to `get-quote.component.ts`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将以下导入添加到`get-quote.component.ts`中：
- en: '[PRE30]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We are importing `HttpClient`, which contains the `JSONP` methods we will be
    using, as well as the RxJS `Observable` and the `map ` operator. These imports
    will look familiar to you from what we have been building in this chapter.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在导入`HttpClient`，其中包含我们将使用的`JSONP`方法，以及RxJS`Observable`和`map`操作符。这些导入对你来说应该很熟悉，因为我们在本章中一直在构建它们。
- en: As you work with Angular JSONP, it is important to understand that by default,
    it returns Observables using RxJS. This means that we will have to follow the
    pattern for subscribing to those Observables and use the RxJS operators to manipulate
    the results. We can also use the async pipe to streamline these operations.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Angular JSONP时，重要的是要理解，默认情况下它返回使用RxJS的Observables。这意味着我们将不得不遵循订阅这些Observables的模式，并使用RxJS操作符来操作结果。我们还可以使用async管道来简化这些操作。
- en: 'Then we inject `HttpClient` into the constructor:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将`HttpClient`注入到构造函数中：
- en: '[PRE31]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next we add several variables that we will be using in our JSONP call:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加了几个变量，我们将在我们的JSONP调用中使用：
- en: '[PRE32]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `symbol` variable will hold the search string provided by the user. The
    `quote` variable will be used in our template to display the returned value from
    the JSONP call. And the `url` variable is the base URL for the call we will be
    making to the service.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`symbol`变量将保存用户提供的搜索字符串。`quote`变量将用于在我们的模板中显示从JSONP调用返回的值。`url`变量是我们将要对服务进行调用的基本URL。'
- en: 'Now we have everything in place for our `getQuote` method. Let''s take a look
    at it:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了我们的`getQuote`方法。让我们来看一下它：
- en: '[PRE33]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We first construct our `searchUrl` by concatenating the `url` with the `symbol`
    and adding `/quote`. The last part `quote` is what we need to pass to the quote
    service to return a stock quote.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过将`url`与`symbol`连接并添加`/quote`来构造我们的`searchUrl`。`quote`的最后部分是我们需要传递给报价服务以返回股票报价的部分。
- en: We then use the HTTPClient's `jsonp` method to execute the remote call to the
    quote service. We pass the `searchUrl` as the first parameter of that method and
    a string `'callback'` as our second parameter. The latter parameter is used by
    Angular to augment the `searchUrl` with an extra query string parameter, `callback`.
    Internally, the Angular JSONP service then generates a dynamic `script` tag and
    a callback function and makes the remote request.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用HTTPClient的`jsonp`方法来执行对报价服务的远程调用。我们将`searchUrl`作为该方法的第一个参数传递，并将字符串`'callback'`作为我们的第二个参数。后一个参数被Angular用来用额外的查询字符串参数`callback`来增强`searchUrl`。在内部，Angular
    JSONP服务然后生成一个动态的`script`标签和一个回调函数，并发起远程请求。
- en: 'Open StackBlitz and enter symbols such as `GOOG`, `MSFT`, or `FB` to see the
    stock quote service in action. The browser network log for requests looks as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 打开StackBlitz并输入诸如`GOOG`、`MSFT`或`FB`之类的符号，以查看股票报价服务的运行情况。请求的浏览器网络日志如下：
- en: '[PRE34]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, `ng_jsonp_callback_0` is the dynamically generated function. And the
    response looks as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ng_jsonp_callback_0`是动态生成的函数。响应如下：
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The response is wrapped in the callback function. Angular parses and evaluates
    this response, which results in the invocation of the `__ng_jsonp__.__req1` callback
    function. Then, this function internally routes the data to our function callback.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 响应被包裹在回调函数中。Angular解析并评估这个响应，导致调用`__ng_jsonp__.__req1`回调函数。然后，这个函数内部将数据路由到我们的函数回调。
- en: 'We hope this explains how JSONP works and what the underlying mechanism of
    a JSONP request is. However, JSONP has its limitations:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这解释了JSONP的工作原理以及JSONP请求的基本机制。然而，JSONP有它的局限性：
- en: First, we can make only `GET` requests (which is obvious as these requests originate
    due to script tags)
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们只能进行`GET`请求（这是显而易见的，因为这些请求是由脚本标签发起的）
- en: Second, the server also needs to implement the part of the solution that involves
    wrapping the response in a function callback
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，服务器还需要实现涉及将响应包装在函数回调中的解决方案的部分
- en: Third, there is always a security risk involved, as JSONP depends on dynamic
    script generation and injection
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，总是存在安全风险，因为JSONP依赖于动态脚本生成和注入
- en: Fourth, error handling is not reliable too because it is not easy to determine
    why a script load failed
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四，错误处理也不可靠，因为很难确定脚本加载失败的原因
- en: Ultimately, we must recognize that JSONP is more of a workaround than a solution.
    As we move towards Web 2.0, where mashups become commonplace and more and more
    service providers decide to expose their API over the web, a far better solution/standard
    has emerged: CORS.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们必须认识到JSONP更像是一种权宜之计，而不是一种解决方案。随着我们向Web 2.0迈进，混搭变得司空见惯，越来越多的服务提供商决定在Web上公开他们的API，一个更好的解决方案/标准已经出现：CORS。
- en: Cross-origin resource sharing
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨域资源共享
- en: '**Cross-origin Resource Sharing** (**CORS**) provides a mechanism for the web
    server to support cross-site access control, allowing browsers to make cross-domain
    requests from scripts. With this standard, a consumer application (such as *Personal
    Trainer*) is allowed to make some types of requests, termed **simple requests**,
    without any special setup requirements. These simple requests are limited to `GET`,
    `POST` (with specific MIME types), and `HEAD`. All other types of requests are
    termed **complex requests**.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨域资源共享**（**CORS**）提供了一种机制，使Web服务器能够支持跨站点访问控制，允许浏览器从脚本中进行跨域请求。根据这个标准，消费者应用程序（如*个人健身教练*）可以在没有任何特殊设置要求的情况下进行一些类型的请求，称为**简单请求**。这些简单请求仅限于`GET`，`POST`（具有特定的MIME类型）和`HEAD`。所有其他类型的请求被称为**复杂请求**。'
- en: For complex requests, CORS mandates that the request should be preceded by an
    HTTP `OPTIONS` request (also called a preflight request) that queries the server
    for HTTP methods allowed for cross-domain requests. And only on successful probing
    is the actual request made.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂请求，CORS要求请求应该在HTTP `OPTIONS`请求（也称为预检请求）之前进行，该请求查询服务器允许跨域请求的HTTP方法。只有在成功探测后才会进行实际请求。
- en: You can learn more about CORS from the MDN documentation available at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从MDN文档中了解更多关于CORS的信息，网址为[https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS)。
- en: The best part about CORS is that the client does not have to make any adjustment
    as in the case of JSONP. The complete handshake mechanism is transparent to the
    calling code and our Angular `HTTPClient` calls work without a hitch.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: CORS最好的部分是，客户端不需要进行任何调整，就像JSONP的情况一样。完整的握手机制对调用代码透明，我们的Angular `HTTPClient`调用可以毫无问题地工作。
- en: CORS requires configurations to be made on the server, and the MongoLab servers
    have already been configured to allow cross-domain requests. So the preceding
    `POST` and `PUT` requests that we made to the MongoLab to add and update `Exercise`
    and `Workout` documents all caused the preflight `OPTIONS` request.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: CORS需要在服务器上进行配置，并且MongoLab服务器已经配置为允许跨域请求。因此，我们之前对MongoLab进行的`POST`和`PUT`请求以添加和更新`Exercise`和`Workout`文档都引起了预检`OPTIONS`请求。
- en: Handling workouts not found
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理找不到的锻炼
- en: You might recall that in [Chapter 2](4b0ad450-2a56-4c24-b431-116d7225a57e.xhtml),
    *Personal Trainer*, we created the `WorkoutResolver` to not only retrieve a workout
    prior to navigation to the `WorkoutComponent`, but also prevent navigation to
    that component if a non-existent workout was in the route parameters. Now we would
    like to augment this functionality by displaying an error message on the workouts
    screen, indicating that the workout was not found.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得在[第2章](4b0ad450-2a56-4c24-b431-116d7225a57e.xhtml)中，*个人教练*，我们创建了`WorkoutResolver`，不仅在导航到`WorkoutComponent`之前检索锻炼，而且还防止导航到该组件，如果路由参数中不存在锻炼。现在我们希望通过在锻炼屏幕上显示错误消息来增强此功能，指示未找到锻炼。
- en: 'In order to do this, we are going to modify `WorkoutResolver` so that it reroutes
    to the workouts screen if a workout is not found. To start, add the following
    child route to `WorkoutBuilderRoutingModule` (making sure it precedes the existing
    workouts route):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将修改`WorkoutResolver`，以便在找不到锻炼时重新路由到锻炼屏幕。首先，在`WorkoutBuilderRoutingModule`中添加以下子路由（确保它位于现有的锻炼路由之前）：
- en: '[PRE36]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, modify the `resolve` method in the `WorkoutResolver` to redirect to this
    route in the event that a workout is not found:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改`WorkoutResolver`中的`resolve`方法，以便在找不到锻炼时重定向到该路由：
- en: '[PRE37]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then add a `notFound` boolean set to `false` to the variables in the `Workouts`
    component:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`Workouts`组件的变量中添加一个名为`notFound`的布尔值，设置为`false`。
- en: '[PRE38]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And, in the `ngOnInit` method of that component, add the following code to
    check for the `workout-not-found` path and set the `notFound` value to `true`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在该组件的`ngOnInit`方法中，添加以下代码来检查`workout-not-found`路径并将`notFound`值设置为`true`：
- en: '[PRE39]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally in the `Workouts.component.html` template, add the following `div`
    tag above the workout list that will display if the `notFound` is set to `true`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`Workouts.component.html`模板中，在锻炼列表上方添加以下`div`标签，如果`notFound`设置为`true`，则会显示：
- en: '[PRE40]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we find `workout-not-found` in the path when a user is returned to the `Workouts`
    page, then this displays the following message on the screen:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户返回到`Workouts`页面时在路径中找到`workout-not-found`，则在屏幕上显示以下消息：
- en: '![](Images/fd1d8b39-7c56-46a0-9965-55fa568c53c4.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fd1d8b39-7c56-46a0-9965-55fa568c53c4.png)'
- en: We have fixed routing failure for the Workout Builder page, but the exercise
    builder page is still pending. Again, we will leave it to you to fix it yourself.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经修复了锻炼生成器页面的路由失败，但练习生成器页面仍在进行中。再次，我们将让您自行解决。
- en: Another major (and pending) implementation is fixing *7 Minute Workout*, as
    it currently caters to only one workout routine.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个主要的（尚未完成）实现是修复*7分钟锻炼*，因为它目前只适用于一个锻炼例程。
- en: Fixing the 7 Minute Workout app
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复7分钟锻炼应用程序
- en: As it stands now, the *7 Minute Workout* (or *Workout Runner*) app can play
    only one specific workout. It needs to be fixed to support the execution of any
    workout plan built using *Personal Trainer*. There is an obvious need to integrate
    these two solutions. We already have the groundwork done to commence this integration.
    We've got the shared model services and `WorkoutService` to load data, enough
    to get us started.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，*7分钟锻炼*（或*锻炼运行器*）应用程序只能播放一个特定的锻炼。需要修复以支持使用*个人教练*构建的任何锻炼计划的执行。显然需要将这两个解决方案整合起来。我们已经做好了开始整合的准备工作。我们已经有了共享的模型服务和`WorkoutService`来加载数据，足以让我们开始。
- en: 'Fixing *7 Minute Workout* and converting it into a generic *Workout Runner*
    roughly involves the following steps:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 修复*7分钟锻炼*并将其转换为通用的*锻炼运行器*大致涉及以下步骤：
- en: Removing the hardcoded workout and exercises used in *7 Minute Workout*.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除*7分钟锻炼*中使用的硬编码锻炼和练习。
- en: Fixing the start page to show all available workouts and allowing users to select
    a workout to run.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复起始页面以显示所有可用的锻炼，并允许用户选择要运行的锻炼。
- en: Fixing the workout route configuration to pass the selected workout name as
    the route parameter to the workout page.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复锻炼路由配置，将所选的锻炼名称作为路由参数传递到锻炼页面。
- en: Loading the selected workout data using `WorkoutService` and starting the workout.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`WorkoutService`加载所选的锻炼数据并开始锻炼。
- en: And, of course, we need to rename the *7 Minute Workout* part of the app; the
    name is now a misnomer. I think the complete app can be called *Personal Trainer*.
    We can remove all references to *7 Minute Workout* from the view as well.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，我们需要重新命名应用程序的*7分钟锻炼*部分；现在这个名字是错误的。我认为完整的应用程序可以称为*个人教练*。我们还可以从视图中删除对*7分钟锻炼*的所有引用。
- en: An excellent exercise to try out yourself! And that is why we are not going
    to walk you through the solution. Instead, go ahead and implement the solution.
    Compare your implementation with the one available at `checkpoint 5.4`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的练习是尝试自己去做！这就是为什么我们不会为您提供解决方案。相反，继续实施解决方案。将您的实现与`检查点5.4`中提供的实现进行比较。
- en: It's time to end the chapter and summarize your learning.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候结束本章并总结您的学习了。
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We now have an app that can do a lot of stuff. It can run workouts, load workouts,
    save and update them, and track history. And if we look back, we have achieved
    this with minimal code. We bet that if we were to try this in standard jQuery
    or some other framework, it would require substantially more effort as compared
    to Angular.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个可以做很多事情的应用程序。它可以运行锻炼，加载锻炼，保存和更新它们，并跟踪历史。如果我们回顾一下，我们用了很少的代码就实现了这一切。我们敢打赌，如果我们尝试在标准的jQuery或其他框架中做这个，与Angular相比，它将需要更多的努力。
- en: We started the chapter by providing a *MongoDB* database on *MongoLab* servers.
    Since MongoLab provided a RESTful API to access the database, we saved some time
    by not setting up our own server infrastructure.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开始时提供了*MongoLab*服务器上的*MongoDB*数据库。由于MongoLab提供了一个RESTful API来访问数据库，我们节省了一些时间，因为不需要设置自己的服务器基础设施。
- en: The first Angular construct that we touched upon was the `HTTPClient`, which
    is the primary service for connecting to any HTTP backend.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们触及的第一个Angular构造是`HTTPClient`，它是连接到任何HTTP后端的主要服务。
- en: You also learned how the `HTTPClient` module uses Observables. For the first
    time, in this chapter, we created our own Observable and explained how to create
    subscriptions to those Observables.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学习了`HTTPClient`模块如何使用Observables。在本章中，我们首次创建了自己的Observable，并解释了如何订阅这些Observables。
- en: We fixed our *Personal Trainer* app so that it uses the `HTTPClient` module
    to load and save workout data (note that data persistence for exercises is left
    for you to complete). In the process, you also learned about issues surrounding
    cross-domain resource access. You learned about JSONP, a workaround to circumvent
    a browser's *same-origin* restrictions, and how to issue JSONP requests using
    Angular. We also touched upon CORS, which has emerged as a standard when it comes
    to cross-domain communication.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修复了我们的*个人教练*应用程序，使其使用`HTTPClient`模块来加载和保存锻炼数据（请注意，对于锻炼的数据持久性留给您来完成）。在这个过程中，您还了解了围绕跨域资源访问的问题。您了解了JSONP，这是一个绕过浏览器*同源*限制的解决方法，以及如何使用Angular发出JSONP请求。我们还涉及了CORS，这在跨域通信方面已成为标准。
- en: 'We have now covered most of the building blocks of Angular, except the big
    one: Angular directives. We have used directives everywhere, but have not created
    one. The next chapter is exclusively dedicated to Angular directives. We will
    be creating a number of small directives, such as a remote validator, AJAX button,
    and a validation cues directive for the *Workout Builder* app.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了Angular的大部分构建块，除了一个重要的：Angular指令。我们在各个地方使用了指令，但还没有创建一个。下一章将专门致力于Angular指令。我们将创建许多小指令，例如远程验证器、AJAX按钮和*Workout
    Builder*应用程序的验证提示指令。

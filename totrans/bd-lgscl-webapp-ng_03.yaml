- en: Supporting Server Data Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's now time to talk to the server! There is no fun in creating a workout,
    adding exercises, and saving it to later realize that all our efforts are lost
    because the data did not persist anywhere. We need to fix this.
  prefs: []
  type: TYPE_NORMAL
- en: Seldom are applications self-contained. Any consumer app, irrespective of its
    size, has parts that interact with elements outside its boundary. With web-based
    applications, the interaction is mostly with a server. Apps interact with the
    server to authenticate, authorize, store/retrieve data, validate data, and perform
    other such operations.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explores the constructs that Angular provides for client-server
    interaction. In the process, we add a persistence layer to *Personal Trainer*
    that loads and saves data to a backend server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we cover in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Provisioning a backend to persist workout data**: We set up a MongoLab account
    and use its Data API to access and store workout data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understanding the Angular HttpClient**: The `HttpClient` allows us to interact
    with a server over HTTP. You''ll learn how to make all types of `GET`, `POST`,
    `PUT`, and `DELETE` requests with the `HttpClient`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementing the loading and saving of workout data**: We use the `HTTPClient`
    to load and store workout data in the MongoLab databases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Two ways in which we can use the HttpClient''s XMLHttpRequest**: Either Observables
    or with promises.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using RxJS and Observables**: To subscribe to and query streams of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using promises**: In this chapter, we will see how to use promises as part
    of HTTP invocation and response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Working with cross-domain access**: As we are interacting with a MongoLab
    server in a different domain, you will learn about browser restrictions on cross-domain
    access. You will also learn how JSONP and CORS help us make cross-domain access
    easy and about Angular JSONP support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's set the ball rolling.
  prefs: []
  type: TYPE_NORMAL
- en: Angular and server interactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any client-server interaction typically boils down to sending HTTP requests
    to a server and receiving responses from a server. For heavy JavaScript apps,
    we depend on the AJAX request/response mechanism to communicate with the server.
    To support AJAX-based communication, Angular provides the Angular `HttpClient` module.
    Before we delve into the `HttpClient` module, we need to set up our server platform
    that stores the data and allows us to manage it.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the persistence store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For data persistence, we use a document database called MongoDB ([https://www.mongodb.com/](https://www.mongodb.com/)),
    hosted over MongoLab ([https://www.mlab.com/](https://www.mlab.com/)), as our
    data store. The reason we zeroed in on MongoLab is that it provides an interface
    to interact with the database directly. This saves us the effort of setting up
    server middleware to support MongoDB interaction.
  prefs: []
  type: TYPE_NORMAL
- en: It is never a good idea to expose the data store/database directly to the client.
    But in this case, since our primary aim is to learn about Angular and client-server
    interaction, we take this liberty and directly access the MongoDB instance hosted
    in MongoLab. There is also a new breed of apps that are built over **noBackend**
    solutions. In such a setup, frontend developers build apps without the knowledge
    of the exact backend involved. Server interaction is limited to making API calls
    to the backend. If you are interested in knowing more about these noBackend solutions,
    do check out [http://nobackend.org/](http://nobackend.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first task is to provision an account on MongoLab and create a database:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://mlab.com](https://mlab.com) and sign up for an mLab account by
    following the instructions on the website
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the account is provisioned, log in and create a new Mongo database by clicking
    on the Create New button on the home page
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the database creation screen, you need to make some selections to provision
    the database. See the following screenshot to select the free database tier and
    other options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/f77d00af-d5f5-4a3c-80ec-b4f229c79e75.png)'
  prefs: []
  type: TYPE_IMG
- en: Create the database and make a note of the database name that you create
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the database is provisioned, open the database and add two collections
    to it from the Collection tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`exercises`: This stores all *Personal Trainer* exercises'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workouts`: This stores all *Personal Trainer* workouts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collections in the MongoDB world equate to a database table.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB belongs to a breed of databases called **document databases**. The central
    concepts here are documents, attributes, and their linkages. And unlike traditional
    databases, the schema is not rigid. We will not be covering what document databases
    are and how to perform data modeling for document-based stores in this book. *Personal
    Trainer* has a limited storage requirement and we manage it using the two previously
    mentioned document collections. We may not even be using the document database
    in its true sense.
  prefs: []
  type: TYPE_NORMAL
- en: Once the collections are added, add yourself as a user to the database from
    the Users tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to determine the API key for the MongoLab account. The provisioned
    API key has to be appended to every request made to MongoLab. To get the API key,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the username (not the account name) in the top-right corner to open
    the user profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the section titled API Key, the current API key is displayed; copy it. At
    the same time, click on the button below the API key to Enable Data API access.
    This is disabled by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The data store schema is complete. We now need to seed these collections.
  prefs: []
  type: TYPE_NORMAL
- en: Seeding the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Personal Trainer* app already has a predefined workout and a list of 12
    exercises. We need to seed the collections with this data.
  prefs: []
  type: TYPE_NORMAL
- en: Open `seed.js` in the `trainer/db` folder for checkpoint 5.1 from the companion
    code base. It contains the seed JSON script and detailed instructions on how to
    seed data into the MongoLab database instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once seeded, the database will have one workout in the workouts collection
    and 12 exercises in the exercises collection. Verify this on the MongoLab site;
    the collections should show the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f0da6449-0b07-4221-a218-299189fbad23.png)'
  prefs: []
  type: TYPE_IMG
- en: Everything has been set up now, so let's start our discussion of the `HttpClient` module
    and implement workout/exercise persistence for the *Personal Trainer* app.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of the HTTPClient module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the core of the `HTTPClient` module is the `HttpClient`. It performs HTTP
    requests using `XMLHttpRequest` as the default backend (JSONP is also available,
    as we will see later in this chapter). It supports requests such as `GET`, `POST`,
    `PUT`, and `DELETE`. In this chapter, we will use the `HttpClient` to make all
    of these types of requests. As we will see, the `HttpClient` makes it easy to
    make these calls with a minimal amount of setup and complexity. None of this terminology
    will come as a surprise to anyone who has previously worked with Angular or built
    JavaScript applications that communicate with a backend data store.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a substantial change in the way Angular handles HTTP requests.
    Calling a request now returns an Observable of HTTP responses. It does so by using
    the RxJS library, which is a well-known open source implementation of the asynchronous
    Observable pattern.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the RxJS project on GitHub at [https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS).
    The site indicates that the project is being actively developed by Microsoft in
    collaboration with a community of open source developers. We will not be covering
    the asynchronous Observable pattern in great detail here, and we encourage you
    to visit that site to learn more about the pattern and how RxJS implements it.
    The version of RxJS that Angular is using is beta 5.
  prefs: []
  type: TYPE_NORMAL
- en: In the simplest of terms, using Observables allows a developer to think about
    the data that flows through an application as streams of information that the
    application can dip into and use whenever it wants. These streams change over
    time, which allows the application to react to these changes. This quality of
    Observables provides a foundation for **functional reactive programming** (**FRP**),
    which fundamentally shifts the paradigm for building web applications from imperative
    to reactive.
  prefs: []
  type: TYPE_NORMAL
- en: The `RxJS` library provides operators that allow you to subscribe to and query
    these data streams. Moreover, you can easily mix and combine them, as we will
    see in this chapter. Another advantage of Observables is that it is easy to cancel
    or unsubscribe from them, making it possible to seamlessly handle errors inline.
  prefs: []
  type: TYPE_NORMAL
- en: While it is still possible to use promises, the default method in Angular uses
    Observables. We will also cover promises in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Personal Trainer and server integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described in the previous section, client-server interaction is all about
    asynchronicity. As we alter our *Personal Trainer* app to load data from the server,
    this pattern becomes self-evident.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, the initial set of workouts and exercises was hardcoded
    in the `WorkoutService` implementation. Let's see how to load this data from the
    server first.
  prefs: []
  type: TYPE_NORMAL
- en: Loading exercise and workout data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we seeded our database with a data form, the `seed.js`
    file. We now need to render this data in our views. The MongoLab Data API is going
    to help us here.
  prefs: []
  type: TYPE_NORMAL
- en: The MongoLab Data API uses an API key to authenticate access requests. Every
    request made to the MongoLab endpoints needs to have a query string parameter,
    `apikey=<key>`, where `key` is the API key that we provisioned earlier in the
    chapter. Remember that the key is always provided to a user and associated with
    their account. Avoid sharing your API keys with others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API follows a predictable pattern to query and update data. For any MongoDB
    collection, the typical endpoint access pattern is one of the following (given
    here is the base URL: [https://api.mongolab.com/api/1/databases](https://api.mongolab.com/api/1/databases)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`/<dbname>/collections/<name>?apiKey=<key>`: This has the following requests:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET`: This action gets all objects in the given collection name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: This action adds a new object to the collection name. MongoLab has
    an `_id` property that uniquely identifies the document (object). If not provided
    in the posted data, it is auto-generated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/<dbname>/collections/<name>/<id>?apiKey=<key>`: This has the following requests:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET`: This gets a specific document/collection item with a specific ID (a
    match done on the `_id` property) from the collection name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: This updates the specific item (`id`) in the collection name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: This deletes the item with a specific ID from the collection name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more details on the Data API interface, visit the MongoLab Data API documentation
    at [http://docs.mlab.com/data-api](http://docs.mlab.com/data-api).
  prefs: []
  type: TYPE_NORMAL
- en: Now we are in a position to start implementing exercise/workout list pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code that we are starting with in this chapter is `checkpoint 4.6` (folder:
    `trainer`) in the GitHub repository for this book. It is available on GitHub ([https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)).
    Checkpoints are implemented as branches in GitHub. If you are not using Git, download
    the snapshot of checkpoint 4.6 (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular6byexample/tree/checkpoint4.6](https://github.com/chandermani/angular6byexample/tree/checkpoint4.6).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  prefs: []
  type: TYPE_NORMAL
- en: Loading exercise and workout lists from a server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To pull exercise and workout lists from the MongoLab database, we have to rewrite
    our `WorkoutService` service methods: `getExercises` and `getWorkouts`. But before
    we can do that, we have to set up our service to work with Angular''s HTTPClient
    module.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the HTTPClient module and RxJS to our project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Angular HTTPClient module is included in the Angular bundles that you have
    already installed. To use it, we need to import it into `app.module.ts,` like
    so (make sure that the import follows `BrowserModule`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We also need an external third-party library: **Reactive Extensions for JavaScript**
    (**RxJS**). RxJS implements the Observable pattern and it is used by Angular with
    the HTTPClient module. It is included in the Angular bundles that are already
    part of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Updating workout-service to use the HTTPClient module and RxJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open  `workout.service.ts` from `trainer/src/app/core`. In order to use the
    HTTPClient and RxJS within the `WorkoutService`, we need to add the following
    imports to that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We are importing the `HTTPClient` module along with `Observable` from RxJS and
    one additional RxJS operator: `catchError`. We'll see how this operator is used
    as we work through the code in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the class definition, add the following properties, which include a workout
    property and ones that set the URL for the collections in our Mongo database and
    the key to that database as well as another property: `params`, which sets up
    the API key as a query string for API access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Replace the `<dbname>` and `<key>` tokens with the database name and API key
    of the database that we provisioned earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, inject the HTTPClient module into the `WorkoutServiceconstructor` using
    the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then change the `getExercises()` method to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you are used to working with promises for asynchronous data operations, what
    you see here will look different. Instead of a promise that has a call to `then()`
    chained to it, what happens here is that the `http.get` method returns an Observable from
    the RxJS library. Notice that we are also setting the response to be of type `<ExercisePlan>` to
    make explicit to our upstream callers what type of Observable is being returned
    from our HTTP GET call.
  prefs: []
  type: TYPE_NORMAL
- en: Returning an Observable is the default response when using the `HTTPClient`
    module's `get` method. The Observable can, however, be converted to a promise.
    And, as we will see later in this chapter, the option to return JSONP also exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, there is one more thing to touch upon in this code. Notice
    that we are using a pipe method to add a `catchError` operator. This operator
    accepts a method, `handleError`, for handling a failed response. The `handleError`
    method takes the failed response as a parameter. We log the error to the console
    and use `Observable.throw` to return the error to the consumer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To be clear, this is not production code, but it will give us the opportunity
    to show how to write code upstream to handle errors that are generated as part
    of data access.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that at this stage no data is flowing through
    the Observable until there is a subscription to it. This can bring about a gotcha
    moment for things such as adds and updates if you are not careful to add subscriptions
    to your Observables.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying getWorkouts() to use the HTTPClient module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The change in the code for retrieving workouts is almost identical to that
    for the exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Again we are specifying the type of Observable—in this case `<WorkoutPlan[]>`—that
    will be returned by our HTTP GET call and using `pipe` to add a `catchError` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the `getExercises` and `getWorkouts` methods are updated, we need to
    make sure that they work with the upstream callers.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the workout/exercise list pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The exercise and workout list pages (as well as `LeftNavExercises`) call either
    the `getExercises` or `getWorkouts` method in `model.ts`. In order to get these
    working with the remote calls that are now being made using the `HTTPClient` module,
    we need to modify those calls to subscribe to the Observable that is being returned
    by the `HTTPClient` module. So, update the code in the `ngOnInit` method in `exercises.component.ts`
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our method now subscribes to the Observable that is being returned by the `getExercises`
    method; at the point when the response arrives, it assigns the results to `exerciseList`.
    If there is an error, it assigns it to a `console.error` call that displays the
    error in the console. All of this is now being handled asynchronously using the
    `HTTPClient` module with RxJS.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and make similar changes to the `ngOnInit` methods in `workouts.component.ts`
    and `left-nav-exercises.component.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Refresh the workout/exercise list page and the workout and exercise data will
    be loaded from the database server.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the complete implementation in checkpoint 5.1 in the GitHub repository
    if you are having difficulty in retrieving/showing data. Note that in this checkpoint,
    we have disabled navigation links to the workout and exercise screens because
    we still have to add the Observable implementation to them. We'll do that in the
    next section. Also remember to replace the database name and API key before you
    run the code from `Checkpoint 5.1`. If you are not using Git, download the snapshot
    of `Checkpoint 5.1` (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular6byexample/tree/checkpoint5.1](https://github.com/chandermani/angular6byexample/tree/checkpoint5.1).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This looks good and the lists are loading fine. Well, almost! There is a small
    glitch in the workout list page. We can easily spot it if we look carefully at
    any list item (in fact, there is only one item):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4851c5e6-0779-4132-8184-519d877ee77f.png)'
  prefs: []
  type: TYPE_IMG
- en: The workout duration calculations are not working anymore! What could be the
    reason? We need to look back at how these calculations were implemented. The `WorkoutPlan`
    service (in `model.ts`) defines a `totalWorkoutDuration` method that does the
    math for this.
  prefs: []
  type: TYPE_NORMAL
- en: The difference is in the workout array that is bound to the view. In the previous
    chapter, we created the array with model objects that were created using the `WorkoutPlan`
    service. But now, since we are retrieving data from the server, we bind a simple
    array of JavaScript objects to the view, which for obvious reasons has no calculation
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: We can fix this problem by mapping a server response to our model class objects
    and returning them to any upstream caller.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping server data to application models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mapping server data to our model and vice versa may be unnecessary if the model
    and server storage definition match. If we look at the `Exercise` model class
    and the seed data that we have added for the exercise in MongoLab, we will see
    that they do match and hence mapping becomes unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mapping a server response to the model data becomes imperative if:'
  prefs: []
  type: TYPE_NORMAL
- en: Our model defines any methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stored model is different from its representation in code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same model class is used to represent data from different sources (this
    can happen for mashups, where we pull data from disparate sources)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `WorkoutPlan` service is a prime example of an impedance mismatch between
    a model representation and its storage. Look at the following screenshot to understand
    these differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/df31aa0c-237d-4043-afea-d2c9a6531a3b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The two major differences between the model and server data are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The model defines the `totalWorkoutDuration` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `exercises` array representation also differs. The `exercises` array of
    the model contains the full `Exercise` object, while the server data stores just
    the exercise identifier or name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This clearly means that loading and saving a workout requires model mapping.
  prefs: []
  type: TYPE_NORMAL
- en: The way we will do this is by adding another operator to transform the Observable
    response object. So far, we have only returned a plain JavaScript object as the
    response. The nice thing is that the pipe method that we used to add error handling
    also allows us to add additional operators that we can use to transform the JavaScript
    object into the `WorkoutPlan` type in our model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite the `getWorkouts` method in the `workout-service.ts` file to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have added a  `map` operator that transforms this Observable into one made
    up of `WorkoutPlan` objects. Each `WorkoutPlan` object (we have only one at the
    moment) will then have the `totalWorkoutDuration` method that we need.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the code you can see that we operate on the JSON results HTTPClient
    response, which is why we are using the `<any>` type. And then we create a typed
    array of `WorkoutPlans` and iterate through the first array using a fat arrow
    `forEach` function, assigning each JavaScript object to a `WorkoutPlan` object.
  prefs: []
  type: TYPE_NORMAL
- en: We return the results of these mappings to the callers that subscribe to them,
    `workouts.component.ts` in this case. We have also updated the `catchError` operator
    with a new `handleError` method which you can find in `Checkpoint 5.2`. The callers
    do not need to make any changes to the code they use to subscribe to our workouts
    Observable. Instead, the model mapping can take place at one spot in the application
    and then be used throughout it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you rerun the application, you will see that the total number of seconds
    now displays properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/93bf867c-e80e-46a1-baa0-d5abedd32142.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Checkpoint 5.2 in the GitHub repository contains the working implementation
    for what we have covered so far. The GitHub branch is `checkpoint5.2` (folder:
    `trainer`).'
  prefs: []
  type: TYPE_NORMAL
- en: Loading exercise and workout data from the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as we fixed the `getWorkouts` implementation in `WorkoutService` earlier,
    we can implement other get operations for exercise- and workout-related stuff.
    Copy the service implementation for the `getExercise` and `getWorkout` methods
    of `WorkoutService` from `workout.service.ts` in the `trainer/src/app/core` folder
    in checkpoint 5.2.
  prefs: []
  type: TYPE_NORMAL
- en: The `getWorkout` and `getExercise` methods use the name of the workout/exercise
    to retrieve results. Every MongoLab collection item has an `_id` property that
    uniquely identifies the item/entity. In the case of our `Exercise` and `WorkoutPlan`
    objects, we use the name of the exercise for unique identification. Hence, the
    `name` and `_id` property of each object always match.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we will need to add one more import to `workout.service.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This import brings in the `forkJoin` operator, which we will be discussing shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay special attention to the implementation of the `getWorkout` method because
    there is a decent amount of data transformation happening due to the model and
    data storage format mismatch. This is how the `getWorkout` method now looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There is a lot happening inside `getWorkout` that we need to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getWorkout` method uses Observable and its `forkJoin` operator to return
    two Observable objects: one that retrieves the `Workout` and another that retrieves
    a list of all the `Exercises`. What is interesting about the `forkJoin` operator
    is that not only does it allow us to return multiple Observable streams, but it
    also waits until both Observable streams have retrieved their data before further
    processing the results. In other words, it enables us to stream the responses
    from multiple concurrent HTTP requests and then operate on the combined results.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the `Workout` details and the complete list of exercises, we then
    `pipe` the results to the `map` operator (which we saw previously with the code
    for the `Workouts` list), which we use to change the `exercises` array of the
    workout to the correct `Exercise` class object. We do this by searching the `allExercises`
    Observable for the name of the exercise in the `workout.exercises` array returned
    from the server, and then assigning the matching exercise to the workout services
    array. The end result is that we have a complete `WorkoutPlan` object with the
    `exercises` array set up correctly.
  prefs: []
  type: TYPE_NORMAL
- en: These `WorkoutService` changes warrant fixes in upstream callers too. We have
    already fixed the lists of exercises in the `LeftNavExercises` and `Exercises`
    components and the workouts in the `Workouts` component. Now let's fix the `Workout`
    and `Exercise` components along similar lines. The `getWorkout` and `getExercise`
    methods in the workout services are not directly called by these components, but
    by builder services. So we'll have to fix the builder services together with the
    `Workout` and `Exercise` components and the two resolvers—`WorkoutResolver` and
    `ExerciseResolver`—that we have added to the routes for these components.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the builder services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have `WorkoutService` set up to retrieve a workout from our remote
    data store, we have to modify `WorkoutBuilderService` to be able to retrieve that
    workout as an Observable. The method that pulls the `Workout` details is `startBuilding`.
    In order to do that, we will break the current `startBuilding` method into two
    methods, one for new workouts and one for existing workouts that we have retrieved
    from the server. Here is the code for new workouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For existing workouts, we add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We'll let you make the same fixes in `ExerciseBuilderService`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the resolvers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we move on to using Observable types with our data access, we are going to
    have to make some adjustments to the resolvers that we have created for the routes
    leading to workout and exercise screens. We start with the `WorkoutResolver` in
    `workout-resolver.ts` that can be found in the `workout` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the following imports from RxJs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next update the `resolve` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have split out the behavior for a new workout (one where
    there is no workout name being passed as a parameter in the URL) and that for
    an existing workout. In the former case, we call `workoutBuilderService.startBuildingExisting`,
    which will return a new `WorkoutPlan`. In the latter case, we call `workoutBuilderService.startBuildingExisting` and pipe
    the results and then map them to return the `workout` unless it is not found,
    in which case we route the user back to the `Workouts` screen.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the Workout and Exercise components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have fixed the `WorkoutBuilderService` and the `WorkoutResolver`, there
    are actually no further fixes needed in the `WorkoutComponent`. All the work to
    handle the Observables has been done further downstream and all we need to do
    at this stage is subscribe to the route data and retrieve the workout as we have
    already been doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the implementation, uncomment the following highlighted code contained
    in the `onSelect` method within `workouts.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Then click on any existing workout, such as *7 Minute Workout*, from the list
    of workouts displayed at `/builder/workouts/`. The workout data should load successfully.
  prefs: []
  type: TYPE_NORMAL
- en: The `ExerciseBuilderService` and `ExerciseResolver` also need fixing. `Checkpoint
    5.2` contains those fixes. You can copy those files or do it yourself and compare
    the implementation. And don't forget to uncomment the code in the `onSelect` method
    in `exercises.component.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Checkpoint 5.2` in the GitHub repository contains the working implementation
    for what we have covered thus far. If you are not using Git, download the snapshot
    of Checkpoint 5.2 (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular6byexample/tree/checkpoint5.2](https://github.com/chandermani/angular6byexample/tree/checkpoint5.2).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  prefs: []
  type: TYPE_NORMAL
- en: It is now time to fix, create, and update scenarios for the exercises and workouts.
  prefs: []
  type: TYPE_NORMAL
- en: Performing CRUD on exercises/workouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to create, read, update, and delete (CRUD) operations, all save,
    update, and delete methods need to be converted to the Observable pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in the chapter, we detailed the endpoint access pattern for CRUD operations
    in a MongoLab collection. Head back to the *Loading exercise and workout data* section
    and revisit the access patterns. We need this now as we plan to create/update
    workouts.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start the implementation, it is important to understand how MongoLab
    identifies a collection item and what our ID generation strategy is. Each collection
    item in MongoDB is uniquely identified in the collection using the `_id` property.
    While creating a new item, either we supply an ID or the server generates one
    itself. Once `_id` is set, it cannot be changed. For our model, we will use the
    `name` property of the exercise/workout as the unique ID and copy the name into
    the `_id` field (hence, there is no autogeneration of `_id`). Also, remember that
    our model classes do not contain this `_id` field; it has to be created before
    saving the record for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Let's fix the workout creation scenario first.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new workout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Taking the bottom-up approach, the first thing that needs to be fixed is `WorkoutService`.
    Update the `addWorkout` method as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In `getWorkout`, we had to map data from the server model to our client model;
    the reverse has to be done here. First, we create a new array for the exercises,
    `workoutExercises`, and then add to that array a version of the exercises that
    is more compact for server storage. We only want to store the exercise name and
    duration in the exercises array on the server (this array is of type `any` because
    in its compact format it does not conform to the `ExercisePlan` type).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set up the body of our post by mapping these changes into a JSON object.
    Note that as part of constructing this object, we set the `_id` property as the
    name of the workout to uniquely identify it in the database of the workouts collection.
  prefs: []
  type: TYPE_NORMAL
- en: The simplistic approach of using the *name* of the workout/exercise as a record
    identifier (or `id`) in MongoDB will break for any decent-sized app. Remember
    that we are creating a web-based application that can be accessed simultaneously
    by many users. Since there is always the possibility of two users coming up with
    the same name for a workout/exercise, we need a strong mechanism to make sure
    that names are not duplicated. Another problem with the MongoLab REST API is that
    if there is a duplicate `POST` request with the same `id` field, one will create
    a new document and the second will update it, instead of the second failing. This
    implies that any duplicate checks on the `id` field on the client side still cannot
    safeguard against data loss. In such a scenario, assigning auto generation of
    the `id` value is preferable. In standard cases where we are creating entities,
    unique ID generation is done on the server (mostly by the database). The response
    to when an entity is created then contains the generated ID. In such a case, we
    need to update the model object before we return data to the calling code.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we call the `post` method of the `HTTPClient` module, passing the URL
    to connect to, an extra query string parameter (`apiKey`), and the data we are
    sending.
  prefs: []
  type: TYPE_NORMAL
- en: The last return statement should look familiar, as we use Observables to return
    the workout object as part of the Observable resolution. You need to be sure you add
    `.subscribe` to the Observable chain in order to make it work. We'll do that shortly
    by adding a subscription to the `save` method to `WorkoutComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a workout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Why not try to implement the update operation? The `updateWorkout` method can
    be fixed in the same manner, the only difference being that the `HTTPClient` module''s
    `put` method is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding request URL now contains an extra fragment (`workout.name`) that
    denotes the identifier of the collection item that needs to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: The MongoLab `PUT` API request creates the document passed in as the request
    body if the document is not found in the collection. While making the `PUT` request,
    make sure that the original record exists. We can do this by making a `GET` request
    for the same document first and confirming that we get a document before we update
    it. We'll leave that for you to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a workout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last operation that needs to be fixed is deleting the workout. Here is
    a simple implementation where we call the `HTTPClient` module''s `delete` method
    to delete the workout referenced by a specific URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Fixing the upstream code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With that, it''s now time to fix the `WorkoutBuilderService` and `Workout`
    components. The `save` method of `WorkoutBuilderService` now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Most of it looks the same as it was earlier because it is the same! We did not
    have to update this code because we effectively isolated the interaction with
    the external server in our `WorkoutService` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the save code for the `Workout` component is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here we have made a change so that we now subscribe to the save. As you may
    recall from our previous discussions, `subscribe` makes an Observable live so
    that we can complete the save.
  prefs: []
  type: TYPE_NORMAL
- en: And that's it! We can now create new workouts and update existing workouts (we'll
    leave completion of deleting workouts to you). That was not too difficult!
  prefs: []
  type: TYPE_NORMAL
- en: Let's try it out. Open the new `Workout Builder` page, create a workout, and
    save it. Also try to edit an existing workout. Both scenarios should work seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Check out `checkpoint 5.3` for an up-to-date implementation if you are having
    issues running your local copy. If you are not using Git, download the snapshot
    of Checkpoint 5.3 (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular6byexample/tree/checkpoint5.3](https://github.com/chandermani/angular2byexample/tree/checkpoint5.3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Something interesting happens on the network side while we make `POST` or `PUT`
    requests save data. Open the browser''s network log console (*F12*) and see the
    requests being made. The log looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/fb3766cd-7ab6-48bf-a59c-d80192bca5e8.png)The network log'
  prefs: []
  type: TYPE_NORMAL
- en: An `OPTIONS` request is made to the same endpoint before the actual `POST` or `PUT` is
    done. The behavior that we witness here is termed as a **prefight request**. This
    happens because we are making a cross-domain request to `api.mongolab.com`.
  prefs: []
  type: TYPE_NORMAL
- en: Using promises for HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bulk of this chapter has focused on how the Angular `HTTPClient` uses Observables
    as the default for `XMLHttpRequests`. This represents a significant change from
    the way things used to work. Many developers are familiar with using promises
    for asynchronous HTTP requests. With that being the case, Angular continues to
    support promises, but just not as the default choice. A developer has to opt for
    promises in an `XMLHttpRequest` in order to be able to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to use promises with the `getExercises` method in `WorkoutService`,
    we will have to restructure the command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In order to convert this method to use promises, all we have to do is add `.toPromise()`
    to the method chain, a success parameter, `then`, for the promise, and  `catch`
    with a `Promise.reject` pointing to the existing `handleError` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For upstream components, we just have to switch to handling the return value
    as a promise rather than an Observable. So, to use promises in this case, we would
    have to change the code in `Exercises.component.ts` and `LeftNavExercises.component.ts`
    to first add a new property for the error message (we''ll leave it to you as to
    how the error message is displayed on the screen):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then change the `ngOnInit` method that is calling `WorkoutService` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the ease with which we can substitute promises for Observables in
    this simple example does not indicate that they are essentially the same. A `then`
    promise returns another promise, which means that you can create successively
    chained promises. In the case of an Observable, a subscription is essentially
    the end of the line and cannot be mapped or subscribed to beyond that point.
  prefs: []
  type: TYPE_NORMAL
- en: If you're familiar with promises, it may be tempting at this stage to stick
    with them and not give Observables a try. After all, much of what we have done
    with Observables in this chapter can be done with promises as well. For example,
    the mapping of two streams of Observables that we did with `getWorkouts` using
    the Observable's `forkJoin` operator can also be done with the promise's `q,all`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: However, you would be selling yourself short if you took that approach. Observables
    open up an exciting new way of doing web development using what is called functional
    reactive programming. They involve a fundamental shift in thinking that treats
    an application's data as a constant stream of information to which the application
    reacts and responds. This shift allows applications to be built with a different
    architecture that makes them faster and more resilient. Observables are at the
    core of Angular in such things as event emitters and the new version of `NgModel`.
  prefs: []
  type: TYPE_NORMAL
- en: While promises are a useful tool to have in your toolkit, we encourage you to
    investigate Observables as you get into developing with Angular. They are part
    of the forward-looking philosophy of Angular and will be useful in future-proofing
    both your applications and your skill set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the `checkpoint 5.3` file for an up-to-date implementation that includes
    the promises-related code that we covered previously. If you are not using Git,
    download the snapshot of Checkpoint 5.3 (a ZIP file) from the following GitHub
    location: [https://github.com/chandermani/angular6byexample/tree/checkpoint5.3](https://github.com/chandermani/angular6byexample/tree/checkpoint5.3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Be aware that in the next section, we will be reverting to
    the use of Observables for this code. This code can be found in the `checkpoint
    5.4` file.'
  prefs: []
  type: TYPE_NORMAL
- en: The async pipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen with many of the data operations covered in this chapter, there
    is a fairly common pattern being repeated over and over again. When an Observable
    is returned from an HTTP request, we convert the response to JSON and subscribe
    to it. The subscription then binds the Observable output to a UI element. Wouldn't
    it be nice if we could eliminate this repetitive coding and replace it with a
    simpler way to accomplish what we are wanting to do?
  prefs: []
  type: TYPE_NORMAL
- en: Not surprisingly, Angular provides us with just the right way to do that. It's
    called the **async pipe**, and it can be used like any other pipe for binding
    to an element on the screen. However, the async pipe is a much more powerful mechanism
    than other pipes. It takes an Observable or a promise as an input and subscribes
    to it automatically. It also handles the teardown of the subscription for an Observable
    without necessitating any further lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example of this in our application. Let's go back to the `LeftNavExercises`
    component that we were just looking at in the previous section in connection with
    promises. Note that we have converted this component and the `Exercises` component
    from promises back to using Observables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the `checkpoint 5.4` file for an up-to-date implementation that includes
    the conversion of this code to use Observables once again. If you are not using
    Git, download the snapshot of Checkpoint 5.4 (a ZIP file) from the following GitHub
    location: [https://github.com/chandermani/angular6byexample/tree/checkpoint5.4](https://github.com/chandermani/angular6byexample/tree/checkpoint5.4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then make the following changes in `LeftNavExercises`. First, import Observable
    from RxJs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then change `exerciseList` from an array of exercises to an Observable of the
    same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next modify the call to `WorkoutService` that gets the exercises to eliminate
    the subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, open `left-nav-exercises.component.html` and add the `async` pipe
    to the `*ngFor` loop, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Refresh the page and you will still see the Exercise list displaying. But this
    time, we have used the `async` pipe to eliminate the need to set up the subscription
    to the Observable. Pretty cool! This is a nice convenience that Angular has added,
    and since we have been spending time in this chapter understanding how Observables
    work with subscriptions, we have a clear idea of what the `async` pipe is now
    handling for us under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: We'll leave it to you to implement the same change in the `Exercises` component.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand the cross-domain behavior of the HTTP request
    and the constructs that Angular provides to make cross-domain requests.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-domain access and Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cross-domain requests are requests made for resources in a different domain.
    Such requests, when originated from JavaScript, have some restrictions imposed
    by the browser; these are called *same-origin policy* restrictions. Such a restriction
    stops the browser from making AJAX requests to domains that are different from
    the script's original source. The source match is done strictly based on a combination
    of protocol, host, and port.
  prefs: []
  type: TYPE_NORMAL
- en: For our own app, the calls to `https://api.mongolab.com` are cross-domain invocations
    as our source code hosting is in a different domain (most probably, something
    like `http://localhost/....`).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some workarounds and some standards that help relax/control cross-domain
    access. We will be exploring two of these techniques as they are the most commonly
    used ones. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JSON with Padding** (**JSONP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-Origin Resource Sharing** (**CORS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A common way to circumvent this same-origin policy is to use the JSONP technique.
  prefs: []
  type: TYPE_NORMAL
- en: Using JSONP to make cross-domain requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JSONP mechanism of remote invocation relies on the fact that browsers can
    execute JavaScript files from any domain irrespective of the source of origin
    as long as the script is included via the `<script>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: In JSONP, instead of making a direct request to a server, a dynamic `<script>`
    tag is generated, with the `src` attribute set to the server endpoint that needs
    to be invoked. This `<script>` tag, when appended to the browser's DOM, causes
    a request to be made to the target server.
  prefs: []
  type: TYPE_NORMAL
- en: The server then needs to send a response in a specific format, wrapping the
    response content inside a function invocation code (this extra padding around
    the response data gives this technique the name JSONP).
  prefs: []
  type: TYPE_NORMAL
- en: The Angular JSONP service hides this complexity and provides an easy API to
    make JSONP requests. The StackBlitz link, [https://stackblitz.com/edit/angular-nxeuxo](https://stackblitz.com/edit/angular-nxeuxo),
    highlights how JSONP requests are made. It uses the *IEX Free Stock API* ([https://iextrading.com/developer/](https://iextrading.com/developer/))
    to get quotes for any stock symbol.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular JSONP service only supports HTTP `GET` requests. Using any other
    HTTP request, such as `POST` or `PUT`, will generate an error.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the StackBlitz project, you will see the familiar pattern for
    component creation that we have followed throughout this book. We will not go
    over this pattern again, but will highlight a few details that are relevant to
    using the Angular JSONP service.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, along with the imports for `FormsModule` and `HttpClientModule`, you
    will need to import `HttpClientJsonpModule` into `app.module.ts` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add the following imports to `get-quote.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We are importing `HttpClient`, which contains the `JSONP` methods we will be
    using, as well as the RxJS `Observable` and the `map ` operator. These imports
    will look familiar to you from what we have been building in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: As you work with Angular JSONP, it is important to understand that by default,
    it returns Observables using RxJS. This means that we will have to follow the
    pattern for subscribing to those Observables and use the RxJS operators to manipulate
    the results. We can also use the async pipe to streamline these operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we inject `HttpClient` into the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we add several variables that we will be using in our JSONP call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `symbol` variable will hold the search string provided by the user. The
    `quote` variable will be used in our template to display the returned value from
    the JSONP call. And the `url` variable is the base URL for the call we will be
    making to the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have everything in place for our `getQuote` method. Let''s take a look
    at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We first construct our `searchUrl` by concatenating the `url` with the `symbol`
    and adding `/quote`. The last part `quote` is what we need to pass to the quote
    service to return a stock quote.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the HTTPClient's `jsonp` method to execute the remote call to the
    quote service. We pass the `searchUrl` as the first parameter of that method and
    a string `'callback'` as our second parameter. The latter parameter is used by
    Angular to augment the `searchUrl` with an extra query string parameter, `callback`.
    Internally, the Angular JSONP service then generates a dynamic `script` tag and
    a callback function and makes the remote request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open StackBlitz and enter symbols such as `GOOG`, `MSFT`, or `FB` to see the
    stock quote service in action. The browser network log for requests looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `ng_jsonp_callback_0` is the dynamically generated function. And the
    response looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The response is wrapped in the callback function. Angular parses and evaluates
    this response, which results in the invocation of the `__ng_jsonp__.__req1` callback
    function. Then, this function internally routes the data to our function callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'We hope this explains how JSONP works and what the underlying mechanism of
    a JSONP request is. However, JSONP has its limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we can make only `GET` requests (which is obvious as these requests originate
    due to script tags)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, the server also needs to implement the part of the solution that involves
    wrapping the response in a function callback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third, there is always a security risk involved, as JSONP depends on dynamic
    script generation and injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fourth, error handling is not reliable too because it is not easy to determine
    why a script load failed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ultimately, we must recognize that JSONP is more of a workaround than a solution.
    As we move towards Web 2.0, where mashups become commonplace and more and more
    service providers decide to expose their API over the web, a far better solution/standard
    has emerged: CORS.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-origin resource sharing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-origin Resource Sharing** (**CORS**) provides a mechanism for the web
    server to support cross-site access control, allowing browsers to make cross-domain
    requests from scripts. With this standard, a consumer application (such as *Personal
    Trainer*) is allowed to make some types of requests, termed **simple requests**,
    without any special setup requirements. These simple requests are limited to `GET`,
    `POST` (with specific MIME types), and `HEAD`. All other types of requests are
    termed **complex requests**.'
  prefs: []
  type: TYPE_NORMAL
- en: For complex requests, CORS mandates that the request should be preceded by an
    HTTP `OPTIONS` request (also called a preflight request) that queries the server
    for HTTP methods allowed for cross-domain requests. And only on successful probing
    is the actual request made.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about CORS from the MDN documentation available at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS).
  prefs: []
  type: TYPE_NORMAL
- en: The best part about CORS is that the client does not have to make any adjustment
    as in the case of JSONP. The complete handshake mechanism is transparent to the
    calling code and our Angular `HTTPClient` calls work without a hitch.
  prefs: []
  type: TYPE_NORMAL
- en: CORS requires configurations to be made on the server, and the MongoLab servers
    have already been configured to allow cross-domain requests. So the preceding
    `POST` and `PUT` requests that we made to the MongoLab to add and update `Exercise`
    and `Workout` documents all caused the preflight `OPTIONS` request.
  prefs: []
  type: TYPE_NORMAL
- en: Handling workouts not found
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might recall that in [Chapter 2](4b0ad450-2a56-4c24-b431-116d7225a57e.xhtml),
    *Personal Trainer*, we created the `WorkoutResolver` to not only retrieve a workout
    prior to navigation to the `WorkoutComponent`, but also prevent navigation to
    that component if a non-existent workout was in the route parameters. Now we would
    like to augment this functionality by displaying an error message on the workouts
    screen, indicating that the workout was not found.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we are going to modify `WorkoutResolver` so that it reroutes
    to the workouts screen if a workout is not found. To start, add the following
    child route to `WorkoutBuilderRoutingModule` (making sure it precedes the existing
    workouts route):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, modify the `resolve` method in the `WorkoutResolver` to redirect to this
    route in the event that a workout is not found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add a `notFound` boolean set to `false` to the variables in the `Workouts`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And, in the `ngOnInit` method of that component, add the following code to
    check for the `workout-not-found` path and set the `notFound` value to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally in the `Workouts.component.html` template, add the following `div`
    tag above the workout list that will display if the `notFound` is set to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If we find `workout-not-found` in the path when a user is returned to the `Workouts`
    page, then this displays the following message on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/fd1d8b39-7c56-46a0-9965-55fa568c53c4.png)'
  prefs: []
  type: TYPE_IMG
- en: We have fixed routing failure for the Workout Builder page, but the exercise
    builder page is still pending. Again, we will leave it to you to fix it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Another major (and pending) implementation is fixing *7 Minute Workout*, as
    it currently caters to only one workout routine.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the 7 Minute Workout app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As it stands now, the *7 Minute Workout* (or *Workout Runner*) app can play
    only one specific workout. It needs to be fixed to support the execution of any
    workout plan built using *Personal Trainer*. There is an obvious need to integrate
    these two solutions. We already have the groundwork done to commence this integration.
    We've got the shared model services and `WorkoutService` to load data, enough
    to get us started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixing *7 Minute Workout* and converting it into a generic *Workout Runner*
    roughly involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing the hardcoded workout and exercises used in *7 Minute Workout*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixing the start page to show all available workouts and allowing users to select
    a workout to run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixing the workout route configuration to pass the selected workout name as
    the route parameter to the workout page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading the selected workout data using `WorkoutService` and starting the workout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, of course, we need to rename the *7 Minute Workout* part of the app; the
    name is now a misnomer. I think the complete app can be called *Personal Trainer*.
    We can remove all references to *7 Minute Workout* from the view as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An excellent exercise to try out yourself! And that is why we are not going
    to walk you through the solution. Instead, go ahead and implement the solution.
    Compare your implementation with the one available at `checkpoint 5.4`.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to end the chapter and summarize your learning.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have an app that can do a lot of stuff. It can run workouts, load workouts,
    save and update them, and track history. And if we look back, we have achieved
    this with minimal code. We bet that if we were to try this in standard jQuery
    or some other framework, it would require substantially more effort as compared
    to Angular.
  prefs: []
  type: TYPE_NORMAL
- en: We started the chapter by providing a *MongoDB* database on *MongoLab* servers.
    Since MongoLab provided a RESTful API to access the database, we saved some time
    by not setting up our own server infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: The first Angular construct that we touched upon was the `HTTPClient`, which
    is the primary service for connecting to any HTTP backend.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how the `HTTPClient` module uses Observables. For the first
    time, in this chapter, we created our own Observable and explained how to create
    subscriptions to those Observables.
  prefs: []
  type: TYPE_NORMAL
- en: We fixed our *Personal Trainer* app so that it uses the `HTTPClient` module
    to load and save workout data (note that data persistence for exercises is left
    for you to complete). In the process, you also learned about issues surrounding
    cross-domain resource access. You learned about JSONP, a workaround to circumvent
    a browser's *same-origin* restrictions, and how to issue JSONP requests using
    Angular. We also touched upon CORS, which has emerged as a standard when it comes
    to cross-domain communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now covered most of the building blocks of Angular, except the big
    one: Angular directives. We have used directives everywhere, but have not created
    one. The next chapter is exclusively dedicated to Angular directives. We will
    be creating a number of small directives, such as a remote validator, AJAX button,
    and a validation cues directive for the *Workout Builder* app.'
  prefs: []
  type: TYPE_NORMAL

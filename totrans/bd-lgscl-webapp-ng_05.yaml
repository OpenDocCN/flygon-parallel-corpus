- en: 1.21 Gigawatt - Flux Pattern Explained
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.21吉瓦特 - Flux模式解释
- en: Your application has grown and in that process, you slowly feel you are losing
    track of what your application knows at a given point, what we call the state
    of the application. There might be other issues, such as parts of your application
    not being in agreement with what they know. An update that happened in one part
    may not have been applied to some other part and you scratch your head, thinking
    should it be this hard and is there a better answer?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序已经发展壮大，在这个过程中，你慢慢感到你正在失去对应用程序在某一点知道的东西的掌握，我们称之为应用程序的状态。可能还有其他问题，比如你的应用程序的某些部分与它们所知道的不一致。在一个部分发生的更新可能没有应用到其他部分，你想了想，想知道这是否应该这么难，是否有更好的答案？
- en: It's entirely possible you are just picking up this book as you have heard about
    NgRx as the way to structure your application and you are curious and want to
    know more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你完全有可能只是因为听说过NgRx作为构建应用程序的方式而拿起这本书，你很好奇，想了解更多。
- en: 'Let''s first explain our title. What do we mean by 1.21 Gigawatt? I''m going
    to quote the character Doc Brown from the movie *Back to the Future* ([http://www.imdb.com/name/nm0000502/?ref_=tt_trv_qu](http://www.imdb.com/name/nm0000502/?ref_=tt_trv_qu)):'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先解释一下我们的标题。我们所说的1.21吉瓦特是什么意思？我要引用电影《回到未来》中的角色Doc Brown（[http://www.imdb.com/name/nm0000502/?ref_=tt_trv_qu](http://www.imdb.com/name/nm0000502/?ref_=tt_trv_qu)）：
- en: '"Marty, I''m sorry, but the only power source capable of generating 1.21 gigawatts
    of electricity is a bolt of lightning."'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: “马蒂，我很抱歉，但唯一能够产生1.21吉瓦特电力的能源就是一道闪电。”
- en: 'Why are we talking about the movie Back to the Future? This is where the name
    Flux comes from. It''s time for another quote from the same movie:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要谈论电影《回到未来》？这就是Flux这个名字的来源。现在是时候引用同一部电影中的另一句话了。
- en: '"Yes! Of course! November 5, 1955! That was the day I invented time-travel.
    I remember it vividly. I was standing on the edge of my toilet hanging a clock,
    the porcelain was wet, I slipped, hit my head on the sink, and when I came to
    I had a revelation! A vision! A picture in my head! A picture of this! This is
    what makes time travel possible: the **flux** capacitor!"'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: “是的！当然！1955年11月5日！那天我发明了时间旅行。我记得很清楚。我站在马桶边挂钟，瓷器是湿的，我滑倒了，撞到了水池，当我醒来时，我有了一个启示！一个愿景！我脑海中有一个画面！这个画面！这就是使时间旅行成为可能的东西：**通量**电容器！”
- en: So as you can see, there is an explanation for the name Flux. It obviously allows
    us to travel in time. At least for Redux, which we will write about later in this
    book, time travel is possible through something called time-travel debugging.
    Whether that needs a bolt of lightning is for you to find out dear reader.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以看到，Flux这个名字是有解释的。显然它允许我们在时间中旅行。至少对于Redux来说，我们将在本书中后面写到，通过一种叫做时间旅行调试的东西，时间旅行是可能的。是否需要一道闪电，就由你亲爱的读者来发现了。
- en: Flux is an architectural pattern created by Facebook. It came about as it was
    perceived that the MVC pattern simply did not scale. It did not scale for large
    code bases as they tended to become fragile, generally complicated as more and
    more features were added, and most of all, unpredictable. Now let's hang on that
    word for a second, unpredictable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Flux是Facebook创建的一种架构模式。它出现是因为人们认为MVC模式根本无法扩展。随着越来越多的功能被添加，大型代码库变得脆弱、复杂，并且最重要的是，不可预测。现在让我们停留在那个词上，不可预测。
- en: 'Large systems were thought to become unpredictable due to their bidirectional
    data flow between models and views when the number of models and views really
    grew, as depicted in the following diagram:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大型系统被认为变得不可预测，因为模型和视图之间的双向数据流在模型和视图的数量真正增长时，如下图所示：
- en: '![](Images/cd476946-b1c8-428f-a290-4d626e5b0794.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/cd476946-b1c8-428f-a290-4d626e5b0794.png)'
- en: Here, we can see that the number of models and views is starting to grow. Everything
    is somewhat under control as long as one model talks to one view and vice versa.
    This is, however, seldom the case. In the preceding diagram, we see that suddenly
    a view can talk to more than one model and vice versa, which means we have a cascading
    effect on the system and we suddenly lose control. Sure, it doesn't look so bad
    with just one deviating arrow, but imagine that this one is suddenly ten arrows,
    then we have a real problem on our hands.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: It is the very fact that we allow bidrectional data flows to happen that things
    get complicated and we lose predictability. The medicine or cure for that is thought
    to be a simpler type of data flow, a unidirectional flow. Now, there are some
    key players involved in enabling undirectional data flow, which brings us to what
    this chapter is meant to teach us.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: What an action and an action creator are
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the dispatcher plays a central role in your application as a hub for messages
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State management with a store
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to put our knowledge of Flux into practice by coding up a Flux application
    flow
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core concepts overview
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the core of the Flux pattern is a unidirectional data flow. It uses some
    core concepts to achieve this flow. The main idea is when an event is created
    on a UI, through the interaction of a user, an action is created. This action
    consists of an intent and a payload. The intent is what you are trying to achieve.
    Think of the intent as a verb. Add an item, remove an item, and so on. The payload
    is the data change that needs to happen to achieve our intent. If we are trying
    to add an item, then the payload is the newly created item. The action is then
    propagated in the flow with the help of a dispatcher. The action and its data
    eventually end up in a store.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'The concepts that make up the Flux pattern are:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Action and action creators, where we set up an intention and a payload of data
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dispatcher, our spider in the web that is able to send messages left and
    right
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The store, our central place for state and state management
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these together form the Flux pattern and promote unidirectional data flow.
    Consider the following diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/89837a9b-d48e-4a33-890c-c61bd5a326d6.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: 'What is depicted here is an undirectional data flow. The data flows from **View**
    to **Action**, from **Action** to **Dispatcher**, from **Dispatcher** to **Store**.
    There are two possible ways that the flow is triggered:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的是一个单向数据流。数据从**视图**流向**行动**，从**行动**流向**分发器**，从**分发器**流向**存储**。触发流动的方式有两种：
- en: The application is loaded a first time, in which the data is pulled from the
    **Store** to populate the view.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序首次加载时，从**存储**中提取数据以填充视图。
- en: A user interaction happens in the view that leads to an intent to change something.
    The intent is encapsulated in an **Action**, and thereafter sent to the **Store**,
    via the **Dispatcher**. At the **Store**, it may be persisted in a database, through
    an **API** or saved as an application state, or both.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图中发生用户交互，导致意图改变。意图封装在**行动**中，然后通过**分发器**发送到**存储**。在**存储**中，它可以通过**API**持久化到数据库，或保存为应用程序状态，或两者兼而有之。
- en: Let's dive into each concept in more detail, together with highlighting some code
    examples, in the upcoming sections.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的部分中更详细地探讨每个概念，并突出一些代码示例。
- en: A uniform data flow
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一的数据流
- en: 'Let''s introduce all parties involved in our uniform data flow by starting
    from the very top and slowly work our way down, concept by concept. We will build
    an application consisting of two views. In the first view, the user will select
    an item from a list. This should result in an action being created. This action
    will then be dispatched, by the dispatcher. The action and its payload will end
    up in a store. The other view meanwhile listens to changes from the store. When
    an item is selected, the second view will be made aware and can, therefore, indicate
    in its UI that a specific item has been selected. On a high level, our application
    and its flow will look like the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最顶层开始，逐个概念地介绍参与我们统一数据流的所有方。我们将构建一个包含两个视图的应用程序。在第一个视图中，用户将从列表中选择一个项目。这应该导致创建一个行动。然后，这个行动将由分发器分发。行动及其有效负载最终将进入存储。与此同时，另一个视图会监听存储的变化。当选择一个项目时，第二个视图将得到通知，因此可以在其UI中指示特定项目已被选择。在高层次上，我们的应用程序及其流程将如下所示：
- en: '![](Images/13f7b397-8882-49b9-a11a-63fa225bc683.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/13f7b397-8882-49b9-a11a-63fa225bc683.png)'
- en: Action – capture the intent
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动 - 捕捉意图
- en: An action is something as simple as an intent with accompanying data, that is,
    a message. How does an action come about though? An action comes about when a
    user interacts with a UI. The user may select a specific item in a list or a press
    a button with the intention of submitting a form. Submitting the form should,
    in turn, lead to a product being created.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 行动是一件简单的事情，就像一个带有附加数据的意图，也就是一条消息。但是，行动是如何产生的呢？当用户与UI交互时，行动就产生了。用户可以从列表中选择特定的项目，或者按下一个按钮，意图是提交一个表单。提交表单应该导致创建一个产品。
- en: 'Let''s look at two different actions:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两种不同的行动：
- en: Selecting an item in a list, here we are interested in saving the index of our
    selected item
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表中选择一个项目，我们对保存所选项目的索引感兴趣
- en: Saving a todo to a todo list
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将待办事项保存到待办事项列表
- en: 'An action is represented by an object. The object has two properties of interest:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个行动由一个对象表示。该对象有两个感兴趣的属性：
- en: 'The type: This is a unique string that tells us the intention of the action,
    for example, `SELECT_ITEM`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型：这是一个唯一的字符串，告诉我们行动的意图，例如，`SELECT_ITEM`
- en: 'The data: This is the data we mean to persist, for example, the numerical index
    of a selected item'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据：这是我们打算持久化的数据，例如，所选项目的数字索引
- en: 'Given our first example action, a code representation of that action would
    look like the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们的第一个示例行动，该行动的代码表示将如下所示：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: OK, so we have prepared our action, which we can also think of as a message.
    We want the message to be sent so that the selected item is highlighted in the
    UI. As this is a undirectional flow, we need to follow a charted course and pass
    our message over to the next party, which is the dispatcher.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经准备好了我们的动作，我们也可以将其视为一条消息。我们希望发送消息，以便在UI中突出显示所选项目。由于这是一个单向流，我们需要遵循一个规划好的路线，并将我们的消息传递给下一个参与者，即调度员。
- en: Dispatcher – the spider in the web
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度员 - 网络中的蜘蛛
- en: 'Think of the dispatcher as the spider in the web that handles messages being
    passed to it.  You can also think of the dispatcher as a mailman who promises
    that your message will reach its target destination. A dispatcher lives, for one
    thing, to dispatch messages to anyone who will listen. There is usually just one
    `dispatcher` in a Flux architecture and a typical usage looks something like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将调度员视为处理传递给它的消息的网络中的蜘蛛。你也可以把调度员看作是一个邮递员，承诺你的消息将到达目标地点。调度员的存在，一方面是为了向任何愿意听的人发送消息。在Flux架构中通常只有一个`dispatcher`，典型的用法看起来像这样：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Listening to the dispatcher
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 听调度员
- en: 'We have established that the dispatcher dispatches a message to anyone who
    will listen. Now it is time to be that listener. The dispatcher needs a `register`
    or `subscribe` method so that you, who listens, have the ability to listen for
    incoming messages. The setup for that usually looks something like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了调度员向任何愿意听的人发送消息。现在是时候成为那个听众了。调度员需要一个`register`或`subscribe`方法，这样你作为听众就有能力监听传入的消息。通常的设置看起来像这样：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, when you set up a listener this way, it will have the capability to listen
    to any message type being sent. You want to narrow this down; usually, a listener
    is specified to only handle a few message types around a certain theme. Your listener
    most likely looks something like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你这样设置一个监听器时，它将有能力监听被发送的任何消息类型。你想要缩小范围；通常，监听器被指定为只处理某个主题周围的几种消息类型。你的监听器很可能看起来像这样：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'OK, so we are able to filter out only the message types we care about, but
    before actually filling in some code we need to think about who this listener
    is. The answer is simple: it is the store.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们能够筛选出我们关心的消息类型，但在填写一些代码之前，我们需要考虑一下这个听众是谁。答案很简单：就是商店。
- en: The store – managing state, data retrieval, and callbacks
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 商店 - 管理状态、数据检索和回调
- en: 'It''s easy to think of the store as the place where our data lives. That is,
    however, not all it is. What the store''s responsibilities are can be expressed
    by this list:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易把商店看作是我们的数据所在的地方。然而，商店的责任不仅仅是这样。商店的责任可以通过以下列表来表达：
- en: Holder of state
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态的持有者
- en: Manages the state, able to update it if need be
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理状态，能够在需要时更新它
- en: Able to handle side effects such as fetching/persisting data through HTTP
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够处理通过HTTP获取/持久化数据等副作用
- en: Handles callbacks
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理回调
- en: 'As you can see, that is a bit more than just storing the state. Let''s now
    reconnect to what we were doing when we set up a listener with the `dispatcher`.
    Let''s move that code into our store file, `store.js`, and let''s persist our
    message content in our store:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这不仅仅是存储状态。现在让我们重新连接到我们设置监听器与`dispatcher`时正在做的事情。让我们将那段代码移到我们的存储文件`store.js`中，并将我们的消息内容持久化在我们的存储中：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: OK, so now the store is being told about the new index, but an important piece
    is missing, how do we tell the UI? We need a way to tell the UI that something
    has changed. A change means that the UI should reread its data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在商店被告知了新的索引，但缺少一个重要的部分，我们如何告诉UI？我们需要一种方法告诉UI有些东西已经改变了。改变意味着UI应该重新读取它的数据。
- en: The view
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: 'To tell the view that something has happened and act on it, three things need
    to happen:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要告诉视图发生了什么并对其进行操作，需要发生三件事：
- en: The view needs to register with the store as a listener
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图需要向商店注册为侦听器
- en: The store needs to send off an event conveying that a change has happened
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商店需要发送一个事件，传达发生了变化
- en: The view needs to reload its data
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图需要重新加载其数据
- en: 'Starting with the store, we need to build it out so that you can register as
    a listener to its events. We, therefore, add the `addListener()` method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从商店开始，我们需要构建它，以便您可以注册为其事件的侦听器。因此，我们添加`addListener()`方法：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code, we also add the ability to emit an event with the addition
    of the `emitChange()` method. You can easily switch out this implementation to
    use an `EventEmitter` or similar. So now is the time to hook up our view to the
    store. We do so by calling the `addListener()` method like so:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们还添加了发出事件的能力，通过添加`emitChange()`方法。您可以轻松地切换此实现以使用`EventEmitter`或类似的东西。现在是时候将我们的视图连接到商店了。我们通过调用`addListener()`方法来实现：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we implement the `notifyChanged()` method, which when
    called invokes the `getSelectedItem()` method from the store and thereby receives
    the new value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们实现了`notifyChanged()`方法，当调用时，会调用商店的`getSelectedItem()`方法，从而接收新值。
- en: 'At this point, we have described the whole chain: how one view receives a user
    interaction, turns that into an action, which is then dispatched to a store, which
    updates the store''s state. The store then emits an event that the other view
    is listening to. When the event is received, in the view the state from the store
    is reread and the view is then free to render this state, which it just read in,
    the way it sees fit.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经描述了整个链条：一个视图如何接收用户交互，将其转换为动作，然后分派到商店，商店更新状态。商店然后发出一个事件，其他视图正在侦听。当事件被接收时，在视图中重新读取来自商店的状态，然后视图可以自由地呈现这个状态，以它认为合适的方式。
- en: 'We have described two things here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里描述了两件事：
- en: How to set up the flow
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置流程
- en: How the information flows in Flux
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flux中信息的流动方式
- en: 'Setting up the flow can be depicted with the following diagram:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 设置流程可以用以下图表描述：
- en: '![](Images/3d1c5a2f-b842-474e-af21-201423bf19e4.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3d1c5a2f-b842-474e-af21-201423bf19e4.png)'
- en: 'As for the second scenario, how the information flows through the system, it
    can be depicted in the following way:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 至于第二种情况，信息如何在系统中流动，可以用以下方式描述：
- en: '![](Images/2f60552e-7c94-4269-b885-5005f7bab5fa.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2f60552e-7c94-4269-b885-5005f7bab5fa.png)'
- en: Demoing a uniform data flow
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演示统一的数据流
- en: 'Ok, so we have described the parts our application consists of:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经描述了我们的应用程序包含的部分。
- en: A view where a user is able to select an index
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用户可以选择索引的视图
- en: A dispatcher that allows us to send a message
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许我们发送消息的调度程序
- en: A store that contains our selected index
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含我们选择的索引的商店
- en: A second view where the selected index is read from the store
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个视图，从商店中读取所选的索引
- en: Let's build a real app from all of this. The following code is found in the
    code repository under `Chapter2/demo`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从所有这些构建一个真正的应用程序。以下代码可以在代码存储库的`Chapter2/demo`下找到。
- en: Creating a selection view
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个选择视图
- en: 'First off we need our view in which we will perform the selection:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个视图，在这个视图中我们将进行选择：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have bolded the   `selectIndex()`   method above that we intend to use.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上面加粗了`selectIndex()`方法，我们打算使用它。
- en: Adding the dispatcher
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加调度程序
- en: 'Next off we need a dispatcher that is able to take our message, like so:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个调度程序，能够接收我们的消息，就像这样：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Adding the store
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加商店
- en: 'The store will act as the data source for our state but will also be able tell
    any listeners when a change to the store happens:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 商店将作为我们状态的数据源，但也能够在商店发生变化时告诉任何侦听器：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Adding a selected view
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个选定的视图
- en: 'This view will register itself with the store and ask for updates to its content.
    If there are any updates it will be notified and the data from the store will
    be read and this view will communicate what the store value now is:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图将向存储注册自己，并请求更新其内容。如果有任何更新，它将收到通知，并从存储中读取数据，然后这个视图将传达存储值现在是什么：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running the demo
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行演示
- en: 'Before we can run our demo we need an application file, `app.js`. The `app.js` file
    should require in our views and also carry out the selection:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行演示之前，我们需要一个应用程序文件 `app.js`。`app.js` 文件应该引入我们的视图，并进行选择：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To run our demo we need to compile it. Above we are using ES2015 modules. To
    compile those we will use `webpack`. We need to install `webpack` by typing the
    following in our terminal:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行我们的演示，我们需要编译它。上面我们使用了ES2015模块。为了编译它们，我们将使用 `webpack`。我们需要在终端中输入以下内容来安装 `webpack`：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once we have done so we need to create `webpack.config.js` file where we tell
    Webpack how to compile our files and where to place the resulting bundle. That
    file looks like the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做了，我们需要创建一个 `webpack.config.js` 文件，告诉Webpack如何编译我们的文件以及将生成的捆绑包放在哪里。该文件如下所示：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This tells Webpack that `app.js` is the entry point to our application and it
    should crawl all the dependencies when creating the output file, `bundle.js`.
    Webpack will by default place `bundle.js` in the `dist` directory.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Webpack `app.js` 是我们应用程序的入口点，并且在创建输出文件 `bundle.js` 时应该遍历所有依赖项。Webpack默认会将
    `bundle.js` 放在 `dist` 目录中。
- en: 'One more thing, we need an HTML file that we will name `index.html`. We will
    place under the `dist` folder. It should look like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事，我们需要一个HTML文件，我们将其命名为 `index.html`。我们将其放在 `dist` 文件夹下。它应该是这样的：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, to run our application, we need to compile it with Webpack and start
    a HTTP server and start up a browser. We will do all that with the following command
    from the `demo` directory:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要运行我们的应用程序，我们需要使用Webpack编译它，并启动一个HTTP服务器并打开一个浏览器。我们将在 `demo` 目录中使用以下命令完成所有这些：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, start a browser and navigate to `http://localhost:5000`. You should see
    the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开浏览器，转到 `http://localhost:5000`。你应该会看到以下内容：
- en: '![](Images/999c31ff-43ad-4cc8-b1f2-9ce4d710869a.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/999c31ff-43ad-4cc8-b1f2-9ce4d710869a.png)'
- en: All of this demonstrates how to views can be made to communicate using a dispatcher
    and a store.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些演示了如何使用调度程序和存储使视图进行通信。
- en: Adding more actions to our flow
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的流程中添加更多操作
- en: Let's do a reality check here. We haven't built the Flux flow as prettily as
    we could make it. The overall picture is correct but it'd be nice if we can clean
    it up a bit to make room for more actions so we get a real sense of how the application
    should grow from here.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里做一个现实检查。我们还没有将Flux流构建得尽可能漂亮。整体情况是正确的，但如果我们能稍微整理一下，为更多操作腾出空间，那就更好了，这样我们就能真正感受到应用程序应该从这里如何发展。
- en: Cleaning up the view
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理视图
- en: 'The first order of business is to have a look at our first view and how it
    reacts to user interactions. It looks like this currently:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首要任务是查看我们的第一个视图以及它如何对用户交互做出反应。目前它看起来是这样的：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Adding a few more actions into the mix means we would extend the view with
    a few methods like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将更多操作添加到混合中意味着我们将扩展视图，添加一些方法，就像这样：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'OK, so now we get how we can add actions. It looks a little ugly though with
    all these calls to the `dispatcher` and magic strings, so we clean this up a bit
    by creating a file with constants, called `product.constants.js`, which consists
    of the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们知道如何添加操作了。不过，这看起来有点丑陋，因为有这么多对 `dispatcher` 和魔术字符串的调用，所以我们通过创建一个常量文件 `product.constants.js`
    来稍微清理一下，其中包含以下代码：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s do one more thing. Let''s move the `dispatcher` into a `product.actions.js`;
    this is generally known as an action creator. This will contain the `dispatcher`
    and refer to our `product.constants.js` file. So let''s create said file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再做一件事。让我们将`dispatcher`移动到`product.actions.js`中；这通常被称为操作创建者。这将包含`dispatcher`并引用我们的`product.constants.js`文件。所以让我们创建这个文件。
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With these constructs, we can clean up our view considerably to look like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些结构，我们可以大大简化我们的视图，看起来像这样：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Cleaning up the store
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理商店
- en: There are improvements we can make to on the store. There is no need to write
    all the code we do currently. In fact, there are libraries out there that do a
    better job of handling certain functionality.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对商店进行改进。没有必要编写我们目前所做的所有代码。事实上，有一些库可以更好地处理某些功能。
- en: Before we apply all those changes we have in mind, let's recap what our store
    can do and what features still need to be in place after the cleanup work.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用所有我们心中所想的变化之前，让我们回顾一下我们的商店能做什么，以及在清理工作之后仍然需要的功能。
- en: 'Let''s remind ourselves, what our store is capable of so far:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提醒自己，到目前为止我们的商店能做到什么：
- en: 'Handles state changes: It handles the state changes; the store is able to change
    the state regardless of whether it is creating, updating, listing, or removing
    state.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理状态变化：它处理状态变化；商店能够改变状态，无论是创建、更新、列出还是删除状态。
- en: 'Subscribable: It lets you subscribe to it; it''s important for the store to
    have a subscription functionality so a view, for example, can listen to the store''s
    state when it changes. A suitable reaction by the view is, for example, rerendering
    based on new data.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可订阅：它允许您订阅它；商店具有订阅功能对于视图来说很重要，例如，当状态发生变化时，视图可以监听商店的状态。视图的适当反应是，例如，基于新数据重新渲染。
- en: 'Can communicate a state change: It can send an event that its state has been
    changed; this goes together with being able to subscribe to the store, but this
    is the very act of actually notifying a listener that a state has changed.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通知状态变化：它可以发送一个状态已经改变的事件；这与能够订阅商店相关，但这实际上是通知监听器状态已经改变的行为。
- en: Adding EventEmitter
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加EventEmitter
- en: The two last bullets can really be condensed into one theme, namely eventing,
    or the ability to register to and fire off events.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个要点实际上可以合并为一个主题，即事件处理，或者注册和触发事件的能力。
- en: So what does a cleanup of the store look like, and why would we need to clean
    it up? The reason for cleaning it up is it makes for simpler code. There is a
    standard library that is often used when constructing a store, called `EventEmitter`.
    The library handles just what we mentioned previously, namely it is able to register
    and fire off events. It is a simple implementation of the pub-sub pattern. Basically, `EventEmitter`
    allows you to subscribe to certain events and also allows you to trigger events.
    For more information on the pattern itself, have a look at the following link: [https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那么清理商店是什么样子的，为什么我们需要清理它呢？清理的原因是使代码更简单。在构建商店时通常会使用一个标准库，称为`EventEmitter`。该库处理了我们之前提到的内容，即能够注册和触发事件。这是发布-订阅模式的简单实现。基本上，`EventEmitter`允许您订阅某些事件，还允许您触发事件。有关模式本身的更多信息，请查看以下链接：[https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)。
- en: You could definitely write your own code for this, but it's nice to be able
    to use a dedicated library so you can focus on other things that matter, such
    as solving business problems.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定可以为此编写自己的代码，但能够使用专用库来专注于解决业务问题等其他重要事项是很好的。
- en: 'We decided to use the `EventEmitter` library and we do so in the following
    way:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定使用`EventEmitter`库，并且我们是这样做的：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This makes our code a little cleaner because we no longer need to hold an internal
    list of subscribers. There are more changes we can make though, so let us talk
    about that in the next section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们的代码更加清晰，因为我们不再需要维护一个内部的订阅者列表。不过我们还可以做更多的改变，让我们在下一节讨论这个。
- en: Adding to and cleaning up the register method
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和清理注册方法
- en: 'One of the store''s jobs has been to handle eventing, especially when the store
    wants to convey to a view that a change has happened to its state. In the `store.js`
    file, other things were happening as well, things like registering ourselves with
    the `dispatcher` and being able to receive dispatched actions. We used these actions
    to alter the state of the store. Let''s remind ourselves what that looked like:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: store的工作之一是处理事件，特别是当store想要向视图传达其状态发生了变化时。在`store.js`文件中，还发生了其他事情，比如注册自己到`dispatcher`并且能够接收分发的操作。我们使用这些操作来改变store的状态。让我们回顾一下那是什么样子的：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we are only supporting one action, namely `SELECT_INDEX`. There are two
    things we need to do here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只支持一个操作，即`SELECT_INDEX`。这里有两件事情我们需要做：
- en: Add the other two actions, `CREATE_PRODUCT` and `REMOVE_PRODUCT`, and the accompanying
    functions `createProduct()` and `removeProduct()`
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加另外两个操作，`CREATE_PRODUCT`和`REMOVE_PRODUCT`，以及相应的函数`createProduct()`和`removeProduct()`
- en: Stop using magic strings and start using our constants file
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止使用魔术字符串，开始使用我们的常量文件
- en: Use the store we created in the `store-event-emitter.js` file
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们在`store-event-emitter.js`文件中创建的store
- en: 'Let''s implement the suggested changes from our preceding list:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现前面列表中建议的更改：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Further improvements
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步的改进
- en: There are definitely more improvements we can make to this code. We did use
    ES2015 imports to import other files, but most of our code was written in ES5
    so why not use most of what ES2015 gives us? Another improvement we can make is
    introducing immutability and making sure our store is not mutated but transitions
    from one state to another.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定可以对这段代码做更多的改进。我们使用了ES2015导入来导入其他文件，但我们的大部分代码是用ES5编写的，那为什么不充分利用ES2015给我们的大部分功能呢？另一个我们可以做的改进是引入不可变性，并确保我们的store不是被改变的，而是从一个状态过渡到另一个状态。
- en: 'Let''s have a look at the store file, primarily because that is where we can
    add the most ES2015 syntax. Our revealing module pattern looks like this currently:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看store文件，主要是因为那里我们可以添加最多的ES2015语法。我们当前的模块模式看起来是这样的：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It can be replaced with a simple class and instead of instantiating an `EventEmitter`,
    we can inherit from it. In all fairness, we could have used ES2015 inheritance
    or the merge library to not have to create a separate `EventEmitter` instance,
    but this shows how elegant ES2015 can make things:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以被一个简单的类替代，而不是实例化一个`EventEmitter`，我们可以继承它。公平地说，我们可以使用ES2015继承或合并库来避免创建一个单独的`EventEmitter`实例，但这展示了ES2015可以使事情变得多么优雅：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Adding immutability
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加不可变性
- en: 'The other thing we can undertake is adding immutability. The reasons for using
    immutability in the first place are to make your code more predictable, and some
    frameworks can use this for simpler change detection and can rely on reference
    checking over dirty checking. This was the case when AngularJS got its whole change
    detection mechanism changed when Angular was written. From a practical standpoint,
    this means that there are functions we can target in our store and apply immutable
    principles on. The first principle is to not mutate but create an entirely new
    state, instead of where the new state is *the old state + the state change*. A
    simple example of this is the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进行的另一件事是添加不可变性。首先使用不可变性的原因是使您的代码更可预测，一些框架可以利用这一点进行更简单的更改检测，并且可以依赖于引用检查而不是脏检查。这就是当AngularJS在编写Angular时整个更改检测机制发生变化的情况。从实际的角度来看，这意味着我们可以针对存储中的函数并应用不可变的原则。第一个原则是不要改变而是创建一个全新的状态，而不是新状态是*旧状态+状态更改*。一个简单的例子是以下内容：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we are creating a new variable, `newState`, rather than mutating our
    `oldState` variable. There are functions that will help us with this, called `Object.assign`
    and the function filter. We can use these for updating scenarios, as well as adding
    or removing things from a list. Let us use these and rewrite part of our store
    code. Let''s highlight the code we mean to change:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个新变量`newState`，而不是改变我们的`oldState`变量。有一些函数可以帮助我们做到这一点，称为`Object.assign`和filter函数。我们可以将它们用于更新场景，以及向列表添加或删除内容。让我们使用这些并重新编写我们存储代码的一部分。让我们突出显示我们打算更改的代码：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s apply `Object.assign` and `filter()`, and remember to not mutate things.
    The end result should look like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用`Object.assign`和`filter()`，并记住不要改变事物。最终结果应该是这样的：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can see that the `createProduct()` method uses an ES2015 construct, namely
    the spread parameter, `...`, which takes a list and turns its members into a comma-separated
    list of items. `Object.assign()` is used to copy over all the values from an object
    so we store the value of an object rather than its reference. The `removeProduct()`
    method becomes very simple when we use the filter method. We simply create a projection
    that does not include the product that we should remove; removing has never been
    this easy or elegant. We haven't mutated anything.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`createProduct()`方法使用了ES2015的构造，即扩展参数`...`，它接受一个列表并将其成员转换为逗号分隔的项目列表。`Object.assign()`用于复制对象的所有值，因此我们存储对象的值而不是其引用。当我们使用filter方法时，`removeProduct()`方法变得非常简单。我们只需创建一个不包括我们应该删除的产品的投影；删除从未如此简单或优雅。我们没有改变任何东西。
- en: Summarizing
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Our cleanup started with the view; we wanted to remove a direct connection to
    the dispatcher and also stop having to use magic strings as this is quite error
    prone, and it's easy to misspell. Instead, we can rely on constants. To remedy
    this, we created an action creator class that talked to the dispatcher instead.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的清理始于视图；我们希望删除与调度程序的直接连接，并且停止使用魔术字符串，因为这相当容易出错，而且很容易拼错。相反，我们可以依赖于常量。为了解决这个问题，我们创建了一个与调度程序交谈的操作创建者类。
- en: We also created a constants module to remove the magic strings.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个常量模块来删除魔术字符串。
- en: Furthermore, we improved the store by starting to use `EventEmitter`. Finally,
    we further improved the store by adding more actions to it and also started to
    refer to the constants.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们通过开始使用`EventEmitter`来改进存储。最后，我们通过向其添加更多操作并开始引用常量来进一步改进存储。
- en: At this point, our solution is ready for more actions to be added to it and
    we should feel pretty clear on what files we need to add to, as we support more
    and more user interactions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的解决方案已经准备好添加更多的动作，并且我们应该清楚地知道需要添加哪些文件，以支持越来越多的用户交互。
- en: Lastly, we added improvements around ES2015 and immutability, which made our
    code look a lot cleaner. With this foundation, we are now ready to go from static
    data to involve working with side effects and Ajax in the upcoming section.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们围绕ES2015和不可变性进行了改进，使我们的代码看起来更加清晰。有了这个基础，我们现在准备从静态数据转向涉及处理副作用和Ajax的工作。
- en: 'Let us summarize all our improvements in a diagram showing the constructs added
    to our flow:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下我们在流程中添加的构造的图表：
- en: '![](Images/d3e6216d-ff51-4e48-bac1-369b8349deac.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d3e6216d-ff51-4e48-bac1-369b8349deac.png)'
- en: It is clear that using an action creator isn't strictly necessary but it does
    clean up the code quite a bit, and the same goes for using an `EventEmitter` in
    the store; it's nice but not necessary.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，使用动作创建器并不是绝对必要的，但它确实可以清理代码，并且在存储中使用`EventEmitter`也是一样的，虽然不是必要的。
- en: Adding AJAX calls
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加AJAX调用
- en: 'So far, we have only been dealing with static data in our Flux flow. The time
    has now come to add real data connections to the flow and thereby real data. It
    is time to start talking to APIs through AJAX and HTTP. Fetching data is quite
    easy nowadays, thanks to the fetch API and libraries such as RxJS. What you need
    to think about when incorporating it in the flow is:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在Flux流程中只处理了静态数据。现在是时候向流程中添加真实数据连接，从而添加真实数据了。现在是时候通过AJAX和HTTP与API进行通信了。由于fetch
    API和RxJS等库，如今获取数据变得非常容易。在将其纳入流程时，您需要考虑以下几点：
- en: Where to place the HTTP call
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在哪里放置HTTP调用
- en: How to ensure that the store is updated and interested views are notified
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保存储已更新并通知感兴趣的视图
- en: 'We have a point at which we register the store to the `dispatcher`, with this
    piece of code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个注册存储到`dispatcher`的点，用这段代码：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we do this for real, that is, call an API to persist this product, `createProduct()`
    would be where we would do the API call, like so:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真的这样做，也就是说，调用API来保存这个产品，`createProduct()`将是我们进行API调用的地方，就像这样：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Calling `fetch()` returns a `Promise`. Let''s use async/await however, as it
    makes the call much more readable. The difference in code can be seen in the following
    example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`fetch()`返回一个`Promise`。然而，让我们使用async/await，因为它使调用更加可读。代码的差异可以在以下示例中看到：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Replacing what happens in `createProduct()` with this adds code with a lot
    of noise so it is a good idea to wrap your HTTP interactions in an API construct
    like so:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个替换`createProduct()`中发生的事情会添加很多噪音的代码，所以将你的HTTP交互封装在API构造中是一个好主意：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now let us replace the `createProduct()` method content with the call to our
    API construct like so:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用调用我们的API构造替换`createProduct()`方法的内容：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'That''s not really enough though. Because we created a product through an API
    call, we should dispatch an action that forces the product list to be reread.
    We don''t have such an action or supporting method in a store to handle it, so
    let''s add one:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不够。因为我们通过API调用创建了一个产品，所以我们应该派发一个强制重新读取产品列表的动作。我们在存储中没有这样的动作或支持方法来处理它，所以让我们添加一个：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now let''s add the required method in the store and the case to handle it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在存储中添加所需的方法和处理它的情况：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can see that the `CREATE_PRODUCT` case will call the corresponding  API method
    `createProduct()`, which on completion will dispatch the `GET_PRODUCTS` action.
    The reason for doing so is that when we successfully manage to create a product,
    we need to read from the endpoint to get an updated version of the products list. We
    don't see that in detail, but it is being invoked through us calling `getProducts()`.
    Again, it is nice to have a wrapper on everything being dispatched, that wrapper
    being an action creator.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`CREATE_PRODUCT`情况将调用相应的API方法`createProduct()`，完成后将分派`GET_PRODUCTS`操作。这样做的原因是，当我们成功创建产品时，我们需要从端点读取以获取产品列表的更新版本。我们没有详细看到这一点，但是通过我们调用`getProducts()`来调用它。同样，将所有被分派的内容包装起来是很好的，这个包装就是一个操作创建者。
- en: 'The full file looks like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的文件看起来是这样的：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: An even bigger solution
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个更大的解决方案
- en: 'So far, we have been describing a solution that consists of only a product''s
    topic and communication has only taken place from one view to another. In a more
    realistic application, we would have a lot of topics such as user management,
    orders, and so on; exactly what they are called is dependent on the domain of
    your application. As for views, it is quite possible that you will have a ton
    of views listening to another view, as in this example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在描述一个仅包含产品主题的解决方案，通信只发生在一个视图到另一个视图之间。在一个更现实的应用程序中，我们可能会有很多主题，比如用户管理、订单等；它们的确切名称取决于您的应用程序的领域。至于视图，很可能您会有大量视图监听另一个视图，就像这个例子中一样：
- en: '![](Images/95cff40e-3af8-43de-904f-36ade57a8316.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/95cff40e-3af8-43de-904f-36ade57a8316.png)'
- en: 'This describes an application that contains four different view components
    around their own topic. The **Customers view** contains a list of customers and
    it allows us to alter which customer we currently want to focus on. The other
    three supporting views show **Orders**, **Messages**, and **Friends** and their
    content depends on which customer is currently highlighted. From a Flux standpoint,
    the **Orders**, **Messages**, and **Friends** views can easily register with the
    store to know when things gets updated so they can fetch/refetch the data they
    need. However, imagine that the supporting views themselves want to support CRUD
    actions; then they would need their own set of constants, action creator, API,
    and store. So now your application would need to look something like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这描述了一个包含四个不同视图组件的应用程序，围绕它们自己的主题。**客户视图**包含客户列表，并允许我们更改我们当前想要关注的客户。其他三个支持视图显示**订单**、**消息**和**朋友**，它们的内容取决于当前突出显示的客户。从Flux的角度来看，**订单**、**消息**和**朋友**视图可以轻松地注册到存储中，以了解何时更新，以便它们可以获取/重新获取所需的数据。然而，想象一下，支持视图本身想要支持CRUD操作；那么它们将需要自己的一组常量、操作创建者、API和存储。因此，现在您的应用程序看起来可能是这样的：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Two interesting situations exist here:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里存在两种有趣的情况：
- en: You have a self-contained view; all CRUD actions happen within it
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您有一个独立的视图；所有CRUD操作都在其中发生
- en: You have a view that needs to listen to other views
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您有一个需要监听其他视图的视图
- en: For the first situation, a good rule of thumb is to create its own set of constants,
    action creator, API, and store.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种情况，一个很好的经验法则是创建自己的一组常量、操作创建者、API和存储。
- en: For the second situation, ensure your view registers itself with the store of
    that topic. For example, if the friends view needs to listen to the customer view,
    then it needs to register itself with the customer store.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二种情况，请确保您的视图在该主题的存储中注册自己。例如，如果朋友视图需要监听客户视图，那么它需要在客户存储中注册自己。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We set out trying only to explain the Flux architecture pattern. It would have
    been very easy to start mentioning how it fits with React and how there are nice
    libraries and tools that support Flux and React. That would, however, have taken our focus away
    from explaining the pattern from a more framework-agnostic viewpoint. Therefore,
    the rest of this chapter set out to explain core concepts such as actions, action
    creator, dispatcher, store, and uniform data flow. Little by little, we improved
    the code to start using constants, action creators, and a nice supporting library
    such as `EventEmitter`. We explained how HTTP fits into this and, lastly, we discussed
    how we could build out our application. There is a lot more that can be said about
    Flux, but we chose to limit the scope to understand the fundamentals so we can
    compare its approach as we dive into Redux and NgRx in later chapters.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始尝试**仅仅**解释Flux架构模式。很容易就会开始提到它如何与React配合，以及有哪些很好的支持Flux和React的库和工具。然而，这样做会让我们的重点偏离了从更框架无关的角度解释这种模式的初衷。因此，本章的其余部分旨在解释核心概念，如actions、action
    creator、dispatcher、store和统一数据流。我们逐渐改进了代码，开始使用常量、action creator和一个很好的支持库，比如`EventEmitter`。我们解释了HTTP如何融入其中，最后，我们讨论了如何构建我们的应用程序。关于Flux还有很多可以说的，但我们选择限制范围，以便在后面的章节中深入研究Redux和NgRx时能够比较它的方法。
- en: The next chapter will build on that foundation by introducing the concept of **Functional
    Reactive Programming** (**FRP**). It deals more with how to reason around the
    fact that data arrives seemingly when it wants to. As messy as that sounds, even
    that can be modeled to create a sense of structure and order if we think of our
    data as a stream. More on that in the next chapter.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将在此基础上介绍**函数式响应式编程**（FRP）的概念。它更多地涉及如何推理数据似乎随心而来的事实。尽管听起来很混乱，但即使这一点也可以被建模成一种结构和秩序的感觉，如果我们把我们的数据看作是一个流。关于这一点，我们将在下一章详细讨论。

- en: Functional Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to Wikipedia, **Functional Reactive Programming** (**FRP**) is a
    programming paradigm for reactive programming, which uses the building blocks
    of functional programming. OK, that sounds fancy, but what does it mean? To understand
    the whole sentence we need to break it apart a bit. Let''s try to define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A **programming paradigm** is an overarching theory, or way of working, centered
    around how a program should be organized and structured. Object-oriented programming
    and functional programming are examples of programming paradigms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reactive programming**, in short, is programming with asynchronous data streams.
    Asynchronous data streams are streams of data whose values can arrive at any point
    in time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional programming** is a programming paradigm that takes a more mathematical
    approach, in that it sees a functional call as a mathematical computation and
    thereby avoids changing states or dealing with mutable data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, in short, our Wikipedia definition means we have a functional programming
    approach to values that might arrive at any point in time. That doesn't really
    mean much, but hopefully things will have been cleared up a bit by the end of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous data streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How these streams can be manipulated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"To understand the word recursion see the word recursion."'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a standing joke at most engineering schools and it explains what it
    is in a very short way. Recursion is a mathematical concept. Let''s explain it
    a bit more. The official definition says the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Recursion is the process a procedure goes through when one of the steps of the
    procedure involves invoking the procedure itself. A procedure that goes through
    recursion is said to be 'recursive'.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, what does that mean in human speak? It says that at some point in running
    our function, we will call ourselves. This means we have a function that looks
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the function `something()` at some point in its body calls
    itself. A recursive function should abide to the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Should call itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should eventually meet an exit condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If a recursive function doesn''t have an exit condition, we will run out of
    memory as the function will call itself for all eternity. There are certain types
    of problems that are more suitable than others to apply recursive programming
    to. Examples of these are:'
  prefs: []
  type: TYPE_NORMAL
- en: Traversing trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing algorithms for compression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sort lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many more examples, but it''s important to remember that, although
    it''s a great tool, it shouldn''t be used everywhere. Let''s look at an example
    where recursion really shines. Our example is a linked list. A linked list consists
    of nodes that know about the node they are connected to. The code for the `Node`
    structure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using such a structure as a `Node`, we can construct a linked list consisting
    of several linked nodes. We can connect a set of node instances in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A graphical representation of the preceding code would be the following diagram.
    Here, we can clearly see what our nodes consist of and how they are connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f652d7d8-c911-4829-89a2-05694b6a39b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we have a linked list where we have three connected node instances. The
    head node is not connected to the node to the left. The second node however is
    connected to the first node and the first node is connected to the head node.
    The following type of operations on a list might be interesting to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the head node, given any node in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insert a node at a given point in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove a node from a given point in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s have a look at how we can solve the first bullet point. Firstly, we
    will use an imperative approach and thereafter we will use a recursive approach
    to see how they differ. More importantly, let''s discuss why the recursive approach
    might be preferred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see here, we are using a `while` loop to traverse through the list
    until we find the node instance whose `left` property is null. Now, let''s show
    the recursive approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we check whether `startNode.left` is null. If that is
    the case, we have reached our exit condition. If we haven't reached the exit condition
    yet, we keep on calling ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, so we have an imperative approach and a recursive approach. Why is the
    latter so much better? Well, with the recursive approach, we start off with a
    long list and we make the list shorter every time we call ourselves: a bit of
    a *divide and conquer* approach. One thing that clearly stands out with the recursive
    approach is that we defer execution by saying, no, our exit condition isn''t met
    yet, keep processing. Keep processing means we call ourselves as we do in our `if` clause.
    Is the point of recursive programming that we get fewer lines of code? Well, that
    could be the result, but more importantly: it changes our mindset toward how we
    go about solving problems. In imperative programming, we have a *let''s solve
    the problem from top to bottom mindset*, whereas in recursive programming, our
    mindset is more, define when we are done and slice down the problem to make it
    easier to deal with. In the preceding case, we discarded the part of our linked
    list that wasn''t interesting anymore.'
  prefs: []
  type: TYPE_NORMAL
- en: No more loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the more significant changes when starting to code in a more functional
    way is that we get rid of `for` loops. Now that we know about recursion, we can
    just use that instead. Let''s have look at a simple imperative piece of code that
    prints an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding code using recursion looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, our imperative code is still there in spirit. We still start
    at `0`. Moreover, we keep going until we come to the last position of our array.
    Once we hit our break condition, we exit the method.
  prefs: []
  type: TYPE_NORMAL
- en: Reoccurring pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We haven''t really sold recursion as a concept at this point. We kind of get
    it, but are probably not convinced why good old `while` or `for` loops can''t
    be used in its place. Recursion shines when it solves problems that look like
    a reoccurring pattern. An example of that is a tree. A tree has some similar concepts
    to it such as consisting of nodes. A node without children connected to it is
    called a leaf. A node with children but that has no connection to an upward node
    is called a root node. Let''s illustrate this with a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/15dea50b-92d5-4552-a346-f62c97b2c3dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a few interesting operations that we would want to carry out on a
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: Summarise the node values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Count the number of nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the width
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculate the depth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To attempt to solve that, we need to think about how to store a tree as a data
    structure. The most common way of modeling it is by creating a representation
    of a node as having a value, and a `left` property and a `right` property, then
    both those properties point to nodes in turn. Therefore, the code for said Node
    class might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is thinking how to create the tree itself. This code shows how
    we can create a tree with a root node and two children, and how to bind these
    together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Worth highlighting is how the instances `left` and `right` do not have children.
    We can see that because we set their values to `null` on creation. Our root node,
    on the other hand, has  the object instances `left` and `right` as children.
  prefs: []
  type: TYPE_NORMAL
- en: Summarise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thereafter, we need to think about how to summarise the nodes. Just looking
    at it, it looks like we should summarise the top node and its two children. So,
    a code implementation would start off like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens if our tree grows and suddenly looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/55827453-fc7c-48d9-adec-c64752c69d31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s add to the preceding code so it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is technically working code, but it can be improved. What we should see
    at this point, looking at the tree, are reoccurring patterns in the tree. We have
    the following triangles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2dca4bd2-7346-45d3-9a0f-22b956b7e5b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One triangle is made up of **2,** **3**, **5**, another one is made up of **3**,
    **1**, **2**, and the last one is made up of **5**, **4**, **2**. Every triangle
    computes its sum by taking the node itself, plus its left child and its right
    child. Recursion is all about this: discovering a reoccurring pattern and codifying
    it. We can now implement our `summarise()` function with recursion, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'What we are doing here is expressing our reoccurring pattern as *node + left
    node + right node*. When we call `summarise(node.left)` we simply run through `summarise()` again
    for that node. The preceding implementation is short and elegant, and is able
    to traverse the entire tree. Recursion is truly elegant once you find that your
    problem can be seen as a repeating pattern. The full code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Count
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing a function that counts all the nodes in the trees is quite trivial
    now that we are beginning to grasp the nature of recursion. We can reuse our summary
    function from before and simply count every non-null node as `1` and null as `0`.
    So, we simply take the existing summary function and modify it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code ensures we traverse each and every node successfully. Our
    exit condition happens when we reach null. That is, we are trying to go from a
    node to one of its non-existing children.
  prefs: []
  type: TYPE_NORMAL
- en: Width
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a width function, we first need to define what we mean by width.
    Let''s have a look at our tree again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/037af05f-c033-4f06-b319-13b1ccabd7ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This tree has a width of **4**. How is that? For every step down in the tree,
    our nodes expand one step to the left and one step to the right. This means that
    to calculate the width correctly, we need to traverse the edges of our tree. Every
    time we have to traverse a node to the left or to the right, we increment the
    width. What we are interested in doing from a calculation standpoint is to traverse
    the tree like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b6f53eb4-fe4a-4426-bd82-1d109f03ff20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code should therefore reflect this fact. We can implement this like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note especially how, in the `calcWidth()` function, we call `calc()` with `node.left` and `node.right`,
    respectively, as arguments. We also add a `left` and `right` argument which, in
    the method `calc()`, means that we will keep going in that direction. Our exit
    condition is when we eventually hit null.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous data streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An asynchronous data stream is a stream of data where values are emitted, one
    after another, with a delay between them. The word asynchronous means that the
    data emitted can appear anywhere in time, after one second or even after two minutes,
    for example. A way to model asynchronous streams is to place the emitted values
    on a time axis, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1a0a21dc-1d98-4f8d-a994-e90bdcf480e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a lot of things that can be considered asynchronous. One such thing
    is fetching data through AJAX. When the data arrives depends on a number of factors,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The speed of your connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The responsiveness of the backend API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The size of the data, and many more factors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The point is the data isn't arriving right at this very second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other things that can be considered asynchronous are user initiated events,
    such as scrolling or mouse clicks. These are events that can happen at any point
    in time, depending on the user''s interaction. As such, we can consider these
    UI events as a continuous stream of data on a time axis. The following diagram
    depicts a stream of data representing a user clicking several times. Each click
    leads to a click event, **c**, which we place on a time axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/834c40dd-9c02-4f1b-85de-68436e9ffe17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At first glance, our diagram depicts four click events. Taking a closer look,
    we see that the click events seem grouped. The preceding diagram contains two
    pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: That a number of click events have occurred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That the click events have occurred with a certain delay in between events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we can see that the two first clicks seem to happen very close together
    in time; when two events happen very close in time, this will be interpreted as
    a double-click. Therefore, our image above thus tells us about the events that
    occurred; it also tells us when and how often they occurred. Looking at the previous
    diagram, it is quite easy to distinguish between a single-click and a double-click.
  prefs: []
  type: TYPE_NORMAL
- en: We can assign different actions to each click behavior. A double-click might
    mean that we want to zoom-in, whereas a single-click might mean we want to select
    something; exactly what is up to the application you are writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'A third example is that of input. What if we have a situation where the user
    is typing and stops typing after a while? After a certain amount of time has passed,
    the user expects the UI to react. This is the case with a search field. In that
    case, the user might enter something in a search field and press a search button
    when done. Another way to model that situation in a UI is to just provide a search
    field and wait for the user to stop typing as a sign of when to start searching
    for what the user wants. The final example is known as **autocomplete** behavior.
    It can be modeled in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7aa371c4-cb52-409d-8c11-fbc31f79ad3c.png)'
  prefs: []
  type: TYPE_IMG
- en: The first three characters entered seem to belong to the same search query,
    whereas the fourth character entered occurs a lot later and probably belongs to
    another query.
  prefs: []
  type: TYPE_NORMAL
- en: The point of this section has been to highlight that different things lend themselves
    to being modeled as streams, and that the time axis and the placement of the emitted
    values on it can come to mean something.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing lists to async streams – preparing for RxJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed so far how we can model asynchronous events as a continuous
    stream of data on a time axis, or stream modeling. Events can be AJAX data, mouse
    clicks, or some other type of event. Modeling things this way makes for an interesting
    perspective on things but, looking at a double-click situation for example, doesn't
    mean much unless we are able to dig out the data. There might be another case
    where there is data that we need to filter out. What we are discussing here is
    how to manipulate streams. Without that ability, stream modeling itself has no
    practical value.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different ways to manipulate data: sometimes we want to change the
    data emitted to some other data and sometimes we might want to change how often
    the data is being emitted to a listener. Sometimes, we want our stream of data
    to become a totally different stream. We will try to model the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Projection**: Changing the data of the value being emitted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filtering**: Changing what gets emitted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining the functional programming paradigm with streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has covered functional programming and asynchronous data streams.
    Working with RxJS doesn't require a deep understanding of functional programming,
    but you do need to understand what declarative means, in order to focus on the
    right things. Your focus should be on what you want done, not how you want it
    done. RxJS, as a library, will take care of the how.
  prefs: []
  type: TYPE_NORMAL
- en: These might seem like two different topics. Combining the two, however, gives
    us the ability to manipulate streams. A stream can be seen as a list of data,
    where the data is available at a certain point in time. If we start treating our
    streams as lists, especially immutable lists, then there are operations that go
    with lists that manipulate lists by applying operators to them. The result of
    the manipulation is a new list, not a mutated list. So let's start applying our
    list philosophy and its operators to the following situations.
  prefs: []
  type: TYPE_NORMAL
- en: Projection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](Images/fd4ecfc2-02b0-436b-946e-0e42628f3d38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we can see that our stream is emitting the values **1**, **2**, **3**,
    and **4**, and then a manipulation happens that changes every value by incrementing
    it by one. This is quite a simple situation. If we consider this as a list, we
    can see that what we do here is simply a projection, which we would code like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There might be some items in a list, as well as in a stream, that you do not
    want. What you do to fix that is to create a filter that filters out the unwanted
    data. Modeling our initial array, the manipulation, and the resulting array, we
    get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ce0ec1ee-e3f3-4327-879c-80d0a271abd2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In JavaScript, we can accomplish this by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Combining mindsets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what are we trying to say with this section. Clearly, we have shown examples
    of how to manipulate lists. Well, what we have done is shown how we can display
    items on an axis. In that sense, we can see how it is easy to think of asynchronous
    events and lists of values in the same way, as we are graphically picturing them
    in the same way. The question is, why do we want to do that? The reason is that
    this is the mindset the RxJS library wants you to have when you start manipulating
    and crafting streams.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has established that we can model asynchronous events as values
    on a time axis. We introduced the idea of comparing these streams to lists and
    thereby applying functional methods to them that would not change the lists themselves
    but merely create a new list. The benefit of applying the functional paradigm
    is that we can focus on *what* to achieve rather than *how* to achieve it, thereby
    having a declarative approach. We realize it's not easy to combine async and lists
    and create readable code from it. Fortunately, this is what the RxJS library does
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: It is this realization that prepares us for [Chapter 8](1cd60ce6-607e-40aa-a87b-84370191f92e.xhtml),
    *RxJS Advanced*, which will cover more operators, and some more advanced concepts.
  prefs: []
  type: TYPE_NORMAL

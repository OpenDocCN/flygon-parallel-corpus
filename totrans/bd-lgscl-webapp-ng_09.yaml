- en: Create a Local Weather Web Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be designing and building a simple Local Weather app with Angular and
    a third-party web API, using an iterative development methodology. You will focus
    on delivering value first while learning about the nuances and optimal ways of
    using Angular, TypeScript, Visual Studio Code, Reactive Programming, and RxJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Planning out your roadmap using Waffle as a GitHub-connected Kanban board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crafting a new UI element to display current weather information using components
    and interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Angular Services and HttpClient to retrieve data from OpenWeatherMap APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging observable streams to transform data using RxJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code samples provided in this book require Angular version 5 and 6\. Angular
    5 code is runtime compatible with Angular 6\. Angular 6 will be supported in LTS
    until October 2019\. The most up-to-date versions of the code repositories may
    be found at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: LocalCast Weather, at: [Github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LemonMart, at: [Github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning a feature road map using Waffle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a rough plan of action before you start coding is very important so
    that you and your colleagues or clients are aware of the road map you're planning
    to execute. Whether you're building an app for yourself or for someone else, a
    living backlog of features will always serve as a great reminder when you get
    back to a project after a break or serve as an information radiator that prevents
    constant requests for status updates.
  prefs: []
  type: TYPE_NORMAL
- en: In Agile development, you may have used various ticketing systems or tools that
    surface or Kanban boards. My favorite tool is Waffle.io, [https://waffle.io/](https://waffle.io/),
    because it directly integrates with your GitHub repository's issues and keeps
    track of the status of issues via labels. This way, you can keep using the tool
    of your choice to interact with your repository and still, effortlessly, radiate
    information. In the next section, you will set up a Waffle project to achieve
    this goal.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Waffle project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now set up our Waffle project:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to Waffle.io [https://waffle.io/](https://waffle.io/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Login or Get Started for Free.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Public & Private Repos to allow access to all of your repositories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Create Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for the local-weather-app repository and select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hit Continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will get two starter layout templates, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/81040eee-bfed-4822-8449-2037e1cbe44e.png)Waffle.io Default Board
    Layouts'
  prefs: []
  type: TYPE_NORMAL
- en: For this simple project, you will be selecting Basic. However, the Advanced
    layout demonstrates how you can modify the default setup of Waffle, by adding
    additional columns such as Review, to account for testers or product owners participating
    in the process. You can further customize any board to fit your existing process.
  prefs: []
  type: TYPE_NORMAL
- en: Select the Basic layout and click on Create Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see a new board created for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/ae7f8ef6-e282-4468-a474-71e05feab25b.png)Empty Waffle Board'
  prefs: []
  type: TYPE_NORMAL
- en: By default, Waffle will serve as a Kanban board. Allowing you to move a task
    from one state to another. However, the default view will show all the issues
    that are present on the repository. To use Waffle as a Scrum board, you need to
    assign issues to GitHub milestones that will represent sprints. You can then use
    the filtering functionality to only display issues from that milestone, or put
    another way from the current sprint.
  prefs: []
  type: TYPE_NORMAL
- en: On Waffle, you can attach story points to issues by clicking on the ![](Images/98c10b6b-b94d-4cca-b7aa-8992281c2ce6.jpg) scale
    icon. The columns will automatically show totals and card orders, which represent
    priority, and they will be retained from session to session. Furthermore, you
    can switch to the Metrics view to get Milestone Burndown and Throughput graphs
    and statistics.
  prefs: []
  type: TYPE_NORMAL
- en: Creating issues for your Local Weather app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now create a backlog of issues that you will use to keep track of your
    progress as you implement the design of your application. When creating issues,
    you should focus on delivering functional iterations that bring some value to
    the user. The technical hurdles you must clear to achieve those results are of
    no interest to your users or clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the features we plan to be building in our first release:'
  prefs: []
  type: TYPE_NORMAL
- en: Display Current Location weather information for the current day
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display forecast information for current location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add city search capability so that users can see weather information from other
    cities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a preferences pane to store the default city for the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve the UX of the app with Angular Material
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go ahead with creating your issues on Waffle or on GitHub; whichever you prefer
    is fine. While creating the scope for Sprint 1, I had some other ideas for features,
    so I just added those issues, but I did not assign them to a person or a milestone.
    I also went ahead and added story points to the issues I intended to work on.
    The following is what the board looks like, as I''m to begin working on the first
    story:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c0baf628-599c-43ba-92f0-fb70250dff89.png)A snapshot of the initial
    state of the board at [https://waffle.io/duluca/local-weather-app](https://waffle.io/duluca/local-weather-app)Ultimately,
    Waffle provides an easy-to-use GUI so that non-technical people can easily interact
    with GitHub issues. By allowing non-technical people to participate in the development
    process on GitHub, you unlock the benefit of GitHub becoming the single source
    of information for your entire project. Questions, answers, and discussions around
    features and issues are all tracked as part of GitHub issues, instead of being
    lost in emails. You can also store wiki type documentation on GitHub, so by centralizing
    all project-related information, data, conversations, and artifacts on GitHub,
    you are greatly simplifying a potentially complicated interaction of multiple
    systems that require continued maintenance, at a high cost. For private repositories
    and on-premise Enterprise installations, GitHub has a very reasonable cost. If
    you''re sticking with open source, as we are in this chapter, all these tools
    are free.As a bonus, I created a rudimentary wiki page on my repository at [https://github.com/duluca/local-weather-app/wiki](https://github.com/duluca/local-weather-app/wiki).
    Note that you can''t upload images to `README.md` or wiki pages. To get around
    this limitation, you can create a new issue, upload an image in a comment, and
    copy and paste the URL for it to embed images to `README.md` or wiki pages. In
    the sample wiki, I followed this technique to embed the wireframe design into
    the page.'
  prefs: []
  type: TYPE_NORMAL
- en: With a concrete road map in place, you're now ready to start implementing your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Crafting UI elements using components and interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be leveraging Angular components, interfaces, and services to build
    the current weather feature in a decoupled, cohesive, and encapsulated manner.
  prefs: []
  type: TYPE_NORMAL
- en: The landing page of an Angular app, by default, resides in `app.component.html`.
    So, start by editing the template of `AppComponent` with rudimentary HTML, laying
    out the initial landing experience for the application.
  prefs: []
  type: TYPE_NORMAL
- en: We are now beginning the development of Feature 1: Display Current Location
    weather information for the current day, so, you can move the card in Waffle to
    the In Progress column.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add a header as an `h1` tag, followed by the tagline of our app as
    a `div` and placeholders for where we may want to display the current weather,
    as demonstrated as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you should run `npm start` and navigate to `http://localhost:5000` on your
    browser so that you can observe the changes you're making in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an Angular component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to display the current weather information, where `<div>current weather</div>`
    is located. In order to achieve this, you need to build a component that will
    be responsible for displaying the weather data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason behind creating a separate component is an architectural best practice
    that is codified in the **Model-View-ViewModel** (**MVVM**) design pattern. You
    may have heard of the **Model-View-Controller** (**MVC**) pattern before. Vast
    majority of web-based code written circa 2005-2015 has been written following
    the MVC pattern. MVVM differs, in important ways, from the MVC pattern. As I have
    explained in my 2013 article on DevPro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[An effective implementation of MVVM] inherently enforces proper separation
    of concerns. Business logic is clearly separated from presentation logic. So when
    a View is developed, it stays developed, because fixing a bug in one View''s functionality
    doesn''t impact other views. On the flip side, if [you use] visual inheritance
    effectively and [create] reusable user controls, fixing a bug in one place can
    fix issues throughout the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Angular provides an effective implementation of MVVM.
  prefs: []
  type: TYPE_NORMAL
- en: ViewModels neatly encapsulate any presentation logic and allow for simpler View
    code by acting as a specialized version of the model. The relationship between
    a View and ViewModel is straightforward, allowing for more natural ways to wrap
    UI behavior in reusable user controls.
  prefs: []
  type: TYPE_NORMAL
- en: You can read further about the architectural nuance, with illustrations, at [http://bit.ly/MVVMvsMVC](http://bit.ly/MVVMvsMVC).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you will create your very first Angular component, which will include
    the View and the ViewModel, using Angular CLI''s `ng generate` command:'
  prefs: []
  type: TYPE_NORMAL
- en: In the terminal, execute `npx ng generate component current-weather`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that you are executing `ng` commands under the `local-weather-app` folder,
    and not under the `root` project folder. In addition, note that `npx ng generate
    component current-weather` can be rewritten as `ng g c current-weather`. Going
    forward, this book will utilize the shorthand format and expect you to prepend `npx`,
    if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe the new files created in your `app` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A generated component has four parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`current-weather.component.css` contains any CSS that is specific to the component
    and is an optional file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current-weather.component.html` contains the HTML template that defines the
    look of the component and rendering of the bindings, and can be considered the
    View, in combination with any CSS styles used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current-weather.component.spec.ts` contains Jasmine-based unit tests that
    you can extend to test your component functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current-weather.component.ts` contains the `@Component` decorator above the class
    definition and is the glue that ties together the CSS, HTML, and JavaScript code
    together. The class itself can be considered the ViewModel, pulling data from
    services and performing any necessary transformations to expose sensible bindings
    for the View, as shown as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If the component you're planning to write is a simple one, you can rewrite it
    using inline styles and an inline template, to simplify the structure of your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `CurrentWeatherComponent` with an inline template and styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When you executed the generate command, in addition to creating the component,
    the command also added the new module you created to `app.module.ts`, avoiding
    an otherwise tedious task of wiring up components together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The bootstrap process of Angular is, admittedly, a bit convoluted. This is the
    chief reason Angular CLI exists. `index.html` contains an element named `<app-root>`.
    When Angular begins execution, it first loads `main.ts`, which configures the
    framework for browser use and loads the app module. App module then loads all
    its dependencies and renders within the aforementioned `<app-root>` element. In
    [Chapter 12](b49e4716-d083-4c8c-a083-bcf6cf182a6f.xhtml), *Create a Router-First
    Line-of-Business App*, when we build a line-of-business app, we will create our
    own feature modules to take advantage of the scalability features of Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to display our new component on the initial `AppComponent` template,
    so it is visible to the end user:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `CurrentWeatherComponent` to `AppComponent` by replacing `<div>current
    weather</div>` with `<app-current-weather></app-current-weather>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything worked correctly, you should see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/73cfd796-6a00-4c6a-b790-4a736c7fa508.png)Initial render of your
    local weather appNote the icon and name in the tab of the browser window. As a
    web development norm, in the `index.html` file, update the `<title>` tag and the
    `favicon.ico` file with the name and icon of your application to customize the
    browser tab information. If your favicon doesn''t update, append the `href` attribute
    with a unique version number, such as `href="favicon.ico?v=2"`. As a result, your
    app will start looking like a real web app, instead of a CLI-generated starter
    project.'
  prefs: []
  type: TYPE_NORMAL
- en: Define your model using interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that your `View` and `ViewModel` are in place, you need to define your
    `Model`. If you look back on the design, you will see that the component needs
    to display:'
  prefs: []
  type: TYPE_NORMAL
- en: City
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Country
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current temperature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current weather description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will first create an interface that represents this data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: In the terminal, execute `npx ng generate interface ICurrentWeather`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Observe a newly generated file named `icurrent-weather.ts` with an empty interface
    definition that looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is not an ideal setup, since we may add numerous interfaces to our app
    and it can get tedious to track down various interfaces. Over time, as you add
    concrete implementations of these interfaces as classes, then it will make sense
    to put classes and their interfaces in their own files.
  prefs: []
  type: TYPE_NORMAL
- en: Why not just call the interface `CurrentWeather`? This is because later on we
    may create a class to implement some interesting behavior for `CurrentWeather`.
    Interfaces establish a contract, establishing the list of available properties
    on any class or interface that implements or extends the interface. It is always
    important to be aware of when you're using a class versus an interface. If you
    follow the best practice to always start your interface names with a capital `I`,
    you will always be conscious of what type of an object you are passing around.
    Hence, the interface is named `ICurrentWeather`.
  prefs: []
  type: TYPE_NORMAL
- en: Rename `icurrent-weather.ts` to `interfaces.ts`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Correct the capitalization of the interface name to `ICurrentWeather`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, implement the interface as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This interface and its eventual concrete representation as a class is the Model
    in MVVM. So far, I have highlighted how various parts of Angular fit the MVVM
    pattern; going forward, I will be referring to these parts with their actual names.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can import the interface into the component and start wiring up the
    bindings in the template of `CurrentWeatherComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Import `ICurrentWeather`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch back to the `templateUrl` and ``styleUrls``
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a local variable called `current` with type `ICurrentWeather`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you just type `current: ICurrentWeather`, you can use the auto-fixer to
    automatically insert the import statement.'
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor, you will temporarily populate the current property with
    dummy data to test your bindings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement dummy data as a JSON object and declare its adherence to `ICurrentWeather`
    using the as operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the `src/assets` folder, create a subfolder named `img` and place an image
    of your choice to reference in your dummy data.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may forget the exact properties in the interface you created. You can get
    a quick peek at them by holding *Ctrl* + hover-over the interface name with your
    mouse, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e15b7ab5-9e57-4aff-a18d-c38830c6e75a.png)*Ctrl* + hover-over the
    interface'
  prefs: []
  type: TYPE_NORMAL
- en: Now you update the template to wire up your bindings with a rudimentary HTML-based
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To change the display formatting of `current.date`, we used the `DatePipe` above,
    passing in `'fullDate'` as the format option. In Angular, various out-of-the-box
    and custom pipe `|` operators can be used to change the appearance of data without
    actually changing the underlying data. This is a very powerful, convenient, and
    flexible system to share such user interface logic without writing repetitive
    boilerplate code. In the preceding example, we could pass in `'shortDate'` if
    we wanted to represent the current date in a more compact form. For more information
    on various `DatePipe` options, refer to the documentation at [https://angular.io/api/common/DatePipe](https://angular.io/api/common/DatePipe). To
    format `current.temperature` so that no fractional values are shown, you can use
    `DecimalPipe`. The documentation is at [https://angular.io/api/common/DecimalPipe](https://angular.io/api/common/DecimalPipe).
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can render ℃ and ℉ using their respective HTML codes: ![](Images/b5a76f73-bb93-4f1a-a344-5f20edef7312.png) for
    ℃ and ![](Images/a4b2101d-64f9-4302-a885-efa078718e12.png) for ℉.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything worked correctly, you app should be looking similar to this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/b0c66fef-99c4-4b07-b2e6-0040f481527b.png)App after wiring up bindings
    with dummy data'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you have successfully wired up your first component.
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular Services and HttpClient to retrieve data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now you need to connect your `CurrentWeather` component to the `OpenWeatherMap`
    APIs. In the upcoming sections, we will go over the following steps to accomplish
    this goal:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Angular Service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `HttpClientModule` and inject it into the service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Discover the `OpenWeatherMap` API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new interface that conforms to the shape of the API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a `get` request
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject the new service into the `CurrentWeather` component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the service from the `init` function of the `CurrentWeather` component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, map the API data to the local `ICurrentWeather` type using RxJS functions
    so that it can be consumed by your component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a new Angular Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any code that touches outside of the boundaries of a component should exist
    in a service; this includes inter-component communication, unless there's a parent-child
    relationship, and API calls of any kind and any code that cache or retrieve data
    from a cookie or the browser's localStorage. This is a critical architectural
    pattern that keeps your application maintainable in the long term. I expand upon
    this idea in my DevPro MVVM article at [http://bit.ly/MVVMvsMVC](http://bit.ly/MVVMvsMVC).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an Angular service, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: In the terminal, execute `npx ng g s weather --flat false`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Observe the new `weather` folder created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A generated service has two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`weather.service.spec.ts` contains Jasmine-based unit tests that you can extend
    to test your service functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`weather.service.ts` contains the `@Injectable` decorator above the class definition,
    which makes it possible to inject this service into other components, leveraging
    Angular''s provider system. This will ensure that our service will be a singleton,
    meaning only instantiated once, no matter how many times it is injected elsewhere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The service is generated, but it''s not automatically provided. To do this,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `app.module.ts`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `WeatherService` inside the providers array
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the auto-fixer to import the class for you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you installed the recommended extension TypeScript Hero, the import statement
    will be automatically added for you. You won't have to use the auto-fixer to do
    it. Going forward, I will not call out the need to import modules.
  prefs: []
  type: TYPE_NORMAL
- en: Inject dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to make API calls, you will be leveraging the `HttpClient` module
    in Angular. The official documentation ([https://angular.io/guide/http](https://angular.io/guide/http))
    explains the benefits of this module succinctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '"With HttpClient, @angular/common/http provides a simplified API for HTTP functionality
    for use with Angular applications, building on top of the XMLHttpRequest interface
    exposed by browsers. Additional benefits of HttpClient include testability support,
    strong typing of request and response objects, request and response interceptor
    support, and better error handling via APIs based on Observables."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with importing the `HttpClientModule` in to our app, so we can
    inject the `HttpClient` within the module into the `WeatherService`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `HttpClientModule` to `app.module.ts`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Inject `HttpClient` provided by the `HttpClientModule` in the  `WeatherService`, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, `httpClient` is ready for use in your service.
  prefs: []
  type: TYPE_NORMAL
- en: Discover OpenWeatherMap APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since `httpClient` is strongly typed, we need to create a new interface that
    conforms to the shape of the API we'll call. To be able to do this, you need to
    familiarize yourself with the Current Weather Data API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read documentation by navigating to [http://openweathermap.org/current](http://openweathermap.org/current):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/771e0150-f856-43e5-9da5-0704544cd618.png)OpenWeatherMap Current
    Weather Data API Documentation'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be using the API named By city name, which allows you to get current
    weather data by providing the city name as a parameter. So, your web request will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'On the documentation page, click on the link under Example of API calls, and
    you will see a sample response like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Given the existing `ICurrentWeather` interface that you have already created,
    this response contains more information than you need. So you will write a new
    interface that conforms to the shape of this response, but only specify the pieces
    of data you will use. This interface will only exist in the `WeatherService` and
    we won't export it, since the other parts of the application don't need to know
    about this type.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new interface named `ICurrentWeatherData` in `weather.service.ts` between
    the `import` and `@Injectable` statements
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The new interface should like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With the `ICurrentWeatherData` interface, we are defining new anonymous types
    by adding children objects to the interface with varying structures. Each of these
    objects can be individually extracted out and defined as their own named interface.
    Especially, note that `weather` will be an array of the anonymous type that has
    the `description` and `icon` properties.
  prefs: []
  type: TYPE_NORMAL
- en: Storing environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s easy to miss, but the sample URL from previous sections contains a required `appid` parameter.
    You must store this key in your Angular app. You can store it in the weather service,
    but in reality, applications need to be able to target different sets of resources
    as they move from development to testing, staging, and production environments.
    Out of the box, Angular provides two environments: one `prod` and the other one
    as the default.'
  prefs: []
  type: TYPE_NORMAL
- en: Before you can continue, you need to sign up for a free `OpenWeatherMap` account
    and retrieve your own `appid`. You can read the documentation for `appid` at [http://openweathermap.org/appid ](http://openweathermap.org/appid)for
    more detailed information.
  prefs: []
  type: TYPE_NORMAL
- en: Copy your `appid`, which will have a long string of characters and numbers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store your `appid `in `environment.ts`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure `baseUrl` for later use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In code, we use a camel-case `appId` to keep our coding style consistent. Since
    URL parameters are case-insensitive, `appId` will work as well as `appid`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an HTTP GET operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can implement the GET call in the Weather service:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new function to the `WeatherService` class named `getCurrentWeather`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `environment` object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `httpClient.get` function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Return the results of the HTTP call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of ES2015's String Interpolation feature. Instead of building your
    string by appending variables to one another like `environment.baseUrl + 'api.openweathermap.org/data/2.5/weather?q='
    + city + ',' + country + '&appid=' + environment.appId`, you can use the backtick
    syntax to wrap ``your string``. Inside the backticks, you can have newlines and
    also directly embed variables into the flow of your string by wrapping them with
    the `${dollarbracket}` syntax. However, when you introduce a newline in your code,
    it will be interpreted as a literal newline—`\n`. In order to break up the string
    in your code, you may add a backslash `\`, but then the next line of your code
    can have no indentation. It is easier to just concatenate multiple templates,
    as shown in the preceding code sample.Note the use TypeScript Generics with the
    get function using the caret syntax like `<TypeName>`. Using generics is development-time
    quality of life feature. By providing the type information to the function, input
    and/or return variables types of that function will be displayed as you write
    your code and validated during development and also at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving service data from a component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to use the `getCurrentWeather` function in the `CurrentWeather`
    component, you need to inject the service into the component:'
  prefs: []
  type: TYPE_NORMAL
- en: Inject the `WeatherService` into the constructor of the `CurrentWeatherComponent`
    class
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the existing code that created the dummy data in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `getCurrentWeather` function inside the `ngOnInit` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Fair warning, do not expect this code to be working just yet. You should see
    an error, so let's understand what's going in the next segment.
  prefs: []
  type: TYPE_NORMAL
- en: Angular components have a rich collection of lifecycle hooks that allow you
    to inject your custom behavior when a component is being rendered, refreshed,
    or destroyed. `ngOnInit()` is the most common lifecycle hook you will be using.
    It is only called once when a component is first instantiated or visited. This
    is where you will want to perform your service calls. For a deeper understanding
    of component lifecycle hooks, check out the documentation at [https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks).Note
    that the anonymous function you have passed to `subscribe` is an ES2015 arrow
    function. If you're not familiar with arrow functions, it may be confusing at
    first. Arrow functions are actually quite elegant and simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following arrow function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(data) => { this.current = data }`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can rewrite it simply as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`function(data) { this.current = data }`'
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a special condition—when you write an arrow function that simply transforms
    a piece of data, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(data) => { data.main.temp }`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function effectively takes `ICurrentWeatherData` as an input and returns
    the temp property. The return statement is implicit. If you rewrite it as a regular
    function, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`function(data) { return data.main.temp }`'
  prefs: []
  type: TYPE_NORMAL
- en: When the `CurrentWeather` component loads, `ngOnInit` will fire once, which
    will call the `getCurrentWeather` function that returns an object with a type
    of `Observable<ICurrentWeatherData>`. An Observable, as described in the official
    documentation, *is the most basic building block of RxJS* that represents an event
    emitter, which will emit any data received over time with the type of `ICurrentWeatherData`.
    The `Observable` object by itself is benign and will not cause a network event
    to be fired unless it is being listened to. You can read more about Observables
    at [reactivex.io/rxjs/class/es6/Observable.js~Observable.html](http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html).
  prefs: []
  type: TYPE_NORMAL
- en: By calling `.subscribe` on the Observable, you're essentially attaching a listener
    to the emitter. You've implemented an anonymous function within the `subscribe`
    method, which will get executed whenever a new piece of data is received and an
    event is emitted. The anonymous function takes a data object as a parameter, and,
    the specific implementation in this case, assigns the piece of data to the local
    variable named current. Whenever current is updated, the template bindings you
    implemented earlier will pull in the new data and render it on the view. Even
    though `ngOnInit` executes only once, the subscription to the Observable persists.
    So whenever there's new data, the current variable will be updated and the view
    will re-render to display the latest data.
  prefs: []
  type: TYPE_NORMAL
- en: The root cause of the error at hand is that the data that is being emitted is
    of type `ICurrentWeatherData`; however, our component only understands data that
    is shaped as described by the `ICurrentWeather` interface. In the next section,
    you will need to dig deeper into RxJS to understand how best to accomplish that
    task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beware, VS Code and CLI sometimes stop working. As previously noted, as you
    code, the `npm start` command is running in the integrated terminal of VS Code.
    Angular CLI, in combination with the Angular Language Service plug-in, continuously
    watches for code changes and transpiles your TypeScript code to JavaScript, so
    you can observe your changes with live-reloading in the browser. The great thing
    is that when you make coding errors, in addition to the red underlining in VS
    Code, you will also see some red text in the terminal or even the browser, because
    the transpilation has failed. In most cases, when correcting the error, the red
    underlining will go away and Angular CLI will automatically retranspile your code
    and everything will work. However, under certain scenarios, you will note that
    VS Code will fail to pick typing changes in the IDE, so you won''t get autocompletion
    help or the CLI tool will get stuck with message saying webpack: Failed to compile.
    You have two main strategies to recover from such conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the terminal and hit *Ctrl* + *C*to stop running the CLI task and restart
    by executing `npm start`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If **#1** doesn't work, quit VS Code with *Alt* + *F4* for Windows or ⌘ + *Q*
    for macOS and restart it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given Angular and VS Code's monthly releases cycles, I'm confident that in time
    the tooling can only improve.
  prefs: []
  type: TYPE_NORMAL
- en: Transform data using RxJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RxJS stands for Reactive Extensions, which is a modular library that enables
    reactive programming, which itself is an asynchronous programming paradigm and
    allows for manipulation of data streams through transformation, filtering, and
    control functions. You can think of reactive programming as an evolution of event-based
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Event-Driven programming, you would define an event handler and attach it
    to an event source. In more concrete terms, if you had a save button, which exposes
    an `onClick` event, you would implement a `confirmSave` function, which when triggered,
    would show a popup to ask the user Are you sure?. Look at the following figure
    for a visualization of this process.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1958996b-696a-4b00-971d-12e7f8537bf2.png)Event-Driven Implementation'
  prefs: []
  type: TYPE_NORMAL
- en: In short, you would have an event firing once per user action. If the user clicks
    on the save button many times, this pattern would gladly render as many popups
    as there are clicks, which doesn't make much sense.
  prefs: []
  type: TYPE_NORMAL
- en: The publish-subscribe (pub/sub) pattern is a different type of event-driven
    programming. In this case, we can write multiple handlers to act on the result
    of a given event all simultaneously. Let's say that your app just received some
    updated data. The publisher will go through its list of subscribers and pass on
    the updated data to each of them. Refer to the following diagram, how can updated
    data event trigger an `updateCache` function that can update your local cache
    with new data, a `fetchDetails` function that can retrieve further details about
    the data from the server, and also a `showToastMessage` function that can inform
    the user that the app just received new data. All these events can happen asynchronously;
    however, the `fetchDetails` and `showToastMessage` functions will be receiving
    more data than they really need, and it can get really convoluted to try to compose
    these events in different ways to modify application behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3526531c-0a8d-4901-887b-2128cf2c4451.png)Pub/Sub Pattern Implementation'
  prefs: []
  type: TYPE_NORMAL
- en: In reactive programming, everything is treated as a stream. A stream will contain
    events that happen over time and these events can contain some data or no data.
    The following diagram visualizes a scenario where your app is listening for mouse
    clicks from the user. Uncontrolled streams of user clicks are meaningless. You
    exert some control over this stream by applying the `throttle` function to it,
    so you only get updates every 250 **milliseconds** (**ms**). If you subscribe
    to this new event, every 250 ms, you will receive a list of click events. You
    may try to extract some data from each click event, but in this case, you're only
    interested in the number of click events that happened. We can shape the raw event
    data into number of clicks using the `map` function.
  prefs: []
  type: TYPE_NORMAL
- en: Further down the stream, we may only be interested in listening for events with
    two or more clicks in it, so we can use the `filter` function to only act on what
    is essentially a double-click event. Every time our filter event fires, it means
    that the user intended to double-click, and you can act on that information by
    popping up an alert. The true power for streams comes from the fact that you can
    choose to act on the event at any time as it passes through various control, transformation,
    and filter functions. You can choose to display click data on an HTML list using
    `*ngFor` and Angular's `async` pipe, so the user can monitor the types of click
    data being captured every 250ms.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c16581a0-78ed-4c3c-87a6-903d7bca41d0.png)A Reactive Data Stream
    Implementation'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Reactive transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To avoid future mistakes in returning the unintended type of data from your
    service, you need to update the `getCurrentWeather` function to define the return
    type to be `Observable<ICurrentWeather>` and import the `Observable` type, as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, VS Code will let you know that Type `Observable<ICurrentWeatherData>` is
    not assignable to type `Observable<ICurrentWeather>`:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a transformation function named `transformToICurrentWeather` that can
    convert `ICurrentWeatherData` to `ICurrentWeather`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, write a helper function named `convertKelvinToFahrenheit` that converts
    the API provided Kelvin temperature to Fahrenheit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that you need to be converting the icon property to an image URL at this
    stage. Doing this in the service helps preserve encapsulation, binding the icon
    value to the URL in the view template will break the **Separation of concerns**
    (**SoC**) principle. If you wish to create truly modular, reusable, and maintainable
    components, you must remain vigilant and strict in terms of enforcing SoC. The
    documentation for Weather Icons and details of how the URL should be formed, including
    all the available icons can be found at [http://openweathermap.org/weather-conditions](http://openweathermap.org/weather-conditions).On
    a separate note, the argument can be made that Kelvin to Fahrenheit conversion
    is actually a view concern, but we have implemented it in the service. This argument
    holds water, especially considering that we have a planned feature to be able
    to toggle between Celsius and Fahrenheit. A counter argument would be that at
    this time, we only need to display in Fahrenheit and it is part of the job of
    the weather service to be able to convert the units. This argument makes sense
    as well. The ultimate implementation will be to write a custom Angular Pipe and
    apply it in the template. A pipe can easily bind with the planned toggle button
    as well. However, at this time, we only need to display in Fahrenheit and I would
    err on the side of *not*over-engineering a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Update `ICurrentWeather.date` to the `number` type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While writing the transformation function, you will note that the API returns
    the date as a number. This number represents time in seconds since the UNIX epoch
    (timestamp), which is January 1st, 1970 00:00:00 UTC. However, `ICurrentWeather`
    expects a `Date` object. It is easy enough to convert the timestamp by passing
    it into the constructor of the `Date` object like `new Date(data.dt)`. This is
    fine, but also unnecessary, since Angular's `DatePipe` can directly work with
    the timestamp. In the name of relentless simplicity and maximally leveraging the
    functionality of the frameworks we use, we will update `ICurrentWeather` to use
    `number`. There's also a performance and memory benefit to this approach if you're
    transforming massive amounts of data, but that concern is not applicable here. There's
    one caveat—JavaScript's timestamp is in milliseconds, but the server value is
    in seconds, so a simple multiplication during the transformation is still required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the RxJS `map` operator right below the other import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It may seem odd to have to manually import the `map` operator. RxJS is a very
    capable framework with a wide API surface. Observable alone has over 200 methods
    attached to it. Including all of these methods by default creates development
    time issues with too many functions to choose from and also, it negatively impacts
    the size of the final deliverable, including app performance and memory use. So
    you must add each operator you intend to use individually.
  prefs: []
  type: TYPE_NORMAL
- en: Apply the `map` function to data stream returned by  `httpClient.get` method
    through a `pipe`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pass the `data` object into the `transformToICurrentWeather` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now incoming data can be transformed as it flows through the stream, ensuring
    that the `OpenWeatherMap` Current Weather API data is in the correct shape, so
    it can be consumed by the `CurrentWeather` component.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that your app compiles successfully
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inspect the results in the browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/9d3b92ed-4580-464f-ba40-4eb4f8b2121d.png)Displaying Live Data from
    OpenWeatherMap'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you should see that your app is able to pull live data from `OpenWeatherMap`
    and correctly transform server data into the format you expect.
  prefs: []
  type: TYPE_NORMAL
- en: You have completed the development of Feature 1: Display Current Location weather
    information for the current day. Commit your code and move the card in Waffle
    to the Done column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can move this task to the Done column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/fa81e672-d175-49db-a89c-67b6acb67a98.png)Waffle.io Kanban Board
    Status'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations, in this chapter, you created your first Angular application
    with a flexible architecture while avoiding over-engineering. This was possible
    because we first built a road map and codified it in a Kanban board that is visible
    to your peers and colleagues. We stayed focused on implementing the first feature
    we put in progress and didn't deviate from the plan.
  prefs: []
  type: TYPE_NORMAL
- en: You can now use Angular CLI and an optimized VS Code development environment
    to help you reduce the amount of coding you need to do. You can leverage TypeScript
    anonymous types and observable streams to accurately reshape complicated API data
    into a simple format without having to create one-use interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: You learned to avoid coding mistakes by proactively declaring input and return
    types of functions and working with generic functions. You used the date and decimal
    pipes to ensure that the data is formatted as desired, while keeping formatting-related
    concerns mostly in the template, where this kind of logic belongs.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you used interfaces to communicate between components and services
    without leaking the external data structure to internal components. By applying
    all these techniques in combination, which Angular, RxJS, and TypeScript have
    allowed us to do, you have ensured proper separation of concerns and encapsulation.
    As a result, the `CurrentWeather` component is now a truly reusable and composable
    component; this is not an easy feat to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't ship it, it never happened. In the next chapter, we will prepare
    this Angular app for a production release by troubleshooting application errors,
    and containerizing the Angular app with Docker, so it can be published on the
    web.
  prefs: []
  type: TYPE_NORMAL

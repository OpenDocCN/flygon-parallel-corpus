- en: Creating RESTful Endpoints
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建RESTful端点
- en: So far, we have understood what a RESTful web services. We have also seen the
    new features in PHP7 which will make our code better and cleaner. Now, it is time
    to implement RESTful web services in PHP. So, this chapter is all about implementation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了什么是RESTful网络服务。我们还看到了PHP7中的新功能，这将使我们的代码更好，更清晰。现在，是时候在PHP中实现RESTful网络服务了。因此，本章就是关于实现的。
- en: 'We have seen an example of a blog having blog posts and comment endpoints.
    In this chapter, we will implement those endpoints. Here are the topics that we
    will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个具有博客帖子和评论端点的博客示例。在本章中，我们将实现这些端点。以下是我们将涵盖的主题：
- en: Creating REST API for a blog in PHP
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在PHP中为博客创建REST API
- en: Creating a database schema
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据库模式
- en: Blog user/author table schema
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 博客用户/作者表模式
- en: Blog post table schema
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 博客帖子表模式
- en: Blog post comments schema
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 博客帖子评论模式
- en: Creating REST API's endpoint
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建REST API的端点
- en: Code structure
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码结构
- en: Common components
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见组件
- en: Creating blog post endpoints
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建博客文章端点
- en: To do
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要做
- en: Visible flaws
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可见的缺陷
- en: Validation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证
- en: Authentication
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证
- en: Proper 404 pages
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确的404页面
- en: Summary
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摘要
- en: Creating a REST API for a blog in PHP
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PHP中为博客创建REST API
- en: To create REST API or RESTful web service for a blog, we first need to have
    blog entities. As we will be storing blog entities in a database and fetching
    the data from a database, we first need to create a database schema for those
    entities.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要为博客创建REST API或RESTful网络服务，我们首先需要有博客实体。由于我们将在数据库中存储博客实体并从数据库中获取数据，因此我们首先需要为这些实体创建数据库模式。
- en: Creating a database schema
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库模式
- en: 'We are going to create endpoints for two resources/entities, which are :'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为两个资源/实体创建端点，它们是：
- en: Blog post
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 博客帖子
- en: Post comments
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帖子评论
- en: So, we will be creating a database schema for these two resources.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将为这两个资源创建数据库模式。
- en: 'Here is how we will design a database schema for a blog having posts and comments.
    A post can have multiple comments and a comment always belongs to post. Here,
    we have SQL for the database schema. You will first need to create a database
    and you will need to run the following SQL to have posts and comments tables.
    If you haven''t created the database, then create it now. You can create it via
    some DB UI tool, or you can run the following SQL query:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们为具有帖子和评论的博客设计数据库模式的方式。一个帖子可以有多个评论，评论始终属于帖子。在这里，我们有数据库模式的SQL。您首先需要创建一个数据库，并且需要运行以下SQL来拥有帖子和评论表。如果您还没有创建数据库，请立即创建。您可以通过一些DB
    UI工具创建它，或者您可以运行以下SQL查询：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will create a database with the name `blog`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`blog`的数据库。
- en: Before creating a blog posts table and a blog post comments table, we will need
    to create a *users* table which will store the post or comment author's information.
    So first, let's create a users table.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建博客帖子表和博客帖子评论表之前，我们需要创建一个*用户*表，该表将存储帖子或评论作者的信息。因此，首先让我们创建一个用户表。
- en: Blog user/author table schema
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 博客用户/作者表模式
- en: 'A users table can have the following fields:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 用户表可以具有以下字段：
- en: '`id`: It will have type integer, which will be unique and will have auto-incremented
    values. `id` will be the primary key of the users table.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：它将具有整数类型，将是唯一的，并且将具有自动增量值。 `id`将是用户表的主键。'
- en: '`name`: It will have type `VARCHAR` with a length of 100 characters. In the
    case of `VARCHAR` 100, 100 characters is the limit. If the title in one entry
    will be less than 100 characters, let''s say only 13 character''s, then it will
    occupy 14 characters space. This is how `VARCHAR` works. It occupies one character
    more than the actual characters in the value.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：它将具有`VARCHAR`类型，长度为100个字符。在`VARCHAR` 100的情况下，100个字符是限制。如果一个条目中的标题少于100个字符，比如只有13个字符，那么它将占用14个字符的空间。这就是`VARCHAR`的工作原理。它占用的空间比值中的实际字符多一个。'
- en: '`email`: Email address will have type `VARCHAR` with a length of 50\. And the
    email field will be unique.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`：电子邮件地址将具有`VARCHAR`类型，长度为50。电子邮件字段将是唯一的。'
- en: '`password`: Password will have type `VARCHAR` with a length of 50\. We will
    be having the `password` field because later, at some stage, we will make the
    user log in using the `email` and `password`.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password`：密码将具有`VARCHAR`类型，长度为50。我们将拥有`password`字段，因为稍后，在某个阶段，我们将使用户使用`email`和`password`登录。'
- en: There can be a lot more fields but for simplicity, we will only keep these fields
    for now.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有更多字段，但为简单起见，我们现在只保留这些字段。
- en: SQL for users table
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户表的SQL
- en: 'The following is the SQL for `users` table. Note, we are using MySQL as RDBMS
    in our example. There can be a slight change in the queries for other databases:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`users`表的SQL。请注意，我们在示例中使用MySQL作为RDBMS。其他数据库的查询可能会有轻微变化：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This query will create a posts table as described above. The only thing that
    we haven't discussed is the database engine. The last line of this query `ENGINE
    = InnoDB` sets the database engine for this table as `InnoDB`. Also, on line 1,
    ``blog`` represents the name of the database. If you have named the database anything
    else other than blog, replace it with your database name.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询将创建一个如上所述的帖子表。我们尚未讨论的唯一事情是数据库引擎。此查询的最后一行`ENGINE = InnoDB`将数据库引擎设置为`InnoDB`。此外，在第1行，``blog``表示数据库的名称。如果您将数据库命名为除blog之外的任何其他名称，请将其替换为您的数据库名称。
- en: We are only going to write the API's endpoint for posts and comments and are
    not going to write the endpoints for users, so we will add data to the users table
    manually using SQL Insert Queries.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只会为帖子和评论编写API的端点，并不会为用户编写端点，因此我们将使用SQL插入查询手动向用户表添加数据。
- en: 'Here are the SQL Insert Queries to populate the `users` table:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于填充`users`表的SQL插入查询：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As we are inserting two records having the `name`, `email`, and `password`,
    we set `id` to `null`. Since it is auto-incremented, it will be set automatically.
    Also, you can see a long random string in both records. This random string is
    the password. We set the same password for both users. However, the user will
    not be entering this random string as the password. This random string is encrypted
    an version of the user''s actual password. The user''s password is `qwerty`. This
    password was encrypted using the following PHP code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在插入两条记录，包括`name`，`email`和`password`，我们将`id`设置为`null`。由于它是自动递增的，它将自动设置。此外，您可以在两条记录中看到一个长随机字符串。这个随机字符串是密码。我们为两个用户设置了相同的密码。但是，用户不会输入这个随机字符串作为密码。这个随机字符串是用户实际密码的加密版本。用户的密码是`qwerty`。这个密码是使用以下PHP代码加密的：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `password_hash()` function is the PHP recommended function for encrypting
    passwords. The first parameter is a `password` string. The second parameter is
    an encryption algorithm. While, the third parameter is an options array where
    we set a random string as salt. You can add a different salt as well.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`password_hash()` 函数是PHP推荐的加密密码函数。第一个参数是`password`字符串。第二个参数是加密算法。而第三个参数是一个选项数组，我们在其中设置一个随机字符串作为盐。您也可以添加不同的盐。'
- en: However, this salt needs to be fixed for encrypting passwords every time because
    this encryption is a one-way encryption. That means the passwords can't be decrypted.
    So every time you need to match passwords, you will always have to encrypt the
    user provided password and match it with the one in the database. In order to
    match the user provided password and the one in the database, we need to use the
    same password function with the same arguments.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个盐需要固定以加密密码，因为这种加密是单向加密。这意味着密码无法解密。因此，每次您需要匹配密码时，您都必须加密用户提供的密码，并将其与数据库中的密码进行匹配。为了匹配用户提供的密码和数据库中的密码，我们需要使用相同的密码函数和相同的参数。
- en: We are not making the user login functionality now, however, we will do that
    later.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会制作用户登录功能，但是以后我们会做。
- en: Blog post table schema
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 博客文章表模式
- en: 'A blog post can have the following fields:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 博客文章可以有以下字段：
- en: '`id` : It will have type integer. It will be unique and have auto-incremented
    values. `id` will be the primary key of the blog post.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：它将是整数类型。它将是唯一的，并且具有自动递增的值。`id`将是博客文章的主键。'
- en: '`title`: It will have type `varchar` with a length of 100 characters. In the
    case of `varchar` 100, 100 characters is the limit. If one post title will be
    less than 100 characters, let''s say a post''s title takes only 13 characters,
    then it will occupy 14 character''s space. It is how `varchar` works. It occupies
    one character more than the actual characters in the field.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：它将是`varchar`类型，长度为100个字符。在`varchar` 100的情况下，100个字符是限制。如果一个帖子标题少于100个字符，比如说一个帖子的标题只有13个字符，那么它将占用14个字符的空间。这就是`varchar`的工作原理。它占用的空间比字段中实际字符多一个字符。'
- en: '`status`: Status will be either published or draft. We will use `enum` for
    it. It has two possible values, `published` and `draft`.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`：状态将是已发布或草稿。我们将使用`enum`。它有两个可能的值，`published`和`draft`。'
- en: '`content`: Content will be the body of the post. We will use the `text` data
    type for the content.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content`：内容将是帖子的正文。我们将使用`text`数据类型来存储内容。'
- en: '`user_id`: `user_id` will be of type integer. It will be a foreign key and
    will relate with the `id` in the users table. This user will be the author of
    the blog post.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_id`：`user_id`将是整数类型。它将是一个外键，并将与用户表中的`id`相关联。这个用户将是博客文章的作者。'
- en: For the sake of simplicity, we will have only these five fields. The `user_id`
    will contain the information of the user who is the author of the post.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们只有这五个字段。 `user_id` 将包含发布者的用户信息。
- en: 'Here is an SQL query for creating a posts table:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于创建帖子表的SQL查询：
- en: 'The following is the SQL for a posts table. Note, we are using MySQL as RDBMS
    in our example. There can be a slight change in the queries for other databases:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于帖子表的SQL。请注意，我们在示例中使用MySQL作为RDBMS。其他数据库的查询可能会有轻微变化：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This query will create a posts table as described earlier.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询将创建一个如前所述的帖子表。
- en: 'Now, we add foreign keys to restrict the `user_id` to have only values which
    are present in the users table. Here is how we will add that constraint:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们添加外键来限制`user_id`只能有用户表中存在的值。以下是我们将添加该约束的方式：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Blog post comments schema
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 博客文章评论模式
- en: 'A blog post comment can have the following fields:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 博客文章评论可以有以下字段：
- en: '`id`: It will have type `integer`. It will be unique and will have auto-incremented
    values. `id` will be the primary key of the blog post.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：它将是`整数`类型。它将是唯一的，并且将具有自动递增的值。`id`将是博客文章的主键。'
- en: '`comment`: It will have type `varchar` with a length of `250` characters.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comment`：它将是`varchar`类型，长度为`250`个字符。'
- en: '`post_id`: `post_id` will be of type integer. It will be the foreign key related
    to the `id` from the posts table.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post_id`：`post_id`将是整数类型。它将是与帖子表中的`id`相关联的外键。'
- en: '`user_id`: `user_id` will be of type `integer`, it will be the foreign key,
    and will relate with the `id` in the users table.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_id`：`user_id` 将是`整数`类型，它将是外键，并将与用户表中的`id`相关联。'
- en: Here, `user_id` is the ID of the author/writer of the comment while `post_id`
    is the ID of the post on which the comment is made.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`user_id`是评论的作者/写作者的ID，而`post_id`是评论所在的帖子的ID。
- en: 'Here is an SQL query for creating a `comments` table:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于创建`comments`表的SQL查询：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Adding foreign key constraints for both `user_id` and `post_id`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为`user_id`和`post_id`添加外键约束：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By running all these SQL queries, you will have most of the DB structure set
    up to proceed toward creating the RESTful API's endpoint in PHP.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行所有这些SQL查询，您将设置好大部分DB结构，以便继续创建PHP中的RESTful API端点。
- en: Creating a RESTful API's endpoint
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建RESTful API端点
- en: 'Before creating the RESTful API''s endpoint specific to resources, let''s first
    create directories in which we will place our code. Create a `blog` directory
    somewhere, your `home` directory, in case Linux is preferable. Then, create an
    `api` directory in the `blog` directory. We will place all our code in the `api`
    directory. If you are a command line fan or a seasoned Ubuntu user, simply run
    the following command to create these directories:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建特定于资源的RESTful API端点之前，让我们首先创建我们将放置代码的目录。在某个地方创建一个`blog`目录，你的`home`目录，在Linux中更可取。然后，在`blog`目录中创建一个`api`目录。我们将把所有的代码放在`api`目录中。如果你是一个命令行爱好者或一个经验丰富的Ubuntu用户，只需运行以下命令来创建这些目录：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So, `api` is the directory where we will place our code. As you know, we are
    going to write code for endpoints related to two resources: blog posts and post
    comments. Before proceeding toward writing code specific to blog posts, let''s
    first see how we are going to structure our code.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`api`是我们将放置代码的目录。正如你所知，我们将编写与两个资源相关的端点的代码：博客文章和文章评论。在继续编写特定于博客文章的代码之前，让我们首先看看我们将如何构建我们的代码结构。
- en: Code structure
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码结构
- en: 'Code can be written in many ways. We can either create different files for
    posts and comments such as `posts.php` and `comments.php` and let the user access
    them from a URL; for example, the user can write: [http://localhost:8000/posts.php](http://localhost:8000/posts.php)
    which can execute code in `posts.php`. The same can also be done in `comments.php`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以以许多方式编写。我们可以创建不同的文件用于文章和评论，比如`posts.php`和`comments.php`，并让用户从URL访问它们；例如，用户可以输入：[http://localhost:8000/posts.php](http://localhost:8000/posts.php)，这将执行`posts.php`中的代码。在`comments.php`中也可以做同样的事情。
- en: 'This is a very simple way but it has two problems:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的方法，但它有两个问题：
- en: The first problem is that `posts.php` and `comments.php` will have different
    code. This means, if we have to use the same code across these different files,
    we will need to either write or include all common things in both these two files.
    In fact, if there will be more resources, then we will need to create a different
    file for every resource and in every new file, we will need to include all that
    common code. Although there are only two resources right now, we also need to
    think for extensibility. So in this approach, we will need to have the same code
    in all the files. Even if we are just doing include or require, we will need to
    do so in all files. However, this can be solved or minimized by having the minimum
    files to include or require.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个问题是`posts.php`和`comments.php`将有不同的代码。这意味着，如果我们必须在这些不同的文件中使用相同的代码，我们将需要在这两个文件中写入或包含所有共同的东西。实际上，如果将会有更多的资源，那么我们将需要为每个资源创建一个不同的文件，并且在每个新文件中，我们将需要包含所有共同的代码。尽管现在只有两个资源，但我们也需要考虑可扩展性。因此，在这种方法中，我们将需要在所有文件中具有相同的代码。即使我们只是在所有文件中进行包含或需要，我们也需要这样做。但是，通过最小化要包含或需要的文件，可以解决或减轻这个问题。
- en: The second problem is related to how it will look in the URL. In the URL, the
    fact file to be used is mentioned, so what if after having our endpoints done
    and the API is given to frontend developers, we need to change the file name on
    the server? The web service from the frontend application will not work unless
    we change the file name in the URL in the frontend application. This points toward
    an important issue about our request and how the things stored on the server.
    So that means our code will be tightly coupled. This shouldn't happen as we stated
    in the constraints of REST in [Chapter 1](42e167df-3aca-4f21-8d1d-c39d5865ab39.xhtml),
    *RESTful Web Services, Introduction and Motivation*. This `.php` extension exposes
    not only that we are using PHP at server side, but also our file structure is
    exposed to everyone who knows the endpoint URL.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个问题与它在URL中的显示方式有关。在URL中，提到要使用的事实文件，所以如果在完成我们的端点并且将API提供给前端开发人员后，我们需要在服务器上更改文件名怎么办？前端应用程序的网络服务将无法正常工作，除非我们在前端应用程序中更改URL中的文件名。这指向了关于我们的请求以及服务器上存储的东西的一个重要问题。这意味着我们的代码将紧密耦合。这不应该发生，因为我们在[第1章](42e167df-3aca-4f21-8d1d-c39d5865ab39.xhtml)中所述的REST的约束中已经说明了。这个`.php`扩展名不仅暴露了我们在服务器端使用PHP，而且我们的文件结构也暴露给了所有知道端点URL的人。
- en: The solution to problem one can be the include and require statements. Although,
    require or include statements will still be required to be in all files, and if
    one include statement needs to be changed in one file, we will need to do it in
    all the files. So, not a good way but the first problem can be solved. However,
    the second problem is a bit more critical. Some of you who have used the `.htaccess`
    file of Apache for URL rewriting will probably be thinking that URL rewriting
    will solve the problem. Yes, it can solve the problem of tight coupling between
    the request URL and the files on the file system but it will work only if we are
    using Apache as a server.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 问题一的解决方案可以是包含和需要语句。尽管，所有文件仍然需要包含或需要语句，如果一个包含语句需要在一个文件中更改，我们将需要在所有文件中进行更改。因此，这不是一个好方法，但第一个问题可以解决。然而，第二个问题更为关键。一些使用Apache的`.htaccess`文件进行URL重写的人可能会认为URL重写可以解决问题。是的，它可以解决请求URL和文件系统上文件之间的紧密耦合的问题，但只有在我们使用Apache作为服务器时才能起作用。
- en: However, with the passage of time, you will see more and more use cases and
    you will realize that this way is not very scalable. In this, we are not following
    some pattern except that we are including the same code in all resource files.
    Also, using `.htaccess` for URL rewriting may work but it is not recommended to
    use it as a complete router because it will have its own limitations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着时间的推移，你会看到越来越多的用例，你会意识到这种方式并不是非常可扩展的。在这种情况下，我们没有遵循任何模式，除了在所有资源文件中包含相同的代码。此外，使用`.htaccess`进行URL重写可能有效，但不建议将其用作完整的路由器，因为它会有自己的局限性。
- en: 'So what is the solution of this? What if we can have a single entry point?
    What if all the requests will go through that same entry point and then route
    toward the appropriate code? That will be a better approach. The request will
    be related to the post or comment, it must go through the same single entry point,
    and at that entry point we can include whatever code we want. That entry point
    will then route the request toward the appropriate code. This will solve both
    problems. Also, things will be in a pattern, as the code for each resource will
    follow the same pattern. This pattern that we just discussed is also known as
    the front controller. You can read more about the front controller at wiki: [https://en.wikipedia.org/wiki/Front_controller](https://en.wikipedia.org/wiki/Front_controller).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know that we will be using the front controller pattern so for that,
    our entry point will be `index.php` file. So let''s create `index.php` in the
    `api` directory. For now, let''s put an echo statement so we can test and run
    and see at least `hello world` using the PHP built-in server. Later, we will add
    proper content in the `index.php` file. So, put this in `index.php` for now:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To test it, you will need to run the PHP built-in server. Note, you don''t
    need to have Apache or NGINX just to run PHP code. PHP has a built-in server and,
    although this is good for testing and the development environment, this is not
    recommended for production use. As we are in the development environment on our
    local machine, let''s run it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will let you hit `http://localhost:8000` and will output `hello World`
    through the PHP built-in server. So now, we are ready to start writing actual
    code to have our RESTful endpoints working.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Common components
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before proceeding toward endpoints, let''s first identify and tackle things
    that we will need in serving all endpoints. Here are those things:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Error reporting settings
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database connection
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Open `index.php`, remove the old hello world code and place this code in the
    `index.php` file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: On the first two lines, we are basically making sure that we can see errors
    if there are errors in our code. The actual magic is happening in the last statement
    where we are requiring `bootstrap.php`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: It is just another file that we are going to create in the `~/blog/core` directory.
    In the blog directory, we are going to create a core directory as we will keep
    a part of the code that is relevant to the flow and pattern of our code execution
    in the core directory. It will be the code that is not relevant to the endpoints
    or logic of our API. This core code will be created once and we can use the same
    core across different applications.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create `bootstrap.php` in the `blog/core` directory. Here is what
    we will write in `bootstrap.php`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Basically, this is going to load everything and execute. `bootstrap.php` is
    the structure of how our application will run. So let's dig into it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The first statement requires a `DB` class from the same directory, that is the
    core directory. The `DB` class is also a core class and it will be responsible
    for DB related stuff. The second statement requires a router that will direct
    the URL to proper files. While the third requires routes telling which file to
    serve in case of which URL.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: We will look into both the `DB` and `Router` classes one by one but let's first
    look at `routes.php` having routes specified. Note that `routes.php` is application
    specific so it's content will vary based on our application URLs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the content of `blog/routes.php`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can see it is just populating a `$routes` array. Here, posts and comments
    are part of the URL that we are expecting and if the URL will have posts, it will
    serve the `posts.php` file, and it will serve `comments.php` if the URL will have
    comments in it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth requirement in `bootstrap.php` is having application configurations
    such as `DB` settings. Here is a sample content of `blog/config.php`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, let's look at the `DB` and `Router` classes one by one so we can understand
    what exactly is going on in `blog/core/bootstrap.php`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐个查看`DB`和`Router`类，这样我们就可以理解`blog/core/bootstrap.php`中到底发生了什么。
- en: DB class
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DB类
- en: 'Here is the code of the `DB` class in `blog/core/DB.php`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`blog/core/DB.php`中`DB`类的代码：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This class is related to the database. Right now, we have a constructor that
    is actually connecting to the database using `PDO` and `$db` arrays defined in
    `blog/config.php`. However, we will add more in this class later.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类与数据库相关。现在，我们有一个构造函数，实际上是使用`blog/config.php`中定义的`PDO`和`$db`数组连接到数据库。但是，我们以后会在这个类中添加更多内容。
- en: 'You can see we are using a `PDO` object here: **PDO** (**PHP Data Objects**).
    It is used to interact with databases and is a recommended one because it doesn''t
    matter which database we want to use, we just need to change the connection string
    and the remaining will work fine. This string: `"mysql:host=$host;dbname=blog"`
    is the connection string. This code in `DB.php` will create a connection with
    the database and this connection will close with the end of the script. We used
    `try catch` here because it is good to use exception handling when anything from
    outside of our code is being triggered.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们在这里使用了一个`PDO`对象：**PDO**（**PHP数据对象**）。它用于与数据库交互，是一个推荐的方法，因为无论我们想使用哪个数据库，我们只需要更改连接字符串，其余的都会正常工作。这个字符串：`"mysql:host=$host;dbname=blog"`是连接字符串。`DB.php`中的这段代码将创建与数据库的连接，并且这个连接将在脚本结束时关闭。我们在这里使用`try
    catch`，因为当我们的代码外部触发任何东西时，使用异常处理是很好的。
- en: Till now, we have looked into the `DB` class, `routes.php` (routes associative
    array), and `config.php` (settings associative array). Now we need to look into
    the content of the `Router` class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经查看了`DB`类，`routes.php`（路由关联数组）和`config.php`（设置关联数组）的内容。现在我们需要查看`Router`类的内容。
- en: Router class
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由器类
- en: 'Here is an implementation of the `Router` class at `blog/core/Router.php`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`blog/core/Router.php`中`Router`类的实现：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`Router` has two methods, `Router::setRoutes(Array $routes)` and `Router::getFilename()`.
    `setRoutes()` is taking an array of routes and storing it. Then, the `getFilename()`
    method is responsible for deciding which file to serve against which URL. We are
    not comparing the whole URL but we are using `strpos()` that checks if the string
    in `$route` exists in `$url` and, if it exists, it returns the appropriate filename.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Router`有两个方法，`Router::setRoutes(Array $routes)`和`Router::getFilename()`。`setRoutes()`接受一个路由数组并将其存储。然后，`getFilename()`方法负责决定对哪个URL提供哪个文件。我们不是比较整个URL，而是使用`strpos()`来检查`$route`中的字符串是否存在于`$url`中，如果存在，则返回适当的文件名。'
- en: Code sync
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码同步
- en: 'To make sure we are on the same page, here is what should be in your `blog`
    directory:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们在同一个页面上，这是你的`blog`目录中应该有的内容：
- en: '`blog`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blog`'
- en: '`blog/config.php`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blog/config.php`'
- en: '`blog/routes.php`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blog/routes.php`'
- en: '`blog/core`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blog/core`'
- en: '`blog/core/DB.php`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blog/core/DB.php`'
- en: '`blog/core/Router.php`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blog/core/Router.php`'
- en: '`blog/core/bootstrap.php`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blog/core/bootstrap.php`'
- en: '`blog/api`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blog/api`'
- en: '`blog/api/index.php`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blog/api/index.php`'
- en: '`blog/api/posts.php`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blog/api/posts.php`'
- en: Note, `blog/api/posts.php` doesn't have any proper content till now, so you
    can keep anything that can be just viewed in the browser so you know that this
    content is coming from `posts.php`. Other than that, if you are missing anything,
    then compare it with the code provided to you with this `book.boostrap.php` review.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`blog/api/posts.php`到目前为止还没有任何适当的内容，所以你可以保留任何可以在浏览器中查看的内容，这样你就知道这个内容来自`posts.php`。除此之外，如果你缺少任何东西，那么就将它与本书提供给你的`book.boostrap.php`进行比较。
- en: 'Anyway, you have seen the content of all files included in `bootstrap.php`,
    so now you can look back at the `bootstrap.php` code to understand things better.
    That content is placed again so you can see it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，你已经看到了`bootstrap.php`中包含的所有文件的内容，所以现在你可以回头看`bootstrap.php`的代码，以更好地理解事情。这些内容再次放在这里，以便你可以看到：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, this is just including the `config` and `routes` files and including
    `Router` and `DB` classes. Here, it is setting the routes coming in `$routes`,
    as written in `routes.php`. And then, based on the URL, it is getting the filename
    which will serve that URL and require that file. We are using `$_SERVER['REQUEST_URI']`;
    it is a super global variable having a URL path that is after the host name.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这只是包含`config`和`routes`文件以及包含`Router`和`DB`类。在这里，它正在设置`$routes`中传入的路由，就像`routes.php`中写的那样。然后，根据URL，它获取将提供该URL的文件名，并要求该文件。我们使用`$_SERVER['REQUEST_URI']`；它是一个超级全局变量，包含主机名之后的URL路径。
- en: 'Till now, we are done with common code making application structure. Now if
    your `blog/api/posts.php` contains code like my `posts.php`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了制作应用程序结构的通用代码。现在，如果你的`blog/api/posts.php`包含了像我的`posts.php`一样的代码：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On starting the PHP server by saying: `php -S localhost:8000` and then in the
    browser hitting: `http://localhost:8000/posts`, you should see: *Posts will come
    here*.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过说：`php -S localhost:8000`来启动PHP服务器，然后在浏览器中输入：`http://localhost:8000/posts`，你应该会看到：*帖子将在这里显示*。
- en: In case you are unable to run it, I would suggest to go back and check what
    you have missed. You can also use the code given to you with this book. In any
    case, it is important to have this code written and running successfully at this
    point because just reading is not enough, practice makes you better.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法运行它，我建议你回去检查你漏掉了什么。你也可以使用本书提供给你的代码。无论如何，现在有必要在这一点上成功地编写和运行这段代码，因为仅仅阅读是不够的，实践会让你变得更好。
- en: Creating blog post endpoints
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建博客文章端点
- en: Till now, we are done with most of the common code. So let's look at blog post
    endpoints. In blog post endpoints, the first one is the blog posts listing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了大部分通用代码。所以让我们来看看博客文章端点。在博客文章端点中，第一个是博客文章列表。
- en: 'Blog posts listing endpoints:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 博客文章列表端点：
- en: 'URI: `/api/posts`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI：`/api/posts`
- en: 'Method: `GET`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法：`GET`
- en: 'So, let''s replace the previous code in `posts.php` with the proper code to
    serve posts. And to serve this, put the following code in the `posts.php` file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们用适当的代码替换`posts.php`中的先前代码来提供帖子。为了提供这个，将以下代码放入`posts.php`文件中：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we are checking if the method is `GET` and the URL is `/posts`, and we
    are getting data from a function named `getAllPosts()`. For the sake of simplicity,
    we are getting data from a hardcoded array instead of a database. However, we
    actually need to get the data from the database. Let''s add the code to get the
    data from the database. Here is what it will look like:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you execute this code, you will get an empty array in JSON format, which
    is fine. An empty array is shown as there is no record in the posts table right
    now. Let's create and use the add post endpoint.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Blog post creation endpoint:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'URI: `/api/posts`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Method: `POST`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameters: `title`, `status`, `content`, `user_id`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we are just making these endpoints work without user authentication so
    we are passing `user_id` by ourselves. So, it should be `id` from users table.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'To have this working, we need to add in `posts.php`. Then new code is mentioned
    in bold:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, we have placed another check, so if the method will be `POST`
    then it will run the `addPost()` method. In the `addPost()` method, `POST` is
    being added. We have used the same `PDO` prepare and execute statements.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: However, this time we have also used `bindValue()`. First, we add a static string
    in the `INSERT` statement with a colon, such as `:title, :status`, and then we
    use a bind statement to bind the variable with those static strings. So what is
    the purpose of doing this? The reason is that we can't trust user input. Directly
    adding user input inside an SQL query can result in SQL injection. So to avoid
    SQL injection, we can use the `PDO::prepare()` function with `PDOStatement::bindValue()`.
    In the `prepare()` function, we provide a string while `bindValue()` binds the
    user input with that string. So, this `PDOStatement::bindValue()` doesn't only
    replace those strings with input parameters but makes sure that SQL injection
    doesn't occur.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: We have also used `PDO::lastInsertId()`. This is to return the auto-incremented
    `id` of the record that was just created.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `addPost()` method, we are using the `bindValue()` method repeatedly
    for different fields. If there will be more fields then we probably need to write
    it even more times repeatedly. To avoid that, we change the `addPost()` method
    code to:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can see `PDOStatement::bindValue()` calls are replaced with one `bindAllValues()`
    function call which takes `PDOStatement` as the first parameter and user input
    as the second parameter. `bindAllValues()` is a custom function that we have written,
    so here is an implementation of the `bindAllValues()` method that we will write
    in the same `posts.php` file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Since we have written it as a separate generic function, we can use it in multiple
    places. Also, no matter how many fields in the posts tables we have, we will not
    need to call the same `PDOStatement::bindValue()` method repeatedly in our code.
    We will just add more fields in the `$allowedFields` array and the `bindValue()`
    method will be called automatically.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: In order to test a `POST` request, we can't simply hit a URL from the browser.
    For testing a `POST` request, we need to use some sort of REST client or create
    and submit a form with `POST`. REST client is a better, easier and simpler way.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: REST client
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the very popular REST clients is Postman. Postman is a Google Chrome
    app. If you are using Chrome, then you can install this app from here: [https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop/related?hl=en](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop/related?hl=en).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you open Postman, you will be able to select the method as POST or any
    other method and, on selecting the Body tab, you will be able to set field names
    and values and then hit Send. Check the following screenshot of Postman having
    fields set and the responses. This will give you an idea about how Postman can
    be used for post requests:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f2c4dc92-00bf-4465-b0c6-2b8aa9f8ae90.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: You can see the POST request has been sent through this Postman and it's result
    is successful as we intended. For all the endpoints testing, Postman can be used.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到通过Postman发送了POST请求，并且结果成功，正如我们所期望的那样。对于所有端点测试，可以使用Postman。
- en: After running this POST based post creation endpoint, we can again test the
    listing of a post's endpoint and it will return data this time as now there is
    a post.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行基于POST的帖子创建端点之后，我们可以再次测试帖子端点的列表，这次它将返回数据，因为现在有一个帖子了。
- en: Let's look into get single post, update post, and delete post's endpoints.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看获取单个帖子、更新帖子和删除帖子的端点。
- en: 'Get single post endpoint:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 获取单个帖子端点：
- en: 'URI: `/api/posts/{id}`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI：`/api/posts/{id}`
- en: 'Method: `GET`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法：`GET`
- en: This URL with a `GET` method should return a single post based on the ID provided.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个带有`GET`方法的URL应该根据提供的ID返回单个帖子。
- en: 'To make it happen, we need to do two things:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要做两件事：
- en: '`Add` a condition where the method is `GET` and the URL is of this pattern.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种模式的情况下，添加一个条件和代码，其中方法是`GET`，URL是这种模式。
- en: We need to write and call the `getPost()` method that fetches a single post
    from the database.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要编写并调用`getPost()`方法，从数据库中获取单个帖子。
- en: We need to add the following code in `posts.php`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`posts.php`中添加以下代码。
- en: 'First, we will add a condition and code to return single post:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加一个条件和代码来返回单个帖子：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, we are checking if the pattern is `/posts/{id}` where `id` can be any
    number. And then we are calling our custom function `getPost()` that will fetch
    the post record from the database. So, here is the `getPost()` implementation
    that we will add in the same `posts.php` file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在检查模式是否为`/posts/{id}`，其中`id`可以是任何数字。然后我们调用我们的自定义函数`getPost()`，它将从数据库中获取帖子记录。因此，这是我们将在同一`posts.php`文件中添加的`getPost()`实现：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code is simply fetching a single record from the database as an associative
    array which can be clearly seen from the last line. Other than that, the `SELECT`
    query and its execution is simple enough.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只是从数据库中获取单个记录作为关联数组，可以从最后一行清楚地看出。除此之外，`SELECT`查询及其执行都足够简单。
- en: 'Update post endpoint:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 更新帖子端点：
- en: 'URI: `/api/posts/{id}`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI：`/api/posts/{id}`
- en: 'Method: `PATCH`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法：`PATCH`
- en: 'Parameters: `title`, `status`, `content`, `user_id`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数：`title`，`status`，`content`，`user_id`
- en: Here `{id}` will be replaced by the actual post's ID. Note, as we are using
    the `PATCH` method, only those attributes should be updated that will be present
    in the input method.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`{id}`将被实际帖子的ID替换。请注意，由于我们使用了`PATCH`方法，因此只应更新输入方法中存在的属性。
- en: Here we are passing `user_id` as a parameter but it is just because we don't
    have authentication working otherwise it is strictly prohibited to pass `user_id`
    as parameter. `user_id` should be the id of authenticated user and that should
    be used instead of getting `user_id` in parameter. Because it can let any user
    pretend to be someone else by passing another `user_id` in parameter.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`user_id`作为参数传递，但这只是因为我们没有进行身份验证，否则严格禁止将`user_id`作为参数传递。`user_id`应该是经过身份验证的用户的ID，并且应该在参数中使用而不是获取`user_id`。因为它可以让任何用户通过在参数中传递另一个`user_id`来假装成其他人。
- en: Please note that while using `PUT` or `PATCH`, parameters should be passed through
    a query string, only `POST` has parameters in the body.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在使用`PUT`或`PATCH`时，参数应通过查询字符串传递，只有`POST`在正文中有参数。
- en: Let's update our code of `posts.php` to support the update operation as well
    and we will then look more into that.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的`posts.php`代码以支持更新操作，然后我们将更深入地研究。
- en: 'Here is the code to add in `posts.php`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要添加到`posts.php`中的代码：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'First, it checks if the URL is of the format : `/posts/{id}` and then checks
    if the `Request` method is `PATCH`. In that case, it calls the `updatePost()`
    method. The `updatePost()` method gets key value pairs as comma separated strings
    through the `getParams()` method. Then make a query, bind values, and `postId`.
    This is very similar to the `INSERT` method. And then in the condition block,
    we echo a JSON encoded form of the record that is updated. This is all very similar
    to what we did in the case of post creation and get single post.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它检查URL是否符合格式：`/posts/{id}`，然后检查`Request`方法是否为`PATCH`。在这种情况下，它调用`updatePost()`方法。`updatePost()`方法通过`getParams()`方法以逗号分隔的字符串形式获取键值对。然后进行查询，绑定值和`postId`。这与`INSERT`方法非常相似。然后在条件块中，我们回显更新的记录的JSON编码形式。这与我们在创建帖子和获取单个帖子的情况下所做的非常相似。
- en: One thing you should note is, we are getting parameters from `$_GET` that are
    query strings. It is because, in the case of `PATCH` and `PUT`, parameters are
    passed in query strings. So while testing through Postman or any other REST client,
    we need to pass parameters in query strings, not the body.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意的一件事是，我们正在从`$_GET`中获取查询字符串的参数。这是因为在`PATCH`和`PUT`的情况下，参数是通过查询字符串传递的。因此，在通过Postman或任何其他REST客户端进行测试时，我们需要在查询字符串中传递参数，而不是在正文中传递。
- en: 'Delete post endpoint:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 删除帖子端点：
- en: 'URI: `/api/posts/{id}`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI：`/api/posts/{id}`
- en: 'Method: `DELETE`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法：`DELETE`
- en: This is very similar to getting a single blog post endpoint but here, the method
    is `DELETE`, so the record will be deleted instead of being viewed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这与获取单个博客帖子端点非常相似，但这里的方法是`DELETE`，因此记录将被删除而不是被查看。
- en: 'Here is the code to add in `posts.php` to delete a blog post record:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要添加到`posts.php`中以删除博客帖子记录的代码：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: After looking at insert, get, and update post's endpoint code, this code is
    very simple. Here, the main work is in the `deletePost()` method but it is also
    very similar to the other methods.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看插入、获取和更新帖子端点的代码之后，这段代码非常简单。在这里，主要工作在于`deletePost()`方法，但它也与其他方法非常相似。
- en: With that, we are now done with posts related to endpoints. However, right now
    all the data that we are returning as JSON it not actually JSON for client(browser
    or Postman). It is still viewing it as a string and considering it as HTML. It
    is because we are returning as JSON but it is still a string. To tell client to
    take it as JSON we need to specify `Content-Type` in header before any output.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在已经完成了与端点相关的帖子。然而，现在我们返回的所有数据都不是真正的JSON，对于客户端（浏览器或Postman）来说，它仍然被视为字符串，并被视为HTML。这是因为我们返回的是JSON，但它仍然是一个字符串。为了告诉客户端将其视为JSON，我们需要在任何输出之前在标头中指定`Content-Type`。
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Just to make sure that our `posts.php` file is the same, here is a complete
    code of `posts.php`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了确保我们的`posts.php`文件是相同的，这里是`posts.php`的完整代码：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note, this code is very basic and it has many flaws that we will see in the
    next chapters. This is just to give you a direction of how you can do it in core
    PHP but this is not the best approach.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这段代码非常基础，它有许多缺陷，我们将在接下来的章节中看到。这只是为了给你一个方向，告诉你如何在核心PHP中做到这一点，但这并不是最佳方法。
- en: To do
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要做的事情
- en: As we are done with Post CRUD endpoints, you need to create the Comments CRUD
    endpoints. It shouldn't be difficult as we have already put comments in routes
    by which you know that we will add `comments.php` similar to `posts.php`. And
    you can also view the logic in the `posts.php` file, as `comments.php` will have
    same operations and will have the similar code. So now, it is your time to code
    for `comments.php` CRUD related endpoints.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经完成了Post CRUD端点，你需要创建Comments CRUD端点。这不应该很困难，因为我们已经在路由中放置了评论，你知道我们将添加`comments.php`类似于`posts.php`。你也可以在`posts.php`文件中查看逻辑，因为`comments.php`将具有相同的操作和类似的代码。所以现在，是你编写`comments.php`
    CRUD相关端点的时候了。
- en: Visible flaws
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可见的缺陷
- en: 'Although the code we discussed in the previous sections will work, there are
    many loopholes in it. We will look into the different problems in the next chapters,
    however here let''s see three of them here and also see how we can solve them:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在前面的章节中讨论的代码将起作用，但其中存在许多漏洞。我们将在接下来的章节中探讨不同的问题，然而在这里让我们看看其中的三个问题，以及如何解决它们：
- en: Validation
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证
- en: Authentication
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证
- en: No response in case of 404
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 404的情况下没有响应
- en: Validation
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: Right now in our code, although we are using `PDO` prepare and `bindValue()`
    methods, it will just save it from SQL injection. However, we are not validating
    all fields in the case of insert and update. We need to validate that the title
    should be of a specific limit, the status should be either draft or published,
    and the `user_id` should be always one of IDs in the users table.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们的代码中，虽然我们使用了`PDO`准备和`bindValue()`方法，它只是保存了我们免受SQL注入的影响。然而，在插入和更新的情况下，我们没有验证所有字段。我们需要验证标题应该是特定限制的，状态应该是草稿或已发布，`user_id`应该始终是用户表中的ID之一。
- en: Solution
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: The first and simple solution is to place manual checks to validate data coming
    from the user's end. This is simple but it is a lot of work. That means it will
    work but we can miss something, and if we do not miss any check, it will be a
    lot of low level detail to deal with.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个简单的解决方案是放置手动检查来验证来自用户端的数据。这很简单，但是工作量很大。这意味着它会起作用，但我们可能会漏掉一些东西，如果我们没有漏掉任何检查，那将是很多低级别的细节要处理。
- en: So a better way is to utilize some open source package or tool already available
    in the community. We will look and use such tools or packages in the upcoming
    chapters. We will also use such packages to validate data in the upcoming chapters.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，更好的方法是利用社区中已经可用的一些开源包或工具。我们将在接下来的章节中寻找并使用这样的工具或包。我们还将在接下来的章节中使用这样的包来验证数据。
- en: In fact, this is not only true about validation, but there is still a lot of
    low level work that we are doing by ourselves in this chapter. So, we will look
    at how we can minimize our efforts on low level stuff by using different tools
    available in the PHP community.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这不仅仅是关于验证的问题，而且在本章中我们仍然在做很多低级别的工作。因此，我们将看看如何通过使用PHP社区中可用的不同工具来最小化我们在低级别工作上的努力。
- en: Authentication
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证
- en: Right now, we are letting anyone add, read, update, and delete any record. It
    is because there is no authenticated user. Once there is an authenticated user,
    we can place different constraints such as that a user shouldn't be able to delete
    or update the content of a different user and so on.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们让任何人都可以添加、读取、更新和删除任何记录。这是因为没有经过身份验证的用户。一旦有了经过身份验证的用户，我们可以放置不同的约束，比如用户不应该能够删除或更新不同用户的内容等等。
- en: So why didn't we simply put in place session based authentication having a **Session
    ID** in an HTTP Only cookie? This is done in traditional websites. We start the
    session, put the user data in session variables and the session ID is stored in
    an HTTPOnly cookie. The server always reads that HTTP Only cookie and gets a session
    ID to know which session data belongs to this user. This is what happens in a
    typical website developed in PHP. So why don't we simply use the same thing for
    authentication in the case of RESTful web services?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么我们不简单地使用基于会话的身份验证，将**Session ID**放在HTTP Only cookie中呢？这在传统网站上是这样做的。我们启动会话，将用户数据放入会话变量中，会话ID存储在HTTPOnly
    cookie中。服务器总是读取那个HTTP Only cookie，并获取会话ID来知道这个用户的会话数据属于哪个用户。这是在PHP开发的典型网站中发生的情况。那么为什么在RESTful
    web服务的情况下，我们不简单地使用相同的方法进行身份验证呢？
- en: Because RESTful web services are not intended to be only called through a web
    browser. It can be anything such as a mobile device, another server, or it can
    be a **SPA** (**Single Page Application**). So, we need a way that can work with
    any of these things.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因为RESTful web服务并不仅仅是通过web浏览器调用。它可以是任何东西，比如移动设备、另一个服务器，或者可以是SPA（单页应用）。因此，我们需要一种可以与任何这些东西一起工作的方式。
- en: Solution
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: A solution is that we will use a simple token, instead of a session ID. And
    instead of cookies, that token will be just sent to the client and the client
    will always take that token in every request to identify the client. Once the
    client is taking the token in every request, it doesn't matter if the client is
    a mobile application, SPA, or anything else. We will simply identify the user
    based on the token.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Now the question is how to create and send back a token? This can be done manually
    but again, why create it if this is already available in open source and tested
    by the community? In fact, in the later chapters, we will use such a package,
    and use tokens for authentication.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Proper 404 pages
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we don't have a proper 404 page if the page or record we are looking for
    doesn't exist. It is because we are not handling this in our router. The router
    is very basic but again, this is low level stuff and we can find such routers
    in open source. We will use this in later chapters as well.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created a basic RESTful web service and provided basic CRUD operations. However,
    there are a lot of issues in the current code which we will see and address in
    the next chapters.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'We have written PHP code to create a basic RESTful web service in this chapter,
    though it is not the best way to do it--this is just to give you a direction.
    Here are some resources from where you can learn to write better PHP code. This
    is a quick reference for PHP best practices: [http://www.phptherightway.com/](http://www.phptherightway.com/).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: To adopt the standard coding style and practice, you can read PHP coding standards
    and style at [http://www.php-fig.org/](http://www.php-fig.org/).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you spend some time on these two URLs so that you can write
    better code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into this in detail and will identify different
    flaws in this code including security and design flaws. And also, look at different
    solutions.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 5\. Design for Least Privilege
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。最小特权设计
- en: By Oliver Barrett, Aaron Joyner, and Rory Ward‎
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：Oliver Barrett，Aaron Joyner和Rory Ward‎
- en: with Guy Fischman and Betsy Beyer
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与Guy Fischman和Betsy Beyer合著
- en: Companies often want to assume their engineers have the best intentions, and
    rely on them to flawlessly execute Herculean tasks. This isn’t a reasonable expectation.
    As a thought exercise, think about the damage you could inflict to your organization
    if you *wanted* to do something evil. What could you do? How would you do it?
    Would you be detected? Could you cover your tracks? Or, even if your intentions
    were good, what’s the worst mistake you (or someone with equivalent access) could
    make? When debugging, responding to an outage, or performing emergency response,
    how many ad hoc, manual commands used by you or your coworkers are one typo or
    copy-paste fail away from causing or worsening an outage?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 公司通常希望假设他们的工程师有最好的意图，并依赖他们无缺地执行艰巨的任务。这不是一个合理的期望。作为一种思考练习，想想如果你*想*做一些邪恶的事情，你可以对你的组织造成什么样的伤害。你能做什么？你会怎么做？你会被发现吗？你能掩盖你的踪迹吗？或者，即使你的意图是好的，你（或具有等效访问权限的人）可能犯下的最严重错误是什么？在调试、应对故障或执行紧急响应时，你或你的同事使用的多少临时手动命令离造成或加剧故障只有一个打字错误或复制粘贴失败的距离？
- en: Because we can’t rely on human perfection, we must assume that any possible
    bad action or outcome can happen. Therefore, we recommend designing the system
    to minimize or eliminate the impact of these bad actions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不能依赖人类的完美，我们必须假设任何可能的坏行为或结果都可能发生。因此，我们建议设计系统以最小化或消除这些坏行为的影响。
- en: Even if we generally trust the humans accessing our systems, we need to limit
    their privilege and the trust we place in their credentials. Things can and will
    go wrong. People will make mistakes, fat-finger commands, get compromised, and
    fall for phishing emails. Expecting perfection is an unrealistic assumption. In
    other words—to quote an SRE maxim—hope is not a strategy.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们通常信任访问我们系统的人类，我们也需要限制他们的特权和我们对他们凭证的信任。事情可能会出错。人们会犯错，误操作命令，被攻击，上当受骗。期望完美是不现实的假设。换句话说，引用SRE的格言——希望不是一种策略。
- en: Concepts and Terminology
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概念和术语
- en: Before we dive into best practices for designing and operating an access control
    system, let’s establish working definitions for some particular terms of art used
    in the industry and at Google.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨设计和操作访问控制系统的最佳实践之前，让我们为行业和谷歌使用的一些特定术语建立工作定义。
- en: Least Privilege
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小特权
- en: '*Least privilege* is a broad concept that’s well established in the security
    industry. The high-level best practices in this chapter can lay the foundations
    of a system that grants the least privilege necessary for any given task or action
    path. This goal applies to the humans, automated tasks, and individual machines
    that a distributed system comprises. The objective of least privilege should extend
    through all authentication and authorization layers of the system. In particular,
    our recommended approach rejects extending implicit authority to tooling (as illustrated
    in [“Worked Example: Configuration Distribution”](#worked_example_configuration_distributi))
    and works to ensure that users don’t have [ambient authority](https://oreil.ly/fF_EA)—for
    example, the ability to log in as root—as much as practically possible.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*最小特权*是安全行业中已经确立的一个广泛概念。本章的高级最佳实践可以为系统奠定为任何特定任务或行动路径授予最小特权的基础。这一目标适用于分布式系统包括的人类、自动化任务和个别机器。最小特权的目标应该贯穿系统的所有身份验证和授权层。特别是，我们推荐的方法拒绝将隐含的权限扩展给工具（如[“工作示例：配置分发”](#worked_example_configuration_distributi)中所示），并努力确保用户尽可能不具有[环境权限](https://oreil.ly/fF_EA)——例如，以root用户登录的能力。'
- en: Zero Trust Networking
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 零信任网络
- en: The design principles we discuss begin with *zero trust networking*—the notion
    that a user’s network location (being within the company’s network) doesn’t grant
    any privileged access. For example, plugging into a network port in a conference
    room does not grant more access than connecting from elsewhere on the internet.
    Instead, a system grants access based on a combination of user credentials and
    device credentials—what we know about the user and what we know about the device.
    Google has successfully implemented a large-scale zero trust networking model
    via its [BeyondCorp program](https://oreil.ly/8x9OJ).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的设计原则始于*零信任网络*——即用户的网络位置（在公司网络内）不授予任何特权访问的概念。例如，在会议室的网络端口插入并不比在互联网其他地方连接获得更多访问权限。相反，系统基于用户凭证和设备凭证的组合来授予访问权限——我们对用户和设备的了解。谷歌通过其[BeyondCorp计划](https://oreil.ly/8x9OJ)成功实施了大规模的零信任网络模型。
- en: Zero Touch
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 零接触
- en: The SRE organization at Google is working to build upon the concept of least
    privilege through automation, with the goal of moving to what we call *Zero Touch*
    interfaces. The specific goal of these interfaces—like Zero Touch Production (ZTP),
    described in [Chapter 3](ch03.html#case_study_safe_proxies), and Zero Touch Networking
    (ZTN)—is to make Google safer and reduce outages by removing direct human access
    to production roles. Instead, humans have indirect access to production through
    tooling and automation that make predictable and controlled changes to production
    infrastructure. This approach requires extensive automation, new safe APIs, and
    resilient multi-party approval systems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌的SRE组织正在努力通过自动化来建立在最小特权概念之上，目标是实现我们所称的*零接触*接口。这些接口的具体目标——比如[第3章](ch03.html#case_study_safe_proxies)中描述的零接触生产（ZTP）和零信任网络（ZTN）——是通过工具和自动化使谷歌更安全，减少故障，从而消除人类对生产角色的直接访问。这种方法需要大量的自动化、新的安全API和弹性的多方批准系统。
- en: Classifying Access Based on Risk
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于风险分类访问
- en: Any risk reduction strategy comes with tradeoffs. Reducing the risk introduced
    by human actors likely entails additional controls or engineering work, and can
    introduce tradeoffs to productivity; it may increase engineering time, process
    changes, operational work, or opportunity cost. You can help limit these costs
    by clearly scoping and prioritizing what you want to protect.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 任何风险降低策略都伴随着权衡。减少人为因素引入的风险可能需要额外的控制或工程工作，并可能会对生产力产生权衡；它可能会增加工程时间，流程变更，运营工作或机会成本。您可以通过明确定义和优先考虑您想要保护的内容来限制这些成本。
- en: Not all data or actions are created equal, and the makeup of your access may
    differ dramatically depending on the nature of your system. Therefore, you shouldn’t
    protect all access to the same degree. In order to apply the most appropriate
    controls and avoid an all-or-nothing mentality, you need to classify access based
    on impact, security risk, and/or criticality. For example, you likely need to
    handle access to different types of data (publicly available data versus company
    data versus user data versus cryptographic secrets) differently. Similarly, you
    likely need to treat administrative APIs that can delete data differently than
    service-specific read APIs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有数据或操作都是平等的，您的访问组成可能会根据系统的性质而有很大不同。因此，您不应该以相同程度保护所有访问。为了应用最合适的控制措施并避免全有或全无的心态，您需要根据影响，安全风险和/或重要性对访问进行分类。例如，您可能需要以不同方式处理对不同类型数据（公开可用数据与公司数据与用户数据与加密密钥）的访问。同样，您可能需要以不同方式处理可以删除数据的管理API与特定服务的读取API。
- en: 'Your classifications should be clearly defined, consistently applied, and broadly
    understood so people can design systems and services that “speak” that language.
    Your classification framework will vary based on the size and complexity of your
    system: you may need only two or three types that rely on ad hoc labeling, or
    you may need a robust and programmatic system for classifying parts of your system
    (API groupings, data types) in a central inventory. These classifications may
    apply to data stores, APIs, services, or other entities that users may access
    in the course of their work. Ensure that your framework can handle the most important
    entities within your systems.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您的分类应该清晰定义，一贯应用，并广泛理解，以便人们可以设计“讲”这种语言的系统和服务。您的分类框架将根据系统的大小和复杂性而变化：您可能只需要依赖临时标记的两种或三种类型，或者您可能需要一个强大和程序化的系统来对系统的部分（API分组，数据类型）进行分类。这些分类可能适用于用户在工作过程中可能访问的数据存储，API，服务或其他实体。确保您的框架可以处理系统中最重要的实体。
- en: 'Once you’ve established a foundation of classification, you should consider
    the controls in place for each. You need to consider several dimensions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您建立了分类的基础，您应该考虑每个分类中的控制措施。您需要考虑几个方面：
- en: Who should have access?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁应该有访问权限？
- en: How tightly should that access be controlled?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该访问应该受到多大程度的控制？
- en: What type of access does the user need (read/write)?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户需要什么类型的访问（读/写）？
- en: What infrastructure controls are in place?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施控制措施是什么？
- en: 'For example, as shown in [Table 5-1](#example_access_classifications_based_on),
    a company may need three classifications: *public*, *sensitive*, and *highly sensitive*.
    That company might categorize security controls as *low risk*, *medium risk*,
    or *high risk* by the level of damage the access can allow if granted inappropriately.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如[表5-1](#example_access_classifications_based_on)所示，一家公司可能需要三种分类：*公开*，*敏感*和*高度敏感*。该公司可能会根据访问如果被不当授予可能造成的损害程度，将安全控制分类为*低风险*，*中风险*或*高风险*。
- en: Table 5-1\. Example access classifications based on risk
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 表5-1。基于风险的访问分类示例
- en: '|  | Description | Read access | Write access | Infrastructure access^([a](ch05.html#ch05fn1))
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|  | 描述 | 读取访问 | 写入访问 | 基础设施访问^([a](ch05.html#ch05fn1)) |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **Public** | Open to anyone in the company | Low risk | Low risk | High risk
    |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **公开** | 对公司内任何人开放 | 低风险 | 低风险 | 高风险 |'
- en: '| **Sensitive** | Limited to groups with business purpose | Medium/high risk
    | Medium risk | High risk |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **敏感** | 仅限于具有业务目的的群体 | 中/高风险 | 中风险 | 高风险 |'
- en: '| **Highly sensitive** | No permanent access | High risk | High risk | High
    risk |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **高度敏感** | 无永久访问 | 高风险 | 高风险 | 高风险 |'
- en: '| ^([a](ch05.html#ch05fn1-marker)) Administrative ability to bypass normal
    access controls. For example, the ability to reduce logging levels, change encryption
    requirements, gain direct SSH access to a machine, restart and reconfigure service
    options, or otherwise affect the availability of the service(s). |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch05.html#ch05fn1-marker)) 绕过正常访问控制的管理能力。例如，减少日志级别，更改加密要求，获得对机器的直接SSH访问，重新启动和重新配置服务选项，或以其他方式影响服务的可用性。
    |'
- en: Your goal should be to construct an access framework from which you can apply
    appropriate controls with the right balance of productivity, security, and reliability.
    Least privilege should apply across all data access and actions. Working from
    this foundational framework, let’s discuss how to design your systems with the
    principles and controls for least privilege.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您的目标应该是构建一个访问框架，从中您可以应用适当的控制，以实现生产力，安全性和可靠性的正确平衡。最小特权应该适用于所有数据访问和操作。基于这个基础框架，让我们讨论如何设计具有最小特权原则和控制的系统。
- en: Best Practices
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: When implementing a least privilege model, we recommend several best practices,
    detailed here.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施最小特权模型时，我们建议遵循这里详细介绍的几项最佳实践。
- en: Small Functional APIs
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小型功能API
- en: Make each program do one thing well. To do a new job, build afresh rather than
    complicate old programs by adding new “features.”
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使每个程序都做一件事情。要做一项新工作，最好重新构建，而不是通过添加新的“功能”来使旧程序变得复杂。
- en: '>'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: —McIlroy, Pinson, and Tague (1978)^([1](ch05.html#ch05fn2))
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —McIlroy, Pinson, and Tague (1978)^([1](ch05.html#ch05fn2))
- en: As this quote conveys, Unix culture centers around small and simple tools that
    can be combined. Because modern distributed computing evolved from the single
    time-shared computing systems of the 1970s into planet-wide network-connected
    distributed systems, the authors’ advice still rings true more than 40 years later.
    To adapt this quote to the current computing environment, one might say, “Make
    each API endpoint do one thing well.” When building systems with an eye toward
    security and reliability, avoid open-ended interactive interfaces—instead, design
    around small functional APIs. This approach allows you to apply the classic security
    principle of least privilege and grant the minimum permissions necessary to perform
    a particular function.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这句引语所传达的，Unix文化的核心是围绕着可以组合的小而简单的工具。因为现代分布式计算是从20世纪70年代的单一时间共享计算系统发展而来的，演变成了全球范围内连接的分布式系统，所以作者的建议在40多年后仍然是正确的。为了适应当前的计算环境，人们可能会说，“让每个API端点都做好一件事。”在构建系统时，要考虑安全性和可靠性，避免开放式的交互式接口，而是设计小型的功能性API。这种方法使您能够应用最小权限的经典安全原则，并授予执行特定功能所需的最低权限。
- en: 'What exactly do we mean by *API*? Every system has an API: it is simply the
    user interface the system presents. Some APIs are very large (such as the POSIX
    API^([2](ch05.html#ch05fn3)) or the Windows API^([3](ch05.html#ch05fn4))), some
    are relatively small (such as memcached^([4](ch05.html#ch05fn5)) and NATS^([5](ch05.html#ch05fn6))),
    and some are downright tiny (such as the [World Clock API](http://worldclockapi.com),
    TinyURL,^([6](ch05.html#ch05fn7)) and the Google Fonts API^([7](ch05.html#ch05fn8))).
    When we talk about the API of a distributed system, we simply mean the sum of
    all the ways you can query or modify its internal state. API design has been well
    covered in computing literature;^([8](ch05.html#ch05fn9)) this chapter focuses
    on how you can design and safely maintain secure systems by exposing API endpoints
    with few well-defined primitives. For example, the input you evaluate might be
    CRUD (Create, Read, Update, and Delete) operations on a unique ID, rather than
    an API that accepts a programming language.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的*API*究竟是什么意思？每个系统都有一个API：它只是系统呈现的用户界面。有些API非常大（比如POSIX API或Windows API），有些相对较小（比如memcached和NATS），有些非常小（比如World
    Clock API、TinyURL和Google Fonts API）。当我们谈论分布式系统的API时，我们只是指您可以查询或修改其内部状态的所有方式的总和。API设计在计算文献中已经得到很好的覆盖；本章重点介绍如何通过暴露具有少量明确定义基元的API端点来设计和安全地维护安全系统。例如，您评估的输入可能是对唯一ID的CRUD（创建、读取、更新和删除）操作，而不是接受编程语言的API。
- en: In addition to the user-facing API, pay careful attention to the administrative
    API. The administrative API is equally important (arguably, more important) to
    the reliability and security of your application. Typos and mistakes when using
    these APIs can result in catastrophic outages or expose huge amounts of data.
    As a result, administrative APIs are also some of the most attractive attack surfaces
    for malicious actors.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了面向用户的API，还要特别关注管理API。管理API对于应用程序的可靠性和安全性同样重要（可以说更重要）。在使用这些API时出现拼写错误和错误可能导致灾难性的中断或暴露大量数据。因此，管理API也是恶意行为者最感兴趣的攻击面之一。
- en: 'Administrative APIs are accessed only by internal users and tooling, so relative
    to user-facing APIs, they can be faster and easier to change. Still, after your
    internal users and tooling start building on any API, there will still be a cost
    to changing it, so we recommend carefully considering their design. Administrative
    APIs include the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 管理API只能由内部用户和工具访问，因此相对于面向用户的API，它们可能更快速和更容易更改。然而，一旦内部用户和工具开始构建任何API，更改它仍然会有成本，因此我们建议仔细考虑其设计。管理API包括以下内容：
- en: Setup/teardown APIs, such as those used to build, install, and update software
    or provision the container(s) it runs in
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置/拆卸API，例如用于构建、安装和更新软件或提供其运行的容器的API
- en: Maintenance and emergency APIs, such as administrative access to delete corrupted
    user data or state, or to restart misbehaving processes
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护和紧急API，例如管理访问以删除损坏的用户数据或状态，或重新启动行为不端的进程
- en: 'Does the size of an API matter when it comes to access and security? Consider
    a familiar example: the POSIX API, one of our previous examples of a very large
    API. This API is popular because it is flexible and familiar to many people. As
    a production machine management API, it is most often used for relatively well-defined
    tasks such as installing a software package, changing a configuration file, or
    restarting a daemon.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问和安全性方面，API的大小是否重要？考虑一个熟悉的例子：POSIX API，这是我们之前提到的一个非常大的API。这个API很受欢迎，因为它灵活并且为许多人所熟悉。作为一个生产机器管理API，它通常用于相对明确定义的任务，比如安装软件包、更改配置文件或重新启动守护进程。
- en: Users often perform traditional Unix^([9](ch05.html#ch05fn11)) host setup and
    maintenance via an interactive OpenSSH session or with tools that script against
    the POSIX API. Both approaches expose the entire POSIX API to the caller. It can
    be difficult to constrain and audit a user’s actions during that interactive session.
    This is especially true if the user is maliciously attempting to circumvent the
    controls, or if the connecting workstation is compromised.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通常通过交互式的OpenSSH会话或使用针对POSIX API的脚本工具执行传统的Unix主机设置和维护。这两种方法都向调用者公开整个POSIX API。在交互式会话期间难以限制和审计用户的操作。特别是如果用户恶意尝试规避控制，或者连接的工作站受到损害。
- en: You can use various mechanisms to limit the permissions granted to the user
    via the POSIX API,^([10](ch05.html#ch05fn12)) but that necessity is a fundamental
    shortcoming of exposing a very large API. Instead, it’s better to reduce and decompose
    this large administrative API into smaller pieces. You can then follow the principle
    of least privilege to grant permission only to the specific action(s) required
    by any particular caller.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用各种机制来限制通过POSIX API授予用户的权限^([10](ch05.html#ch05fn12))，但这是暴露非常庞大的API的基本缺陷。相反，最好将这个庞大的管理API减少和分解成更小的部分。然后，您可以遵循最小权限原则，仅授予特定调用者所需的特定操作的权限。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The exposed POSIX API should not be confused with the OpenSSH API. It is possible
    to leverage the OpenSSH protocol and its authentication, authorization, and auditing
    (AAA) controls without exposing the entire POSIX API; for example, using [git-shell](https://oreil.ly/gN12-).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 暴露的POSIX API不应与OpenSSH API混淆。可以利用OpenSSH协议及其身份验证、授权和审计（AAA）控件，而无需暴露整个POSIX API；例如，使用[git-shell](https://oreil.ly/gN12-)。
- en: Breakglass
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 紧急功能
- en: Named after fire alarm pulls that instruct the user to “break glass in case
    of emergency,” a *breakglass mechanism* provides access to your system in an emergency
    situation and bypasses your authorization system completely. This can be useful
    for recovering from unforeseen circumstances. For more context, see [“Graceful
    Failure and Breakglass Mechanisms”](#graceful_failure_and_breakglass_mechani)
    and [“Diagnosing Access Denials”](#diagnosing_access_denials).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以火警拉环的名字命名，指示用户“在紧急情况下打破玻璃”的*紧急功能机制*在紧急情况下提供对系统的访问，并完全绕过您的授权系统。这对于从意想不到的情况中恢复很有用。有关更多上下文，请参见[“优雅失败和紧急功能机制”](#graceful_failure_and_breakglass_mechani)和[“诊断访问拒绝”](#diagnosing_access_denials)。
- en: Auditing
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审计
- en: '*Auditing* primarily serves to detect incorrect authorization usage. This can
    include a malicious system operator abusing their powers, a compromise of a user’s
    credentials by an external actor, or rogue software taking unexpected actions
    against another system. Your ability to audit and meaningfully detect the signal
    in the noise is largely dependent on the design of the systems you’re auditing:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*审计*主要用于检测错误的授权使用。这可能包括恶意系统操作员滥用其权力，外部参与者窃取用户凭据，或者恶意软件对另一个系统采取意外行动。您对审计和有意义地检测噪音中的信号的能力在很大程度上取决于您审计的系统的设计：'
- en: How granular is the access control decision being made or bypassed? (*What?
    Where?*)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问控制决策的粒度有多大，或者是否被绕过？（*什么？在哪里？*）
- en: How clearly can you capture the metadata associated with the request? (*Who?
    When? Why?*)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您能清楚地捕获与请求相关的元数据吗？（*谁？何时？为什么？*）
- en: The following tips will help in crafting a sound auditing strategy. Ultimately,
    your success will also depend on the culture associated with auditing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下提示将有助于制定健全的审计策略。最终，您的成功也将取决于与审计相关的文化。
- en: Collecting good audit logs
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收集良好的审计日志
- en: Using small functioning APIs (as discussed in [“Small Functional APIs”](#small_functional_apis))
    provides the largest single advantage to your auditing ability. The most useful
    audit logs capture a granular series of actions, such as “pushed a config with
    cryptographic hash 123DEAD...BEEF456” or “executed `<x>` command.” Thinking about
    how to display and justify your administrative actions to your customers can also
    help make your audit logs more descriptive, and thus more useful internally. Granular
    audit log information enables strong assertions about what actions the user did
    or did not take, but be sure to focus on capturing the *useful* parts of the actions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用小型功能API（如[“小型功能API”](#small_functional_apis)中讨论的）对您的审计能力提供了最大的单一优势。最有用的审计日志捕获了一系列细粒度的操作，例如“推送了一个带有密码哈希123DEAD...BEEF456的配置”或“执行了`<x>`命令”。考虑如何向客户显示和证明您的管理操作也有助于使您的审计日志更具描述性，从而在内部更有用。细粒度的审计日志信息使您能够对用户执行或未执行的操作做出强有力的断言，但一定要专注于捕获*有用*部分的操作。
- en: 'Exceptional circumstances require exceptional access, which requires a strong
    culture of auditing. If you discover that the existing small functional API surfaces
    are insufficient to recover the system, you have two options:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊情况需要特殊访问权限，这需要强大的审计文化。如果您发现现有的小型功能API界面不足以恢复系统，您有两个选择：
- en: Provide breakglass functionality that allows a user to open an interactive session
    to the powerful and flexible API.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供紧急功能，允许用户打开与强大且灵活的API的交互式会话。
- en: Allow the user to have direct access to credentials in a way that precludes
    reasonable auditing of their usage.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户以一种无法合理审计其使用情况的方式直接访问凭据。
- en: 'In either of these scenarios, you may be unable to build a granular audit trail.
    Logging that the user opened an interactive session to a large API does not meaningfully
    tell you what they did. A motivated and knowledgeable insider can trivially bypass
    many solutions that capture session logs of interactive sessions, such as recording
    bash command history. Even if you can capture a full session transcript, effectively
    auditing it may be quite difficult: visual applications using ncurses need to
    be replayed to be human-readable, and features such as SSH multiplexing can further
    complicate capturing and understanding the interleaved state.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，您可能无法构建粒度细致的审计跟踪。记录用户打开与大型API的交互式会话并不能有意义地告诉您他们做了什么。一个有动机和知识的内部人员可以轻松地绕过许多捕获交互式会话的会话日志的解决方案，例如记录bash命令历史。即使您可以捕获完整的会话记录，有效地审计它可能会非常困难：使用ncurses的可视应用程序需要重播才能被人类读取，并且诸如SSH多路复用之类的功能可能进一步复杂化捕获和理解交织状态。
- en: The antidote to overly broad APIs and/or frequent breakglass use is to foster
    a culture that values careful auditing. This is critical both for reliability
    reasons and security reasons, and you can use both motivations to appeal to the
    responsible parties. Two pairs of eyes help avoid typos and mistakes, and you
    should always safeguard against unilateral access to user data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对过于宽泛的API和/或频繁的紧急访问的解药是培养重视仔细审计的文化。这对可靠性和安全性都至关重要，你可以利用这两种动机来吸引负责任的人。两双眼睛有助于避免拼写错误和错误，你应该始终防范对用户数据的单方面访问。
- en: Ultimately, the teams building the administrative APIs and automation need to
    design them in a way that facilitates auditing. Anyone who regularly accesses
    production systems should be incentivized to solve these problems collaboratively
    and to understand the value of a good audit log. Without cultural reinforcement,
    audits can become rubber stamps, and breakglass use can become an everyday occurrence,
    losing its sense of importance or urgency. Culture is the key to ensuring that
    teams choose, build, and use systems in ways that support auditing; that these
    events occur only rarely; and that audit events receive the scrutiny they deserve.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，建立管理API和自动化的团队需要以促进审计的方式设计它们。经常访问生产系统的人应该有动力共同解决这些问题，并理解良好审计日志的价值。如果没有文化的强化，审计可能会变成橡皮图章，而紧急访问可能会变成每天的事情，失去了其重要性或紧迫性。文化是确保团队选择、构建和使用支持审计的系统的关键；这些事件只会偶尔发生；审计事件得到应有的审查。
- en: Choosing an auditor
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择审计员
- en: Once you have collected a good audit log, you need to choose the right person
    to inspect the (hopefully rare) recorded events. An auditor needs to have both
    the right context and the right objective.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你收集了一个良好的审计日志，你需要选择合适的人来检查（希望是罕见的）记录事件。审计员需要具有正确的上下文和正确的目标。
- en: 'When it comes to context, an auditor needs to know what a given action does,
    and ideally why the actor needed to perform that action. The auditor will therefore
    usually be a teammate, a manager, or someone familiar with the workflows that
    require that action. You’ll need to strike a balance between sufficient context
    and objectivity: while an internal reviewer might have a close personal relationship
    with the person who generated the audit event and/or want the organization to
    succeed, an external private auditor may want to continue to be hired by an organization.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文方面，审计员需要知道特定操作的作用，最好知道执行该操作的原因。因此，审计员通常会是一个队友、经理或熟悉需要执行该操作的工作流程的人。你需要在充分的上下文和客观性之间取得平衡：虽然内部审查员可能与生成审计事件的人有密切的个人关系和/或希望组织取得成功，但外部私人审计员可能希望继续受雇于一个组织。
- en: 'Choosing an auditor with the right objective depends on the purpose of the
    audit. At Google, we perform two broad categories of auditing:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 选择具有正确目标的审计员取决于审计的目的。在谷歌，我们进行两种广泛的审计：
- en: Audits to ensure best practices are being followed
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计以确保遵循最佳实践
- en: Audits to identify security breaches
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计以识别安全漏洞
- en: Generally speaking, “best practice” audits support our reliability objectives.
    For example, an SRE team might choose to audit breakglass events from the last
    week’s on-call shift during a weekly team meeting. This practice provides a cultural
    peer pressure to use and improve smaller service administrative APIs, rather than
    using a breakglass mechanism to access a more flexible emergency-use API. Widely
    scoped breakglass access often bypasses some or all safety checks, exposing the
    service to a higher potential for human error.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，“最佳实践”审计支持我们的可靠性目标。例如，一个SRE团队可能会选择在每周团队会议期间审计上周的紧急访问事件。这种做法提供了一种文化上的同行压力，以使用和改进更小的服务管理API，而不是使用紧急使用API来访问更灵活的紧急使用API。广泛范围的紧急访问通常会绕过一些或全部安全检查，使服务面临更高的人为错误风险。
- en: Google typically distributes breakglass reviews down to the team level, where
    we can leverage the social norming that accompanies team review. Peers performing
    the review have context that enables them to spot even very well-disguised actions,
    which is key to preventing internal abuses and thwarting malicious insiders. For
    example, a peer is well equipped to notice if a coworker repeatedly uses a breakglass
    action to access an unusual resource that they likely don’t actually need. This
    type of team review also helps identify shortcomings in administrative APIs. When
    breakglass access is required for a specific task, it often signals a need to
    provide a safer or more secure way to perform that task as part of the normal
    API. You can read more about this subject in [Chapter 21](ch21.html#twoone_building_a_culture_of_security_a).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌通常将紧急访问审查下放到团队级别，这样我们就可以利用伴随团队审查的社会规范。进行审查的同行具有上下文，使他们能够发现即使是伪装得很好的行为，这对于防止内部滥用和阻止恶意内部人员至关重要。例如，同事很容易注意到如果一个同事反复使用紧急访问操作来访问一个他们可能实际上并不需要的不寻常资源。这种团队审查还有助于发现管理API的不足。当特定任务需要紧急访问时，通常表明需要提供一种更安全或更安全的方式来执行该任务作为正常API的一部分。您可以在[第21章](ch21.html#twoone_building_a_culture_of_security_a)中阅读更多关于这个主题的内容。
- en: At Google we tend to centralize the second type of audit, as identifying external
    security breaches benefits from a broad view of the organization. An advanced
    attacker may compromise one team, and then use that access to compromise another
    team, service, or role. Each individual team may not notice a couple of anomalous
    actions, and doesn’t have the cross-team view to connect the dots between different
    sets of actions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在谷歌，我们倾向于集中第二类审计，因为识别外部安全漏洞有利于对组织的广泛视野。一个高级攻击者可能会侵入一个团队，然后利用该访问来侵入另一个团队、服务或角色。每个单独的团队可能不会注意到一些异常的行为，并且没有跨团队的视野来连接不同的行为集。
- en: A central auditing team may also be equipped to build extra signaling and add
    code for additional audit events that aren’t widely known. These types of tripwires
    can be especially useful in early detection, but you may not want to share their
    implementation details widely. You may also need to work with other departments
    in your organization (such as Legal and HR), to ensure that auditing mechanisms
    are appropriate, properly scoped, and documented.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 中央审计团队也可以配备额外的信号和添加代码以进行额外的审计事件，这些事件可能并不广为人知。这些类型的警报在早期检测中可能特别有用，但您可能不希望广泛共享其实施细节。您可能还需要与组织中的其他部门（如法律和人力资源）合作，以确保审计机制是适当的、范围适当的并且有文档记录。
- en: We at Google associate structured data with audit log events using *structured
    justification*. When an event that generates an audit log occurs, we can associate
    it with a structured reference such as a bug number, ticket number, or customer
    case number. Doing so allows us to build programmatic checks of the audit logs.
    For example, if support personnel look at a customer’s payment details or other
    sensitive data, they can associate that data to a particular customer case. Therefore,
    we can ensure that the observed data belongs to the customer that opened the case.
    It would be much harder to automate log verification if we relied upon free-text
    fields. Structured justification has been key to scaling our auditing efforts—it
    provides a centralized auditing team context that’s critical to effective auditing
    and analysis.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在谷歌使用*结构化理由*将审计日志事件与结构化数据关联起来。当发生生成审计日志的事件时，我们可以将其与结构化引用（例如bug编号、工单编号或客户案例编号）关联起来。这样做可以让我们构建审计日志的程序检查。例如，如果支持人员查看客户的付款详情或其他敏感数据，他们可以将这些数据与特定客户案例相关联。因此，我们可以确保观察到的数据属于开启案例的客户。如果我们依赖自由文本字段，要自动化日志验证将会更加困难。结构化理由对于扩展我们的审计工作至关重要，它为中央审计团队提供了关键的上下文，对于有效的审计和分析至关重要。
- en: Testing and Least Privilege
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试和最小权限
- en: 'Proper testing is a fundamental property of any well designed system. Testing
    has two important dimensions with regard to least privilege:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 适当的测试是任何良好设计系统的基本属性。测试在最小权限方面有两个重要的维度：
- en: Testing *of* least privilege, to ensure that access is properly granted only
    to necessary resources
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小权限的测试，以确保访问仅被正确授予必要的资源
- en: Testing *with* least privilege, to ensure that the infrastructure for testing
    has only the access it needs
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小权限的测试，以确保测试基础设施只具有其所需的访问权限
- en: Testing of least privilege
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小权限的测试
- en: In the context of least privilege, you need to be able to test that well-defined
    user profiles (i.e., data analyst, customer support, SRE) have enough privileges
    to perform their role, but no more.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在最小权限的背景下，您需要能够测试明确定义的用户配置文件（例如，数据分析师、客户支持、SRE）是否具有足够的权限来执行其角色，但不会过多。
- en: 'Your infrastructure should let you do the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您的基础设施应该让您做到以下几点：
- en: Describe what a specific user profile needs to be able to do in their job role.
    This defines the minimal access (APIs and data) and the type of access (read or
    write, permanent or temporary) they need for their role.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述特定用户配置文件在其工作角色中需要能够做什么。这定义了他们在角色中所需的最小访问权限（API和数据）以及访问类型（读或写，永久或临时）。
- en: Describe a set of scenarios in which the user profile attempts an action on
    your system (i.e., read, bulk read, write, delete, bulk delete, administer) and
    an expected result/impact on your system.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述一组场景，在这些场景中，用户配置文件尝试在您的系统上执行操作（例如读取、批量读取、写入、删除、批量删除、管理），并描述对您的系统的预期结果/影响。
- en: Run these scenarios and compare the actual result/impact against the expected
    result/impact.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行这些场景，并将实际结果/影响与预期结果/影响进行比较。
- en: Ideally, to prevent adverse effects on production systems, these are tests that
    run before code or ACL changes. If test coverage is incomplete, you can mitigate
    overly broad access via monitoring of access and alerting systems.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，为了防止对生产系统产生不利影响，这些测试应该在代码或ACL更改之前运行。如果测试覆盖不完整，您可以通过监控访问和警报系统来减轻过于广泛的访问。
- en: Testing with least privilege
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小权限的测试
- en: Tests should allow you to verify the expected read/write behavior without putting
    service reliability, sensitive data, or other critical assets at risk. However,
    if you don’t have proper test infrastructure in place—infrastructure that accounts
    for varied environments, clients, credentials, data sets, etc.—tests that need
    to read/write data or mutate service state can be risky.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该允许您验证预期的读/写行为，而不会危及服务的可靠性、敏感数据或其他关键资产。但是，如果您没有适当的测试基础设施，即考虑到各种环境、客户端、凭证、数据集等的基础设施，那么需要读/写数据或改变服务状态的测试可能会带来风险。
- en: Consider the example of pushing a configuration file to production, which we’ll
    return to in the next section. As your first step in designing a testing strategy
    for this configuration push, you should provide a separate environment keyed with
    its own credentials. This setup ensures that a mistake in writing or executing
    a test won’t impact production—for example, by overwriting production data or
    bringing down a production service.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑将配置文件推送到生产环境的示例，我们将在下一节中返回到这个示例。在为此配置推送设计测试策略的第一步是提供一个使用自己凭证的单独环境。这样的设置可以确保在编写或执行测试时出现错误不会影响生产环境，例如覆盖生产数据或使生产服务崩溃。
- en: Alternately, let’s say you’re developing a keyboard app that allows people to
    post memes with one click. You want to analyze users’ behavior and history so
    you can automatically recommend memes. Lacking a proper test infrastructure, you
    instead need to give data analysts read/write access to an entire set of raw user
    data in production to perform analysis and testing.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，假设您正在开发一个键盘应用程序，允许用户一键发布表情包。您希望分析用户的行为和历史，以便自动推荐表情包。如果缺乏适当的测试基础设施，您需要在生产环境中给数据分析师读/写访问权限，以执行分析和测试。
- en: Proper testing methodology should consider ways to restrict user access and
    decrease risk, but still allow the data analysts to perform the tests they need
    to do their job. Do they need write access? Can you use anonymized data sets for
    the tasks they need to perform? Can you use test accounts? Can you operate in
    a test environment with anonymized data? If this access is compromised, what data
    is exposed?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 适当的测试方法应考虑限制用户访问和降低风险的方式，但仍允许数据分析师执行他们需要完成工作的测试。他们需要写入权限吗？您可以使用匿名化的数据集来执行他们需要执行的任务吗？您可以使用测试账户吗？您可以在具有匿名化数据的测试环境中操作吗？如果此访问受到威胁，哪些数据会被暴露？
- en: You can approach test infrastructure by starting small—don’t let perfect be
    the enemy of good. Start by thinking about ways you can most easily
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从小处开始来处理测试基础设施——不要让完美成为良好的敌人。首先考虑您最容易实现的方式
- en: Separate environments and credentials
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离环境和凭证
- en: Limit the types of access
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制访问类型
- en: Limit the exposure of data
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制数据的暴露
- en: Initially, perhaps you can stand up short-lived tests on a cloud platform instead
    of building out an entire test infrastructure stack. Some employees may need only
    read or temporary access. In some cases, you may also be able to use representative
    or anonymized data sets.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，也许您可以在云平台上快速进行短暂的测试，而不是构建整个测试基础设施堆栈。一些员工可能只需要读取或临时访问。在某些情况下，您还可以使用代表性或匿名化的数据集。
- en: 'While these testing best practices sound great in theory, at this point, you
    may be getting overwhelmed by the potential cost of building out a proper test
    infrastructure. Getting this right isn’t cheap. However, consider the cost of
    *not* having a proper test infrastructure: Can you be certain that every test
    of critical operations won’t bring down production? Can you live with data analysts
    having otherwise avoidable privileges to access sensitive data? Are you relying
    on perfect humans with perfect tests that are perfectly executed?'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些测试最佳实践在理论上听起来很棒，但在这一点上，您可能会被构建适当的测试基础设施的潜在成本所压倒。做对这件事并不便宜。然而，请考虑没有适当的测试基础设施的成本：您能确定每次关键操作的测试不会导致生产中断吗？您能接受数据分析师具有本来可以避免的访问敏感数据的特权吗？您是否依赖于完美的人类和完美执行的完美测试？
- en: It’s important to conduct a proper cost–benefit analysis for your specific situation.
    It may not make sense to initially build the “ideal” solution. However, make sure
    you build a framework people will use. People need to perform testing. If you
    don’t provide an adequate testing framework, they’ll test in production, circumventing
    the controls you put in place.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您特定的情况，进行适当的成本效益分析非常重要。最初构建“理想”解决方案可能并不合理。但是，请确保您构建的框架会被人们使用。人们需要进行测试。如果您没有提供足够的测试框架，他们将在生产环境中进行测试，绕过您制定的控制措施。
- en: Diagnosing Access Denials
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 诊断访问拒绝
- en: In a complex system, where least privilege is enforced and trust must be earned
    by the client via a third factor, multi-party authorization, or another mechanism
    (see [“Advanced Controls”](#advanced_controls)), policy is enforced at multiple
    levels and at a fine granularity. As a result, policy denials can also happen
    in complex ways.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个复杂的系统中，最小权限被强制执行，客户必须通过第三方因素、多方授权或其他机制（见“高级控制”）来赢得信任，策略在多个级别和细粒度上被执行。因此，策略拒绝也可能以复杂的方式发生。
- en: 'Consider the case in which a sane security policy is being enforced, and your
    authorization system denies access. One of three possible outcomes might occur:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个理智的安全策略正在执行的情况，您的授权系统拒绝访问。可能会出现三种可能的结果之一：
- en: The client was correctly denied and your system behaved appropriately. Least
    privilege has been enforced, and all is well.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户被正确拒绝，您的系统行为正确。最小权限已被执行，一切都很好。
- en: The client was correctly denied, but can use an advanced control (such as multi-party
    authorization) to obtain temporary access.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户被正确拒绝，但可以使用高级控制（如多方授权）来获得临时访问。
- en: The client believes they were incorrectly denied, and potentially files a support
    ticket with your security policy team. For example, this might happen if the client
    was recently removed from an authorized group, or if the policy changed in a subtle
    or perhaps incorrect way.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户认为他们被错误拒绝了，并可能向您的安全策略团队提交支持工单。例如，如果客户最近被从授权组中移除，或者策略以微妙或可能不正确的方式发生了变化，这可能会发生。
- en: In all cases, the caller is blind to the reason for denial. But could the system
    perhaps provide the client with more information? Depending on the caller’s level
    of privilege, it can.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，呼叫者对拒绝的原因一无所知。但系统是否可以向客户提供更多信息？根据呼叫者的权限级别，它可以。
- en: If the client has no or very limited privileges, the denial should remain blind—you
    probably don’t want to expose information beyond a 403 Access Denied error code
    (or its equivalent), because details about the reasons for a denial could be exploited
    to gain information about a system and even to find a way to gain access. However,
    if the caller has certain minimal privileges, you can provide a token associated
    with the denial. The caller can use that token to invoke an advanced control to
    obtain temporary access, or provide the token to the security policy team through
    a support channel so they can use it to diagnose the problem. For a more privileged
    caller, you can provide a token associated with the denial *and* some remediation
    information. The caller can then attempt to self-remediate before invoking the
    support channel. For example, the caller might learn that access was denied because
    they need to be a member of a specific group, and they can then request access
    to that group.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端没有或权限非常有限，拒绝应该保持盲目 - 您可能不希望暴露403访问被拒绝错误代码（或其等效），因为有关拒绝原因的详细信息可能被利用以获取有关系统的信息，甚至找到获得访问权限的方法。但是，如果调用者具有某些最低权限，您可以提供与拒绝相关联的令牌。调用者可以使用该令牌调用高级控件以获取临时访问权限，或通过支持渠道将令牌提供给安全策略团队，以便他们用于诊断问题。对于更具特权的调用者，您可以提供与拒绝相关联的令牌*和*一些纠正信息。然后，调用者可以尝试自行纠正，然后再调用支持渠道。例如，调用者可能会得知访问被拒绝是因为他们需要成为特定组的成员，然后他们可以请求访问该组。
- en: There will always be tension between how much remediation information to expose
    and how much support overload the security policy team can handle. However, if
    you expose too much information, clients may be able to reengineer the policy
    from the denial information, making it easier for a malicious actor to craft a
    request that uses the policy in an unintended way. With this in mind, we recommend
    that in the early stages of implementing a zero trust model, you use tokens and
    have all clients invoke the support channel.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在公开多少纠正信息和安全策略团队可以处理多少支持负载之间总会存在紧张关系。但是，如果您公开了太多信息，客户端可能能够从拒绝信息中重新设计策略，从而使恶意行为者更容易制定使用策略的请求的方式。考虑到这一点，我们建议在实施零信任模型的早期阶段，您使用令牌，并要求所有客户端调用支持渠道。
- en: Graceful Failure and Breakglass Mechanisms
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优雅的失败和破玻璃机制
- en: Ideally, you’ll always be dealing with a working authorization system enforcing
    a sane policy. But in reality, you might run into a scenario that results in large-scale
    incorrect denials of access (perhaps due to a bad system update). In response,
    you need to be able to circumvent your authorization system via a breakglass mechanism
    so you can fix it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您总是在处理一个实施合理策略的工作授权系统。但实际上，您可能会遇到导致大规模访问拒绝的场景（可能是由于糟糕的系统更新）。作为回应，您需要能够通过破玻璃机制绕过授权系统，以便您可以修复它。
- en: 'When employing a breakglass mechanism, consider the following guidelines:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用破玻璃机制时，请考虑以下准则：
- en: The ability to use a breakglass mechanism should be highly restricted. In general,
    it should be available only to your SRE team, which is responsible for the operational
    SLA of your system.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用破玻璃机制的能力应受到严格限制。通常情况下，它应仅对负责系统运行SLA的SRE团队可用。
- en: The breakglass mechanism for zero trust networking should be available only
    from specific locations. These locations are your *panic rooms*, specific locations
    with additional physical access controls to offset the increased trust placed
    in their connectivity. (The careful reader will notice that the fallback mechanism
    for zero trust networking, a strategy of distrusting network location, is…trusting
    network location—but with additional physical access controls.)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零信任网络的破玻璃机制应仅在特定位置可用。这些位置是您的*恐慌室*，具有额外物理访问控制的特定位置，以抵消其连接性所放置的增加信任。 （细心的读者会注意到，零信任网络的备用机制是不信任网络位置的策略，实际上是信任网络位置，但具有额外的物理访问控制。）
- en: All uses of a breakglass mechanism should be closely monitored.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有使用破玻璃机制的情况都应受到密切监控。
- en: The breakglass mechanism should be tested regularly by the team(s) responsible
    for production services, to make sure it functions when you need it.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破玻璃机制应该由负责生产服务的团队定期测试，以确保在需要时它能正常运行。
- en: When the breakglass mechanism has successfully been utilized so that users regain
    access, your SREs and security policy team can further diagnose and resolve the
    underlying problem. Chapters [8](ch08.html#design_for_resilience) and [9](ch09.html#design_for_recovery)
    discuss relevant strategies.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当成功利用破玻璃机制使用户恢复访问权限时，您的SREs和安全策略团队可以进一步诊断和解决潜在问题。第8章和第9章讨论了相关策略。
- en: 'Worked Example: Configuration Distribution'
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作示例：配置分发
- en: 'Let’s turn to a real-world example. Distributing a configuration file to a
    set of web servers is an interesting design problem, and it can be practically
    implemented with a small functional API. The best practices for managing a configuration
    file are to:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个现实世界的例子。将配置文件分发给一组Web服务器是一个有趣的设计问题，可以通过一个小型的功能API实际实现。管理配置文件的最佳实践是：
- en: Store the configuration file in a version control system.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将配置文件存储在版本控制系统中。
- en: Code review changes to the file.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对文件进行代码审查更改。
- en: Automate the distribution to a canary set first, health check the canaries,
    and then continue health checking all hosts as you gradually push the file to
    the fleet of web servers.^([11](ch05.html#ch05fn2a)) This step requires granting
    the automation access to update the configuration file remotely.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先自动将配置文件分发给一组金丝雀，对金丝雀进行健康检查，然后在逐渐将文件推送到Web服务器群中继续对所有主机进行健康检查。这一步需要授予自动化访问权限以远程更新配置文件。
- en: There are many approaches to exposing a small API, each tailored to the function
    of updating the configuration of your web servers. [Table 5-2](#apis_that_update_web_server_configurati)
    summarizes a few APIs you may consider, and their tradeoffs. The sections that
    follow explain each tactic in more depth.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-2\. APIs that update web server configuration and their tradeoffs
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '|  | POSIX API via OpenSSH | Software update API | Custom OpenSSH ForceCommand
    | Custom HTTP receiver |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| **API surface** | Large | Various | Small | Small |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| **Preexisting**^([a](ch05.html#ch05fn13)) | Likely | Yes | Unlikely | Unlikely
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| **Complexity** | High | High | Low | Medium |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| **Ability to scale** | Moderate | Moderate, but reusable | Difficult | Moderate
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| **Auditability** | Poor | Good | Good | Good |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| **Can express least privilege** | Poor | Various | Good | Good |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| ^([a](ch05.html#ch05fn13-marker)) This indicates how likely or unlikely it
    is that you already have this type of API as part of an existing web server deployment.
    |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: POSIX API via OpenSSH
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can allow the automation to connect to the web server host via OpenSSH,
    typically connecting as the local user the web server runs as. The automation
    can then write the configuration file and restart the web server process. This
    pattern is simple and common. It leverages an administrative API that likely already
    exists, and thus requires little additional code. Unfortunately, leveraging the
    large preexisting administrative API introduces several risks:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The role running the automation can stop the web server permanently, start another
    binary in its place, read any data it has access to, etc.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bugs in the automation implicitly have enough access to cause a coordinated
    outage of all of the web servers.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A compromise of the automation’s credentials is equivalent to a compromise of
    all of the web servers.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software Update API
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can distribute the config as a packaged software update, using the same
    mechanism you use to update the web server binary. There are many ways to package
    and trigger binary updates, using APIs of varying sizes. A simple example is a
    Debian package (*.deb*) pulled from a central repository by a periodic `apt-get`
    called from `cron`. You might build a more complex example using one of the patterns
    discussed in the following sections to trigger the update (instead of `cron`),
    which you could then reuse for both the configuration and the binary. As you evolve
    your binary distribution mechanism to add safety and security, the benefits accrue
    to your configuration, because both use the same infrastructure. Any work done
    to centrally orchestrate a canary process, coordinate health checking, or provide
    signatures/provenance/auditing similarly pays dividends for both of these artifacts.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes the needs of binary and configuration update systems don’t align.
    For example, you might distribute an IP deny list in your configuration that needs
    to converge as quickly as is safely practical, while also building your web server
    binary into a container. In this case, building, standing up, and tearing down
    a new container at the same rate you want to distribute configuration updates
    may be too expensive or disruptive. Conflicting requirements of this type may
    necessitate two distribution mechanisms: one for binaries, another for configuration
    updates.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: For many more thoughts on this pattern, see [Chapter 9](ch09.html#design_for_recovery).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Custom OpenSSH ForceCommand
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can write a short script to perform these steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Receive the configuration from `STDIN`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sanity check the configuration.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart the web server to update the configuration.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can then expose this command via OpenSSH by tying particular entries in
    an *authorized_keys* file with the `ForceCommand` option.^([12](ch05.html#ch05fn14))
    This strategy presents a very small API to the caller, which can connect via the
    battle-hardened OpenSSH protocol, where the only available action is to provide
    a copy of the configuration file. Logging the file (or a hash of it^([13](ch05.html#ch05fn15)))
    reasonably captures the entire action of the session for later auditing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: You can implement as many of these unique key/`ForceCommand` combinations as
    you like, but this pattern can be hard to scale to many unique administrative
    actions. While you can build a text-based protocol on top of the OpenSSH API (such
    as [git-shell](https://oreil.ly/k4igi)), doing so starts down the path of building
    your own RPC mechanism. You’re likely better off skipping to the end of that road
    by building on top of an existing framework such as [gRPC](https://grpc.io) or
    [Thrift](https://thrift.apache.org).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Custom HTTP Receiver (Sidecar)
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can write a small sidecar daemon—much like the `ForceCommand` solution,
    but using another AAA mechanism (e.g., gRPC with SSL, [SPIFFE](https://spiffe.io),
    or similar)—that accepts a config. This approach doesn’t require modifying the
    serving binary and is very flexible, at the expense of introducing more code and
    another daemon to manage.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Custom HTTP Receiver (In-Process)
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You could also modify the web server to [expose an API to update its config
    directly](https://oreil.ly/hu7yg), receiving the config and writing it to disk.
    This is one of the most flexible approaches, and bears a strong similarity to
    the way we manage configuration at Google, but it requires incorporating the code
    into the serving binary.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Tradeoffs
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All but the large options in [Table 5-2](#apis_that_update_web_server_configurati)
    provide opportunities to add security and safety to your automation. An attacker
    may still be able to compromise the web server’s role by pushing an arbitrary
    config; however, choosing a smaller API means that the push mechanism won’t implicitly
    allow that compromise.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: You may be able to further design for least privilege by signing the config
    independently from the automation that pushes it. This strategy segments the trust
    between roles, guaranteeing that if the automation role pushing the configuration
    is compromised, the automation cannot also compromise the web server by sending
    a malicious config. To recall McIlroy, Pinson, and Tague ’s advice, designing
    each piece of the system to perform one task and perform that task well allows
    you to isolate trust.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: The more granular control surface presented by a narrow API also allows you
    to add protection against bugs in the automation. In addition to requiring a signature
    to validate the config, you can require a bearer token^([14](ch05.html#ch05fn16))
    from a central rate limiter, created independently of your automation and targeted
    to each host in the rollout. You can very carefully unit test this general rate
    limiter; if the rate limiter is independently implemented, bugs affecting the
    rollout automation likely won’t simultaneously affect it. An independent rate
    limiter is also conveniently reusable, as it can rate limit the config rollout
    of the web server, the binary rollout of the same server, reboots of the server,
    or any other task to which you wish to add a safety check.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: A Policy Framework for Authentication and Authorization Decisions
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*authentication* [noun]: verifying the **identity** of a user or process'
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '*authorization* [noun]: evaluating if a request from a specific authenticated
    party **should be permitted**'
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The previous section advocates designing a narrow administrative API for your
    service, which allows you to grant the least amount of privilege possible to achieve
    a given action. Once that API exists, you must decide how to control access to
    it. Access control involves two important but distinct steps.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you must *authenticate* who is connecting. An authentication mechanism
    can range in complexity:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您必须*验证*谁在连接。认证机制的复杂程度可以不同：
- en: 'Simple: Accepting a username passed in a URL parameter'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 简单：接受通过URL参数传递的用户名
- en: 'Example: */service?username=admin*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：*/service?username=admin*
- en: 'More complex: Presenting a preshared secret'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂：呈现预共享密钥
- en: 'Examples: WPA2-PSK, an HTTP cookie'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：WPA2-PSK，HTTP cookie
- en: 'Even more complex: Complex hybrid encryption and certificate schemes'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂：复杂的混合加密和证书方案
- en: 'Examples: TLS 1.3, OAuth'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：TLS 1.3，OAuth
- en: Generally speaking, you should prefer to reuse an existing strong cryptographic
    authentication mechanism to identify the API’s caller. The result of this authentication
    decision is commonly expressed as a username, a common name, a “principal,” a
    “role,” and so on. For purposes of this section, we use *role* to describe the
    interchangeable result of authentication.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，您应该更倾向于重用现有的强大的加密身份验证机制来识别API的调用者。这个身份验证决定的结果通常表示为用户名、常用名称、“主体”、“角色”等。在本节中，我们使用*角色*来描述身份验证的可互换结果。
- en: 'Next, your code must make a decision: is this role *authorized* to perform
    the requested action? Your code may consider many attributes of the request, such
    as the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您的代码必须做出决定：这个角色是否*被授权*执行所请求的操作？您的代码可能会考虑请求的许多属性，例如以下内容：
- en: The specific action being requested
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所请求的具体操作
- en: 'Examples: URL, command being run, gRPC method'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：URL，正在运行的命令，gRPC方法
- en: Arguments to the requested action
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的操作参数
- en: 'Examples: URL parameters, `argv`, gRPC request'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：URL参数，`argv`，gRPC请求
- en: The source of the request
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的来源
- en: 'Examples: IP address, client certificate metadata'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：IP地址，客户端证书元数据
- en: Metadata about the authenticated role
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 经过身份验证的角色的元数据
- en: 'Examples: geographic location, legal jurisdiction, machine learning evaluation
    of risk'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：地理位置，法律管辖区，风险的机器学习评估
- en: Server-side context
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端上下文
- en: 'Examples: rate of similar requests, available capacity'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：类似请求的速率，可用容量
- en: The rest of this section discusses several techniques that Google has found
    useful to improve upon, and scale up, the basic requirements of authentication
    and authorization decisions.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分讨论了谷歌发现有用的几种技术，以改进和扩展身份验证和授权决策的基本要求。
- en: Using Advanced Authorization Controls
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用高级授权控制
- en: An access control list for a given resource is a familiar way to implement an
    authorization decision. The simplest ACL is a string matching the authenticated
    role, often combined with some notion of grouping—for example, a group of roles,
    such as “administrator,” which expands to a larger list of roles, such as usernames.
    When the service evaluates the incoming request, it checks whether the authenticated
    role is a member of the ACL.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 给定资源的访问控制列表是实现授权决策的一种熟悉方式。最简单的ACL是与经过身份验证的角色匹配的字符串，通常与某种分组概念结合在一起，例如一组角色，例如“管理员”，它扩展为更大的角色列表，例如用户名。当服务评估传入请求时，它会检查经过身份验证的角色是否是ACL的成员。
- en: More complex authorization requirements, such as multi-factor authorization
    (MFA) or multi-party authorization (MPA), require more complex authorization code
    (for more on three-factor authorization and MPA, see [“Advanced Controls”](#advanced_controls)).
    In addition, some organizations may have to consider their particular regulatory
    or contractual requirements when designing authorization policies.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的授权要求，例如多因素授权（MFA）或多方授权（MPA），需要更复杂的授权代码（有关三因素授权和MPA的更多信息，请参见[“高级控制”](#advanced_controls)）。此外，一些组织在设计授权策略时可能需要考虑其特定的监管或合同要求。
- en: This code can be difficult to implement correctly, and its complexity can rapidly
    compound if many services each implement their own authorization logic. In our
    experience, it’s helpful to separate the complexities of authorization decisions
    from core API design and business logic with frameworks like the [AWS](https://aws.amazon.com/iam)
    or [GCP](https://cloud.google.com/iam) Identity & Access Management (IAM) offerings.
    At Google, we also extensively use a variation of the GCP authorization framework
    for internal services.^([15](ch05.html#ch05fn17))
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很难正确实现，如果许多服务都实现了自己的授权逻辑，其复杂性可能会迅速增加。根据我们的经验，使用像[AWS](https://aws.amazon.com/iam)或[GCP](https://cloud.google.com/iam)身份和访问管理（IAM）等框架可以将授权决策的复杂性与核心API设计和业务逻辑分离。在谷歌，我们还广泛使用GCP授权框架的变体来内部服务。^([15](ch05.html#ch05fn17))
- en: The security policy framework allows our code to make simple checks (such as
    “Can X access resource Y?”) and evaluate those checks against an externally supplied
    policy. If we need to add more authorization controls to a particular action,
    we can simply change the relevant policy configuration file. This low overhead
    has tremendous functionality and velocity benefits.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 安全策略框架允许我们的代码进行简单的检查（例如“X是否可以访问资源Y？”），并将这些检查与外部提供的策略进行评估。如果我们需要向特定操作添加更多的授权控制，我们可以简单地更改相关的策略配置文件。这种低开销具有巨大的功能和速度优势。
- en: Investing in a Widely Used Authorization Framework
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 投资于广泛使用的授权框架
- en: 'You can enable authentication and authorization changes at scale by using a
    shared library to implement authorization decisions, and by using a consistent
    interface as widely as possible. Applying this classic modular software design
    advice in the security sphere yields surprising benefits. For example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用共享库实现授权决策，并尽可能广泛地使用一致的接口来实现规模化的身份验证和授权更改。在安全领域应用这一经典的模块化软件设计建议会产生意想不到的好处。例如：
- en: You can add support for MFA or MPA to all service endpoints with a single library
    change.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过单个库更改为所有服务端点添加对MFA或MPA的支持。
- en: You can then implement this support for a small percentage of the actions or
    resources in all services with a single configuration change.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，您可以通过单个配置更改在所有服务中的少量操作或资源上实现此支持。
- en: You can improve reliability by requiring MPA for all actions that allow a potentially
    unsafe action, similar to a code review system. This process improvement can improve
    security against insider risk threats (for more about types of adversaries, see
    [Chapter 2](ch02.html#understanding_adversaries)) by facilitating fast incident
    response (by bypassing revision control system and code review dependencies) without
    allowing broad unilateral access.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As your organization grows, standardization is your friend. A uniform authorization
    framework facilitates team mobility, as more people know how to code against and
    implement access controls with a common framework.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Potential Pitfalls
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Designing a complex authorization policy language is difficult. If the policy
    language is too simplistic, it won’t achieve its goal, and you’ll end up with
    authorization decisions spread across both the framework’s policy and the primary
    codebase. If the policy language is too general, it can be very hard to reason
    about. To mitigate these concerns, you can apply standard software API design
    practices—in particular, an iterative design approach—but we recommend proceeding
    carefully to avoid both of these extremes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Carefully consider how the authorization policy is shipped to (or with) the
    binary. You may want to update the authorization policy, which will plausibly
    become one of the most security-sensitive pieces of configuration, independently
    of the binary. For additional discussion about configuration distribution, see
    the worked example in the previous section, Chapters [9](ch09.html#design_for_recovery)
    and [14](ch14.html#onefour_deploying_code) in this book, [Chapter 8](https://landing.google.com/sre/sre-book/chapters/release-engineering/)
    in the SRE book, and Chapters [14](https://landing.google.com/sre/workbook/chapters/configuration-design/)
    and [15](https://landing.google.com/sre/workbook/chapters/configuration-specifics/)
    in the SRE workbook.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Application developers will need assistance with the policy decisions that will
    be encoded in this language. Even if you avoid the pitfalls described here and
    create an expressive and understandable policy language, more often than not it
    will still require collaboration between application developers implementing the
    administrative APIs and security engineers and SREs with domain-specific knowledge
    about your production environment, to craft the right balance between security
    and functionality.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'DEEP DIVE: Advanced Controls'
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While many authorization decisions are a binary yes/no, more flexibility is
    useful in some situations. Rather than requiring a strict yes/no, an escape valve
    of “maybe,” paired with an additional check, can dramatically ease the pressures
    on a system. Many of the controls described here can be used either in isolation
    or in combination. Appropriate usage depends on the sensitivity of the data, the
    risk of the action, and existing business processes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Multi-Party Authorization (MPA)
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Involving another person is one classic way to ensure a proper access decision,
    fostering a culture of security and reliability (see [Chapter 21](ch21.html#twoone_building_a_culture_of_security_a)).
    This strategy offers several benefits:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '*Preventing mistakes* or unintentional violations of policy that may lead to
    security or privacy issues.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Discouraging bad actors* from attempting to perform malicious changes. This
    includes both employees, who risk disciplinary action, and external attackers,
    who risk detection.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Increasing the cost of the attack* by requiring either compromise of at least
    one other person or a carefully constructed change that passes a peer review.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Auditing past actions* for incident response or postmortem analysis, assuming
    the reviews are recorded permanently and in a tamper-resistant fashion.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Providing customer comfort*. Your customers may be more comfortable using
    your service knowing that no single person can make a change by themselves.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MPA is often performed for a broad level of access—for example, by requiring
    approval to join a group that grants access to production resources, or the ability
    to act as a given role or credential. Broad MPA can serve as a valuable breakglass
    mechanism, to enable very unusual actions that you may not have specific workflows
    for. Where possible, you should try to provide more granular authorization, which
    can provide stronger guarantees of reliability and security. If the second party
    approves an action against a small functional API (see [“Small Functional APIs”](#small_functional_apis)),
    they can have much more confidence in precisely what they are authorizing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: MPA通常用于广泛的访问级别，例如要求批准加入一个授予对生产资源访问权限的组，或者扮演特定角色或凭证的能力。广泛的MPA可以作为一个有价值的紧急机制，以启用非常不寻常的操作，对于这些操作你可能没有特定的工作流程。在可能的情况下，你应该尽量提供更细粒度的授权，这可以提供更强的可靠性和安全性保证。如果第二方批准针对小型功能API的操作（见[“小型功能API”]），他们可以更加确信他们正在授权的内容。
- en: Social pressure around approvals may also lead to bad decisions. For example,
    an engineer might not feel comfortable rejecting a suspicious request if its issued
    by a manager, a senior engineer, or someone standing over their desk. To mitigate
    these pressures, you can provide the option to escalate approvals to a security
    or investigations team after the fact. Or, you might have a policy that all (or
    a percentage) of a certain type of approval are independently audited.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 关于批准的社会压力也可能导致糟糕的决定。例如，如果一个工程师不愿意拒绝一个可疑请求，因为它是由经理、高级工程师或者站在他们办公桌旁的人发出的。为了减轻这些压力，你可以提供将批准事后升级给安全或调查团队的选项。或者，你可以制定一个政策，要求某种类型的批准全部（或一部分）独立审计。
- en: Before building a multi-party authorization system, make sure the technology
    and social dynamics allow someone to say no. Otherwise, the system is of little
    value.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建多方授权系统之前，确保技术和社会动态允许某人说不。否则，系统就没有多少价值。
- en: Three-Factor Authorization (3FA)
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三因素授权（3FA）
- en: 'In a large organization, MPA often has one key weakness that can be exploited
    by a determined and persistent attacker: all of the “multiple parties” use the
    same centrally managed workstations. The more homogeneous the fleet of workstations,
    the more likely it is that an attacker who can compromise one workstation can
    compromise several or even all of them.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型组织中，MPA通常存在一个关键弱点，可以被决心和坚持的攻击者利用：所有的“多方”使用同一台中央管理的工作站。工作站车队越同质化，攻击者就越有可能攻击一台工作站就能攻击几台甚至全部工作站。
- en: 'A classic method to harden the fleet of workstations against attack is for
    users to maintain two completely separate workstations: one for general use, such
    as browsing the web and sending/receiving emails, and another more trusted workstation
    for communicating with the production environment. In our experience, users ultimately
    want similar sets of features and capabilities from those workstations, and maintaining
    two sets of workstation infrastructure for the limited set of users whose credentials
    require this increased level of protection is both expensive and difficult to
    sustain over time. Once this issue is no longer top of mind for management, people
    are less incentivized to maintain the infrastructure.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一种经典的方法是为了加固工作站车队免受攻击，用户需要维护两个完全独立的工作站：一个用于一般用途，比如浏览网页和发送/接收电子邮件，另一个更可信的工作站用于与生产环境通信。根据我们的经验，用户最终希望这些工作站具有类似的功能和能力，为了维护这些需要更高级别保护的有限用户集的两套工作站基础设施，既昂贵又难以长期维持。一旦这个问题不再是管理层关注的焦点，人们就没有动力去维护这些基础设施。
- en: 'Mitigating the risk that a single compromised platform can undermine all authorization
    requires the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 减轻单个受损平台可能破坏所有授权的风险需要以下措施：
- en: Maintaining at least two platforms
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少维护两个平台
- en: The ability to approve requests on two platforms
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个平台上批准请求的能力
- en: (Preferably) The ability to harden at least one platform
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （最好）至少有一个平台具有硬化能力
- en: Considering these requirements, another option is to require authorization from
    a hardened mobile platform for certain very risky operations. For simplicity and
    convenience, you can only allow RPCs to be originated from fully managed desktop
    workstations, and then require three-factor authorization from the mobile platform.
    When a production service receives a sensitive RPC, the policy framework (described
    in [“A Policy Framework for Authentication and Authorization Decisions”](#a_policy_framework_for_authentication_a))
    requires cryptographically signed approval from the separate 3FA service. That
    service then indicates that it sent the RPC to the mobile device, it was shown
    to the originating user, and they acknowledged the request.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些要求，另一个选择是要求从一个硬化的移动平台对某些非常危险的操作进行授权。为了简单和方便起见，你只允许RPCs从完全管理的桌面工作站发起，然后要求移动平台进行三因素授权。当一个生产服务接收到一个敏感的RPC时，策略框架（在[“用于认证和授权决策的策略框架”]中描述）要求从独立的3FA服务获得加密签名的批准。然后该服务指示它将RPC发送到移动设备，显示给发起用户，并且他们确认了请求。
- en: Hardening mobile platforms is somewhat easier than hardening general-purpose
    workstations. We’ve found that users are generally more tolerant of certain security
    restrictions on mobile devices, such as additional network monitoring, allowing
    only a subset of apps, and connecting through a limited number of HTTP endpoints.
    These policies are also quite easy to achieve with modern mobile platforms.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 硬化移动平台比硬化通用工作站要容易一些。我们发现用户通常更容忍移动设备上的某些安全限制，比如额外的网络监控，只允许一部分应用程序，并且只能连接有限数量的HTTP端点。这些策略在现代移动平台上也很容易实现。
- en: Once you have a hardened mobile platform on which to display the proposed production
    change, you have to get the request to that platform and display it to the user.
    At Google, we reuse the infrastructure that delivers notifications to Android
    phones to authorize and report Google login attempts to our users. If you have
    the luxury of a similar hardened piece of infrastructure lying around, it might
    be useful to extend it to support this use case, but failing that, a basic web-based
    solution is relatively easy to create. The core of a 3FA system is a simple RPC
    service that receives the request to be authorized and exposes the request for
    authorization by the trusted client. The user requesting the 3FA-protected RPC
    visits the web URL of the 3FA service from their mobile device, and is presented
    with the request for approval.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了一个坚固的移动平台来显示拟议的生产变更，您必须将请求发送到该平台并显示给用户。在谷歌，我们重用了将通知传递到安卓手机的基础设施，以授权和报告我们用户的谷歌登录尝试。如果您有类似的坚固基础设施，那么将其扩展以支持此用例可能是有用的，但如果没有，基本的基于网络的解决方案相对容易创建。3FA系统的核心是一个简单的RPC服务，它接收要授权的请求，并通过受信任的客户端公开请求以进行授权。请求3FA受保护的RPC的用户会从其移动设备访问3FA服务的网络URL，并收到授权请求。
- en: It is important to distinguish what threats MPA and 3FA protect against, so
    you can decide on a consistent policy about when to apply them. MPA protects against
    unilateral insider risk as well as against compromise of an individual workstation
    (by requiring a second internal approval). 3FA protects against broad compromise
    of internal workstations, but does not provide any protection against insider
    threats when used in isolation. Requiring 3FA from the originator and simple web-based
    MPA from a second party can provide a very strong defense against the combination
    of most of these threats, with relatively little organizational overhead.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要区分MPA和3FA保护的威胁，以便您可以决定何时应用一致的策略。MPA不仅保护免受单方面内部风险的威胁，还保护免受个人工作站的妥协（通过需要第二次内部批准）。3FA保护免受内部工作站的广泛妥协，但在单独使用时不提供任何对内部威胁的保护。要求发起者进行3FA，并要求第二方进行简单的基于网络的MPA，可以提供对大多数这些威胁的组合的非常强大的防御，而组织开销相对较小。
- en: Business Justifications
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 业务理由
- en: As mentioned in [“Choosing an auditor”](#choosing_an_auditor), you can enforce
    authorization by tying access to a structured business justification, such as
    a bug, incident, ticket, case ID, or assigned account. But building the validation
    logic may require additional work, and may also require process changes for the
    people staffing on-call or customer service.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如[“选择审计员”](#choosing_an_auditor)中所述，您可以通过将访问权限与结构化的业务理由（例如错误、事件、工单、案例ID或分配的帐户）联系起来来强制执行授权。但是构建验证逻辑可能需要额外的工作，也可能需要对值班或客户服务人员进行流程更改。
- en: As an example, consider a customer service workflow. In an anti-pattern sometimes
    found in small or immature organizations, a basic and nascent system may give
    customer service representatives access to all customer records, either for efficiency
    reasons or because controls don’t exist. A better option would be to block access
    by default, and to only allow access to specific data when you can verify the
    business need. This approach may be a gradient of controls implemented over time.
    For example, it may start by only allowing access to customer service representatives
    assigned an open ticket. Over time, you can improve the system to only allow access
    to specific customers, and specific data for those customers, in a time-bound
    fashion, with customer approval.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑客户服务工作流程。在一些小型或不成熟组织中有时会发现的反模式中，基本和初期的系统可能会给客户服务代表访问所有客户记录，要么是出于效率原因，要么是因为不存在控制。更好的选择是默认情况下阻止访问，并且只有在您可以验证业务需求时才允许访问特定数据。这种方法可能是随时间实施的控制梯度。例如，它可能从仅允许分配了一个开放工单的客户服务代表开始。随着时间的推移，您可以改进系统，仅允许访问特定客户以及这些客户的特定数据，并且在经过一段时间后需要客户批准。
- en: 'When properly configured, this strategy can provide a strong authorization
    guarantee that access was appropriate and properly scoped. Structured justifications
    allow the automation to require that Ticket #12345 isn’t a random number typed
    in to satisfy a simple regular expression check. Instead, the justification satisfies
    a set of access policies that balance operational business needs and system capabilities.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '当正确配置时，这种策略可以提供强大的授权保证，以确保访问是适当的并且范围适当。结构化的理由允许自动化要求Ticket #12345不是随意输入的随机数字，以满足简单的正则表达式检查。相反，理由满足一组平衡运营业务需求和系统能力的访问策略。'
- en: Temporary Access
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时访问
- en: You can limit the risk of an authorization decision by granting temporary access
    to resources. This strategy can often be useful when fine-grained controls are
    not available for every action, but you still want to grant the least privilege
    possible with the available tooling.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过向资源授予临时访问来限制授权决策的风险。当没有针对每个操作的细粒度控制时，这种策略通常是有用的，但您仍希望尽可能使用可用的工具授予最低特权。
- en: You can grant temporary access in a structured and scheduled way (e.g., during
    on-call rotations, or via expiring group memberships) or in an on-demand fashion
    where users explicitly request access. You can combine temporary access with a
    request for multi-party authorization, a business justification, or another authorization
    control. Temporary access also creates a logical point for auditing, since you
    have clear logging about users who have access at any given time. It also provides
    data about where temporary access occurs so you can prioritize and reduce these
    requests over time.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以结构化和计划的方式（例如，在值班轮换期间或通过过期的组成员资格）或按需方式授予临时访问（用户明确请求访问）来授予临时访问。您还可以将临时访问与多方授权请求、业务理由或其他授权控制结合使用。临时访问还创建了一个逻辑点进行审计，因为您可以清楚地记录任何给定时间具有访问权限的用户。它还提供了关于临时访问发生位置的数据，因此您可以随时间优先处理并减少这些请求。
- en: Temporary access also reduces ambient authority. This is one reason that administrators
    favor `sudo` or “Run as Administrator” over operating as the Unix user *root*
    or Windows Administrator accounts—when you accidentally issue a command to delete
    all the data, the fewer permissions you have, the better!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 临时访问还会减少环境权限。这是管理员更喜欢使用`sudo`或“以管理员身份运行”而不是作为Unix用户*root*或Windows管理员帐户操作的一个原因——当您意外地发出删除所有数据的命令时，您拥有的权限越少，越好！
- en: Proxies
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理
- en: When fine-grained controls for backend services are not available, you can fall
    back to a heavily monitored and restricted proxy machine (or *bastion*). Only
    requests from these specified proxies are allowed to access sensitive services.
    This proxy can restrict dangerous actions, rate limit actions, and perform more
    advanced logging.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当后端服务的细粒度控制不可用时，您可以退而使用受到严格监控和限制的代理机器（或*堡垒*）。只有来自这些指定代理的请求才被允许访问敏感服务。该代理可以限制危险操作，限制操作速度，并执行更高级的日志记录。
- en: 'For example, you may need to perform an emergency rollback of a bad change.
    Given the infinite ways a bad change can happen, and the infinite ways it can
    be resolved, the steps required to perform a rollback may not be available in
    a predefined API or a tool. You can give a system administrator the flexibility
    to resolve an emergency, but introduce restrictions or additional controls that
    mitigate the risk. For example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可能需要执行紧急回滚以撤销错误的更改。鉴于错误更改可能发生的无限方式，以及解决错误更改可能的无限方式，执行回滚所需的步骤可能不会在预定义的API或工具中提供。您可以给系统管理员灵活性来解决紧急情况，但引入限制或额外的控制以减轻风险。例如：
- en: Each command may need peer approval.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个命令可能需要同行批准。
- en: An administrator may only connect to relevant machines.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员可能只连接到相关的机器。
- en: The computer that an administrator is using may not have access to the internet.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员使用的计算机可能无法访问互联网。
- en: You can enable more thorough logging.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以启用更彻底的日志记录。
- en: As always, implementing any of these controls comes with an integration and
    operational cost, as discussed in the next section.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，实施任何这些控制都会带来集成和运营成本，如下一节所讨论的。
- en: Tradeoffs and Tensions
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权衡和紧张关系
- en: Adopting a least privilege access model will definitely improve your organization’s
    security posture. However, you must offset the benefits outlined in the previous
    sections against the potential cost of implementing that posture. This section
    considers some of those costs.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 采用最小权限访问模型肯定会改善您组织的安全姿态。然而，您必须权衡前面部分中概述的好处与实施该姿态的潜在成本。本节考虑了其中一些成本。
- en: Increased Security Complexity
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增加安全复杂性
- en: 'A highly granular security posture is a very powerful tool, but it’s also complex
    and therefore challenging to manage. It is important to have a comprehensive set
    of tooling and infrastructure to help you define, manage, analyze, push, and debug
    your security policies. Otherwise, this complexity may become overwhelming. You
    should always aim to be able to answer these foundational questions: “Does a given
    user have access to a given service/piece of data?” and “For a given service/piece
    of data, who has access?”'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 高度细粒度的安全姿态是一个非常强大的工具，但也很复杂，因此难以管理。拥有一套全面的工具和基础设施来帮助您定义、管理、分析、推送和调试安全策略非常重要。否则，这种复杂性可能变得令人不堪重负。您应该始终力求能够回答这些基本问题：“给定用户是否有权访问给定服务/数据？”和“对于给定服务/数据，谁有权限访问？”
- en: Impact on Collaboration and Company Culture
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对协作和公司文化的影响
- en: While a strict model of least privilege is likely appropriate for sensitive
    data and services, a more relaxed approach in other areas can provide tangible
    benefits.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最小权限模型可能适用于敏感数据和服务，但在其他领域采取更宽松的方法可以提供切实的好处。
- en: For example, providing software engineers with broad access to source code carries
    a certain amount of risk. However, this is counterbalanced by engineers being
    able to learn on the job according to their own curiosity and by contributing
    features and bug fixes outside of their normal roles when they can lend their
    attention and expertise. Less obviously, this transparency also makes it harder
    for an engineer to write inappropriate code that goes unnoticed.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为软件工程师提供对源代码的广泛访问权带来一定的风险。然而，这可以通过工程师能够根据自己的好奇心在工作中学习，并在能够借用他们的注意力和专业知识时在正常角色之外贡献功能和错误修复来平衡。更不明显的是，这种透明度也使工程师更难以编写不合适的代码而不被注意到。
- en: Including source code and related artifacts in your data classification effort
    can help you form a principled approach for protecting sensitive assets while
    benefiting from visibility into less sensitive assets, which you can read more
    about in [Chapter 21](ch21.html#twoone_building_a_culture_of_security_a).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的数据分类工作中包括源代码和相关工件可以帮助您形成一个有原则的方法来保护敏感资产，同时又能从对不太敏感资产的可见性中受益，您可以在[第21章](ch21.html#twoone_building_a_culture_of_security_a)中了解更多。
- en: Quality Data and Systems That Impact Security
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 影响安全的高质量数据和系统
- en: 'In a zero trust environment that is the underpinning of least privilege, every
    granular security decision depends on two things: the policy being enforced and
    the context of the request. *Context* is informed by a large set of data—some
    of it potentially dynamic—that can impact the decision. For example, the data
    might include the role of the user, the groups the user belongs to, the attributes
    of the client making the request, the training set fed into a machine learning
    model, or the sensitivity of the API being accessed. You should review the systems
    that produce this data to ensure that the quality of security-impacting data is
    as high as possible. Low-quality data will result in incorrect security decisions.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在零信任环境中，最小特权的基础上，每个细粒度的安全决策都取决于两件事：正在执行的策略和请求的上下文。*上下文*受到大量数据的影响，其中一些可能是动态的，这些数据可能会影响决策。例如，数据可能包括用户的角色、用户所属的组、发出请求的客户端的属性、输入到机器学习模型的训练集，或者被访问的API的敏感性。您应该审查产生这些数据的系统，以确保安全影响数据的质量尽可能高。低质量的数据将导致不正确的安全决策。
- en: Impact on User Productivity
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对用户生产力的影响
- en: Your users need to be able to accomplish their workflows as efficiently as possible.
    The best security posture is one that your end users don’t notice. However, introducing
    new three-factor and multi-party authorization steps may impinge on user productivity,
    especially if users must wait to be granted authorization. You can minimize user
    pain by making sure the new steps are easy to navigate. Similarly, end users need
    a simple way to make sense of access denials, either through self-service diagnosis
    or fast access to a support channel.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您的用户需要尽可能高效地完成其工作流程。最佳的安全姿态是您的最终用户不会注意到的。然而，引入新的三因素和多方授权步骤可能会影响用户的生产力，特别是如果用户必须等待获得授权。您可以通过确保新步骤易于导航来减轻用户的痛苦。同样，最终用户需要一种简单的方式来理解访问拒绝，可以通过自助诊断或快速访问支持渠道。
- en: Impact on Developer Complexity
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对开发人员复杂性的影响
- en: As the model for least privilege is adopted across your organization, developers
    must conform to it. The concepts and policies must be easily consumable by developers
    who aren’t particularly security-savvy, so you should provide training materials
    and thoroughly document your APIs.^([16](ch05.html#ch05fn18)) As they navigate
    the new requirements, give developers easy and fast access to security engineers
    for security reviews and general consulting. Deploying third-party software in
    this environment requires particular care, as you may need to wrap software in
    a layer that can enforce the security policy.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 随着最小特权模型在您的组织中得到采用，开发人员必须遵守它。这些概念和政策必须易于被不太懂安全的开发人员消化，因此您应该提供培训材料并充分记录您的API。在他们应对新要求时，为开发人员提供便捷快速地访问安全工程师进行安全审查和一般咨询。在这种环境中部署第三方软件需要特别小心，因为您可能需要将软件包装在一个可以执行安全策略的层中。
- en: Conclusion
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'When designing a complex system, the least privilege model is the most secure
    way to ensure that clients have the ability to accomplish what they need to do,
    but no more. This is a powerful design paradigm to protect your systems and your
    data from malicious or accidental damage caused by known or unknown users. Google
    has spent significant time and effort implementing this model. Here are the key
    components:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计复杂系统时，最小特权模型是确保客户能够完成所需工作，但不多的最安全方式。这是一种强大的设计范式，可以保护您的系统和数据免受已知或未知用户造成的恶意或意外损害。谷歌已经花费了大量时间和精力来实施这个模型。以下是关键组件：
- en: A comprehensive knowledge of the functionality of your system, so you can classify
    different parts according to the level of security risk each holds.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对系统功能的全面了解，以便根据每个部分的安全风险水平对其进行分类。
- en: Based on this classification, a partitioning of your system and access to your
    data to as fine a level as possible. Small functional APIs are a necessity for
    least privilege.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于这种分类，对系统和数据进行尽可能细致的分区。最小特权需要小型功能API。
- en: An authentication system for validating users’ credentials as they attempt to
    access your system.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于验证用户凭据的身份验证系统，当他们尝试访问您的系统时。
- en: An authorization system that enforces a well-defined security policy that can
    be easily attached to your finely partitioned systems.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制执行明确定义的安全策略的授权系统，可以轻松附加到您的精细分区系统上。
- en: A set of advanced controls for nuanced authorization. These can, for example,
    provide temporary, multi-factor, and multi-party approval.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一套用于微妙授权的高级控制。例如，这些控制可以提供临时、多因素和多方批准。
- en: 'A set of operational requirements for your system to support these key concepts.
    At a minimum, your system needs the following:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统支持这些关键概念的操作要求。至少，您的系统需要以下内容：
- en: The ability to audit all access and to generate signals so you can identify
    threats and perform historical forensic analysis
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计所有访问并生成信号，以便您可以识别威胁并进行历史取证分析。
- en: The means to reason about, define, test, and debug your security policy, and
    to provide end-user support for this policy
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推理、定义、测试和调试安全策略的手段，并为此策略提供最终用户支持
- en: The ability to provide a breakglass mechanism when your system does not behave
    as expected
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您的系统表现不如预期时，提供一个紧急访问机制
- en: Making all these components work in a way that is easy for users and developers
    to adopt, and that does not significantly impact their productivity, also requires
    an organizational commitment to making adoption of least privilege as seamless
    as possible. This commitment includes a focused security function that owns your
    security posture and interfaces with users and developers through security consulting,
    policy definition, threat detection, and support on security-related issues.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: While this can be a large undertaking, we strongly believe it is a significant
    improvement over existing approaches to security posture enforcement.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](ch05.html#ch05fn2-marker)) McIlroy, M.D., E.N. Pinson, and B.A. Tague.
    1978\. “UNIX Time-Sharing System: Foreword.” *The Bell System Technical Journal*
    57(6): 1899–1904\. doi:10.1002/j.1538-7305.1978.tb02135.x.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch05.html#ch05fn3-marker)) POSIX stands for Portable Operating System
    Interface, the IEEE standardized interface provided by most Unix variants. For
    a general overview, see [Wikipedia](https://oreil.ly/4vLTI).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch05.html#ch05fn4-marker)) The Windows API includes the familiar graphical
    elements, as well as the programming interfaces like [DirectX](https://oreil.ly/TnmPu),
    [COM](https://oreil.ly/PzTUF), etc.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch05.html#ch05fn5-marker)) [Memcached](https://memcached.org) is a high-performance,
    distributed memory object caching system.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch05.html#ch05fn6-marker)) [NATS](https://oreil.ly/baCc4) is an example
    of a basic API built on top of a text protocol, as opposed to a complex RPC interface
    like gRPC.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch05.html#ch05fn7-marker)) The [TinyURL.com](http://TinyURL.com) API isn’t
    well documented, but it is essentially a single GET URL that returns the shortened
    URL as the body of the response. This is a rare example of a mutable service with
    a tiny API.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch05.html#ch05fn8-marker)) The [Fonts API](https://oreil.ly/-Z4F4) simply
    lists the fonts currently available. It has exactly one endpoint.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '^([8](ch05.html#ch05fn9-marker)) A good starting point is Gamma, Erich et al.
    1994\. *Design Patterns: Elements of Reusable Object-Oriented Software*. Boston,
    MA: Addison-Wesley. See also Bloch, Joshua. 2006\. “How to Design a Good API and
    Why It Matters.” *Companion to the 21st ACM SIGPLAN Symposium on Object-Oriented
    Programming Systems, Languages, and Applications*: 506–507\. doi:10.1145/1176617.1176622.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch05.html#ch05fn11-marker)) Although we use Unix hosts as an example,
    this pattern is not unique to Unix. Traditional Windows host setup and management
    follows a similar model, where the interactive exposure of the Windows API is
    typically via RDP instead of OpenSSH.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: ^([10](ch05.html#ch05fn12-marker)) Popular options include running as an unprivileged
    user and then encoding allowed commands via `sudo`, granting only the necessary
    [`capabilities(7)`](https://oreil.ly/7Zf70), or using a framework like SELinux.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: ^([11](ch05.html#ch05fn2a-marker)) *Canarying* a change is rolling it out to
    production slowly, beginning with a small set of production endpoints. Like a
    canary in a coal mine, it provides warning signals if something goes wrong. See
    [Chapter 27 in the SRE book](https://landing.google.com/sre/sre-book/chapters/reliable-product-launches)
    for more.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: ^([12](ch05.html#ch05fn14-marker)) `ForceCommand` is a configuration option
    to constrain a particular authorized identity to run only a single command. See
    the [*sshd_config* manpage](https://oreil.ly/4ruSh) for more details.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: ^([13](ch05.html#ch05fn15-marker)) At scale, it may be impractical to log and
    store many duplicate copies of the file. Logging the hash allows you to correlate
    the config back to the revision control system, and detect unknown or unexpected
    configurations when auditing the log. As icing on the cake, and if space allows,
    you may wish to store rejected configurations to aid a later investigation. Ideally,
    all configs should be signed, indicating they came from the revision control system
    with a known hash, or rejected.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ^([13](ch05.html#ch05fn15-marker)) 在规模上，记录和存储许多重复文件副本可能是不切实际的。记录哈希值可以让您将配置关联回修订控制系统，并在审计日志中检测未知或意外的配置。作为额外的保险，如果空间允许，您可能希望存储被拒绝的配置，以帮助进行后续调查。理想情况下，所有配置应该被签名，表明它们来自具有已知哈希值的修订控制系统，或者被拒绝。
- en: ^([14](ch05.html#ch05fn16-marker)) A *bearer token* is just a cryptographic
    signature, signed by the rate limiter, which can be presented to anyone with the
    rate limiter’s public key. They can use that public key to validate that the rate
    limiter has approved this operation, during the validity window of the token.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ^([14](ch05.html#ch05fn16-marker)) *持票令牌*只是一个由速率限制器签名的加密签名，可以呈现给任何人，该人具有速率限制器的公钥。他们可以使用该公钥验证速率限制器在令牌的有效期内批准了此操作。
- en: ^([15](ch05.html#ch05fn17-marker)) Our internal variant supports our internal
    authentication primitives, avoids some circular dependency concerns, etc.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ^([15](ch05.html#ch05fn17-marker)) 我们的内部变体支持我们的内部身份验证原语，避免了一些循环依赖的问题等。
- en: ^([16](ch05.html#ch05fn18-marker)) See [“A Policy Framework for Authentication
    and Authorization Decisions”](#a_policy_framework_for_authentication_a).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ^([16](ch05.html#ch05fn18-marker)) 参见[“用于身份验证和授权决策的策略框架”](#a_policy_framework_for_authentication_a)。

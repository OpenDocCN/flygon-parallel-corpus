- en: Chapter 6\. Design for Understandability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。可理解性设计
- en: By Julien Boeuf‎, Christoph Kern‎, and John Reese‎
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由Julien Boeuf‎、Christoph Kern‎和John Reese‎
- en: with Guy Fischman, Paul Blankinship, Aleksandra Culver, Sergey Simakov, Peter
    Valchev, and Douglas Colish
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与Guy Fischman、Paul Blankinship、Aleksandra Culver、Sergey Simakov、Peter Valchev和Douglas
    Colish一起
- en: 'For the purposes of this book, we define a system’s *understandability* as
    the extent to which a person with relevant technical background can accurately
    and confidently reason about both of the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本书的目的，我们将系统的“可理解性”定义为具有相关技术背景的人能够准确自信地推理以下两点的程度：
- en: The operational behavior of the system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的操作行为
- en: The system’s invariants, including security and availability
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的不变性，包括安全性和可用性
- en: Why Is Understandability Important?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么可理解性很重要？
- en: 'Designing a system to be understandable, and maintaining that understandability
    over time, requires effort. Generally, this effort is an investment that’s repaid
    in the form of sustained project velocity (as discussed in [Chapter 4](ch04.html#design_tradeoffs)).
    More specifically, an understandable system has concrete benefits:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个可理解的系统，并在一段时间内保持其可理解性，需要努力。一般来说，这种努力是一种投资，以持续的项目速度回报（如[第4章](ch04.html#design_tradeoffs)中所讨论的）。更具体地说，可理解的系统具有具体的好处：
- en: Decreases the likelihood of security vulnerabilities or resilience failures
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 降低安全漏洞或韧性故障的可能性
- en: Whenever you modify a system or software component—for example, when you add
    a feature, fix a bug, or change configuration—there’s an inherent risk that you
    might accidentally introduce a new security vulnerability or compromise the system’s
    operational resilience. The less understandable the system, the more likely it
    is that the engineer who’s modifying it will make a mistake. That engineer might
    misunderstand the existing behavior of the system, or may be unaware of a hidden,
    implicit, or undocumented requirement that conflicts with the change.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时您修改系统或软件组件，例如添加功能，修复错误或更改配置，都存在您可能会意外引入新的安全漏洞或损害系统操作韧性的风险。系统越不易理解，修改它的工程师犯错的可能性就越大。该工程师可能会误解系统的现有行为，或者可能不知道与更改冲突的隐藏、隐含或未记录的要求。
- en: Facilitates effective incident response
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 促进有效的事故响应
- en: During an incident, it’s vital that responders can quickly and accurately assess
    damage, contain the incident, and identify and remediate root causes. A complex,
    difficult-to-understand system significantly hinders that process.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在事故发生时，响应者能够快速准确地评估损害，控制事故，并确定和纠正根本原因至关重要。一个复杂、难以理解的系统显著阻碍了这一过程。
- en: Increases confidence in assertions about a system’s security posture
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 增加对系统安全状况的断言的信心
- en: 'Assertions about a system’s security are typically expressed in terms of *invariants*:
    properties that must hold for *all possible* behaviors of the system. This includes
    how the system behaves in response to unexpected interactions with its external
    environment—for example, when the system receives malformed or maliciously crafted
    inputs. In other words, the system’s behavior in response to a malicious input
    must not violate a required security property. In a difficult-to-understand system,
    it is hard or sometimes impossible to verify with a high degree of confidence
    that such assertions hold. Testing is often insufficient to demonstrate that a
    “for all possible behaviors” property holds—testing typically exercises the system
    for only a relatively small fraction of possible behaviors that correspond to
    typical or expected operation.^([1](ch06.html#ch06fn1)) You usually need to rely
    on abstract reasoning about the system to establish such properties as invariants.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关于系统安全性的断言通常以“不变性”来表达：系统的所有可能行为都必须满足的属性。这包括系统对其外部环境的意外交互的响应，例如，当系统接收到格式错误或恶意制作的输入时。换句话说，系统对恶意输入的响应不得违反所需的安全属性。在难以理解的系统中，很难或有时不可能以高度自信来验证这样的断言是否成立。测试通常不足以证明“对于所有可能的行为”属性成立——测试通常只对系统进行了相对较小比例的行为的练习，这些行为对应于典型或预期的操作。^([1](ch06.html#ch06fn1))
    您通常需要依赖对系统的抽象推理来建立这样的属性作为不变性。
- en: System Invariants
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统不变性
- en: A *system invariant* is a property that is always true, no matter how the system’s
    environment behaves or misbehaves. The system is *fully responsible* for ensuring
    that a desired property is in fact an invariant, even if the system’s environment
    misbehaves in arbitrarily unexpected or malicious ways. That environment includes
    everything that you don’t have direct control over, from nefarious users who hit
    your service frontend with maliciously crafted requests to hardware failures that
    result in random crashes. One of our main goals in analyzing a system is to determine
    whether specific desired properties are actually invariants.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统不变性*是一个属性，无论系统的环境如何行为或不当行为，它始终为真。系统*完全负责*确保所需的属性实际上是不变的，即使系统的环境以任意意外或恶意的方式行为不当。该环境包括您无法直接控制的一切，从用恶意制作的请求击中您的服务前端的恶意用户到导致随机崩溃的硬件故障。分析系统的主要目标之一是确定特定所需属性是否实际上是不变的。'
- en: 'Here are some examples of desired security and reliability properties of a
    system:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是系统所需的一些安全性和可靠性属性的一些示例：
- en: Only authenticated and properly authorized users can access a system’s persistent
    data store.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有经过身份验证并得到适当授权的用户才能访问系统的持久数据存储。
- en: All operations on sensitive data in a system’s persistent data store are recorded
    in an audit log in accordance with the system’s auditing policy.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的持久数据存储中对敏感数据的所有操作都根据系统的审计政策记录在审计日志中。
- en: All values received from outside a system’s trust boundary are appropriately
    validated or encoded before being passed to APIs that are prone to injection vulnerabilities
    (e.g., SQL query APIs or APIs for constructing HTML markup).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统信任边界之外接收到的所有值在传递给易受注入漏洞的API（例如SQL查询API或用于构建HTML标记的API）之前都经过适当的验证或编码。
- en: The number of queries received by a system’s backend scales relative to the
    number of queries received by the system’s frontend.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统后端接收到的查询数量与系统前端接收到的查询数量成比例增长。
- en: If a system’s backend fails to respond to a query after a predetermined amount
    of time, the system’s frontend [gracefully degrades](https://oreil.ly/bLTJN)—for
    example, by responding with an approximate answer.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果系统后端在预定时间后未能响应查询，系统前端将[优雅地降级](https://oreil.ly/bLTJN)，例如通过返回一个近似答案。
- en: When the load on any component is greater than that component can handle, in
    order to reduce the risk of cascading failure, that component will serve [overload
    errors](https://oreil.ly/7eJtF) rather than crashing.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当任何组件的负载大于该组件可以处理的负载时，为了减少级联故障的风险，该组件将提供[超载错误](https://oreil.ly/7eJtF)而不是崩溃。
- en: A system can only receive RPCs from a set of designated systems and can only
    send RPCs to a set of designated systems.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统只能从一组指定系统接收RPC，并且只能向一组指定系统发送RPC。
- en: If your system allows behaviors that violate a desired security property—in
    other words, if the stated property isn’t actually an invariant—then the system
    has a security weakness or vulnerability. For example, imagine that property 1
    from the list is not true for your system because a request handler is missing
    access checks, or because those checks were implemented incorrectly. You now have
    a security vulnerability that could permit an attacker to access your users’ private
    data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统允许违反所需安全属性的行为，换句话说，如果所述属性实际上不是不变的，那么系统就存在安全弱点或漏洞。例如，想象一下，列表中的属性1对于您的系统来说并不成立，因为请求处理程序缺少访问检查，或者因为这些检查实施不正确。现在您的系统存在安全漏洞，可能允许攻击者访问用户的私人数据。
- en: 'Similarly, suppose your system does not satisfy the fourth property: under
    some circumstances, the system generates an excessive number of backend requests
    for each incoming frontend request. For example, perhaps the frontend generates
    multiple retries in quick succession (and without an appropriate backoff mechanism)
    if a backend request fails or takes too long. Your system has a potential availability
    weakness: once the system reaches this state, its frontend could completely overwhelm
    the backend and make the service unresponsive, in a kind of self-inflicted denial-of-service
    scenario.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，假设您的系统不满足第四个属性：在某些情况下，系统为每个传入的前端请求生成过多的后端请求。例如，也许前端如果后端请求失败或花费太长时间会快速生成多个重试（并且没有适当的退避机制）。您的系统存在潜在的可用性弱点：一旦系统达到这种状态，其前端可能会完全压倒后端并使服务无响应，形成一种自我造成的拒绝服务场景。
- en: Analyzing Invariants
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析不变量
- en: When analyzing whether a system meets a given invariant, there’s a tradeoff
    between the potential harm caused by violations of that invariant and the amount
    of effort you spend in meeting the invariant and verifying that it actually holds.
    On one end of the spectrum, that effort might involve running a few tests and
    reading parts of the source code to look for bugs—for example, forgotten access
    checks—that could lead to violation of the invariant. This approach does not lead
    to a particularly high degree of confidence. It’s quite possible, and in many
    cases likely, that behavior not covered by testing or in-depth code review will
    harbor bugs. It’s telling that well-understood common classes of software vulnerabilities
    like SQL injection, cross-site scripting (XSS), and buffer overflows have maintained
    leading positions in “top vulnerability” lists.^([2](ch06.html#ch06fn2)) Absence
    of evidence is not evidence of absence.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析系统是否满足给定的不变量时，存在违反该不变量可能造成的潜在危害与您花费在满足不变量和验证其实际成立的努力之间的权衡。在这个光谱的一端，这种努力可能涉及运行一些测试并阅读源代码的部分，以寻找可能导致违反不变量的错误，例如遗忘的访问检查。这种方法并不能带来特别高的信心。很可能，许多情况下未经测试或深入代码审查的行为将存在错误。值得注意的是，像SQL注入、跨站脚本（XSS）和缓冲区溢出等众所周知的常见软件漏洞类别一直在“顶级漏洞”列表中保持领先地位。[2]
    缺乏证据并不意味着证据的缺失。
- en: 'On the other end of the spectrum, you might perform analyses based on provably
    sound, formal reasoning: the system and the claimed properties are modeled in
    a formal logic, and you construct a logical proof (typically with the help of
    an automated proof assistant) that the property holds for the system.^([3](ch06.html#ch06fn3))
    This approach is difficult and involves a lot of work. For example, one of the
    largest software verification projects to date constructed a [proof](https://oreil.ly/qxVk2)
    of comprehensive correctness and security properties of a microkernel’s implementation
    at the machine code level; this project took approximately 20 person-years of
    effort.^([4](ch06.html#ch06fn4)) While formal verification is becoming practically
    applicable in certain situations, such as microkernels or complex cryptographic
    library code,^([5](ch06.html#ch06fn5)) it is typically not feasible for large-scale
    application software development projects.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，您可能会进行基于可证明的合理形式推理的分析：系统和所声称的属性在一个正式逻辑中建模，并且您构建一个逻辑证明（通常在自动证明助手的帮助下），证明该属性对系统成立。[3]
    这种方法很困难，需要大量工作。例如，迄今为止最大的软件验证项目之一构建了一个[证明](https://oreil.ly/qxVk2)，证明了微内核实现在机器代码级别的全面正确性和安全性属性；该项目大约耗费了20人年的工作。[4]
    尽管形式验证在某些情况下正在变得实用，比如微内核或复杂的加密库代码，[5] 但对于大规模应用软件开发项目来说通常是不可行的。
- en: This chapter aims to present a practical middle ground. By designing a system
    with an explicit goal of understandability, you can support principled (but still
    informal) arguments that the system has certain invariants and gain a fairly high
    degree of confidence in these assertions with a reasonable amount of effort. At
    Google, we’ve found this approach to be practical for large-scale software development,
    and highly effective in reducing the occurrence of common classes of vulnerabilities.
    For more discussion on testing and validation, see [Chapter 13](ch13.html#onethree_testing_code).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在提出一个实用的中间立场。通过设计一个明确的可理解性目标的系统，您可以支持有原则的（但仍然是非正式的）论证，即系统具有某些不变量，并且在合理的努力下对这些断言有相当高的信心。在谷歌，我们发现这种方法对大规模软件开发非常实用，并且在减少常见漏洞发生方面非常有效。有关测试和验证的更多讨论，请参见[第13章](ch13.html#onethree_testing_code)。
- en: Mental Models
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 心理模型
- en: Highly complex systems are difficult for humans to reason about in a holistic
    way. In practice, engineers and subject matter experts often construct mental
    models that explain relevant behaviors of a system while leaving out irrelevant
    details. For a complex system, you may construct multiple mental models that build
    on each other. In this way, when thinking about the behavior or invariants of
    a given system or subsystem, you can abstract away the details of its surrounding
    and underlying components and instead substitute their respective mental models.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 高度复杂的系统对人类来说很难以整体方式进行推理。在实践中，工程师和主题专家经常构建解释系统相关行为的心理模型，同时忽略不相关的细节。对于复杂系统，您可能构建多个相互补充的心理模型。这样，当思考给定系统或子系统的行为或不变量时，您可以抽象出其周围和底层组件的细节，而代之以它们各自的心理模型。
- en: Mental models are useful because they simplify reasoning about a complex system.
    For that same reason, mental models are also limited. If you form a mental model
    based on experience with a system performing under typical operating conditions,
    that model may not predict a system’s behavior in unusual scenarios. To a large
    extent, security and reliability engineering is concerned with analyzing systems
    in exactly those unusual conditions—for example, when a system is actively under
    attack, or in an overload or component-failure scenario.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 心理模型很有用，因为它们简化了对复杂系统的推理。出于同样的原因，心理模型也是有限的。如果您根据系统在典型操作条件下的经验形成了心理模型，那么该模型可能无法预测系统在不寻常情况下的行为。在很大程度上，安全性和可靠性工程关注的是在这些不寻常条件下分析系统，例如当系统处于主动攻击、过载或组件故障场景时。
- en: Consider a system whose throughput normally increases predictably and gradually
    with the rate of incoming requests. However, beyond a certain load threshold,
    the system might reach a state where it responds in a dramatically different fashion.
    For example, memory pressure might lead to thrashing^([6](ch06.html#ch06fn6))
    at the virtual memory or heap/garbage collector level, leaving the system unable
    to keep up with the additional load. Too much additional load could even lead
    to *decreased* throughput. When troubleshooting a system in this state, you could
    be seriously misled by an overly simplified mental model of the system, unless
    you explicitly recognize that the model no longer applies.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个系统，其吞吐量通常会随着传入请求的速率可预测地逐渐增加。然而，在某个负载阈值之上，系统可能会达到一个状态，其响应方式截然不同。例如，内存压力可能导致在虚拟内存或堆/垃圾收集器级别出现抖动，使系统无法跟上额外负载。太多的额外负载甚至可能导致*减少*吞吐量。在这种状态下排除系统故障时，除非您明确意识到该模型不再适用，否则您可能会被系统的过度简化心理模型误导。
- en: When designing systems, it’s valuable to consider the mental models that software,
    security, and reliability engineers will inevitably construct for themselves.
    When designing a new component to add to a larger system, ideally, its naturally
    emerging mental model should be consistent with the mental models people have
    formed for similar existing subsystems.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计系统时，考虑软件、安全和可靠性工程师不可避免地会为自己构建的心理模型是很有价值的。在设计要添加到较大系统中的新组件时，理想情况下，其自然形成的心理模型应与人们为类似的现有子系统形成的心理模型一致。
- en: When possible, you should also design systems so that their mental models remain
    predictive and useful when the system is operating under extreme or unusual conditions.
    For example, to avoid thrashing, you can configure production servers to run without
    on-disk virtual memory swap space. If a production service can’t allocate memory
    that it needs to respond to a request, it can quickly return an error in a predictable
    way. Even if a buggy or misbehaving service can’t handle a memory allocation failure
    and crashes, you can at least clearly attribute the failure to an underlying problem—in
    this case, memory pressure; that way, the mental models of the people observing
    the system remain useful.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，您还应设计系统，使其心理模型在系统在极端或不寻常条件下运行时仍然具有预测性和实用性。例如，为了避免抖动，您可以配置生产服务器在没有磁盘虚拟内存交换空间的情况下运行。如果生产服务无法分配所需的内存来响应请求，它可以以可预测的方式快速返回错误。即使有错误或行为不端的服务无法处理内存分配失败并崩溃，您至少可以清楚地将故障归因于潜在问题——在这种情况下是内存压力；这样，观察系统的人的心理模型仍然是有用的。
- en: Designing Understandable Systems
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计可理解的系统
- en: The remainder of this chapter discusses some concrete measures you can take
    to make a system more understandable, and to maintain a system’s understandability
    as it evolves over time. We’ll start by considering the issue of complexity.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分讨论了一些具体措施，可以使系统更易理解，并在系统随时间演变时保持其可理解性。我们将首先考虑复杂性问题。
- en: Complexity Versus Understandability
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂性与可理解性
- en: The primary enemy of understandability is *unmanaged complexity*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 可理解性的主要敌人是*未受控制的复杂性*。
- en: Some amount of complexity is often inherent and unavoidable because of the scale
    of modern software systems—especially distributed systems—and the problems they
    solve. For example, Google employs tens of thousands of engineers, who work in
    a source repository that contains over a billion lines of code. Those lines of
    code collectively implement a large number of user-facing services and the backends
    and data pipelines that support them. Even smaller organizations with a single
    product offering may implement hundreds of features and user stories in hundreds
    of thousands of lines of code, which is edited by tens or hundreds of engineers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现代软件系统的规模（尤其是分布式系统）及其解决的问题，某种程度的复杂性通常是内在的和不可避免的。例如，谷歌雇佣了数万名工程师，他们在一个包含超过10亿行代码的源代码库中工作。这些代码共同实现了大量的用户服务以及支持它们的后端和数据管道。即使是只提供单一产品的较小组织，也可能在数十万行代码中实现数百个功能和用户故事，由数十甚至数百名工程师编辑。
- en: 'Let’s take Gmail as an example of a system with significant inherent feature
    complexity. You could briefly sum up Gmail as a cloud-based email service, but
    that summary belies its complexity. Among its many features, Gmail offers the
    following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Gmail为例，这是一个具有重要内在特性复杂性的系统。你可以简要总结Gmail为基于云的电子邮件服务，但这一概括掩盖了它的复杂性。在其众多功能中，Gmail提供以下功能：
- en: Multiple frontends and UIs (desktop web, mobile web, mobile apps)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个前端和用户界面（桌面Web、移动Web、移动应用）
- en: Several [APIs](https://oreil.ly/RaYQx) that permit third-party developers to
    develop add-ons
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许第三方开发人员开发附加组件的几个API
- en: Inbound and outbound IMAP and POP interfaces
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入站和出站IMAP和POP接口
- en: Attachment handling that’s integrated with cloud storage services
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与云存储服务集成的附件处理
- en: Rendering of attachments in many formats, such as documents and spreadsheets
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以多种格式呈现附件，如文档和电子表格
- en: An offline-capable web client and underlying synchronization infrastructure
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离线可用的Web客户端和底层同步基础设施
- en: Spam filtering
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾邮件过滤
- en: Automatic message categorization
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动消息分类
- en: Systems for extracting structured information about flights, calendar events,
    etc.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于提取关于航班、日历事件等结构化信息的系统
- en: Spelling correction
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拼写纠正
- en: Smart Reply and Smart Compose
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能回复和智能撰写
- en: Reminders to reply to messages
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提醒回复消息
- en: A system with such features is inherently more complex than a system without
    them, but we can’t very well tell Gmail’s product managers that these features
    add too much complexity and ask them to remove them for the sake of security and
    reliability. After all, the features provide value, and are to a large extent
    what defines Gmail as a product. But if we work diligently to manage this complexity,
    the system can still be sufficiently secure and reliable.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 具有这些功能的系统本质上比没有这些功能的系统更复杂，但我们不能告诉Gmail的产品经理这些功能增加了太多复杂性，并要求他们出于安全性和可靠性的考虑将其删除。毕竟，这些功能提供了价值，并在很大程度上定义了Gmail作为产品。但如果我们努力管理这种复杂性，系统仍然可以足够安全和可靠。
- en: As mentioned previously, understandability is relevant in the context of specific
    behaviors and properties of systems and subsystems. Our goal must be to structure
    a system’s design to compartmentalize and contain this inherent complexity in
    a way that permits a human to reason with high fidelity about these *specific,
    relevant system properties and behaviors.* In other words, we must specifically
    manage the aspects of complexity that stand in the way of understandability.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，可理解性与系统和子系统的特定行为和属性相关。我们的目标必须是构建系统设计，以便以一种允许人类高度准确地推理这些*特定、相关系统属性和行为*的方式来分隔和包含这种内在复杂性。换句话说，我们必须特别管理妨碍可理解性的复杂性方面。
- en: Of course, this is easier said than done. The rest of this section investigates
    common sources of unmanaged complexity and corresponding decreased understandability,
    and design patterns that can help keep complexity under control and make systems
    more understandable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，说起来容易做起来难。本节的其余部分将探讨未受管理的复杂性的常见来源以及相应的降低可理解性的设计模式，以及可以帮助控制复杂性并使系统更易理解的设计模式。
- en: While our primary concerns are security and reliability, the patterns we discuss
    largely aren’t specific to those two areas—they are very much aligned with general
    software design techniques aimed at managing complexity and fostering understandability.
    You might also want to refer to general texts on system and software design, such
    as John Ousterhout’s *A Philosophy of Software Design* (Yaknyam Press, 2018).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的主要关注点是安全性和可靠性，但我们讨论的模式在很大程度上并不特定于这两个领域，它们与旨在管理复杂性和促进可理解性的一般软件设计技术非常一致。你可能还想参考有关系统和软件设计的一般文本，如约翰·奥斯特豪特的《软件设计哲学》（Yaknyam
    Press，2018）。
- en: Breaking Down Complexity
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分解复杂性
- en: To understand all the aspects of a complex system’s behavior, you need to internalize
    and maintain a large mental model. Humans simply aren’t very good at that.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解复杂系统行为的所有方面，你需要内化并维护一个庞大的心智模型。人类在这方面并不擅长。
- en: You can make a system more understandable by composing it from smaller components.
    You should be able to reason about each component in isolation, and combine them
    in such a way that you can derive the properties of the whole system from the
    component properties. This approach allows you to establish whole-system invariants
    *without* having to think about the entire system in one go.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过由较小的组件组合而成，可以使系统更易理解。你应该能够独立地推理每个组件，并以这样的方式组合它们，以便从组件属性推导出整个系统的属性。这种方法使你能够建立整个系统的不变性，而无需一次性考虑整个系统。
- en: This approach is not straightforward in practice. Your ability to establish
    properties of subsystems, and to combine properties of subsystems into system-wide
    properties, depends on how the whole system is structured into components and
    the nature of the interfaces and trust relationships between those components.
    We’ll look at these relationships and related considerations in [“System Architecture”](#system_architecture).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在实践中并不简单。您能够建立子系统的属性，并将子系统的属性组合成系统范围的属性，取决于整个系统如何被结构化为组件以及这些组件之间的接口和信任关系的性质。我们将在“系统架构”中讨论这些关系和相关考虑。
- en: Centralized Responsibility for Security and Reliability Requirements
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集中负责安全和可靠性要求
- en: As discussed in [Chapter 4](ch04.html#design_tradeoffs), security and reliability
    requirements often apply horizontally across all components of a system. For example,
    a security requirement might state that for any operation executed in response
    to a user request, the system must complete some common task (e.g., audit logging
    and operational metrics collection) or check some condition (e.g., authentication
    and authorization).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第4章](ch04.html#design_tradeoffs)所述，安全和可靠性要求通常横跨系统的所有组件。例如，安全要求可能规定，对于响应用户请求执行的任何操作，系统必须完成一些常见任务（例如审计日志记录和操作指标收集）或检查某些条件（例如身份验证和授权）。
- en: If each individual component is responsible for independently implementing common
    tasks and checks, it’s difficult to determine whether the resulting system actually
    satisfies the requirement. You can improve upon this design by moving responsibility
    for common functionalities to a centralized component—often a library or framework.
    For example, an RPC service framework can ensure that the system implements authentication,
    authorization, and logging for every RPC method according to a policy that’s defined
    centrally for the entire service. With this design, individual service methods
    aren’t responsible for these security functions, and application developers can’t
    forget to implement them or implement them incorrectly. In addition, a security
    reviewer can understand a service’s authentication and authorization controls
    without reading each individual service method implementation. Instead, the reviewer
    just needs to understand the framework and inspect the service-specific configuration.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个单独的组件都负责独立实现常见任务和检查，很难确定最终系统是否真正满足要求。您可以通过将常见功能的责任移交给集中组件（通常是库或框架）来改进这种设计。例如，RPC服务框架可以确保系统根据为整个服务集中定义的策略为每个RPC方法实现身份验证、授权和日志记录。有了这种设计，单个服务方法不再负责这些安全功能，应用程序开发人员也不会忘记实现它们或者实现不正确。此外，安全审阅者可以理解服务的身份验证和授权控制，而无需阅读每个单独的服务方法实现。相反，审阅者只需理解框架并检查特定于服务的配置。
- en: 'To provide another example: to prevent cascading failures under load, incoming
    requests should be subject to time-outs and deadlines. Any logic that retries
    failures caused by overload should be subject to stringent safety mechanisms.
    To implement these policies, you might rely on application or service code to
    configure deadlines for subrequests and appropriately process failures. A mistake
    or omission in any relevant code in a single application could result in a reliability
    weakness for the entire system. You can make a system more robust and more understandable
    with respect to reliability by including mechanisms in the underlying RPC service
    framework to support automatic deadline propagation and centralized handling of
    request cancellations.^([7](ch06.html#ch06fn8))'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 再举一个例子：为了防止负载下的级联故障，传入请求应该受到超时和截止日期的限制。任何重试由于过载引起的故障的逻辑都应受到严格的安全机制的约束。为了实施这些策略，您可能依赖应用程序或服务代码来配置子请求的截止日期并适当处理故障。单个应用程序中任何相关代码的错误或遗漏都可能导致整个系统的可靠性弱点。通过在底层RPC服务框架中包含支持自动截止日期传播和请求取消的集中处理机制，您可以使系统更加健壮和可理解。^([7](ch06.html#ch06fn8))
- en: 'These examples highlight two benefits of centralizing responsibility for security
    and reliability requirements:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子突出了集中负责安全和可靠性要求的两个好处：
- en: Improved understandability of the system
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 提高系统的可理解性
- en: A reviewer needs to look in only one place in order to understand and validate
    that a security/reliability requirement is implemented correctly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 审阅者只需查看一个地方，就能理解和验证安全/可靠性要求是否正确实现。
- en: Increased likelihood that the resulting system is actually correct
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 增加最终系统实际正确的可能性
- en: This approach removes the possibility that an ad hoc implementation of the requirement
    in application code is incorrect or missing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法消除了应用代码中对要求的临时实现不正确或缺失的可能性。
- en: While there’s an up-front cost to building and validating a centralized implementation
    as part of an application framework or library, this cost is amortized across
    all applications built based on that framework.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在构建和验证应用程序框架或库的集中实现时存在前期成本，但这些成本可以分摊到基于该框架构建的所有应用程序中。
- en: System Architecture
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统架构
- en: Structuring systems into layers and components is a key tool for managing complexity.
    Using this approach, you can reason about the system in chunks, rather than having
    to understand every detail of the whole system all at once.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将系统结构化为层和组件是管理复杂性的关键工具。使用这种方法，您可以按块来思考系统，而不必一次性理解整个系统的每个细节。
- en: You also need to think carefully about exactly how you break your system into
    components and layers. Components that are too tightly coupled are just as hard
    to understand as a monolithic system. To make a system understandable, you have
    to pay as much attention to the boundaries and interfaces between components as
    you do to the components themselves.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要仔细考虑如何将系统分解为组件和层。过于紧密耦合的组件和层与单片系统一样难以理解。要使系统可理解，您必须像关注组件本身一样关注组件之间的边界和接口。
- en: Experienced software developers are usually aware that a system must consider
    inputs from (and sequences of interactions with) its external environment untrustworthy,
    and that a system can’t make assumptions about those inputs. In contrast, it can
    be tempting to treat callers of internal, lower-layer APIs (such as APIs of in-process
    service objects, or RPCs exposed by internal backend microservices) as trustworthy,
    and to rely on those callers to stay within documented constraints on the API’s
    usage.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有经验的软件开发人员通常知道系统必须将来自外部环境的输入（和交互序列）视为不可信，并且系统不能对这些输入做出假设。相比之下，很容易将内部、较低层API的调用者（如进程内服务对象的API或内部后端微服务暴露的RPC）视为可信任，并依赖这些调用者遵守API使用的文档约束。
- en: Suppose that a security property of the system depends on the correct operation
    of an internal component. Also, suppose that its correct operation in turn depends
    on preconditions ensured by the component’s API’s callers, such as correct sequencing
    of operations, or constraints on values of method parameters. Determining whether
    the system actually has the desired property requires not only understanding the
    API’s implementation, but understanding every call site of the API across the
    entire system, and whether every such call site ensures the required precondition.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设系统的安全属性取决于内部组件的正确操作。另外，假设其正确操作又取决于组件API的调用者确保的前提条件，比如操作的正确顺序，或者方法参数的值的约束。确定系统是否实际具有所需的属性不仅需要理解API的实现，还需要理解整个系统中API的每个调用点，以及每个调用点是否确保了所需的前提条件。
- en: The fewer assumptions a component makes about its callers, the easier it is
    to reason about that component in isolation. Ideally, a component makes no assumptions
    about its callers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 组件对其调用者做出的假设越少，就越容易独立推理该组件。理想情况下，组件对其调用者不做任何假设。
- en: If a component is forced to make assumptions about its callers, it’s important
    to capture these assumptions explicitly in the design of interfaces, or in other
    constraints on the environment—for example, by restricting the set of principals
    who can interact with the component.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件被迫对其调用者做出假设，重要的是要在接口设计中明确捕获这些假设，或者在环境的其他约束中明确捕获这些假设，例如限制可以与组件交互的主体集。
- en: Understandable Interface Specifications
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可理解的接口规范
- en: Structured interfaces, consistent object models, and idempotent operations contribute
    to a system’s understandability. As described in the following sections, these
    considerations make it easier to predict output behavior and how the interfaces
    will interact.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化接口、一致的对象模型和幂等操作有助于系统的可理解性。如下节所述，这些考虑因素使得更容易预测输出行为以及接口之间的交互方式。
- en: Prefer narrow interfaces that offer less room for interpretation
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更喜欢提供较少解释空间的窄接口
- en: 'Services can use many different models and frameworks to expose interfaces.
    To name just a few:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可以使用许多不同的模型和框架来公开接口。举几个例子：
- en: RESTful HTTP with JSON with OpenAPI
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有OpenAPI的RESTful HTTP和JSON
- en: gRPC
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC
- en: Thrift
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thrift
- en: W3C Web Services (XML/WSDL/SOAP)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: W3C Web Services（XML/WSDL/SOAP）
- en: CORBA
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CORBA
- en: DCOM
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DCOM
- en: Some of these models are very flexible, while others provide more structure.
    For example, a service that uses gRPC or Thrift defines the name of each RPC method
    it supports, as well as the types of that method’s input and output. By contrast,
    a free-form RESTful service might accept any HTTP request, while application code
    validates that the request body is a JSON object with an expected structure.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些模型非常灵活，而其他模型提供更多结构。例如，使用gRPC或Thrift的服务定义了它支持的每个RPC方法的名称，以及该方法的输入和输出类型。相比之下，自由格式的RESTful服务可能接受任何HTTP请求，而应用代码验证请求体是否为具有预期结构的JSON对象。
- en: Frameworks that support user-defined types (such as gRPC, Thrift, and OpenAPI)
    make it easier to create tooling for features like cross referencing and conformance
    checks that enhance the discoverability and understandability of an API surface.
    Such frameworks typically also allow for safer evolution of an API surface over
    time. For example, OpenAPI has API versioning as a built-in feature. Protocol
    buffers, used for declaring gRPC interfaces, have [well-documented guidelines](https://oreil.ly/yRUQ3)
    on how to update message definitions to retain backward compatibility.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 支持用户定义类型的框架（如gRPC、Thrift和OpenAPI）使得更容易创建工具，用于增强API表面的可发现性和可理解性，比如交叉引用和一致性检查。这些框架通常也允许API表面随着时间的推移更安全地演化。例如，OpenAPI具有API版本控制作为内置功能。用于声明gRPC接口的协议缓冲区有关如何更新消息定义以保持向后兼容性的[详细文档指南](https://oreil.ly/yRUQ3)。
- en: In contrast, an API built on free-form JSON strings can be hard to understand
    unless you inspect its implementation code and core business logic. This unconstrained
    approach may lead to security or reliability incidents. For example, if a client
    and a server are updated independently, they may interpret an RPC payload differently,
    which could cause one of them to crash.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，基于自由格式JSON字符串构建的API在不检查其实现代码和核心业务逻辑的情况下可能难以理解。这种无约束的方法可能导致安全或可靠性事件。例如，如果客户端和服务器独立更新，它们可能以不同方式解释RPC有效负载，这可能导致其中一个崩溃。
- en: The lack of an explicit API specification also makes evaluating the security
    posture of the service difficult. For instance, unless you had access to the API
    definition, it would be hard to build an automatic security audit system to correlate
    the policies described in an authorization framework like [Istio Authorization
    Policy](https://oreil.ly/DjOpK) with the actual surface area exposed by services.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏明确的API规范也使得评估服务的安全姿态变得困难。例如，除非您可以访问API定义，否则很难构建一个自动安全审计系统，将授权框架（如[Istio授权策略](https://oreil.ly/DjOpK)中描述的策略与服务实际暴露的表面积相关联。
- en: Prefer interfaces that enforce a common object model
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优先选择强制实施通用对象模型的接口
- en: 'Systems that manage multiple types of resources can benefit from a common object
    model, such as the model used for [Kubernetes](https://oreil.ly/AtXnp). Rather
    than handling each resource type separately, a common object model lets engineers
    use a single mental model to understand large parts of a system. For example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 管理多种类型资源的系统可以从一个通用的对象模型中受益，比如[Kubernetes](https://oreil.ly/AtXnp)使用的模型。通用对象模型让工程师可以使用单一的思维模型来理解系统的大部分内容，而不是单独处理每种资源类型。例如：
- en: Each object in the system can be guaranteed to satisfy a set of predefined base
    properties (invariants).
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统中的每个对象都可以保证满足一组预定义的基本属性（不变量）。
- en: The system can provide standard ways to scope, annotate, reference, and group
    objects of all types.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统可以提供标准的方式来范围、注释、引用和分组所有类型的对象。
- en: Operations can have consistent behavior across all types of objects.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作可以在所有类型的对象上具有一致的行为。
- en: Engineers can create custom object types to support their use cases, and can
    reason about these object types using the same mental model they use for built-in
    types.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工程师可以创建自定义对象类型来支持他们的用例，并且可以使用与内置类型相同的思维模型来推理这些对象类型。
- en: Google provides general [guidelines for designing resource-oriented APIs](https://oreil.ly/AyMVP).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Google提供了关于设计面向资源的API的[一般指南](https://oreil.ly/AyMVP)。
- en: Pay attention to idempotent operations
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意幂等操作
- en: An idempotent operation will yield the same result when applied multiple times.
    For example, if a person pushes a button for floor two in an elevator, the elevator
    will go to the second floor every time. Pushing the button again, even multiple
    times, will not change the outcome.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等操作在多次应用时会产生相同的结果。例如，如果一个人在电梯里按下二楼的按钮，电梯每次都会到达二楼。再次按下按钮，甚至多次按下，都不会改变结果。
- en: In distributed systems, idempotency is important because operations may arrive
    out of order, or a server’s response after completing an operation may never reach
    the client. If an API method is idempotent, a client may retry an operation until
    it receives a successful result. If a method isn’t idempotent, the system may
    need to use a secondary approach, such as polling the server to see whether a
    newly created object already exists.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，幂等性很重要，因为操作可能以无序的方式到达，或者服务器在完成操作后的响应可能永远不会到达客户端。如果一个API方法是幂等的，客户端可以重试操作，直到收到成功的结果。如果一个方法不是幂等的，系统可能需要使用次要方法，比如轮询服务器来查看新创建的对象是否已经存在。
- en: Idempotency also affects engineers’ mental models. A mismatch between an API’s
    actual behavior and its expected behavior can lead to unreliable or incorrect
    results. For example, suppose that a client wants to add a record to a database.
    Although the request succeeds, the response isn’t delivered because of a connection
    reset. If the client code’s authors believe the operation to be idempotent, the
    client will likely retry the request. But if the operation is not actually idempotent,
    the system will create a duplicate record.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等性也会影响工程师的思维模型。API的实际行为与预期行为之间的不匹配可能导致不可靠或不正确的结果。例如，假设客户端想要向数据库添加一条记录。虽然请求成功，但由于连接重置，响应未被传递。如果客户端代码的作者认为该操作是幂等的，客户端很可能会重试该请求。但如果操作实际上不是幂等的，系统将创建一个重复的记录。
- en: While nonidempotent operations can be necessary, idempotent operations often
    lead to a simpler mental model. When an operation is idempotent, engineers (including
    developers and incident responders) don’t need to keep track of when an operation
    started; they can simply keep trying the operation until they know it succeeds.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然非幂等操作可能是必要的，但幂等操作通常会导致更简单的思维模型。当操作是幂等的时，工程师（包括开发人员和事件响应者）不需要跟踪操作何时开始；他们可以简单地不断尝试操作，直到知道它成功为止。
- en: Some operations are naturally idempotent, and you can make other operations
    idempotent by restructuring them. In the preceding example, the database could
    ask the client to include a unique identifier (e.g., a UUID) with each mutating
    RPC. If the server receives a second mutation with the same unique identifier,
    it knows that the operation is a duplicate and can respond accordingly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作自然是幂等的，通过重新构造其他操作也可以使其成为幂等。在前面的例子中，数据库可以要求客户端在每次变异的RPC中包含一个唯一标识符（例如UUID）。如果服务器收到具有相同唯一标识符的第二次变异，它就知道该操作是重复的，并可以相应地做出响应。
- en: Understandable Identities, Authentication, and Access Control
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可理解的身份、认证和访问控制
- en: Any system should be able to identify who has access to which resources, especially
    if the resources are highly sensitive. For example, a payment system auditor needs
    to understand which insiders have access to customers’ personally identifiable
    information. Typically, systems have authorization and access control policies
    that limit access of a given entity to a given resource in a given context—in
    this case, a policy would limit employee access to PII data when credit cards
    are processed. When this specific access occurs, an auditing framework can log
    the access. Later, you can automatically analyze the access log, either as part
    of a routine check or as part of an incident investigation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 任何系统都应该能够确定谁有权访问哪些资源，特别是如果这些资源非常敏感。例如，支付系统的审计员需要了解哪些内部人员可以访问客户的个人身份信息。通常，系统具有授权和访问控制策略，限制特定实体在特定上下文中对特定资源的访问——在这种情况下，策略将限制员工在处理信用卡时对PII数据的访问。当发生这种特定访问时，审计框架可以记录访问。稍后，您可以自动分析访问日志，作为例行检查的一部分，或作为事故调查的一部分。
- en: Identities
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 身份
- en: An *identity* is the set of attributes or identifiers that relate to an entity.
    *Credentials* assert the identity of a given entity. Credentials can take different
    forms, such as a simple password, an X.509 certificate, or an OAuth2 token. Credentials
    are typically sent using a defined *authentication protocol*, which access control
    systems use to identify the entities that access a resource. Identifying entities
    and choosing a model to identify them can be complex. While it’s relatively easy
    to reason about how the system recognizes human entities (both customers and administrators),
    large systems need to be able to identify all entities, not just human ones.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*身份*是与实体相关的属性或标识符集合。*凭证*断言了特定实体的身份。凭证可以采用不同的形式，例如简单密码、X.509证书或OAuth2令牌。凭证通常使用定义好的*认证协议*发送，访问控制系统用于识别访问资源的实体。识别实体并选择一个用于识别它们的模型可能是复杂的。虽然系统识别人类实体（包括客户和管理员）相对容易，但大型系统需要能够识别所有实体，而不仅仅是人类实体。'
- en: Large systems are often composed of a constellation of microservices that call
    each other, either with or without human involvement. For example, a database
    service may want to periodically snapshot to a lower-level disk service. This
    disk service may want to call a quota service to ensure that the database service
    has sufficient disk quota for the data that needs to be snapshotted. Or, consider
    a customer authenticating to a food-ordering frontend service. The frontend service
    calls a backend service, which in turn calls a database to retrieve the customer’s
    food preferences. In general, *active entities* are the set of humans, software
    components, and hardware components that interact with one another in the system.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 大型系统通常由一系列相互调用的微服务组成，无论是否涉及人类。例如，数据库服务可能希望定期快照到较低级别的磁盘服务。这个磁盘服务可能需要调用配额服务，以确保数据库服务有足够的磁盘配额来存储需要快照的数据。或者，考虑一个客户对食品订购前端服务进行身份验证。前端服务调用后端服务，后端服务再调用数据库来检索客户的食品偏好。一般来说，*活动实体*是系统中相互交互的人类、软件组件和硬件组件的集合。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Traditional network security practices sometimes use IP addresses as the primary
    identifier for both access control and logging and auditing (for example, firewall
    rules). Unfortunately, IP addresses have a number of disadvantages in modern microservices
    systems. Because they lack stability and security (and are easily spoofable),
    IP addresses simply don’t provide a suitable identifier to identify services and
    model their level of privilege in the system. For starters, microservices are
    deployed on pools of hosts, with multiple services hosted on the same host. Ports
    don’t provide a strong identifier, as they can be reused over time or—even worse—arbitrarily
    chosen by the different services that run on the host. A microservice may also
    serve different instances running on different hosts, which means you can’t use
    IP addresses as a stable identifier.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的网络安全实践有时使用IP地址作为访问控制和日志记录和审计（例如防火墙规则）的主要标识符。不幸的是，在现代微服务系统中，IP地址存在许多缺点。因为它们缺乏稳定性和安全性（并且很容易被伪造），IP地址简单地不能提供一个适当的标识符来识别服务并模拟它们在系统中的特权级别。首先，微服务部署在主机池上，多个服务托管在同一主机上。端口并不提供一个强大的标识符，因为它们可以随着时间的推移被重复使用，或者更糟糕的是，由运行在主机上的不同服务任意选择。一个微服务也可能为在不同主机上运行的不同实例提供服务，这意味着您不能使用IP地址作为稳定的标识符。
- en: The quality of access control and auditing mechanisms depends on the relevance
    of the identities used in the system and their trust relationships. Attaching
    a meaningful identifier to all active entities in a system is a fundamental step
    for understandability, in terms of both security and reliability. In terms of
    security, identifiers help you determine who has access to what. In terms of reliability,
    identifiers help you plan and enforce the use of shared resources like CPU, memory,
    and network bandwidth.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制和审计机制的质量取决于系统中使用的身份的相关性和它们的信任关系。在系统中为所有活动实体附加有意义的标识符是理解能力的基本步骤，无论是在安全性还是可靠性方面。在安全性方面，标识符帮助您确定谁可以访问什么。在可靠性方面，标识符帮助您规划和执行共享资源的使用，如CPU、内存和网络带宽。
- en: An organization-wide identity system reinforces a common mental model and means
    the entire workforce can speak the same language when referring to entities. Having
    competing identity systems for the same types of entities—for example, coexisting
    systems of global and local entities—makes comprehension unnecessarily complex
    for engineers and auditors.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 组织范围的身份系统强化了共同的心智模型，意味着整个员工队伍在提及实体时可以使用相同的语言。对于相同类型的实体存在竞争性的身份系统，例如全球和本地实体的共存系统，会使工程师和审计员的理解变得不必要复杂。
- en: Similar to the external payment processing services in the widget ordering example
    in [Chapter 4](ch04.html#design_tradeoffs), companies can externalize their identity
    subsystems. [OpenID Connect (OIDC)](https://openid.net/connect) provides a framework
    that allows a given provider to assert identities. Rather than implementing its
    own identity subsystem, the organization is responsible only for configuring which
    providers it accepts. As with all dependencies, however, there’s a tradeoff to
    consider—in this case, between the simplicity of this model versus the perceived
    security and reliability robustness of the trusted providers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于[第4章](ch04.html#design_tradeoffs)中小部件订购示例中的外部支付处理服务，公司可以将其身份子系统外部化。[OpenID
    Connect（OIDC）](https://openid.net/connect)提供了一个框架，允许特定提供者断言身份。组织只需配置接受哪些提供者，而不是实现自己的身份子系统。然而，与所有依赖关系一样，这里需要考虑一个权衡——在这种情况下，是这种模型的简单性还是受信任提供者的感知安全性和可靠性的稳健性之间的权衡。
- en: 'Example: Identity model for the Google production system'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例：谷歌生产系统的身份模型
- en: 'Google models identities by using different types of of active entities:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌通过使用不同类型的活动实体来建模身份：
- en: Administrators
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员
- en: Humans (Google engineers) who can take actions to mutate the state of the system—for
    example, by pushing a new release or modifying a configuration.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 人类（谷歌工程师）可以采取行动改变系统的状态，例如推送新版本或修改配置。
- en: Machines
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 机器
- en: Physical machines in a Google datacenter. These machines run the programs that
    implement our services (like Gmail), along with the services the system itself
    needs (for example, an internal time service).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌数据中心的物理机器。这些机器运行实现我们服务的程序（如Gmail），以及系统本身需要的服务（例如内部时间服务）。
- en: Workloads
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 工作负载
- en: These are scheduled on machines by the Borg orchestration system, which is similar
    to Kubernetes.^([9](ch06.html#ch06fn10)) Most of the time, the identity of a workload
    is different from the identities of the machines it runs on.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实体由类似于Kubernetes的Borg编排系统在机器上调度。大多数情况下，工作负载的身份与其运行的机器的身份不同。
- en: Customers
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 客户
- en: The Google customers who access Google-provided services.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌客户访问由谷歌提供的服务。
- en: '*Administrators* are at the base of all interactions within the production
    system. In the case of workload-to-workload interactions, administrators may not
    actively modify the state of the system, but they initiate the action of starting
    a workload during the bootstrap phase (which may itself start another workload).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*管理员*是生产系统内所有交互的基础。在工作负载之间的交互中，管理员可能不会主动修改系统的状态，但他们在引导阶段启动工作负载的行为（可能会启动另一个工作负载）。'
- en: As described in [Chapter 5](ch05.html#design_for_least_privilege), you can use
    auditing to trace all actions back to an administrator (or set of administrators),
    so you can establish accountability and analyze a given employee’s level of privilege.
    Meaningful identities for administrators and the entities they manage make auditing
    possible.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第5章](ch05.html#design_for_least_privilege)中所述，您可以使用审计来追溯所有操作到管理员（或一组管理员），以便建立责任和分析特定员工的特权级别。管理员和他们管理的实体的有意义的身份使审计成为可能。
- en: Administrators are managed by a global directory service integrated with single
    sign-on. A global group management system can group administrators to represent
    the concept of teams.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员由全局目录服务集成的单点登录管理。全局组管理系统可以将管理员分组以代表团队的概念。
- en: '*Machines* are cataloged in a global inventory service/machine database. On
    the Google production network, machines are addressable using a DNS name. We also
    need to tie the machine identity to administrators in order to represent who can
    modify the software running on the machine. In practice, we usually unite the
    group that releases the machine’s software image with the group that can log on
    to the machine as root.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*机器*在全局库存服务/机器数据库中进行分类。在谷歌生产网络上，可以使用DNS名称寻址机器。我们还需要将机器身份与管理员联系起来，以表示谁可以修改机器上运行的软件。实际上，我们通常将发布机器软件镜像的组与可以以root身份登录到机器的组合在一起。'
- en: Every production machine in Google’s datacenters has an identity. The *identity*
    refers to the typical purpose of the machine. For example, lab machines dedicated
    to testing have different identities than those running production workloads.
    Programs like machine management daemons that run core applications on a machine
    reference this identity.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌数据中心的每台生产机器都有一个身份。*身份*指的是机器的典型用途。例如，专用于测试的实验室机器与运行生产工作负载的机器具有不同的身份。运行机器上的核心应用程序的机器管理守护程序引用此身份。
- en: '*Workloads* are scheduled on machines using an orchestration framework. Each
    workload has an identity chosen by the requester. The orchestration system is
    responsible for ensuring that the entity that makes a request has the right to
    make the request, and specifically that the requestor has the right to schedule
    a workload running as the requested identity. The orchestration system also enforces
    constraints on which machines a workload can be scheduled on. Workloads themselves
    can perform administrative tasks like group management, but should not have root
    or admin rights on the underlying machine.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*工作负载*使用编排框架在机器上调度。每个工作负载都有一个由请求者选择的身份。编排系统负责确保发出请求的实体有权发出请求，特别是请求者有权以所请求的身份调度运行工作负载。编排系统还对工作负载可以调度到哪些机器施加约束。工作负载本身可以执行组管理等管理任务，但不应具有底层机器的根或管理员权限。'
- en: '*Customer* identities also have a specialized identity subsystem. Internally,
    these identities are used each time a service performs an action on a customer’s
    behalf. *Access control* explains how customer identities work in coordination
    with workload identities. Externally, Google provides [OpenID Connect workflows](https://oreil.ly/vxJAP)
    to allow customers to use their Google identity to authenticate to endpoints not
    controlled by Google (such as *zoom.us*).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*客户*身份也有一个专门的身份子系统。在内部，每当服务代表客户执行操作时，这些身份都会被使用。*访问控制*解释了客户身份如何与工作负载身份协调工作。在外部，Google提供[OpenID
    Connect工作流程](https://oreil.ly/vxJAP)允许客户使用其Google身份对不受Google控制的端点（例如*zoom.us*）进行身份验证。'
- en: Authentication and transport security
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 身份验证和传输安全
- en: Authentication and transport security are complicated disciplines that require
    specialized knowledge of areas like cryptography, protocol design, and operating
    systems. It’s not reasonable to expect every engineer to understand all of these
    topics in depth.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证和传输安全是复杂的学科，需要对诸如密码学、协议设计和操作系统等领域有专门的知识。不合理地期望每个工程师都深入了解所有这些主题。
- en: Instead, engineers should be able to understand abstractions and APIs. A system
    like Google’s [Application Layer Transport Security (ALTS)](https://oreil.ly/EsBfd)
    provides automatic service-to-service authentication and transport security to
    applications. That way, application developers don’t need to worry about how credentials
    are provisioned or which specific cryptographic algorithm is used to secure data
    on the connection.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，工程师应该能够理解抽象和API。像Google的[应用层传输安全（ALTS）](https://oreil.ly/EsBfd)这样的系统为应用程序提供了自动的服务对服务身份验证和传输安全。这样，应用程序开发人员就不需要担心凭据是如何配置的，或者用于在连接上保护数据的具体加密算法是什么。
- en: 'The mental model for the application developer is simple:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发人员的心智模型很简单：
- en: 'An application is run as a meaningful identity:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序以有意义的身份运行：
- en: A tool on an administrator’s workstation to access production typically runs
    as that administrator’s identity.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员工作站上的工具通常以管理员的身份运行，用于访问生产环境。
- en: A privileged process on a machine typically runs as that machine’s identity.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器上的特权进程通常以该机器的身份运行。
- en: An application deployed as a workload using an orchestration framework typically
    runs as a workload identity specific to the environment and service provided (such
    as *myservice-frontend-prod*).
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用编排框架将应用程序部署为工作负载，通常以特定于环境和服务提供的工作负载身份运行（例如*myservice-frontend-prod*）。
- en: ALTS provides zero-config transport security on the wire.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ALTS提供了零配置的传输安全。
- en: An API for common access control frameworks retrieves authenticated peer information.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见访问控制框架的API检索经过身份验证的对等信息。
- en: ALTS and similar systems—for example, [Istio’s security model](https://oreil.ly/17Jm6)—provide
    authentication and transport security in an understandable way.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ALTS和类似系统（例如[Istio的安全模型](https://oreil.ly/17Jm6)）以可理解的方式提供身份验证和传输安全。
- en: Unless an infrastructure’s application-to-application security posture uses
    a systematic approach, it is difficult or impossible to reason about. For example,
    suppose that application developers have to make individual choices about the
    type of credentials to use, and the workload identity these credentials will assert.
    To verify that the application performs authentication correctly, an auditor would
    need to manually read all of the application’s code. This approach is bad for
    security—it doesn’t scale, and some portion of the code will likely be either
    unaudited or incorrect.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除非基础设施的应用程序间安全姿态采用系统化的方法，否则很难或不可能进行推理。例如，假设应用程序开发人员必须就要使用的凭据类型以及这些凭据将断言的工作负载身份做出个别选择。要验证应用程序是否正确执行身份验证，审计员需要手动阅读所有应用程序的代码。这种方法对安全性来说是不好的——它不具备可扩展性，而且代码的某部分很可能是未经审计或不正确的。
- en: Access control
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问控制
- en: Using frameworks to codify and enforce access control policies for incoming
    service requests is a net benefit for the understandability of the global system.
    Frameworks reinforce common knowledge and provide a unified way to describe policies,
    and are thus an important part of an engineer’s toolkit.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用框架对传入服务请求的访问控制策略进行编码和强制执行对于全局系统的可理解性是一个净利益。框架强化了共同的知识，并提供了一种统一的描述策略的方式，因此是工程师工具包的重要组成部分。
- en: 'Frameworks can handle inherently complex interactions, such as the multiple
    identities involved in transferring data between workloads. For example, [Figure 6-1](#interactions_involved_in_transferring_d)
    shows the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 框架可以处理固有复杂的交互，例如在工作负载之间传输数据涉及的多个身份。例如，[图6-1](#interactions_involved_in_transferring_d)显示了以下内容：
- en: 'A chain of workloads running as three identities: *Ingress*, *Frontend*, and
    *Backend*'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为三个身份运行的工作负载链：*Ingress*、*Frontend*和*Backend*
- en: An authenticated customer making a request
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行请求的经过身份验证的客户
- en: '![Interactions involved in transferring data between workloads](assets/bsrs_0601.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![工作负载之间传输数据涉及的交互](assets/bsrs_0601.png)'
- en: Figure 6-1\. Interactions involved in transferring data between workloads
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-1。工作负载之间传输数据涉及的交互
- en: For each link in the chain, the framework must be able to determine whether
    the workload or the customer is the authority for the request. Policies must also
    be expressive enough for it to decide which workload identity is allowed to retrieve
    data on behalf of the customer.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于链中的每个链接，框架必须能够确定是工作负载还是客户是请求的权威。策略还必须足够表达性，以便它决定允许哪个工作负载身份代表客户检索数据。
- en: Equipped with one unified way to capture this inherent complexity, the majority
    of engineers can understand these controls. If each service team had its own ad
    hoc system for dealing with the same complex use case, understandability would
    be a challenge.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 具备一种统一的方式来捕获这种固有复杂性，大多数工程师都能理解这些控制。如果每个服务团队都有自己的临时系统来处理相同的复杂用例，理解起来将是一个挑战。
- en: Frameworks dictate consistency in specifying and applying declarative access
    control policies. This declarative and unified nature allows engineers to develop
    tools to evaluate the security exposure of services and user data within the infrastructure.
    If the access control logic were implemented in an ad hoc fashion at the application
    code level, developing that tooling would be essentially impossible.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 框架规定了在指定和应用声明式访问控制策略方面的一致性。这种声明式和统一的性质使工程师能够开发工具来评估基础设施中服务和用户数据的安全风险。如果访问控制逻辑是以自发方式在应用程序代码级别实现的，开发这种工具基本上是不可能的。
- en: 'DEEP DIVE: Security Boundaries'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入探讨：安全边界
- en: The *trusted computing base* (TCB) of a system is “the set of components (hardware,
    software, human, …) whose correct functioning is sufficient to ensure that the
    security policy is enforced, or more vividly, whose failure could cause a breach
    of the security policy.”^([10](ch06.html#ch06fn11)) As such, the TCB must uphold
    the security policy even if any entity *outside* of the TCB misbehaves in arbitrary
    and possibly malicious ways. Of course, the area outside of the TCB includes your
    system’s external environment (such as malicious actors somewhere across the internet),
    but this area *also* includes parts of *your own system* that are not within the
    TCB.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的*可信计算基础*（TCB）是“足以确保执行安全策略的一组组件（硬件、软件、人员等）的正确功能，或者更生动地说，其失败可能导致安全策略的违反。”。因此，TCB必须维护安全策略，即使TCB之外的任何实体以任意可能恶意的方式行为不端。当然，TCB之外的区域包括您系统的外部环境（例如互联网上某处的恶意行为者），但这个区域*也*包括不在TCB内的您自己系统的部分。
- en: The interface between the TCB and “everything else” is referred to as a *security
    boundary*. “Everything else”—other parts of the system, the external environment,
    clients of the system that interact with it via a network, and so on—interacts
    with the TCB by communicating across this boundary. This communication might be
    in the form of an interprocess communication channel, network packets, and higher-level
    protocols built on those foundations (like gRPC). The TCB must treat anything
    that crosses the security boundary with suspicion—both the data itself and other
    aspects, like message ordering.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: TCB与“其他一切”之间的接口被称为*安全边界*。“其他一切”——系统的其他部分、外部环境、通过网络与其交互的系统客户端等——通过跨越这个边界进行通信与TCB交互。这种通信可能以进程间通信通道、网络数据包和建立在这些基础上的更高级协议的形式进行（如gRPC）。TCB必须对跨越安全边界的任何东西持怀疑态度——包括数据本身和其他方面，如消息排序。
- en: The parts of a system that form a TCB depend upon the security policy you have
    in mind. It can be useful to think about security policies and the corresponding
    TCBs necessary to uphold them in layers. For example, the security model of an
    operating system typically has a notion of “user identity,” and provides security
    policies that stipulate separation between processes running under different users.
    In Unix-like systems, a process running under user A should not be able to view
    or modify memory or network traffic associated with a process owned by a different
    user B.^([11](ch06.html#ch06fn12)) At the software level, the TCB that ensures
    this property essentially consists of the operating system kernel and all privileged
    processes and system daemons. In turn, the operating system typically relies on
    mechanisms provided by the underlying hardware, such as virtual memory. These
    mechanisms are included in the TCB that pertains to security policies regarding
    separation between OS-level users.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 构成TCB的系统部分取决于您所考虑的安全策略。思考安全策略及其必要的TCB在层面上维护的相关性可能是有用的。例如，操作系统的安全模型通常具有“用户身份”的概念，并提供规定在不同用户下运行的进程之间分离的安全策略。在类Unix系统中，运行在用户A下的进程不应能够查看或修改属于不同用户B的进程的内存或网络流量。在软件级别上，确保这一属性的TCB基本上由操作系统内核和所有特权进程和系统守护程序组成。反过来，操作系统通常依赖于底层硬件提供的机制，如虚拟内存。这些机制包括在与OS级用户之间的分离相关的安全策略的TCB中。
- en: The software of a network application server (for example, the server exposing
    a web application or API) is *not* part of the TCB of this OS-level security policy,
    since it runs under a nonprivileged OS-level role (such as the *httpd* user).
    However, that application may enforce its own security policy. For example, suppose
    that a multiuser application has a security policy that makes user data accessible
    only through explicit document-sharing controls. In that case, the application’s
    code (or portions of it) *is* within the TCB with respect to this application-level
    security policy.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用服务器的软件（例如，公开Web应用程序或API的服务器）*不*是此操作系统级安全策略的TCB的一部分，因为它在非特权的操作系统级角色（例如*httpd*用户）下运行。但是，该应用程序可能会强制执行自己的安全策略。例如，假设一个多用户应用程序具有安全策略，只能通过显式文档共享控件访问用户数据。在这种情况下，应用程序的代码（或其中的部分）*是*与该应用程序级安全策略相关的TCB内。
- en: To ensure that a system enforces a desired security policy, you have to understand
    and reason about the entire TCB relevant to that security policy. By definition,
    a failure or bug in any part of the TCB could result in a breach of the security
    policy.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保系统执行所需的安全策略，您必须了解并推理与该安全策略相关的整个TCB。根据定义，TCB的任何部分的失败或错误可能导致安全策略的违反。
- en: 'Reasoning about a TCB becomes more difficult as the TCB broadens to include
    more code and complexity. For this reason, it’s valuable to keep TCBs as small
    as possible, and to exclude any components that aren’t actually involved in upholding
    the security policy. In addition to impairing understandability, including these
    unrelated components in the TCB adds risk: a bug or failure in any of these components
    could result in a security breach.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 随着TCB扩大以包括更多的代码和复杂性，对TCB的推理变得更加困难。因此，将TCB保持尽可能小，并排除任何实际上不涉及维护安全策略的组件是有价值的。除了损害可理解性外，将这些不相关的组件包括在TCB中还增加了风险：这些组件中的任何错误或故障都可能导致安全漏洞。
- en: 'Let’s revisit our example from [Chapter 4](ch04.html#design_tradeoffs): a web
    application that allows users to buy widgets online. The checkout flow of the
    application’s UI allows users to enter credit card and shipping address information.
    The system stores some of that information and passes other parts (such as credit
    card data) to a third-party payment service.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视一下[第4章](ch04.html#design_tradeoffs)中的例子：一个允许用户在线购买小部件的网络应用。应用程序的UI结账流程允许用户输入信用卡和送货地址信息。系统存储其中一些信息，并将其他部分（如信用卡数据）传递给第三方支付服务。
- en: We want to guarantee that only the users themselves can access their own sensitive
    user data, such as shipping addresses. We’ll use TCB[AddressData] to denote the
    trusted computing base for this security property.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望确保只有用户自己可以访问他们自己的敏感用户数据，比如送货地址。我们将使用TCB[AddressData]来表示这个安全属性的受信任计算基础。
- en: Using one of the many popular application frameworks, we might end up with an
    architecture like [Figure 6-2](#example_architecture_of_an_application).^([12](ch06.html#ch06fn13))
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用许多流行的应用程序框架之一，我们可能会得到一个像[图6-2](#example_architecture_of_an_application)的架构。
- en: '![Example architecture of an application that sells widgets](assets/bsrs_0602.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![销售小部件的应用程序的示例架构](assets/bsrs_0602.png)'
- en: Figure 6-2\. Example architecture of an application that sells widgets
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-2。销售小部件的应用程序的示例架构
- en: In this design, our system consists of a monolithic web application and an associated
    database. The application might use several modules to implement different features,
    but they are all part of the same codebase, and the entire application runs as
    a single server process. Likewise, the application stores all its data in a single
    database, and all parts of the server have read and write access to the whole
    database.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，我们的系统由一个整体的网络应用和一个相关的数据库组成。应用可能使用多个模块来实现不同的功能，但它们都是同一个代码库的一部分，整个应用作为一个单一的服务器进程运行。同样，应用将所有数据存储在一个单一的数据库中，服务器的所有部分都可以读取和写入整个数据库。
- en: 'One part of the application handles shopping cart checkout and purchasing,
    and some parts of the database store information related to purchases. Other parts
    of the application handle features that are related to purchasing, but that don’t
    themselves depend on purchasing functionality (for example, managing the contents
    of a shopping cart). Still other parts of the application have nothing to do with
    purchasing at all (they handle features such as browsing the widget catalog or
    reading and writing product reviews). Since all of these features are part of
    a single server, and all of this data is stored in a single database, the entire
    application and its dependencies—for example, the database server and the OS kernel—are
    part of the TCB for the security property we want to provide: enforcement of the
    user data access policy.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 应用的一部分处理购物车结账和购买，数据库的一些部分存储与购买相关的信息。应用的其他部分处理与购买相关的功能，但它们本身并不依赖于购买功能（例如，管理购物车的内容）。应用的其他部分与购买无关（它们处理诸如浏览小部件目录或阅读和编写产品评论等功能）。由于所有这些功能都是单个服务器的一部分，并且所有这些数据都存储在单个数据库中，整个应用及其依赖项——例如数据库服务器和操作系统内核——都是我们想要提供的安全属性的TCB的一部分：执行用户数据访问策略。
- en: Risks include a SQL injection vulnerability in the catalog search code allowing
    an attacker to obtain sensitive user data, like names or shipping addresses, or
    a remote code execution vulnerability in the web application server, such as [CVE-2010-1870](https://oreil.ly/y0xRl),
    permitting an attacker to read or modify any part of the application’s database.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 风险包括目录搜索代码中的SQL注入漏洞，允许攻击者获取敏感用户数据，如姓名或送货地址，或者Web应用程序服务器中的远程代码执行漏洞，例如[CVE-2010-1870](https://oreil.ly/y0xRl)，允许攻击者读取或修改应用程序数据库的任何部分。
- en: Small TCBs and strong security boundaries
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小的TCB和强大的安全边界
- en: We can improve the security of our design by splitting the application into
    microservices. In this architecture, each microservice handles a self-contained
    part of the application’s functionality and stores data in its own separate database.
    These microservices communicate with each other via RPCs and treat all incoming
    requests as not necessarily trustworthy, even if the caller is another internal
    microservice.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将应用拆分成微服务来改进设计的安全性。在这种架构中，每个微服务处理应用功能的一个独立部分，并将数据存储在自己的独立数据库中。这些微服务通过RPC进行通信，并将所有传入请求视为不一定可信，即使调用者是另一个内部微服务。
- en: Using microservices, we might restructure the application as shown in [Figure 6-3](#example_microservices_architecture_for).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务，我们可以重构应用，如[图6-3](#example_microservices_architecture_for)所示。
- en: Instead of a monolithic server, we now have a web application frontend and separate
    backends for the product catalog and purchasing-related functionality. Each backend
    has its own separate database.^([13](ch06.html#ch06fn14)) The web frontend never
    directly queries a database; instead, it sends RPCs to the appropriate backend.
    For example, the frontend queries the catalog backend to search for items in the
    catalog or to retrieve the details of a particular item. Likewise, the frontend
    sends RPCs to the purchasing backend to handle the shopping cart checkout process.
    As discussed earlier in this chapter, the backend microservice and the database
    server can rely on workload identity and infrastructure-level authentication protocols
    like ALTS to authenticate callers and limit requests to authorized workloads.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再有一个整体的服务器，而是有一个网络应用前端和产品目录和与购买相关功能的独立后端。每个后端都有自己独立的数据库。前端从不直接查询数据库；相反，它发送RPC到适当的后端。例如，前端查询目录后端以搜索目录中的项目或检索特定项目的详细信息。同样，前端发送RPC到购买后端以处理购物车结账流程。正如本章前面讨论的那样，后端微服务和数据库服务器可以依赖工作负载标识和基础设施级身份验证协议，如ALTS来验证调用者并限制对授权工作负载的请求。^([13](ch06.html#ch06fn14))
- en: '![Example microservices architecture for widget-selling application](assets/bsrs_0603.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![小部件销售应用程序的示例微服务架构](assets/bsrs_0603.png)'
- en: Figure 6-3\. Example microservices architecture for widget-selling application
  id: totrans-175
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-3。小部件销售应用程序的示例微服务架构
- en: 'In this new architecture, the trusted computing base for the address data security
    policy is much smaller: it consists only of the purchasing backend and its database,
    along with their associated dependencies. An attacker can no longer use a vulnerability
    in the catalog backend to obtain payment data, since the catalog backend can’t
    access that data in the first place. As a result, this design limits the impact
    of vulnerabilities in a major system component (a topic discussed further in [Chapter 8](ch08.html#design_for_resilience)).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种新的架构中，地址数据安全策略的受信任计算基础要小得多：它仅包括购买后端及其数据库，以及它们的相关依赖项。攻击者不再能够利用目录后端中的漏洞来获取付款数据，因为目录后端根本无法访问该数据。因此，这种设计限制了主要系统组件中漏洞的影响（这是[第8章](ch08.html#design_for_resilience)中进一步讨论的主题）。
- en: Security boundaries and threat models
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全边界和威胁模型
- en: A trusted computing base’s size and shape will depend on the security property
    you want to guarantee and the architecture of your system. You can’t just draw
    a dashed line around a component of your system and call it a TCB. You have to
    think about the component’s interface, and the ways in which it might implicitly
    trust the rest of the system.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 受信任的计算基础的大小和形状将取决于您想要保证的安全属性和系统的架构。您不能只是在系统的一个组件周围画一个虚线并称其为TCB。您必须考虑组件的接口，以及它可能隐含地信任系统的其他部分的方式。
- en: Suppose our application allows users to view and update their shipping addresses.
    Since the purchasing backend handles shipping addresses, that backend needs to
    expose an RPC method that allows the web frontend to retrieve and update a user’s
    shipping address.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的应用程序允许用户查看和更新他们的送货地址。由于购买后端处理送货地址，该后端需要公开一个RPC方法，允许Web前端检索和更新用户的送货地址。
- en: If the purchasing backend allows the frontend to obtain *any* user’s shipping
    address, an attacker who compromises the web frontend can use this RPC method
    to access or modify sensitive data for any and all users. In other words, if the
    purchasing backend trusts the web frontend more than it trusts a random third
    party, then the web frontend is part of the TCB.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果购买后端允许前端获取*任何*用户的送货地址，那么入侵Web前端的攻击者可以使用此RPC方法来访问或修改任何和所有用户的敏感数据。换句话说，如果购买后端比随机第三方更信任Web前端，那么Web前端就是TCB的一部分。
- en: Alternatively, the purchasing backend could require the frontend to provide
    a so-called [*end-user context ticket* (EUC)](https://oreil.ly/0WkhS) that authenticates
    a request in the context of a specific external user request. The EUC is an internal
    short-term ticket that’s minted by a central authentication service in exchange
    for an external-facing credential, such as an authentication cookie or a token
    (for example, OAuth2) associated with a given request. If the backend provides
    data only in response to requests with a valid EUC, an attacker who compromises
    the frontend does *not* have complete access to the purchasing backend, because
    they can’t get EUCs for any arbitrary user. At the worst, they could obtain sensitive
    data about users who are actively using the application during the attack.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，购买后端可以要求前端提供所谓的[*终端用户上下文票证*（EUC）](https://oreil.ly/0WkhS)，以在特定外部用户请求的上下文中对请求进行身份验证。EUC是由中央认证服务发行的内部短期票证，以外部凭据（例如身份验证cookie或与特定请求相关的令牌（例如OAuth2））交换而来。如果后端只对具有有效EUC的请求提供数据，那么入侵前端的攻击者就无法完全访问购买后端，因为他们无法为任意用户获取EUC。最坏的情况是，他们可能会在攻击期间获取正在使用应用程序的用户的敏感数据。
- en: 'To provide another example that illustrates how TCBs are relative to the threat
    model under consideration, let’s think about how this architecture relates to
    the security model of the web platform.^([14](ch06.html#ch06fn15)) In this security
    model, a *web origin* (the fully qualified hostname of the server, plus the protocol
    and optional port) represents a trust domain: JavaScript running in the context
    of a given origin can observe or modify any information present in or available
    to that context. In contrast, browsers restrict access between content and code
    across different origins based on rules referred to as the *same-origin policy*.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供另一个例子，说明TCB相对于正在考虑的威胁模型的相关性，让我们思考一下这种架构与Web平台的安全模型的关系。^([14](ch06.html#ch06fn15))在这个安全模型中，*Web来源*（服务器的完全合格主机名，加上协议和可选端口）代表一个信任域：在给定来源的上下文中运行的JavaScript可以观察或修改该上下文中存在或可用的任何信息。相反，浏览器根据称为*同源策略*的规则限制不同来源之间内容和代码之间的访问。
- en: Our web frontend might serve its entire UI from a single web origin, such as
    *https://widgets.example.com*. This means that, for example, a malicious script
    injected into our origin via an XSS vulnerability^([15](ch06.html#ch06fn16)) in
    the catalog display UI can access a user’s profile information, and might even
    be able to “purchase” items in the name of that user. Thus, in a web security
    threat model, TCB[AddressData] again includes the entire web frontend.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Web前端可能会从单个Web来源（例如*https://widgets.example.com*）提供其整个UI。这意味着，例如，通过目录显示UI中的XSS漏洞^([15](ch06.html#ch06fn16))注入到我们的来源中的恶意脚本可以访问用户的个人资料，并且甚至可能能够以该用户的名义“购买”物品。因此，在Web安全威胁模型中，TCB[AddressData]再次包括整个Web前端。
- en: 'We can remedy this situation by decomposing the system further and erecting
    additional security boundaries—in this case, based on web origins. As shown in
    [Figure 6-4](#decomposing_the_web_frontend), we can operate two separate web frontends:
    one that implements catalog search and browsing and which serves at *https://widgets.example.com*,
    and a separate frontend responsible for purchasing profiles and checkout serving
    at *https://checkout.example.com*.^([16](ch06.html#ch06fn17)) Now, web vulnerabilities
    such as XSS in the catalog UI cannot compromise the payment functionality, because
    that functionality is segregated into its own web origin.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Decomposing the web frontend](assets/bsrs_0604.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4\. Decomposing the web frontend
  id: totrans-186
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: TCBs and understandability
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Aside from their security benefits, TCBs and security boundaries also make systems
    easier to understand. In order to qualify as a TCB, a component must be isolated
    from the rest of the system. The component must have a well-defined, clean interface,
    and you must be able to reason about the correctness of the TCB’s implementation
    in isolation. If the correctness of a component depends on assumptions outside
    of that component’s control, then it’s by definition not a TCB.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: A TCB is often its own failure domain, which makes understanding how an application
    might behave in the face of bugs, DoS attacks, or other operational impacts easier.
    [Chapter 8](ch08.html#design_for_resilience) discusses the benefits of compartmentalizing
    a system in more depth.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Software Design
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you’ve structured a large system into components that are separated by
    security boundaries, you’ll still need to reason about all the code and subcomponents
    inside a given security boundary, which is often still a rather large and complex
    piece of software. This section discusses techniques for structuring software
    to further enable reasoning about invariants at the level of smaller software
    components, such as modules, libraries, and APIs.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Using Application Frameworks for Service-Wide Requirements
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As previously discussed, frameworks can provide pieces of reusable functionality.
    A given system might have an authentication framework, authorization framework,
    RPC framework, orchestration framework, monitoring framework, software release
    framework, and so on. These frameworks can provide a lot of flexibility—often,
    *too much* flexibility. All the possible combinations of frameworks, and the ways
    they can be configured, can be overwhelming for the engineers who interact with
    the service—application and service developers, service owners, SREs, and DevOps
    engineers alike.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: At Google, we’ve found it useful to create higher-level frameworks to manage
    this complexity, which we call *application frameworks*. Sometimes these are called
    *full-stack* or *batteries-included frameworks*. Application frameworks provide
    a canonical set of subframeworks for individual pieces of functionality, with
    reasonable default configurations and the assurance that all subframeworks work
    together. The application framework saves users from having to choose and configure
    a set of subframeworks.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose that an application developer exposes a new service with
    their favorite RPC framework. They set up authentication using their preferred
    authentication framework, but forget to configure authorization and/or access
    control. Functionally, their new service seems to be working fine. But without
    an authorization policy, their application is dangerously insecure. Any authenticated
    client (for example, every application in their system) can call this new service
    at will, violating the principle of least privilege (see [Chapter 5](ch05.html#design_for_least_privilege)).
    This situation might result in severe security issues—for example, imagine that
    one method exposed by the service allows the caller to reconfigure all the network
    switches in a datacenter!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: An application framework can avoid this problem by ensuring that every application
    has a valid authorization policy, and by providing safe defaults by disallowing
    all clients that aren’t explicitly permitted.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序框架可以通过确保每个应用程序都有有效的授权策略，并通过提供安全的默认值来避免这个问题，从而禁止所有未经明确允许的客户端。
- en: 'In general, application frameworks must provide an opinionated way to enable
    and configure all the features application developers and service owners need,
    including (but not limited to) these:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，应用程序框架必须提供一种有见地的方式来启用和配置应用程序开发人员和服务所有者需要的所有功能，包括（但不限于）以下内容：
- en: Request dispatching, request forwarding, and deadline propagation
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求分派、请求转发和截止时间传播
- en: User input sanitization and locale detection
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入净化和区域设置检测
- en: Authentication, authorization, and data access auditing
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证、授权和数据访问审计
- en: Logging and error reporting
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录和错误报告
- en: Health management, monitoring, and diagnostics
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康管理、监控和诊断
- en: Quota enforcement
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配额执行
- en: Load balancing and traffic management
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载平衡和流量管理
- en: Binary and configuration deployments
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制和配置部署
- en: Integration, prerelease, and load testing
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成、预发布和负载测试
- en: Dashboards and alerting
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表板和警报
- en: Capacity planning and provisioning
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容量规划和供应
- en: Handling of planned infrastructure outages
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理计划的基础设施中断
- en: An application framework addresses reliability-related concerns like monitoring,
    alerting, load balancing, and capacity planning (see [Chapter 12](ch12.html#writing_code)).
    As such, the application framework allows engineers across multiple departments
    to speak the same language, thereby increasing understandability and empathy between
    teams.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序框架解决了与可靠性相关的问题，如监控、警报、负载平衡和容量规划（见[第12章](ch12.html#writing_code)）。因此，应用程序框架允许跨多个部门的工程师使用相同的语言，从而增加团队之间的可理解性和共鸣。
- en: Understanding Complex Data Flows
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解复杂的数据流
- en: Many security properties rely on assertions about *values* as they flow through
    a system.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 许多安全属性依赖于关于*值*在系统中流动的断言。
- en: For example, many web services use URLs for various purposes. At first, representing
    URLs as strings throughout the system seems simple and straightforward. However,
    an application’s code and libraries might make the implicit assumption that URLs
    are well formed, or that a URL has a specific scheme, such as `https`. Such code
    is incorrect (and might harbor security bugs) if it can be invoked with a URL
    that violates the assumption. In other words, there’s an implicit assumption that
    upstream code that receives inputs from untrustworthy external callers applies
    correct and appropriate validation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，许多Web服务在各种情况下使用URL。最初，在整个系统中将URL表示为字符串似乎是简单而直接的。然而，应用程序的代码和库可能会做出隐含的假设，即URL是格式良好的，或者URL具有特定的方案，如`https`。如果可以使用违反这些假设的URL调用此类代码，则此类代码是不正确的（并可能存在安全漏洞）。换句话说，存在一个隐含的假设，即从不可信的外部调用者接收输入的上游代码应用了正确和适当的验证。
- en: However, a string-typed value does not carry any explicit assertion as to whether
    or not it represents a well-formed URL. The “string” type itself confers only
    that the value is a sequence of characters or code points of a certain length
    (details depend on the implementation language). Any other assumptions about properties
    of the value are implicit. Thus, reasoning about the correctness of the downstream
    code requires understanding of all upstream code, and whether that code actually
    performs the required validation.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，字符串类型的值并不附带任何关于它是否表示格式良好的URL的明确断言。“字符串”类型本身只表明该值是一系列特定长度的字符或代码点（具体取决于实现语言的细节）。关于该值的其他属性的任何假设都是隐含的。因此，对下游代码的正确性进行推理需要理解所有上游代码，以及该代码是否实际执行所需的验证。
- en: You can make reasoning about properties of data that flows through large, complex
    systems more tractable by representing the value as a specific data type, whose
    type contract stipulates the desired property. In a more understandable design,
    your downstream code consumes the URL not in the form of a basic string type,
    but rather as a type (implemented, for instance, as a Java class) representing
    a *well-formed* URL.^([17](ch06.html#ch06fn18)) This type’s contract can be enforced
    by the type’s constructors or factory functions. For example, a `Url.parse(String)`
    factory function would perform runtime validation and either return an instance
    of `Url` (representing a well-formed URL) or signal an error or throw an exception
    for a malformed value.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将值表示为特定数据类型，使得对流经大型复杂系统的数据属性进行推理更加容易，该类型的合同规定了所需的属性。在更易理解的设计中，您的下游代码不是以基本字符串类型的形式使用URL，而是作为一个类型（例如作为Java类实现）来表示*格式良好*的URL。^([17](ch06.html#ch06fn18))
    这种类型的合同可以由类型的构造函数或工厂函数强制执行。例如，`Url.parse(String)`工厂函数将执行运行时验证，并返回`Url`的实例（表示格式良好的URL），或者对于格式不正确的值发出错误信号或抛出异常。
- en: With this design, understanding code that consumes a URL, and whose correctness
    relies on its well-formedness, no longer requires understanding all its callers
    and whether they perform appropriate validation. Instead, you can understand URL
    handling by understanding two smaller parts. First, you can inspect the `Url`
    type’s implementation *in isolation*. You can observe that all of the type’s constructors
    ensure well-formedness, and that they guarantee that all instances of the type
    conform to the type’s documented contract. Then, you can *separately* reason about
    the correctness of the code that consumes the `Url`-typed value, using the type’s
    contract (i.e., well-formedness) as an assumption in your reasoning.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这种设计，理解消耗URL的代码以及其正确性是否依赖于其格式良好性，不再需要理解所有的调用者以及它们是否执行适当的验证。相反，您可以通过理解两个较小的部分来理解URL处理。首先，您可以独立检查`Url`类型的实现。您可以观察到所有类型的构造函数都确保格式良好，并且它们保证所有类型的实例符合类型的文档合同。然后，您可以*分别*推理出消耗`Url`类型值的代码的正确性，使用类型的合同（即格式良好性）作为推理的假设。
- en: Using types in this way aids understandability because it can dramatically shrink
    the amount of code that you have to read and verify. Without types, you have to
    understand all code that uses URLs, as well as all code that transitively passes
    URLs to that code in plain string form. By representing URLs as a type, you only
    have to understand the implementation of data validation inside `Url.parse()`
    (and similar constructors and factory functions) and the ultimate uses of `Url`.
    You don’t need to understand the rest of the application code that merely passes
    around instances of the type.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: In a sense, the type’s implementation behaves like a TCB—it’s solely responsible
    for the “all URLs are well-formed” property. However, in commonly used implementation
    languages, encapsulation mechanisms for interfaces, types, or modules typically
    do not represent security boundaries. Therefore, you can’t treat the internals
    of a module as a TCB that can stand up to malicious behavior of code outside the
    module. This is because in most languages, code on the “outside” of a module boundary
    can nevertheless modify the internal state of the module (for example, by using
    reflection features or via type casts). Type encapsulation permits you to understand
    the module’s behavior in isolation, but *only under the assumption* that surrounding
    code was written by nonmalicious developers and that code executes in an environment
    that hasn’t been compromised. This is actually a reasonable assumption in practice;
    it’s normally ensured by organization- and infrastructure-level controls, such
    as repository access controls, code review processes, server hardening, and the
    like. But if the assumption doesn’t hold true, your security team will need to
    address the resulting worst-case scenario (see [Part IV](part04.html#maintaining_systems)).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: You can use types to reason about more complex properties, too. For example,
    preventing injection vulnerabilities (such as XSS or SQL injection) depends on
    appropriately validating or encoding any external and potentially malicious inputs,
    at some point between when the inputs are received and when they’re passed to
    an injection-prone API.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Asserting that an application is free of injection vulnerabilities requires
    understanding all code and components involved in passing data from external inputs
    to so-called *injection sinks* (i.e., APIs that are prone to security vulnerabilities
    if presented with insufficiently validated or encoded inputs). Such data flows
    can be very complex in typical applications. It’s common to find data flows where
    values are received by a frontend, passed through one or more layers of microservice
    backends, persisted in a database, and then later read back and used in the context
    of an injection sink. A common class of vulnerabilities in such a scenario are
    so-called *stored XSS* bugs, where untrusted inputs reach an HTML injection sink
    (such as an HTML template or a browser-side DOM API) via persistent storage, without
    appropriate validation or escaping. Reviewing and understanding the union of all
    relevant flows across a large application within a reasonable amount of time is
    typically well beyond a human’s capacity, even if they’re equipped with tooling.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: One effective way of preventing such injection vulnerabilities to a high degree
    of confidence is to use types to distinguish values that are known to be safe
    for use in a specific injection sink context, such as SQL queries or HTML markup:^([18](ch06.html#ch06fn19))
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Constructors and builder APIs for types such as `SafeSql` or `SafeHtml` are
    responsible for ensuring that all instances of such types are indeed safe to use
    in the corresponding sink context (for example, a SQL query API or HTML rendering
    context). These APIs ensure type contracts through a combination of runtime validation
    of potentially untrusted values and correct-by-construction API design. Constructors
    might also rely on more complex libraries, such as fully fledged HTML validators/sanitizers
    or HTML template systems that apply context-sensitive escaping or validation to
    data that is interpolated into the template.^([19](ch06.html#ch06fn20))
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sinks are modified to accept values of appropriate types. The type contract
    states that its values are safe to use in the corresponding context, which makes
    the typed API safe by construction. For example, when using a SQL query API that
    accepts only values of type `SafeSql` (instead of `String`), you don’t have to
    worry about SQL injection vulnerabilities, since all values of type `SafeSql`
    are safe to use as a SQL query.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sinks may also accept values of basic types (such as strings), but in this case
    must not make any assumptions about the value’s safety in the sink’s injection
    context. Instead, the sink API is itself responsible for validating or encoding
    data, as appropriate, to ensure at runtime that the value is safe.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this design, you can support an assertion that an *entire application*
    is free of SQL injection or XSS vulnerabilities based *solely* on understanding
    the implementations of the types and the type-safe sink APIs. You don’t need to
    understand or read any application code that forwards values of these types, since
    type encapsulation ensures that application code cannot invalidate security-relevant
    type invariants.^([20](ch06.html#ch06fn21)) You also don’t need to understand
    and review application code that uses the types’ safe-by-construction builders
    to create instances of the types, since those builders were designed to ensure
    their types’ contracts without any assumptions about the behavior of their callers.
    [Chapter 12](ch12.html#writing_code) discusses this approach in detail.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Considering API Usability
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s a good idea to consider the impact of API adoption and usage on your organization’s
    developers and their productivity. If APIs are cumbersome to use, developers will
    be slow or reluctant to adopt them. Secure-by-construction APIs have the double
    benefit of making your code more understandable and allowing developers to focus
    on the logic of your application, while also automatically building secure approaches
    into your organization’s culture.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, it is often possible to design libraries and frameworks such that
    secure-by-construction APIs are a net benefit for developers, while also promoting
    a culture of security and reliability ([Chapter 21](ch21.html#twoone_building_a_culture_of_security_a)).
    In return for adopting your secure API, which ideally follows established patterns
    and idioms that they’re already familiar with, your developers gain the benefit
    of not being responsible for ensuring security invariants related to the API’s
    use.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: For example, a contextually autoescaping HTML template system takes full responsibility
    for correct validation and escaping of all data interpolated into the template.
    This is a powerful security invariant for the entire application, since it ensures
    that rendering of any such template cannot result in XSS vulnerabilities, no matter
    what (potentially malicious) data the template is being fed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, from a developer’s perspective, using a contextually autoescaping
    HTML template system is just like using a regular HTML template—you provide data,
    and the template system interpolates it into placeholders within HTML markup—except
    you no longer have to worry about adding appropriate escaping or validation directives.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Secure cryptographic APIs and the Tink crypto framework'
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Cryptographic code is particularly prone to subtle mistakes. Many cryptographic
    primitives (such as cipher and hash algorithms) have catastrophic failure modes
    that are difficult for nonexperts to recognize. For example, in certain situations
    where encryption is combined improperly with authentication (or used without authentication
    at all), an attacker who can only observe whether a request to a service fails
    or is accepted can nevertheless use the service as a so-called “decryption oracle”
    and recover the clear text of encrypted messages.^([21](ch06.html#ch06fn22)) A
    nonexpert who is not aware of the underlying attack technique has little chance
    of noticing the flaw: the encrypted data looks perfectly unreadable, and the code
    is using a standard, recommended, and secure cipher like AES. Nevertheless, because
    of subtly incorrect usage of the nominally secure cipher, the cryptographic scheme
    is insecure.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: In our experience, code involving cryptographic primitives that was not developed
    and reviewed by experienced cryptographers commonly has serious flaws. Using crypto
    correctly is just really, really hard.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Our experience from many security review engagements led Google to develop
    Tink: a library that enables engineers to [use cryptography safely](https://oreil.ly/7G0mD)
    in their applications. Tink was born out of our extensive experience working with
    Google product teams, fixing vulnerabilities in cryptography implementations,
    and providing simple APIs that engineers without a cryptographic background can
    use safely.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Tink reduces the potential for common crypto pitfalls, and provides secure
    APIs that are easy to use correctly and hard(er) to misuse. The following principles
    guided Tink’s design and development:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Secure by default
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The library provides an API that’s hard to misuse. For example, the API does
    not permit reuse of nonces in Galois Counter Mode—a fairly common but subtle mistake
    that was specifically called out in [RFC 5288](https://oreil.ly/3z4CT), as it
    allows authentication key recovery that leads to a complete failure of the AES-GCM
    mode’s authenticity. Thanks to [Project Wycheproof](https://oreil.ly/7UhA7), Tink
    reuses proven and well-tested libraries.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Usability
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The library has a simple and easy-to-use API, so a software engineer can focus
    on the desired functionality—for example, implementing block and streaming Authenticated
    Encryption with Associated Data (AEAD) primitives.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Readability and auditability
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Functionality is clearly readable in code, and Tink maintains control over employed
    cryptographic schemes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Extensibility
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to add new functionality, schemes, and formats—for example, via the
    registry for key managers.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Agility
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Tink has built-in key rotation and supports deprecation of obsolete/broken schemes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Tink is available in many languages and on many platforms.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Tink also provides a solution for key management, integrating with [Cloud Key
    Management Service (KMS)](https://oreil.ly/k5A3c), [AWS Key Management Service](https://oreil.ly/nzkF9),
    and [Android Keystore](https://oreil.ly/PUkYz). Many cryptographic libraries make
    it easy to store private keys on disk, and make adding private keys to your source
    code—a practice that’s strongly discouraged—even easier. Even if you run “keyhunt”
    and “password hunt” activities to find and scrub secrets from your codebase and
    storage systems, it’s difficult to eliminate key management–related incidents
    completely. In contrast, Tink’s API does not accept raw key material. Instead,
    the API encourages use of a key management service.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Google uses Tink to secure the data of many products, and it is now the recommended
    library for protecting data within Google and when communicating with third parties.
    By providing abstractions with well-understood properties (such as “authenticated
    encryption”) backed by well-engineered implementations, it allows security engineers
    to focus on higher-level aspects of cryptographic code without having to be concerned
    with lower-level attacks on the underlying cryptographic primitives.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note, however, that Tink cannot prevent higher-level design
    mistakes in cryptographic code. For example, a software developer without sufficient
    cryptography background might choose to protect sensitive data by hashing it.
    This is unsafe if the data in question is from a set that is (in cryptographic
    terms) relatively modest in size, such as credit card or Social Security numbers.
    Using a cryptographic hash in such a scenario, instead of authenticated encryption,
    is a design-level mistake that exhibits itself at a level of granularity above
    Tink’s API. A security reviewer cannot conclude that such mistakes are absent
    from an application just because the code uses Tink instead of a different crypto
    library.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Software developers and reviewers must take care to understand what security
    and reliability properties a library or framework does and does not guarantee.
    Tink prevents many mistakes that could result in low-level cryptographic vulnerabilities,
    but does not prevent mistakes based on using the wrong crypto API (or not using
    crypto at all). Similarly, a secure-by-construction web framework prevents XSS
    vulnerabilities, but does not prevent security bugs in an application’s business
    logic.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reliability and security benefit, in a deep and intertwined way, from understandable
    systems.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Although “reliability” is sometimes treated as synonymous with “availability,”
    this attribute really means upholding all of a system’s critical design guarantees—availability,
    durability, and security invariants, to name a few.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Our primary guidance for building an understandable system is to construct it
    with components that have clear and constrained purposes. Some of those components
    may make up its trusted computing base, and therefore concentrate responsibility
    for addressing security risk.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'We also discussed strategies for enforcing desirable properties—such as security
    invariants, architectural resilience, and data durability—in and between those
    components. Those strategies include the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Narrow, consistent, typed interfaces
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistent and carefully implemented authentication, authorization, and accounting
    strategies
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear assignment of identities to active entities, whether they are software
    components or human administrators
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application framework libraries and data types that encapsulate security invariants
    to ensure that components follow best practices consistently
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When your most critical system behaviors are malfunctioning, the understandability
    of your system can make the difference between a brief incident and a protracted
    disaster. SREs must be aware of the security invariants of the system in order
    to do their job. In extreme cases, they may have to take a service offline during
    a security incident, sacrificing availability for security.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch06.html#ch06fn1-marker)) Automated fuzz testing, especially if combined
    with instrumentation and coverage guidance, can in some cases explore a larger
    fraction of possible behaviors. This is discussed in detail in [Chapter 13](ch13.html#onethree_testing_code).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch06.html#ch06fn2-marker)) Such as those published by [SANS](https://oreil.ly/cYTHM),
    [MITRE](https://oreil.ly/-XYhE), and [OWASP](https://oreil.ly/eChGB).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '^([3](ch06.html#ch06fn3-marker)) See Murray, Toby, and Paul van Oorschot. 2018\.
    “BP: Formal Proofs, the Fine Print and Side Effects.” *Proceedings of the 2018
    IEEE Cybersecurity Development Conference*: 1–10\. doi:10.1109/SecDev.2018.00009.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '^([4](ch06.html#ch06fn4-marker)) See Klein, Gerwin et al. 2014\. “Comprehensive
    Formal Verification of an OS Microkernel.” *ACM Transactions on Computer Systems*
    32(1): 1–70\. doi:10.1145/2560537.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '^([5](ch06.html#ch06fn5-marker)) See, for example, Erbsen, Andres et al. 2019\.
    “Simple High-Level Code for Cryptographic Arithmetic—With Proofs, Without Compromises.”
    *Proceedings of the 2019 IEEE Symposium on Security and Privacy*: 73–90\. doi:10.1109/SP.2019.00005\.
    For another example, see Chudnov, Andrey et al. 2018\. “Continuous Formal Verification
    of Amazon s2n.” *Proceedings of the 30th International Conference on Computer
    Aided Verification*: 430–446\. doi:10.1007/978-3-319-96142-2_26.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '^([6](ch06.html#ch06fn6-marker)) See Denning, Peter J. 1968\. “Thrashing: Its
    Causes and Prevention.” *Proceedings of the 1968 Fall Joint Computer Conference*:
    915–922\. doi:10.1145/1476589.1476705.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch06.html#ch06fn8-marker)) For more information, see [Chapter 11 in the
    SRE workbook](https://landing.google.com/sre/workbook/chapters/managing-load/).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch06.html#ch06fn9-marker)) There are multiple identity subsystems in the
    general case. For example, the system may have one identity subsystem for internal
    microservices and another identity subsystem for human administrators.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch06.html#ch06fn10-marker)) For more information on Borg, see Verma, Abhishek
    et al. 2015\. “Large-Scale Cluster Management at Google with Borg.” *Proceedings
    of the European Conference on Computer Systems (EuroSys)*. [*https://oreil.ly/zgKsd*](https://oreil.ly/zgKsd).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '^([10](ch06.html#ch06fn11-marker)) Anderson, Ross J. 2008\. *Security Engineering:
    A Guide to Building Dependable Distributed Systems*. Hoboken, NJ: Wiley.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: ^([11](ch06.html#ch06fn12-marker)) This is true unless user A is the root user,
    as well as under a number of other specific conditions—for example, if shared
    memory is involved, or if mechanisms such as Linux capabilities confer specific
    aspects of root’s privileges.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: ^([12](ch06.html#ch06fn13-marker)) To keep the example simple, [Figure 6-2](#example_architecture_of_an_application)
    doesn’t show connections to external service providers.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: ^([13](ch06.html#ch06fn14-marker)) In a real-world design, you would likely
    use a single database with separate groups of tables to which workload identities
    have been granted appropriate access. This achieves separation of access to data
    while still allowing the database to ensure data consistency properties across
    all tables, such as foreign-key constraints between shopping cart contents and
    catalog items.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '^([14](ch06.html#ch06fn15-marker)) Zalewski, Michał. 2012\. *The Tangled Web:
    A Guide to Securing Modern Web Applications*. San Francisco, CA: No Starch Press.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: ^([15](ch06.html#ch06fn16-marker)) See Zalewski, *The Tangled Web*.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: ^([16](ch06.html#ch06fn17-marker)) It’s important that we configure our web
    servers so that the payments frontend is *not* also accessible at, for example,
    *https://widgets.example.com/checkout*.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: ^([17](ch06.html#ch06fn18-marker)) Or more generally, a URL that satisfies specific
    relevant properties, such as having a particular scheme.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '^([18](ch06.html#ch06fn19-marker)) See Kern, Christoph. 2014\. “Securing the
    Tangled Web.” *Communications of the ACM* 57(9): 38–47\. doi:10.1145/2643134.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '^([19](ch06.html#ch06fn20-marker)) See Samuel, Mike, Prateek Saxena, and Dawn
    Song. 2011\. “Context-Sensitive Auto-Sanitization in Web Templating Languages
    Using Type Qualifiers.” *Proceedings of the 18th ACM Conference on Computer and
    Communications Security*: 587–600\. doi:10.1145/2046707.2046775.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: ^([20](ch06.html#ch06fn21-marker)) As noted previously, this assertion holds
    only under the assumption that the entire codebase of the application is nonmalicious.
    In other words, the type system is relied upon to uphold invariants in the face
    of nonmalicious mistakes elsewhere in the codebase, but not against actively malicious
    code that might, for example, use a language’s reflection APIs to modify a type’s
    private fields. You can address the latter through additional security mechanisms
    like code reviews, access controls, and audit trails at the source repository
    level.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ^([20](ch06.html#ch06fn21-marker)) 正如前面所指出的，这种断言仅在假设应用程序的整个代码库都是非恶意的情况下才成立。换句话说，类型系统依赖于在代码库的其他地方发生非恶意错误的情况下维护不变量，但不能抵御积极恶意的代码，例如使用语言的反射API修改类型的私有字段。您可以通过额外的安全机制，如代码审查、访问控制和源代码存储库级别的审计跟踪来解决后者。
- en: '^([21](ch06.html#ch06fn22-marker)) See Rizzo, Juliano, and Thai Duong. 2010\.
    “Practical Padding Oracle Attacks.” *Proceedings of the 4th USENIX Conference
    on Offensive Technologies*: 1–8\. [*https://oreil.ly/y-OYm*](https://oreil.ly/y-OYm).'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '^([21](ch06.html#ch06fn22-marker)) 参见Rizzo, Juliano, and Thai Duong. 2010.
    “Practical Padding Oracle Attacks.” *Proceedings of the 4th USENIX Conference
    on Offensive Technologies*: 1–8. [*https://oreil.ly/y-OYm*](https://oreil.ly/y-OYm)。'

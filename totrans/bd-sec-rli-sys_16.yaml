- en: 'Chapter 11\. Case Study: Designing, Implementing, and Maintaining a Publicly
    Trusted CA'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。案例研究：设计、实施和维护公信CA
- en: By Andy Warner, James Kasten, Rob Smits, Piotr Kucharski, and Sergey Simakov
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：Andy Warner、James Kasten、Rob Smits、Piotr Kucharski和Sergey Simakov
- en: Background on Publicly Trusted Certificate Authorities
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公信证书颁发机构的背景
- en: Publicly trusted certificate authorities act as trust anchors for the transport
    layer of the internet by issuing certificates for Transport Layer Security (TLS),^([1](ch11.html#ch11fn1))
    S/MIME,^([2](ch11.html#ch11fn2)) and other common distributed trust scenarios.
    They are the set of CAs that browsers, operating systems, and devices trust by
    default. As such, writing and maintaining a publicly trusted CA raises a number
    of security and reliability considerations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 公信证书颁发机构通过为传输层安全性（TLS）、S/MIME等常见的分布式信任场景颁发证书，充当互联网传输层的信任锚点。它们是浏览器、操作系统和设备默认信任的CA集合。因此，编写和维护一个公信CA引发了许多安全性和可靠性考虑。
- en: To become publicly trusted and maintain that status, a CA must pass a number
    of criteria that span different platforms and use cases. At minimum, publicly
    trusted CAs must undergo audits against standards such as [WebTrust](https://oreil.ly/ubToZ)
    and those set by organizations like the [European Telecommunications Standards
    Institute (ETSI)](https://www.etsi.org). Publicly trusted CAs must also meet the
    objectives of the [CA/Browser Forum Baseline Requirements](https://oreil.ly/gfdBF).
    These evaluations assess logical and physical security controls, procedures, and
    practices, and a typical publicly trusted CA spends at least one quarter of each
    year on these audit(s). Additionally, most browsers and operating systems have
    their own unique requirements that a CA must meet before it’s trusted by default.
    As requirements change, CAs need to be adaptable and amenable to making process
    or infrastructure changes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要成为公信并保持这一地位，CA必须通过跨不同平台和用例的一系列标准。至少，公信CA必须接受诸如[WebTrust](https://oreil.ly/ubToZ)和[欧洲电信标准化协会（ETSI）](https://www.etsi.org)等组织设定的标准的审计。公信CA还必须满足[CA/Browser论坛基线要求](https://oreil.ly/gfdBF)的目标。这些评估评估逻辑和物理安全控制、程序和实践，一个典型的公信CA每年至少花费四分之一的时间进行这些审计。此外，大多数浏览器和操作系统都有自己独特的要求，CA必须在被默认信任之前满足这些要求。随着要求的变化，CA需要适应并愿意进行流程或基础设施的变更。
- en: 'Chances are, your organization will never need to build a publicly trusted
    CA^([3](ch11.html#ch11fn3))—most organizations rely on third parties for acquiring
    public TLS certificates, code signing certificates, and other types of certificates
    that require broad trust by users. With that in mind, the goal of this case study
    is not to show you how to build a publicly trusted CA, but to highlight some of
    our findings that might resonate with projects in your environment. Key takeaways
    included the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你的组织很可能永远不需要构建一个公信CA——大多数组织依赖第三方获取公共TLS证书、代码签名证书和其他需要用户广泛信任的证书。考虑到这一点，本案例研究的目标不是向您展示如何构建一个公信CA，而是强调我们的一些发现可能与您环境中的项目产生共鸣。主要的收获包括以下内容：
- en: Our choice of programming language and decision to use segmentation or containers
    when handling data generated by third parties made the overall environment more
    secure.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们选择的编程语言以及在处理第三方生成的数据时使用分段或容器使整体环境更加安全。
- en: Rigorously testing and hardening code—both code we generated ourselves and third-party
    code—was critical for addressing fundamental reliability and security issues.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格测试和加固代码——无论是我们自己生成的代码还是第三方代码——对于解决基本的可靠性和安全性问题至关重要。
- en: Our infrastructure became safer and more reliable when we reduced complexity
    in the design and replaced manual steps with automation.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们在设计中减少复杂性并用自动化替换手动步骤时，我们的基础设施变得更安全、更可靠。
- en: Understanding our threat model enabled us to build validation and recovery mechanisms
    that allow us to better prepare for a disaster ahead of time.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解我们的威胁模型使我们能够构建验证和恢复机制，使我们能够更好地提前为灾难做准备。
- en: Why Did We Need a Publicly Trusted CA?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么需要一个公信CA？
- en: 'Our business needs for a publicly trusted CA changed over time. In Google’s
    early days, we purchased all of our public certificates from a third-party CA.
    This approach had three inherent problems we wanted to solve:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我们对公信CA的业务需求发生了变化。在谷歌早期，我们从第三方CA购买了所有的公共证书。这种方法存在三个固有问题，我们希望解决：
- en: Reliance on third parties
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖第三方
- en: Business requirements that necessitate a high level of trust—for example, offering
    cloud services to customers—meant we needed strong validation and control over
    how certificates were issued and handled. Even if we performed mandatory audits
    in the CA ecosystem, we were unsure of whether third parties could meet a high
    standard of safety. Notable lapses in security at publicly trusted CAs solidified
    our views about safety.^([4](ch11.html#ch11fn4))
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 业务需求需要高度的信任——例如，向客户提供云服务——这意味着我们需要对证书的发放和处理进行强有力的验证和控制。即使我们在CA生态系统中进行了强制性的审计，我们仍然不确定第三方是否能够达到高标准的安全性。公信CA中的显著安全漏洞巩固了我们对安全性的看法。
- en: Need for automation
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化的需求
- en: 'Google has thousands of company-owned domains that serve users globally. As
    part of our ubiquitous TLS efforts (see [“Example: Increasing HTTPS usage”](ch07.html#example_increasing_https_usage)),
    we wanted to protect every domain we own and rotate certificates frequently. We
    also wanted to provide an easy way for customers to get TLS certificates. Automating
    the acquisition of new certificates was difficult because third-party publicly
    trusted CAs often did not have extensible APIs, or provided SLAs below our needs.
    As a result, much of the request process for these certificates involved error-prone
    manual methods.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌拥有成千上万的公司拥有的域名，为全球用户提供服务。作为我们普遍的TLS工作的一部分（参见[“示例：增加HTTPS使用率”](ch07.html#example_increasing_https_usage)），我们希望保护我们拥有的每个域，并经常更换证书。我们还希望为客户提供获取TLS证书的简便方法。自动获取新证书很困难，因为第三方公信CA通常没有可扩展的API，或者提供的SLA低于我们的需求。因此，这些证书的请求过程很大程度上涉及容易出错的手动方法。
- en: Cost
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 成本
- en: Given the millions of TLS certificates Google wanted to use for its own web
    properties and on behalf of customers, cost analysis showed it would be more cost-effective
    to design, implement, and maintain our own CA rather than continuing to obtain
    certificates from third-party root CAs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到谷歌想要为自己的网络属性和客户代表使用数百万个TLS证书，成本分析显示，与继续从第三方根CA获取证书相比，设计、实现和维护我们自己的CA将更具成本效益。
- en: The Build or Buy Decision
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建设或购买决策
- en: 'Once Google decided it wanted to operate a publicly trusted CA, we had to decide
    whether to buy commercial software to operate the CA or to write our own software.
    Ultimately, we decided to develop the core of the CA ourselves, with the option
    to integrate open source and commercial solutions where necessary. Among a number
    of deciding factors, there were a few primary motivators behind this decision:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦谷歌决定要运营一个公信CA，我们就必须决定是购买商业软件来运营CA，还是编写我们自己的软件。最终，我们决定自己开发CA的核心部分，并在必要时集成开源和商业解决方案。在许多决定因素中，这个决定背后有一些主要的动机：
- en: Transparency and validation
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 透明度和验证
- en: Commercial solutions for CAs often didn’t come with the level of auditability
    for code or the supply chain that we needed for such critical infrastructure.
    Even though it was integrated with open source libraries and used some third-party
    proprietary code, writing and testing our own CA software gave us increased confidence
    in the system we were building.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CA的商业解决方案通常没有我们对代码或供应链的审计能力，这是我们对于如此关键的基础设施所需的。尽管它与开源库集成并使用了一些第三方专有代码，但编写和测试我们自己的CA软件使我们对正在构建的系统更加有信心。
- en: Integration capabilities
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 集成能力
- en: We wanted to simplify implementation and maintenance of the CA by integrating
    with Google’s secure critical infrastructure. For example, we could set up regular
    backups in [Spanner](https://oreil.ly/ZnhV-) with one line in a configuration
    file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过与谷歌的安全关键基础设施集成，简化CA的实施和维护。例如，我们可以在[Spanner](https://oreil.ly/ZnhV-)中的配置文件中设置定期备份。
- en: Flexibility
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 灵活性
- en: The wider internet community was developing new initiatives that would provide
    increased security for the ecosystem. [Certificate Transparency](https://www.certificate-transparency.org)—a
    way to monitor and audit certificates—and domain validation using DNS, HTTP, and
    other methods^([5](ch11.html#ch11fn5)) are two canonical examples. We wanted to
    be early adopters of these kinds of initiatives, and a custom CA was our best
    option for being able to add this flexibility quickly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 更广泛的互联网社区正在开发新的倡议，以提高生态系统的安全性。[证书透明度](https://www.certificate-transparency.org)——一种监视和审计证书的方式——以及使用DNS、HTTP和其他方法进行域验证^([5](ch11.html#ch11fn5))是两个典型的例子。我们希望成为这类倡议的早期采用者，自定义CA是我们能够迅速增加这种灵活性的最佳选择。
- en: Design, Implementation, and Maintenance Considerations
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计、实现和维护考虑
- en: 'To secure our CA, we created a three-layer tiered architecture, where each
    layer is responsible for a different part of the issuance process: certificate
    request parsing, Registration Authority functions (routing and logic), and certificate
    signing. Each layer is composed of microservices with well-defined responsibilities.
    We also devised a dual trust zone architecture, where untrusted input is handled
    in a different environment than critical operations. This segmentation creates
    carefully defined boundaries that promote understandability and ease of review.
    The architecture also makes mounting an attack more difficult: since components
    are limited in functionality, an attacker who gains access to a given component
    will be similarly limited in the functionality they can affect. To gain additional
    access, the attacker would have to bypass additional audit points.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护我们的CA，我们创建了一个三层分层架构，其中每一层负责发行过程的不同部分：证书请求解析、注册机构功能（路由和逻辑）和证书签发。每一层都由具有明确定义责任的微服务组成。我们还设计了一个双信任区域架构，其中不受信任的输入在不同的环境中处理关键操作。这种分割创建了精心定义的边界，促进了可理解性和审查的便利。该架构还使得发动攻击更加困难：由于组件的功能受到限制，攻击者如果获得对特定组件的访问权限，也将受到功能受限的限制。要获得额外的访问权限，攻击者必须绕过额外的审计点。
- en: Each microservice is designed and implemented with simplicity as a key principle.
    Over the lifetime of the CA, we continually refactor each component with simplicity
    in mind. We subject code (both internally developed and third-party) and data
    to rigorous testing and validation. We also containerize code when doing so will
    improve safety. This section describes our approach to addressing security and
    reliability through good design and implementation choices in more detail.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务都是以简单性作为关键原则进行设计和实现的。在CA的整个生命周期中，我们不断地以简单性为考量对每个组件进行重构。我们对代码（包括内部开发和第三方）和数据进行严格的测试和验证。当需要提高安全性时，我们还会对代码进行容器化。本节详细描述了我们通过良好的设计和实现选择来解决安全性和可靠性的方法。
- en: Programming Language Choice
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程语言选择
- en: The choice of programming language for parts of the system that accept arbitrary
    untrusted input was an important aspect of the design. Ultimately, we decided
    to write the CA in a mix of Go and C++, and chose which language to use for each
    subcomponent based upon its purpose. Both Go and C++ have interoperability with
    well-tested cryptographic libraries, exhibit excellent performance, and have a
    strong ecosystem of frameworks and tools to implement common tasks.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接受任意不受信任输入的系统部分的编程语言选择是设计的一个重要方面。最终，我们决定用Go和C++的混合编写CA，并根据其目的选择使用哪种语言来处理每个子组件。Go和C++都可以与经过充分测试的加密库进行互操作，表现出优异的性能，并拥有强大的生态系统框架和工具来实现常见任务。
- en: Since Go is memory-safe, it has some additional upsides for security where the
    CA handles arbitrary input. For example, [Certificate Signing Requests (CSRs)](https://oreil.ly/8YkPI)
    represent untrusted input into the CA. CSRs could come from one of our internal
    systems, which may be relatively safe, or from an internet user (perhaps even
    a malicious actor). There is a long history of memory-related vulnerabilities
    in code that parses DER (Distinguished Encoding Rules, the encoding format used
    for certificates),^([6](ch11.html#ch11fn6)) so we wanted to use a memory-safe
    language that provided extra security. [Go](https://oreil.ly/WM_zw) fit the bill.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go是内存安全的，它在处理CA处理任意输入时具有一些额外的安全优势。例如，[证书签名请求（CSR）](https://oreil.ly/8YkPI)代表CA的不受信任输入。CSR可能来自我们内部系统中的一个，这可能相对安全，也可能来自互联网用户（甚至是恶意行为者）。代码中解析DER（用于证书的编码格式）的代码存在与内存相关的漏洞的悠久历史，因此我们希望使用一种提供额外安全性的内存安全语言。[Go](https://oreil.ly/WM_zw)符合要求。
- en: C++ is not memory-safe, but has good interoperability for critical subcomponents
    of the system—especially for certain components of Google’s core infrastructure.
    To secure this code, we run it in a secure zone and validate all data before it
    reaches that zone. For example, for CSR handling, we parse the request in Go before
    relaying it to the C++ subsystem for the same operation, and then compare the
    results. If there is a discrepancy, processing does not proceed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: C++不是内存安全的，但对于系统的关键子组件具有良好的互操作性，特别是对于谷歌核心基础设施的某些组件。为了保护这些代码，我们在安全区域中运行它，并在数据到达该区域之前验证所有数据。例如，对于CSR处理，我们在Go中解析请求，然后将其传递给C++子系统进行相同的操作，然后比较结果。如果存在差异，则不进行处理。
- en: 'Additionally, we [enforce good security practices and readability](https://oreil.ly/m8dug)
    at pre-submit time for all C++ code, and Google’s centralized toolchain enables
    various compile-time and runtime mitigations. These include the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在所有C++代码的提交前[强制执行良好的安全实践和可读性](https://oreil.ly/m8dug)，谷歌的集中式工具链实现了各种编译时和运行时缓解措施。这些包括以下内容：
- en: '[W^X](https://oreil.ly/9gNIa)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[W^X](https://oreil.ly/9gNIa)'
- en: Breaks the common exploitation trick of `mmap`ing with `PROT_EXEC` by copying
    shellcode and jumping into that memory. This mitigation does not incur a CPU or
    memory performance hit.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过复制shellcode并跳转到该内存来破坏`mmap`和`PROT_EXEC`的常见利用技巧。这种缓解措施不会造成CPU或内存性能损失。
- en: '[Scudo Allocator](https://oreil.ly/xpo5t)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[Scudo Allocator](https://oreil.ly/xpo5t)'
- en: A user-mode secure heap allocator.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 用户模式安全堆分配器。
- en: '[SafeStack](https://oreil.ly/EPwod)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[SafeStack](https://oreil.ly/EPwod)'
- en: A security mitigation technique that protects against attacks based on stack
    buffer overflows.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一种安全缓解技术，可防范基于堆栈缓冲区溢出的攻击。
- en: Complexity Versus Understandability
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂性与可理解性
- en: As a defensive measure, we explicitly chose to implement our CA with limited
    functionality compared to the full range of options available in the standards
    (see [“Designing Understandable Systems”](ch06.html#designing_understandable_systems)).
    Our primary use case was to issue certificates for standard web services with
    commonly used attributes and extensions. Our evaluation of commercial and open
    source CA software options showed that their attempts to accommodate esoteric
    attributes and extensions that we didn’t need led to complexity in the system,
    making the software difficult to validate and more error-prone. Therefore, we
    opted to write a CA with limited functionality and better understandability, where
    we could more easily audit expected inputs and outputs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种防御措施，我们明确选择实现CA的功能有限，与标准中提供的完整选项相比（参见[“设计可理解的系统”](ch06.html#designing_understandable_systems)）。我们的主要用例是为具有常用属性和扩展的标准Web服务颁发证书。我们对商业和开源CA软件选项的评估显示，它们试图适应我们不需要的奇特属性和扩展导致了系统的复杂性，使软件难以验证且更容易出错。因此，我们选择编写具有有限功能和更好可理解性的CA，以便更容易审计预期的输入和输出。
- en: We continuously work on simplifying the architecture of the CA to make it more
    understandable and maintainable. In one case, we realized that our architecture
    had created too many different microservices, resulting in increased maintenance
    costs. While we wanted the benefits of a modular service with well-defined boundaries,
    we found that it was simpler to consolidate some parts of the system. In another
    case, we realized that our ACL checks for RPC calls were implemented manually
    in each instance, creating opportunities for developer and reviewer error. We
    refactored the codebase to centralize ACL checks and eliminate the possibility
    of new RPCs being added without ACLs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不断努力简化CA的架构，使其更易于理解和维护。有一次，我们意识到我们的架构创建了太多不同的微服务，导致维护成本增加。虽然我们希望获得模块化服务和明确定义的边界的好处，但我们发现将系统的某些部分合并更简单。在另一种情况下，我们意识到我们对RPC调用的ACL检查是在每个实例中手动实现的，这为开发人员和审阅人员出现错误提供了机会。我们重构了代码库，以集中ACL检查并消除添加新的RPC而不使用ACL的可能性。
- en: Securing Third-Party and Open Source Components
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护第三方和开源组件
- en: Our custom CA relies on third-party code, in the form of open source libraries
    and commercial modules. We needed to validate, harden, and containerize this code.
    As a first step, we focused on the several well-known and widely used open source
    packages the CA uses. Even open source packages that are widely used in security
    contexts, and that originate from individuals or organizations with strong security
    backgrounds, are susceptible to vulnerabilities. We conducted an in-depth security
    review of each, and submitted patches to address issues we found. Where possible,
    we also subjected all third-party and open source components to the testing regime
    detailed in the next section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义CA依赖于第三方代码，即开源库和商业模块。我们需要验证、加固和容器化这些代码。作为第一步，我们专注于CA使用的几个众所周知且广泛使用的开源软件包。即使是在安全环境中广泛使用的开源软件包，也可能来自具有强大安全背景的个人或组织，也容易受到漏洞的影响。我们对每个软件包进行了深入的安全审查，并提交了修补程序以解决我们发现的问题。在可能的情况下，我们还将所有第三方和开源组件都提交到下一节详细介绍的测试制度中。
- en: Our use of two secure zones—one for handling untrusted data and one for handling
    sensitive operations—also gives us some layered protection against bugs or malicious
    insertions into code. The previously mentioned CSR parser relies on open source
    X.509 libraries and runs as a microservice in the untrusted zone in a Borg container.^([7](ch11.html#ch11fn7))
    This provides an extra layer of protection against issues in this code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用两个安全区域——一个用于处理不受信任的数据，另一个用于处理敏感操作——也为我们提供了一些分层保护，以防止错误或恶意插入到代码中。前面提到的CSR解析器依赖于开源X.509库，并作为Borg容器中不受信任区域的微服务运行。这为这段代码提供了额外的保护层。
- en: 'We also had to secure proprietary third-party closed-source code. Running a
    publicly trusted CA requires using a hardware security module (HSM)—a dedicated
    cryptographic processor—provided by a commercial vendor to act as a vault protecting
    the CA’s keys. We wanted to provide an extra layer of validation for the vendor-provided
    code that interacts with the HSM. As with many vendor-supplied solutions, the
    kinds of testing we could perform were limited. To protect the system from problems
    like memory leaks, we took these steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须保护专有的第三方闭源代码。运行一个公开可信的CA需要使用硬件安全模块（HSM）——由商业供应商提供的专用加密处理器——作为保护CA密钥的保险库。我们希望为与HSM交互的供应商提供的代码提供额外的验证层。与许多供应商提供的解决方案一样，我们可以进行的测试种类有限。为了保护系统免受内存泄漏等问题的影响，我们采取了以下步骤：
- en: We built parts of the CA that had to interact with the HSM libraries defensively,
    as we knew that the inputs or outputs might be risky.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们构建了必须与HSM库进行交互的CA的部分，采取了防御性措施，因为我们知道输入或输出可能存在风险。
- en: We ran the third-party code in [*nsjail*](https://oreil.ly/QaE4s), a lightweight
    process isolation mechanism.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在[*nsjail*](https://oreil.ly/QaE4s)中运行第三方代码，这是一个轻量级的进程隔离机制。
- en: We reported issues we found to the vendor.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们向供应商报告了我们发现的问题。
- en: Testing
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: To maintain project hygiene, we write unit and integration tests (see [Chapter 13](ch13.html#onethree_testing_code))
    to cover a wide range of scenarios. Team members are expected to write these tests
    as part of the development process, and peer reviews ensure this practice is adhered
    to. In addition to testing for expected behavior, we test for negative conditions.
    Every few minutes, we generate test certificate issuance conditions that meet
    good criteria, and others that contain egregious errors. For example, we explicitly
    test that accurate error messages trigger alarms when an unauthorized person makes
    an issuance. Having a repository of both positive and negative test conditions
    enables us to perform high-confidence end-to-end testing on all new CA software
    deployments very quickly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持项目的卫生，我们编写单元测试和集成测试（见[第13章](ch13.html#onethree_testing_code)）来覆盖各种场景。团队成员应在开发过程中编写这些测试，而同行评审则确保遵守这一做法。除了测试预期行为外，我们还测试负面情况。每隔几分钟，我们生成符合良好标准的测试证书签发条件，以及包含严重错误的条件。例如，我们明确测试了当未经授权的人员进行签发时，准确的错误消息是否会触发警报。拥有正面和负面测试条件的存储库使我们能够非常快速地对所有新的CA软件部署进行高可信度的端到端测试。
- en: By using Google’s centralized software development toolchains, we also gain
    the benefits of integrated automated code testing on both pre-submit and post-build
    artifacts. As discussed in [“Integration of Static Analysis in the Developer Workflow”](ch13.html#integration_of_static_analysis_in_the_d),
    all code changes at Google are inspected by Tricorder, our static analysis platform.
    We also subject the CA’s code to a variety of sanitizers, such as AddressSanitizer
    (ASAN) and ThreadSanitizer, to identify common errors (see [“Dynamic Program Analysis”](ch13.html#dynamic_program_analysis)).
    Additionally, we perform targeted fuzzing of the CA code (see [“Fuzz Testing”](ch13.html#fuzz_testing)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用谷歌的集中式软件开发工具链，我们还获得了在提交前和构建后的集成自动代码测试的好处。正如在[“将静态分析集成到开发人员工作流程中”](ch13.html#integration_of_static_analysis_in_the_d)中讨论的那样，谷歌所有的代码更改都经过Tricorder，我们的静态分析平台的检查。我们还对CA的代码进行各种消毒剂的检查，如AddressSanitizer（ASAN）和ThreadSanitizer，以识别常见错误（见[“动态程序分析”](ch13.html#dynamic_program_analysis)）。此外，我们对CA代码进行有针对性的模糊测试（见[“模糊测试”](ch13.html#fuzz_testing)）。
- en: Resiliency for the CA Key Material
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CA密钥材料的弹性
- en: The most severe risk to a CA is theft or misuse of CA key material. Most of
    the mandated security controls for a publicly trusted CA address common problems
    that can lead to such abuse, and include standard advice such as using HSMs and
    strict access controls.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: CA面临的最严重风险是CA密钥材料的盗窃或滥用。公开可信的CA的大多数强制性安全控制措施都是针对可能导致这种滥用的常见问题，包括使用HSM和严格的访问控制等标准建议。
- en: We keep the CA’s root key material offline and secure it with multiple layers
    of physical protection that require two-party authorization for each access layer.
    For day-to-day certificate issuance, we use intermediary keys that are available
    online, which is standard practice across the industry. Since the process of getting
    a publicly trusted CA included broadly in the ecosystem (that is, in browsers,
    televisions, and cellphones) can take years, rotating keys as part of a recovery
    effort after compromise (see [“Rotating signing keys”](ch09.html#rotating_signing_keys))
    is not a straightforward or timely process. Therefore, loss or theft of key material
    can cause significant disruption. As a defense against this scenario, we mature
    other root key material in the ecosystem (by distributing the material to browsers
    and other clients that make use of encrypted connections) so we can swap in alternate
    material if necessary.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将CA的根密钥材料离线保存，并用多层物理保护来保护它，每个访问层都需要两方授权。对于日常证书签发，我们使用在线可用的中间密钥，这是行业标准做法。由于让公众信任的CA被广泛纳入生态系统（即浏览器、电视和手机）的过程可能需要多年时间，因此在遭受损害后旋转密钥（参见“旋转签名密钥”）作为恢复工作的一部分并不是一个简单或及时的过程。因此，密钥材料的丢失或被盗可能会造成重大中断。为了防范这种情况，我们在生态系统中成熟了其他根密钥材料（通过将材料分发给使用加密连接的浏览器和其他客户端），这样我们就可以在必要时替换备用材料。
- en: Data Validation
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据验证
- en: Aside from loss of key material, issuance errors are the most serious mistakes
    a CA can make. We sought to design our systems to ensure that human discretion
    cannot influence validation or issuance, which means we can focus our attention
    on the correctness and robustness of the CA code and infrastructure.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了密钥材料的丢失，签发错误是CA可能犯的最严重的错误。我们努力设计我们的系统，以确保人为判断不能影响验证或签发，这意味着我们可以将注意力集中在CA代码和基础设施的正确性和健壮性上。
- en: Continuous validation (see [“Continuous Validation”](ch08.html#continuous_validation))
    ensures a system is behaving as anticipated. To implement this concept in Google’s
    publicly trusted CA, we automatically run certificates through linters at multiple
    stages of the issuance process.^([8](ch11.html#ch11fn8)) The linters check for
    error patterns—for example, ensuring that certificates have a valid lifetime or
    that `subject:commonName` has a valid length. Once the certificate is validated,
    we enter it into Certificate Transparency logs, which allows for ongoing validation
    by the public. As a final defense against malicious issuance, we also use multiple
    independent logging systems, which we can reconcile by comparing the two systems
    entry by entry to ensure consistency. These logs are signed before they reach
    the log repository for further safety and later validation, if needed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 持续验证（见“持续验证”）确保系统的行为符合预期。为了在Google的公众信任CA中实现这一概念，我们自动在签发过程的多个阶段通过linter运行证书。linter检查错误模式，例如确保证书具有有效的生命周期或者`subject:commonName`具有有效的长度。一旦证书经过验证，我们将其输入到证书透明日志中，这允许公众进行持续验证。为了防范恶意签发，我们还使用多个独立的日志系统，通过逐个比较两个系统的条目来确保一致性。这些日志在到达日志存储库之前会被签名，以提供进一步的安全性和以备需要时进行后续验证。
- en: Conclusion
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: Certificate authorities are an example of infrastructure that has strong requirements
    for security and reliability. Using the best practices outlined in this book for
    the implementation of infrastructure can lead to long-term positive outcomes for
    security and reliability. These principles should be part of a design early on,
    but you should also use them to improve systems as they mature.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 证书颁发机构是对安全性和可靠性有严格要求的基础设施的一个例子。使用本书中概述的最佳实践来实施基础设施可以带来长期的安全性和可靠性。这些原则应该是设计的一部分，但您也应该在系统成熟时使用它们来改进系统。
- en: ^([1](ch11.html#ch11fn1-marker)) The latest version of TLS is described in [RFC
    8446](https://oreil.ly/dB0au).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch11.html#ch11fn1-marker)) TLS的最新版本在[RFC 8446](https://oreil.ly/dB0au)中有描述。
- en: ^([2](ch11.html#ch11fn2-marker)) Secure/Multipurpose Internet Mail Extensions
    is a common method to encrypt email content.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch11.html#ch11fn2-marker)) 安全/多用途互联网邮件扩展是一种加密电子邮件内容的常见方法。
- en: ^([3](ch11.html#ch11fn3-marker)) We recognize that many organizations do build
    and operate private CAs, using common solutions such as Microsoft’s AD Certificate
    Services. These are typically for internal use only.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch11.html#ch11fn3-marker)) 我们意识到许多组织确实构建和运营私有CA，使用诸如微软的AD证书服务等常见解决方案。这些通常仅供内部使用。
- en: ^([4](ch11.html#ch11fn4-marker)) DigiNotar [went out of business](https://oreil.ly/nwNnG)
    after attackers compromised and misused its CA.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch11.html#ch11fn4-marker)) DigiNotar在遭受攻击者的侵害和滥用其CA后[破产了](https://oreil.ly/nwNnG)。
- en: ^([5](ch11.html#ch11fn5-marker)) A good reference for domain validation guidelines
    is the [CA/Browser Forum Baseline Requirements](https://oreil.ly/OkYRq).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch11.html#ch11fn5-marker)) 域验证指南的良好参考是[CA/Browser Forum基线要求](https://oreil.ly/OkYRq)。
- en: ^([6](ch11.html#ch11fn6-marker)) The [Mitre CVE database](https://cve.mitre.org)
    contains hundreds of vulnerabilities discovered in various DER handlers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch11.html#ch11fn6-marker)) [Mitre CVE数据库](https://cve.mitre.org)中包含了各种DER处理程序发现的数百个漏洞。
- en: '^([7](ch11.html#ch11fn7-marker)) Borg containers are described in Verma, Abhishek
    et al. 2015\. “Large-Scale Cluster Management at Google with Borg.” *Proceedings
    of the 10th European Conference on Computer Systems*: 1–17\. doi:10.1145/2741948.2741964.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '^([7](ch11.html#ch11fn7-marker)) Borg容器在Verma, Abhishek等人的2015年的论文“Large-Scale
    Cluster Management at Google with Borg.”中有描述。*Proceedings of the 10th European
    Conference on Computer Systems*: 1–17\. doi:10.1145/2741948.2741964。'
- en: ^([8](ch11.html#ch11fn8-marker)) For example, [ZLint](https://github.com/zmap/zlint)
    is a linter written in Go that verifies that the contents of a certificate are
    consistent with RFC 5280 and the CA/Browser Forum requirements.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch11.html#ch11fn8-marker)) 例如，[ZLint](https://github.com/zmap/zlint)是一个用Go编写的linter，用于验证证书的内容是否符合RFC
    5280和CA/Browser Forum的要求。

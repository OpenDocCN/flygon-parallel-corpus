- en: 'Chapter 11\. Case Study: Designing, Implementing, and Maintaining a Publicly
    Trusted CA'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By Andy Warner, James Kasten, Rob Smits, Piotr Kucharski, and Sergey Simakov
  prefs: []
  type: TYPE_NORMAL
- en: Background on Publicly Trusted Certificate Authorities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Publicly trusted certificate authorities act as trust anchors for the transport
    layer of the internet by issuing certificates for Transport Layer Security (TLS),^([1](ch11.html#ch11fn1))
    S/MIME,^([2](ch11.html#ch11fn2)) and other common distributed trust scenarios.
    They are the set of CAs that browsers, operating systems, and devices trust by
    default. As such, writing and maintaining a publicly trusted CA raises a number
    of security and reliability considerations.
  prefs: []
  type: TYPE_NORMAL
- en: To become publicly trusted and maintain that status, a CA must pass a number
    of criteria that span different platforms and use cases. At minimum, publicly
    trusted CAs must undergo audits against standards such as [WebTrust](https://oreil.ly/ubToZ)
    and those set by organizations like the [European Telecommunications Standards
    Institute (ETSI)](https://www.etsi.org). Publicly trusted CAs must also meet the
    objectives of the [CA/Browser Forum Baseline Requirements](https://oreil.ly/gfdBF).
    These evaluations assess logical and physical security controls, procedures, and
    practices, and a typical publicly trusted CA spends at least one quarter of each
    year on these audit(s). Additionally, most browsers and operating systems have
    their own unique requirements that a CA must meet before it’s trusted by default.
    As requirements change, CAs need to be adaptable and amenable to making process
    or infrastructure changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chances are, your organization will never need to build a publicly trusted
    CA^([3](ch11.html#ch11fn3))—most organizations rely on third parties for acquiring
    public TLS certificates, code signing certificates, and other types of certificates
    that require broad trust by users. With that in mind, the goal of this case study
    is not to show you how to build a publicly trusted CA, but to highlight some of
    our findings that might resonate with projects in your environment. Key takeaways
    included the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Our choice of programming language and decision to use segmentation or containers
    when handling data generated by third parties made the overall environment more
    secure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rigorously testing and hardening code—both code we generated ourselves and third-party
    code—was critical for addressing fundamental reliability and security issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our infrastructure became safer and more reliable when we reduced complexity
    in the design and replaced manual steps with automation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding our threat model enabled us to build validation and recovery mechanisms
    that allow us to better prepare for a disaster ahead of time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Did We Need a Publicly Trusted CA?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our business needs for a publicly trusted CA changed over time. In Google’s
    early days, we purchased all of our public certificates from a third-party CA.
    This approach had three inherent problems we wanted to solve:'
  prefs: []
  type: TYPE_NORMAL
- en: Reliance on third parties
  prefs: []
  type: TYPE_NORMAL
- en: Business requirements that necessitate a high level of trust—for example, offering
    cloud services to customers—meant we needed strong validation and control over
    how certificates were issued and handled. Even if we performed mandatory audits
    in the CA ecosystem, we were unsure of whether third parties could meet a high
    standard of safety. Notable lapses in security at publicly trusted CAs solidified
    our views about safety.^([4](ch11.html#ch11fn4))
  prefs: []
  type: TYPE_NORMAL
- en: Need for automation
  prefs: []
  type: TYPE_NORMAL
- en: 'Google has thousands of company-owned domains that serve users globally. As
    part of our ubiquitous TLS efforts (see [“Example: Increasing HTTPS usage”](ch07.html#example_increasing_https_usage)),
    we wanted to protect every domain we own and rotate certificates frequently. We
    also wanted to provide an easy way for customers to get TLS certificates. Automating
    the acquisition of new certificates was difficult because third-party publicly
    trusted CAs often did not have extensible APIs, or provided SLAs below our needs.
    As a result, much of the request process for these certificates involved error-prone
    manual methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Cost
  prefs: []
  type: TYPE_NORMAL
- en: Given the millions of TLS certificates Google wanted to use for its own web
    properties and on behalf of customers, cost analysis showed it would be more cost-effective
    to design, implement, and maintain our own CA rather than continuing to obtain
    certificates from third-party root CAs.
  prefs: []
  type: TYPE_NORMAL
- en: The Build or Buy Decision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once Google decided it wanted to operate a publicly trusted CA, we had to decide
    whether to buy commercial software to operate the CA or to write our own software.
    Ultimately, we decided to develop the core of the CA ourselves, with the option
    to integrate open source and commercial solutions where necessary. Among a number
    of deciding factors, there were a few primary motivators behind this decision:'
  prefs: []
  type: TYPE_NORMAL
- en: Transparency and validation
  prefs: []
  type: TYPE_NORMAL
- en: Commercial solutions for CAs often didn’t come with the level of auditability
    for code or the supply chain that we needed for such critical infrastructure.
    Even though it was integrated with open source libraries and used some third-party
    proprietary code, writing and testing our own CA software gave us increased confidence
    in the system we were building.
  prefs: []
  type: TYPE_NORMAL
- en: Integration capabilities
  prefs: []
  type: TYPE_NORMAL
- en: We wanted to simplify implementation and maintenance of the CA by integrating
    with Google’s secure critical infrastructure. For example, we could set up regular
    backups in [Spanner](https://oreil.ly/ZnhV-) with one line in a configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Flexibility
  prefs: []
  type: TYPE_NORMAL
- en: The wider internet community was developing new initiatives that would provide
    increased security for the ecosystem. [Certificate Transparency](https://www.certificate-transparency.org)—a
    way to monitor and audit certificates—and domain validation using DNS, HTTP, and
    other methods^([5](ch11.html#ch11fn5)) are two canonical examples. We wanted to
    be early adopters of these kinds of initiatives, and a custom CA was our best
    option for being able to add this flexibility quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Design, Implementation, and Maintenance Considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To secure our CA, we created a three-layer tiered architecture, where each
    layer is responsible for a different part of the issuance process: certificate
    request parsing, Registration Authority functions (routing and logic), and certificate
    signing. Each layer is composed of microservices with well-defined responsibilities.
    We also devised a dual trust zone architecture, where untrusted input is handled
    in a different environment than critical operations. This segmentation creates
    carefully defined boundaries that promote understandability and ease of review.
    The architecture also makes mounting an attack more difficult: since components
    are limited in functionality, an attacker who gains access to a given component
    will be similarly limited in the functionality they can affect. To gain additional
    access, the attacker would have to bypass additional audit points.'
  prefs: []
  type: TYPE_NORMAL
- en: Each microservice is designed and implemented with simplicity as a key principle.
    Over the lifetime of the CA, we continually refactor each component with simplicity
    in mind. We subject code (both internally developed and third-party) and data
    to rigorous testing and validation. We also containerize code when doing so will
    improve safety. This section describes our approach to addressing security and
    reliability through good design and implementation choices in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Language Choice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The choice of programming language for parts of the system that accept arbitrary
    untrusted input was an important aspect of the design. Ultimately, we decided
    to write the CA in a mix of Go and C++, and chose which language to use for each
    subcomponent based upon its purpose. Both Go and C++ have interoperability with
    well-tested cryptographic libraries, exhibit excellent performance, and have a
    strong ecosystem of frameworks and tools to implement common tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Since Go is memory-safe, it has some additional upsides for security where the
    CA handles arbitrary input. For example, [Certificate Signing Requests (CSRs)](https://oreil.ly/8YkPI)
    represent untrusted input into the CA. CSRs could come from one of our internal
    systems, which may be relatively safe, or from an internet user (perhaps even
    a malicious actor). There is a long history of memory-related vulnerabilities
    in code that parses DER (Distinguished Encoding Rules, the encoding format used
    for certificates),^([6](ch11.html#ch11fn6)) so we wanted to use a memory-safe
    language that provided extra security. [Go](https://oreil.ly/WM_zw) fit the bill.
  prefs: []
  type: TYPE_NORMAL
- en: C++ is not memory-safe, but has good interoperability for critical subcomponents
    of the system—especially for certain components of Google’s core infrastructure.
    To secure this code, we run it in a secure zone and validate all data before it
    reaches that zone. For example, for CSR handling, we parse the request in Go before
    relaying it to the C++ subsystem for the same operation, and then compare the
    results. If there is a discrepancy, processing does not proceed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we [enforce good security practices and readability](https://oreil.ly/m8dug)
    at pre-submit time for all C++ code, and Google’s centralized toolchain enables
    various compile-time and runtime mitigations. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[W^X](https://oreil.ly/9gNIa)'
  prefs: []
  type: TYPE_NORMAL
- en: Breaks the common exploitation trick of `mmap`ing with `PROT_EXEC` by copying
    shellcode and jumping into that memory. This mitigation does not incur a CPU or
    memory performance hit.
  prefs: []
  type: TYPE_NORMAL
- en: '[Scudo Allocator](https://oreil.ly/xpo5t)'
  prefs: []
  type: TYPE_NORMAL
- en: A user-mode secure heap allocator.
  prefs: []
  type: TYPE_NORMAL
- en: '[SafeStack](https://oreil.ly/EPwod)'
  prefs: []
  type: TYPE_NORMAL
- en: A security mitigation technique that protects against attacks based on stack
    buffer overflows.
  prefs: []
  type: TYPE_NORMAL
- en: Complexity Versus Understandability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a defensive measure, we explicitly chose to implement our CA with limited
    functionality compared to the full range of options available in the standards
    (see [“Designing Understandable Systems”](ch06.html#designing_understandable_systems)).
    Our primary use case was to issue certificates for standard web services with
    commonly used attributes and extensions. Our evaluation of commercial and open
    source CA software options showed that their attempts to accommodate esoteric
    attributes and extensions that we didn’t need led to complexity in the system,
    making the software difficult to validate and more error-prone. Therefore, we
    opted to write a CA with limited functionality and better understandability, where
    we could more easily audit expected inputs and outputs.
  prefs: []
  type: TYPE_NORMAL
- en: We continuously work on simplifying the architecture of the CA to make it more
    understandable and maintainable. In one case, we realized that our architecture
    had created too many different microservices, resulting in increased maintenance
    costs. While we wanted the benefits of a modular service with well-defined boundaries,
    we found that it was simpler to consolidate some parts of the system. In another
    case, we realized that our ACL checks for RPC calls were implemented manually
    in each instance, creating opportunities for developer and reviewer error. We
    refactored the codebase to centralize ACL checks and eliminate the possibility
    of new RPCs being added without ACLs.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Third-Party and Open Source Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our custom CA relies on third-party code, in the form of open source libraries
    and commercial modules. We needed to validate, harden, and containerize this code.
    As a first step, we focused on the several well-known and widely used open source
    packages the CA uses. Even open source packages that are widely used in security
    contexts, and that originate from individuals or organizations with strong security
    backgrounds, are susceptible to vulnerabilities. We conducted an in-depth security
    review of each, and submitted patches to address issues we found. Where possible,
    we also subjected all third-party and open source components to the testing regime
    detailed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Our use of two secure zones—one for handling untrusted data and one for handling
    sensitive operations—also gives us some layered protection against bugs or malicious
    insertions into code. The previously mentioned CSR parser relies on open source
    X.509 libraries and runs as a microservice in the untrusted zone in a Borg container.^([7](ch11.html#ch11fn7))
    This provides an extra layer of protection against issues in this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also had to secure proprietary third-party closed-source code. Running a
    publicly trusted CA requires using a hardware security module (HSM)—a dedicated
    cryptographic processor—provided by a commercial vendor to act as a vault protecting
    the CA’s keys. We wanted to provide an extra layer of validation for the vendor-provided
    code that interacts with the HSM. As with many vendor-supplied solutions, the
    kinds of testing we could perform were limited. To protect the system from problems
    like memory leaks, we took these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We built parts of the CA that had to interact with the HSM libraries defensively,
    as we knew that the inputs or outputs might be risky.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We ran the third-party code in [*nsjail*](https://oreil.ly/QaE4s), a lightweight
    process isolation mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We reported issues we found to the vendor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To maintain project hygiene, we write unit and integration tests (see [Chapter 13](ch13.html#onethree_testing_code))
    to cover a wide range of scenarios. Team members are expected to write these tests
    as part of the development process, and peer reviews ensure this practice is adhered
    to. In addition to testing for expected behavior, we test for negative conditions.
    Every few minutes, we generate test certificate issuance conditions that meet
    good criteria, and others that contain egregious errors. For example, we explicitly
    test that accurate error messages trigger alarms when an unauthorized person makes
    an issuance. Having a repository of both positive and negative test conditions
    enables us to perform high-confidence end-to-end testing on all new CA software
    deployments very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: By using Google’s centralized software development toolchains, we also gain
    the benefits of integrated automated code testing on both pre-submit and post-build
    artifacts. As discussed in [“Integration of Static Analysis in the Developer Workflow”](ch13.html#integration_of_static_analysis_in_the_d),
    all code changes at Google are inspected by Tricorder, our static analysis platform.
    We also subject the CA’s code to a variety of sanitizers, such as AddressSanitizer
    (ASAN) and ThreadSanitizer, to identify common errors (see [“Dynamic Program Analysis”](ch13.html#dynamic_program_analysis)).
    Additionally, we perform targeted fuzzing of the CA code (see [“Fuzz Testing”](ch13.html#fuzz_testing)).
  prefs: []
  type: TYPE_NORMAL
- en: Resiliency for the CA Key Material
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most severe risk to a CA is theft or misuse of CA key material. Most of
    the mandated security controls for a publicly trusted CA address common problems
    that can lead to such abuse, and include standard advice such as using HSMs and
    strict access controls.
  prefs: []
  type: TYPE_NORMAL
- en: We keep the CA’s root key material offline and secure it with multiple layers
    of physical protection that require two-party authorization for each access layer.
    For day-to-day certificate issuance, we use intermediary keys that are available
    online, which is standard practice across the industry. Since the process of getting
    a publicly trusted CA included broadly in the ecosystem (that is, in browsers,
    televisions, and cellphones) can take years, rotating keys as part of a recovery
    effort after compromise (see [“Rotating signing keys”](ch09.html#rotating_signing_keys))
    is not a straightforward or timely process. Therefore, loss or theft of key material
    can cause significant disruption. As a defense against this scenario, we mature
    other root key material in the ecosystem (by distributing the material to browsers
    and other clients that make use of encrypted connections) so we can swap in alternate
    material if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Data Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Aside from loss of key material, issuance errors are the most serious mistakes
    a CA can make. We sought to design our systems to ensure that human discretion
    cannot influence validation or issuance, which means we can focus our attention
    on the correctness and robustness of the CA code and infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous validation (see [“Continuous Validation”](ch08.html#continuous_validation))
    ensures a system is behaving as anticipated. To implement this concept in Google’s
    publicly trusted CA, we automatically run certificates through linters at multiple
    stages of the issuance process.^([8](ch11.html#ch11fn8)) The linters check for
    error patterns—for example, ensuring that certificates have a valid lifetime or
    that `subject:commonName` has a valid length. Once the certificate is validated,
    we enter it into Certificate Transparency logs, which allows for ongoing validation
    by the public. As a final defense against malicious issuance, we also use multiple
    independent logging systems, which we can reconcile by comparing the two systems
    entry by entry to ensure consistency. These logs are signed before they reach
    the log repository for further safety and later validation, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Certificate authorities are an example of infrastructure that has strong requirements
    for security and reliability. Using the best practices outlined in this book for
    the implementation of infrastructure can lead to long-term positive outcomes for
    security and reliability. These principles should be part of a design early on,
    but you should also use them to improve systems as they mature.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch11.html#ch11fn1-marker)) The latest version of TLS is described in [RFC
    8446](https://oreil.ly/dB0au).
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch11.html#ch11fn2-marker)) Secure/Multipurpose Internet Mail Extensions
    is a common method to encrypt email content.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch11.html#ch11fn3-marker)) We recognize that many organizations do build
    and operate private CAs, using common solutions such as Microsoft’s AD Certificate
    Services. These are typically for internal use only.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch11.html#ch11fn4-marker)) DigiNotar [went out of business](https://oreil.ly/nwNnG)
    after attackers compromised and misused its CA.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch11.html#ch11fn5-marker)) A good reference for domain validation guidelines
    is the [CA/Browser Forum Baseline Requirements](https://oreil.ly/OkYRq).
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch11.html#ch11fn6-marker)) The [Mitre CVE database](https://cve.mitre.org)
    contains hundreds of vulnerabilities discovered in various DER handlers.
  prefs: []
  type: TYPE_NORMAL
- en: '^([7](ch11.html#ch11fn7-marker)) Borg containers are described in Verma, Abhishek
    et al. 2015\. “Large-Scale Cluster Management at Google with Borg.” *Proceedings
    of the 10th European Conference on Computer Systems*: 1–17\. doi:10.1145/2741948.2741964.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch11.html#ch11fn8-marker)) For example, [ZLint](https://github.com/zmap/zlint)
    is a linter written in Go that verifies that the contents of a certificate are
    consistent with RFC 5280 and the CA/Browser Forum requirements.
  prefs: []
  type: TYPE_NORMAL

["```\ntype Request struct {  Payload proto.Message  } **type** Response struct {  Err error\n  Payload proto.Message  } **type** Interceptor interface {  Before(context.Context, *Request) (context.Context, error)  After(context.Context, *Response) error } **type** CallInfo struct {  User string  Host string  ...  }\n```", "```\ntype authzInterceptor **struct** {\n allowedRoles **map**[**string**]**bool**\n}\n\nfunc (ai *authzInterceptor) Before(ctx context.Context, req *Request) (context.Context, error) {\n  *// callInfo was populated by the framework.*\n  callInfo, err := FromContext(ctx)\n  **if** err != **nil** { **return** ctx, err }\n\n  **if** ai.allowedRoles[callInfo.User] { **return** ctx, **nil** }\n  **return** ctx, fmt.Errorf(\"Unauthorized request from %q\", callInfo.User)\n}\n\nfunc (*authzInterceptor) After(ctx context.Context, resp *Response) error {\n  **return** **nil**  *// Nothing left to do here after the RPC is handled.*\n}\n```", "```\ntype logInterceptor struct {\n  logger *LoggingBackendStub\n}\n\nfunc (*logInterceptor) Before(ctx context.Context,\n                              req *Request) (context.Context, error) {\n  *// callInfo was populated by the framework.*\n  callInfo, err := FromContext(ctx)\n  if err != **nil** { **return** ctx, err }\n  logReq := &pb.LogRequest{\n    timestamp: time.Now().Unix(),\n    user: callInfo.User,\n    request: req.Payload,\n  }\n  resp, err := logger.Log(ctx, logReq, WithAttemptCount(3))\n  return ctx, err\n}\n\nfunc (*logInterceptor) After(ctx context.Context, resp *Response) error {\n  **if** resp.Err == **nil** { return **nil** }\n\n  logErrorReq := &pb.LogErrorRequest{\n    timestamp: time.Now().Unix(),\n    error: resp.Err.Error(),\n  }\n  resp, err := logger.LogError(ctx, logErrorReq, WithAttemptCount(3))\n  return err\n}\n```", "```\ndb.query(\"UPDATE users SET pw_hash = '\" + request[\"pw_hash\"] \n         + \"' WHERE reset_token = '\" + request.params[\"reset_token\"] + \"'\")\n```", "```\nQuery q = db.createQuery(\n  \"UPDATE users SET pw_hash = @hash WHERE token = @token\");\nq.setParameter(\"hash\", request.params[\"hash\"]);\nq.setParameter(\"token\", request.params[\"token\"]);\ndb.query(q);\n```", "```\nstruct Query {\n  sql strings.Builder;\n} \ntype stringLiteral string;  \n*// Only call this function with string literal parameters.*\nfunc (q *Query) AppendLiteral(literal stringLiteral) {\n  q.sql.writeString(literal);\n}\n*// q.AppendLiteral(\"foo\") will work, q.AppendLiteral(foo) will not*\n```", "```\n{template .foo kind=\"html\"}<script src=\"{$url}\"></script>{/template}\n```", "```\ntemplateRendered.setMapData(ImmutableMap.of(\"url\", some_variable));\n```", "```\ntemplateRenderer.setMapData(\n     ImmutableMap.of(\"x\", TrustedResourceUrl.fromConstant(\"/script.js\"))\n ).render();\n```", "```\n<a onclick=\"showUserProfile('{{username}}');\">Show profile</a>\">\n```", "```\nclass Mammal { ...\n  virtual Status Sleep(bool hibernate) = 0;\n};\nclass Human : public Mammal { ...\n  virtual Status Sleep(bool hibernate) {\n    age += hibernate ? kSevenMonths : kSevenHours;\n    return OK;\n  }\n};\n```", "```\nclass Human { ...\n  void Sleep() { age += kSevenHours; }\n};\n```", "```\nclass Bar {  public:  Bar(bool is_safe) {...}  };  void Foo(const Bar& bar) {...}  Foo(false);  *// Likely OK, but is the developer aware a Bar object was created?*  Foo(5);      *// Will create Bar(is_safe := true), but likely by accident.*  Foo(NULL);   *// Will create Bar(is_safe := false), again likely by accident.*\n```"]
- en: Chapter 12\. Writing Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。编写代码
- en: By Michał Czapiński and Julian Bangert
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由Michał Czapiński和Julian Bangert撰写
- en: with Thomas Maufer and Kavita Guliani
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与Thomas Maufer和Kavita Guliani合作
- en: Security and reliability cannot easily be retrofitted into software, so it’s
    important to account for them in software design from the earliest phases. Tacking
    on these features after a launch is painful and less effective, and may require
    you to change other fundamental assumptions about the codebase (see [Chapter 4](ch04.html#design_tradeoffs)
    for a deeper discussion on this topic).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性和可靠性不能轻易地加入软件中，因此在软件设计的早期阶段就考虑它们是很重要的。在发布后添加这些功能是痛苦且不太有效的，可能需要您改变代码库的其他基本假设（有关此主题的更深入讨论，请参见[第4章](ch04.html#design_tradeoffs)）。
- en: The first and most important step in reducing security and reliability issues
    is to educate developers. However, even the best-trained engineers make mistakes—security
    experts can write insecure code and SREs can miss reliability issues. It’s difficult
    to keep the many considerations and tradeoffs involved in building secure and
    reliable systems in mind simultaneously, especially if you’re also responsible
    for producing software.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 减少安全性和可靠性问题的第一步，也是最重要的一步是教育开发人员。然而，即使是训练有素的工程师也会犯错——安全专家可能会编写不安全的代码，SRE可能会忽略可靠性问题。在同时考虑构建安全和可靠系统所涉及的许多考虑因素和权衡是困难的，尤其是如果你还负责生产软件的话。
- en: Instead of relying solely on developers to vet code for security and reliability,
    you can task SREs and security experts with reviewing code and software designs.
    This approach is also imperfect—manual code reviews won’t find every issue, and
    no reviewer will catch *every* security problem that an attacker could potentially
    exploit. Reviewers can also be biased by their own experience or interests. For
    example, they may naturally gravitate toward seeking out new classes of attacks,
    high-level design issues, or interesting flaws in cryptographic protocols; in
    contrast, reviewing hundreds of HTML templates for cross-site scripting (XSS)
    flaws or checking the error-handling logic for each RPC in an application may
    be seen as less thrilling.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 与其完全依赖开发人员审查代码的安全性和可靠性，不如让SRE和安全专家审查代码和软件设计。这种方法也是不完美的——手动代码审查不会发现每个问题，也不会每个安全问题都能被审查人员发现。审查人员也可能会受到自己的经验或兴趣的影响。例如，他们可能自然而然地倾向于寻找新的攻击类型、高级设计问题或加密协议中的有趣缺陷；相比之下，审查数百个HTML模板以查找跨站脚本（XSS）漏洞，或者检查应用程序中每个RPC的错误处理逻辑可能会被视为不那么令人兴奋。
- en: While code reviews may not find every vulnerability, they do have other benefits.
    A strong review culture encourages developers to structure their code in a way
    that makes the security and reliability properties easy to review. This chapter
    discusses strategies for making these properties obvious to reviewers and for
    integrating automation into the development process. These strategies can free
    up a team’s bandwidth to focus on other issues and lead to building a culture
    of security and reliability (see [Chapter 21](ch21.html#twoone_building_a_culture_of_security_a)).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码审查可能不会发现每个漏洞，但它们确实有其他好处。良好的审查文化鼓励开发人员以便于审查安全性和可靠性属性的方式构建他们的代码。本章讨论了使审查人员能够明显看到这些属性的策略，并将自动化整合到开发过程中。这些策略可以释放团队的带宽，让他们专注于其他问题，并建立安全和可靠性的文化（参见[第21章](ch21.html#twoone_building_a_culture_of_security_a)）。
- en: Frameworks to Enforce Security and Reliability
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制执行安全性和可靠性的框架
- en: As discussed in [Chapter 6](ch06.html#design_for_understandability), the security
    and reliability of an application rely on domain-specific invariants. For example,
    an application is secure against SQL injection attacks if all of its database
    queries consist only of developer-controlled code, with external inputs supplied
    via query parameter bindings. A web application can prevent XSS attacks if all
    user input that’s inserted into HTML forms is properly escaped or sanitized to
    remove any executable code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第6章](ch06.html#design_for_understandability)所讨论的，应用程序的安全性和可靠性依赖于特定领域的不变量。例如，如果应用程序的所有数据库查询仅由开发人员控制的代码组成，并通过查询参数绑定提供外部输入，那么该应用程序就可以防止SQL注入攻击。如果所有插入HTML表单的用户输入都经过适当转义或清理以删除任何可执行代码，Web应用程序就可以防止XSS攻击。
- en: In theory, you can create secure and reliable software by carefully writing
    application code that maintains these invariants. However, as the number of desired
    properties and the size of the codebase grows, this approach becomes almost impossible.
    It’s unreasonable to expect any developer to be an expert in all these subjects,
    or to constantly maintain vigilance when writing or reviewing code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，您可以通过仔细编写维护这些不变量的应用程序代码来创建安全可靠的软件。然而，随着所需属性的数量和代码库的规模增长，这种方法几乎变得不可能。不合理地期望任何开发人员都是所有这些主题的专家，或者在编写或审查代码时始终保持警惕是不合理的。
- en: If humans need to manually review every change, those humans will have a hard
    time maintaining global invariants because reviewers can’t always keep track of
    global context. If a reviewer needs to know which function parameters are passed
    user input by callers and which arguments only contain developer-controlled, trustworthy
    values, they must also be familiar with all transitive callers of a function.
    Reviewers are unlikely to be able to keep this state over the long run.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要人工审查每个更改，那么这些人将很难维护全局不变量，因为审查人员无法始终跟踪全局上下文。如果审查人员需要知道哪些函数参数是由调用者传递的用户输入，哪些参数只包含开发人员控制的可信值，他们还必须熟悉函数的所有传递调用者。审查人员不太可能能够长期保持这种状态。
- en: A better approach is to handle security and reliability in common frameworks,
    languages, and libraries. Ideally, libraries only expose an interface that makes
    writing code with common classes of security vulnerabilities impossible. Multiple
    applications can use each library or framework. When domain experts fix an issue,
    they remove it from all the applications the framework supports, allowing this
    engineering approach to scale better. Compared to manual review, using a centralized
    hardened framework also reduces the chances of future vulnerabilities creeping
    in. Of course, no framework can protect against all security vulnerabilities,
    and it is still possible for attackers to discover an unforeseen class of attacks
    or find mistakes in the implementation of the framework. But if you discover a
    new vulnerability, you can address it in one place (or a few) instead of throughout
    the codebase.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是在通用框架、语言和库中处理安全和可靠性。理想情况下，库只公开一个接口，使得使用常见安全漏洞类的代码编写变得不可能。多个应用程序可以使用每个库或框架。当领域专家修复问题时，他们会从框架支持的所有应用程序中删除它，从而使这种工程方法更好地扩展。与手动审查相比，使用集中的强化框架还可以减少未来漏洞的可能性。当然，没有框架可以防止所有安全漏洞，攻击者仍然有可能发现未预料到的攻击类别或发现框架实现中的错误。但是，如果您发现了新的漏洞，您可以在一个地方（或几个地方）解决它，而不是在整个代码库中。
- en: 'To provide one concrete example: SQL injection (SQLI) holds the top spot on
    both the [OWASP](https://oreil.ly/TnBaK) and [SANS](https://oreil.ly/RWvPF) lists
    of common security vulnerabilities. In our experience, when you use a hardened
    data library such as `TrustedSqlString` (see [“SQL Injection Vulnerabilities:
    TrustedSqlString”](#sql_injection_vulnerabilities_trustedsq)), these types of
    vulnerabilities become a nonissue. Types make these assumptions explicit, and
    are automatically enforced by the compiler.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 举一个具体的例子：SQL注入（SQLI）在常见安全漏洞的[OWASP](https://oreil.ly/TnBaK)和[SANS](https://oreil.ly/RWvPF)列表中占据首要位置。根据我们的经验，当您使用像`TrustedSqlString`这样的强化数据库时（参见[“SQL注入漏洞：TrustedSqlString”](#sql_injection_vulnerabilities_trustedsq)），这类漏洞就不再是问题。类型使这些假设变得明确，并且由编译器自动执行。
- en: Benefits of Using Frameworks
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用框架的好处
- en: Most applications have similar building blocks for security (authentication
    and authorization, logging, data encryption) and reliability (rate limiting, load
    balancing, retry logic). Developing and maintaining such building blocks from
    scratch for every service is expensive, and leads to a patchwork of different
    bugs in each service.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都具有类似的安全构建块（身份验证和授权、日志记录、数据加密）和可靠性构建块（速率限制、负载平衡、重试逻辑）。为每个服务从头开始开发和维护这些构建块是昂贵的，并且会导致每个服务中不同错误的拼接。
- en: 'Frameworks enable code reuse: rather than accounting for all of the security
    and reliability aspects affecting a given functionality or feature, developers
    only need to customize a specific building block. For example, a developer can
    specify which information from the incoming request credentials is important for
    authorization without worrying about the credibility of that information—that
    credibility is verified by the framework. Equally, a developer can specify which
    data needs to be logged without worrying about storage or replication. Frameworks
    also make propagating updates easier, as you need to apply an update in only one
    location.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 框架实现了代码重用：开发人员只需定制特定的构建块，而不需要考虑影响给定功能或特性的所有安全和可靠性方面。例如，开发人员可以指定传入请求凭据中哪些信息对授权很重要，而无需担心这些信息的可信度——框架会验证可信度。同样，开发人员可以指定需要记录哪些数据，而无需担心存储或复制。框架还使传播更新更容易，因为您只需要在一个位置应用更新。
- en: Using frameworks leads to increased productivity for all developers in an organization,
    a benefit for building a culture of security and reliability (see [Chapter 21](ch21.html#twoone_building_a_culture_of_security_a)).
    It’s much more efficient for a team of domain experts to design and develop the
    framework building blocks than for each individual team to implement security
    and reliability features itself. For example, if the security team handles cryptography,
    all other teams benefit from their knowledge. None of the developers using the
    frameworks need to worry about their internal details, and they can instead focus
    on an application’s business logic.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用框架可以提高组织中所有开发人员的生产力，有助于建立安全和可靠文化（参见[第21章](ch21.html#twoone_building_a_culture_of_security_a)）。对于一个团队的领域专家来说，设计和开发框架构建块要比每个团队单独实现安全和可靠特性更有效率。例如，如果安全团队处理加密，其他所有团队都会从他们的知识中受益。使用框架的开发人员无需担心其内部细节，而可以专注于应用程序的业务逻辑。
- en: Frameworks further increase productivity by providing tools that are easy to
    integrate with. For example, frameworks can provide tools that automatically export
    basic operational metrics, like the total number of requests, the number of failed
    requests broken down by error type, or the latency of each processing stage. You
    can use that data to generate automated monitoring dashboards and alerting for
    a service. Frameworks also make integrating with load-balancing infrastructure
    easier, so a service can automatically redirect traffic away from overloaded instances,
    or spin up new service instances under heavy load. As a result, services built
    on top of frameworks exhibit significantly higher reliability.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 框架通过提供易于集成的工具进一步提高了生产力。例如，框架可以提供自动导出基本操作指标的工具，比如总请求数、按错误类型分解的失败请求数量，或者每个处理阶段的延迟。您可以使用这些数据生成自动化监控仪表板和服务的警报。框架还使与负载均衡基础设施集成更容易，因此服务可以自动将流量重定向到超载实例之外，或者在负载较重时启动新的服务实例。因此，基于框架构建的服务表现出更高的可靠性。
- en: Using frameworks also makes reasoning about the code easy by clearly separating
    business logic from common functions. This enables developers to make assertions
    about the security or reliability of a service with more confidence. In general,
    frameworks lead to reduced complexity—when code across multiple services is more
    uniform, it’s easier to follow common good practices.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用框架还可以通过清晰地将业务逻辑与常见功能分离，使对代码的推理变得容易。这使开发人员可以更有信心地对服务的安全性或可靠性做出断言。总的来说，框架可以降低复杂性——当跨多个服务的代码更加统一时，遵循常见的良好实践就更容易了。
- en: 'It doesn’t always make sense to develop your own frameworks. In many cases,
    the best strategy is to reuse existing solutions. For example, almost any security
    professional will advise you against designing and implementing your own cryptographic
    framework—instead, you might use a well-established and widely used framework
    such as Tink (discussed in [“Example: Secure cryptographic APIs and the Tink crypto
    framework”](ch06.html#example_secure_cryptographic_apis_and_t)).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 开发自己的框架并不总是有意义。在许多情况下，最好的策略是重用现有的解决方案。例如，几乎任何安全专业人士都会建议您不要设计和实现自己的加密框架，而是可以使用像Tink这样的成熟和广泛使用的框架（在[“示例：安全加密API和Tink加密框架”](ch06.html#example_secure_cryptographic_apis_and_t)中讨论）。
- en: Before deciding to adopt any specific framework, it’s important to evaluate
    its security posture. We also suggest using actively maintained frameworks and
    continuously updating your code dependencies to incorporate the latest security
    fixes for any code on which your code depends.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定采用任何特定框架之前，评估其安全姿态是很重要的。我们还建议使用积极维护的框架，并不断更新您的代码依赖项，以纳入对您的代码依赖的任何代码的最新安全修复。
- en: 'The following case study is a practical example demonstrating the benefits
    of frameworks: in this case, a framework for creating RPC backends.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下案例是一个实际示例，演示了框架的好处：在这种情况下，是用于创建RPC后端的框架。
- en: 'Example: Framework for RPC Backends'
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：RPC后端框架
- en: 'Most RPC backends follow a similar structure. They handle request-specific
    logic and typically also perform the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数RPC后端遵循类似的结构。它们处理特定于请求的逻辑，并通常还执行以下操作：
- en: Logging
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录
- en: Authentication
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证
- en: Authorization
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权
- en: Throttling (rate limiting)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限流（速率限制）
- en: Instead of reimplementing this functionality for every single RPC backend, we
    recommend using a framework that can hide the implementation details of these
    building blocks. Then developers just need to customize each step to accommodate
    their service’s needs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用一个可以隐藏这些构建块的实现细节的框架，而不是为每个单独的RPC后端重新实现这些功能。然后开发人员只需要定制每个步骤以适应其服务的需求。
- en: '[Figure 12-1](#a_control_flow_in_a_potential_framework) presents a possible
    framework architecture based on predefined *interceptors* that are responsible
    for each of the previously mentioned steps. You can potentially also use interceptors
    for custom steps. Each interceptor defines an action to be performed *before*
    and *after* the actual RPC logic executes. Each stage can report an error condition,
    which prevents further interceptors from executing. However, when this occurs,
    the *after* steps of each interceptor that has already been called are executed
    in the reverse order. The framework between the interceptors can transparently
    perform additional actions—for example, exporting error rates or performance metrics.
    This architecture leads to a clear separation of the logic performed at every
    stage, resulting in increased simplicity and reliability.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-1](#a_control_flow_in_a_potential_framework)展示了一个基于预定义*拦截器*的可能框架架构，这些拦截器负责前面提到的每个步骤。您还可以使用拦截器来执行自定义步骤。每个拦截器定义了在实际RPC逻辑执行*之前*和*之后*要执行的操作。每个阶段都可以报告错误条件，这会阻止进一步执行拦截器。但是，当发生这种情况时，已经调用的每个拦截器的*之后*步骤会以相反的顺序执行。拦截器之间的框架可以透明地执行其他操作，例如导出错误率或性能指标。这种架构导致了在每个阶段执行的逻辑的清晰分离，从而增加了简单性和可靠性。'
- en: '![A control flow in a potential framework for RPC backends; the typical steps
    are encapsulated in predefined interceptors and authorization is highlighted as
    an example](assets/bsrs_1201.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![RPC后端潜在框架中的控制流；典型步骤封装在预定义的拦截器中，授权作为示例突出显示](assets/bsrs_1201.png)'
- en: 'Figure 12-1\. A control flow in a potential framework for RPC backends: the
    typical steps are encapsulated in predefined interceptors and authorization is
    highlighted as an example'
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-1。RPC后端潜在框架中的控制流：典型步骤封装在预定义的拦截器中，授权作为示例突出显示
- en: In this example, the *before* stage of the logging interceptor could log the
    call, and the *after* stage could log the status of the operation. Now, if the
    request is unauthorized, the RPC logic doesn’t execute, but the “permission denied”
    error is properly logged. Afterward, the system calls the authentication and logging
    interceptors’ *after* stages (even if they are empty), and only then does it send
    the error to the client.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，日志拦截器的*之前*阶段可以记录调用，*之后*阶段可以记录操作的状态。现在，如果请求未经授权，RPC逻辑不会执行，但是“权限被拒绝”的错误会被正确记录。之后，系统调用认证和日志拦截器的*之后*阶段（即使它们是空的），然后才将错误发送给客户端。
- en: Interceptors share state through a *context object* that they pass to each other.
    For example, the authentication interceptor’s *before* stage can handle all the
    cryptographic operations associated with certificate handling (note the increased
    security from reusing a specialized crypto library rather than reimplementing
    one yourself). The system then wraps the extracted and validated information about
    the caller in a convenience object, which it adds to the context. Subsequent interceptors
    can easily access this object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器通过它们传递给彼此的*上下文对象*共享状态。例如，认证拦截器的*之前*阶段可以处理与证书处理相关的所有加密操作（注意从重用专门的加密库而不是重新实现一个来提高安全性）。然后系统将提取和验证的关于调用者的信息包装在一个方便的对象中，并将其添加到上下文中。随后的拦截器可以轻松访问此对象。
- en: The framework can then use the context object to track request execution time.
    If at any stage it becomes obvious that the request won’t complete before the
    deadline, the system can automatically cancel the request. You can increase service
    reliability by notifying the client quickly, which also conserves resources.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后框架可以使用上下文对象来跟踪请求执行时间。如果在任何阶段明显地请求不会在截止日期之前完成，系统可以自动取消请求。通过快速通知客户端，还可以提高服务的可靠性，这也节省了资源。
- en: A good framework should also enable you to work with dependencies of the RPC
    backend—for example, another backend that’s responsible for storing logs. You
    might register these as either soft or hard dependencies, and the framework can
    constantly monitor their availability. When it detects the unavailability of a
    hard dependency, the framework can stop the service, report itself as unavailable,
    and automatically redirect traffic to other instances.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的框架还应该使您能够处理RPC后端的依赖关系，例如负责存储日志的另一个后端。您可以将这些注册为软依赖或硬依赖，框架可以不断监视它们的可用性。当它检测到硬依赖不可用时，框架可以停止服务，报告自身不可用，并自动将流量重定向到其他实例。
- en: Sooner or later, overload, network issues, or some other issue will result in
    a dependency being unavailable. In many cases, it would be reasonable to retry
    the request, but implement retries carefully in order to avoid a *cascading failure*
    (akin to falling dominoes).^([1](ch12.html#ch12fn1)) The most common solution
    is to retry with an *exponential backoff*.^([2](ch12.html#ch12fn2)) A good framework
    should provide support for such logic, rather than requiring the developer to
    implement the logic for every RPC call.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 迟早，过载、网络问题或其他问题将导致依赖不可用。在许多情况下，重试请求是合理的，但要小心实施重试，以避免*级联故障*（类似于多米诺骨牌的倒塌）。^([1](ch12.html#ch12fn1))最常见的解决方案是使用*指数退避*。^([2](ch12.html#ch12fn2))一个好的框架应该提供对这样的逻辑的支持，而不是要求开发人员为每个RPC调用实现逻辑。
- en: A framework that gracefully handles unavailable dependencies and redirects traffic
    to avoid overloading the service or its dependencies naturally improves the reliability
    of both the service itself and the entire ecosystem. These improvements require
    minimal involvement from developers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优雅处理不可用依赖并重定向流量以避免过载服务或其依赖的框架自然地提高了服务本身和整个生态系统的可靠性。这些改进需要开发人员的最少参与。
- en: Example code snippets
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例代码片段
- en: Examples [12-1](#example_onetwo_onedot_initial_type_defi) through [12-3](#example_onetwo_threedot_example_logging)
    demonstrate the RPC backend developer’s perspective of working with a security-
    or reliability-focused framework. The examples are in Go and use [Google Protocol
    Buffers](https://oreil.ly/yzES2).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 示例[12-1](#example_onetwo_onedot_initial_type_defi)到[12-3](#example_onetwo_threedot_example_logging)演示了RPC后端开发人员与安全或可靠性框架合作的视角。这些示例使用Go并使用[Google
    Protocol Buffers](https://oreil.ly/yzES2)。
- en: Example 12-1\. Initial type definitions (the before stage of an interceptor
    can modify the context; for example, the authentication interceptor can add verified
    information about the caller)
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 12-1示例。初始类型定义（拦截器的前阶段可以修改上下文；例如，身份验证拦截器可以添加有关调用者的验证信息）
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Example 12-2\. Example authorization interceptor that allows only requests from
    whitelisted users
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 12-2示例。示例授权拦截器，只允许来自白名单用户的请求
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example 12-3\. Example logging interceptor that logs every incoming request
    (before stage) and then logs all the failed requests with their status (after
    stage); WithAttemptCount is a framework-provided RPC call option that implements
    exponential backoff
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 12-3示例。示例日志拦截器，记录每个传入请求（阶段前）然后记录所有失败的请求及其状态（阶段后）；WithAttemptCount是一个由框架提供的RPC调用选项，实现指数退避
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Common Security Vulnerabilities
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见安全漏洞
- en: In large codebases, a handful of classes account for the majority of security
    vulnerabilities, despite ongoing efforts to educate developers and introduce code
    review. OWASP and SANS publish lists of common vulnerability classes. [Table 12-1](#top_onezero_most_common_vulnerability_r)
    lists the 10 most common vulnerability risks according to [OWASP](https://oreil.ly/bUZq8),
    along with some potential approaches to mitigate each at a framework level.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型代码库中，少数类占据了大部分安全漏洞，尽管不断努力教育开发人员并引入代码审查。OWASP和SANS发布了常见漏洞类别的列表。[表12-1](#top_onezero_most_common_vulnerability_r)列出了根据[OWASP](https://oreil.ly/bUZq8)列出的前10个最常见的漏洞风险，以及在框架级别上缓解每个漏洞的一些潜在方法。
- en: Table 12-1\. Top 10 most common vulnerability risks according to OWASP
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表12-1。根据OWASP列出的前10个最常见的漏洞风险
- en: '| OWASP top 10 vulnerability | Framework hardening measures |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| OWASP前10大漏洞 | 框架加固措施 |'
- en: '| --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [SQL] Injection | `TrustedSQLString` (see the following section). |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| [SQL]注入 | `TrustedSQLString`（请参阅下一节）。|'
- en: '| Broken authentication | Require authentication using a well-tested mechanism
    like OAuth before routing a request to the application. (See [“Example: Framework
    for RPC Backends”](#example_framework_for_rpc_backends).) |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 损坏的身份验证 | 在将请求路由到应用程序之前，要求使用像OAuth这样经过充分测试的机制进行身份验证。（参见[“示例：RPC后端框架”](#example_framework_for_rpc_backends)。）|'
- en: '| Sensitive data exposure | Use distinct types (instead of strings) to store
    and handle sensitive data like credit card numbers. This approach can restrict
    serialization to prevent leaks and enforce appropriate encryption. Frameworks
    can additionally enforce transparent in-transit protection, like HTTPS with LetsEncrypt.
    Cryptographic APIs such as [Tink](https://oreil.ly/38Vpd) can encourage appropriate
    secret storage, such as loading keys from a cloud key management system instead
    of a configuration file. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 敏感数据泄露 | 使用不同的类型（而不是字符串）来存储和处理信用卡号等敏感数据。这种方法可以限制序列化以防止泄漏并强制适当的加密。框架还可以强制执行透明的传输保护，如使用LetsEncrypt的HTTPS。加密API，如[Tink](https://oreil.ly/38Vpd)，可以鼓励适当的秘密存储，例如从云密钥管理系统加载密钥，而不是从配置文件加载。|'
- en: '| XML external entities (XXE) | Use an XML parser without XXE enabled; ensure
    this risky feature is disabled in libraries that support it.^([a](ch12.html#ch12fn3))
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| XML外部实体（XXE）|使用未启用XXE的XML解析器；确保支持它的库中禁用这个风险特性。^([a](ch12.html#ch12fn3))|'
- en: '| Broken access control | This is a tricky problem, because it’s often application-specific.
    Use a framework that requires every request handler or RPC to have well-defined
    access control restrictions. If possible, pass end-user credentials to the backend,
    and enforce an access control policy in the backend. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|破损的访问控制|这是一个棘手的问题，因为它通常是特定于应用程序的。使用一个要求每个请求处理程序或RPC具有明确定义的访问控制限制的框架。如果可能的话，将最终用户凭据传递到后端，并在后端强制执行访问控制策略。|'
- en: '| Security misconfiguration | Use a technology stack that provides secure configurations
    by default and restricts or doesn’t allow risky configuration options. For example,
    use a web framework that does not print error information in production. Use a
    single flag to enable all debug features, and set up your deployment and monitoring
    infrastructure to ensure this flag is not enabled for public users. The `environment`
    flag in Rails is one example of this approach. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|安全配置错误|使用默认提供安全配置并限制或不允许风险配置选项的技术堆栈。例如，使用一个在生产中不打印错误信息的Web框架。使用一个标志来启用所有调试功能，并设置部署和监控基础设施以确保这个标志不对公共用户启用。Rails中的`environment`标志就是这种方法的一个例子。|'
- en: '| Cross-site scripting (XSS) | Use an XSS-hardened template system (see [“Preventing
    XSS: SafeHtml”](#preventing_xss_safehtml)). |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '|跨站脚本（XSS）|使用XSS强化的模板系统（参见[“预防XSS：SafeHtml”](#preventing_xss_safehtml)）。|'
- en: '| Insecure deserialization | Use deserialization libraries that are built for
    handling untrusted inputs, such as [Protocol Buffers](https://oreil.ly/hlezU).
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|不安全的反序列化|使用专为处理不受信任输入而构建的反序列化库，例如[Protocol Buffers](https://oreil.ly/hlezU)。|'
- en: '| Using components with known vulnerabilities | Choose libraries that are popular
    and actively maintained. Do not pick components that have a history of unfixed
    or slowly fixed security issues. Also see [“Lessons for Evaluating and Building
    Frameworks”](#lessons_for_evaluating_and_building_fra). |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|使用已知漏洞的组件|选择受欢迎且积极维护的库。不要选择有未修复或缓慢修复安全问题历史的组件。另请参见[“评估和构建框架的教训”](#lessons_for_evaluating_and_building_fra)。|'
- en: '| Insufficient logging & monitoring | Instead of relying on ad hoc logging,
    log and monitor requests and other events as appropriate in a low-level library.
    See the logging interceptor described in the previous section for an example.
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|日志记录和监控不足|不要依赖于临时日志记录，适当地记录和监控请求和其他事件在低级库中。有关示例，请参见前一节中描述的日志拦截器。|'
- en: '| ^([a](ch12.html#ch12fn3-marker)) See the [XXE Prevention Cheat Sheet](https://oreil.ly/AOYev)
    for more information. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|^([a](ch12.html#ch12fn3-marker))有关更多信息，请参见[XXE预防备忘单](https://oreil.ly/AOYev)。|'
- en: 'SQL Injection Vulnerabilities: TrustedSqlString'
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL注入漏洞：TrustedSqlString
- en: '[SQL injection](https://xkcd.com/327) is a common class of security vulnerability.
    When untrustworthy string fragments are inserted into a SQL query, attackers can
    potentially inject database commands. The following is a simple password reset
    web form:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQL注入](https://xkcd.com/327)是一种常见的安全漏洞类别。当不可信的字符串片段被插入到SQL查询中时，攻击者可能会注入数据库命令。以下是一个简单的密码重置网页表单：'
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, the user’s request is directed to a backend with an unguessable
    `reset_token` specific to their account. However, because of the string concatenation,
    a malicious user could craft a custom `reset_token` with extra SQL commands (such
    as `' or username='admin)` and *inject* this token into the backend. The result
    could reset the password hash of a different user—in this case, the admin account.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，用户的请求被定向到一个具有与其帐户特定的不可猜测的`reset_token`的后端。然而，由于字符串连接，恶意用户可以制作一个带有额外SQL命令（例如`'
    or username='admin`）的自定义`reset_token`并将其*注入*到后端。结果可能会重置不同用户的密码哈希—在这种情况下是管理员帐户。
- en: 'SQL injection vulnerabilities can be harder to spot in more complicated codebases.
    The database engine can help you prevent SQL injection vulnerabilities by providing
    bound parameters and prepared statements:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的代码库中，SQL注入漏洞可能更难以发现。数据库引擎可以通过提供绑定参数和预编译语句来帮助您防止SQL注入漏洞：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, merely establishing a guideline to use prepared statements does not
    result in a scalable security process. You would need to educate every developer
    about this rule, and security reviewers would have to review all application code
    to ensure consistent use of prepared statements. Instead, you can design the database
    API so that mixing user input and SQL becomes impossible by design. For example,
    you can create a separate type called `TrustedSqlString` and enforce by construction
    that all SQL query strings are created from developer-controlled input. In Go,
    you could implement the type as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅建立一个使用预编译语句的准则并不能导致可扩展的安全流程。您需要教育每个开发人员遵守这个规则，并且安全审查人员需要审查所有应用程序代码，以确保一致使用预编译语句。相反，您可以设计数据库API，使用户输入和SQL的混合在设计上变得不可能。例如，您可以创建一个名为`TrustedSqlString`的单独类型，并通过构造强制执行所有SQL查询字符串都是由开发人员控制的输入创建的。在Go中，您可以实现该类型如下：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This implementation guarantees by construction that the contents of `q.sql`
    are entirely concatenated from string literals present in your source code, and
    the user cannot provide string literals. To enforce this contract at scale, you
    can use a language-specific mechanism to make sure `AppendLiteral` is called only
    with string literals. For example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 该实现通过构造保证了`q.sql`的内容完全是从您的源代码中存在的字符串字面量连接而成的，用户无法提供字符串字面量。为了在规模上强制执行这个合同，您可以使用一种特定于语言的机制，确保`AppendLiteral`只能与字符串字面量一起调用。例如：
- en: In Go
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go
- en: Use a package-private type alias (`stringLiteral`). Code outside the package
    cannot refer to this alias; however, string literals are implicitly converted
    to this type.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包私有类型别名（`stringLiteral`）。包外的代码不能引用此别名；但是，字符串字面量会被隐式转换为这种类型。
- en: In Java
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java
- en: Use the [Error Prone](https://errorprone.info) code checker, which provides
    a `@CompileTimeConstant` annotation for parameters.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[Error Prone](https://errorprone.info)代码检查器，它为参数提供了`@CompileTimeConstant`注释。
- en: In C++
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中
- en: Use a template constructor that depends on each character value in the string.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用依赖于字符串中每个字符值的模板构造函数。
- en: You can find similar mechanisms for other languages.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在其他语言中找到类似的机制。
- en: You can’t build some features—like a data analytics application that by design
    runs arbitrary SQL queries provided by the user who owns the data—using just compile-time
    constants. To handle complicated use cases, at Google we allow a way to bypass
    the type restrictions with approval from a security engineer. For example, our
    database API has a separate package, `unsafequery`, that exports a distinct `unsafequery.String`
    type, which can be constructed from arbitrary strings and appended to SQL queries.
    Only a small fraction of our queries use the unchecked APIs. The burden of reviewing
    new uses of SQL queries that are not inherently safe and other restricted API
    patterns is handled by one (rotating) engineer on a part-time basis, for hundreds
    to thousands of active developers. See [“Lessons for Evaluating and Building Frameworks”](#lessons_for_evaluating_and_building_fra)
    for other benefits of reviewed exemptions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法仅使用编译时常量构建某些功能，比如设计为由拥有数据的用户提供任意SQL查询的数据分析应用程序。为了处理复杂的用例，在Google，我们允许通过安全工程师的批准绕过类型限制的方法。例如，我们的数据库API有一个单独的包`unsafequery`，它导出一个独特的`unsafequery.String`类型，可以从任意字符串构造并附加到SQL查询中。只有很小一部分查询使用了未经检查的API。对于数百到数千名活跃开发人员，审核不安全的SQL查询的新用途和其他受限API模式的负担由一名（轮换的）工程师兼职处理。参见[“评估和构建框架的教训”](#lessons_for_evaluating_and_building_fra)以了解审核豁免的其他好处。
- en: 'Preventing XSS: SafeHtml'
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止XSS：SafeHtml
- en: The type-based safety approach we described in the previous section is not specific
    to SQL injection. Google uses a more complex version of the same design to reduce
    cross-site scripting vulnerabilities in web applications.^([3](ch12.html#ch12fn4))
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一节中描述的基于类型的安全方法并不特定于SQL注入。Google使用更复杂的相同设计的版本来减少Web应用程序中的跨站脚本漏洞。^([3](ch12.html#ch12fn4))
- en: At their core, XSS vulnerabilities occur when a web application renders untrustworthy
    input without appropriate sanitization. For example, an application might interpolate
    an attacker-controlled `$address` value into an HTML snippet such as `<div>$address</div>`,
    which is shown to another user. An attacker can then set `$address` to `<script>exfiltrate_user_data();</script>`
    and execute arbitrary code in the context of another user’s page.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在核心上，XSS漏洞发生在Web应用程序在没有适当清理的情况下呈现不可信的输入时。例如，一个应用程序可能会将一个受攻击者控制的`$address`值插入到HTML片段中，如`<div>$address</div>`，然后显示给另一个用户。攻击者可以将`$address`设置为`<script>exfiltrate_user_data();</script>`并在另一个用户页面的上下文中执行任意代码。
- en: HTML does not have the equivalent of binding query parameters. Instead, untrustworthy
    values must be appropriately sanitized or escaped before they are inserted into
    an HTML page. Furthermore, different HTML attributes and elements have different
    semantics, so application developers have to treat values differently depending
    on the context in which they appear. For example, an attacker-controlled URL can
    cause code execution with the `javascript:` scheme.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: HTML没有绑定查询参数的等价物。相反，不可信的值必须在插入到HTML页面之前得到适当的清理或转义。此外，不同的HTML属性和元素具有不同的语义，因此应用程序开发人员必须根据它们出现的上下文来不同对待值。例如，攻击者控制的URL可以使用`javascript:`方案来执行代码。
- en: A type system can capture these requirements by introducing different types
    for values meant for different contexts—for example, `SafeHtml` to represent the
    contents of an HTML element, and `SafeUrl` for URLs that are safe to navigate
    to. Each of the types is a (immutable) wrapper around a string; the contracts
    are upheld by the constructors available for each type. The constructors make
    up the trusted codebase that’s responsible for ensuring the security properties
    of the application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类型系统可以通过为不同上下文中的值引入不同的类型来捕获这些要求，例如，`SafeHtml`用于表示HTML元素的内容，`SafeUrl`用于安全导航到的URL。每种类型都是一个（不可变的）字符串包装器；构造函数负责维护每种类型的合同。构造函数构成了负责确保应用程序安全属性的受信任代码库。
- en: 'Google has created different builder libraries for different use cases. Individual
    HTML elements can be constructed with builder methods that require the correct
    type for each attribute value, and `SafeHtml` for the element contents. The template
    system with strict contextual escaping guarantees the `SafeHtml` contract for
    more complicated HTML. That system does the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Google为不同的用例创建了不同的构建器库。可以使用构建器方法构造单个HTML元素，该方法要求每个属性值都具有正确的类型，并且对于元素内容使用`SafeHtml`。具有严格上下文转义的模板系统可以保证更复杂的HTML的`SafeHtml`合同。该系统执行以下操作：
- en: Parses the partial HTML in the template
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析模板中的部分HTML
- en: Determines the context for each substitution point
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定每个替换点的上下文
- en: Either requires the program to pass in a value of the correct type, or correctly
    escapes or sanitizes untrusted string values
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要么要求程序传递正确类型的值，要么正确转义或清理不受信任的字符串值
- en: 'For example, if you have the following Closure Template:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您有以下Closure模板：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'trying to use a string value for `$url` will fail:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用`$url`的字符串值将失败：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Instead, the developer has to provide a `TrustedResourceUrl` value, e.g.:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，开发人员必须提供`TrustedResourceUrl`值，例如：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If HTML originates from an untrusted source, you won’t want to embed it into
    your application’s web UI, since doing so would result in an easily exploitable
    XSS vulnerability. Instead, you can use an HTML sanitizer that parses the HTML
    and performs runtime checks to determine that each value meets its contract. The
    sanitizer removes elements that do not meet their contract, or elements for which
    it is impossible to check the contract at runtime. You can also use a sanitizer
    to interoperate with other systems that don’t use safe types, because many HTML
    fragments are unchanged by sanitization.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果HTML来自不受信任的来源，您不希望将其嵌入到应用程序的Web UI中，因为这样做会导致易受攻击的XSS漏洞。相反，您可以使用HTML清理器解析HTML并执行运行时检查，以确定每个值是否符合其合同。清理器会删除不符合其合同的元素，或者无法在运行时检查合同的元素。您还可以使用清理器与不使用安全类型的其他系统进行交互，因为许多HTML片段在清理过程中保持不变。
- en: Different HTML construction libraries target different developer productivity
    and code readability tradeoffs. However, they all enforce the same contract and
    should be equally trustworthy (apart from any bugs in their trusted implementations).
    In fact, to reduce the maintenance burden at Google, we code-generate the builder
    functions in various languages from a declarative configuration file. This file
    lists HTML elements and the required contracts for the values of each attribute.
    Some of our HTML sanitizers and template systems use the same configuration file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的HTML构建库针对不同的开发人员生产力和代码可读性权衡。但是，它们都强制执行相同的合同，并且应该同样值得信赖（除了它们受信任的实现中的任何错误）。实际上，为了减少谷歌的维护负担，我们从声明性配置文件中为各种语言代码生成构建器函数。该文件列出了HTML元素和每个属性值的所需合同。我们的一些HTML清理器和模板系统使用相同的配置文件。
- en: A mature open source implementation of safe types for HTML is available in [Closure
    Templates](https://oreil.ly/6x6Yb), and there is an effort underway to introduce
    [type-based security](https://oreil.ly/VrN4w) as a web standard.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Closure Templates](https://oreil.ly/6x6Yb)中提供了成熟的开源安全类型实现，目前正在进行引入[基于类型的安全性](https://oreil.ly/VrN4w)的工作，作为Web标准。
- en: Lessons for Evaluating and Building Frameworks
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估和构建框架的教训
- en: The previous sections discussed how to structure libraries to establish security
    and reliability properties. However, you can’t elegantly express all such properties
    with API design, and in some cases you can’t even change the API easily—for example,
    when interacting with the standardized DOM API exposed by a web browser.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前几节讨论了如何构建库以建立安全性和可靠性属性。但是，并非所有这样的属性都可以通过API设计优雅地表达，有些情况下甚至无法轻松更改API，例如与Web浏览器公开的标准化DOM
    API交互时。
- en: Instead, you can introduce compile-time checks to prevent developers from using
    risky APIs. Plug-ins for popular compilers, such as [Error Prone](https://errorprone.info)
    for Java and [Tsetse](https://tsetse.info) for TypeScript, can prohibit risky
    code patterns.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可以引入编译时检查，以防止开发人员使用风险API。流行编译器的插件，如Java的[Error Prone](https://errorprone.info)和TypeScript的[Tsetse](https://tsetse.info)，可以禁止危险的代码模式。
- en: Our experience has shown that compiler errors provide immediate and actionable
    feedback. Tools running on an opt-in basis (like linters) or at code review time
    provide feedback much later. By the time code is sent for review, developers usually
    have a finished, working unit of code. Learning that you need to perform some
    rearchitecting in order to use a strictly typed API that late in the development
    process can be frustrating.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的经验表明，编译器错误提供了即时和可操作的反馈。在代码审查时运行的工具（如linter）或在代码审查时提供的反馈要晚得多。到代码发送进行审查时，开发人员通常已经有了一个完成的、可工作的代码单元。在开发过程的这么晚阶段得知需要进行一些重新架构才能使用严格类型的API可能会令人沮丧。
- en: It’s much easier to equip developers with compiler errors or faster feedback
    mechanisms like IDE plug-ins that underline problematic code. Typically, developers
    iterate through compilation issues quickly, and already have to fix other compiler
    diagnostics like trivial misspellings and syntactic errors. Because the developers
    are already working on the specific lines of code affected, they have full context,
    so making changes is easier—for example, changing the type of a string to `SafeHtml`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 向开发人员提供编译器错误或更快的反馈机制（如IDE插件，可以标出有问题的代码）要容易得多。通常，开发人员会快速解决编译问题，并且已经必须修复其他编译器诊断，如拼写错误和语法错误。因为开发人员已经在处理受影响的特定代码行，他们有完整的上下文，所以进行更改更容易，例如将字符串的类型更改为`SafeHtml`。
- en: You can improve the developer experience even further by suggesting automatic
    fixes that work as a starting point for a safe solution. For example, when you
    detect a call to a SQL query function, you can automatically insert a call to
    `TrustedSqlBuilder.fromConstant` with the query parameter. Even if the resulting
    code does not quite compile (perhaps because the query is a string variable and
    not a constant), developers know what to do, and don’t need to bother with the
    mechanical details of the API by finding the right function, adding the correct
    import declarations, and so on.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过建议自动修复，甚至可以进一步改善开发人员的体验，这些自动修复可以作为安全解决方案的起点。例如，当检测到对SQL查询函数的调用时，可以自动插入对`TrustedSqlBuilder.fromConstant`的调用，其中包含查询参数。即使生成的代码不能完全编译（也许是因为查询是字符串变量而不是常量），开发人员也知道该怎么做，无需通过找到正确的函数、添加正确的导入声明等来烦恼API的机械细节。
- en: In our experience, as long as the feedback cycle is quick, and fixing each pattern
    is relatively easy, developers embrace inherently safe APIs much more readily—even
    when we can’t prove that their code was insecure, or when they do a good job of
    writing secure code using the unsafe APIs. Our experience contrasts with existing
    research literature, which focuses on reducing the false-positive and false-negative
    rates.^([4](ch12.html#ch12fn5))
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的经验，只要反馈周期快，修复每个模式相对容易，开发人员就会更愿意接受固有安全的API，即使我们无法证明他们的代码是不安全的，或者他们在使用不安全的API编写安全代码时做得很好。我们的经验与现有的研究文献形成对比，后者侧重于降低误报和漏报率。([4](ch12.html#ch12fn5))
- en: We’ve found that focusing on those rates often results in complicated checkers
    that take much longer to produce findings. For example, a check might have to
    analyze whole-program data flows across a complicated application. It’s often
    difficult to explain how to remove the issue that the static analysis detects
    to developers, as the workings of the checker are much harder to explain than
    a simple syntactic property. Understanding a finding takes as much work as tracking
    down a bug in GDB (the GNU Debugger). On the other hand, fixing a type safety
    error at compile time while writing new code is usually not much harder than fixing
    a trivial type error.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现，专注于这些速率通常会导致复杂的检查器，需要更长时间才能发现问题。例如，一个检查可能需要分析复杂应用程序中的整个程序数据流。通常很难解释如何从静态分析检测到的问题中删除问题，因为检查器的工作方式比简单的语法属性要难得多。理解一个发现需要和在GDB（GNU调试器）中追踪错误一样多的工作。另一方面，在编写新代码时在编译时修复类型安全错误通常并不比修复微不足道的类型错误困难得多。
- en: Simple, Safe, Reliable Libraries for Common Tasks
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单、安全、可靠的常见任务库
- en: 'Building a safe library that covers all possible use cases and handles each
    reliably can be very challenging. For example, an application developer working
    on an HTML templating system might write the following template:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个安全的库，涵盖所有可能的用例并可靠地处理每个用例可能非常具有挑战性。例如，一个在HTML模板系统上工作的应用程序开发人员可能会编写以下模板：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To be XSS-proof, if `username` is attacker-controlled, the template system
    must nest three different layers of context: a single-quoted string, inside JavaScript,
    inside an attribute in an HTML element. Creating a template system that can handle
    all possible combinations of corner cases is complicated, and using that system
    won’t be straightforward. In other domains, this issue can grow even more complex.
    For example, business needs might dictate complex rules about who can perform
    an action and who cannot. Unless your authorization library is as expressive (and
    as hard to analyze) as a general-purpose programming language, you might not be
    able to meet all developer needs.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止XSS攻击，如果“用户名”受攻击者控制，模板系统必须嵌套三种不同的上下文层：单引号字符串，JavaScript内部，HTML元素属性内部。创建一个可以处理所有可能的边缘情况组合的模板系统是复杂的，并且使用该系统不会简单。在其他领域，这个问题可能变得更加复杂。例如，业务需求可能会规定谁可以执行动作，谁不能。除非您的授权库像通用编程语言一样具有表达力（并且难以分析），您可能无法满足所有开发人员的需求。
- en: Instead, you can start with a simple, small library that covers only common
    use cases but is easier to use correctly. Simple libraries are easier to explain,
    document, and use. These qualities reduce developer friction and may help you
    convince other developers to adopt the secure-by-design library. In some cases,
    it might make sense to offer different libraries optimized for different use cases.
    For example, you might have both HTML templating systems for complicated pages
    and builder libraries for short snippets.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可以从一个简单的、小型的库开始，只涵盖常见用例，但更容易正确使用。简单的库更容易解释、文档化和使用。这些特性减少了开发人员的摩擦，并可能帮助您说服其他开发人员采用安全设计的库。在某些情况下，提供针对不同用例进行优化的不同库可能是有意义的。例如，您可能既有用于复杂页面的HTML模板系统，也有用于短片段的构建器库。
- en: 'You can accommodate other use cases with expert-reviewed access to an unconstrained,
    risky library that bypasses safety guarantees. If you see repeated similar requests
    for a use case, you can support that feature in the inherently safe library. As
    we observed in [“SQL Injection Vulnerabilities: TrustedSqlString”](#sql_injection_vulnerabilities_trustedsq),
    the review load is usually manageable.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过专家审查的方式满足其他用例，访问一个不受限制的、风险的库，绕过安全保证。如果您看到类似的重复请求，您可以在固有安全的库中支持该功能。正如我们在[“SQL注入漏洞：TrustedSqlString”](#sql_injection_vulnerabilities_trustedsq)中观察到的，审查负载通常是可以管理的。
- en: 'Because the volume of review requests is relatively small, security reviewers
    can look at the code in depth and suggest extensive improvements—and the reviews
    tend to be unique use cases, which keeps reviewers motivated and prevents mistakes
    due to repetition and fatigue. Exemptions also act as a feedback mechanism: If
    developers repeatedly need exemptions for a use case, library authors should consider
    building a library for that use case.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于审查请求的数量相对较少，安全审查人员可以深入查看代码并提出广泛的改进建议——审查往往是独特的用例，这保持了审查人员的积极性，并防止了由于重复和疲劳而导致的错误。豁免也作为一个反馈机制：如果开发人员反复需要豁免某个用例，库作者应该考虑为该用例构建一个库。
- en: Rollout Strategy
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推出策略
- en: Our experience has shown that using types for security properties is very useful
    for new code. In fact, applications created in one widely used Google-internal
    web framework, which was developed from the outset with safe types for HTML, have
    had far fewer reported XSS vulnerabilities (by two orders of magnitude) than applications
    written without safe types, despite careful code review. The few reported vulnerabilities
    were caused by components of the application that did not use safe types.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的经验表明，对安全属性使用类型对于新代码非常有用。事实上，使用安全类型的谷歌内部广泛使用的一个Web框架创建的应用程序，报告的XSS漏洞要少得多（少两个数量级）比没有使用安全类型编写的应用程序，尽管进行了仔细的代码审查。少数报告的漏洞是由于应用程序的组件没有使用安全类型造成的。
- en: It is more challenging to adapt existing code to use safe types. Even if you
    are starting with a brand new codebase, you need a strategy for migrating legacy
    code—you might discover new classes of security and reliability issues you want
    to protect against, or you might need to refine existing contracts.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将现有代码调整为使用安全类型更具挑战性。即使您从头开始创建一个全新的代码库，您也需要一个迁移遗留代码的策略——您可能会发现您想要保护的新的安全性和可靠性问题类别，或者您可能需要完善现有的合同。
- en: We have experimented with several strategies for refactoring existing code;
    we discuss our two most successful approaches in the following subsections. These
    strategies require that you are able to access and modify the entire source code
    of your application. Most of Google’s source code is stored in a single repository^([5](ch12.html#ch12fn6))
    with centralized processes for making, building, testing, and submitting changes.
    Code reviewers also enforce common readability and code organization standards,
    which reduces the complexity of changing an unfamiliar codebase. In other environments,
    large-scale refactorings can be more challenging. It helps to get broad agreement
    so every code owner is willing to accept changes to their source code, which contributes
    to the goal of building a culture of security and reliability.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经尝试了几种重构现有代码的策略；我们在下面的小节中讨论了我们最成功的两种方法。这些策略要求您能够访问和修改应用程序的整个源代码。Google的大部分源代码都存储在一个单一的存储库中^([5](ch12.html#ch12fn6))，并具有用于制作、构建、测试和提交更改的集中式流程。代码审查人员还会强制执行常见的可读性和代码组织标准，这减少了改变陌生代码库的复杂性。在其他环境中，大规模的重构可能更具挑战性。获得广泛的一致意见有助于每个代码所有者都愿意接受对他们源代码的更改，这有助于建立一个安全可靠的文化。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Google’s company-wide style guide incorporates the concept of language *readability:*
    a certification that an engineer understands Google’s best practices and coding
    style for a given language. Readability ensures a baseline for code quality. An
    engineer must either have readability in the language they’re working with, or
    get a code review from someone with readability. For particularly complex or critically
    important code, in-person code reviews can be the most productive and effective
    way to improve your codebase’s quality.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Google公司的全公司风格指南融入了语言*可读性*的概念：工程师理解给定语言的Google最佳实践和编码风格的认证。可读性确保了代码质量的基线。工程师必须在他们正在使用的语言中具有可读性，或者从具有可读性的人那里获得代码审查。对于特别复杂或至关重要的代码，面对面的代码审查可能是改进代码库质量最有效和高效的方式。
- en: Incremental rollout
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增量推出
- en: Fixing the entire codebase at once is often not feasible. Different components
    might be in different repositories, and authoring, reviewing, testing, and submitting
    a single change that touches multiple applications is often brittle and error-prone.
    Instead, at Google, we initially exempt legacy code from enforcement, and address
    existing unsafe API users one by one.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性修复整个代码库通常是不可行的。不同的组件可能在不同的存储库中，对多个应用程序进行更改的编写、审查、测试和提交通常是脆弱且容易出错的。相反，在Google，我们最初豁免遗留代码的执行，并逐个解决现有不安全API的使用者。
- en: For example, if you already have a database API with a `doQuery(String sql)`
    function, you could introduce an overload, `doQuery(TrustedSqlString sql)`, and
    restrict the unsafe version to existing callers. Using the Error Prone framework,
    you can add a `@RestrictedApi(whitelistAnnotation={LegacyUnsafeStringQueryAllowed.class})`
    annotation and add the `@LegacyUnsafeStringQueryAllowed` annotation to all existing
    callers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您已经有一个带有`doQuery(String sql)`函数的数据库API，您可以引入一个重载，`doQuery(TrustedSqlString
    sql)`，并将不安全版本限制为现有的调用者。使用Error Prone框架，您可以添加一个`@RestrictedApi(whitelistAnnotation={LegacyUnsafeStringQueryAllowed.class})`注解，并将`@LegacyUnsafeStringQueryAllowed`注解添加到所有现有的调用者。
- en: Then, by introducing *Git hooks* that analyze every commit, you can prevent
    new code from using the string-based overload. Alternatively, you can restrict
    the visibility of the unsafe API—for example, [Bazel visibility whitelists](https://oreil.ly/ajmrr)
    would allow a user to call the API only if a security team member approves the
    pull request (PR). If your codebase is under active development, it will organically
    move toward the safe API. After you reach the point at which only a small fraction
    of callers use the deprecated string-based API, you can manually clean up the
    remainder. At that point, your code will be immune to SQL injection by design.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过引入*Git hooks*来分析每个提交，您可以防止新代码使用基于字符串的过载。或者，您可以限制不安全API的可见性——例如，[Bazel可见性白名单](https://oreil.ly/ajmrr)将允许用户仅在安全团队成员批准拉取请求（PR）时调用API。如果您的代码库正在积极开发，它将自然地向安全API迁移。在达到只有少部分调用者使用已弃用的基于字符串的API的时候，您可以手动清理剩余部分。在那时，您的代码将因设计而免疫SQL注入。
- en: Legacy conversions
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遗留转换
- en: It is also often worthwhile to consolidate all of your exemption mechanisms
    into a single function that is obvious in the source code being read. For example,
    you can create a function that takes an arbitrary string and returns a safe type.
    You can use this function to replace all calls to string-typed APIs with more
    precisely typed calls. Typically, there will be a lot fewer types than functions
    consuming them. Instead of restricting and monitoring the removal of many legacy
    APIs (for example, every DOM API that consumes a URL), you have to remove only
    a single legacy conversion function per type.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有的豁免机制整合到一个在源代码中明显的函数中通常也是值得的。例如，您可以创建一个函数，它接受任意字符串并返回一个安全类型。您可以使用这个函数来替换所有对字符串类型的API的调用，使其更精确地调用。通常，类型会比使用它们的函数少得多。与限制和监控许多遗留API的移除（例如，每个消耗URL的DOM
    API）不同，您只需要删除每种类型的一个遗留转换函数。
- en: Simplicity Leads to Secure and Reliable Code
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单导致安全可靠的代码
- en: Whenever practical, try to keep your code clean and simple. There are a number
    of publications on this topic,^([6](ch12.html#ch12fn7)) so here we focus on two
    lightweight stories that were published in the [Google Testing Blog](https://testing.googleblog.com).
    Both stories highlight strategies for avoiding quickly increasing codebase complexity.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际情况下，尽量保持代码简洁和简单。关于这个主题有很多出版物，^([6](ch12.html#ch12fn7))所以这里我们专注于两个轻量级的故事，这些故事发表在[Google测试博客](https://testing.googleblog.com)上。这两个故事都强调了避免快速增加代码库复杂性的策略。
- en: Avoid Multilevel Nesting
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免多级嵌套
- en: Multilevel nesting is a common anti-pattern that can lead to simple mistakes.
    If the error is in the most common code path, it will likely be captured by the
    unit tests. However, unit tests don’t always check error handling paths in multilevel
    nested code. The error might result in decreased reliability (for example, if
    the service crashes when it mishandles an error) or a security vulnerability (like
    a mishandled authorization check error).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 多层嵌套是一种常见的反模式，可能导致简单的错误。如果错误出现在最常见的代码路径中，它很可能会被单元测试捕获。但是，单元测试并不总是检查多层嵌套代码中的错误处理路径。错误可能导致可靠性降低（例如，如果服务在错误处理不当时崩溃）或安全漏洞（如错误处理授权检查错误）。
- en: Can you spot a bug in the code in [Figure 12-2](#errors_are_often_harder_to_spot_in_code)?
    The two versions are equivalent.^([7](ch12.html#ch12fn8))
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您能在[图12-2](#errors_are_often_harder_to_spot_in_code)的代码中发现错误吗？这两个版本是等价的。^([7](ch12.html#ch12fn8))
- en: '![Errors are often harder to spot in code with multiple levels of nesting](assets/bsrs_1202.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![在多层嵌套代码中，错误通常更难发现](assets/bsrs_1202.png)'
- en: Figure 12-2\. Errors are often harder to spot in code with multiple levels of
    nesting
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-2。在多层嵌套代码中，错误通常更难发现
- en: The “wrong encoding” and “unauthorized” errors are swapped. This bug is easier
    to see in the refactored version because the checks occur as soon as the errors
    are handled.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: “错误编码”和“未经授权”的错误被交换了。在重构版本中更容易看到这个错误，因为检查发生在处理错误时。
- en: Eliminate YAGNI Smells
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消除YAGNI气味
- en: Sometimes developers overengineer solutions by adding functionality that may
    be useful in the future, “just in case.” This goes against the [YAGNI (You Aren’t
    Gonna Need It) principle](https://oreil.ly/K4Oan), which recommends implementing
    only the code that you need. YAGNI code adds unnecessary complexity because it
    needs to be documented, tested, and maintained. Consider the following example:^([8](ch12.html#ch12fn9))
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，开发人员通过添加可能在将来有用的功能“以防万一”来过度设计解决方案。这违反了[YAGNI（你不会需要它）原则](https://oreil.ly/K4Oan)，该原则建议仅实现您需要的代码。YAGNI代码会增加不必要的复杂性，因为它需要进行文档化、测试和维护。考虑以下示例：^([8](ch12.html#ch12fn9))
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `Human::Sleep` code must handle the case when `hibernate` is `true`, even
    though all callers should always pass `false`. In addition, callers must handle
    the returned status, even though that status should always be `OK`. Instead, until
    you need classes other than `Human`, this code can be simplified to the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Human::Sleep`代码必须处理`hibernate`为`true`的情况，即使所有调用者应始终传递`false`。此外，调用者必须处理返回的状态，即使该状态应始终为`OK`。因此，在您需要除`Human`之外的其他类之前，此代码可以简化为以下内容：'
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the developer’s assumptions about possible requirements for future functionality
    are actually true, they can easily add that functionality later by following the
    principle of *incremental development and design*. In our example, it will be
    easier to create a `Mammal` interface with a better common API when we generalize
    based on several existing classes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发人员对未来功能的可能需求做出的假设实际上是正确的，他们可以通过遵循*增量开发和设计*原则轻松地稍后添加该功能。在我们的例子中，基于几个现有类进行概括时，将更容易创建具有更好公共API的`Mammal`接口。
- en: To summarize, avoiding YAGNI code leads to improved reliability, and simpler
    code leads to fewer security bugs, fewer opportunities to make mistakes, and less
    developer time spent maintaining unused code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，避免YAGNI代码会提高可靠性，简化代码会减少安全漏洞，减少出错的机会，并减少开发人员维护未使用代码的时间。
- en: Repay Technical Debt
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 偿还技术债务
- en: It is a common practice for developers to mark places that require further attention
    with TODO or FIXME annotations. In the short term, this habit can accelerate the
    delivery velocity for the most critical functionality, and allow a team to meet
    early deadlines—but it also incurs *technical debt*. Still, it’s not necessarily
    a bad practice, as long as you have a clear process (and allocate time) for repaying
    such debt.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员通常会使用TODO或FIXME注释标记需要进一步关注的地方。短期内，这种习惯可以加快最关键功能的交付速度，并允许团队满足早期的截止日期，但也会产生*技术债务*。不过，只要您有清晰的流程（并分配时间）来偿还这样的债务，这并不一定是一种坏习惯。
- en: Technical debt can include the erroneous handling of exceptional situations
    and the introduction of unnecessarily complex logic into the code (often written
    to work around other areas of technical debt). Either behavior can introduce security
    vulnerabilities and reliability issues that are rarely detected during testing
    (because of insufficient coverage of rare cases), and which consequently become
    part of the production environment.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 技术债务可能包括对异常情况的错误处理以及将不必要的复杂逻辑引入代码（通常编写以解决其他技术债务领域的问题）。任何一种行为都可能引入安全漏洞和可靠性问题，这些问题在测试期间很少被检测到（因为罕见情况的覆盖不足），因此成为生产环境的一部分。
- en: 'You can deal with technical debt in many ways. For example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以许多方式处理技术债务。例如：
- en: Keeping dashboards with code health metrics. These can range from simple dashboards
    that show test coverage or the number and average age of TODOs, to more sophisticated
    dashboards including metrics like [*cyclomatic complexity*](https://oreil.ly/pXJBL)
    or [*maintainability index*](https://oreil.ly/_N25V).
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持具有代码健康度指标的仪表板。这些可以是简单的仪表板，显示测试覆盖率或TODO的数量和平均年龄，也可以是包括[*圈复杂度*](https://oreil.ly/pXJBL)或[*可维护性指数*](https://oreil.ly/_N25V)等指标的更复杂的仪表板。
- en: Using analysis tools like linters to detect common code defects such as dead
    code, unnecessary dependencies, or language-specific gotchas. Often, such tools
    can also automatically fix your code.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用诸如linter之类的分析工具来检测常见的代码缺陷，例如死代码、不必要的依赖关系或特定于语言的陷阱。通常，这些工具还可以自动修复您的代码。
- en: Creating notifications when code health metrics drop below predefined thresholds
    or when the number of automatically detected issues is too high.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当代码健康度指标下降到预定义阈值以下或自动检测到的问题数量过高时创建通知。
- en: In addition, it’s important to maintain a team culture that embraces and focuses
    on good code health. Leadership can support this culture in many ways. For example,
    you can schedule regular *fixit* weeks during which developers focus on improving
    code health and fixing outstanding bugs rather than adding new functionality.
    You can also support continuous contributions to code health within the team with
    bonuses or other forms of recognition.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，重要的是要保持一个拥抱并专注于良好代码健康的团队文化。领导可以通过多种方式支持这种文化。例如，您可以安排定期的*修复*周，在这些周内，开发人员专注于改善代码健康和修复未解决的错误，而不是添加新功能。您还可以通过奖金或其他形式的认可来支持团队内对代码健康的持续贡献。
- en: Refactoring
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构
- en: '*Refactoring* is the most effective way to keep a codebase clean and simple.
    Even a healthy codebase occasionally needs to be refactored when you extend the
    existing feature set, change the backend, and so on.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*重构*是保持代码库清洁和简单的最有效方法。即使健康的代码库偶尔也需要在扩展现有功能集、更改后端等情况下进行重构。'
- en: Refactoring is particularly useful when working with old, inherited codebases.
    The first step of refactoring is measuring code coverage and increasing that coverage
    to a sufficient level.^([9](ch12.html#ch12fn10)) In general, the higher the coverage,
    the higher your confidence in the safety of refactoring. Unfortunately, even 100%
    test coverage can’t guarantee success, because the tests may not be meaningful.
    You can address this issue with other kinds of testing, such as *fuzzing,* which
    is covered in [Chapter 13](ch13.html#onethree_testing_code).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 重构在处理旧的、继承的代码库时特别有用。重构的第一步是测量代码覆盖率，并将覆盖率提高到足够的水平。^([9](ch12.html#ch12fn10))一般来说，覆盖率越高，对重构的安全性的信心就越高。不幸的是，即使测试覆盖率达到100%，也不能保证成功，因为测试可能没有意义。您可以通过其他类型的测试来解决这个问题，例如*fuzzing*，这在[第13章](ch13.html#onethree_testing_code)中有介绍。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Regardless of the reasons behind refactoring, you should always follow one
    golden rule: *never mix refactoring and functional changes in a single commit
    to the code repository*. Refactoring changes are typically significant and can
    be difficult to understand. If a commit also includes functional changes, there’s
    a higher risk that an author or reviewer might overlook bugs.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 无论重构背后的原因是什么，您都应始终遵循一个黄金法则：*永远不要在单个提交到代码存储库中混合重构和功能更改*。重构更改通常很重要，可能难以理解。如果提交还包括功能更改，那么作者或审阅者可能会忽略错误的风险更高。
- en: A complete overview of refactoring techniques is beyond the scope of this book.
    For more on this topic, see Martin Fowler’s excellent book^([10](ch12.html#ch12fn11))
    and the discussions of tooling for automated, large-scale refactorings provided
    by Wright et al. (2013),^([11](ch12.html#ch12fn12)) Wasserman (2013),^([12](ch12.html#ch12fn13))
    and Potvin and Levenberg (2016).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 重构技术的完整概述超出了本书的范围。有关此主题的更多信息，请参阅Martin Fowler的优秀著作^([10](ch12.html#ch12fn11))以及Wright等人提供的自动化大规模重构工具的讨论（2013年），^([11](ch12.html#ch12fn12))
    Wasserman（2013年），^([12](ch12.html#ch12fn13))和Potvin和Levenberg（2016年）。
- en: Security and Reliability by Default
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认安全性和可靠性
- en: In addition to using frameworks with strong guarantees, you can use several
    other techniques to automatically improve the security and reliability posture
    of your application, as well as that of your team culture, which you’ll read more
    about in [Chapter 21](ch21.html#twoone_building_a_culture_of_security_a).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用具有强大保证的框架外，您还可以使用其他几种技术来自动改善应用程序的安全性和可靠性姿态，以及团队文化的姿态，您将在[第21章](ch21.html#twoone_building_a_culture_of_security_a)中了解更多。
- en: Choose the Right Tools
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的工具
- en: 'Choosing a language, framework, and libraries is a complicated task that’s
    often influenced by a combination of factors, such as these:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 选择语言、框架和库是一项复杂的任务，通常受多种因素的影响，例如：
- en: Integration with the existing codebase
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与现有代码库的集成
- en: Availability of libraries
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库的可用性
- en: Skills or preferences of the developer team
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发团队的技能或偏好
- en: Be aware of the enormous impact that language choice can have on the security
    and reliability of the project.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要意识到语言选择对项目安全性和可靠性的巨大影响。
- en: Use memory-safe languages
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用内存安全语言
- en: At BlueHat Israel in February 2019, Microsoft’s Matt Miller claimed that around
    70% of all security vulnerabilities are due to memory safety issues.^([13](ch12.html#ch12fn14))
    This statistic has remained consistent over at least the last 12 years.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在2019年2月的以色列BlueHat大会上，微软的Matt Miller声称，大约70%的安全漏洞都是由内存安全问题引起的。^([13](ch12.html#ch12fn14))这个统计数据在过去至少12年中一直保持一致。
- en: In a 2016 presentation, Nick Kralevich from Google reported that 85% of all
    bugs in Android (including bugs in the kernel and other components) were caused
    by memory management errors (slide 54).^([14](ch12.html#ch12fn15)) Kralevich concluded
    that “we need to move towards memory safe languages.” By using any language with
    higher-level memory management (such as Java or Go) rather than a language with
    more memory allocation difficulties (like C/C++), you can avoid this entire class
    of security (and reliability) vulnerabilities by default. Alternatively, you can
    use code sanitizers that detect most memory management pitfalls (see [“Sanitize
    Your Code”](#sanitize_your_code)).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在2016年的一次演讲中，来自Google的Nick Kralevich报告称，Android中85%的所有错误（包括内核和其他组件中的错误）都是由内存管理错误引起的（第54页）。^([14](ch12.html#ch12fn15))
    Kralevich得出结论：“我们需要转向内存安全语言。”通过使用具有更高级内存管理的任何语言（如Java或Go）而不是具有更多内存分配困难的语言（如C/C++），您可以默认避免这整类安全（和可靠性）漏洞。或者，您可以使用代码消毒剂来检测大多数内存管理陷阱（请参阅[“消毒您的代码”](#sanitize_your_code)）。
- en: Use strong typing and static type checking
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用强类型和静态类型检查
- en: In a *strongly typed* language, “whenever an object is passed from a calling
    function to a called function, its type must be compatible with the type declared
    in the called function.”^([15](ch12.html#ch12fn16)) A language without that requirement
    is referred to as *weakly* or *loosely typed*. You can enforce type checking either
    during compilation (*static type checking*) or at runtime (*dynamic type checking*).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在*强类型*语言中，“每当对象从调用函数传递到被调用函数时，其类型必须与被调用函数中声明的类型兼容。”没有这个要求的语言被称为*弱类型*或*松散类型*。您可以在编译期间（*静态类型检查*）或运行时（*动态类型检查*）执行类型检查。
- en: The benefits of strong typing and static type checking are especially noticeable
    when working on large codebases with multiple developers, as you can enforce invariants
    and eliminate a wide range of errors at compilation time rather than at runtime.
    This leads to more reliable systems, fewer security issues, and better-performing
    code in a production environment.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 强类型和静态类型检查的好处在于在大型代码库中与多个开发人员合作时特别明显，因为您可以在编译时强制执行不变量，并消除各种错误，而不是在运行时。这导致在生产环境中更可靠的系统，更少的安全问题和更高性能的代码。
- en: 'In contrast, when using dynamic type checking (for example, in Python), you
    can infer almost nothing about the code unless it has 100% test coverage—which
    is great in principle, but rarely observed in practice. Reasoning about the code
    becomes even harder in weakly typed languages, often leading to surprising behavior.
    For example, in JavaScript, every literal is by default treated as a string: `[9,
    8, 10].sort() -> [10, 8, 9]`.^([16](ch12.html#ch12fn17)) In both of these cases,
    because invariants aren’t enforced at compilation time, you can only capture mistakes
    during testing. In consequence, you more often detect reliability and security
    issues, especially in less frequently exercised code paths, in the production
    environment rather than during development.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在使用动态类型检查时（例如在Python中），除非代码具有100%的测试覆盖率，否则您几乎无法推断代码的任何信息——这在原则上很好，但在实践中很少见。在弱类型语言中，推理代码变得更加困难，通常会导致意外行为。例如，在JavaScript中，每个文字默认都被视为字符串：`[9,
    8, 10].sort() -> [10, 8, 9]`。在这两种情况下，由于不变量在编译时未被强制执行，您只能在测试期间捕获错误。因此，您更容易在生产环境中而不是在开发过程中检测到可靠性和安全性问题，特别是在较少频繁使用的代码路径中。
- en: 'If you want to use languages that have dynamic type checking or weak typing
    by default, we recommend using extensions like the following to improve the reliability
    of your code. These extensions offer support for stricter type checking, and you
    can incrementally add them to existing codebases:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用默认具有动态类型检查或弱类型的语言，我们建议使用以下扩展来提高代码的可靠性。这些扩展提供了对更严格类型检查的支持，您可以逐步将它们添加到现有的代码库中：
- en: '[Pytype for Python](https://oreil.ly/_AAvo)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Pytype for Python](https://oreil.ly/_AAvo)'
- en: '[TypeScript for JavaScript](https://www.typescriptlang.org)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[TypeScript for JavaScript](https://www.typescriptlang.org)'
- en: Use Strong Types
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用强类型
- en: 'Using untyped primitives (such as strings or integers) can lead to the following
    issues:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用未类型化的基元（例如字符串或整数）可能会导致以下问题：
- en: Passing conceptually invalid parameters to a function
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向函数传递概念上无效的参数
- en: Unwanted implicit type conversions
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要的隐式类型转换
- en: Difficult-to-understand type hierarchy^([17](ch12.html#ch12fn18))
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难以理解的类型层次结构
- en: Confusing measurement units
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令人困惑的测量单位
- en: 'The first situation—passing conceptually invalid parameters to a function—occurs
    if the primitive type of a function parameter does not have enough context, and
    therefore becomes confusing when it’s called. For example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况——向函数传递概念上无效的参数——发生在函数参数的原始类型没有足够的上下文，并且在调用时变得令人困惑。例如：
- en: For the function `AddUserToGroup(string, string)`, it’s unclear whether the
    group name is provided as the first or the second argument.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于函数`AddUserToGroup(string, string)`，不清楚组名是作为第一个参数还是第二个参数提供的。
- en: What is the order of height and width in the `Rectangle (3.14, 5.67)` constructor
    call?
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Rectangle(3.14, 5.67)`构造函数调用中，高度和宽度的顺序是什么？
- en: Does `Circle(double)` expect a radius or diameter?
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Circle(double)`是否期望半径还是直径？'
- en: Documentation can correct for ambiguity, but developers are still bound to make
    mistakes. Unit tests can catch most of these errors if we’ve done our due diligence,
    but some errors may surface only at runtime.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 文档可以纠正歧义，但开发人员仍然可能犯错。如果我们尽了责任，单元测试可以捕捉到大多数这些错误，但有些错误可能只在运行时出现。
- en: 'When using strong types, you can catch these mistakes at compilation time.
    To return to our earlier example, the required calls would look like the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用强类型时，您可以在编译时捕捉到这些错误。回到我们之前的例子，所需的调用将如下所示：
- en: '`Add(User("alice"), Group("root-users"))`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add(User("alice"), Group("root-users"))`'
- en: '`Rectangle(Width(3.14), Height(5.67))`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rectangle(Width(3.14), Height(5.67))`'
- en: '`Circle(Radius(1.23))`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Circle(Radius(1.23))`'
- en: where `User`, `Group`, `Width`, `Height`, and `Radius` are strong type wrappers
    around string or double primitives. This approach is less error-prone and makes
    the code more self-documenting—in this context, in the first example it’s sufficient
    to call the function `Add`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`User`、`Group`、`Width`、`Height`和`Radius`是围绕字符串或双精度基元的强类型包装器。这种方法不太容易出错，并使代码更具自我说明性——在这种情况下，在第一个示例中，只需调用函数`Add`即可。
- en: 'In the second situation, implicit type conversions may lead to the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，隐式类型转换可能导致以下情况：
- en: Truncation when converting from larger to smaller integer types
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从较大的整数类型转换为较小的整数类型时的截断
- en: Precision loss when converting from larger to smaller floating-point types
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从较大的浮点类型转换为较小的浮点类型时的精度损失
- en: Unexpected object creation
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意外对象创建
- en: In some cases, a compiler will report the first two issues (for example, when
    using the `{}` direct initialization syntax in C++), but many instances will likely
    be overlooked. Using strong types protects your code from errors of this type
    that a compiler doesn’t capture.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，编译器将报告前两个问题（例如，在C++中使用`{}`直接初始化语法时），但许多实例可能会被忽视。使用强类型可以保护您的代码免受编译器无法捕获的此类错误。
- en: 'Now let’s consider the case of the difficult-to-understand type hierarchy:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑难以理解的类型层次结构的情况：
- en: '[PRE12]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The three calls here will compile and execute, but will the outcome of the operation
    match developers’ expectations? By default, a C++ compiler attempts to implicitly
    cast (*coerce*) parameters to match function argument types. In this case, the
    compiler will attempt to match the type `Bar`, which conveniently has a single-value
    constructor taking a parameter of type `bool`. Most C++ types implicitly cast
    to `bool`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的三个调用将编译并执行，但操作的结果是否符合开发人员的期望呢？默认情况下，C++编译器会尝试隐式转换（*强制*）参数以匹配函数参数类型。在这种情况下，编译器将尝试匹配类型`Bar`，它恰好有一个接受`bool`类型参数的单值构造函数。大多数C++类型会隐式转换为`bool`。
- en: Implicit casting in constructors is sometimes intended (for example, when converting
    floating-point values to the `std::complex` class), but can be dangerous in most
    situations. To prevent dangerous outcomes, at a minimum, make single-value constructors
    *explicit*—for example, `explicit Bar(bool is_safe)`. Note that the last call
    will result in a compilation error when using `nullptr` rather than `NULL` because
    there is no implicit conversion to `bool`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中的隐式转换有时是有意的（例如，将浮点值转换为`std::complex`类时），但在大多数情况下可能是危险的。为了防止危险的结果，至少要使单值构造函数*显式*——例如，`explicit
    Bar(bool is_safe)`。请注意，最后一次调用将导致编译错误，因为使用`nullptr`而不是`NULL`，因为没有到`bool`的隐式转换。
- en: 'Finally, unit confusion is an endless source of mistakes. These mistakes might
    be characterized as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，单位混淆是错误的无尽源泉。这些错误可能被描述如下：
- en: Harmless
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 无害的
- en: For example, code that sets a timer for 30 seconds instead of 30 minutes because
    the programmer didn’t know what units `Timer(30)` uses.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，设置一个30秒的定时器而不是30分钟，因为程序员不知道`Timer(30)`使用的单位。
- en: Dangerous
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 危险的
- en: For example, AirCanada’s [“Gimli Glider” airplane](https://oreil.ly/5r61w) had
    to make an emergency landing after ground crew calculated the necessary fuel in
    pounds instead of kilograms, leaving it with only half the required fuel.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，加拿大航空的“吉姆利滑翔机”飞机在地勤人员计算所需的燃料时使用的是磅而不是千克，导致它只有所需燃料的一半。
- en: Expensive
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 昂贵的
- en: For example, scientists [lost the $125 million Mars Climate Orbiter](https://oreil.ly/ZMbIO)
    because two separate engineering teams used different units of measurement (imperial
    versus metric).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，科学家们[失去了价值1.25亿美元的火星气候轨道飞行器](https://oreil.ly/ZMbIO)，因为两个独立的工程团队使用了不同的测量单位（英制与公制）。
- en: 'As before, strong types are a solution to this issue: they can encapsulate
    the unit, and represent only abstract concepts such as timestamp, duration, or
    weight. Such types typically implement the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，强类型是解决此问题的一种方法：它们可以封装单位，并且只表示抽象概念，如时间戳、持续时间或重量。这些类型通常实现以下功能：
- en: Sensible operations
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 明智的操作
- en: For example, adding two timestamps is not normally a useful operation, but subtracting
    them returns a duration that can be useful for many use cases. Adding two durations
    or weights is similarly useful.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，添加两个时间戳通常不是一个有用的操作，但是减去它们会返回一个对许多用例有用的持续时间。类似地，添加两个持续时间或重量也是有用的。
- en: Unit conversions
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 单位转换
- en: For example, T`imestamp::ToUnix, Duration::ToHours, Weight::ToKilograms`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Timestamp::ToUnix, Duration::ToHours, Weight::ToKilograms`。
- en: 'Some languages provide such abstractions natively: examples include the [`time`
    package](https://golang.org/pkg/time) in Go and the [`chrono` library](http://www.wg21.link/p0355)
    in the upcoming C++20 standard. Other languages might require a dedicated implementation.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言本身提供这样的抽象：例如Go中的[`time`包](https://golang.org/pkg/time)和即将到来的C++20标准中的[`chrono`库](http://www.wg21.link/p0355)。其他语言可能需要专门的实现。
- en: The [Fluent C++ blog](https://oreil.ly/Urmzl) has more discussion on applications
    of strong types and example implementations in C++.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[Fluent C++博客](https://oreil.ly/Urmzl)对C++中强类型的应用和示例实现进行了更多讨论。'
- en: Sanitize Your Code
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 净化您的代码
- en: It’s very useful to automatically validate that your code is not experiencing
    any typical memory management or concurrency pitfalls. You can run these checks
    as a presubmit action for each change list or as part of a continuous build and
    test automation harness. The list of pitfalls to check is language-dependent.
    This section presents some solutions for C++ and Go.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 自动验证代码是否遇到任何典型的内存管理或并发陷阱非常有用。您可以将这些检查作为每个更改列表的预提交操作运行，也可以作为持续构建和测试自动化工具的一部分运行。要检查的陷阱列表取决于语言。本节介绍了C++和Go的一些解决方案。
- en: 'C++: Valgrind or Google Sanitizers'
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++：Valgrind或Google Sanitizers
- en: 'C++ allows for low-level memory management. As we mentioned earlier, memory
    management errors are a leading cause of security issues, and can result in the
    following failure scenarios:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: C++允许进行低级内存管理。正如我们之前提到的，内存管理错误是安全问题的主要原因，并且可能导致以下故障场景：
- en: Reading unallocated memory (before `new` or after `delete`)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取未分配的内存（`new`之前或`delete`之后）
- en: Reading outside of the allocated memory (buffer overflow attack scenario)
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取超出分配内存范围的内容（缓冲区溢出攻击场景）
- en: Reading uninitialized memory
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取未初始化的内存
- en: Memory leaks when a system loses the address of allocated memory or doesn’t
    deallocate unused memory early
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当系统丢失已分配内存的地址或不及时释放未使用的内存时，会发生内存泄漏
- en: '[Valgrind](http://www.valgrind.org) is a popular framework that allows developers
    to catch those sorts of errors, even if unit tests don’t catch them. Valgrind
    has the benefit of providing a virtual machine that interprets a user’s binary,
    so users don’t need to recompile their code to use it. The Valgrind tool [Helgrind](https://oreil.ly/mBSSw)
    can additionally detect common synchronization errors such as these:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[Valgrind](http://www.valgrind.org)是一个流行的框架，允许开发人员捕捉这些类型的错误，即使单元测试没有捕捉到它们。Valgrind的好处在于提供了一个解释用户二进制的虚拟机，因此用户无需重新编译代码即可使用它。Valgrind工具[Helgrind](https://oreil.ly/mBSSw)还可以检测常见的同步错误，例如：'
- en: Misuses of the POSIX pthreads API (e.g., unlocking a not-locked mutex, or a
    mutex held by another thread)
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对POSIX pthreads API的误用（例如，解锁未锁定的互斥锁，或者由另一个线程持有的互斥锁）
- en: Potential deadlocks arising from lock ordering problems
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于锁定顺序问题而产生的潜在死锁
- en: Data races caused by accessing memory without adequate locking or synchronization
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于访问内存而未进行充分锁定或同步而引起的数据竞争
- en: 'Alternatively, the [Google Sanitizers suite](https://oreil.ly/qqdMy) offers
    various components that can detect all the same issues that Valgrind’s Callgrind
    (a cache and branch prediction profiler) can detect:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，[Google Sanitizers套件](https://oreil.ly/qqdMy)提供了各种组件，可以检测Valgrind的Callgrind（缓存和分支预测分析器）可以检测到的所有相同问题：
- en: AddressSanitizer (ASan) detects memory errors (buffer overflows, use after free,
    incorrect initialization order).
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AddressSanitizer (ASan)检测内存错误（缓冲区溢出，释放后使用，不正确的初始化顺序）。
- en: LeakSanitizer (LSan) detects memory leaks.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LeakSanitizer (LSan)检测内存泄漏。
- en: MemorySanitizer (MSan) detects when a system is reading uninitialized memory.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MemorySanitizer (MSan)检测系统是否正在读取未初始化的内存。
- en: ThreadSanitizer (TSan) detects data races and deadlocks.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ThreadSanitizer (TSan)检测数据竞争和死锁。
- en: UndefinedBehaviorSanitizer (UBSan) detects situations that have undefined behavior
    (using misaligned pointers; signed integer overflow; converting to, from, or between
    floating-point types that will overflow the destination).
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UndefinedBehaviorSanitizer (UBSan)检测具有未定义行为的情况（使用未对齐的指针；有符号整数溢出；转换到、从或在浮点类型之间溢出目标）。
- en: 'The main advantage of the Google Sanitizers suite is speed: it’s [up to 10
    times faster](https://oreil.ly/iyxQ1) than Valgrind. Popular IDEs like [CLion](https://oreil.ly/yGhh-)
    also provide first-class integration with Google Sanitizers. The next chapter
    provides more details on sanitizers and other dynamic program analysis tools.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Google Sanitizers套件的主要优势是速度：它比Valgrind快[高达10倍](https://oreil.ly/iyxQ1)。像[CLion](https://oreil.ly/yGhh-)这样的流行IDE还提供了与Google
    Sanitizers的一流集成。下一章将更详细地介绍sanitizers和其他动态程序分析工具。
- en: 'Go: Race Detector'
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go：竞争检测器
- en: While Go is designed to disallow memory corruption issues typical to C++, it
    may still suffer from data race conditions. [Go Race Detector](https://oreil.ly/RU46m)
    can detect these conditions.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Go旨在禁止C++典型的内存损坏问题，但仍可能受到数据竞争条件的影响。[Go竞争检测器](https://oreil.ly/RU46m)可以检测这些条件。
- en: Conclusion
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'This chapter presented several principles that guide developers toward designing
    and implementing more secure and reliable code. In particular, we recommend using
    frameworks as a powerful strategy, as they reuse proven building blocks for sensitive
    areas of code prone to reliability and security issues: authentication, authorization,
    logging, rate limiting, and communication in distributed systems. Frameworks also
    tend to improve developer productivity—both for the people writing the framework
    and the people using the framework—and make reasoning about the code much easier.
    Additional strategies for writing secure and reliable code include aiming for
    simplicity, choosing the right tools, using strong rather than primitive types,
    and continuously sanitizing the codebase.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了几个指导开发人员设计和实现更安全可靠代码的原则。特别是，我们建议使用框架作为一种强大的策略，因为它们重用了已被证明对于代码的敏感区域（身份验证、授权、日志记录、速率限制和分布式系统中的通信）的建设块：框架还倾向于提高开发人员的生产力，无论是编写框架的人还是使用框架的人，并使对代码的推理变得更加容易。编写安全可靠代码的其他策略包括追求简单性，选择合适的工具，使用强类型而不是原始类型，并持续对代码进行消毒。
- en: Investing extra effort in improving security and reliability while writing software
    pays off in the long run, and reduces the effort you have to spend reviewing your
    application or fixing issues after your application is deployed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写软件时，额外投入精力改善安全性和可靠性将在长期内得到回报，并减少您在部署应用程序后需要花费的审查应用程序或修复问题的工作量。
- en: ^([1](ch12.html#ch12fn1-marker)) See [Chapter 22 of the SRE book](https://landing.google.com/sre/sre-book/chapters/addressing-cascading-failures/)
    for more on cascading failures.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch12.html#ch12fn1-marker)) 有关级联故障的更多信息，请参见[SRE书的第22章](https://landing.google.com/sre/sre-book/chapters/addressing-cascading-failures/)。
- en: ^([2](ch12.html#ch12fn2-marker)) Also described in [Chapter 22 of the SRE book](https://landing.google.com/sre/sre-book/chapters/addressing-cascading-failures/).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch12.html#ch12fn2-marker)) 也在[SRE书的第22章](https://landing.google.com/sre/sre-book/chapters/addressing-cascading-failures/)中有描述。
- en: '^([3](ch12.html#ch12fn4-marker)) This system is described in more detail in
    Kern, Christoph. 2014\. “Securing the Tangled Web.” *Communications of the ACM*
    57(9): 38–47\. [*https://oreil.ly/drZss*](https://oreil.ly/drZss).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '^([3](ch12.html#ch12fn4-marker)) 有关该系统的更多详细信息，请参见Kern, Christoph. 2014. “保护纠缠不清的网络。”
    *ACM通讯* 57(9): 38–47. [*https://oreil.ly/drZss*](https://oreil.ly/drZss).'
- en: '^([4](ch12.html#ch12fn5-marker)) See Bessey, Al et al. 2010\. “A Few Billion
    Lines of Code Later: Using Static Analysis to Find Bugs in the Real World.” *Communications
    of the ACM* 53(2): 66–75\. doi:10.1145/1646353.1646374.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '^([4](ch12.html#ch12fn5-marker)) 请参见Bessey, Al等人。2010. “数十亿行代码之后：使用静态分析在现实世界中查找错误。”
    *ACM通讯* 53(2): 66–75. doi:10.1145/1646353.1646374.'
- en: '^([5](ch12.html#ch12fn6-marker)) Potvin, Rachel, and Josh Levenberg. 2016\.
    “Why Google Stores Billions of Lines of Code in a Single Repository.” *Communications
    of the ACM* 59(7): 78–87\. doi:10.1145/2854146.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '^([5](ch12.html#ch12fn6-marker)) Potvin, Rachel, and Josh Levenberg. 2016.
    “为什么Google将数十亿行代码存储在单个存储库中。” *ACM通讯* 59(7): 78–87. doi:10.1145/2854146.'
- en: '^([6](ch12.html#ch12fn7-marker)) See, e.g., Ousterhout, John. 2018\. *A Philosophy
    of Software Design*. Palo Alto, CA: Yaknyam Press.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '^([6](ch12.html#ch12fn7-marker)) 例如，Ousterhout, John. 2018. *软件设计哲学*. Palo
    Alto, CA: Yaknyam Press.'
- en: '^([7](ch12.html#ch12fn8-marker)) Source: Karpilovsky, Elliott. 2017\. “Code
    Health: Reduce Nesting, Reduce Complexity.” [*https://oreil.ly/PO1QR*](https://oreil.ly/PO1QR).'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch12.html#ch12fn8-marker)) 来源：Karpilovsky, Elliott. 2017. “代码健康：减少嵌套，减少复杂性。”
    [*https://oreil.ly/PO1QR*](https://oreil.ly/PO1QR).
- en: '^([8](ch12.html#ch12fn9-marker)) Source: Eaddy, Marc. 2017\. “Code Health:
    Eliminate YAGNI Smells.” [*https://oreil.ly/NYr7y*](https://oreil.ly/NYr7y).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch12.html#ch12fn9-marker)) 来源：Eaddy, Marc. 2017. “代码健康：消除YAGNI气味。” [*https://oreil.ly/NYr7y*](https://oreil.ly/NYr7y).
- en: ^([9](ch12.html#ch12fn10-marker)) A wide selection of code coverage tools are
    available. For an overview, see the list on [Stackify](https://oreil.ly/-w6DM).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch12.html#ch12fn10-marker)) 有很多代码覆盖工具可供选择。有关概述，请参阅[Stackify上的列表](https://oreil.ly/-w6DM)。
- en: '^([10](ch12.html#ch12fn11-marker)) Fowler, Martin. 2019\. *Refactoring: Improving
    the Design of Existing Code*. Boston, MA: Addison-Wesley.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch12.html#ch12fn11-marker)) Fowler, Martin. 2019年。 *重构：改善现有代码的设计*。马萨诸塞州波士顿：Addison-Wesley。
- en: '^([11](ch12.html#ch12fn12-marker)) Wright, Hyrum et al. 2013\. “Large-Scale
    Automated Refactoring Using Clang.” *Proceedings of the 29^(th) International
    Conference on Software Maintenance*: 548–551\. doi:10.1109/ICSM.2013.93.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch12.html#ch12fn12-marker)) Wright, Hyrum等。 2013年。 “使用Clang进行大规模自动重构。”
    *软件维护国际会议第29届论文集*：548–551。 doi:10.1109/ICSM.2013.93。
- en: '^([12](ch12.html#ch12fn13-marker)) Wasserman, Louis. 2013\. “Scalable, Example-Based
    Refactorings with Refaster.” *Proceedings of the 2013 ACM Workshop on Refactoring
    Tools*: 25–28 doi:10.1145/2541348.2541355.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch12.html#ch12fn13-marker)) Wasserman, Louis. 2013年。 “可扩展的基于示例的重构与Refaster。”
    *2013年重构工具ACM研讨会论文集*：25–28 doi:10.1145/2541348.2541355。
- en: ^([13](ch12.html#ch12fn14-marker)) Miller, Matt. 2019\. “Trends, Challenges,
    and Strategic Shifts in the Software Vulnerability Mitigation Landscape.” BlueHat
    IL. [*https://goo.gl/vKM7uQ*](https://goo.gl/vKM7uQ).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ^([13](ch12.html#ch12fn14-marker)) Miller, Matt. 2019年。 “软件漏洞缓解领域的趋势、挑战和战略转变。”
    BlueHat IL。 [*https://goo.gl/vKM7uQ*](https://goo.gl/vKM7uQ)。
- en: '^([14](ch12.html#ch12fn15-marker)) Kralevich, Nick. 2016\. “The Art of Defense:
    How Vulnerabilities Help Shape Security Features and Mitigations in Android.”
    BlackHat. [*https://oreil.ly/16rCq*](https://oreil.ly/16rCq).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ^([14](ch12.html#ch12fn15-marker)) Kralevich, Nick. 2016年。 “防御的艺术：漏洞如何塑造Android中的安全功能和缓解措施。”
    BlackHat。 [*https://oreil.ly/16rCq*](https://oreil.ly/16rCq)。
- en: '^([15](ch12.html#ch12fn16-marker)) Liskov, Barbara, and Stephen Zilles. 1974\.
    “Programming with Abstract Data Types.” *Proceedings of the ACM SIGPLAN Symposium
    on Very High Level Languages*: 50–59\. doi:10.1145/800233.807045'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ^([15](ch12.html#ch12fn16-marker)) Liskov, Barbara和Stephen Zilles。 1974年。 “使用抽象数据类型进行编程。”
    *ACM SIGPLAN非常高级语言研讨会论文集*：50–59。 doi:10.1145/800233.807045。
- en: ^([16](ch12.html#ch12fn17-marker)) For many more surprises in JavaScript and
    Ruby, see [Gary Bernhardt’s lightning talk from CodeMash 2012](https://oreil.ly/M69rg).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ^([16](ch12.html#ch12fn17-marker)) 有关JavaScript和Ruby中更多的惊喜，请参见[Gary Bernhardt在CodeMash
    2012的闪电演讲](https://oreil.ly/M69rg)。
- en: '^([17](ch12.html#ch12fn18-marker)) See Eaddy, Mark. 2017\. “Code Health: Obsessed
    with Primitives?” [*https://oreil.ly/0DvJI*](https://oreil.ly/0DvJI).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ^([17](ch12.html#ch12fn18-marker)) 参见Eaddy, Mark. 2017年。 “代码健康：对基元着迷？” [*https://oreil.ly/0DvJI*](https://oreil.ly/0DvJI)。

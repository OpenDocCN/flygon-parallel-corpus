- en: Chapter 12\. Writing Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。编写代码
- en: By Michał Czapiński and Julian Bangert
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由Michał Czapiński和Julian Bangert撰写
- en: with Thomas Maufer and Kavita Guliani
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与Thomas Maufer和Kavita Guliani合作
- en: Security and reliability cannot easily be retrofitted into software, so it’s
    important to account for them in software design from the earliest phases. Tacking
    on these features after a launch is painful and less effective, and may require
    you to change other fundamental assumptions about the codebase (see [Chapter 4](ch04.html#design_tradeoffs)
    for a deeper discussion on this topic).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性和可靠性不能轻易地加入软件中，因此在软件设计的早期阶段就考虑它们是很重要的。在发布后添加这些功能是痛苦且不太有效的，可能需要您改变代码库的其他基本假设（有关此主题的更深入讨论，请参见[第4章](ch04.html#design_tradeoffs)）。
- en: The first and most important step in reducing security and reliability issues
    is to educate developers. However, even the best-trained engineers make mistakes—security
    experts can write insecure code and SREs can miss reliability issues. It’s difficult
    to keep the many considerations and tradeoffs involved in building secure and
    reliable systems in mind simultaneously, especially if you’re also responsible
    for producing software.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 减少安全性和可靠性问题的第一步，也是最重要的一步是教育开发人员。然而，即使是训练有素的工程师也会犯错——安全专家可能会编写不安全的代码，SRE可能会忽略可靠性问题。在同时考虑构建安全和可靠系统所涉及的许多考虑因素和权衡是困难的，尤其是如果你还负责生产软件的话。
- en: Instead of relying solely on developers to vet code for security and reliability,
    you can task SREs and security experts with reviewing code and software designs.
    This approach is also imperfect—manual code reviews won’t find every issue, and
    no reviewer will catch *every* security problem that an attacker could potentially
    exploit. Reviewers can also be biased by their own experience or interests. For
    example, they may naturally gravitate toward seeking out new classes of attacks,
    high-level design issues, or interesting flaws in cryptographic protocols; in
    contrast, reviewing hundreds of HTML templates for cross-site scripting (XSS)
    flaws or checking the error-handling logic for each RPC in an application may
    be seen as less thrilling.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 与其完全依赖开发人员审查代码的安全性和可靠性，不如让SRE和安全专家审查代码和软件设计。这种方法也是不完美的——手动代码审查不会发现每个问题，也不会每个安全问题都能被审查人员发现。审查人员也可能会受到自己的经验或兴趣的影响。例如，他们可能自然而然地倾向于寻找新的攻击类型、高级设计问题或加密协议中的有趣缺陷；相比之下，审查数百个HTML模板以查找跨站脚本（XSS）漏洞，或者检查应用程序中每个RPC的错误处理逻辑可能会被视为不那么令人兴奋。
- en: While code reviews may not find every vulnerability, they do have other benefits.
    A strong review culture encourages developers to structure their code in a way
    that makes the security and reliability properties easy to review. This chapter
    discusses strategies for making these properties obvious to reviewers and for
    integrating automation into the development process. These strategies can free
    up a team’s bandwidth to focus on other issues and lead to building a culture
    of security and reliability (see [Chapter 21](ch21.html#twoone_building_a_culture_of_security_a)).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码审查可能不会发现每个漏洞，但它们确实有其他好处。良好的审查文化鼓励开发人员以便于审查安全性和可靠性属性的方式构建他们的代码。本章讨论了使审查人员能够明显看到这些属性的策略，并将自动化整合到开发过程中。这些策略可以释放团队的带宽，让他们专注于其他问题，并建立安全和可靠性的文化（参见[第21章](ch21.html#twoone_building_a_culture_of_security_a)）。
- en: Frameworks to Enforce Security and Reliability
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制执行安全性和可靠性的框架
- en: As discussed in [Chapter 6](ch06.html#design_for_understandability), the security
    and reliability of an application rely on domain-specific invariants. For example,
    an application is secure against SQL injection attacks if all of its database
    queries consist only of developer-controlled code, with external inputs supplied
    via query parameter bindings. A web application can prevent XSS attacks if all
    user input that’s inserted into HTML forms is properly escaped or sanitized to
    remove any executable code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第6章](ch06.html#design_for_understandability)所讨论的，应用程序的安全性和可靠性依赖于特定领域的不变量。例如，如果应用程序的所有数据库查询仅由开发人员控制的代码组成，并通过查询参数绑定提供外部输入，那么该应用程序就可以防止SQL注入攻击。如果所有插入HTML表单的用户输入都经过适当转义或清理以删除任何可执行代码，Web应用程序就可以防止XSS攻击。
- en: In theory, you can create secure and reliable software by carefully writing
    application code that maintains these invariants. However, as the number of desired
    properties and the size of the codebase grows, this approach becomes almost impossible.
    It’s unreasonable to expect any developer to be an expert in all these subjects,
    or to constantly maintain vigilance when writing or reviewing code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，您可以通过仔细编写维护这些不变量的应用程序代码来创建安全可靠的软件。然而，随着所需属性的数量和代码库的规模增长，这种方法几乎变得不可能。不合理地期望任何开发人员都是所有这些主题的专家，或者在编写或审查代码时始终保持警惕是不合理的。
- en: If humans need to manually review every change, those humans will have a hard
    time maintaining global invariants because reviewers can’t always keep track of
    global context. If a reviewer needs to know which function parameters are passed
    user input by callers and which arguments only contain developer-controlled, trustworthy
    values, they must also be familiar with all transitive callers of a function.
    Reviewers are unlikely to be able to keep this state over the long run.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要人工审查每个更改，那么这些人将很难维护全局不变量，因为审查人员无法始终跟踪全局上下文。如果审查人员需要知道哪些函数参数是由调用者传递的用户输入，哪些参数只包含开发人员控制的可信值，他们还必须熟悉函数的所有传递调用者。审查人员不太可能能够长期保持这种状态。
- en: A better approach is to handle security and reliability in common frameworks,
    languages, and libraries. Ideally, libraries only expose an interface that makes
    writing code with common classes of security vulnerabilities impossible. Multiple
    applications can use each library or framework. When domain experts fix an issue,
    they remove it from all the applications the framework supports, allowing this
    engineering approach to scale better. Compared to manual review, using a centralized
    hardened framework also reduces the chances of future vulnerabilities creeping
    in. Of course, no framework can protect against all security vulnerabilities,
    and it is still possible for attackers to discover an unforeseen class of attacks
    or find mistakes in the implementation of the framework. But if you discover a
    new vulnerability, you can address it in one place (or a few) instead of throughout
    the codebase.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是在通用框架、语言和库中处理安全和可靠性。理想情况下，库只公开一个接口，使得使用常见安全漏洞类的代码编写变得不可能。多个应用程序可以使用每个库或框架。当领域专家修复问题时，他们会从框架支持的所有应用程序中删除它，从而使这种工程方法更好地扩展。与手动审查相比，使用集中的强化框架还可以减少未来漏洞的可能性。当然，没有框架可以防止所有安全漏洞，攻击者仍然有可能发现未预料到的攻击类别或发现框架实现中的错误。但是，如果您发现了新的漏洞，您可以在一个地方（或几个地方）解决它，而不是在整个代码库中。
- en: 'To provide one concrete example: SQL injection (SQLI) holds the top spot on
    both the [OWASP](https://oreil.ly/TnBaK) and [SANS](https://oreil.ly/RWvPF) lists
    of common security vulnerabilities. In our experience, when you use a hardened
    data library such as `TrustedSqlString` (see [“SQL Injection Vulnerabilities:
    TrustedSqlString”](#sql_injection_vulnerabilities_trustedsq)), these types of
    vulnerabilities become a nonissue. Types make these assumptions explicit, and
    are automatically enforced by the compiler.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 举一个具体的例子：SQL注入（SQLI）在常见安全漏洞的[OWASP](https://oreil.ly/TnBaK)和[SANS](https://oreil.ly/RWvPF)列表中占据首要位置。根据我们的经验，当您使用像`TrustedSqlString`这样的强化数据库时（参见[“SQL注入漏洞：TrustedSqlString”](#sql_injection_vulnerabilities_trustedsq)），这类漏洞就不再是问题。类型使这些假设变得明确，并且由编译器自动执行。
- en: Benefits of Using Frameworks
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用框架的好处
- en: Most applications have similar building blocks for security (authentication
    and authorization, logging, data encryption) and reliability (rate limiting, load
    balancing, retry logic). Developing and maintaining such building blocks from
    scratch for every service is expensive, and leads to a patchwork of different
    bugs in each service.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都具有类似的安全构建块（身份验证和授权、日志记录、数据加密）和可靠性构建块（速率限制、负载平衡、重试逻辑）。为每个服务从头开始开发和维护这些构建块是昂贵的，并且会导致每个服务中不同错误的拼接。
- en: 'Frameworks enable code reuse: rather than accounting for all of the security
    and reliability aspects affecting a given functionality or feature, developers
    only need to customize a specific building block. For example, a developer can
    specify which information from the incoming request credentials is important for
    authorization without worrying about the credibility of that information—that
    credibility is verified by the framework. Equally, a developer can specify which
    data needs to be logged without worrying about storage or replication. Frameworks
    also make propagating updates easier, as you need to apply an update in only one
    location.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 框架实现了代码重用：开发人员只需定制特定的构建块，而不需要考虑影响给定功能或特性的所有安全和可靠性方面。例如，开发人员可以指定传入请求凭据中哪些信息对授权很重要，而无需担心这些信息的可信度——框架会验证可信度。同样，开发人员可以指定需要记录哪些数据，而无需担心存储或复制。框架还使传播更新更容易，因为您只需要在一个位置应用更新。
- en: Using frameworks leads to increased productivity for all developers in an organization,
    a benefit for building a culture of security and reliability (see [Chapter 21](ch21.html#twoone_building_a_culture_of_security_a)).
    It’s much more efficient for a team of domain experts to design and develop the
    framework building blocks than for each individual team to implement security
    and reliability features itself. For example, if the security team handles cryptography,
    all other teams benefit from their knowledge. None of the developers using the
    frameworks need to worry about their internal details, and they can instead focus
    on an application’s business logic.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用框架可以提高组织中所有开发人员的生产力，有助于建立安全和可靠文化（参见[第21章](ch21.html#twoone_building_a_culture_of_security_a)）。对于一个团队的领域专家来说，设计和开发框架构建块要比每个团队单独实现安全和可靠特性更有效率。例如，如果安全团队处理加密，其他所有团队都会从他们的知识中受益。使用框架的开发人员无需担心其内部细节，而可以专注于应用程序的业务逻辑。
- en: Frameworks further increase productivity by providing tools that are easy to
    integrate with. For example, frameworks can provide tools that automatically export
    basic operational metrics, like the total number of requests, the number of failed
    requests broken down by error type, or the latency of each processing stage. You
    can use that data to generate automated monitoring dashboards and alerting for
    a service. Frameworks also make integrating with load-balancing infrastructure
    easier, so a service can automatically redirect traffic away from overloaded instances,
    or spin up new service instances under heavy load. As a result, services built
    on top of frameworks exhibit significantly higher reliability.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 框架通过提供易于集成的工具进一步提高了生产力。例如，框架可以提供自动导出基本操作指标的工具，比如总请求数、按错误类型分解的失败请求数量，或者每个处理阶段的延迟。您可以使用这些数据生成自动化监控仪表板和服务的警报。框架还使与负载均衡基础设施集成更容易，因此服务可以自动将流量重定向到超载实例之外，或者在负载较重时启动新的服务实例。因此，基于框架构建的服务表现出更高的可靠性。
- en: Using frameworks also makes reasoning about the code easy by clearly separating
    business logic from common functions. This enables developers to make assertions
    about the security or reliability of a service with more confidence. In general,
    frameworks lead to reduced complexity—when code across multiple services is more
    uniform, it’s easier to follow common good practices.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用框架还可以通过清晰地将业务逻辑与常见功能分离，使对代码的推理变得容易。这使开发人员可以更有信心地对服务的安全性或可靠性做出断言。总的来说，框架可以降低复杂性——当跨多个服务的代码更加统一时，遵循常见的良好实践就更容易了。
- en: 'It doesn’t always make sense to develop your own frameworks. In many cases,
    the best strategy is to reuse existing solutions. For example, almost any security
    professional will advise you against designing and implementing your own cryptographic
    framework—instead, you might use a well-established and widely used framework
    such as Tink (discussed in [“Example: Secure cryptographic APIs and the Tink crypto
    framework”](ch06.html#example_secure_cryptographic_apis_and_t)).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 开发自己的框架并不总是有意义。在许多情况下，最好的策略是重用现有的解决方案。例如，几乎任何安全专业人士都会建议您不要设计和实现自己的加密框架，而是可以使用像Tink这样的成熟和广泛使用的框架（在[“示例：安全加密API和Tink加密框架”](ch06.html#example_secure_cryptographic_apis_and_t)中讨论）。
- en: Before deciding to adopt any specific framework, it’s important to evaluate
    its security posture. We also suggest using actively maintained frameworks and
    continuously updating your code dependencies to incorporate the latest security
    fixes for any code on which your code depends.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定采用任何特定框架之前，评估其安全姿态是很重要的。我们还建议使用积极维护的框架，并不断更新您的代码依赖项，以纳入对您的代码依赖的任何代码的最新安全修复。
- en: 'The following case study is a practical example demonstrating the benefits
    of frameworks: in this case, a framework for creating RPC backends.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下案例是一个实际示例，演示了框架的好处：在这种情况下，是用于创建RPC后端的框架。
- en: 'Example: Framework for RPC Backends'
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：RPC后端框架
- en: 'Most RPC backends follow a similar structure. They handle request-specific
    logic and typically also perform the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数RPC后端遵循类似的结构。它们处理特定于请求的逻辑，并通常还执行以下操作：
- en: Logging
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录
- en: Authentication
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证
- en: Authorization
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权
- en: Throttling (rate limiting)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限流（速率限制）
- en: Instead of reimplementing this functionality for every single RPC backend, we
    recommend using a framework that can hide the implementation details of these
    building blocks. Then developers just need to customize each step to accommodate
    their service’s needs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用一个可以隐藏这些构建块的实现细节的框架，而不是为每个单独的RPC后端重新实现这些功能。然后开发人员只需要定制每个步骤以适应其服务的需求。
- en: '[Figure 12-1](#a_control_flow_in_a_potential_framework) presents a possible
    framework architecture based on predefined *interceptors* that are responsible
    for each of the previously mentioned steps. You can potentially also use interceptors
    for custom steps. Each interceptor defines an action to be performed *before*
    and *after* the actual RPC logic executes. Each stage can report an error condition,
    which prevents further interceptors from executing. However, when this occurs,
    the *after* steps of each interceptor that has already been called are executed
    in the reverse order. The framework between the interceptors can transparently
    perform additional actions—for example, exporting error rates or performance metrics.
    This architecture leads to a clear separation of the logic performed at every
    stage, resulting in increased simplicity and reliability.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-1](#a_control_flow_in_a_potential_framework)展示了一个基于预定义*拦截器*的可能框架架构，这些拦截器负责前面提到的每个步骤。您还可以使用拦截器来执行自定义步骤。每个拦截器定义了在实际RPC逻辑执行*之前*和*之后*要执行的操作。每个阶段都可以报告错误条件，这会阻止进一步执行拦截器。但是，当发生这种情况时，已经调用的每个拦截器的*之后*步骤会以相反的顺序执行。拦截器之间的框架可以透明地执行其他操作，例如导出错误率或性能指标。这种架构导致了在每个阶段执行的逻辑的清晰分离，从而增加了简单性和可靠性。'
- en: '![A control flow in a potential framework for RPC backends; the typical steps
    are encapsulated in predefined interceptors and authorization is highlighted as
    an example](assets/bsrs_1201.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![RPC后端潜在框架中的控制流；典型步骤封装在预定义的拦截器中，授权作为示例突出显示](assets/bsrs_1201.png)'
- en: 'Figure 12-1\. A control flow in a potential framework for RPC backends: the
    typical steps are encapsulated in predefined interceptors and authorization is
    highlighted as an example'
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-1。RPC后端潜在框架中的控制流：典型步骤封装在预定义的拦截器中，授权作为示例突出显示
- en: In this example, the *before* stage of the logging interceptor could log the
    call, and the *after* stage could log the status of the operation. Now, if the
    request is unauthorized, the RPC logic doesn’t execute, but the “permission denied”
    error is properly logged. Afterward, the system calls the authentication and logging
    interceptors’ *after* stages (even if they are empty), and only then does it send
    the error to the client.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，日志拦截器的*之前*阶段可以记录调用，*之后*阶段可以记录操作的状态。现在，如果请求未经授权，RPC逻辑不会执行，但是“权限被拒绝”的错误会被正确记录。之后，系统调用认证和日志拦截器的*之后*阶段（即使它们是空的），然后才将错误发送给客户端。
- en: Interceptors share state through a *context object* that they pass to each other.
    For example, the authentication interceptor’s *before* stage can handle all the
    cryptographic operations associated with certificate handling (note the increased
    security from reusing a specialized crypto library rather than reimplementing
    one yourself). The system then wraps the extracted and validated information about
    the caller in a convenience object, which it adds to the context. Subsequent interceptors
    can easily access this object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器通过它们传递给彼此的*上下文对象*共享状态。例如，认证拦截器的*之前*阶段可以处理与证书处理相关的所有加密操作（注意从重用专门的加密库而不是重新实现一个来提高安全性）。然后系统将提取和验证的关于调用者的信息包装在一个方便的对象中，并将其添加到上下文中。随后的拦截器可以轻松访问此对象。
- en: The framework can then use the context object to track request execution time.
    If at any stage it becomes obvious that the request won’t complete before the
    deadline, the system can automatically cancel the request. You can increase service
    reliability by notifying the client quickly, which also conserves resources.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后框架可以使用上下文对象来跟踪请求执行时间。如果在任何阶段明显地请求不会在截止日期之前完成，系统可以自动取消请求。通过快速通知客户端，还可以提高服务的可靠性，这也节省了资源。
- en: A good framework should also enable you to work with dependencies of the RPC
    backend—for example, another backend that’s responsible for storing logs. You
    might register these as either soft or hard dependencies, and the framework can
    constantly monitor their availability. When it detects the unavailability of a
    hard dependency, the framework can stop the service, report itself as unavailable,
    and automatically redirect traffic to other instances.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的框架还应该使您能够处理RPC后端的依赖关系，例如负责存储日志的另一个后端。您可以将这些注册为软依赖或硬依赖，框架可以不断监视它们的可用性。当它检测到硬依赖不可用时，框架可以停止服务，报告自身不可用，并自动将流量重定向到其他实例。
- en: Sooner or later, overload, network issues, or some other issue will result in
    a dependency being unavailable. In many cases, it would be reasonable to retry
    the request, but implement retries carefully in order to avoid a *cascading failure*
    (akin to falling dominoes).^([1](ch12.html#ch12fn1)) The most common solution
    is to retry with an *exponential backoff*.^([2](ch12.html#ch12fn2)) A good framework
    should provide support for such logic, rather than requiring the developer to
    implement the logic for every RPC call.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 迟早，过载、网络问题或其他问题将导致依赖不可用。在许多情况下，重试请求是合理的，但要小心实施重试，以避免*级联故障*（类似于多米诺骨牌的倒塌）。^([1](ch12.html#ch12fn1))最常见的解决方案是使用*指数退避*。^([2](ch12.html#ch12fn2))一个好的框架应该提供对这样的逻辑的支持，而不是要求开发人员为每个RPC调用实现逻辑。
- en: A framework that gracefully handles unavailable dependencies and redirects traffic
    to avoid overloading the service or its dependencies naturally improves the reliability
    of both the service itself and the entire ecosystem. These improvements require
    minimal involvement from developers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优雅处理不可用依赖并重定向流量以避免过载服务或其依赖的框架自然地提高了服务本身和整个生态系统的可靠性。这些改进需要开发人员的最少参与。
- en: Example code snippets
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例代码片段
- en: Examples [12-1](#example_onetwo_onedot_initial_type_defi) through [12-3](#example_onetwo_threedot_example_logging)
    demonstrate the RPC backend developer’s perspective of working with a security-
    or reliability-focused framework. The examples are in Go and use [Google Protocol
    Buffers](https://oreil.ly/yzES2).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 示例[12-1](#example_onetwo_onedot_initial_type_defi)到[12-3](#example_onetwo_threedot_example_logging)演示了RPC后端开发人员与安全或可靠性框架合作的视角。这些示例使用Go并使用[Google
    Protocol Buffers](https://oreil.ly/yzES2)。
- en: Example 12-1\. Initial type definitions (the before stage of an interceptor
    can modify the context; for example, the authentication interceptor can add verified
    information about the caller)
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 12-1示例。初始类型定义（拦截器的前阶段可以修改上下文；例如，身份验证拦截器可以添加有关调用者的验证信息）
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Example 12-2\. Example authorization interceptor that allows only requests from
    whitelisted users
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 12-2示例。示例授权拦截器，只允许来自白名单用户的请求
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example 12-3\. Example logging interceptor that logs every incoming request
    (before stage) and then logs all the failed requests with their status (after
    stage); WithAttemptCount is a framework-provided RPC call option that implements
    exponential backoff
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 12-3示例。示例日志拦截器，记录每个传入请求（阶段前）然后记录所有失败的请求及其状态（阶段后）；WithAttemptCount是一个由框架提供的RPC调用选项，实现指数退避
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Common Security Vulnerabilities
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见安全漏洞
- en: In large codebases, a handful of classes account for the majority of security
    vulnerabilities, despite ongoing efforts to educate developers and introduce code
    review. OWASP and SANS publish lists of common vulnerability classes. [Table 12-1](#top_onezero_most_common_vulnerability_r)
    lists the 10 most common vulnerability risks according to [OWASP](https://oreil.ly/bUZq8),
    along with some potential approaches to mitigate each at a framework level.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型代码库中，少数类占据了大部分安全漏洞，尽管不断努力教育开发人员并引入代码审查。OWASP和SANS发布了常见漏洞类别的列表。[表12-1](#top_onezero_most_common_vulnerability_r)列出了根据[OWASP](https://oreil.ly/bUZq8)列出的前10个最常见的漏洞风险，以及在框架级别上缓解每个漏洞的一些潜在方法。
- en: Table 12-1\. Top 10 most common vulnerability risks according to OWASP
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表12-1。根据OWASP列出的前10个最常见的漏洞风险
- en: '| OWASP top 10 vulnerability | Framework hardening measures |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| OWASP前10大漏洞 | 框架加固措施 |'
- en: '| --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [SQL] Injection | `TrustedSQLString` (see the following section). |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| [SQL]注入 | `TrustedSQLString`（请参阅下一节）。|'
- en: '| Broken authentication | Require authentication using a well-tested mechanism
    like OAuth before routing a request to the application. (See [“Example: Framework
    for RPC Backends”](#example_framework_for_rpc_backends).) |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 损坏的身份验证 | 在将请求路由到应用程序之前，要求使用像OAuth这样经过充分测试的机制进行身份验证。（参见[“示例：RPC后端框架”](#example_framework_for_rpc_backends)。）|'
- en: '| Sensitive data exposure | Use distinct types (instead of strings) to store
    and handle sensitive data like credit card numbers. This approach can restrict
    serialization to prevent leaks and enforce appropriate encryption. Frameworks
    can additionally enforce transparent in-transit protection, like HTTPS with LetsEncrypt.
    Cryptographic APIs such as [Tink](https://oreil.ly/38Vpd) can encourage appropriate
    secret storage, such as loading keys from a cloud key management system instead
    of a configuration file. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 敏感数据泄露 | 使用不同的类型（而不是字符串）来存储和处理信用卡号等敏感数据。这种方法可以限制序列化以防止泄漏并强制适当的加密。框架还可以强制执行透明的传输保护，如使用LetsEncrypt的HTTPS。加密API，如[Tink](https://oreil.ly/38Vpd)，可以鼓励适当的秘密存储，例如从云密钥管理系统加载密钥，而不是从配置文件加载。|'
- en: '| XML external entities (XXE) | Use an XML parser without XXE enabled; ensure
    this risky feature is disabled in libraries that support it.^([a](ch12.html#ch12fn3))
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| XML外部实体（XXE）|使用未启用XXE的XML解析器；确保支持它的库中禁用这个风险特性。^([a](ch12.html#ch12fn3))|'
- en: '| Broken access control | This is a tricky problem, because it’s often application-specific.
    Use a framework that requires every request handler or RPC to have well-defined
    access control restrictions. If possible, pass end-user credentials to the backend,
    and enforce an access control policy in the backend. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|破损的访问控制|这是一个棘手的问题，因为它通常是特定于应用程序的。使用一个要求每个请求处理程序或RPC具有明确定义的访问控制限制的框架。如果可能的话，将最终用户凭据传递到后端，并在后端强制执行访问控制策略。|'
- en: '| Security misconfiguration | Use a technology stack that provides secure configurations
    by default and restricts or doesn’t allow risky configuration options. For example,
    use a web framework that does not print error information in production. Use a
    single flag to enable all debug features, and set up your deployment and monitoring
    infrastructure to ensure this flag is not enabled for public users. The `environment`
    flag in Rails is one example of this approach. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|安全配置错误|使用默认提供安全配置并限制或不允许风险配置选项的技术堆栈。例如，使用一个在生产中不打印错误信息的Web框架。使用一个标志来启用所有调试功能，并设置部署和监控基础设施以确保这个标志不对公共用户启用。Rails中的`environment`标志就是这种方法的一个例子。|'
- en: '| Cross-site scripting (XSS) | Use an XSS-hardened template system (see [“Preventing
    XSS: SafeHtml”](#preventing_xss_safehtml)). |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '|跨站脚本（XSS）|使用XSS强化的模板系统（参见[“预防XSS：SafeHtml”](#preventing_xss_safehtml)）。|'
- en: '| Insecure deserialization | Use deserialization libraries that are built for
    handling untrusted inputs, such as [Protocol Buffers](https://oreil.ly/hlezU).
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|不安全的反序列化|使用专为处理不受信任输入而构建的反序列化库，例如[Protocol Buffers](https://oreil.ly/hlezU)。|'
- en: '| Using components with known vulnerabilities | Choose libraries that are popular
    and actively maintained. Do not pick components that have a history of unfixed
    or slowly fixed security issues. Also see [“Lessons for Evaluating and Building
    Frameworks”](#lessons_for_evaluating_and_building_fra). |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|使用已知漏洞的组件|选择受欢迎且积极维护的库。不要选择有未修复或缓慢修复安全问题历史的组件。另请参见[“评估和构建框架的教训”](#lessons_for_evaluating_and_building_fra)。|'
- en: '| Insufficient logging & monitoring | Instead of relying on ad hoc logging,
    log and monitor requests and other events as appropriate in a low-level library.
    See the logging interceptor described in the previous section for an example.
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|日志记录和监控不足|不要依赖于临时日志记录，适当地记录和监控请求和其他事件在低级库中。有关示例，请参见前一节中描述的日志拦截器。|'
- en: '| ^([a](ch12.html#ch12fn3-marker)) See the [XXE Prevention Cheat Sheet](https://oreil.ly/AOYev)
    for more information. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|^([a](ch12.html#ch12fn3-marker))有关更多信息，请参见[XXE预防备忘单](https://oreil.ly/AOYev)。|'
- en: 'SQL Injection Vulnerabilities: TrustedSqlString'
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL注入漏洞：TrustedSqlString
- en: '[SQL injection](https://xkcd.com/327) is a common class of security vulnerability.
    When untrustworthy string fragments are inserted into a SQL query, attackers can
    potentially inject database commands. The following is a simple password reset
    web form:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQL注入](https://xkcd.com/327)是一种常见的安全漏洞类别。当不可信的字符串片段被插入到SQL查询中时，攻击者可能会注入数据库命令。以下是一个简单的密码重置网页表单：'
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, the user’s request is directed to a backend with an unguessable
    `reset_token` specific to their account. However, because of the string concatenation,
    a malicious user could craft a custom `reset_token` with extra SQL commands (such
    as `' or username='admin)` and *inject* this token into the backend. The result
    could reset the password hash of a different user—in this case, the admin account.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，用户的请求被定向到一个具有与其帐户特定的不可猜测的`reset_token`的后端。然而，由于字符串连接，恶意用户可以制作一个带有额外SQL命令（例如`'
    or username='admin`）的自定义`reset_token`并将其*注入*到后端。结果可能会重置不同用户的密码哈希—在这种情况下是管理员帐户。
- en: 'SQL injection vulnerabilities can be harder to spot in more complicated codebases.
    The database engine can help you prevent SQL injection vulnerabilities by providing
    bound parameters and prepared statements:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的代码库中，SQL注入漏洞可能更难以发现。数据库引擎可以通过提供绑定参数和预编译语句来帮助您防止SQL注入漏洞：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, merely establishing a guideline to use prepared statements does not
    result in a scalable security process. You would need to educate every developer
    about this rule, and security reviewers would have to review all application code
    to ensure consistent use of prepared statements. Instead, you can design the database
    API so that mixing user input and SQL becomes impossible by design. For example,
    you can create a separate type called `TrustedSqlString` and enforce by construction
    that all SQL query strings are created from developer-controlled input. In Go,
    you could implement the type as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅建立一个使用预编译语句的准则并不能导致可扩展的安全流程。您需要教育每个开发人员遵守这个规则，并且安全审查人员需要审查所有应用程序代码，以确保一致使用预编译语句。相反，您可以设计数据库API，使用户输入和SQL的混合在设计上变得不可能。例如，您可以创建一个名为`TrustedSqlString`的单独类型，并通过构造强制执行所有SQL查询字符串都是由开发人员控制的输入创建的。在Go中，您可以实现该类型如下：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This implementation guarantees by construction that the contents of `q.sql`
    are entirely concatenated from string literals present in your source code, and
    the user cannot provide string literals. To enforce this contract at scale, you
    can use a language-specific mechanism to make sure `AppendLiteral` is called only
    with string literals. For example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 该实现通过构造保证了`q.sql`的内容完全是从您的源代码中存在的字符串字面量连接而成的，用户无法提供字符串字面量。为了在规模上强制执行这个合同，您可以使用一种特定于语言的机制，确保`AppendLiteral`只能与字符串字面量一起调用。例如：
- en: In Go
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go
- en: Use a package-private type alias (`stringLiteral`). Code outside the package
    cannot refer to this alias; however, string literals are implicitly converted
    to this type.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包私有类型别名（`stringLiteral`）。包外的代码不能引用此别名；但是，字符串字面量会被隐式转换为这种类型。
- en: In Java
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java
- en: Use the [Error Prone](https://errorprone.info) code checker, which provides
    a `@CompileTimeConstant` annotation for parameters.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: In C++
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Use a template constructor that depends on each character value in the string.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: You can find similar mechanisms for other languages.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: You can’t build some features—like a data analytics application that by design
    runs arbitrary SQL queries provided by the user who owns the data—using just compile-time
    constants. To handle complicated use cases, at Google we allow a way to bypass
    the type restrictions with approval from a security engineer. For example, our
    database API has a separate package, `unsafequery`, that exports a distinct `unsafequery.String`
    type, which can be constructed from arbitrary strings and appended to SQL queries.
    Only a small fraction of our queries use the unchecked APIs. The burden of reviewing
    new uses of SQL queries that are not inherently safe and other restricted API
    patterns is handled by one (rotating) engineer on a part-time basis, for hundreds
    to thousands of active developers. See [“Lessons for Evaluating and Building Frameworks”](#lessons_for_evaluating_and_building_fra)
    for other benefits of reviewed exemptions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Preventing XSS: SafeHtml'
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The type-based safety approach we described in the previous section is not specific
    to SQL injection. Google uses a more complex version of the same design to reduce
    cross-site scripting vulnerabilities in web applications.^([3](ch12.html#ch12fn4))
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: At their core, XSS vulnerabilities occur when a web application renders untrustworthy
    input without appropriate sanitization. For example, an application might interpolate
    an attacker-controlled `$address` value into an HTML snippet such as `<div>$address</div>`,
    which is shown to another user. An attacker can then set `$address` to `<script>exfiltrate_user_data();</script>`
    and execute arbitrary code in the context of another user’s page.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: HTML does not have the equivalent of binding query parameters. Instead, untrustworthy
    values must be appropriately sanitized or escaped before they are inserted into
    an HTML page. Furthermore, different HTML attributes and elements have different
    semantics, so application developers have to treat values differently depending
    on the context in which they appear. For example, an attacker-controlled URL can
    cause code execution with the `javascript:` scheme.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: A type system can capture these requirements by introducing different types
    for values meant for different contexts—for example, `SafeHtml` to represent the
    contents of an HTML element, and `SafeUrl` for URLs that are safe to navigate
    to. Each of the types is a (immutable) wrapper around a string; the contracts
    are upheld by the constructors available for each type. The constructors make
    up the trusted codebase that’s responsible for ensuring the security properties
    of the application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Google has created different builder libraries for different use cases. Individual
    HTML elements can be constructed with builder methods that require the correct
    type for each attribute value, and `SafeHtml` for the element contents. The template
    system with strict contextual escaping guarantees the `SafeHtml` contract for
    more complicated HTML. That system does the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Parses the partial HTML in the template
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determines the context for each substitution point
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either requires the program to pass in a value of the correct type, or correctly
    escapes or sanitizes untrusted string values
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, if you have the following Closure Template:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'trying to use a string value for `$url` will fail:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Instead, the developer has to provide a `TrustedResourceUrl` value, e.g.:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If HTML originates from an untrusted source, you won’t want to embed it into
    your application’s web UI, since doing so would result in an easily exploitable
    XSS vulnerability. Instead, you can use an HTML sanitizer that parses the HTML
    and performs runtime checks to determine that each value meets its contract. The
    sanitizer removes elements that do not meet their contract, or elements for which
    it is impossible to check the contract at runtime. You can also use a sanitizer
    to interoperate with other systems that don’t use safe types, because many HTML
    fragments are unchanged by sanitization.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果HTML来自不受信任的来源，您不希望将其嵌入到应用程序的Web UI中，因为这样做会导致易受攻击的XSS漏洞。相反，您可以使用HTML清理器解析HTML并执行运行时检查，以确定每个值是否符合其合同。清理器会删除不符合其合同的元素，或者无法在运行时检查合同的元素。您还可以使用清理器与不使用安全类型的其他系统进行交互，因为许多HTML片段在清理过程中保持不变。
- en: Different HTML construction libraries target different developer productivity
    and code readability tradeoffs. However, they all enforce the same contract and
    should be equally trustworthy (apart from any bugs in their trusted implementations).
    In fact, to reduce the maintenance burden at Google, we code-generate the builder
    functions in various languages from a declarative configuration file. This file
    lists HTML elements and the required contracts for the values of each attribute.
    Some of our HTML sanitizers and template systems use the same configuration file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的HTML构建库针对不同的开发人员生产力和代码可读性权衡。但是，它们都强制执行相同的合同，并且应该同样值得信赖（除了它们受信任的实现中的任何错误）。实际上，为了减少谷歌的维护负担，我们从声明性配置文件中为各种语言代码生成构建器函数。该文件列出了HTML元素和每个属性值的所需合同。我们的一些HTML清理器和模板系统使用相同的配置文件。
- en: A mature open source implementation of safe types for HTML is available in [Closure
    Templates](https://oreil.ly/6x6Yb), and there is an effort underway to introduce
    [type-based security](https://oreil.ly/VrN4w) as a web standard.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Closure Templates](https://oreil.ly/6x6Yb)中提供了成熟的开源安全类型实现，目前正在进行引入[基于类型的安全性](https://oreil.ly/VrN4w)的工作，作为Web标准。
- en: Lessons for Evaluating and Building Frameworks
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估和构建框架的教训
- en: The previous sections discussed how to structure libraries to establish security
    and reliability properties. However, you can’t elegantly express all such properties
    with API design, and in some cases you can’t even change the API easily—for example,
    when interacting with the standardized DOM API exposed by a web browser.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前几节讨论了如何构建库以建立安全性和可靠性属性。但是，并非所有这样的属性都可以通过API设计优雅地表达，有些情况下甚至无法轻松更改API，例如与Web浏览器公开的标准化DOM
    API交互时。
- en: Instead, you can introduce compile-time checks to prevent developers from using
    risky APIs. Plug-ins for popular compilers, such as [Error Prone](https://errorprone.info)
    for Java and [Tsetse](https://tsetse.info) for TypeScript, can prohibit risky
    code patterns.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可以引入编译时检查，以防止开发人员使用风险API。流行编译器的插件，如Java的[Error Prone](https://errorprone.info)和TypeScript的[Tsetse](https://tsetse.info)，可以禁止危险的代码模式。
- en: Our experience has shown that compiler errors provide immediate and actionable
    feedback. Tools running on an opt-in basis (like linters) or at code review time
    provide feedback much later. By the time code is sent for review, developers usually
    have a finished, working unit of code. Learning that you need to perform some
    rearchitecting in order to use a strictly typed API that late in the development
    process can be frustrating.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的经验表明，编译器错误提供了即时和可操作的反馈。在代码审查时运行的工具（如linter）或在代码审查时提供的反馈要晚得多。到代码发送进行审查时，开发人员通常已经有了一个完成的、可工作的代码单元。在开发过程的这么晚阶段得知需要进行一些重新架构才能使用严格类型的API可能会令人沮丧。
- en: It’s much easier to equip developers with compiler errors or faster feedback
    mechanisms like IDE plug-ins that underline problematic code. Typically, developers
    iterate through compilation issues quickly, and already have to fix other compiler
    diagnostics like trivial misspellings and syntactic errors. Because the developers
    are already working on the specific lines of code affected, they have full context,
    so making changes is easier—for example, changing the type of a string to `SafeHtml`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 向开发人员提供编译器错误或更快的反馈机制（如IDE插件，可以标出有问题的代码）要容易得多。通常，开发人员会快速解决编译问题，并且已经必须修复其他编译器诊断，如拼写错误和语法错误。因为开发人员已经在处理受影响的特定代码行，他们有完整的上下文，所以进行更改更容易，例如将字符串的类型更改为`SafeHtml`。
- en: You can improve the developer experience even further by suggesting automatic
    fixes that work as a starting point for a safe solution. For example, when you
    detect a call to a SQL query function, you can automatically insert a call to
    `TrustedSqlBuilder.fromConstant` with the query parameter. Even if the resulting
    code does not quite compile (perhaps because the query is a string variable and
    not a constant), developers know what to do, and don’t need to bother with the
    mechanical details of the API by finding the right function, adding the correct
    import declarations, and so on.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过建议自动修复，甚至可以进一步改善开发人员的体验，这些自动修复可以作为安全解决方案的起点。例如，当检测到对SQL查询函数的调用时，可以自动插入对`TrustedSqlBuilder.fromConstant`的调用，其中包含查询参数。即使生成的代码不能完全编译（也许是因为查询是字符串变量而不是常量），开发人员也知道该怎么做，无需通过找到正确的函数、添加正确的导入声明等来烦恼API的机械细节。
- en: In our experience, as long as the feedback cycle is quick, and fixing each pattern
    is relatively easy, developers embrace inherently safe APIs much more readily—even
    when we can’t prove that their code was insecure, or when they do a good job of
    writing secure code using the unsafe APIs. Our experience contrasts with existing
    research literature, which focuses on reducing the false-positive and false-negative
    rates.^([4](ch12.html#ch12fn5))
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的经验，只要反馈周期快，修复每个模式相对容易，开发人员就会更愿意接受固有安全的API，即使我们无法证明他们的代码是不安全的，或者他们在使用不安全的API编写安全代码时做得很好。我们的经验与现有的研究文献形成对比，后者侧重于降低误报和漏报率。([4](ch12.html#ch12fn5))
- en: We’ve found that focusing on those rates often results in complicated checkers
    that take much longer to produce findings. For example, a check might have to
    analyze whole-program data flows across a complicated application. It’s often
    difficult to explain how to remove the issue that the static analysis detects
    to developers, as the workings of the checker are much harder to explain than
    a simple syntactic property. Understanding a finding takes as much work as tracking
    down a bug in GDB (the GNU Debugger). On the other hand, fixing a type safety
    error at compile time while writing new code is usually not much harder than fixing
    a trivial type error.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现，专注于这些速率通常会导致复杂的检查器，需要更长时间才能发现问题。例如，一个检查可能需要分析复杂应用程序中的整个程序数据流。通常很难解释如何从静态分析检测到的问题中删除问题，因为检查器的工作方式比简单的语法属性要难得多。理解一个发现需要和在GDB（GNU调试器）中追踪错误一样多的工作。另一方面，在编写新代码时在编译时修复类型安全错误通常并不比修复微不足道的类型错误困难得多。
- en: Simple, Safe, Reliable Libraries for Common Tasks
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单、安全、可靠的常见任务库
- en: 'Building a safe library that covers all possible use cases and handles each
    reliably can be very challenging. For example, an application developer working
    on an HTML templating system might write the following template:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个安全的库，涵盖所有可能的用例并可靠地处理每个用例可能非常具有挑战性。例如，一个在HTML模板系统上工作的应用程序开发人员可能会编写以下模板：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To be XSS-proof, if `username` is attacker-controlled, the template system
    must nest three different layers of context: a single-quoted string, inside JavaScript,
    inside an attribute in an HTML element. Creating a template system that can handle
    all possible combinations of corner cases is complicated, and using that system
    won’t be straightforward. In other domains, this issue can grow even more complex.
    For example, business needs might dictate complex rules about who can perform
    an action and who cannot. Unless your authorization library is as expressive (and
    as hard to analyze) as a general-purpose programming language, you might not be
    able to meet all developer needs.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止XSS攻击，如果“用户名”受攻击者控制，模板系统必须嵌套三种不同的上下文层：单引号字符串，JavaScript内部，HTML元素属性内部。创建一个可以处理所有可能的边缘情况组合的模板系统是复杂的，并且使用该系统不会简单。在其他领域，这个问题可能变得更加复杂。例如，业务需求可能会规定谁可以执行动作，谁不能。除非您的授权库像通用编程语言一样具有表达力（并且难以分析），您可能无法满足所有开发人员的需求。
- en: Instead, you can start with a simple, small library that covers only common
    use cases but is easier to use correctly. Simple libraries are easier to explain,
    document, and use. These qualities reduce developer friction and may help you
    convince other developers to adopt the secure-by-design library. In some cases,
    it might make sense to offer different libraries optimized for different use cases.
    For example, you might have both HTML templating systems for complicated pages
    and builder libraries for short snippets.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可以从一个简单的、小型的库开始，只涵盖常见用例，但更容易正确使用。简单的库更容易解释、文档化和使用。这些特性减少了开发人员的摩擦，并可能帮助您说服其他开发人员采用安全设计的库。在某些情况下，提供针对不同用例进行优化的不同库可能是有意义的。例如，您可能既有用于复杂页面的HTML模板系统，也有用于短片段的构建器库。
- en: 'You can accommodate other use cases with expert-reviewed access to an unconstrained,
    risky library that bypasses safety guarantees. If you see repeated similar requests
    for a use case, you can support that feature in the inherently safe library. As
    we observed in [“SQL Injection Vulnerabilities: TrustedSqlString”](#sql_injection_vulnerabilities_trustedsq),
    the review load is usually manageable.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过专家审查的方式满足其他用例，访问一个不受限制的、风险的库，绕过安全保证。如果您看到类似的重复请求，您可以在固有安全的库中支持该功能。正如我们在[“SQL注入漏洞：TrustedSqlString”](#sql_injection_vulnerabilities_trustedsq)中观察到的，审查负载通常是可以管理的。
- en: 'Because the volume of review requests is relatively small, security reviewers
    can look at the code in depth and suggest extensive improvements—and the reviews
    tend to be unique use cases, which keeps reviewers motivated and prevents mistakes
    due to repetition and fatigue. Exemptions also act as a feedback mechanism: If
    developers repeatedly need exemptions for a use case, library authors should consider
    building a library for that use case.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于审查请求的数量相对较少，安全审查人员可以深入查看代码并提出广泛的改进建议——审查往往是独特的用例，这保持了审查人员的积极性，并防止了由于重复和疲劳而导致的错误。豁免也作为一个反馈机制：如果开发人员反复需要豁免某个用例，库作者应该考虑为该用例构建一个库。
- en: Rollout Strategy
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推出策略
- en: Our experience has shown that using types for security properties is very useful
    for new code. In fact, applications created in one widely used Google-internal
    web framework, which was developed from the outset with safe types for HTML, have
    had far fewer reported XSS vulnerabilities (by two orders of magnitude) than applications
    written without safe types, despite careful code review. The few reported vulnerabilities
    were caused by components of the application that did not use safe types.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的经验表明，对安全属性使用类型对于新代码非常有用。事实上，使用安全类型的谷歌内部广泛使用的一个Web框架创建的应用程序，报告的XSS漏洞要少得多（少两个数量级）比没有使用安全类型编写的应用程序，尽管进行了仔细的代码审查。少数报告的漏洞是由于应用程序的组件没有使用安全类型造成的。
- en: It is more challenging to adapt existing code to use safe types. Even if you
    are starting with a brand new codebase, you need a strategy for migrating legacy
    code—you might discover new classes of security and reliability issues you want
    to protect against, or you might need to refine existing contracts.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将现有代码调整为使用安全类型更具挑战性。即使您从头开始创建一个全新的代码库，您也需要一个迁移遗留代码的策略——您可能会发现您想要保护的新的安全性和可靠性问题类别，或者您可能需要完善现有的合同。
- en: We have experimented with several strategies for refactoring existing code;
    we discuss our two most successful approaches in the following subsections. These
    strategies require that you are able to access and modify the entire source code
    of your application. Most of Google’s source code is stored in a single repository^([5](ch12.html#ch12fn6))
    with centralized processes for making, building, testing, and submitting changes.
    Code reviewers also enforce common readability and code organization standards,
    which reduces the complexity of changing an unfamiliar codebase. In other environments,
    large-scale refactorings can be more challenging. It helps to get broad agreement
    so every code owner is willing to accept changes to their source code, which contributes
    to the goal of building a culture of security and reliability.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-116
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Google’s company-wide style guide incorporates the concept of language *readability:*
    a certification that an engineer understands Google’s best practices and coding
    style for a given language. Readability ensures a baseline for code quality. An
    engineer must either have readability in the language they’re working with, or
    get a code review from someone with readability. For particularly complex or critically
    important code, in-person code reviews can be the most productive and effective
    way to improve your codebase’s quality.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Incremental rollout
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fixing the entire codebase at once is often not feasible. Different components
    might be in different repositories, and authoring, reviewing, testing, and submitting
    a single change that touches multiple applications is often brittle and error-prone.
    Instead, at Google, we initially exempt legacy code from enforcement, and address
    existing unsafe API users one by one.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you already have a database API with a `doQuery(String sql)`
    function, you could introduce an overload, `doQuery(TrustedSqlString sql)`, and
    restrict the unsafe version to existing callers. Using the Error Prone framework,
    you can add a `@RestrictedApi(whitelistAnnotation={LegacyUnsafeStringQueryAllowed.class})`
    annotation and add the `@LegacyUnsafeStringQueryAllowed` annotation to all existing
    callers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Then, by introducing *Git hooks* that analyze every commit, you can prevent
    new code from using the string-based overload. Alternatively, you can restrict
    the visibility of the unsafe API—for example, [Bazel visibility whitelists](https://oreil.ly/ajmrr)
    would allow a user to call the API only if a security team member approves the
    pull request (PR). If your codebase is under active development, it will organically
    move toward the safe API. After you reach the point at which only a small fraction
    of callers use the deprecated string-based API, you can manually clean up the
    remainder. At that point, your code will be immune to SQL injection by design.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Legacy conversions
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also often worthwhile to consolidate all of your exemption mechanisms
    into a single function that is obvious in the source code being read. For example,
    you can create a function that takes an arbitrary string and returns a safe type.
    You can use this function to replace all calls to string-typed APIs with more
    precisely typed calls. Typically, there will be a lot fewer types than functions
    consuming them. Instead of restricting and monitoring the removal of many legacy
    APIs (for example, every DOM API that consumes a URL), you have to remove only
    a single legacy conversion function per type.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity Leads to Secure and Reliable Code
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever practical, try to keep your code clean and simple. There are a number
    of publications on this topic,^([6](ch12.html#ch12fn7)) so here we focus on two
    lightweight stories that were published in the [Google Testing Blog](https://testing.googleblog.com).
    Both stories highlight strategies for avoiding quickly increasing codebase complexity.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Avoid Multilevel Nesting
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multilevel nesting is a common anti-pattern that can lead to simple mistakes.
    If the error is in the most common code path, it will likely be captured by the
    unit tests. However, unit tests don’t always check error handling paths in multilevel
    nested code. The error might result in decreased reliability (for example, if
    the service crashes when it mishandles an error) or a security vulnerability (like
    a mishandled authorization check error).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Can you spot a bug in the code in [Figure 12-2](#errors_are_often_harder_to_spot_in_code)?
    The two versions are equivalent.^([7](ch12.html#ch12fn8))
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![Errors are often harder to spot in code with multiple levels of nesting](assets/bsrs_1202.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: Figure 12-2\. Errors are often harder to spot in code with multiple levels of
    nesting
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The “wrong encoding” and “unauthorized” errors are swapped. This bug is easier
    to see in the refactored version because the checks occur as soon as the errors
    are handled.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Eliminate YAGNI Smells
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes developers overengineer solutions by adding functionality that may
    be useful in the future, “just in case.” This goes against the [YAGNI (You Aren’t
    Gonna Need It) principle](https://oreil.ly/K4Oan), which recommends implementing
    only the code that you need. YAGNI code adds unnecessary complexity because it
    needs to be documented, tested, and maintained. Consider the following example:^([8](ch12.html#ch12fn9))
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `Human::Sleep` code must handle the case when `hibernate` is `true`, even
    though all callers should always pass `false`. In addition, callers must handle
    the returned status, even though that status should always be `OK`. Instead, until
    you need classes other than `Human`, this code can be simplified to the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the developer’s assumptions about possible requirements for future functionality
    are actually true, they can easily add that functionality later by following the
    principle of *incremental development and design*. In our example, it will be
    easier to create a `Mammal` interface with a better common API when we generalize
    based on several existing classes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, avoiding YAGNI code leads to improved reliability, and simpler
    code leads to fewer security bugs, fewer opportunities to make mistakes, and less
    developer time spent maintaining unused code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Repay Technical Debt
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is a common practice for developers to mark places that require further attention
    with TODO or FIXME annotations. In the short term, this habit can accelerate the
    delivery velocity for the most critical functionality, and allow a team to meet
    early deadlines—but it also incurs *technical debt*. Still, it’s not necessarily
    a bad practice, as long as you have a clear process (and allocate time) for repaying
    such debt.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Technical debt can include the erroneous handling of exceptional situations
    and the introduction of unnecessarily complex logic into the code (often written
    to work around other areas of technical debt). Either behavior can introduce security
    vulnerabilities and reliability issues that are rarely detected during testing
    (because of insufficient coverage of rare cases), and which consequently become
    part of the production environment.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'You can deal with technical debt in many ways. For example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Keeping dashboards with code health metrics. These can range from simple dashboards
    that show test coverage or the number and average age of TODOs, to more sophisticated
    dashboards including metrics like [*cyclomatic complexity*](https://oreil.ly/pXJBL)
    or [*maintainability index*](https://oreil.ly/_N25V).
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using analysis tools like linters to detect common code defects such as dead
    code, unnecessary dependencies, or language-specific gotchas. Often, such tools
    can also automatically fix your code.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating notifications when code health metrics drop below predefined thresholds
    or when the number of automatically detected issues is too high.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, it’s important to maintain a team culture that embraces and focuses
    on good code health. Leadership can support this culture in many ways. For example,
    you can schedule regular *fixit* weeks during which developers focus on improving
    code health and fixing outstanding bugs rather than adding new functionality.
    You can also support continuous contributions to code health within the team with
    bonuses or other forms of recognition.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Refactoring* is the most effective way to keep a codebase clean and simple.
    Even a healthy codebase occasionally needs to be refactored when you extend the
    existing feature set, change the backend, and so on.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring is particularly useful when working with old, inherited codebases.
    The first step of refactoring is measuring code coverage and increasing that coverage
    to a sufficient level.^([9](ch12.html#ch12fn10)) In general, the higher the coverage,
    the higher your confidence in the safety of refactoring. Unfortunately, even 100%
    test coverage can’t guarantee success, because the tests may not be meaningful.
    You can address this issue with other kinds of testing, such as *fuzzing,* which
    is covered in [Chapter 13](ch13.html#onethree_testing_code).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Regardless of the reasons behind refactoring, you should always follow one
    golden rule: *never mix refactoring and functional changes in a single commit
    to the code repository*. Refactoring changes are typically significant and can
    be difficult to understand. If a commit also includes functional changes, there’s
    a higher risk that an author or reviewer might overlook bugs.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: A complete overview of refactoring techniques is beyond the scope of this book.
    For more on this topic, see Martin Fowler’s excellent book^([10](ch12.html#ch12fn11))
    and the discussions of tooling for automated, large-scale refactorings provided
    by Wright et al. (2013),^([11](ch12.html#ch12fn12)) Wasserman (2013),^([12](ch12.html#ch12fn13))
    and Potvin and Levenberg (2016).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Security and Reliability by Default
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to using frameworks with strong guarantees, you can use several
    other techniques to automatically improve the security and reliability posture
    of your application, as well as that of your team culture, which you’ll read more
    about in [Chapter 21](ch21.html#twoone_building_a_culture_of_security_a).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Choose the Right Tools
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Choosing a language, framework, and libraries is a complicated task that’s
    often influenced by a combination of factors, such as these:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Integration with the existing codebase
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Availability of libraries
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skills or preferences of the developer team
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be aware of the enormous impact that language choice can have on the security
    and reliability of the project.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Use memory-safe languages
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At BlueHat Israel in February 2019, Microsoft’s Matt Miller claimed that around
    70% of all security vulnerabilities are due to memory safety issues.^([13](ch12.html#ch12fn14))
    This statistic has remained consistent over at least the last 12 years.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: In a 2016 presentation, Nick Kralevich from Google reported that 85% of all
    bugs in Android (including bugs in the kernel and other components) were caused
    by memory management errors (slide 54).^([14](ch12.html#ch12fn15)) Kralevich concluded
    that “we need to move towards memory safe languages.” By using any language with
    higher-level memory management (such as Java or Go) rather than a language with
    more memory allocation difficulties (like C/C++), you can avoid this entire class
    of security (and reliability) vulnerabilities by default. Alternatively, you can
    use code sanitizers that detect most memory management pitfalls (see [“Sanitize
    Your Code”](#sanitize_your_code)).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Use strong typing and static type checking
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a *strongly typed* language, “whenever an object is passed from a calling
    function to a called function, its type must be compatible with the type declared
    in the called function.”^([15](ch12.html#ch12fn16)) A language without that requirement
    is referred to as *weakly* or *loosely typed*. You can enforce type checking either
    during compilation (*static type checking*) or at runtime (*dynamic type checking*).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of strong typing and static type checking are especially noticeable
    when working on large codebases with multiple developers, as you can enforce invariants
    and eliminate a wide range of errors at compilation time rather than at runtime.
    This leads to more reliable systems, fewer security issues, and better-performing
    code in a production environment.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, when using dynamic type checking (for example, in Python), you
    can infer almost nothing about the code unless it has 100% test coverage—which
    is great in principle, but rarely observed in practice. Reasoning about the code
    becomes even harder in weakly typed languages, often leading to surprising behavior.
    For example, in JavaScript, every literal is by default treated as a string: `[9,
    8, 10].sort() -> [10, 8, 9]`.^([16](ch12.html#ch12fn17)) In both of these cases,
    because invariants aren’t enforced at compilation time, you can only capture mistakes
    during testing. In consequence, you more often detect reliability and security
    issues, especially in less frequently exercised code paths, in the production
    environment rather than during development.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use languages that have dynamic type checking or weak typing
    by default, we recommend using extensions like the following to improve the reliability
    of your code. These extensions offer support for stricter type checking, and you
    can incrementally add them to existing codebases:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[Pytype for Python](https://oreil.ly/_AAvo)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[TypeScript for JavaScript](https://www.typescriptlang.org)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Strong Types
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using untyped primitives (such as strings or integers) can lead to the following
    issues:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Passing conceptually invalid parameters to a function
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unwanted implicit type conversions
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Difficult-to-understand type hierarchy^([17](ch12.html#ch12fn18))
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confusing measurement units
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first situation—passing conceptually invalid parameters to a function—occurs
    if the primitive type of a function parameter does not have enough context, and
    therefore becomes confusing when it’s called. For example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: For the function `AddUserToGroup(string, string)`, it’s unclear whether the
    group name is provided as the first or the second argument.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the order of height and width in the `Rectangle (3.14, 5.67)` constructor
    call?
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does `Circle(double)` expect a radius or diameter?
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation can correct for ambiguity, but developers are still bound to make
    mistakes. Unit tests can catch most of these errors if we’ve done our due diligence,
    but some errors may surface only at runtime.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'When using strong types, you can catch these mistakes at compilation time.
    To return to our earlier example, the required calls would look like the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '`Add(User("alice"), Group("root-users"))`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rectangle(Width(3.14), Height(5.67))`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Circle(Radius(1.23))`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: where `User`, `Group`, `Width`, `Height`, and `Radius` are strong type wrappers
    around string or double primitives. This approach is less error-prone and makes
    the code more self-documenting—in this context, in the first example it’s sufficient
    to call the function `Add`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second situation, implicit type conversions may lead to the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Truncation when converting from larger to smaller integer types
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Precision loss when converting from larger to smaller floating-point types
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unexpected object creation
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some cases, a compiler will report the first two issues (for example, when
    using the `{}` direct initialization syntax in C++), but many instances will likely
    be overlooked. Using strong types protects your code from errors of this type
    that a compiler doesn’t capture.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s consider the case of the difficult-to-understand type hierarchy:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The three calls here will compile and execute, but will the outcome of the operation
    match developers’ expectations? By default, a C++ compiler attempts to implicitly
    cast (*coerce*) parameters to match function argument types. In this case, the
    compiler will attempt to match the type `Bar`, which conveniently has a single-value
    constructor taking a parameter of type `bool`. Most C++ types implicitly cast
    to `bool`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Implicit casting in constructors is sometimes intended (for example, when converting
    floating-point values to the `std::complex` class), but can be dangerous in most
    situations. To prevent dangerous outcomes, at a minimum, make single-value constructors
    *explicit*—for example, `explicit Bar(bool is_safe)`. Note that the last call
    will result in a compilation error when using `nullptr` rather than `NULL` because
    there is no implicit conversion to `bool`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, unit confusion is an endless source of mistakes. These mistakes might
    be characterized as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Harmless
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: For example, code that sets a timer for 30 seconds instead of 30 minutes because
    the programmer didn’t know what units `Timer(30)` uses.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Dangerous
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: For example, AirCanada’s [“Gimli Glider” airplane](https://oreil.ly/5r61w) had
    to make an emergency landing after ground crew calculated the necessary fuel in
    pounds instead of kilograms, leaving it with only half the required fuel.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Expensive
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: For example, scientists [lost the $125 million Mars Climate Orbiter](https://oreil.ly/ZMbIO)
    because two separate engineering teams used different units of measurement (imperial
    versus metric).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, strong types are a solution to this issue: they can encapsulate
    the unit, and represent only abstract concepts such as timestamp, duration, or
    weight. Such types typically implement the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Sensible operations
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: For example, adding two timestamps is not normally a useful operation, but subtracting
    them returns a duration that can be useful for many use cases. Adding two durations
    or weights is similarly useful.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Unit conversions
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: For example, T`imestamp::ToUnix, Duration::ToHours, Weight::ToKilograms`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Some languages provide such abstractions natively: examples include the [`time`
    package](https://golang.org/pkg/time) in Go and the [`chrono` library](http://www.wg21.link/p0355)
    in the upcoming C++20 standard. Other languages might require a dedicated implementation.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The [Fluent C++ blog](https://oreil.ly/Urmzl) has more discussion on applications
    of strong types and example implementations in C++.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Sanitize Your Code
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s very useful to automatically validate that your code is not experiencing
    any typical memory management or concurrency pitfalls. You can run these checks
    as a presubmit action for each change list or as part of a continuous build and
    test automation harness. The list of pitfalls to check is language-dependent.
    This section presents some solutions for C++ and Go.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'C++: Valgrind or Google Sanitizers'
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C++ allows for low-level memory management. As we mentioned earlier, memory
    management errors are a leading cause of security issues, and can result in the
    following failure scenarios:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Reading unallocated memory (before `new` or after `delete`)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading outside of the allocated memory (buffer overflow attack scenario)
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading uninitialized memory
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory leaks when a system loses the address of allocated memory or doesn’t
    deallocate unused memory early
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Valgrind](http://www.valgrind.org) is a popular framework that allows developers
    to catch those sorts of errors, even if unit tests don’t catch them. Valgrind
    has the benefit of providing a virtual machine that interprets a user’s binary,
    so users don’t need to recompile their code to use it. The Valgrind tool [Helgrind](https://oreil.ly/mBSSw)
    can additionally detect common synchronization errors such as these:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Misuses of the POSIX pthreads API (e.g., unlocking a not-locked mutex, or a
    mutex held by another thread)
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Potential deadlocks arising from lock ordering problems
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data races caused by accessing memory without adequate locking or synchronization
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alternatively, the [Google Sanitizers suite](https://oreil.ly/qqdMy) offers
    various components that can detect all the same issues that Valgrind’s Callgrind
    (a cache and branch prediction profiler) can detect:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: AddressSanitizer (ASan) detects memory errors (buffer overflows, use after free,
    incorrect initialization order).
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LeakSanitizer (LSan) detects memory leaks.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MemorySanitizer (MSan) detects when a system is reading uninitialized memory.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ThreadSanitizer (TSan) detects data races and deadlocks.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UndefinedBehaviorSanitizer (UBSan) detects situations that have undefined behavior
    (using misaligned pointers; signed integer overflow; converting to, from, or between
    floating-point types that will overflow the destination).
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main advantage of the Google Sanitizers suite is speed: it’s [up to 10
    times faster](https://oreil.ly/iyxQ1) than Valgrind. Popular IDEs like [CLion](https://oreil.ly/yGhh-)
    also provide first-class integration with Google Sanitizers. The next chapter
    provides more details on sanitizers and other dynamic program analysis tools.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Go: Race Detector'
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While Go is designed to disallow memory corruption issues typical to C++, it
    may still suffer from data race conditions. [Go Race Detector](https://oreil.ly/RU46m)
    can detect these conditions.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter presented several principles that guide developers toward designing
    and implementing more secure and reliable code. In particular, we recommend using
    frameworks as a powerful strategy, as they reuse proven building blocks for sensitive
    areas of code prone to reliability and security issues: authentication, authorization,
    logging, rate limiting, and communication in distributed systems. Frameworks also
    tend to improve developer productivity—both for the people writing the framework
    and the people using the framework—and make reasoning about the code much easier.
    Additional strategies for writing secure and reliable code include aiming for
    simplicity, choosing the right tools, using strong rather than primitive types,
    and continuously sanitizing the codebase.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Investing extra effort in improving security and reliability while writing software
    pays off in the long run, and reduces the effort you have to spend reviewing your
    application or fixing issues after your application is deployed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch12.html#ch12fn1-marker)) See [Chapter 22 of the SRE book](https://landing.google.com/sre/sre-book/chapters/addressing-cascading-failures/)
    for more on cascading failures.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch12.html#ch12fn2-marker)) Also described in [Chapter 22 of the SRE book](https://landing.google.com/sre/sre-book/chapters/addressing-cascading-failures/).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '^([3](ch12.html#ch12fn4-marker)) This system is described in more detail in
    Kern, Christoph. 2014\. “Securing the Tangled Web.” *Communications of the ACM*
    57(9): 38–47\. [*https://oreil.ly/drZss*](https://oreil.ly/drZss).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '^([4](ch12.html#ch12fn5-marker)) See Bessey, Al et al. 2010\. “A Few Billion
    Lines of Code Later: Using Static Analysis to Find Bugs in the Real World.” *Communications
    of the ACM* 53(2): 66–75\. doi:10.1145/1646353.1646374.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '^([5](ch12.html#ch12fn6-marker)) Potvin, Rachel, and Josh Levenberg. 2016\.
    “Why Google Stores Billions of Lines of Code in a Single Repository.” *Communications
    of the ACM* 59(7): 78–87\. doi:10.1145/2854146.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '^([6](ch12.html#ch12fn7-marker)) See, e.g., Ousterhout, John. 2018\. *A Philosophy
    of Software Design*. Palo Alto, CA: Yaknyam Press.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '^([7](ch12.html#ch12fn8-marker)) Source: Karpilovsky, Elliott. 2017\. “Code
    Health: Reduce Nesting, Reduce Complexity.” [*https://oreil.ly/PO1QR*](https://oreil.ly/PO1QR).'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '^([8](ch12.html#ch12fn9-marker)) Source: Eaddy, Marc. 2017\. “Code Health:
    Eliminate YAGNI Smells.” [*https://oreil.ly/NYr7y*](https://oreil.ly/NYr7y).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch12.html#ch12fn10-marker)) A wide selection of code coverage tools are
    available. For an overview, see the list on [Stackify](https://oreil.ly/-w6DM).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '^([10](ch12.html#ch12fn11-marker)) Fowler, Martin. 2019\. *Refactoring: Improving
    the Design of Existing Code*. Boston, MA: Addison-Wesley.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '^([11](ch12.html#ch12fn12-marker)) Wright, Hyrum et al. 2013\. “Large-Scale
    Automated Refactoring Using Clang.” *Proceedings of the 29^(th) International
    Conference on Software Maintenance*: 548–551\. doi:10.1109/ICSM.2013.93.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '^([12](ch12.html#ch12fn13-marker)) Wasserman, Louis. 2013\. “Scalable, Example-Based
    Refactorings with Refaster.” *Proceedings of the 2013 ACM Workshop on Refactoring
    Tools*: 25–28 doi:10.1145/2541348.2541355.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: ^([13](ch12.html#ch12fn14-marker)) Miller, Matt. 2019\. “Trends, Challenges,
    and Strategic Shifts in the Software Vulnerability Mitigation Landscape.” BlueHat
    IL. [*https://goo.gl/vKM7uQ*](https://goo.gl/vKM7uQ).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '^([14](ch12.html#ch12fn15-marker)) Kralevich, Nick. 2016\. “The Art of Defense:
    How Vulnerabilities Help Shape Security Features and Mitigations in Android.”
    BlackHat. [*https://oreil.ly/16rCq*](https://oreil.ly/16rCq).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '^([15](ch12.html#ch12fn16-marker)) Liskov, Barbara, and Stephen Zilles. 1974\.
    “Programming with Abstract Data Types.” *Proceedings of the ACM SIGPLAN Symposium
    on Very High Level Languages*: 50–59\. doi:10.1145/800233.807045'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: ^([16](ch12.html#ch12fn17-marker)) For many more surprises in JavaScript and
    Ruby, see [Gary Bernhardt’s lightning talk from CodeMash 2012](https://oreil.ly/M69rg).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '^([17](ch12.html#ch12fn18-marker)) See Eaddy, Mark. 2017\. “Code Health: Obsessed
    with Primitives?” [*https://oreil.ly/0DvJI*](https://oreil.ly/0DvJI).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 13\. Testing Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。测试代码
- en: By Phil Ames and Franjo Ivančić
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：Phil Ames和Franjo Ivančić
- en: with Vera Haas and Jen Barnason
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：Vera Haas和Jen Barnason
- en: No matter how careful the engineers developing your software are, some mistakes
    and overlooked edge cases are inevitable. Unexpected input combinations may trigger
    data corruption or result in availability issues like the “Query of Death” example
    in [Chapter 22 of the SRE book](https://landing.google.com/sre/sre-book/chapters/addressing-cascading-failures/).
    Coding errors can cause security problems like buffer overflows and cross-site
    scripting vulnerabilities. Put simply, there are many ways software is prone to
    failure in the real world.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无论开发软件的工程师多么小心，都不可避免地会出现一些错误和被忽视的边缘情况。意外的输入组合可能会触发数据损坏或导致像SRE书的[第22章](https://landing.google.com/sre/sre-book/chapters/addressing-cascading-failures/)中的“死亡查询”示例中的可用性问题。编码错误可能会导致安全问题，如缓冲区溢出和跨站脚本漏洞。简而言之，在现实世界中，软件容易出现许多故障。
- en: The techniques discussed in this chapter, used in different stages and contexts
    of software development, have a variety of cost–benefit profiles.^([1](ch13.html#ch13fn1))
    For example, *fuzzing*—sending random requests to a system—can help you harden
    that system in terms of both security and reliability. This technique can potentially
    help you catch information leaks and reduce serving errors by exposing the service
    to a multitude of edge cases. To identify potential bugs in systems that you can’t
    patch easily and quickly, you’ll likely need to perform thorough up-front testing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的技术在软件开发的不同阶段和环境中具有各种成本效益概况。例如，*模糊测试*——向系统发送随机请求——可以帮助您在安全性和可靠性方面加固系统。这种技术可能有助于捕捉信息泄漏，并通过暴露服务于大量边缘情况来减少服务错误。要识别无法轻松快速修补的系统中的潜在错误，您可能需要进行彻底的前期测试。
- en: Unit Testing
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: '*Unit testing* can increase system security and reliability by pinpointing
    a wide range of bugs in individual software components before a release. This
    technique involves breaking software components into smaller, self-contained “units”
    that have no external dependencies, and then testing each unit. Unit tests consist
    of code that exercises a given unit with different inputs selected by the engineer
    writing the test. Popular unit test frameworks are available for many languages;
    systems based on the [xUnit](https://oreil.ly/jZgl5) architecture are very common.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*单元测试*可以通过在发布之前找出个别软件组件中的各种错误来提高系统安全性和可靠性。这种技术涉及将软件组件分解为没有外部依赖关系的更小、自包含的“单元”，然后对每个单元进行测试。单元测试由编写测试的工程师选择的不同输入来执行给定单元的代码组成。许多语言都有流行的单元测试框架；基于[xUnit](https://oreil.ly/jZgl5)架构的系统非常常见。'
- en: Frameworks following the xUnit paradigm allow common setup and teardown code
    to execute with each individual test method. These frameworks also define roles
    and responsibilities for individual testing framework components that help standardize
    the test result format. That way, other systems have detailed information about
    what exactly went wrong. Popular examples include JUnit for Java, GoogleTest for
    C++, go2xunit for Golang, and the built-in `unittest` module in Python.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循xUnit范例的框架允许通用的设置和拆卸代码与每个单独的测试方法一起执行。这些框架还定义了各个测试框架组件的角色和职责，有助于标准化测试结果格式。这样，其他系统就可以详细了解到底出了什么问题。流行的例子包括Java的JUnit，C++的GoogleTest，Golang的go2xunit，以及Python中内置的`unittest`模块。
- en: '[Example 13-1](#example_onethree_onedot_unit_test_for_a) is a simple [unit
    test](https://oreil.ly/4Dkod) written using the GoogleTest framework.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例13-1](#example_onethree_onedot_unit_test_for_a)是使用GoogleTest框架编写的简单[单元测试](https://oreil.ly/4Dkod)。'
- en: Example 13-1\. Unit test for a function that checks whether the provided argument
    is a prime number, written using the GoogleTest framework
  id: totrans-9
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例13-1。使用GoogleTest框架编写检查提供的参数是否为质数的函数的单元测试
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Unit tests typically run locally as part of engineering workflows to provide
    fast feedback to developers before they submit changes to the codebase. In continuous
    integration/continuous delivery (CI/CD) pipelines, unit tests often run before
    a commit is merged into a repository’s mainline branch. This practice attempts
    to prevent code changes that break behavior that other teams rely on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试通常作为工程工作流程的一部分在本地运行，以便在开发人员提交更改到代码库之前为他们提供快速反馈。在持续集成/持续交付（CI/CD）流水线中，单元测试通常在提交合并到存储库的主干分支之前运行。这种做法旨在防止破坏其他团队依赖的行为的代码更改。
- en: Writing Effective Unit Tests
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写有效的单元测试
- en: The quality and comprehensiveness of unit tests can significantly impact the
    robustness of your software. Unit tests should be fast and reliable to give engineers
    immediate feedback on whether a change has broken expected behavior. By writing
    and maintaining unit tests, you can ensure that as engineers add new features
    and code, they do not break existing behavior covered by the relevant tests. As
    discussed in [Chapter 9](ch09.html#design_for_recovery), your tests should also
    be hermetic—if a test can’t repeatedly produce the same results in an isolated
    environment, you can’t necessarily rely on the test results.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的质量和全面性可以显著影响软件的健壮性。单元测试应该快速可靠，以便工程师立即得到反馈，了解更改是否破坏了预期的行为。通过编写和维护单元测试，您可以确保工程师在添加新功能和代码时不会破坏相关测试覆盖的现有行为。如[第9章](ch09.html#design_for_recovery)所讨论的，您的测试还应该是隔离的——如果测试无法在隔离的环境中重复产生相同的结果，您就不能完全依赖测试结果。
- en: Consider a system that manages the amount of storage bytes a team can use in
    a given datacenter or region. Suppose that the system allows teams to request
    additional quota if the datacenter has available unallocated bytes. A simple unit
    test might involve validating requests for quota in a set of imaginary clusters
    partially occupied by imaginary teams, rejecting requests that would exceed the
    available storage capacity. Security-focused unit tests might check how requests
    involving negative amounts of bytes are handled, or how the code handles capacity
    overflows for large transfers that result in quota values near the limit of the
    variable types used to represent them. Another unit test might check whether the
    system returns an appropriate error message when sent malicious or malformed input.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个管理团队在给定数据中心或区域可以使用的存储字节数的系统。假设该系统允许团队在数据中心有可用的未分配字节时请求额外的配额。一个简单的单元测试可能涉及验证在由虚构团队部分占用的虚构集群中请求配额的情况，拒绝超出可用存储容量的请求。以安全为重点的单元测试可能检查涉及负字节数的请求是如何处理的，或者代码如何处理容量溢出，例如导致接近用于表示它们的变量类型的限制的大型转移。另一个单元测试可能检查系统在发送恶意或格式不正确的输入时是否返回适当的错误消息。
- en: It’s often useful to test the same code with different parameters or environmental
    data, such as the initial starting quota usages in our example. To minimize the
    amount of duplicated code, unit test frameworks or languages often provide a way
    to invoke the same test with different parameters. This approach helps reduce
    duplicate boilerplate code, which can make refactoring efforts less tedious.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 经常有用的是使用不同的参数或环境数据对相同的代码进行测试，例如我们示例中的初始起始配额使用情况。为了最小化重复的代码量，单元测试框架或语言通常提供一种以不同参数调用相同测试的方法。这种方法有助于减少重复的样板代码，从而使重构工作变得不那么乏味。
- en: When to Write Unit Tests
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时编写单元测试
- en: A common strategy is to write tests shortly after writing the code, using the
    tests to verify that the code performs as expected. These tests typically accompany
    the new code in the same commit, and often encompass the cases that the engineer
    writing the code checked manually. For instance, our example storage management
    application might require that “Only billing administrators for the group that
    owns the service can request more quota.” You can translate this type of requirement
    into several unit tests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的策略是在编写代码后不久编写测试，使用测试来验证代码的预期性能。这些测试通常与新代码一起提交，并且通常包括工程师手动检查的情况。例如，我们的示例存储管理应用程序可能要求“只有拥有服务的组的计费管理员才能请求更多的配额。”您可以将这种要求转化为几个单元测试。
- en: In organizations that practice code review, a peer reviewer can double-check
    the tests to ensure they’re sufficiently robust to maintain the quality of the
    codebase. For example, a reviewer may notice that although new tests accompany
    a change, the tests may pass even if the new code is removed or inactive. If a
    reviewer can replace a statement like `if (condition_1 || condition_2)` with `if
    (false)` or `if (true)` in the new code, and none of the new tests fail, then
    the test may have overlooked important test cases. For more information about
    Google’s experience with automating this kind of *mutation testing*, see Petrović
    and Ivanković (2018).^([2](ch13.html#ch13fn2))
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行代码审查的组织中，同行审查者可以再次检查测试，以确保它们足够健壮，以维护代码库的质量。例如，审阅者可能会注意到，尽管新的测试伴随着变化，但即使删除或停用新代码，测试也可能通过。如果审阅者可以在新代码中用`if
    (false)`或`if (true)`替换类似`if (condition_1 || condition_2)`的语句，并且没有新的测试失败，那么测试可能已经忽略了重要的测试用例。有关Google自动化这种*突变测试*的经验的更多信息，请参见Petrović和Ivanković（2018）。^（[2]（ch13.html#ch13fn2））
- en: Instead of writing tests *after* writing code, test-driven development (TDD)
    methodologies encourage engineers to write unit tests based on established requirements
    and expected behaviors *before* writing code. When testing new features or bug
    fixes, the tests will fail until the behavior is completely implemented. Once
    a feature is implemented and the tests pass, engineers progress to the next feature,
    where the process repeats.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发（TDD）方法鼓励工程师根据已建立的需求和预期行为在编写代码之前编写单元测试，而不是在编写代码之后编写测试。在测试新功能或错误修复时，测试将在行为完全实现之前失败。一旦功能实现并且测试通过，工程师就会进入下一个功能，然后该过程重复。
- en: For existing projects that weren’t built using TDD models, it is common to slowly
    integrate and improve test coverage in response to bug reports or proactive efforts
    to increase confidence in a system. But even once you achieve full coverage, your
    project isn’t necessarily bug-free. Unknown edge cases or sparsely implemented
    error handling can still cause incorrect behavior.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有使用TDD模型构建的现有项目，通常会根据错误报告或积极努力增加对系统的信心来慢慢整合和改进测试覆盖率。但即使您实现了全面覆盖，您的项目也不一定是无错误的。未知的边缘情况或稀疏实现的错误处理仍可能导致不正确的行为。
- en: You can also write unit tests in response to internal manual testing or code
    review efforts. You might write these tests during standard development and review
    practices, or during milestones like a security review before a launch. New unit
    tests can verify that a proposed bug fix works as expected, and that later refactoring
    won’t reintroduce the same bug. This type of testing is particularly important
    if the code is hard to reason about and potential bugs impact security—for example,
    when writing access control checks in a system with a complicated permission model.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以根据内部手动测试或代码审查工作编写单元测试。您可能会在标准开发和审查实践中编写这些测试，或者在像发布前的安全审查这样的里程碑期间编写。新的单元测试可以验证建议的错误修复是否按预期工作，并且以后的重构不会重新引入相同的错误。如果代码难以理解并且潜在的错误会影响安全性，例如在编写具有复杂权限模型的系统中的访问控制检查时，这种类型的测试尤为重要。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In the interest of covering as many scenarios as possible, you’ll often spend
    more time writing tests than writing the code being tested—especially when dealing
    with nontrivial systems. This extra time pays off in the long run, since early
    testing yields a higher-quality codebase with fewer edge cases to debug.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能涵盖多种情景，你通常会花费更多时间编写测试而不是编写被测试的代码，特别是在处理非平凡系统时。这额外的时间从长远来看是值得的，因为早期测试会产生质量更高的代码库，减少需要调试的边缘情况。
- en: How Unit Testing Affects Code
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试如何影响代码
- en: To improve the comprehensiveness of your tests, you may need to design new code
    to include testing provisions, or refactor older code to make it more testable.
    Typically, refactoring involves providing a way to intercept calls to external
    systems. Using that introspection ability, you can test code in a variety of ways—for
    example, to verify that the code invokes the interceptor the correct number of
    times, or with the correct arguments.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进测试的全面性，你可能需要设计新的代码来包含测试规定，或者重构旧代码使其更易于测试。通常，重构涉及提供拦截对外部系统的调用的方法。利用这种内省能力，你可以以各种方式测试代码，例如验证代码调用拦截器的次数是否正确，或者使用正确的参数。
- en: Consider how you might test a piece of code that opens tickets in a remote issue
    tracker when certain conditions are met. Creating a real ticket every time the
    unit test runs would generate unnecessary noise. Even worse, this testing strategy
    may fail randomly if the issue tracker system is unavailable, violating the goal
    of quick, reliable test results.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下如何测试一段代码，当满足某些条件时在远程问题跟踪器中打开票证。每次单元测试运行时创建一个真实的票证会产生不必要的噪音。更糟糕的是，如果问题跟踪系统不可用，这种测试策略可能会随机失败，违反了快速、可靠测试结果的目标。
- en: To refactor this code, you could remove direct calls to the issue tracker service
    and replace those calls with an abstraction—for example, an interface for an `IssueTrackerService`
    object. The implementation for testing could record data when it receives calls
    such as “Create an issue,” and the test could inspect that metadata to make a
    pass or fail conclusion. By contrast, the production implementation would connect
    to remote systems and call the exposed API methods.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要重构这段代码，你可以删除对问题跟踪服务的直接调用，并用一个抽象来替换这些调用，例如一个`IssueTrackerService`对象的接口。用于测试的实现可以在接收到“创建问题”等调用时记录数据，测试可以检查元数据以做出通过或失败的结论。相比之下，生产实现将连接到远程系统并调用公开的API方法。
- en: This refactor dramatically reduces the “flakiness” of a test that depends on
    real-world systems. Because they rely on behavior that isn’t guaranteed—like an
    external dependency, or the order of elements when retrieving items from some
    container types—flaky tests are often more of a nuisance than a help. Try to fix
    flaky tests as they arise; otherwise, developers may get in the habit of ignoring
    test results when checking in changes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重构大大减少了依赖于现实世界系统的测试的“不稳定性”。因为它们依赖于不能保证的行为，比如外部依赖性，或者从某些容器类型中检索项目时元素的顺序，不稳定的测试通常更像是一种麻烦而不是帮助。尽量在出现不稳定的测试时进行修复；否则，开发人员可能会养成在提交更改时忽略测试结果的习惯。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: These abstractions and their corresponding implementations are called *mocks*,
    *stubs*, or *fakes*. Engineers sometimes use these words interchangeably, despite
    the fact that the concepts vary in implementation complexity and features, so
    it’s important to ensure everyone at your organization uses consistent vocabulary.
    If you practice code review or use style guides, you can help reduce confusion
    by providing definitions that teams can align around.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些抽象及其相应的实现被称为*模拟*、*存根*或*伪装*。工程师有时会将这些词用法混淆，尽管这些概念在实现复杂性和功能上有所不同，因此确保你的组织中的每个人都使用一致的词汇是很重要的。如果你进行代码审查或使用风格指南，你可以通过提供团队可以对齐的定义来帮助减少混淆。
- en: It’s easy to fall into the trap of overabstraction, where tests assert mechanical
    facts about the order of function calls or their arguments. Overly abstracted
    tests often don’t provide much value, as they tend to “test” the language’s control
    flow implementation rather than the behavior of the systems you care about.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易陷入过度抽象的陷阱，测试断言关于函数调用顺序或它们的参数的机械事实。过度抽象的测试通常并不提供太多价值，因为它们往往“测试”语言的控制流实现，而不是你关心的系统的行为。
- en: 'If you have to completely rewrite your tests every time a method changes, you
    may need to rethink the tests—or even the architecture of the system itself. To
    help avoid constant test rewrites, you might consider asking engineers familiar
    with the service to provide suitable fake implementations for any nontrivial testing
    needs. This solution is advantageous to both the team responsible for the system
    and the engineers testing the code: the team that owns the abstraction can ensure
    it tracks the feature set of the service as it evolves, and the team using the
    abstraction now has a more realistic component to use in its tests.^([3](ch13.html#ch13fn3))'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每次方法更改时都必须完全重写测试，你可能需要重新考虑测试，甚至是系统本身的架构。为了避免不断重写测试，你可以考虑要求熟悉服务的工程师为任何非平凡的测试需求提供合适的虚拟实现。这种解决方案对于负责系统的团队和测试代码的工程师都是有利的：拥有抽象的团队可以确保它跟踪服务的功能集随着其发展的变化，而使用抽象的团队现在有了一个更真实的组件用于测试。
- en: Integration Testing
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: '*Integration testing* moves beyond individual units and abstractions, replacing
    fake or stubbed-out implementations of abstractions like databases or network
    services with real implementations. As a result, integration tests exercise more
    complete code paths. Because you must initialize and configure these other dependencies,
    integration testing may be slower and flakier than unit testing—to execute the
    test, this approach incorporates real-world variables like network latency as
    services communicate end-to-end. As you move from testing individual low-level
    units of code to testing how they interact when composed together, the net result
    is a higher degree of confidence that the system is behaving as expected.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*集成测试*超越了单个单元和抽象，用真实的实现替换了抽象的假或存根实现，如数据库或网络服务。因此，集成测试涵盖了更完整的代码路径。由于你必须初始化和配置这些其他依赖项，集成测试可能比单元测试更慢、更不稳定——执行测试时，这种方法会将网络延迟等真实世界变量纳入其中，因为服务端到端地进行通信。当你从测试代码的单个低级单元转移到测试它们在组合在一起时的交互方式时，最终结果是对系统行为符合预期的更高程度的信心。'
- en: Integration testing takes different shapes, which are determined by the complexity
    of the dependencies they address. When the dependencies that integration testing
    needs are relatively simple, an integration test may look like a base class that
    sets up a few shared dependencies (for example, a database in a preconfigured
    state) from which other tests extend. As services grow in complexity, integration
    tests can become far more complex, requiring supervising systems to orchestrate
    the initialization or setup of dependencies to support the test. Google has teams
    focused exclusively on infrastructure that enables standardized integration test
    setup for common infrastructure services. For organizations using a continuous
    build and delivery system like [Jenkins](https://jenkins.io), integration tests
    may run either alongside or separately from unit tests, depending on the size
    of the codebase and the number of available tests in a project.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试采用不同的形式，这取决于它们所涉及的依赖项的复杂性。当集成测试需要的依赖相对简单时，集成测试可能看起来像一个设置了一些共享依赖项（例如，处于预配置状态的数据库）的基类，其他测试从中继承。随着服务复杂性的增加，集成测试可能变得更加复杂，需要监督系统来编排依赖项的初始化或设置，以支持测试。谷歌有专门致力于基础设施的团队，为常见的基础设施服务提供标准化的集成测试设置。对于使用像[Jenkins](https://jenkins.io)这样的持续构建和交付系统的组织，集成测试可以根据代码库的大小和项目中可用测试的数量，与单元测试一起运行，或者单独运行。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'As you build integration tests, keep the principles discussed in [Chapter 5](ch05.html#design_for_least_privilege)
    in mind: make sure the data and systems access requirements of the tests don’t
    introduce security risks. It can be tempting to mirror actual databases into test
    environments since the databases provide a rich set of real-world data, but you
    should avoid this anti-pattern because they may contain sensitive data that will
    be available to anyone running tests that use those databases. Such an implementation
    is inconsistent with the principle of least privilege and may pose a security
    risk. Instead, you can seed these systems with nonsensitive test data. This approach
    also makes it easy to wipe test environments to a known clean state, reducing
    the likelihood of integration test flakiness.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建集成测试时，请牢记[第5章](ch05.html#design_for_least_privilege)中讨论的原则：确保测试的数据和系统访问要求不会引入安全风险。诱人的做法是将实际数据库镜像到测试环境中，因为数据库提供了丰富的真实数据，但你应该避免这种反模式，因为它们可能包含敏感数据，将对使用这些数据库运行测试的任何人都可用。这种实现与最小特权原则不一致，可能会带来安全风险。相反，你可以使用非敏感的测试数据来填充这些系统。这种方法还可以轻松地将测试环境清除到已知的干净状态，减少集成测试不稳定性的可能性。
- en: Writing Effective Integration Tests
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写有效的集成测试
- en: Like unit tests, integration tests may be influenced by design choices in your
    code. To continue with our earlier example of an issue tracker that files tickets,
    a unit test mock may simply assert that the method was invoked to file a ticket
    with the remote service. An integration test would more likely use a real client
    library. Rather than creating spurious bugs in production, the integration test
    would communicate with a QA endpoint. Test cases would exercise the application
    logic with inputs that trigger calls to the QA instance. Supervising logic could
    then query the QA instance to verify that externally visible actions took place
    successfully from an end-to-end perspective.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与单元测试一样，集成测试可能受到代码中设计选择的影响。继续我们之前关于问题跟踪器的例子，一个单元测试模拟可能只是断言该方法被调用以向远程服务提交一个问题。而集成测试更可能使用一个真实的客户端库。与其在生产中创建虚假的错误，集成测试会与QA端点进行通信。测试用例将使用触发对QA实例的调用的输入来执行应用逻辑。监督逻辑随后可以查询QA实例，以验证从端到端的角度成功地进行了外部可见的操作。
- en: Understanding why integration tests fail when all unit tests pass can require
    a lot of time and energy. Good logging at key logical junctures of your integration
    tests can help you debug and understand where breakdowns occur. Bear in mind too
    that because integration tests go beyond individual units by examining interactions
    between components, they can tell you only a limited amount about how well those
    units will conform to your expectations in other scenarios. This is one of the
    many reasons using each type of testing in your development lifecycle adds value—one
    form of testing is often not a substitute for another.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 了解为什么集成测试失败，而所有单元测试都通过可能需要大量的时间和精力。在集成测试的关键逻辑交汇处进行良好的日志记录可以帮助你调试和理解故障发生的位置。还要记住，因为集成测试超越了单个单元，检查组件之间的交互，它们只能告诉你有关这些单元在其他场景中是否符合你的期望的有限信息。这是在开发生命周期中使用每种类型的测试的许多原因之一，因为一种测试通常不能替代另一种。
- en: 'DEEP DIVE: Dynamic Program Analysis'
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨：动态程序分析
- en: '*Program analysis* allows users to carry out a number of useful actions—for
    example, performance profiling, checking for security-related correctness, code
    coverage reporting, and dead code elimination. As discussed later in this chapter,
    you can perform program analysis *statically* to investigate software without
    executing it. Here, we focus on *dynamic* approaches. Dynamic program analysis
    analyzes software by running programs, potentially in virtualized or emulated
    environments, for purposes beyond just testing.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*程序分析*允许用户执行许多有用的操作，例如性能分析、检查与安全相关的正确性、代码覆盖报告和死代码消除。正如本章后面讨论的那样，您可以*静态*地执行程序分析来研究软件而不执行它。在这里，我们关注*动态*方法。动态程序分析通过运行程序来分析软件，可能在虚拟化或模拟环境中，用于除了测试之外的目的。'
- en: Performance profilers (which are used to find performance issues in programs)
    and code coverage report generators are the best-known types of dynamic analysis.
    The previous chapter introduced the dynamic program analysis tool [Valgrind](http://www.valgrind.org),
    which provides a virtual machine and various tools to interpret a binary and check
    whether an execution exhibits various common bugs. This section focuses on dynamic
    analysis approaches that rely on compiler support (often called *instrumentation*)
    to detect memory-related errors.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析器（用于发现程序中的性能问题）和代码覆盖报告生成器是最常见的动态分析类型。上一章介绍了动态程序分析工具[Valgrind](http://www.valgrind.org)，它提供了一个虚拟机和各种工具来解释二进制代码，并检查执行是否存在各种常见的错误。本节重点介绍依赖于编译器支持（通常称为*instrumentation*）来检测与内存相关的错误的动态分析方法。
- en: Compilers and dynamic program analysis tools let you configure instrumentation
    to collect runtime statistics on the binaries that the compilers produce, such
    as performance profiling information, code coverage information, and profile-based
    optimizations. The compiler inserts additional instructions and callbacks to a
    backend runtime library that surfaces and collects the relevant information when
    the binary is executed. Here, we focus on security-relevant memory misuse bugs
    for C/C++ programs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器和动态程序分析工具允许您配置仪器化，以收集编译器生成的二进制文件的运行时统计信息，例如性能分析信息、代码覆盖信息和基于配置的优化。当二进制文件执行时，编译器插入额外的指令和回调到后端运行时库，以显示和收集相关信息。在这里，我们关注C/C++程序的安全相关内存误用错误。
- en: 'The Google Sanitizers suite provides compilation-based dynamic analysis tools.
    They were initially developed as part of the [LLVM](https://llvm.org) compiler
    infrastructure to capture common programming mistakes, and are now supported by
    GCC and other compilers, as well. For example, [AddressSanitizer (ASan)](https://oreil.ly/NkxYL)
    finds a number of common memory-related bugs, such as out-of-bounds memory accesses,
    in C/C++ programs. Other popular sanitizers include the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Google Sanitizers套件提供了基于编译的动态分析工具。它们最初作为[LLVM](https://llvm.org)编译器基础设施的一部分开发，用于捕获常见的编程错误，并且现在也得到了GCC和其他编译器的支持。例如，[AddressSanitizer
    (ASan)](https://oreil.ly/NkxYL)可以在C/C++程序中找到许多常见的与内存相关的错误，比如越界内存访问。其他流行的sanitizers包括以下内容：
- en: '[UndefinedBehaviorSanitizer](https://oreil.ly/fRXLV)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[UndefinedBehaviorSanitizer](https://oreil.ly/fRXLV)'
- en: Performs runtime flagging of undefined behavior
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 执行未定义行为的运行时标记
- en: '[ThreadSanitizer](https://oreil.ly/b6-wy)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[ThreadSanitizer](https://oreil.ly/b6-wy)'
- en: Detects race conditions
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 检测竞争条件
- en: '[MemorySanitizer](https://oreil.ly/u9Jfh)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[MemorySanitizer](https://oreil.ly/u9Jfh)'
- en: Detects reading of uninitialized memory
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 检测未初始化内存的读取
- en: '[LeakSanitizer](https://oreil.ly/Z9O5m)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[LeakSanitizer](https://oreil.ly/Z9O5m)'
- en: Detects memory leaks and other types of leaks
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 检测内存泄漏和其他类型的泄漏
- en: As new hardware features allow tagging of memory addresses, there are [proposals](https://oreil.ly/8BXt4)
    to use those new features to further improve the performance of ASan.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新的硬件功能允许对内存地址进行标记，有[提案](https://oreil.ly/8BXt4)利用这些新功能进一步提高ASan的性能。
- en: ASan provides fast performance by building a custom, instrumented binary of
    the program under analysis. During compilation, ASan adds certain instructions
    to make callbacks into the provided sanitizer runtime. The runtime maintains metadata
    about the program execution—for example, which memory addresses are valid to access.
    ASan uses a shadow memory to record whether a given byte is safe for the program
    to access, and uses compiler-inserted instructions to check the shadow memory
    when the program tries to read or write that byte. It also provides custom memory
    allocation and deallocation (`malloc` and `free`) implementations. For example,
    the `malloc` function allocates additional memory immediately before and after
    the returned requested memory region. This creates a buffer memory region that
    allows ASan to easily report buffer overflows and underflows with precise information
    about what went wrong and where. To do so, ASan marks these regions (also called
    *red zones*) as *poisoned*. Similarly, ASan marks memory that was freed as poisoned,
    allowing you to catch use-after-free bugs easily.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ASan通过构建程序分析的自定义仪器化二进制文件来提供快速性能。在编译过程中，ASan添加了某些指令，以便调用提供的sanitizer运行时。运行时维护有关程序执行的元数据，例如哪些内存地址是有效的访问。ASan使用影子内存来记录给定字节对程序访问是否安全，并使用编译器插入的指令在程序尝试读取或写入该字节时检查影子内存。它还提供自定义内存分配和释放（`malloc`和`free`）实现。例如，`malloc`函数在返回请求的内存区域之前立即分配额外的内存。这创建了一个缓冲内存区域，使ASan能够轻松报告关于溢出和下溢的精确信息。为此，ASan将这些区域（也称为*red
    zones*）标记为*poisoned*。同样，ASan将已释放的内存标记为*poisoned*，使您能够轻松捕获使用后释放的错误。
- en: 'The following example illustrates a simple run of ASan, using the Clang compiler.
    The shell commands instrument and run a particular input file with a use-after-free
    bug, which occurs when a memory address belonging to a previously deallocated
    memory region is read. A security exploit can use this type of access as a building
    block. The option `-fsanitize=address` turns on the ASan instrumentation:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了使用Clang编译器运行ASan的简单过程。shell命令对具有使用后释放错误的特定输入文件进行插装和运行。当读取先前释放的内存区域的内存地址时，将发生使用后释放错误。安全漏洞可以利用这种类型的访问作为构建块。选项`-fsanitize=address`打开ASan插装：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After the compilation finishes, we can see the error report ASan produces when
    executing the generated binary. (For the sake of brevity, we’ve omitted the full
    ASan error message.) Note that ASan allows error reports to indicate the source
    file information, such as line numbers, by using the LLVM symbolizer, as described
    in the [“Symbolizing the Reports” section](https://oreil.ly/0VfIH) of the Clang
    documentation. As you can see in the output report, ASan finds a 1-byte use-after-free
    read access (emphasis added). The error message includes information for the original
    allocation, the deallocation, and the subsequent illegal use:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 编译完成后，当执行生成的二进制文件时，我们可以看到ASan生成的错误报告。（为了简洁起见，我们省略了完整的ASan错误消息。）请注意，ASan允许错误报告指示源文件信息，例如行号，使用LLVM符号化程序，如Clang文档中的[“符号化报告”部分](https://oreil.ly/0VfIH)所述。正如您在输出报告中所看到的，ASan发现了一个1字节的使用后释放读取访问（已强调）。错误消息包括原始分配、释放和随后的非法使用的信息：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'DEEP DIVE: Fuzz Testing'
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨：模糊测试
- en: '*Fuzz testing* (often referred to as *fuzzing*) is a technique that complements
    the previously mentioned testing strategies. Fuzzing involves using a *fuzz engine*
    (or *fuzzer*) to generate large numbers of candidate inputs that are then passed
    through a *fuzz driver* to the *fuzz target* (the code that processes the inputs).
    The fuzzer then analyzes how the system handles the input. Complex inputs handled
    by all kinds of software are popular targets for fuzzing—for example, file parsers,
    compression algorithm implementations, network protocol implementations, and audio
    codecs.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*模糊测试*（通常称为*模糊测试*）是一种补充先前提到的测试策略的技术。模糊测试涉及使用*模糊引擎*（或*模糊器*）生成大量候选输入，然后通过*模糊驱动程序*传递给*模糊目标*（处理输入的代码）。然后，模糊器分析系统如何处理输入。各种软件处理的复杂输入都是模糊测试的热门目标，例如文件解析器、压缩算法实现、网络协议实现和音频编解码器。'
- en: You can also use fuzzing to evaluate different implementations of the same functionality.
    For example, if you are considering moving from library A to library B, a fuzzer
    can generate inputs, pass them to each library for processing, and compare the
    results. The fuzzer can report any nonmatching result as a “crash,” which can
    help engineers determine what subtle behavior changes may result. This crash-on-different-outputs
    action is typically implemented as part of the fuzz driver, as seen in OpenSSL’s
    [BigNum fuzzer](https://oreil.ly/jWQsI).^([5](ch13.html#ch13fn5))
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用模糊测试来评估相同功能的不同实现。例如，如果您正在考虑从库A迁移到库B，模糊器可以生成输入，将其传递给每个库进行处理，并比较结果。模糊器可以将任何不匹配的结果报告为“崩溃”，这有助于工程师确定可能导致微妙行为变化的原因。这种在不同输出上崩溃的操作通常作为模糊驱动程序的一部分实现，如在OpenSSL的[BigNum模糊器](https://oreil.ly/jWQsI)中所见。^([5](ch13.html#ch13fn5))
- en: Since fuzzing can execute indefinitely, it’s not feasible to block every commit
    on the results of an extended test. This means that when the fuzzer finds a bug,
    that bug may already be checked in. Ideally, other testing or analysis strategies
    will have prevented the bug in the first place, so fuzzing acts as a complement
    by generating test cases that engineers may not have considered. As an added benefit,
    another unit test can use the generated input samples that identify bugs in the
    fuzz target to ensure that later changes don’t regress the fix.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模糊测试可能会无限期地执行，因此不太可能阻止每次提交都要进行扩展测试的结果。这意味着当模糊器发现错误时，该错误可能已经被检入。理想情况下，其他测试或分析策略将首先防止错误发生，因此模糊测试通过生成工程师可能没有考虑到的测试用例来作为补充。作为额外的好处，另一个单元测试可以使用在模糊目标中识别错误的生成输入样本，以确保后续更改不会使修复退化。
- en: How Fuzz Engines Work
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模糊引擎的工作原理
- en: Fuzz engines can vary in complexity and sophistication. At the low end of the
    spectrum, a technique often referred to as *dumb fuzzing* simply reads bytes from
    a random number generator and passes them to the fuzz target in an attempt to
    find bugs. Fuzz engines have grown increasingly smart through integration with
    compiler toolchains. They can now generate more interesting and meaningful samples
    by taking advantage of the compiler instrumentation features discussed earlier.
    It is considered a good industry practice to use as many fuzz engines as you can
    integrate into your build toolchain, and to monitor metrics like the percentage
    of code covered. If code coverage plateaus at some point, it’s usually worth investigating
    why the fuzzer can’t reach other areas.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊引擎的复杂性和精密度可以有所不同。在光谱的低端，一种通常称为*愚蠢模糊*的技术简单地从随机数生成器中读取字节，并将它们传递给模糊目标，以寻找错误。通过与编译器工具链的集成，模糊引擎变得越来越智能。它们现在可以利用先前讨论的编译器插装功能生成更有趣和有意义的样本。在工业实践中，使用尽可能多的模糊引擎集成到构建工具链中，并监视代码覆盖的百分比等指标被认为是一种良好的做法。如果代码覆盖在某个点停滞不前，通常值得调查为什么模糊器无法到达其他区域。
- en: Some fuzz engines accept dictionaries of interesting keywords from the specifications
    or grammars of well-specified protocols, languages, and formats (like HTTP, SQL,
    and JSON). The fuzz engine can then generate input that’s likely to be accepted
    by the program under test, since the input may simply be rejected by generated
    parser code if it contains illegal keywords. Providing a dictionary increases
    the likelihood of reaching the code you actually want to test through fuzzing.
    Otherwise, you may end up exercising code that rejects input based on invalid
    tokens and never finds any interesting bugs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一些模糊引擎接受来自规范或语法的有趣关键字字典，这些规范或语法来自规范良好的协议、语言和格式（如HTTP、SQL和JSON）。 模糊引擎可以生成可能被测试程序接受的输入，因为如果输入包含非法关键字，则生成的解析器代码可能会简单地拒绝输入。
    提供字典可以增加通过模糊测试达到实际想要测试的代码的可能性。 否则，您可能最终会执行基于无效标记拒绝输入的代码，并且永远找不到任何有趣的错误。
- en: 'Fuzz engines like [Peach Fuzzer](https://oreil.ly/_n1KP) allow a fuzz driver
    author to programmatically define the format of the input and the expected relationships
    between fields, so the fuzz engine can generate test cases that violate those
    relationships. Fuzz engines also commonly accept a set of sample input files,
    referred to as a *seed corpus*, that are representative of what the code being
    fuzzed expects. The fuzz engine then mutates these seed inputs, in addition to
    carrying out any other supported input generation strategies. Some software packages
    come with sample files (such as MP3s for audio libraries or JPEGs for image processing)
    as part of their existing test suites—these sample files are great candidates
    for a seed corpus. Otherwise, you can curate a seed corpus from real-world or
    hand-generated files. Security researchers also publish seed corpora for popular
    file formats, such as those provided by the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 像[Peach Fuzzer](https://oreil.ly/_n1KP)这样的模糊引擎允许模糊驱动程序作者以编程方式定义输入的格式和字段之间的预期关系，因此模糊引擎可以生成违反这些关系的测试用例。
    模糊引擎通常还接受一组示例输入文件，称为*种子语料库*，这些文件代表了被模糊化的代码所期望的内容。 然后，模糊引擎会改变这些种子输入，以及执行任何其他支持的输入生成策略。
    一些软件包包含示例文件（例如音频库的MP3文件或图像处理的JPEG文件）作为其现有测试套件的一部分 - 这些示例文件非常适合作为种子语料库的候选文件。 否则，您可以从真实世界或手动生成的文件中策划种子语料库。
    安全研究人员还会发布流行文件格式的种子语料库，例如以下提供的种子语料库：
- en: '[OSS-Fuzz](https://oreil.ly/K39Q2)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[OSS-Fuzz](https://oreil.ly/K39Q2)'
- en: '[The Fuzzing Project](https://oreil.ly/ywq1N)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[模糊项目](https://oreil.ly/ywq1N)'
- en: '[American Fuzzy Lop (AFL)](https://oreil.ly/mJBh1)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[美国模糊洛普（AFL）](https://oreil.ly/mJBh1)'
- en: In recent years, improvements to compiler toolchains have resulted in significant
    advancements toward making smarter fuzz engines. For C/C++, compilers such as
    LLVM Clang can instrument the code (as discussed earlier) to allow the fuzz engine
    to observe what code is executed while processing a specific sample input. When
    the fuzz engine finds a new code path, it preserves the samples that triggered
    the code path and uses them to generate future samples. Other languages or fuzz
    engines may require a specific compiler—such as afl-gcc for [AFL](https://github.com/google/AFL)
    or go-fuzz-build for the [go-fuzz engine](https://github.com/dvyukov/go-fuzz)—to
    properly trace the execution paths to increase code coverage.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，编译器工具链的改进已经在使更智能的模糊引擎方面取得了重大进展。 对于C/C++，例如LLVM Clang等编译器可以对代码进行仪器化（如前所述），以允许模糊引擎观察处理特定样本输入时执行的代码。
    当模糊引擎找到新的代码路径时，它会保留触发代码路径的样本，并使用它们来生成未来的样本。 其他语言或模糊引擎可能需要特定的编译器 - 例如[AFL](https://github.com/google/AFL)的afl-gcc或[go-fuzz引擎](https://github.com/dvyukov/go-fuzz)的go-fuzz-build，以正确跟踪执行路径以增加代码覆盖率。
- en: When a fuzz engine generates an input that triggers a crash in a sanitizer-instrumented
    code path, it records the input along with metadata extracted from the program
    in the crashed state. This metadata can include information such as a stack trace
    indicating what line of code triggered the crash, or the process’s memory layout
    at the time. This information provides engineers with details about the cause
    of the crash, which can help them understand its nature, prepare fixes, or prioritize
    bugs. For example, when an organization is considering how to prioritize fixes
    for different types of issues, a memory read access violation may be considered
    less critical than a write access violation. Such prioritization contributes to
    a culture of security and reliability (see [Chapter 21](ch21.html#twoone_building_a_culture_of_security_a)).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当模糊引擎生成触发经过消毒处理的代码路径中的崩溃的输入时，它会记录输入以及从程序中提取的元数据，这些元数据包括诸如堆栈跟踪（指示触发崩溃的代码行）或进程在那个时间的内存布局等信息。
    此信息为工程师提供了有关崩溃原因的详细信息，这有助于他们了解其性质、准备修复或优先处理错误。 例如，当组织考虑如何为不同类型的问题设置优先级时，内存读取访问违规可能被认为比写入访问违规不太重要。
    这种优先级有助于建立安全和可靠的文化（参见[第21章](ch21.html#twoone_building_a_culture_of_security_a)）。
- en: The way your program reacts when the fuzz engine triggers a potential bug depends
    on a wide variety of circumstances. A fuzz engine is most effective at detecting
    bugs if encountering them triggers consistent and well-defined events—for example,
    receiving a signal or executing a specific function when memory corruption or
    undefined behavior occurs. These functions can explicitly signal the fuzz engine
    when the system reaches a particular error state. Many of the sanitizers mentioned
    earlier work this way.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当模糊引擎触发潜在错误时，程序对其做出反应的方式取决于各种各样的情况。 如果遇到错误会触发一致和明确定义的事件，例如接收信号或在发生内存损坏或未定义行为时执行特定函数，那么模糊引擎最有效地检测错误。
    这些函数可以在系统达到特定错误状态时明确地向模糊引擎发出信号。 之前提到的许多消毒剂都是这样工作的。
- en: Some fuzz engines also allow you to set an upper time bound for processing a
    particular generated input. If, for example, a deadlock or infinite loop causes
    an input to exceed the time limit, the fuzzer categorizes the sample as “crashing.”
    It also saves that sample for further investigation so development teams can prevent
    DoS issues that might render the service unavailable.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一些模糊引擎还允许您为处理特定生成的输入设置一个上限时间。例如，如果死锁或无限循环导致输入超过时间限制，模糊器将把样本归类为“崩溃”。它还保存该样本以供进一步调查，以便开发团队可以防止可能导致服务不可用的DoS问题。
- en: 'The Heartbleed bug (CVE-2014-0160) that caused web servers to leak memory (including
    memory containing TLS certificates or cookies) can be identified relatively quickly
    by fuzzing with the right fuzz driver and sanitizer. Google’s [fuzzer-test-suite
    GitHub repository](https://oreil.ly/f1J7X) contains an example Dockerfile that
    demonstrates successful identification of the bug. Here is an excerpt of the ASan
    report for the Heartbleed bug, triggered by the `__asan_memcpy` function call
    that the sanitizer compiler plug-in inserted (emphasis added):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用正确的模糊驱动程序和消毒剂，可以相对快速地识别导致Web服务器泄漏内存（包括包含TLS证书或Cookie的内存）的Heartbleed漏洞（CVE-2014-0160）。Google的[fuzzer-test-suite
    GitHub存储库](https://oreil.ly/f1J7X)包含一个演示成功识别该漏洞的Dockerfile示例。以下是Heartbleed漏洞的ASan报告摘录，由消毒剂编译器插件插入的`__asan_memcpy`函数调用触发（重点添加）：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first portion of the output describes the type of issue (in this case, `heap-buffer-overflow`—specifically,
    a read access violation) and an easy-to-read symbolized stack trace pointing to
    the exact line of code that reads beyond the allocated buffer size. The second
    portion contains metadata about a nearby memory region and how it was allocated
    to help an engineer analyze the issue and understand how the process reached the
    invalid state.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一部分描述了问题的类型（在本例中是“堆缓冲区溢出”——具体来说是读取访问违规）和一个易于阅读的符号化堆栈跟踪，指向读取超出分配的缓冲区大小的代码行。第二部分包含了有关附近内存区域的元数据，以及如何分配这些元数据，以帮助工程师分析问题并了解进程如何达到无效状态。
- en: 'The compiler and sanitizer instrumentation make this analysis possible. However,
    this instrumentation has limits: fuzzing with sanitizers doesn’t work as well
    when some portions of the software are handwritten assembly for performance reasons.
    The compiler can’t instrument the assembly code because the sanitizer plug-ins
    operate at a higher layer. As such, the handwritten assembly code that does not
    get instrumented may be responsible for false positives or undetected bugs.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器和消毒剂仪器使这种分析成为可能。然而，这种仪器有限：当软件的某些部分是手写汇编以提高性能时，使用消毒剂进行模糊处理效果不佳。编译器无法对汇编代码进行仪器化，因为消毒剂插件在更高层操作。因此，未被仪器化的手写汇编代码可能会导致误报或未检测到的错误。
- en: Fuzzing entirely without sanitizers is possible, but it diminishes your ability
    to detect invalid program states and the metadata available to analyze a crash.
    For example, in order for fuzzing to produce any useful information if you’re
    not using a sanitizer, the program must encounter an “undefined behavior” scenario,
    and then signal this error state to the external fuzz engine (typically by crashing
    or exiting). Otherwise, the undefined behavior carries on undetected. Likewise,
    if you’re not using ASan or similar instrumentation, your fuzzer may not identify
    states where memory has been corrupted but is not used in a way that causes the
    operating system to terminate the process.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 完全不使用消毒剂进行模糊处理是可能的，但会降低您检测无效程序状态和分析崩溃时可用的元数据的能力。例如，如果您不使用消毒剂，为了使模糊处理产生任何有用的信息，程序必须遇到“未定义行为”场景，然后将此错误状态通知外部模糊引擎（通常是通过崩溃或退出）。否则，未定义的行为将继续未被检测。同样，如果您不使用ASan或类似的仪器，您的模糊器可能无法识别内存已被损坏但未被使用以导致操作系统终止进程的状态。
- en: If you are working with libraries that are only available in binary form, compiler
    instrumentation is not an option. Some fuzz engines, like American Fuzzy Lop,
    also integrate with processor emulators like QEMU to instrument interesting instructions
    at the CPU level. This type of integration may be an appealing option for binary-only
    libraries you need to fuzz, at the expense of speed. This approach allows the
    fuzz engine to understand which code paths a generated input might trigger when
    compared to another generated input, but does not provide as much bug detection
    assistance as source code builds with compiler-added sanitizer instructions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用仅以二进制形式提供的库，编译器仪器化就不是一个选择。一些模糊引擎，如American Fuzzy Lop，还与处理器模拟器（如QEMU）集成，以在CPU级别仪器化有趣的指令。这种集成可能是一个吸引人的选择，用于模糊化需要模糊化的仅以二进制形式提供的库，但会降低速度。这种方法允许模糊引擎了解生成的输入可能触发的代码路径，但与使用编译器添加的消毒剂指令构建的源代码构建一样，它不提供太多的错误检测帮助。
- en: Many modern fuzz engines, like [libFuzzer](https://oreil.ly/uRzhZ), [AFL](https://oreil.ly/gJ64J),
    and [Honggfuzz](https://oreil.ly/b418b), use some combination of the previously
    described techniques, or variations of these techniques. It’s possible to build
    a single fuzz driver that works with multiple fuzz engines. When working with
    multiple fuzz engines, it’s a good idea to make sure that you periodically move
    interesting input samples generated by each one back into the seed corpus that
    the other fuzz engines are configured to use. One engine might be successful at
    taking an input generated by another engine, mutating it, and triggering a crash.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代模糊引擎，如[libFuzzer](https://oreil.ly/uRzhZ)、[AFL](https://oreil.ly/gJ64J)和[Honggfuzz](https://oreil.ly/b418b)，使用先前描述的技术的某种组合，或这些技术的变体。可以构建一个单一的模糊驱动程序，可以与多个模糊引擎一起使用。在使用多个模糊引擎时，最好确保定期将每个引擎生成的有趣输入样本移回其他模糊引擎配置为使用的种子语料库中。一个引擎可能成功地接受另一个引擎生成的输入，对其进行变异，并触发崩溃。
- en: Writing Effective Fuzz Drivers
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写有效的模糊驱动程序
- en: 'To make these fuzzing concepts more concrete, we’ll go into more detail about
    a fuzz driver using the framework provided by LLVM’s libFuzzer engine, which is
    included with the Clang compiler. This particular framework is convenient because
    other fuzz engines (like Honggfuzz and AFL) also work with the libFuzzer entry
    point. As a fuzzer author, using this framework means you only have to write a
    single driver that implements the function prototype:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些模糊概念更具体，我们将更详细地介绍使用LLVM的libFuzzer引擎提供的框架编写模糊驱动程序的步骤，该引擎包含在Clang编译器中。这个特定的框架很方便，因为其他模糊引擎（如Honggfuzz和AFL）也可以使用libFuzzer入口点。作为模糊器作者，使用这个框架意味着您只需要编写一个实现函数原型的驱动程序：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The respective fuzz engines will then generate byte sequences and invoke your
    driver, which can pass the input to the code you want to test.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 随后的模糊引擎将生成字节序列并调用您的驱动程序，该驱动程序可以将输入传递给您想要测试的代码。
- en: 'The goal of the fuzz engines is to execute the fuzz target via the driver as
    quickly as possible with as many unique and interesting inputs as they can generate.
    To enable reproducible crashes and quick fuzzing, try to avoid the following in
    your fuzz drivers:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊引擎的目标是通过驱动尽快执行模糊目标，并生成尽可能多的独特和有趣的输入。为了实现可重现的崩溃和快速模糊，请尽量避免在模糊驱动程序中出现以下情况：
- en: Nondeterministic behavior, such as relying on random number generators or specific
    multithreading behavior.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非确定性行为，比如依赖随机数生成器或特定的多线程行为。
- en: Slow operations, like console logging or disk I/O. Instead, consider creating
    “fuzzer-friendly” builds that disable these slow operations, or using a memory-based
    filesystem.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 慢操作，如控制台日志记录或磁盘I/O。相反，考虑创建“模糊器友好”的构建，禁用这些慢操作，或者使用基于内存的文件系统。
- en: Crashing intentionally. The idea behind fuzzing is to find crashes you didn’t
    intend to have. The fuzz engine can’t disambiguate intentional crashes.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故意崩溃。模糊测试的理念是找到你没有意图发生的崩溃。模糊引擎无法区分故意的崩溃。
- en: These properties can also be desirable for the other types of testing described
    in this chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性对于本章描述的其他类型的测试也可能是理想的。
- en: You should also avoid any specialized integrity checks (like CRC32 or message
    digests) that an adversary can “fix up” in a generated input sample. The fuzz
    engine is unlikely to ever produce a valid checksum and pass the integrity check
    without specialized logic. A common convention is to use compiler preprocessor
    flags like `-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION` to enable this fuzzer-friendly
    behavior and to help reproduce crashes identified through fuzzing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该避免任何对手可以在生成的输入样本中“修复”的专门完整性检查（如CRC32或消息摘要）。模糊引擎不太可能生成有效的校验和，并在没有专门逻辑的情况下通过完整性检查。一个常见的约定是使用编译器预处理器标志，如`-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION`，以启用这种模糊器友好的行为，并帮助通过模糊测试识别出的崩溃。
- en: An Example Fuzzer
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个示例模糊器
- en: This section follows the steps of writing a fuzzer for a simple open source
    C++ library called [Knusperli](https://oreil.ly/1zV0T). Knusperli is a JPEG decoder
    that might see a wide range of input if it’s encoding user uploads or processing
    images (including potentially malicious images) from the web.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本节遵循编写一个名为[Knusperli](https://oreil.ly/1zV0T)的简单开源C++库的模糊器的步骤。Knusperli是一个JPEG解码器，如果它对用户上传的内容进行编码或处理来自网络的图像（包括潜在的恶意图像），可能会看到各种各样的输入。
- en: 'Knusperli also provides a convenient interface for us to fuzz: a function that
    accepts a sequence of bytes (the JPEG) and size parameter, as well as a parameter
    that controls which sections of the image to parse. For software that does not
    expose such a straightforward interface, you can use helper libraries like [`FuzzedDataProvider`](https://oreil.ly/HnrdZ)
    to help transform the byte sequence into useful values for the target interface.
    Our example fuzz driver targets [this function](https://oreil.ly/zTtl-):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Knusperli还为我们提供了一个方便的接口来进行模糊测试：一个接受字节序列（JPEG）和大小参数的函数，以及一个控制解析图像的哪些部分的参数。对于不提供这样直接接口的软件，您可以使用辅助库，如[`FuzzedDataProvider`](https://oreil.ly/HnrdZ)，来帮助将字节序列转换为目标接口的有用值。我们的示例模糊驱动程序针对[这个函数](https://oreil.ly/zTtl-)。
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Knusperli builds with the [Bazel build system](https://bazel.build). By modifying
    your *.bazelrc* file, you can create a convenient shorthand way to build targets
    using the various sanitizers, and build libFuzzer-based fuzzers directly. Here’s
    an example for ASan:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Knusperli使用[Bazel构建系统](https://bazel.build)。通过修改*.bazelrc*文件，您可以创建一个方便的快捷方式来使用各种消毒剂构建目标，并直接构建基于libFuzzer的模糊器。以下是ASan的示例：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At this point, you should be able to build a version of the tool with ASan
    enabled:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您应该能够构建启用了ASan的工具版本：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also add a rule to the *BUILD* file for the fuzzer we’re about to write:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为我们即将编写的模糊器在*BUILD*文件中添加规则：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Example 13-2](#example_onethree_twodot_jpeg_decoder_fu) shows what a simple
    attempt at the fuzz driver might look like.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例13-2](#example_onethree_twodot_jpeg_decoder_fu)展示了模糊驱动程序的简单尝试可能是什么样子。'
- en: Example 13-2\. jpeg_decoder_fuzzer.cc
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例13-2\. jpeg_decoder_fuzzer.cc
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can build and run the fuzz driver with these commands:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令构建和运行模糊驱动程序：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding command runs the fuzzer for five minutes using an empty input
    corpus. LibFuzzer places interesting generated samples in the *synthetic_corpus/*
    directory to use in future fuzzing sessions. You receive the following results:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令在使用空输入语料库的情况下运行模糊器五分钟。LibFuzzer将有趣的生成样本放在*synthetic_corpus/*目录中，以便在未来的模糊会话中使用。您将收到以下结果：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Adding a JPEG file—for example, the color bar pattern seen on broadcast TV—to
    the seed corpus also results in improvements. That single seed input brings >10%
    improvement in the code blocks executed (the `cov` metric):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 添加JPEG文件（例如，在广播电视上看到的彩条图案）到种子语料库中也会带来改进。这个单一的种子输入带来了执行的代码块的>10%的改进（`cov`指标）：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To reach even more code, we can use different values for the `JpegReadMode`
    parameter. The [valid values](https://oreil.ly/h4ok1) are as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步达到更多的代码，我们可以使用不同的值来设置`JpegReadMode`参数。[有效值](https://oreil.ly/h4ok1)如下：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Rather than writing three different fuzzers, we can hash a subset of the input
    and use that result to exercise different combinations of library features in
    a single fuzzer. Be careful to use enough input to create a varied hash output.
    If the file format mandates that the first *N* bytes of an input all look the
    same, use at least one more than *N* when deciding what bytes will influence which
    options to set.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与编写三种不同的模糊器不同，我们可以对输入的子集进行哈希处理，并使用该结果在单个模糊器中执行不同组合的库特性。要小心使用足够的输入来创建多样化的哈希输出。如果文件格式要求输入的前*N*个字节都看起来相同，那么在决定哪些字节会影响设置哪些选项时，请至少使用比*N*多一个的字节。
- en: Other approaches include using the previously mentioned `FuzzedDataProvider`
    to split the input, or dedicating the first few bytes of input to setting the
    library parameters. The remaining bytes are then passed as the input to the fuzz
    target. Whereas hashing the input may result in wildly different configuration
    if a single input bit changes, the alternative approaches to splitting the input
    allow the fuzz engine to better track the relationship between the selected options
    and the way the code behaves. Be mindful of how these different approaches can
    affect the usability of potential existing seed inputs. In this case, imagine
    that you create a new pseudoformat by deciding to rely on the first few input
    bytes to set the options to the library. As a result, you can no longer easily
    use all the existing JPEG files in the world as possible seed inputs, unless you
    first preprocess the files to add initial parameters.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法包括使用先前提到的`FuzzedDataProvider`来分割输入，或者将输入的前几个字节专门用于设置库参数。然后，剩余的字节作为输入传递给模糊目标。与对输入进行哈希处理可能会导致不同的配置，如果单个输入位发生变化，那么将输入拆分的替代方法允许模糊引擎更好地跟踪所选选项与代码行为方式之间的关系。要注意这些不同方法如何影响潜在现有种子输入的可用性。在这种情况下，想象一下，通过决定依赖前几个输入字节来设置库的选项，您可以创建一个新的伪格式。结果，除非您首先对文件进行预处理以添加初始参数，否则您将不再能够轻松地使用世界上所有现有的JPEG文件作为可能的种子输入。
- en: To explore the idea of configuring the library as a function of the generated
    input sample, we’ll use the number of bits set in the first 64 bytes of input
    to select a `JpegReadMode`, as illustrated in [Example 13-3](#example_onethree_threedot_fuzzing_by_sp).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索将库配置为生成输入样本的函数的想法，我们将使用输入的前64个字节中设置的位数来选择`JpegReadMode`，如[示例13-3](#example_onethree_threedot_fuzzing_by_sp)所示。
- en: Example 13-3\. Fuzzing by splitting the input
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例13-3。通过拆分输入进行模糊
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When using the color bar as the only input corpus for five minutes, this fuzzer
    gives the following results:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当将彩色条作为唯一的输入语料库使用五分钟时，这个模糊器给出了以下结果：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Executions per second have dropped because the changes enable more features
    of the library, causing this fuzz driver to reach much more code (indicated by
    the rising `cov` metric). If you run the fuzzer without any time-out limits, it
    will continue to generate inputs indefinitely until the code triggers a sanitizer
    error condition. At that point, you will see a report like the one shown earlier
    for the Heartbleed bug. You can then make code changes, rebuild, and run the fuzzer
    binary that you built with the saved artifact as a way to reproduce the crash
    or to verify that the code change will fix the issue.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒执行次数下降了，因为更改使库的更多特性生效，导致这个模糊驱动器达到了更多代码（由上升的`cov`指标表示）。如果您在没有任何超时限制的情况下运行模糊器，它将继续无限期地生成输入，直到代码触发了一个消毒器错误条件。在那时，您将看到一个类似于之前显示的Heartbleed漏洞的报告。然后，您可以进行代码更改，重新构建，并运行您使用保存的工件构建的模糊器二进制文件，以重现崩溃或验证代码更改是否会修复问题。
- en: Continuous Fuzzing
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续模糊
- en: Once you have written some fuzzers, running them regularly over a codebase as
    it’s developed can provide a valuable feedback loop to engineers. A continuous
    build pipeline can generate daily builds of fuzzers in your codebase to be consumed
    by a system that runs the fuzzers, collects crash information, and files bugs
    in an issue tracker. Engineering teams can use the results to focus on identifying
    vulnerabilities or eliminating root causes that make the service miss its SLO.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您编写了一些模糊器，定期在代码库上运行它们可以为工程师提供宝贵的反馈循环。持续构建管道可以在您的代码库中生成每日构建的模糊器，以供运行模糊器、收集崩溃信息并在问题跟踪器中提交错误。工程团队可以利用结果来专注于识别漏洞或消除导致服务未达到SLO的根本原因。
- en: 'Example: ClusterFuzz and OSSFuzz'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：ClusterFuzz和OSSFuzz
- en: '[ClusterFuzz](https://oreil.ly/10wuR) is an open source implementation of a
    scalable fuzzing infrastructure released by Google. It manages pools of virtual
    machines that run fuzzing tasks and provides a web interface to view information
    about the fuzzers. ClusterFuzz does not build fuzzers, but instead expects a continuous
    build/integration pipeline to push fuzzers to a Google Cloud Storage bucket. It
    also provides services like corpus management, crash deduplication, and lifecycle
    management for the crashes that it identifies. The heuristics ClusterFuzz uses
    for crash deduplication are based on the state of the program at the time of the
    crash. By preserving the samples that cause a crash, ClusterFuzz can also periodically
    retest these issues to determine whether they still reproduce, and automatically
    close the issue when the latest version of the fuzzer no longer crashes on the
    offending sample.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[ClusterFuzz](https://oreil.ly/10wuR)是由Google发布的可扩展模糊基础设施的开源实现。它管理运行模糊任务的虚拟机池，并提供一个Web界面来查看有关模糊器的信息。ClusterFuzz不构建模糊器，而是期望持续构建/集成管道将模糊器推送到Google
    Cloud Storage存储桶。它还提供诸如语料库管理、崩溃去重和崩溃的生命周期管理等服务。ClusterFuzz用于崩溃去重的启发式是基于崩溃时程序的状态。通过保留导致崩溃的样本，ClusterFuzz还可以定期重新测试这些问题，以确定它们是否仍然重现，并在最新版本的模糊器不再在有问题的样本上崩溃时自动关闭问题。'
- en: The ClusterFuzz web interface shows metrics you can use to understand how well
    a given fuzzer is performing. The metrics available depend on what’s exported
    by the fuzz engines integrated into your build pipeline (as of early 2020, ClusterFuzz
    supports libFuzzer and AFL). The ClusterFuzz documentation provides instructions
    for extracting code coverage information from fuzzers built with Clang code coverage
    support, then converting that information into a format you can store in a Google
    Cloud Storage bucket and display in the frontend. Using this functionality to
    explore the code covered by the fuzzer written in the previous section would be
    a good next step for determining additional improvements to the input corpus or
    fuzz driver.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ClusterFuzz网络界面显示了您可以使用的指标，以了解给定模糊器的性能如何。可用的指标取决于构建流水线中集成的模糊引擎导出的内容（截至2020年初，ClusterFuzz支持libFuzzer和AFL）。ClusterFuzz文档提供了从使用Clang代码覆盖支持构建的模糊器中提取代码覆盖信息的说明，然后将该信息转换为可以存储在Google
    Cloud Storage存储桶中并在前端显示的格式。使用此功能来探索上一节中编写的模糊器覆盖的代码将是确定输入语料库或模糊驱动程序的其他改进的下一个良好步骤。
- en: '[OSS-Fuzz](https://oreil.ly/tWlyz) combines [modern fuzzing techniques](https://oreil.ly/yIaKz)
    with a scalable distributed execution of ClusterFuzz that’s hosted on the Google
    Cloud Platform. It uncovers security vulnerabilities and stability issues, and
    reports them directly to developers—within five months of its launch in December
    2016, OSS-Fuzz had discovered [over a thousand bugs](https://oreil.ly/r-jx6),
    and since then it has found tens of thousands more.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[OSS-Fuzz](https://oreil.ly/tWlyz)将[现代模糊技术](https://oreil.ly/yIaKz)与托管在谷歌云平台上的可扩展分布式ClusterFuzz执行相结合。它发现安全漏洞和稳定性问题，并直接向开发人员报告——自2016年12月推出以来的五个月内，OSS-Fuzz已经发现了[一千多个错误](https://oreil.ly/r-jx6)，自那时以来，它已经发现了成千上万个错误。'
- en: Once a project is [integrated](https://oreil.ly/AReAc) with OSS-Fuzz, the tool
    uses continuous and automated testing to find issues only hours after modified
    code is introduced into the upstream repository, before any users are affected.
    At Google, by unifying and automating our fuzzing tools, we’ve consolidated our
    processes into a single workflow based on OSS-Fuzz. These integrated OSS projects
    also benefit from being [reviewed](https://oreil.ly/_TiJc) by both Google’s internal
    tools and external fuzzing tools. Our integrated approach increases code coverage
    and discovers bugs faster, improving the security posture of Google projects and
    the open source ecosystem.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目与OSS-Fuzz集成，该工具就会使用持续和自动化测试，在修改的代码引入上游存储库后的几小时内发现问题，而不会影响任何用户。在谷歌，通过统一和自动化我们的模糊工具，我们已经将我们的流程整合到基于OSS-Fuzz的单个工作流程中。这些集成的OSS项目还受益于谷歌内部工具和外部模糊工具的审查。我们的集成方法增加了代码覆盖率，并更快地发现错误，改善了谷歌项目和开源生态系统的安全状况。
- en: 'DEEP DIVE: Static Program Analysis'
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨：静态程序分析
- en: '*Static analysis* is a means of analyzing and understanding computer programs
    by inspecting their source code without executing or running them. Static analyzers
    parse the source code and build an internal representation of the program that’s
    suitable for automated analysis. This approach can discover potential bugs in
    source code, preferably before the code is checked in or deployed in production.
    Numerous [tools](https://oreil.ly/p3yP1) are available for various languages,
    as well as tools for cross-language analyses.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态分析*是一种分析和理解计算机程序的方法，它通过检查其源代码而不执行或运行它们。静态分析器解析源代码并构建适合自动化分析的程序的内部表示。这种方法可以在源代码中发现潜在的错误，最好是在代码被检入或部署到生产环境之前。许多[工具](https://oreil.ly/p3yP1)可用于各种语言，以及用于跨语言分析的工具。'
- en: Static analysis tools make different tradeoffs between depth of analysis versus
    cost of analyzing the source code. For example, the shallowest analyzers perform
    simple textual or abstract syntax tree (AST)–based pattern matches. Other techniques
    rely on reasoning about a program’s state-based semantic constructs, and basing
    that reasoning on the program’s control flow and data flow.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析工具在分析深度与分析源代码成本之间做出不同的权衡。例如，最浅的分析器执行简单的文本或基于抽象语法树（AST）的模式匹配。其他技术依赖于对程序的基于状态的语义构造进行推理，并基于程序的控制流和数据流进行推理。
- en: 'Tools also target different analysis tradeoffs between false positives (incorrect
    warnings) and false negatives (missed warnings). Tradeoffs are unavoidable, partially
    because of the fundamental limit to static analysis: statically verifying any
    program is an [*undecidable problem*](https://oreil.ly/4CPo_)—that is, it is not
    possible to develop an algorithm that can determine whether any given program
    will execute without violating any given property.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 工具还针对分析误报（错误警告）和漏报（遗漏警告）之间的不同分析权衡。权衡是不可避免的，部分原因是静态分析的基本限制：静态验证任何程序都是一个[*不可判定的问题*](https://oreil.ly/4CPo_)——也就是说，不可能开发出一个能够确定任何给定程序是否会执行而不违反任何给定属性的算法。
- en: Given that constraint, tool providers focus on generating useful signals for
    developers at various stages of development. Depending on the integration point
    for static analysis engines, different tradeoffs with respect to analysis speed
    and expected analysis feedback are acceptable. For example, a static analysis
    tool that’s integrated within a code review system will likely target only newly
    developed source code, and will issue precise warnings that focus on very probable
    issues. On the other hand, source code undergoing a final predeployment release
    analysis for a safety-critical program (e.g., for domains like avionics software
    or medical device software with potential governmental certification requirements)
    may require more formal and stricter analysis.^([6](ch13.html#ch13fn6))
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这一约束，工具提供商专注于在开发的各个阶段为开发人员生成有用的信号。根据静态分析引擎的集成点，对于分析速度和预期分析反馈的不同权衡是可以接受的。例如，集成在代码审查系统中的静态分析工具可能只针对新开发的源代码，并会发出专注于非常可能的问题的精确警告。另一方面，正在进行最终的预部署发布分析的源代码（例如，用于航空电子软件或具有潜在政府认证要求的医疗设备软件等领域）可能需要更正式和更严格的分析。^([6](ch13.html#ch13fn6))
- en: The following sections present static analysis techniques adapted for various
    needs during different stages of the development process. We highlight automated
    code inspection tools, abstract interpretation–based tools (this process is sometimes
    referred to as *deep static analysis*), and more resource-intensive approaches,
    such as formal methods. We also discuss how to integrate static analyzers into
    developer workflows.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分介绍了针对开发过程不同阶段的各种需求而调整的静态分析技术。我们重点介绍了自动化代码检查工具、基于抽象解释的工具（有时这个过程被称为*深度静态分析*）以及更消耗资源的方法，比如形式化方法。我们还讨论了如何将静态分析器集成到开发人员的工作流程中。
- en: Automated Code Inspection Tools
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化代码检查工具
- en: '*Automated code inspection tools* perform a syntactic analysis of source code
    with respect to language features and usage rules. These tools, commonly referred
    to as *linters*, generally don’t model complex program behaviors like interprocedural
    data flow. Because they perform relatively shallow analysis, the tools scale easily
    to arbitrary code sizes—they can often complete their source code analysis in
    about the same amount of time it takes to compile the code. Code inspection tools
    are also easily extensible—you can simply add new rules that cover many types
    of bugs, especially bugs related to language features.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*自动化代码检查工具*针对语言特性和使用规则对源代码进行了句法分析。这些工具通常被称为*linters*，通常不对程序的复杂行为进行建模，比如过程间数据流。由于它们执行的分析相对较浅，这些工具很容易扩展到任意大小的代码——它们通常可以在大约相同的时间内完成源代码分析，就像编译代码一样。代码检查工具也很容易扩展——您可以简单地添加涵盖许多类型错误的新规则，特别是与语言特性相关的错误。'
- en: Over the past few years, code inspection tools have focused on stylistic and
    readability changes, because such code improvement suggestions have a high acceptance
    rate by developers. Many organizations enforce style and format checks by default
    in order to maintain a cohesive codebase that’s easier to manage across large
    developer teams. These organizations also routinely run checks that reveal potential
    [code smells](https://oreil.ly/ONE8f) and highly likely bugs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，代码检查工具已经专注于风格和可读性的改变，因为这些代码改进建议被开发人员高度接受。许多组织默认强制执行风格和格式检查，以便在大型开发团队中维护一个更易管理的统一代码库。这些组织还定期运行检查，以揭示潜在的[代码异味](https://oreil.ly/ONE8f)和高度可能的错误。
- en: 'The following example focuses on tools that perform one particular type of
    analysis—AST pattern matching. An *AST* is a tree representation of a program’s
    source code based on the syntactic structure of the programming language. Compilers
    commonly parse a given source code input file into such a representation, and
    then manipulate that representation during the compilation process. For example,
    an AST may contain a node representing an `if-then-else` construct, which has
    three child nodes: one node for the condition of the `if` statement, one node
    representing the subtree for the `then` branch, and another node representing
    the subtree of the `else` branch.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例侧重于执行一种特定类型的分析的工具——AST模式匹配。 *AST*是程序源代码的树形表示，基于编程语言的句法结构。编译器通常将给定的源代码输入文件解析为这样的表示，并在编译过程中操纵该表示。例如，AST可能包含一个表示`if-then-else`结构的节点，该节点有三个子节点：一个节点用于`if`语句的条件，一个节点表示`then`分支的子树，另一个节点表示`else`分支的子树。
- en: '[Error Prone](https://errorprone.info) for Java and [Clang-Tidy](https://oreil.ly/qFh_k)
    for C/C++ are widely used across projects at Google. Both of these analyzers allow
    engineers to add custom checks. For example, [as of early 2018](https://oreil.ly/gKJDy),
    162 authors had submitted 733 checks to Error Prone. For certain types of bugs,
    both Error Prone and Clang-Tidy can produce suggested fixes. Some compilers (like
    Clang and MSVC) also support the community-developed [C++ core guidelines](https://oreil.ly/y2Eqd).
    With help from the Guideline Support Library (GSL), these guidelines prevent many
    common mistakes in C++ programs.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[Error Prone](https://errorprone.info)用于Java，[Clang-Tidy](https://oreil.ly/qFh_k)用于C/C++在Google的项目中被广泛使用。这两种分析器都允许工程师添加自定义检查。例如，截至2018年初，已有162位作者提交了733个Error
    Prone检查。对于某些类型的错误，Error Prone和Clang-Tidy都可以提出建议的修复方案。一些编译器（如Clang和MSVC）还支持社区开发的[C++核心指南](https://oreil.ly/y2Eqd)。借助指南支持库（GSL）的帮助，这些指南可以防止C++程序中的许多常见错误。'
- en: 'AST pattern-matching tools allow users to add new checks by writing rules on
    the parsed AST. For example, consider the [`absl-string-find-startsWith`](https://oreil.ly/3w5sM)
    Clang-Tidy warning. The tool attempts to improve the readability and performance
    of code that checks for string prefix matches using the C++ [`string::find` API](https://oreil.ly/tg1HX):
    Clang-Tidy recommends using the `StartsWith` API provided by [ABSL](https://oreil.ly/lmrox)
    instead. To perform its analysis, the tool creates an AST subtree pattern that
    compares the output of the C++ `string::find` API with the integer value 0\. The
    Clang-Tidy infrastructure provides the tooling to find AST subtree patterns in
    the AST representation of the program being analyzed.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `absl-string-find-startsWith` Clang-Tidy warning flags this code snippet
    and suggests that the code be changed in the following way:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In order to suggest a fix, Clang-Tidy (conceptually speaking) provides the capability
    to transform an AST subtree, given a pattern. The left side of [Figure 13-1](#ast_pattern_match_and_replacement_sugge)
    shows an AST pattern match. (The AST subtree is simplified for the sake of clarity.)
    If the tool finds a matching AST subtree in the parse AST tree of the source code,
    it notifies the developer. AST nodes also contain line and column information,
    which allows the AST pattern-matcher to report a specific warning to the developer.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![AST pattern-match and replacement suggestion](assets/bsrs_1301.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: Figure 13-1\. AST pattern-match and replacement suggestion
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In addition to performance and readability checks, Clang-Tidy also provides
    many common bug pattern checks. Consider running Clang-Tidy on the following input
    files:^([7](ch13.html#ch13fn7))
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The two input files differ only in the type declaration of `kMessage`. When
    `kMessage` is defined as a pointer to initialized memory, `sizeof(kMessage)` returns
    the size of a pointer type. Therefore, Clang-Tidy produces the [`clang-diagnostic-sizeof-pointer-memaccess`](https://oreil.ly/Q3teN)
    warning. On the other hand, when `kMessage` is of type `const char[]`, the `sizeof(kMessage)`
    operation returns the appropriate, expected length, and Clang-Tidy doesn’t produce
    a warning.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: For some pattern checks, in addition to reporting a warning, Clang-Tidy can
    suggest code fixes. The `absl-string-find-startsWith` Clang-Tidy warning suggestion
    presented earlier is one such instance. The righthand side of [Figure 13-1](#ast_pattern_match_and_replacement_sugge)
    shows the appropriate AST-level replacement. When such suggestions are available,
    you can tell Clang-Tidy to automatically apply them to the input file, using the
    `--fix` command-line option.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use automatically applied suggestions to update a codebase using
    the Clang-Tidy `modernize` fixes. Consider the following sequence of commands,
    which showcases the [`modernize-use-nullptr`](https://oreil.ly/9K8vD) pattern.
    The sequence finds instances of zero-constants used for pointer assignments or
    comparisons, and changes them to use `nullptr` instead. In order to run all `modernize`
    checks, we use Clang-Tidy with the option `--checks=modernize-*`; then `--fix`
    applies the suggestions to the input file. At the end of the sequence of commands,
    we highlight the four changes by printing the transformed file (emphasis added):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Other languages have similar automated code inspection tools. For example,
    [GoVet](https://oreil.ly/m815w) analyzes Go source code for common suspicious
    constructs, [Pylint](https://www.pylint.org) analyzes Python code, and Error Prone
    provides analysis and auto-fix capabilities for Java programs. The following example
    briefly demonstrates running Error Prone via Bazel build rule (emphasis added).
    In Java, the subtraction operation `i-1` on the variable `i` of type `Short` returns
    a value of type `int`. Therefore, it is infeasible for the `remove` operation
    to succeed:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Integration of Static Analysis in the Developer Workflow
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将静态分析集成到开发者工作流程中
- en: It’s considered good industry practice to run relatively fast static analysis
    tools as early as possible in the development cycle. Finding bugs early is important
    because the cost of fixing them increases substantially if they’re pushed into
    the source code repository or deployed to users.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 尽早在开发周期中运行相对快速的静态分析工具被认为是良好的行业实践。早期发现错误很重要，因为如果将它们推送到源代码存储库或部署给用户，修复它们的成本会大大增加。
- en: There’s a low barrier to integrating static analysis tools into your CI/CD pipeline,
    with a potentially high positive impact on the productivity of your engineers.
    For example, a developer can get an error and a suggestion about how to fix null
    pointer dereferencing. And if they can’t push their code, they can’t forget to
    fix the issue and accidentally cause the system to crash or expose information,
    which contributes to a culture of security and reliability (see [Chapter 21](ch21.html#twoone_building_a_culture_of_security_a)).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将静态分析工具集成到CI/CD流水线中的门槛很低，对工程师的生产力可能会产生很高的积极影响。例如，开发人员可以收到有关如何修复空指针解除引用的错误和建议。如果他们无法推送他们的代码，他们就不会忘记修复问题并意外地导致系统崩溃或暴露信息，这有助于建立安全和可靠的文化（见[第21章](ch21.html#twoone_building_a_culture_of_security_a)）。
- en: To this end, Google developed the Tricorder program analysis platform^([8](ch13.html#ch13fn8))
    and an open-source version of Tricorder called [Shipshape](https://github.com/google/shipshape).
    Tricorder performs static analysis of approximately 50,000 code review changes
    per day. The platform runs many types of program analysis tools and surfaces warnings
    to developers during code review, when they are accustomed to evaluating suggestions.
    The tools aim to provide code findings that are easy to understand and easy to
    fix, with a low user-perceived false-positive rate (10%, at most).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，谷歌开发了Tricorder程序分析平台^([8](ch13.html#ch13fn8))和Tricorder的开源版本[Shipshape](https://github.com/google/shipshape)。Tricorder每天对大约50,000个代码审查更改进行静态分析。该平台运行许多类型的程序分析工具，并在代码审查期间向开发人员显示警告，当时他们习惯于评估建议。这些工具旨在提供易于理解和易于修复的代码发现，用户感知的误报率低（最多为10%）。
- en: Tricorder is designed to allow users to run many different program analysis
    tools. As of early 2018, the platform included 146 analyzers covering over 30
    source languages. Most of these analyzers were contributed by Google developers.
    Generally speaking, commonly available static analysis tools are not very complex.
    Most checkers run by Tricorder are automated code inspection tools. These tools
    target a variety of languages, check for conformance to coding style guidelines,
    and find bugs. As previously mentioned, Error Prone and Clang-Tidy can produce
    suggested fixes in certain scenarios. The code author can then apply the fixes
    with the click of a button.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Tricorder旨在允许用户运行许多不同的程序分析工具。截至2018年初，该平台包括146个分析器，涵盖30多种源语言。其中大多数分析器是由谷歌开发人员贡献的。一般来说，通常可用的静态分析工具并不是非常复杂。Tricorder运行的大多数检查器都是自动化的代码检查工具。这些工具针对各种语言，检查是否符合编码风格指南，并查找错误。如前所述，Error
    Prone和Clang-Tidy在某些情况下可以提供建议的修复方法。代码作者随后可以通过点击按钮应用修复。
- en: '[Figure 13-2](#screenshot_of_static_analysis_results_d) shows a screenshot
    of Tricorder analysis results for a given Java input file, as presented to a code
    reviewer. The results show two warnings, one from the Java linter and one from
    Error Prone. Tricorder measures the user-perceived false-positive rate by allowing
    code reviewers to provide feedback on surfaced warnings via a “Not useful” link.
    The Tricorder team uses these signals to disable individual checks. The code reviewer
    can also send a request to the code author to “Please fix” an individual warning.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-2显示了给定Java输入文件的Tricorder分析结果的屏幕截图，呈现给代码审查人员。结果显示了两个警告，一个来自Java linter，一个来自Error
    Prone。Tricorder通过允许代码审查人员通过“无用”链接对出现的警告提供反馈来衡量用户感知的误报率。Tricorder团队使用这些信号来禁用个别检查。代码审查人员还可以向代码作者发送“请修复”个别警告的请求。
- en: '![Screenshot of static analysis results during code review provided via Tricorder](assets/bsrs_1302.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![通过Tricorder提供的代码审查期间的静态分析结果的屏幕截图](assets/bsrs_1302.png)'
- en: Figure 13-2\. Screenshot of static analysis results during code review provided
    via Tricorder
  id: totrans-162
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-2. 通过Tricorder提供的代码审查期间的静态分析结果的屏幕截图
- en: '[Figure 13-3](#screenshot_of_the_preview_fix_view_for) shows the automatically
    applied code changes suggested by Error Prone during code review.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-3显示了在代码审查期间由Error Prone建议的自动应用的代码更改。
- en: '![Screenshot of the preview fix view for the Error Prone warning from](assets/bsrs_1303.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![来自的Error Prone警告的预览修复视图的屏幕截图](assets/bsrs_1303.png)'
- en: Figure 13-3\. Screenshot of the preview fix view for the Error Prone warning
    from [Figure 13-2](#screenshot_of_static_analysis_results_d)
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-3. 来自[图13-2](#screenshot_of_static_analysis_results_d)的Error Prone警告的预览修复视图的屏幕截图
- en: Abstract Interpretation
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象解释
- en: Abstract interpretation–based tools statically perform a semantic analysis of
    program behaviors.^([9](ch13.html#ch13fn9)) This technique has been used successfully
    to verify safety-critical software, such as flight control software.^([10](ch13.html#ch13fn10))
    Consider the simple example of a program that generates the 10 smallest positive
    even integers. During its regular execution, the program generates the integer
    values 2, 4, 6, 8, 10, 12, 14, 16, 18, and 20\. In order to allow efficient static
    analysis of such a program, we want to summarize all the possible values using
    a compact representation that covers all the observed values. Using the so-called
    interval or range domain, we can represent all observed values using the abstract
    interval value [2, 20] instead. The interval domain allows the static analyzer
    to reason efficiently about all program executions by simply remembering the lowest
    and highest possible values.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 基于抽象解释的工具静态地执行程序行为的语义分析。这种技术已成功用于验证关键安全软件，如飞行控制软件。考虑一个简单的例子，一个程序生成10个最小的正偶数。在正常执行期间，程序生成整数值2、4、6、8、10、12、14、16、18和20。为了允许对这样一个程序进行高效的静态分析，我们希望使用一个紧凑的表示来总结所有可能的值，覆盖所有观察到的值。使用所谓的区间或范围域，我们可以代表所有观察到的值，使用抽象区间值[2,
    20]。区间域允许静态分析器通过简单地记住最低和最高可能的值来高效地推理所有程序执行。
- en: In order to ensure that we’re capturing all possible program behaviors, it’s
    important to cover all observed values with the abstract representation. However,
    this approach also introduces an approximation that may lead to *imprecision*,
    or false warnings. For example, if we wanted to guarantee that the actual program
    never produces the value 11, an analysis using an integer domain would lead to
    a false positive.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们捕捉到所有可能的程序行为，重要的是用抽象表示覆盖所有观察到的值。然而，这种方法也引入了可能导致不精确或错误警告的近似。例如，如果我们想要保证实际程序永远不会产生值11，使用整数域的分析将导致一个错误的阳性。
- en: Static analyzers utilizing abstract interpretation generally compute an abstract
    value for every program point. To do so, they rely on a *control-flow graph* (CFG)
    representation of a program. CFGs are commonly used during compiler optimizations,
    and to statically analyze programs. Each node in a CFG represents a basic block
    in the program, which corresponds to a sequence of program statements that are
    always executed in order. That is, there are no jumps from within this sequence
    of statements, and no jump targets in the middle of the sequence. Edges in a CFG
    represent control flow in the program, where a jump occurs either through intraprocedural
    control flow—for example, due to `if` statements or loop constructs—or interprocedural
    control flow due to function calls. Note that the CFG representation is also used
    by coverage-guided fuzzers (discussed previously). For instance, libFuzzer keeps
    track of which basic blocks and edges are covered during fuzzing. The fuzzer uses
    this information to decide whether to consider an input for future mutations.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 利用抽象解释的静态分析器通常为每个程序点计算一个抽象值。为此，它们依赖于程序的控制流图（CFG）表示。CFG在编译器优化和静态分析程序中通常被使用。CFG中的每个节点代表程序中的一个基本块，对应于按顺序执行的程序语句序列。也就是说，在这个语句序列中没有跳转，也没有跳转目标在序列中间。CFG中的边代表程序中的控制流，其中跳转发生在程序内部的控制流（例如，由于`if`语句或循环结构）或由于函数调用的程序间的控制流。请注意，CFG表示也被覆盖引导的模糊器（之前讨论过）使用。例如，libFuzzer跟踪在模糊过程中覆盖的基本块和边。模糊器使用这些信息来决定是否考虑将输入用于未来的变异。
- en: Abstract interpretation–based tools perform a semantic analysis that reasons
    about data flow and control flow in programs, often across function calls. For
    that reason, they take much longer to run than the previously discussed automated
    code inspection tools. While you can integrate automated code inspection tools
    into interactive development environments such as code editors, abstract interpretation
    is generally not similarly integrated. Instead, developers might run abstract
    interpretation–based tools on committed code occasionally (nightly, for example),
    or during code review in differential settings, analyzing only the changed code
    while reusing analysis facts for unchanged code.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 基于抽象解释的工具执行关于程序中数据流和控制流的语义分析，通常跨越函数调用。因此，它们的运行时间比之前讨论的自动化代码检查工具要长得多。虽然你可以将自动化代码检查工具集成到交互式开发环境中，比如代码编辑器，但抽象解释通常不会被类似地集成。相反，开发人员可能会偶尔（比如每晚）在提交的代码上运行基于抽象解释的工具，或者在差异设置中进行代码审查，分析只有改变的代码，同时重用未改变的代码的分析事实。
- en: A number of tools rely on abstract interpretation for a variety of languages
    and properties. For example, the [Frama-C tool](https://frama-c.com) allows you
    to find common runtime errors and assertion violations including buffer overflows,
    segmentation faults due to dangling or null pointers, and division by zero in
    programs written in C. As previously discussed, these types of bugs—especially
    memory-related bugs—can have security implications. The [Infer tool](https://fbinfer.com)
    reasons about memory and pointer changes performed by programs and can find bugs
    like dangling pointers in Java, C, and other languages. The [AbsInt tool](https://www.absint.com)
    can perform worst-case execution time analysis of tasks in real-time systems.
    The [App Security Improvement (ASI) program](https://oreil.ly/60tlV) performs
    a sophisticated interprocedural analysis on every Android app that’s uploaded
    to the Google Play Store, for safety and security. If it finds a vulnerability,
    ASI flags the vulnerability and presents suggestions for addressing the issue.
    [Figure 13-4](#an_app_security_improvement_alert) shows a sample security alert.
    As of early 2019, this program had led to over [one million app fixes](https://oreil.ly/my8fa)
    in the Play Store by over 300,000 app developers.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 许多工具依赖于抽象解释来处理各种语言和属性。例如，[Frama-C工具](https://frama-c.com)允许您查找C语言程序中的常见运行时错误和断言违规，包括缓冲区溢出、由于悬空或空指针导致的分段错误以及除零。正如之前讨论的那样，这些类型的错误，特别是与内存相关的错误，可能具有安全影响。[Infer工具](https://fbinfer.com)推理程序执行的内存和指针更改，并可以在Java、C和其他语言中找到悬空指针等错误。[AbsInt工具](https://www.absint.com)可以对实时系统中任务的最坏执行时间进行分析。[应用安全改进（ASI）程序](https://oreil.ly/60tlV)对上传到Google
    Play商店的每个Android应用进行复杂的过程间分析，以确保安全性。如果发现漏洞，ASI会标记漏洞并提出解决问题的建议。[图13-4](#an_app_security_improvement_alert)显示了一个样本安全警报。截至2019年初，该程序已导致Play商店中超过300,000个应用开发者修复了超过100万个应用。
- en: '![An App Security Improvement alert](assets/bsrs_1304.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![应用安全改进警报](assets/bsrs_1304.png)'
- en: Figure 13-4\. An App Security Improvement alert
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-4。应用安全改进警报
- en: Formal Methods
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 形式化方法
- en: '*Formal methods* allow users to specify properties of interest for software
    or hardware systems. Most of these are so-called *safety properties* that specify
    that a certain bad behavior should never be observable. For example, “bad behavior”
    can include assertions in programs. Others include *liveness properties,* which
    allow users to specify a desired outcome—for example, that a submitted print job
    is eventually processed by a printer. Users of formal methods can verify these
    properties for particular systems or models, and even develop such systems using
    *correct-by-construction*–based approaches. As highlighted in [“Analyzing Invariants”](ch06.html#analyzing_invariants),
    formal methods–based approaches often have a relatively high up-front cost. This
    is partially because these approaches require an a priori description of system
    requirements and properties of interest. These requirements must be specified
    in a mathematically rigorous and formal way.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*形式化方法*允许用户指定对软件或硬件系统感兴趣的属性。其中大多数是所谓的*安全属性*，指定某种不良行为不应该被观察到。例如，“不良行为”可以包括程序中的断言。其他包括*活性属性*，允许用户指定期望的结果，例如提交的打印作业最终由打印机处理。形式化方法的用户可以验证特定系统或模型的这些属性，甚至使用基于*正确构造*的方法开发这些系统。正如[“分析不变量”](ch06.html#analyzing_invariants)中所强调的，基于形式化方法的方法通常具有相对较高的前期成本。这部分是因为这些方法需要对系统要求和感兴趣的属性进行先验描述。这些要求必须以数学严谨和形式化的方式进行规定。'
- en: Formal methods–based techniques have been successfully integrated into hardware
    design and verification tools.^([11](ch13.html#ch13fn11)) In hardware design,
    it is now standard practice to use formal or semiformal tools provided by electronic
    design automation (EDA) vendors. These techniques have also been successfully
    applied to software in specialized domains, such as safety-critical systems or
    cryptographic protocol analysis. For example, a formal methods–based approach
    continuously analyzes the cryptographic protocols used in TLS within computer
    network communications.^([12](ch13.html#ch13fn12))
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 基于形式化方法的技术已成功整合到硬件设计和验证工具中。^([11](ch13.html#ch13fn11))在硬件设计中，使用电子设计自动化（EDA）供应商提供的形式化或半形式化工具现在是标准做法。这些技术也已成功应用于专门领域的软件，如安全关键系统或加密协议分析。例如，基于形式化方法的方法不断分析计算机网络通信中TLS使用的加密协议。^([12](ch13.html#ch13fn12))
- en: Conclusion
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: Testing software for security and reliability is a vast topic, of which we’ve
    just scratched the surface. The testing strategies presented in this chapter,
    combined with practices around writing secure code to eliminate entire bug classes
    (see [Chapter 12](ch12.html#writing_code)), have been key in helping Google teams
    scale reliably, minimizing outages and security problems. It’s important to build
    software with testability in mind from the earliest stages of development, and
    to engage in comprehensive testing throughout the development lifecycle.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 测试软件的安全性和可靠性是一个广泛的话题，我们只是触及了表面。本章介绍的测试策略，结合编写安全代码的实践（参见[第12章](ch12.html#writing_code)），对帮助谷歌团队可靠扩展、最小化停机时间和安全问题起到了关键作用。从开发的最早阶段就考虑可测试性，并在整个开发生命周期中进行全面测试是非常重要的。
- en: At this point, we want to emphasize the value of fully integrating all of these
    testing and analysis methods into your engineering workflows and CI/CD pipelines.
    By combining and regularly using these techniques consistently throughout your
    codebase, you can identify bugs more quickly. You’ll also raise confidence in
    your ability to detect or prevent bugs when you deploy your applications—a topic
    covered in the next chapter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们要强调将所有这些测试和分析方法完全整合到您的工程工作流程和CI/CD流水线中的价值。通过在整个代码库中一致地结合和定期使用这些技术，您可以更快地识别错误。您还将提高在部署应用程序时检测或预防错误的能力，这是下一章将涵盖的主题。
- en: ^([1](ch13.html#ch13fn1-marker)) We recommend checking out [Chapter 17 of the
    SRE book](https://landing.google.com/sre/sre-book/chapters/testing-reliability/)
    for a reliability-focused perspective.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '^([2](ch13.html#ch13fn2-marker)) Petrović, Goran, and Marko Ivanković. 2018\.
    “State of Mutation Testing at Google.” *Proceedings of the 40th International
    Conference on Software Engineering*: 163–171\. doi:10.1145/3183519.3183521.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '^([3](ch13.html#ch13fn3-marker)) For more discussion of common unit testing
    pitfalls encountered at Google, see Wright, Hyrum, and Titus Winters. 2015\. “All
    Your Tests Are Terrible: Tales from the Trenches.” CppCon 2015\. [*https://oreil.ly/idleN*](https://oreil.ly/idleN).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch13.html#ch13fn4-marker)) See [Chapter 2 of the SRE workbook](https://landing.google.com/sre/workbook/chapters/implementing-slos/).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch13.html#ch13fn5-marker)) The fuzz target compares the results of two
    modular exponentiation implementations inside OpenSSL, and will fail if the results
    ever differ.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '^([6](ch13.html#ch13fn6-marker)) For an example, see Bozzano, Marco et al.
    2017\. “Formal Methods for Aerospace Systems.” In *Cyber-Physical System Design
    from an Architecture Analysis Viewpoint*, edited by Shin Nakajima, Jean-Pierre
    Talpin, Masumi Toyoshima, and Huafeng Yu. Singapore: Springer.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch13.html#ch13fn7-marker)) You can install Clang-Tidy using standard package
    managers. It is generally called clang-tidy.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '^([8](ch13.html#ch13fn8-marker)) See Sadowski, Caitlin et al. 2018\. “Lessons
    from Building Static Analysis Tools at Google.” *Communications of the ACM* 61(4):
    58–66\. doi:10.1145/3188720.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '^([9](ch13.html#ch13fn9-marker)) See Cousot, Patrick, and Radhia Cousot. 1976\.
    “Static Determination of Dynamic Properties of Programs.” *Proceedings of the
    2nd International Symposium on Programming*: 106–130\. [*https://oreil.ly/4xLgB*](https://oreil.ly/4xLgB).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '^([10](ch13.html#ch13fn10-marker)) Souyris, Jean et al. 2009\. “Formal Verification
    of Avionics Software Products.” *Proceedings of the 2nd World Conference on Formal
    Methods*: 532–546\. doi:10.1007/978-3-642-05089-3_34.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '^([11](ch13.html#ch13fn11-marker)) See, e.g., Kern, Christoph, and Mark R.
    Greenstreet. 1999\. “Formal Verification in Hardware Design: A Survey.” *ACM Transactions
    on Design Automation of Electronic Systems* 4(2): 123–193\. doi:10.1145/307988.307989\.
    See also Hunt Jr. et al. 2017\. “Industrial Hardware and Software Verification
    with ACL2.” *Philosophical Transactions of The Royal Society A Mathematical Physical
    and Engineering Sciences* 375(2104): 20150399\. doi: 10.1098/rsta.2015.0399.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '^([12](ch13.html#ch13fn12-marker)) See Chudnov, Andrey et al. 2018\. “Continuous
    Formal Verification of Amazon s2n.” *Proceedings of the 30th International Conference
    on Computer Aided Verification*: 430–446\. doi:10.1007/978-3-319-96142-2_26.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 14\. Deploying Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。部署代码
- en: By Jeremiah Spradlin and Mark Lodato
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：Jeremiah Spradlin和Mark Lodato
- en: with Sergey Simakov and Roxana Loza
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与Sergey Simakov和Roxana Loza
- en: Previous chapters addressed how to consider security and reliability when writing
    and testing your code. However, that code has no real impact until it’s built
    and deployed. Therefore, it’s important to carefully consider security and reliability
    for all elements of the build and deployment process. It can be difficult to determine
    if a deployed artifact is safe purely by inspecting the artifact itself. Controls
    on various stages of the software supply chain can increase your confidence in
    the safety of a software artifact. For example, code reviews can reduce the chance
    of mistakes and deter adversaries from making malicious changes, and automated
    tests can increase your confidence that the code operates correctly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写和测试代码时，前几章讨论了如何考虑安全性和可靠性。然而，直到代码构建和部署之后，该代码才会产生真正的影响。因此，对构建和部署过程的所有元素仔细考虑安全性和可靠性非常重要。仅通过检查构件本身很难确定部署的构件是否安全。软件供应链各个阶段的控制可以增加您对软件构件安全性的信心。例如，代码审查可以减少错误的机会，并阻止对手进行恶意更改，自动化测试可以增加您对代码操作正确性的信心。
- en: Controls built around the source, build, and test infrastructure have limited
    effect if adversaries can bypass them by deploying directly to your system. Therefore,
    systems should reject deployments that don’t originate from the proper software
    supply chain. To meet this requirement, each step in the supply chain must be
    able to offer proof that it has executed properly.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕源代码、构建和测试基础设施构建的控制具有有限的效果，如果对手可以通过直接部署到您的系统来绕过它们。因此，系统应拒绝不是来自正确软件供应链的部署。为了满足这一要求，供应链中的每个步骤都必须能够提供其已正确执行的证据。
- en: Concepts and Terminology
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概念和术语
- en: We use the term *software supply chain* to describe the process of writing,
    building, testing, and deploying a software system. These steps include the typical
    responsibilities of a version control system (VCS), a continuous integration (CI)
    pipeline, and a continuous delivery (CD) pipeline.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用术语*软件供应链*来描述编写、构建、测试和部署软件系统的过程。这些步骤包括版本控制系统（VCS）、持续集成（CI）流水线和持续交付（CD）流水线的典型责任。
- en: 'While implementation details vary across companies and teams, most organizations
    have a process that looks something like [Figure 14-1](#a_high_level_view_of_a_typical_software):'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管实施细节在公司和团队之间有所不同，但大多数组织都有一个类似于[图14-1](#a_high_level_view_of_a_typical_software)的流程：
- en: Code must be checked into a version control system.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码必须检入版本控制系统。
- en: Code is then built from a checked-in version.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后从检入的版本构建代码。
- en: Once built, the binary must be tested.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦构建完成，二进制文件必须经过测试。
- en: Code is then deployed to some environment where it is configured and executed.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将代码部署到某个环境中，进行配置和执行。
- en: '![A high-level view of a typical software supply chain](assets/bsrs_1401.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![典型软件供应链的高层视图](assets/bsrs_1401.png)'
- en: Figure 14-1\. A high-level view of a typical software supply chain
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图14-1。典型软件供应链的高层视图
- en: Even if your supply chain is more complicated than this model, you can usually
    break it into these basic building blocks. [Figure 14-2](#typical_cloud_hosted_container_based_se)
    shows a concrete example of how a typical deployment pipeline executes these steps.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您的供应链比这个模型更复杂，您通常也可以将其分解为这些基本构建块。[图14-2](#typical_cloud_hosted_container_based_se)显示了典型部署流水线如何执行这些步骤的具体示例。
- en: You should design the software supply chain to mitigate threats to your system.
    This chapter focuses on mitigating threats presented by insiders (or malicious
    attackers impersonating insiders), as defined in [Chapter 2](ch02.html#understanding_adversaries),
    without regard to whether the insider is acting with malicious intent. For example,
    a well-meaning engineer might unintentionally build from code that includes unreviewed
    and unsubmitted changes, or an external attacker might attempt to deploy a backdoored
    binary using the privileges of a compromised engineer’s account. We consider both
    scenarios equally.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该设计软件供应链以减轻对系统的威胁。本章重点介绍了如何减轻内部人员（或恶意攻击者冒充内部人员）在[第2章](ch02.html#understanding_adversaries)中定义的威胁，而不考虑内部人员是否具有恶意意图。例如，一个善意的工程师可能无意中构建了包含未经审查和未提交更改的代码，或者外部攻击者可能尝试使用受损工程师帐户的权限部署带有后门的二进制文件。我们同样考虑这两种情况。
- en: In this chapter, we define the steps of the software supply chain rather broadly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对软件供应链的步骤进行了广泛定义。
- en: A *build* is any transformation of input artifacts to output artifacts, where
    an *artifact* is any piece of data—for example, a file, a package, a Git commit,
    or a virtual machine (VM) image. A *test* is a special case of a build, where
    the output artifact is some logical result—usually “pass” or “fail”—rather than
    a file or executable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*构建*是将输入构件转换为输出构件的任何过程，其中*构件*是任何数据片段，例如文件、软件包、Git提交或虚拟机（VM）镜像。*测试*是构建的特殊情况，其中输出构件是一些逻辑结果，通常是“通过”或“失败”，而不是文件或可执行文件。'
- en: '![Typical cloud-hosted container-based service deployment](assets/bsrs_1402.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![典型的云托管基于容器的服务部署](assets/bsrs_1402.png)'
- en: Figure 14-2\. Typical cloud-hosted container-based service deployment
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图14-2。典型的云托管基于容器的服务部署
- en: Builds can be chained together, and an artifact can be subject to multiple tests.
    For example, a release process might first “build” binaries from source code,
    then “build” a Docker image from the binaries, and then “test” the Docker image
    by running it in a development environment.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 构建可以链接在一起，并且一个构件可以经历多次测试。例如，发布过程可能首先从源代码“构建”二进制文件，然后从二进制文件“构建”Docker镜像，然后通过在开发环境中运行Docker镜像来“测试”Docker镜像。
- en: 'A *deployment* is any assignment of some artifact to some environment. You
    can consider each of the following to be a deployment:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*部署*是将某个构件分配到某个环境的任何过程。您可以将以下每个过程视为部署：'
- en: 'Pushing code:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推送代码：
- en: Issuing a command to cause a server to download and run a new binary
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布命令以导致服务器下载并运行新的二进制文件
- en: Updating a Kubernetes Deployment object to pick up a new Docker image
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新Kubernetes部署对象以使用新的Docker镜像
- en: Booting a VM or physical machine, which loads initial software or firmware
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动虚拟机或物理机，加载初始软件或固件
- en: 'Updating configuration:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新配置：
- en: Running a SQL command to change a database schema
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行SQL命令来更改数据库模式
- en: Updating a Kubernetes Deployment object to change a command-line flag
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新Kubernetes部署对象以更改命令行标志
- en: 'Publishing a package or other data, which will be consumed by other users:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布一个包或其他数据，将被其他用户使用：
- en: Uploading a deb package to an apt repository
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传deb包到apt仓库
- en: Uploading a Docker image to a container registry
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传Docker镜像到容器注册表
- en: Uploading an APK to the Google Play Store
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传APK到Google Play商店
- en: Post-deployment changes are out of scope for this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不包括部署后更改。
- en: Threat Model
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 威胁模型
- en: 'Before hardening your software supply chain to mitigate threats, you have to
    identify your adversaries. For the purpose of this discussion, we’ll consider
    the following three types of adversaries. Depending on your system and organization,
    your list of adversaries may differ:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在加固软件供应链以缓解威胁之前，您必须确定您的对手。在本讨论中，我们将考虑以下三种对手类型。根据您的系统和组织，您的对手清单可能会有所不同：
- en: Benign insiders who may make mistakes
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能犯错误的良性内部人员
- en: Malicious insiders who try to gain more access than their role allows
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 试图获得比其角色允许的更多访问权限的恶意内部人员
- en: External attackers who compromise the machine or account of one or more insiders
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部攻击者入侵一个或多个内部人员的机器或帐户
- en: '[Chapter 2](ch02.html#understanding_adversaries) describes attacker profiles
    and provides guidance on how to model against insider risk.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](ch02.html#understanding_adversaries)描述了攻击者的配置文件，并提供了针对内部风险建模的指导。'
- en: 'Next, you must think like an attacker and try to identify all the ways an adversary
    can subvert the software supply chain to compromise your system. The following
    are some examples of common threats; you should tailor this list to reflect the
    specific threats to your organization. For the sake of simplicity, we use the
    term *engineer* to refer to benign insiders, and *malicious adversary* to refer
    to both malicious insiders and external attackers:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您必须像攻击者一样思考，尝试识别对手可以颠覆软件供应链以威胁您系统的所有方式。以下是一些常见威胁的例子；您应该根据您组织的具体威胁来调整这个清单。为了简单起见，我们使用术语*工程师*来指代良性内部人员，*恶意对手*来指代恶意内部人员和外部攻击者：
- en: An engineer submits a change that accidentally introduces a vulnerability to
    the system.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工程师提交了一个意外引入系统漏洞的更改。
- en: A malicious adversary submits a change that enables a backdoor or introduces
    some other intentional vulnerability to the system.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意对手提交了一个启用后门或引入系统其他有意漏洞的更改。
- en: An engineer accidentally builds from a locally modified version of the code
    that contains unreviewed changes.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工程师意外地从包含未经审查的更改的本地修改版本的代码构建。
- en: An engineer deploys a binary with a harmful configuration. For example, the
    change enables debug features in production that were intended only for testing.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工程师部署了一个带有有害配置的二进制文件。例如，更改启用了仅用于测试的生产调试功能。
- en: A malicious adversary deploys a modified binary to production that begins exfiltrating
    customer credentials.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意对手部署了一个修改过的二进制文件到生产环境，开始窃取客户凭据。
- en: A malicious adversary modifies the ACLs of a cloud bucket, allowing them to
    exfiltrate data.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意对手修改了云存储桶的ACL，允许他们窃取数据。
- en: A malicious adversary steals the integrity key used to sign the software.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意对手窃取用于签署软件的完整性密钥。
- en: An engineer deploys an old version of the code with a known vulnerability.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工程师部署了一个带有已知漏洞的旧版本代码。
- en: The CI system is misconfigured to allow requests to build from arbitrary source
    repositories. As a result, a malicious adversary can build from a source repository
    containing malicious code.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI系统配置错误，允许从任意源代码库构建请求。因此，恶意对手可以从包含恶意代码的源代码库构建。
- en: A malicious adversary uploads a custom build script to the CI system that exfiltrates
    the signing key. The adversary then uses that key to sign and deploy a malicious
    binary.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意对手上传一个自定义的构建脚本到CI系统，窃取签名密钥。然后对手使用该密钥对恶意二进制文件进行签名和部署。
- en: A malicious adversary tricks the CD system to use a backdoored compiler or build
    tool that produces a malicious binary.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意对手欺骗CD系统使用带有后门的编译器或构建工具来生成恶意二进制文件。
- en: Once you’ve compiled a comprehensive list of potential adversaries and threats,
    you can map the threats you identified to the mitigations you already have in
    place. You should also document any limitations of your current mitigation strategies.
    This exercise will provide a thorough picture of the potential risks in your system.
    Threats that don’t have corresponding mitigations, or threats for which existing
    mitigations have significant limitations, are areas for improvement.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您编制了一个潜在对手和威胁的全面清单，您可以将您已经采取的缓解措施与您识别出的威胁进行映射。您还应该记录当前缓解策略的任何限制。这个练习将为您的系统中潜在风险提供一个全面的图片。没有相应缓解措施的威胁，或者现有缓解措施存在重大限制的威胁，都是需要改进的领域。
- en: Best Practices
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: The following best practices can help you mitigate threats, fill any security
    gaps you identified in your threat model, and continuously improve the security
    of your software supply chain.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下最佳实践可以帮助您缓解威胁，在您的威胁模型中填补任何安全漏洞，并持续改进您的软件供应链的安全性。
- en: Require Code Reviews
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要代码审查
- en: 'Code review is the practice of having a second person (or several people) review
    changes to the source code before those changes are checked in or deployed.^([1](ch14.html#ch14fn1))
    In addition to improving code security, code reviews provide multiple benefits
    for a software project: they promote knowledge sharing and education, instill
    coding norms, improve code readability, and reduce mistakes,^([2](ch14.html#ch14fn2))
    all of which helps to build a culture of security and reliability (for more on
    this idea, see [Chapter 21](ch21.html#twoone_building_a_culture_of_security_a)).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查是在提交或部署更改之前，让第二个人（或几个人）审查源代码的更改的做法。除了提高代码安全性外，代码审查还为软件项目提供了多种好处：它们促进知识共享和教育，灌输编码规范，提高代码可读性，减少错误，所有这些有助于建立安全和可靠的文化（有关这个想法的更多信息，请参见[第21章](ch21.html#twoone_building_a_culture_of_security_a)）。
- en: From a security perspective, code review is a form of multi-party authorization,^([3](ch14.html#ch14fn3))
    meaning that no individual has the privilege to submit changes on their own. As
    described in [Chapter 5](ch05.html#design_for_least_privilege), multi-party authorization
    provides many security benefits.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全的角度来看，代码审查是一种多方授权的形式，这意味着没有个人有权利单独提交更改。正如[第5章](ch05.html#design_for_least_privilege)中所描述的，多方授权提供了许多安全好处。
- en: To be implemented successfully, code reviews must be mandatory. An adversary
    will not be deterred if they can simply opt out of the review! Reviews must also
    be comprehensive enough to catch problems. The reviewer must understand the details
    of any change and its implications for the system, or ask the author for clarifications—otherwise,
    the process can devolve into rubber-stamping.^([4](ch14.html#ch14fn4))
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功实施，代码审查必须是强制性的。如果对手可以选择退出审查，那么他们将不会被阻止！审查还必须足够全面，以捕捉问题。审阅者必须理解任何更改的细节及其对系统的影响，或者向作者询问澄清问题，否则该过程可能会变得形式化。
- en: Many publicly available tools allow you to implement mandatory code reviews.
    For example, you can configure GitHub, GitLab, or BitBucket to require a certain
    number of approvals for every pull/merge request. Alternatively, you can use standalone
    review systems like Gerrit or Phabricator in combination with a source repository
    configured to accept only pushes from that review system.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 许多公开可用的工具允许您实施强制性的代码审查。例如，您可以配置GitHub、GitLab或BitBucket，要求每个拉取/合并请求都需要一定数量的批准。或者，您可以使用独立的审查系统，如Gerrit或Phabricator，结合一个配置为只接受来自该审查系统的推送的源代码库。
- en: Code reviews have limitations with respect to security, as described in the
    introduction to [Chapter 12](ch12.html#writing_code). Therefore, they are best
    implemented as one “defense in depth” security measure, alongside automated testing
    (described in [Chapter 13](ch13.html#onethree_testing_code)) and the recommendations
    in [Chapter 12](ch12.html#writing_code).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全的角度来看，代码审查在安全方面存在一些限制，正如[第12章](ch12.html#writing_code)中所述。因此，最好将其作为“深度防御”安全措施之一，与自动化测试（在[第13章](ch13.html#onethree_testing_code)中描述）和[第12章](ch12.html#writing_code)中的建议一起实施。
- en: Rely on Automation
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖自动化
- en: Ideally, automated systems should perform most of the steps in the software
    supply chain.^([5](ch14.html#ch14fn5)) Automation provides a number of advantages.
    It can provide a consistent, repeatable process for building, testing, and deploying
    software. Removing humans from the loop helps prevent mistakes and reduces toil.
    When you run the software supply chain automation on a locked-down system, you
    harden the system from subversion by malicious adversaries.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，自动化系统应该执行软件供应链中的大部分步骤。自动化提供了许多优势。它可以为构建、测试和部署软件提供一致、可重复的流程。将人类从循环中移除有助于防止错误并减少劳动。当您在一个封闭的系统上运行软件供应链自动化时，您可以使系统免受恶意对手的颠覆。
- en: Consider a hypothetical scenario in which engineers manually build “production”
    binaries on their workstations as needed. This scenario creates many opportunities
    to introduce errors. Engineers can accidentally build from the wrong version of
    the code or include unreviewed or untested code changes. Meanwhile, malicious
    adversaries—including external attackers who have compromised an engineer’s machine—might
    intentionally overwrite the locally built binaries with malicious versions. Automation
    can prevent both of these outcomes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个假设的场景，工程师根据需要在他们的工作站上手动构建“生产”二进制文件。这种情况会产生许多引入错误的机会。工程师可能会意外地从错误的代码版本构建，或者包含未经审查或未经测试的代码更改。同时，恶意对手，包括已经攻破工程师机器的外部攻击者，可能会故意用恶意版本覆盖本地构建的二进制文件。自动化可以防止这两种结果。
- en: 'Adding automation in a secure manner can be tricky, as an automated system
    itself might introduce other security holes. To avoid the most common classes
    of vulnerabilities, we recommend, at minimum, the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以安全的方式添加自动化可能会有些棘手，因为自动化系统本身可能会引入其他安全漏洞。为了避免最常见的漏洞类别，我们建议至少采取以下措施：
- en: Move all build, test, and deployment steps to automated systems.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有构建、测试和部署步骤移至自动化系统。
- en: At a minimum, you should script all steps. This allows both humans and automation
    to execute the same steps for consistency. You can use CI/CD systems (such as
    [Jenkins](https://jenkins.io)) for this purpose. Consider establishing a policy
    that requires automation for all new projects, since retrofitting automation into
    existing systems can often be challenging.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，您应该编写所有步骤的脚本。这样可以让人类和自动化执行相同的步骤以保持一致性。您可以使用CI/CD系统（如[Jenkins](https://jenkins.io)）来实现这一目的。考虑制定一个要求所有新项目都需要自动化的政策，因为将自动化应用到现有系统中通常是具有挑战性的。
- en: Require peer review for all configuration changes to the software supply chain.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 软件供应链的所有配置更改都需要同行审查。
- en: Often, treating configuration as code (as discussed shortly) is the best way
    to accomplish this. By requiring review, you greatly decrease your chances of
    making errors and mistakes, and increase the cost of malicious attacks.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将配置视为代码（如前所述）是实现这一目标的最佳方式。通过要求审查，您大大减少了出错和错误的机会，并增加了恶意攻击的成本。
- en: Lock down the automated system to prevent tampering by administrators or users.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定自动化系统，防止管理员或用户篡改。
- en: This is the most challenging step, and implementation details are beyond the
    scope of this chapter. In short, consider all of the paths where an administrator
    could make a change without review—for example, making a change by configuring
    the CI/CD pipeline directly or using SSH to run commands on the machine. For each
    path, consider a mitigation to prevent such access without peer review.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最具挑战性的一步，实施细节超出了本章的范围。简而言之，考虑管理员可以在没有审查的情况下进行更改的所有路径——例如，通过直接配置CI/CD管道或使用SSH在机器上运行命令进行更改。对于每条路径，考虑采取措施以防止未经同行审查的访问。
- en: For further recommendations on locking down your automated build system, see
    [“Verifiable Builds”](#verifiable_builds).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有关锁定自动化构建系统的进一步建议，请参阅[“可验证构建”](#verifiable_builds)。
- en: Automation is a win-win, reducing toil while simultaneously increasing reliability
    and security. Rely on automation whenever possible!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化是双赢，减少了繁重的工作，同时增加了可靠性和安全性。尽可能依赖自动化！
- en: Verify Artifacts, Not Just People
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证构件，而不仅仅是人
- en: The controls around the source, build, and test infrastructure have limited
    effect if adversaries can bypass them by deploying directly to production. It
    is not sufficient to verify *who* initiated a deployment, because that actor may
    make a mistake or may be intentionally deploying a malicious change.^([6](ch14.html#ch14fn7))
    Instead, deployment environments should verify *what* is being deployed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对手可以绕过源、构建和测试基础设施的控制，直接部署到生产环境，那么这些控制的效果就会受到限制。仅仅验证*谁*发起了部署是不够的，因为该行为者可能会犯错误，或者可能是有意部署了恶意更改。相反，部署环境应该验证*正在*部署的内容。
- en: Deployment environments should require proof that each automated step of the
    deployment process occurred. Humans must not be able to bypass the automation
    unless some other mitigating control checks that action. For example, if you run
    on Google Kubernetes Engine (GKE), you can use [Binary Authorization](https://oreil.ly/0jsVi)
    to by default accept only images signed by your CI/CD system, and monitor the
    Kubernetes cluster audit log for notifications when someone uses the breakglass
    feature to deploy a noncompliant image.^([7](ch14.html#ch14fn8))
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 部署环境应该要求证明部署过程的每个自动化步骤都已发生。除非有其他缓解控制检查该操作，否则人类不应能够绕过自动化。例如，如果您在Google Kubernetes
    Engine（GKE）上运行，您可以使用[二进制授权](https://oreil.ly/0jsVi)默认接受仅由您的CI/CD系统签名的镜像，并监视Kubernetes集群审计日志，以获取有人使用紧急功能部署不符合规定的镜像时的通知。
- en: 'One limitation of this approach is that it assumes that all components of your
    setup are secure: that the CI/CD system accepts build requests only for sources
    that are allowed in production, that the signing keys (if used) are accessible
    only by the CI/CD system, and so on. [“Advanced Mitigation Strategies”](#advanced_mitigation_strategies)
    describes a more robust approach of directly verifying the desired properties
    with fewer implicit assumptions.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个局限性是，它假设您设置的所有组件都是安全的：即CI/CD系统仅接受允许在生产环境中使用的源的构建请求，如果使用签名密钥，则只能由CI/CD系统访问，等等。[“高级缓解策略”](#advanced_mitigation_strategies)描述了一种更健壮的方法，直接验证所需属性，减少了隐含的假设。
- en: Treat Configuration as Code
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将配置视为代码
- en: A service’s configuration is just as critical to security and reliability as
    the service’s code. Therefore, all the best practices regarding code versioning
    and change review apply to configuration as well. Treat configuration as code
    by requiring that configuration changes be checked in, reviewed, and tested prior
    to deployment, just like any other change.^([8](ch14.html#ch14fn9))
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的配置对于安全性和可靠性同样至关重要。因此，关于代码版本控制和更改审查的所有最佳实践也适用于配置。将配置视为代码，要求在部署之前对配置更改进行检入、审查和测试，就像对任何其他更改一样。
- en: 'To provide an example: suppose your frontend server has a configuration option
    to specify the backend. If someone were to point your production frontend to a
    testing version of the backend, you’d have a major security and reliability problem.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子：假设您的前端服务器有一个配置选项来指定后端。如果有人将您的生产前端指向后端的测试版本，那么您将面临严重的安全和可靠性问题。
- en: Or, as a more practical example, consider a system that uses Kubernetes and
    stores the configuration in a [YAML](https://yaml.org) file under version control.^([9](ch14.html#ch14fn10))
    The deployment process calls the `kubectl` binary and passes in the YAML file,
    which deploys the approved configuration. Restricting the deployment process to
    use only “approved” YAML—YAML from version control with required peer review—makes
    it much more difficult to misconfigure your service.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，作为一个更实际的例子，考虑一个使用Kubernetes并将配置存储在版本控制下的[YAML](https://yaml.org)文件的系统。部署过程调用`kubectl`二进制文件并传递YAML文件，部署经过批准的配置。限制部署过程仅使用“经过批准”的YAML——来自版本控制并需要同行审查的YAML——使得误配置服务变得更加困难。
- en: You can reuse all of the controls and best practices this chapter recommends
    to protect your service’s configuration. Reusing these approaches is usually much
    easier than other methods of securing post-deployment configuration changes, which
    often require a completely separate multi-party authorization system.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以重复使用本章推荐的所有控件和最佳实践，以保护您服务的配置。重用这些方法通常比其他方法更容易，后者通常需要完全独立的多方授权系统来保护部署后的配置更改。
- en: The practice of versioning and reviewing configuration is not nearly as widespread
    as code versioning and review. Even organizations that implement configuration-as-code
    usually don’t apply code-level rigor to configuration. For example, engineers
    generally know that they shouldn’t build a production version of a binary from
    a locally modified copy of the source code. Those same engineers might not think
    twice before deploying a configuration change without first saving the change
    to version control and soliciting review.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制和审查配置的做法并不像代码版本控制和审查那样普遍。即使实施了配置即代码的组织通常也不会对配置应用代码级别的严格要求。例如，工程师通常知道他们不应该从本地修改的源代码构建生产版本的二进制文件。这些工程师可能在未将更改保存到版本控制并征求审查的情况下部署配置更改。
- en: Implementing configuration-as-code requires changes to your culture, tooling,
    and processes. Culturally, you need to place importance on the review process.
    Technically, you need tools that allow you to easily compare proposed changes
    (i.e., `diff`, `grep`) and that provide the ability to manually override changes
    in case of emergency.^([10](ch14.html#ch14fn11))
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 实施配置即代码需要改变你的文化、工具和流程。在文化上，你需要重视审查流程。在技术上，你需要工具，允许你轻松比较提议的更改（即`diff`，`grep`），并提供在紧急情况下手动覆盖更改的能力。
- en: Securing Against the Threat Model
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防范威胁模型
- en: 'Now that we’ve defined some best practices, we can map those processes to the
    threats we identified earlier. When evaluating these processes with respect to
    your specific threat model, ask yourself: Are all of the best practices necessary?
    Do they sufficiently mitigate all the threats? [Table 14-1](#example_threatscomma_with_their_corresp)
    lists example threats, along with their corresponding mitigations and potential
    limitations of those mitigations.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一些最佳实践，我们可以将这些流程映射到我们之前确定的威胁上。在评估这些流程与您特定的威胁模型相关时，问问自己：所有最佳实践都是必要的吗？它们是否足以缓解所有威胁？[表14-1](#example_threatscomma_with_their_corresp)列出了示例威胁，以及它们对应的缓解措施和这些缓解措施的潜在限制。
- en: Table 14-1\. Example threats, mitigations, and potential limitations of mitigations
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 表14-1. 示例威胁、缓解措施和缓解措施的潜在限制
- en: '| Threat | Mitigation | Limitations |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 威胁 | 缓解 | 限制 |'
- en: '| --- | --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| An engineer submits a change that accidentally introduces a vulnerability
    to the system. | Code review plus automated testing (see [Chapter 13](ch13.html#onethree_testing_code)).
    This approach significantly reduces the chance of mistakes. |  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 一个工程师提交了一个意外引入系统漏洞的更改。 | 代码审查加自动化测试（见[第13章](ch13.html#onethree_testing_code)）。这种方法显著减少了错误的机会。
    |  |'
- en: '| A malicious adversary submits a change that enables a backdoor or introduces
    some other intentional vulnerability to the system. | Code review. This practice
    increases the cost for attacks and the chance of detection—the adversary has to
    carefully craft the change to get it past code review. | Does not protect against
    collusion or external attackers who are able to compromise multiple insider accounts.
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 一个恶意的对手提交了一个改变，使系统启用了后门或引入了其他有意的漏洞。 | 代码审查。这种做法增加了攻击的成本和检测的机会——对手必须仔细制定更改以通过代码审查。
    | 不能防止串通或外部攻击者能够 compromise 多个内部账户。 |'
- en: '| An engineer accidentally builds from a locally modified version of the code
    that contains unreviewed changes. | An automated CI/CD system that always pulls
    from the correct source repository performs builds. |  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: 一个工程师意外地从包含未经审查的更改的本地修改版本的代码构建。一个自动化的CI/CD系统总是从正确的源代码库中拉取执行构建。
- en: '| An engineer deploys a harmful configuration. For example, the change enables
    debug features in production that were intended only for testing. | Treat configuration
    the same as source code, and require the same level of peer review. | Not all
    configuration can be treated “as code.” |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: 一个工程师部署了一个有害的配置。例如，更改启用了仅用于测试的生产环境中的调试功能。将配置视为源代码，并要求进行相同级别的同行审查。并非所有配置都可以被视为“代码”。
- en: '| A malicious adversary deploys a modified binary to production that begins
    exfiltrating customer credentials. | The production environment requires proof
    that the CI/CD system built the binary. The CI/CD system is configured to pull
    sources from only the correct source repository. | An adversary may figure out
    how to bypass this requirement by using emergency deployment breakglass procedures
    (see [“Practical Advice”](#practical_advice)). Sufficient logging and auditing
    can mitigate this possibility. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: 一个恶意的对手部署了一个修改后的二进制文件到生产环境，开始窃取客户凭据。生产环境需要证明CI/CD系统构建了二进制文件。CI/CD系统配置为只从正确的源代码库中拉取源代码。对手可能会想出如何绕过这一要求，使用紧急部署
    breakglass 程序。充分的日志记录和审计可以缓解这种可能性。
- en: '| A malicious adversary modifies the ACLs of a cloud bucket, allowing them
    to exfiltrate data. | Consider resource ACLs as configuration. The cloud bucket
    only allows configuration changes by the deployment process, so humans can’t make
    changes. | Does not protect against collusion or external attackers who are able
    to compromise multiple insider accounts. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: 一个恶意的对手修改了云存储桶的ACL，使他们能够窃取数据。考虑资源ACL作为配置。云存储桶只允许部署过程进行配置更改，因此人类无法进行更改。不能防止串通或外部攻击者能够
    compromise 多个内部账户。
- en: '| A malicious adversary steals the integrity key used to sign the software.
    | Store the integrity key in a key management system that is configured to allow
    only the CI/CD system to access the key, and that supports key rotation. For more
    information, see [Chapter 9](ch09.html#design_for_recovery). For build-specific
    suggestions, see the recommendations in [“Advanced Mitigation Strategies”](#advanced_mitigation_strategies).
    |  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: 一个恶意的对手窃取了用于签署软件的完整性密钥。将完整性密钥存储在一个密钥管理系统中，该系统配置为只允许CI/CD系统访问密钥，并支持密钥轮换。有关更多信息，请参见[第9章](ch09.html#design_for_recovery)。有关构建特定的建议，请参见[“高级缓解策略”](#advanced_mitigation_strategies)。
- en: '[Figure 14-3](#a_typical_software_supply_chainem_dasha) shows an updated software
    supply chain that includes the threats and mitigations listed in the preceding
    table.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-3](#a_typical_software_supply_chainem_dasha)显示了一个更新的软件供应链，其中包括前面表中列出的威胁和缓解措施。'
- en: '![A typical software supply chain—adversaries should not be able to bypass
    the process](assets/bsrs_1403.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![典型的软件供应链-对手不应能够绕过流程](assets/bsrs_1403.png)'
- en: Figure 14-3\. A typical software supply chain—adversaries should not be able
    to bypass the process
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图14-3。典型的软件供应链-对手不应能够绕过流程
- en: 'We have yet to match several threats with mitigations from best practices:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未将几个威胁与最佳实践中的缓解措施相匹配：
- en: An engineer deploys an old version of the code with a known vulnerability.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工程师部署了一个带有已知漏洞的旧版本代码。
- en: The CI system is misconfigured to allow requests to build from arbitrary source
    repositories. As a result, a malicious adversary can build from a source repository
    containing malicious code.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI系统配置错误，允许从任意源代码仓库构建请求。因此，恶意对手可以从包含恶意代码的源代码仓库构建。
- en: A malicious adversary uploads a custom build script to the CI system that exfiltrates
    the signing key. The adversary then uses that key to sign and deploy a malicious
    binary.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个恶意对手上传了一个自定义的构建脚本到CI系统，用于窃取签名密钥。然后对手使用该密钥对恶意二进制文件进行签名和部署。
- en: A malicious adversary tricks the CD system to use a backdoored compiler or build
    tool that produces a malicious binary.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个恶意对手欺骗CD系统使用一个带有后门的编译器或构建工具来生成恶意二进制文件。
- en: To address these threats, you need to implement more controls, which we cover
    in the following section. Only you can decide whether these threats are worth
    addressing for your particular organization.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些威胁，您需要实施更多的控制，我们将在下一节中介绍。只有您才能决定是否值得为您特定的组织解决这些威胁。
- en: 'DEEP DIVE: Advanced Mitigation Strategies'
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨：高级缓解策略
- en: You may need complex mitigations to address some of the more advanced threats
    to your software supply chain. Because the recommendations in this section are
    not yet standard across the industry, you may need to build some custom infrastructure
    to adopt them. These recommendations are best suited for large and/or particularly
    security-sensitive organizations, and may not make sense for small organizations
    with low exposure to insider risk.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要复杂的缓解措施来解决软件供应链中一些更高级的威胁。因为本节中的建议在行业内尚未成为标准，您可能需要构建一些自定义基础设施来采用这些建议。这些建议最适合规模大和/或特别安全敏感的组织，对于暴露于内部风险较低的小型组织可能没有意义。
- en: Binary Provenance
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二进制来源
- en: 'Every build should produce *binary provenance* describing exactly how a given
    binary artifact was built: the inputs, the transformation, and the entity that
    performed the build.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每次构建都应该生成描述给定二进制工件是如何构建的“二进制来源”：输入、转换和执行构建的实体。
- en: To explain why, consider the following motivating example. Suppose you are investigating
    a security incident and see that a deployment occurred within a particular time
    window. You’d like to determine if the deployment was related to the incident.
    Reverse engineering the binary would be prohibitively expensive. It would be much
    easier to inspect the source code, preferably by looking at changes in version
    control. But how do you know what source code the binary came from?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释原因，考虑以下激励性例子。假设您正在调查一个安全事件，并且看到在特定时间窗口内发生了部署。您想确定部署是否与该事件有关。逆向工程二进制将成本过高。检查源代码将更容易得多，最好是查看版本控制中的更改。但是您如何知道二进制来自哪个源代码？
- en: Even if you don’t anticipate that you’ll need these types of security investigations,
    you’ll also need binary provenance for provenance-based deployment policies, as
    discussed later in this section.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您不预期需要这些类型的安全调查，您也需要基于来源的二进制来源来制定基于来源的部署策略，如本节后面所讨论的。
- en: What to put in binary provenance
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二进制来源中应包含的内容
- en: 'The exact information you should include in the provenance depends on the assumptions
    built into your system and the information that consumers of the provenance will
    eventually need. To enable rich deployment policies and allow for ad hoc analysis,
    we recommend the following provenance fields:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在来源中包含的确切信息取决于您的系统内置的假设和最终需要来源的消费者的信息。为了实现丰富的部署策略并允许临时分析，我们建议以下来源字段：
- en: Authenticity (required)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 真实性（必需）
- en: Connotes implicit information about the build, such as which system produced
    it and why you can trust the provenance. This is usually accomplished using a
    cryptographic signature protecting the rest of the fields of the binary provenance.^([11](ch14.html#ch14fn12))
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 暗示了构建的隐式信息，例如产生它的系统以及您为何可以信任来源。这通常是通过使用加密签名来保护二进制来源的其他字段来实现的。^([11](ch14.html#ch14fn12))
- en: Outputs (required)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 输出（必需）
- en: The output artifacts to which this binary provenance applies. Usually, each
    output is identified by a cryptographic hash of the content of the artifact.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于此二进制来源的输出工件。通常，每个输出都由工件内容的加密哈希标识。
- en: Inputs
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 输入
- en: 'What went into the build. This field allows the verifier to link properties
    of the source code to properties of the artifact. It should include the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 构建中的内容。此字段允许验证者将源代码的属性与工件的属性进行关联。它应包括以下内容：
- en: Sources
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 来源
- en: 'The “main” input artifacts to the build, such as the source code tree where
    the top-level build command ran. For example: “Git commit `270f...ce6d` from `https://github.com/mysql/mysql-server`”^([12](ch14.html#ch14fn13))
    or “file `foo.tar.gz` with SHA-256 content `78c5...6649`.”'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 构建的“主”输入工件，例如顶层构建命令运行的源代码树。例如：“来自`https://github.com/mysql/mysql-server`的Git提交`270f...ce6d`”^([12](ch14.html#ch14fn13))或“文件`foo.tar.gz`的SHA-256内容`78c5...6649`。”
- en: Dependencies
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖
- en: All other artifacts you need for the build—such as libraries, build tools, and
    compilers—that are not fully specified in the sources. Each of these inputs can
    affect the integrity of the build.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 构建所需的所有其他工件，如库、构建工具和编译器，这些工件在源代码中没有完全指定。这些输入都可能影响构建的完整性。
- en: Command
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 命令
- en: 'The command used to initiate the build. For example: “`bazel build //main:hello-world`”.
    Ideally, this field is structured to allow for automated analysis, so our example
    might become “`{"bazel": {"command": "build", "target": "//main:hello_world"}}`”.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '用于启动构建的命令。例如：“`bazel build //main:hello-world`”。理想情况下，该字段应结构化以允许自动化分析，因此我们的示例可能变为“`{"bazel":
    {"command": "build", "target": "//main:hello_world"}}`”。'
- en: Environment
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 环境
- en: Any other information you need to reproduce the build, such as architecture
    details or environment variables.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 需要重现构建的任何其他信息，例如架构细节或环境变量。
- en: Input metadata
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 输入元数据
- en: In some cases, the builder may read metadata about the inputs that downstream
    systems will find useful. For example, a builder might include the timestamp of
    the source commit, which a policy evaluation system then uses at deployment time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，构建者可能会读取有关下游系统将发现有用的输入的元数据。例如，构建者可能包括源提交的时间戳，然后策略评估系统在部署时使用。
- en: Debug info
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 调试信息
- en: Any extra information that isn’t necessary for security but may be useful for
    debugging, such as the machine on which the build ran.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 任何不必要用于安全性但可能对调试有用的额外信息，例如构建运行的机器。
- en: Versioning
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制
- en: A build timestamp and provenance format version number are often useful to allow
    for future changes—for example, so you can invalidate old builds or change the
    format without being susceptible to rollback attacks.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 构建时间戳和溯源格式版本号通常很有用，以便进行将来的更改，例如使旧构建无效或更改格式而不易受到回滚攻击。
- en: You can omit fields that are implicit or covered by the source itself. For example,
    Debian’s provenance format omits the build command because that command is always
    `dpkg-buildpackage`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以省略隐含或由源代码本身覆盖的字段。例如，Debian的溯源格式省略了构建命令，因为该命令始终是`dpkg-buildpackage`。
- en: Input artifacts should generally list both an *identifier*, such as a URI, and
    a *version*, such as a cryptographic hash. You typically use the identifier to
    verify the authenticity of the build—for example, to verify that code came from
    the proper source repository. The version is useful for various purposes, such
    as ad hoc analysis, ensuring reproducible builds, and verification of chained
    build steps where the output of step *i* is the input to step *i*+1.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 输入工件通常应列出*标识符*（例如URI）和*版本*（例如加密哈希）。通常使用标识符来验证构建的真实性，例如验证代码是否来自正确的源代码库。版本对于各种目的都很有用，例如临时分析、确保可重现的构建以及验证链式构建步骤，其中步骤*i*的输出是步骤*i*+1的输入。
- en: Be aware of the attack surface. You need to verify anything not checked by the
    build system (and therefore implied by the signature) or included in the sources
    (and therefore peer reviewed) downstream. If the user who initiated the build
    can specify arbitrary compiler flags, the verifier must validate those flags.
    For example, GCC’s `-D` flag allows the user to overwrite arbitrary symbols, and
    therefore also to completely change the behavior of a binary. Similarly, if the
    user can specify a custom compiler, then the verifier must ensure that the “right”
    compiler was used. In general, the more validation the build process can perform,
    the better.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意攻击面。您需要验证构建系统未检查的任何内容（因此由签名隐含）或包含在源代码中（因此经过同行审查）的内容。如果启动构建的用户可以指定任意编译器标志，则验证器必须验证这些标志。例如，GCC的`-D`标志允许用户覆盖任意符号，因此也可以完全更改二进制文件的行为。同样，如果用户可以指定自定义编译器，则验证器必须确保使用了“正确”的编译器。一般来说，构建过程可以执行的验证越多，越好。
- en: For a good example of binary provenance, see Debian’s [deb-buildinfo](https://oreil.ly/WNUw_)
    format. For more general advice, see [the Reproducible Builds project’s documentation](https://oreil.ly/Y5VFW).
    For a standard way to sign and encode this information, consider [JSON Web Tokens
    (JWT)](https://jwt.io).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有关二进制溯源的一个很好的例子，请参见Debian的[deb-buildinfo](https://oreil.ly/WNUw_)格式。有关更一般的建议，请参见[可重现构建项目的文档](https://oreil.ly/Y5VFW)。要签名和编码此信息的标准方法，请考虑[JSON
    Web Tokens（JWT）](https://jwt.io)。
- en: Provenance-Based Deployment Policies
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于溯源的部署策略
- en: '[“Verify Artifacts, Not Just People”](#verify_artifactscomma_not_just_people)
    recommends that the official build automation pipeline should verify what is being
    deployed. How do you verify that the pipeline is configured properly? And what
    if you want to make specific guarantees for some deployment environments that
    don’t apply to other environments?'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[“验证工件，而不仅仅是人”](#verify_artifactscomma_not_just_people)建议官方构建自动化流水线应该验证正在部署的内容。如何验证流水线配置正确？如果您想为某些部署环境提供特定的保证，而这些保证不适用于其他环境，该怎么办？'
- en: You can use explicit deployment policies that describe the intended properties
    of each deployment environment to address these concerns. The deployment environments
    can then match these policies against the binary provenance of artifacts deployed
    to them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用明确的部署策略来描述每个部署环境的预期属性，以解决这些问题。然后，部署环境可以将这些策略与部署到它们的工件的二进制溯源进行匹配。
- en: 'This approach has several benefits over a pure signature-based approach:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法比纯粹基于签名的方法有几个优点：
- en: It reduces the number of implicit assumptions throughout the software supply
    chain, making it easier to analyze and ensure correctness.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它减少了软件供应链中隐含的假设数量，使分析和确保正确性变得更容易。
- en: It clarifies the contract of each step in the software supply chain, reducing
    the likelihood of misconfiguration.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它澄清了软件供应链中每个步骤的合同，减少了配置错误的可能性。
- en: It allows you to use a single signing key per build step rather than per deployment
    environment, since you can now use the binary provenance for deployment decisions.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许您在每个构建步骤中使用单个签名密钥，而不是每个部署环境，因为现在您可以使用二进制溯源进行部署决策。
- en: For example, suppose you have a microservices architecture and want to guarantee
    that each microservice can be built only from code submitted to that microservice’s
    source repository. Using code signing, you would need one key per source repository,
    and the CI/CD system would have to choose the correct signing key based on the
    source repository. The disadvantage to this approach is that it’s challenging
    to verify that the CI/CD system’s configuration meets these requirements.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您有一个微服务架构，并希望保证每个微服务只能从提交到该微服务源存储库的代码构建。使用代码签名，您需要每个源存储库一个密钥，并且CI/CD系统需要根据源存储库选择正确的签名密钥。这种方法的缺点是很难验证CI/CD系统的配置是否符合这些要求。
- en: Using provenance-based deployment policies, the CI/CD system produces binary
    provenance stating the originating source repository, always signed with a single
    key. The deployment policy for each microservice lists which source repository
    is allowed. Verification of correctness is much easier than with code signing,
    because the deployment policy describes each microservice’s properties in a single
    place.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于溯源的部署策略，CI/CD系统生成了二进制溯源，说明了源存储库，总是由单一密钥签名。每个微服务的部署策略列出了允许的源存储库。与代码签名相比，正确性的验证要容易得多，因为部署策略在一个地方描述了每个微服务的属性。
- en: 'The rules listed in your deployment policy should mitigate the threats to your
    system. Refer to the threat model you created for your system. What rules can
    you define to mitigate those threats? For reference, here are some example rules
    you may want to implement:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 部署策略中列出的规则应该减轻对系统的威胁。参考您为系统创建的威胁模型。您可以定义哪些规则来减轻这些威胁？例如，以下是一些您可能想要实施的示例规则：
- en: Source code was submitted to version control and peer reviewed.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码已提交到版本控制并经过同行审查。
- en: Source code came from a particular location, such as a specific build target
    and repository.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码来自特定位置，比如特定的构建目标和存储库。
- en: Build was through the official CI/CD pipeline (see [“Verifiable Builds”](#verifiable_builds)).
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建是通过官方的CI/CD流水线进行的（参见[“可验证构建”](#verifiable_builds)）。
- en: Tests have passed.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试已通过。
- en: Binary was explicitly allowed for this deployment environment. For example,
    do not allow “test” binaries in production.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制文件在此部署环境中明确允许。例如，不要在生产环境中允许“测试”二进制文件。
- en: Version of code or build is sufficiently recent.^([13](ch14.html#ch14fn14))
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码或构建的版本足够新。^([13](ch14.html#ch14fn14))
- en: Code is free of known vulnerabilities, as reported by a sufficiently recent
    security scan.^([14](ch14.html#ch14fn15))
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码不包含已知的漏洞，如最近的安全扫描所报告的。^([14](ch14.html#ch14fn15))
- en: The [in-toto framework](https://in-toto.github.io) provides one standard for
    implementing provenance policies.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[in-toto框架](https://in-toto.github.io)提供了实施溯源策略的一个标准。'
- en: Implementing policy decisions
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实施政策决策
- en: 'If you implement your own engine for provenance-based deployment policies,
    remember that three steps are necessary:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为基于溯源的部署策略实施自己的引擎，请记住需要三个步骤：
- en: Verify that the *provenance is authentic*. This step also implicitly verifies
    the integrity of the provenance, preventing an adversary from tampering with or
    forging it. Typically, this means verifying that the provenance was cryptographically
    signed by a specific key.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证*溯源的真实性*。这一步还隐式地验证了溯源的完整性，防止对手篡改或伪造它。通常，这意味着验证溯源是否由特定密钥进行了加密签名。
- en: Verify that the *provenance applies to the artifact*. This step also implicitly
    verifies the integrity of the artifact, ensuring an adversary cannot apply an
    otherwise “good” provenance to a “bad” artifact. Typically, this means comparing
    a cryptographic hash of the artifact to the value found within the provenance’s
    payload.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证*溯源是否适用于构件*。这一步还隐式地验证了构件的完整性，确保对手不能将一个“好”的溯源应用于一个“坏”的构件。通常，这意味着比较构件的加密哈希与溯源有效负载中找到的值。
- en: Verify that the *provenance meets all the policy rules*.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证*溯源是否符合所有策略规则*。
- en: 'The simplest example of this process is a rule that requires artifacts to be
    signed by a specific key. This single check implements all three steps: it verifies
    that the signature itself is valid, that the artifact applies to the signature,
    and that the signature is present.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的最简单的例子是一个规则，要求构件必须由特定密钥签名。这个单一的检查实施了所有三个步骤：它验证了签名本身是否有效，构件是否适用于签名，以及签名是否存在。
- en: 'Let’s consider a more complex example: “Docker image must be built from GitHub
    repo `mysql/mysql-server`.” Suppose your build system uses key *K[B]* to sign
    build provenance in a JWT format. In this case, the schema of the token’s payload
    would be the following, where the subject, `sub`, is an [RFC 6920 URI](https://oreil.ly/_8zJm):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个更复杂的例子：“Docker镜像必须从GitHub存储库`mysql/mysql-server`构建。”假设您的构建系统使用密钥*K[B]*以JWT格式签署构建溯源。在这种情况下，令牌有效负载的模式将如下所示，其中主题`sub`是[RFC
    6920 URI](https://oreil.ly/_8zJm)：
- en: '[PRE0]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To evaluate whether an artifact satisfies this rule, the engine needs to verify
    the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要评估构件是否符合此规则，引擎需要验证以下内容：
- en: The JWT signature verifies using key *K[B]*.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JWT签名使用密钥*K[B]*进行验证。
- en: '`sub` matches the SHA-256 hash of the artifact.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sub` 匹配了构件的SHA-256哈希。'
- en: '`input.source_uri` is exactly `"https://github.com/mysql/mysql-server"`.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`input.source_uri` 正好是`"https://github.com/mysql/mysql-server"`。'
- en: Verifiable Builds
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可验证构建
- en: We call a build *verifiable* if the binary provenance produced by the build
    is trustworthy.^([15](ch14.html#ch14fn16)) Verifiability is in the eye of the
    beholder. Whether or not you trust a particular build system depends on your threat
    model and how the build system fits into your organization’s larger security story.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称构建为*可验证的*，如果构建产生的二进制溯源是可信的。^([15](ch14.html#ch14fn16)) 可验证性取决于观察者。您是否信任特定的构建系统取决于您的威胁模型以及构建系统如何融入您组织更大的安全故事。
- en: 'Consider whether the following examples of nonfunctional requirements are appropriate
    for your organization,^([16](ch14.html#ch14fn17)) and add any requirements that
    meet your specific needs:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下非功能性需求示例是否适合你的组织，^([16](ch14.html#ch14fn17))并添加符合你特定需求的任何需求：
- en: If a single developer’s workstation is compromised, the integrity of binary
    provenance or output artifacts is not compromised.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果单个开发者的工作站受到损害，二进制出处或输出物品的完整性不会受到损害。
- en: An adversary cannot tamper with provenance or output artifacts without detection.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对手无法在不被察觉的情况下篡改出处或输出物品。
- en: One build cannot affect the integrity of another build, whether run in parallel
    or serial.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构建不能影响另一个构建的完整性，无论是并行运行还是串行运行。
- en: A build cannot produce provenance containing false information. For example,
    the provenance should not be able to claim an artifact was built from Git commit
    `abc...def` when it really came from `123...456`.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建不能产生包含错误信息的出处。例如，出处不应该声称一个物品是从Git提交`abc...def`构建的，而实际上是来自`123...456`。
- en: Nonadministrators cannot configure user-defined build steps, such as a Makefile
    or a Jenkins Groovy script, in a way that violates any requirement in this list.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非管理员不能配置用户定义的构建步骤，比如Makefile或Jenkins Groovy脚本，以违反此列表中的任何要求。
- en: A snapshot of all source artifacts is available for at least *N* months after
    the build, to allow for potential investigations.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建后至少*N*个月内，所有源物品的快照都可以用于潜在的调查。
- en: A build is reproducible (see [“Hermetic, Reproducible, or Verifiable?”](#hermeticcomma_reproduciblecomma_or_veri)).
    This approach may be desirable even if it is not required by the verifiable build
    architecture, as defined in the next section. For example, reproducible builds
    may be useful to independently reverify the binary provenance of an artifact after
    discovering a security incident or vulnerability.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建是可复现的（参见[“隔离的、可复现的或可验证的？”](#hermeticcomma_reproduciblecomma_or_veri)）。即使在可验证的构建架构中没有要求，这种方法也可能是可取的。例如，在发现安全事件或漏洞后，可复现的构建可能有助于独立重新验证物品的二进制出处。
- en: Verifiable build architectures
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可验证的构建架构
- en: 'The purpose of a verifiable build system is to increase a verifier’s trust
    in the binary provenance produced by that build system. Regardless of the specific
    requirements for verifiability, three main architectures are available:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 可验证构建系统的目的是增加验证者对构建系统产生的二进制出处的信任。无论可验证性的具体要求如何，都有三种主要的架构可供选择：
- en: Trusted build service
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可信的构建服务
- en: The verifier requires that the original build has been performed by a build
    service that the verifier trusts. Usually, this means that the trusted build service
    signs the binary provenance with a key accessible only to that service.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 验证者要求原始构建是由验证者信任的构建服务执行的。通常，这意味着可信的构建服务用只有该服务才能访问的密钥对二进制出处进行签名。
- en: This approach has the advantages of needing to build only once and not requiring
    reproducibility (see [“Hermetic, Reproducible, or Verifiable?”](#hermeticcomma_reproduciblecomma_or_veri)).
    Google uses this model for internal builds.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是只需要构建一次，不需要可复现性（参见[“隔离的、可复现的或可验证的？”](#hermeticcomma_reproduciblecomma_or_veri)）。Google在内部构建中使用这种模型。
- en: A rebuild you perform yourself
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你自己进行的重建
- en: The verifier reproduces the build on the fly in order to validate the binary
    provenance. For example, if the binary provenance claims to come from Git commit
    `abc...def`, the verifier fetches that Git commit, reruns the build commands listed
    in the binary provenance, and checks that the output is bit-for-bit identical
    to the artifact in question. See the following sidebar for more about reproducibility.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 验证者在飞行中重现构建，以验证二进制出处。例如，如果二进制出处声称来自Git提交`abc...def`，验证者会获取该Git提交，重新运行二进制出处中列出的构建命令，并检查输出是否与问题物品完全相同。有关可复现性的更多信息，请参见下面的侧边栏。
- en: While this approach may initially seem appealing because you trust yourself,
    it is not scalable. Builds often take minutes or hours, whereas deployment decisions
    often need to be made in milliseconds. This also requires the build to be fully
    reproducible, which is not always practical; see the sidebar for more information.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法可能一开始看起来很吸引人，因为你信任自己，但它并不具备可扩展性。构建通常需要几分钟甚至几小时，而部署决策通常需要在毫秒内做出。这还要求构建是完全可复现的，这并不总是切实可行；有关更多信息，请参见侧边栏。
- en: Rebuilding service
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 重建服务
- en: The verifier requires that some quorum of “rebuilders” have reproduced the build
    and attested to the authenticity of the binary provenance. This is a hybrid of
    the two previous options. In practice, this approach usually means that each rebuilder
    monitors a package repository, proactively rebuilds each new version, and stores
    the results in some database. Then, the verifier looks up entries in *N* different
    databases, keyed by the cryptographic hash of the artifact in question. Open source
    projects like [Debian](https://oreil.ly/zNZ7G) use this model when a central authority
    model is infeasible or undesirable.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 验证者要求“重建者”中的一些“重建者”已经重现了构建并证明了二进制出处的真实性。这是前两种选项的混合体。在实践中，这种方法通常意味着每个重建者监视一个软件包存储库，主动重建每个新版本，并将结果存储在某个数据库中。然后，验证者在*N*个不同的数据库中查找条目，这些条目以问题物品的加密哈希为键。当中央管理模式不可行或不可取时，像[Debian](https://oreil.ly/zNZ7G)这样的开源项目使用这种模型。
- en: Implementing verifiable builds
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实施可验证的构建
- en: Regardless of whether a verifiable build service is a “trusted build service”
    or a “rebuilding service,” you should keep several important design considerations
    in mind.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 无论可验证的构建服务是“可信的构建服务”还是“重建服务”，都应该牢记一些重要的设计考虑。
- en: 'At a basic level, almost all CI/CD systems function according to the steps
    in [Figure 14-4](#a_basic_cisoliduscd_system): the service takes in requests,
    fetches any necessary inputs, performs the build, and writes the output to a storage
    system.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，几乎所有的CI/CD系统都按照[图14-4](#a_basic_cisoliduscd_system)中的步骤运行：服务接收请求，获取任何必要的输入，执行构建，并将输出写入存储系统。
- en: '![A basic CI/CD system](assets/bsrs_1404.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![一个基本的CI/CD系统](assets/bsrs_1404.png)'
- en: Figure 14-4\. A basic CI/CD system
  id: totrans-191
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图14-4. 一个基本的CI/CD系统
- en: Given such a system, you can add signed provenance to the output relatively
    easily, as shown in [Figure 14-5](#the_addition_of_signing_to_an_existing). For
    a small organization with a “central build service” model, this additional signing
    step may be sufficient to address security concerns.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这样的系统，您可以相对容易地向输出添加签名的来源，如[图14-5](#the_addition_of_signing_to_an_existing)所示。对于一个采用“中央构建服务”模型的小型组织来说，这个额外的签名步骤可能足以解决安全问题。
- en: '![The addition of signing to an existing CI/CD system](assets/bsrs_1405.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![向现有的CI/CD系统添加签名](assets/bsrs_1405.png)'
- en: Figure 14-5\. The addition of signing to an existing CI/CD system
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图14-5. 向现有的CI/CD系统添加签名
- en: 'As the size of your organization grows and you have more resources to invest
    in security, you will likely want to address two more security risks: untrusted
    inputs and unauthenticated inputs.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的组织规模的增长和您有更多的资源投入到安全中，您可能希望解决另外两个安全风险：不受信任的输入和未经身份验证的输入。
- en: Untrusted inputs
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不受信任的输入
- en: 'Adversaries can potentially use the inputs to the build to subvert the build
    process. Many build services allow nonadministrative users to define arbitrary
    commands to execute during the build process—for example, through the Jenkinsfile,
    *travis.yml*, the Makefile, or *BUILD*. This functionality is usually necessary
    to support the wide variety of builds an organization needs. However, from a security
    perspective, this functionality is effectively “Remote Code Execution (RCE) by
    design.” A malicious build command running in a privileged environment could do
    the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对手可能使用构建的输入来颠覆构建过程。许多构建服务允许非管理员用户定义在构建过程中执行的任意命令，例如通过Jenkinsfile、*travis.yml*、Makefile或*BUILD*。从安全的角度来看，这种功能实际上是“远程代码执行（RCE）设计”。在特权环境中运行的恶意构建命令可以执行以下操作：
- en: Steal the signing key.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窃取签名密钥。
- en: Insert false information in the provenance.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在来源中插入错误信息。
- en: Modify the system state, influencing subsequent builds.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改系统状态，影响后续构建。
- en: Manipulate another build that’s happening in parallel.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '操纵另一个同时进行的构建。 '
- en: Even if users are not allowed to define their own steps, compilation is a very
    complex operation that provides ample opportunity for RCE vulnerabilities.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 即使用户不被允许定义自己的步骤，编译是一个非常复杂的操作，提供了充分的机会进行RCE漏洞。
- en: You can mitigate this threat via privilege separation. Use a trusted orchestrator
    process to set up the initial known good state, start the build, and create the
    signed provenance when the build is finished. Optionally, the orchestrator may
    fetch inputs to address the threats described in the following subsection. All
    user-defined build commands should execute within another environment that has
    no access to the signing key or any other special privileges. You can create this
    environment in various ways—for example, through a sandbox on the same machine
    as the orchestrator, or by running on a separate machine.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过特权分离来减轻这种威胁。使用一个受信任的编排器进程来设置初始的已知良好状态，启动构建，并在构建完成时创建签名的来源。可选地，编排器可以获取输入以解决下一小节中描述的威胁。所有用户定义的构建命令应在另一个环境中执行，该环境无法访问签名密钥或任何其他特权。您可以通过各种方式创建这个环境，例如通过与编排器相同的机器上的沙盒，或者在单独的机器上运行。
- en: Unauthenticated inputs
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 未经身份验证的输入
- en: Even if the user and build steps are trustworthy, most builds have dependencies
    on other artifacts. Any such dependency is a surface through which adversaries
    can potentially subvert the build. For example, if the build system fetches a
    dependency over HTTP without TLS, an attacker can perform a man-in-the-middle
    attack to modify the dependency in transit.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 即使用户和构建步骤是可信的，大多数构建都依赖于其他工件。任何这样的依赖都是对手可能潜在颠覆构建的表面。例如，如果构建系统在没有TLS的情况下通过HTTP获取依赖项，攻击者可以进行中间人攻击以修改传输中的依赖项。
- en: For this reason, we recommend hermetic builds (see [“Hermetic, Reproducible,
    or Verifiable?”](#hermeticcomma_reproduciblecomma_or_veri)). The build process
    should declare all inputs up front, and only the orchestrator should fetch those
    inputs. Hermetic builds give much higher confidence that the inputs listed in
    the provenance are correct.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们建议使用隔离构建（参见[“隔离的、可重现的或可验证的？”](#hermeticcomma_reproduciblecomma_or_veri)）。构建过程应该提前声明所有输入，只有编排器应该获取这些输入。隔离构建大大提高了在来源中列出的输入是正确的信心。
- en: Once you’ve accounted for untrusted and unauthenticated inputs, your system
    resembles [Figure 14-6](#an_quotation_markidealquotation_mark_ci). Such a model
    is much more resistant to attack than the simple model in [Figure 14-5](#the_addition_of_signing_to_an_existing).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您考虑了不受信任和未经身份验证的输入，您的系统就类似于[图14-6](#an_quotation_markidealquotation_mark_ci)。这样的模型比[图14-5](#the_addition_of_signing_to_an_existing)中的简单模型更抵抗攻击。
- en: '![An “ideal” CI/CD design that addresses risks of untrusted and unauthenticated
    inputs](assets/bsrs_1406.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![一个“理想”的CI/CD设计，解决了不受信任和未经身份验证输入的风险](assets/bsrs_1406.png)'
- en: Figure 14-6\. An “ideal” CI/CD design that addresses risks of untrusted and
    unauthenticated inputs
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图14-6. 解决不受信任和未经身份验证输入风险的“理想”CI/CD设计
- en: Deployment Choke Points
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署阻塞点
- en: To “verify artifacts, not just people,” deployment decisions must occur at proper
    choke points within the deployment environment. In this context, a *choke point*
    is a point through which all deployment requests must flow. Adversaries can bypass
    deployment decisions that don’t occur at choke points.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要“验证工件，而不仅仅是人”，部署决策必须发生在部署环境内的适当阻塞点。在这种情况下，“阻塞点”是所有部署请求必须流经的点。对手可以绕过不在阻塞点发生的部署决策。
- en: Consider Kubernetes as an example for setting up deployment choke points, as
    shown in [Figure 14-7](#kubernetes_architectureem_dashall_deplo). Suppose you
    want to verify all deployments to the pods in a specific Kubernetes cluster. The
    master node would make a good choke point because all deployments are supposed
    to flow through it. To make this a proper choke point, configure the worker nodes
    to accept requests only from the master node. This way, adversaries cannot deploy
    directly to worker nodes.^([19](ch14.html#ch14fn20))
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以Kubernetes为例，设置部署瓶颈，如[图14-7](#kubernetes_architectureem_dashall_deplo)所示。假设您想要验证特定Kubernetes集群中所有部署到pod的部署。主节点将成为一个良好的瓶颈，因为所有部署都应该通过它进行。为了使其成为一个合适的瓶颈，配置工作节点只接受来自主节点的请求。这样，对手就无法直接部署到工作节点。
- en: '![Kubernetes architecture—all deployments must flow through the master](assets/bsrs_1407.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![Kubernetes架构-所有部署必须通过主节点](assets/bsrs_1407.png)'
- en: Figure 14-7\. Kubernetes architecture—all deployments must flow through the
    master
  id: totrans-214
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图14-7。Kubernetes架构-所有部署必须通过主节点
- en: Ideally, the choke point performs the policy decision, either directly or via
    an RPC. Kubernetes offers an [Admission Controller](https://oreil.ly/Bm04C) webhook
    for this exact purpose. If you use Google Kubernetes Engine, [Binary Authorization](https://oreil.ly/YxiJX)
    offers a hosted admission controller and many additional features. And even if
    you don’t use Kubernetes, you may be able to modify your “admission” point to
    perform the deployment decision.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，瓶颈执行策略决策，可以直接执行，也可以通过RPC执行。Kubernetes为此目的提供了[准入控制器](https://oreil.ly/Bm04C)webhook。如果您使用Google
    Kubernetes Engine，[二进制授权](https://oreil.ly/YxiJX)提供了一个托管的准入控制器和许多其他功能。即使您不使用Kubernetes，您也可以修改“准入”点以执行部署决策。
- en: Alternatively, you can place a “proxy” in front of the choke point and perform
    the policy decision in the proxy, as shown in [Figure 14-8](#alternative_architecture_using_a_proxy).
    This approach requires configuring your “admission” point to allow access only
    via the proxy. Otherwise, an adversary can bypass the proxy by talking directly
    to the admission point.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在瓶颈前放置一个“代理”，并在代理中执行策略决策，如[图14-8](#alternative_architecture_using_a_proxy)所示。这种方法需要配置您的“准入”点，只允许通过代理访问。否则，对手可以通过直接与准入点通信来绕过代理。
- en: '![Alternative architecture using a proxy to make policy decisions](assets/bsrs_1408.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![使用代理进行策略决策的替代架构](assets/bsrs_1408.png)'
- en: Figure 14-8\. Alternative architecture using a proxy to make policy decisions
  id: totrans-218
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图14-8。使用代理进行策略决策的替代架构
- en: Post-Deployment Verification
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署后验证
- en: 'Even when you enforce deployment policies or signature checks at deployment
    time, logging and post-deployment verification are almost always desirable, for
    the following reasons:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在部署时执行部署策略或签名检查时，记录和部署后验证几乎总是可取的，原因如下：
- en: '*Policies can change*, in which case the verification engine must reevaluate
    existing deployments in the system to ensure they still comply with the new policies.
    This is particularly important when enabling a policy for the first time.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*策略可能会更改*，在这种情况下，验证引擎必须重新评估系统中现有的部署，以确保它们仍然符合新的策略。这在首次启用策略时尤为重要。'
- en: The request might have been allowed to proceed because the decision service
    was unavailable. This *fail open* design is often necessary to ensure the availability
    of the service, especially when first rolling out an enforcement feature.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于决策服务不可用，请求可能已被允许继续进行。这种*故障开放*设计通常是必要的，以确保服务的可用性，特别是在首次推出执行功能时。
- en: An operator might have used a *breakglass mechanism* to bypass the decision
    in the case of an emergency, as described in the following section.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在紧急情况下，操作员可能使用了*紧急开关机制*来绕过决策，如下一节所述。
- en: Users need a way to *test* potential policy changes before committing them,
    to make sure that the existing state won’t violate the new version of the policy.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户需要一种方法，在提交之前*测试*潜在的策略更改，以确保现有状态不会违反新版本的策略。
- en: For reasons similar to the “fail open” use case, users may also want a *dry
    run* mode, where the system always allows requests at deployment time but monitoring
    surfaces potential problems.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出于类似于“故障开放”用例的原因，用户可能还希望有一种*干预运行*模式，在部署时系统始终允许请求，但监控会发现潜在问题。
- en: Investigators may need the information after an incident for *forensics* reasons.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查人员可能需要在事故发生后出于*取证*目的获取信息。
- en: 'The enforcement decision point must log enough information to allow the verifier
    to evaluate the policy after the deployment.^([20](ch14.html#ch14fn21)) Logging
    of the full request is usually necessary but not always sufficient—if policy evaluation
    requires some other state, the logs must include that extra state. For example,
    we ran into this issue when implementing post-deployment verification for Borg:
    because “job” requests include references to existing “allocs” and “packages,”
    we had to join three log sources—jobs, allocs, and packages—to get the full state
    necessary to make a decision.^([21](ch14.html#ch14fn22))'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 执行决策点必须记录足够的信息，以便验证器在部署后评估策略。^([20](ch14.html#ch14fn21))通常需要记录完整的请求，但并不总是足够的-如果策略评估需要一些其他状态，则日志必须包括该额外状态。例如，当我们为Borg实现部署后验证时遇到了这个问题：因为“作业”请求包括对现有“分配”和“包”引用，我们必须连接三个日志来源-作业，分配和包-以获取做出决策所需的完整状态。^([21](ch14.html#ch14fn22))
- en: Practical Advice
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实用建议
- en: We’ve learned several lessons over the years while implementing verifiable builds
    and deployment policies in a variety of contexts. Most of these lessons are less
    about the actual technology choices, and more about how to deploy changes that
    are reliable, easy to debug, and easy to understand. This section contains some
    practical advice that we hope you’ll find useful.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，在各种情境中实施可验证的构建和部署策略时，我们学到了一些经验教训。这些经验教训大多与实际技术选择无关，而更多地与如何部署可靠、易于调试和易于理解的更改有关。本节包含一些建议，希望您会发现有用。
- en: Take It One Step at a Time
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逐步进行
- en: Providing a highly secure, reliable, and consistent software supply chain will
    likely require you to make many changes—from scripting your build steps, to implementing
    build provenance, to implementing configuration-as-code. Coordinating all of those
    changes may be difficult. Bugs or missing functionality in these controls can
    also pose a significant risk to engineering productivity. In the worst-case scenario,
    an error in these controls can potentially cause an outage for your service.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 提供高度安全、可靠和一致的软件供应链可能需要您进行许多更改，从编写构建步骤到实施构建来源，再到实施配置即代码。协调所有这些更改可能很困难。这些控件中的错误或缺失功能也可能对工程生产力构成重大风险。在最坏的情况下，这些控件中的错误可能导致服务中断。
- en: You may be more successful if you focus on securing one particular aspect of
    the supply chain at a time. That way, you can minimize the risk of disruption
    while also helping your coworkers learn new workflows.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一次专注于保护供应链的一个特定方面，可能会更成功。这样，您可以最大程度地减少中断风险，同时还可以帮助同事学习新的工作流程。
- en: Provide Actionable Error Messages
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供可操作的错误消息
- en: When a deployment is rejected, the error message must clearly explain what went
    wrong and how to fix the situation. For example, if an artifact is rejected because
    it was built from an incorrect source URI, the fix can be to either update the
    policy to allow that URI, or to rebuild from the correct URI. Your policy decision
    engine should give the user actionable feedback that provides such suggestions.
    Simply saying “does not meet policy” will likely leave the user confused and floundering.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当部署被拒绝时，错误消息必须清楚地解释出了什么问题以及如何解决。例如，如果工件被拒绝是因为从错误的源URI构建的，解决方法可以是更新策略以允许该URI，或者从正确的URI重新构建。您的策略决策引擎应该给用户提供可操作的反馈，提供这样的建议。简单地说“不符合策略”可能会让用户感到困惑和手足无措。
- en: Consider these user journeys when designing your architecture and policy language.
    Some design choices make providing actionable feedback for users very difficult,
    so try to catch these problems early. For example, one of our early policy language
    prototypes offered a lot of flexibility in expressing policies, but prevented
    us from supplying actionable error messages. We ultimately abandoned this approach
    in favor of a very limited language that allowed for better error messages.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计架构和策略语言时，请考虑这些用户旅程。一些设计选择会使为用户提供可操作的反馈变得非常困难，因此请尽早发现这些问题。例如，我们早期的策略语言原型提供了许多表达策略的灵活性，但阻止我们提供可操作的错误消息。我们最终放弃了这种方法，转而采用了一种非常有限的语言，可以提供更好的错误消息。
- en: Ensure Unambiguous Provenance
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保来源清晰
- en: Google’s verifiable build system originally uploaded binary provenance to a
    database asynchronously. Then at deployment time, the policy engine looked up
    the provenance in the database using the hash of the artifact as a key.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌的可验证构建系统最初将二进制来源异步上传到数据库。然后在部署时，策略引擎使用工件的哈希作为键在数据库中查找来源。
- en: 'While this approach *mostly* worked just fine, we ran into a major issue: users
    could build an artifact multiple times, resulting in multiple entries for the
    same hash. Consider the case of the empty file: we had literally millions of provenance
    records tied to the hash of the empty file, since many different builds produced
    an empty file as part of their output. In order to verify such a file, our system
    had to check whether *any* of the provenance records passed the policy. This in
    turn resulted in two problems:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法*大多*运行良好，但我们遇到了一个主要问题：用户可以多次构建工件，导致相同哈希的多个条目。考虑空文件的情况：我们有数百万条与空文件的哈希相关的来源记录，因为许多不同的构建生成了空文件作为其输出的一部分。为了验证这样的文件，我们的系统必须检查*任何*来源记录是否符合策略。这反过来又导致了两个问题：
- en: When we failed to find a passing record, we had no way to provide actionable
    error messages. For example, instead of saying, “The source URI was *X*, but the
    policy said it was supposed to be *Y*,” we had to say, “None of these 497,129
    records met the policy.” This was a bad user experience.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们未能找到通过记录时，我们无法提供可操作的错误消息。例如，我们不得不说，“源URI是*X*，但策略应该是*Y*”，而不是“这497,129条记录中没有一条符合策略”。这是糟糕的用户体验。
- en: Verification time was linear in the number of records returned. This caused
    us to exceed our 100 ms latency SLO by several orders of magnitude!
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证时间与返回的记录数量成正比。这导致我们的延迟SLO超出了100毫秒数倍！
- en: We also ran into issues with the asynchronous upload to the database. Uploads
    could fail silently, in which case our policy engine would reject the deployment.
    Meanwhile, users didn’t understand why it had been rejected. We could have fixed
    this problem by making the upload synchronous, but that solution would have made
    our build system less reliable.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还遇到了与数据库的异步上传问题。上传可能会悄无声息地失败，这种情况下我们的策略引擎会拒绝部署。与此同时，用户不明白为什么被拒绝。我们本可以通过使上传同步来解决这个问题，但这种解决方案会使我们的构建系统不太可靠。
- en: Therefore, we strongly recommend making provenance unambiguous. Whenever possible,
    avoid using databases and instead *propagate the provenance inline with the artifact*.
    Doing so makes the overall system more reliable, lower latency, and easier to
    debug. For example, a system using Kubernetes can add an annotation that’s passed
    to the Admission Controller webhook.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们强烈建议使来源清晰。在可能的情况下，避免使用数据库，而是*内联传播来源与工件*。这样做可以使整个系统更可靠，延迟更低，更易于调试。例如，使用Kubernetes的系统可以添加一个传递给Admission
    Controller webhook的注释。
- en: Create Unambiguous Policies
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建明确的策略
- en: 'Similar to our recommended approach to an artifact’s provenance, the policy
    that applies to a particular deployment should be unambiguous. We recommend designing
    the system so that only a single policy applies to any given deployment. Consider
    the alternative: if two policies apply, do both policies need to pass, or can
    just one policy pass? It’s easier to avoid this question altogether. If you want
    to apply a global policy across an organization, you can do so as a meta-policy:
    implement a check that all of the individual policies meet some global criteria.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们推荐的工件来源的方法类似，适用于特定部署的策略应该是明确的。我们建议设计系统，以便任何给定的部署只适用一个策略。考虑另一种选择：如果有两个策略适用，那么两个策略都需要通过吗，还是只需要一个策略通过？最好完全避免这个问题。如果您想在整个组织中应用全局策略，可以将其作为元策略实施：实施一个检查，以确保所有个体策略符合一些全局标准。
- en: Include a Deployment Breakglass
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包括部署breakglass
- en: In an emergency, it may be necessary to bypass the deployment policy. For example,
    an engineer may need to reconfigure a frontend to divert traffic from a failing
    backend, and the corresponding configuration-as-code change might take too long
    to deploy through the regular CI/CD pipeline. A breakglass mechanism that bypasses
    the policy can allow engineers to quickly resolve outages and promotes a culture
    of security and reliability (see [Chapter 21](ch21.html#twoone_building_a_culture_of_security_a)).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在紧急情况下，可能需要绕过部署策略。例如，工程师可能需要重新配置前端以将流量从失败的后端转移，相应的配置即代码更改可能需要通过常规CI/CD管道部署太长时间。绕过策略的breakglass机制可以让工程师快速解决故障，并促进安全和可靠性的文化（见[第21章](ch21.html#twoone_building_a_culture_of_security_a)）。
- en: Because adversaries may exploit the breakglass mechanism, all breakglass deployments
    must raise alarms and be audited quickly. In order to make auditing practical,
    breakglass events should be rare—if there are too many events, it may not be possible
    to differentiate malicious activity from legitimate usage.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对手可能利用breakglass机制，所有breakglass部署必须迅速引发警报并进行审计。为了使审计变得实用，breakglass事件应该是罕见的——如果事件太多，可能无法区分恶意活动和合法使用。
- en: Securing Against the Threat Model, Revisited
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视威胁模型的安全防护
- en: We can now map advanced mitigations to our previously unaddressed threats, as
    shown in [Table 14-2](#advanced_mitigations_to_complex_threat).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将高级缓解措施映射到以前未解决的威胁，如[表14-2](#advanced_mitigations_to_complex_threat)所示。
- en: Table 14-2\. Advanced mitigations to complex threat examples
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 表14-2. 复杂威胁示例的高级缓解措施
- en: '| Threat | Mitigation |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: 威胁 | 缓解
- en: '| --- | --- |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| An engineer deploys an old version of the code with a known vulnerability.
    | The deployment policy requires the code to have undergone a security vulnerability
    scan within the last *N* days. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 工程师部署了一个存在已知漏洞的旧版本代码。 | 部署策略要求代码在过去的*N*天内进行了安全漏洞扫描。'
- en: '| The CI system is misconfigured to allow requests to build from arbitrary
    source repositories. As a result, a malicious adversary can build from a source
    repository containing malicious code. | The CI system generates binary provenance
    describing what source repository it pulled from. The production environment enforces
    a deployment policy requiring provenance to prove that the deployed artifact originated
    from an approved source repository. |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| CI系统配置错误，允许从任意源代码库构建请求。结果，恶意对手可以从包含恶意代码的源代码库构建。 | CI系统生成描述其拉取源代码库的二进制来源。生产环境强制执行部署策略，要求来源证明部署的工件来自批准的源代码库。'
- en: '| A malicious adversary uploads a custom build script to the CI system that
    exfiltrates the signing key. The adversary then uses that key to sign and deploy
    a malicious binary. | The verifiable build system separates privileges so that
    the component that runs custom build scripts does not have access to the signing
    key. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 恶意对手向CI系统上传自定义构建脚本，窃取签名密钥。然后对手使用该密钥签名和部署恶意二进制文件。 | 可验证构建系统分离权限，以便运行自定义构建脚本的组件无法访问签名密钥。'
- en: '| A malicious adversary tricks the CD system to use a backdoored compiler or
    build tool that produces a malicious binary. | Hermetic builds require developers
    to explicitly specify the choice of compiler and build tool in the source code.
    This choice is peer reviewed like all other code. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 恶意对手欺骗CD系统使用带有后门的编译器或构建工具生成恶意二进制文件。 | 严格构建要求开发人员在源代码中明确指定编译器和构建工具的选择。这个选择像所有其他代码一样经过同行评审。'
- en: With appropriate security controls around your software supply chain, you can
    mitigate even advanced and complex threats.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在软件供应链周围采取适当的安全控制，您可以缓解甚至是高级和复杂的威胁。
- en: Conclusion
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: The recommendations in this chapter can help you harden your software supply
    chain against various insider threats. Code reviews and automation are essential
    tactics for preventing mistakes and increasing attack costs for malicious actors.
    Configuration-as-code extends those benefits to configuration, which traditionally
    receives much less scrutiny than code. Meanwhile, artifact-based deployment controls,
    particularly those involving binary provenance and verifiable builds, bring protection
    against sophisticated adversaries and allow you to scale as your organization
    grows.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的建议可以帮助您加强软件供应链对各种内部威胁的防范。代码审查和自动化是防止错误和增加恶意行为攻击成本的基本策略。代码作为配置将这些好处扩展到传统上受到比代码更少关注的配置。同时，基于工件的部署控制，特别是涉及二进制来源和可验证构建的控制，可以提供对复杂对手的保护，并允许您随着组织的增长而扩展。
- en: Together, these recommendations help ensure that the code you wrote and tested
    (following the principles in Chapters [12](ch12.html#writing_code) and [13](ch13.html#onethree_testing_code))
    is the code that’s actually deployed in production. Despite your best efforts,
    however, your code probably won’t always behave as expected. When that happens,
    you can use some of the debugging strategies presented in the next chapter.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 7.这些建议有助于确保您编写和测试的代码（遵循第[12](ch12.html#writing_code)章和第[13](ch13.html#onethree_testing_code)章的原则）实际上是部署在生产环境中的代码。然而，尽管您已经尽力，您的代码可能并不总是按预期行为。当发生这种情况时，您可以使用下一章介绍的一些调试策略。
- en: ^([1](ch14.html#ch14fn1-marker)) Code reviews also apply to changes to configuration
    files; see [“Treat Configuration as Code”](#treat_configuration_as_code).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 18.（[1](ch14.html#ch14fn1-marker)）代码审查也适用于对配置文件的更改；请参阅[“将配置视为代码”](#treat_configuration_as_code)。
- en: '^([2](ch14.html#ch14fn2-marker)) Sadowski, Caitlin et al. 2018\. “Modern Code
    Review: A Case Study at Google.” *Proceedings of the 40th International Conference
    on Software Engineering*: 181–190\. doi:10.1145/3183519.3183525.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 11.（[2](ch14.html#ch14fn2-marker)）Sadowski, Caitlin等人。2018年。“现代代码审查：谷歌的案例研究。”*第40届国际软件工程大会论文集*：181-190。doi:10.1145/3183519.3183525。
- en: ^([3](ch14.html#ch14fn3-marker)) When combined with configuration-as-code and
    the deployment policies described in this chapter, code reviews form the basis
    of a multi-party authorization system for arbitrary systems.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 2.（[3](ch14.html#ch14fn3-marker)）当与配置即代码和本章描述的部署策略结合时，代码审查构成了任意系统的多方授权系统的基础。
- en: ^([4](ch14.html#ch14fn4-marker)) For more on the responsibilities of the code
    reviewer, see [“Culture of Review”](ch21.html#culture_of_review).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 1.（[4](ch14.html#ch14fn4-marker)）有关代码审查者的责任，请参阅[“审查文化”](ch21.html#culture_of_review)。
- en: ^([5](ch14.html#ch14fn5-marker)) The *chain* of steps need not be fully automatic.
    For example, it is usually acceptable for a human to be able to initiate a build
    or deployment step. However, the human should not be able to influence the behavior
    of that step in any meaningful way.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 3.（[5](ch14.html#ch14fn5-marker)）步骤的“链”不一定需要完全自动。例如，通常可以接受人类能够启动构建或部署步骤。但是，人类不应该能够以任何有意义的方式影响该步骤的行为。
- en: ^([6](ch14.html#ch14fn7-marker)) That said, such authorization checks are still
    necessary for the principle of least privilege (see [Chapter 5](ch05.html#design_for_least_privilege)).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 16.（[6](ch14.html#ch14fn7-marker)）尽管如此，这样的授权检查对于最小特权原则仍然是必要的（请参阅[第5章](ch05.html#design_for_least_privilege)）。
- en: ^([7](ch14.html#ch14fn8-marker)) A breakglass mechanism can bypass policies
    to allow engineers to quickly resolve outages. See [“Breakglass”](ch05.html#breakglass).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 10.（[7](ch14.html#ch14fn8-marker)）紧急开关机制可以绕过策略，允许工程师快速解决故障。请参阅[“紧急开关”](ch05.html#breakglass)。
- en: ^([8](ch14.html#ch14fn9-marker)) This concept is discussed in more detail in
    [Chapter 8 of the SRE book](https://landing.google.com/sre/sre-book/chapters/release-engineering/)
    and Chapters [14](https://landing.google.com/sre/workbook/chapters/configuration-design/)
    and [15](https://landing.google.com/sre/workbook/chapters/configuration-specifics/)
    of the SRE workbook. The recommendations in all of those chapters apply here.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 4.（[8](ch14.html#ch14fn9-marker)）这个概念在[SRE书籍第8章](https://landing.google.com/sre/sre-book/chapters/release-engineering/)和SRE
    workbook的第[14](https://landing.google.com/sre/workbook/chapters/configuration-design/)章和第[15](https://landing.google.com/sre/workbook/chapters/configuration-specifics/)章中有更详细的讨论。所有这些章节中的建议都适用于这里。
- en: ^([9](ch14.html#ch14fn10-marker)) YAML is the [configuration language](https://oreil.ly/UKo2t)
    used by Kubernetes.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 12.（[9](ch14.html#ch14fn10-marker)）YAML是Kubernetes使用的[配置语言](https://oreil.ly/UKo2t)。
- en: ^([10](ch14.html#ch14fn11-marker)) You must log and audit these manual overrides,
    lest an adversary use manual overrides as an attack vector.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 5.（[10](ch14.html#ch14fn11-marker)）您必须记录和审计这些手动覆盖，以防对手使用手动覆盖作为攻击向量。
- en: ^([11](ch14.html#ch14fn12-marker)) Note that authenticity implies integrity.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 15.（[11](ch14.html#ch14fn12-marker)）请注意，真实性意味着完整性。
- en: ^([12](ch14.html#ch14fn13-marker)) Git commit IDs are cryptographic hashes that
    provide integrity of the entire source tree.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 6.（[12](ch14.html#ch14fn13-marker)）Git提交ID是提供整个源代码树完整性的加密哈希。
- en: ^([13](ch14.html#ch14fn14-marker)) For a discussion on rollbacks to vulnerable
    versions, see [“Minimum Acceptable Security Version Numbers”](ch09.html#minimum_acceptable_security_version_num).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 8.（[13](ch14.html#ch14fn14-marker)）有关回滚到有漏洞版本的讨论，请参阅[“最低可接受的安全版本号”](ch09.html#minimum_acceptable_security_version_num)。
- en: ^([14](ch14.html#ch14fn15-marker)) For example, you might require proof that
    [Cloud Security Scanner](https://oreil.ly/mrTi7) found no results against your
    test instance running this specific version of the code.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 13.（[14](ch14.html#ch14fn15-marker)）例如，您可能需要证明[Cloud Security Scanner](https://oreil.ly/mrTi7)在运行此特定代码版本的测试实例时未发现任何结果。
- en: ^([15](ch14.html#ch14fn16-marker)) Recall that pure signatures still count as
    “binary provenance,” as described in the previous section.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 14.（[15](ch14.html#ch14fn16-marker)）请记住，纯签名仍然算作“二进制来源”，如前一节所述。
- en: ^([16](ch14.html#ch14fn17-marker)) See [“Design Objectives and Requirements”](ch04.html#design_objectives_and_requirements).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '17.（[16](ch14.html#ch14fn17-marker)）请参阅[“设计目标和要求”](ch04.html#design_objectives_and_requirements)。 '
- en: ^([17](ch14.html#ch14fn18-marker)) For example, the [SRE book](https://landing.google.com/sre/sre-book/chapters/release-engineering/#hermetic-builds-nqslhnid)
    uses the terms *hermetic* and *reproducible* interchangeably. The [Reproducible
    Builds project](https://reproducible-builds.org) defines *reproducible* the same
    way this chapter defines the term, but occasionally overloads *reproducible* to
    mean *verifiable*.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 9.（[17](ch14.html#ch14fn18-marker)）例如，[SRE书籍](https://landing.google.com/sre/sre-book/chapters/release-engineering/#hermetic-builds-nqslhnid)将“hermetic”和“reproducible”这两个术语互换使用。[Reproducible
    Builds项目](https://reproducible-builds.org)将“reproducible”定义为本章定义的方式，但有时也会将“reproducible”重载为“可验证”。
- en: ^([18](ch14.html#ch14fn19-marker)) As a counterexample, consider a build process
    that fetches the latest version of a dependency during the build but otherwise
    produces identical outputs. This process is reproducible so long as two builds
    happen at roughly the same time, but is not hermetic.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ^([18](ch14.html#ch14fn19-marker)) 作为一个反例，考虑一个构建过程，在构建过程中获取依赖的最新版本，但在其他方面产生相同的输出。只要两次构建大致同时发生，这个过程就是可重现的，但不是完全隔离的。
- en: ^([19](ch14.html#ch14fn20-marker)) In reality, there must be some way to deploy
    software to the node itself—the bootloader, the operating system, the Kubernetes
    software, and so on—and that deployment mechanism must have its own policy enforcement,
    which is likely a completely different implementation than the one used for pods.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ^([19](ch14.html#ch14fn20-marker)) 实际上，必须有一种方式将软件部署到节点本身——引导加载程序、操作系统、Kubernetes
    软件等等——而且该部署机制必须有自己的策略执行，这很可能是与用于 pod 的实现完全不同的实现。
- en: ^([20](ch14.html#ch14fn21-marker)) Ideally, the logs are highly reliable and
    tamper-evident, even in the face of outages or system compromise. For example,
    suppose a Kubernetes master receives a request while the logging backend is unavailable.
    The master can temporarily save the log to local disk. What if the machine dies
    before the logging backend comes back up? Or what if the machine runs out of space?
    This is a challenging area for which we’re still developing solutions.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ^([20](ch14.html#ch14fn21-marker)) 理想情况下，日志是非常可靠和防篡改的，即使在停机或系统受到威胁的情况下也是如此。例如，假设
    Kubernetes 主节点在日志后端不可用时接收到一个请求。主节点可以暂时将日志保存到本地磁盘。如果机器在日志后端恢复之前死机了怎么办？或者如果机器的空间用完了怎么办？这是一个具有挑战性的领域，我们仍在开发解决方案。
- en: '^([21](ch14.html#ch14fn22-marker)) A Borg alloc (short for *allocation*) is
    a reserved set of resources on a machine in which one or more sets of Linux processes
    can be run in a container. Packages contain the Borg job’s binaries and data files.
    For a complete description of Borg, see Verma, Abhishek et al. 2015\. “Large-Scale
    Cluster Management at Google with Borg.” *Proceedings of the 10th European Conference
    on Computer Systems*: 1–17\. doi:10.1145/2741948.2741964.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ^([21](ch14.html#ch14fn22-marker)) Borg 分配（简称 *分配*）是机器上一组保留的资源，其中可以在容器中运行一个或多个
    Linux 进程集。软件包包含 Borg 作业的二进制文件和数据文件。有关 Borg 的完整描述，请参见 Verma, Abhishek 等人 2015 年的文章《Google
    的 Borg 大规模集群管理》。*第 10 届欧洲计算机系统会议论文集*：1–17。doi:10.1145/2741948.2741964。

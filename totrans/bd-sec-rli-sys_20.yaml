- en: Chapter 15\. Investigating Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章。调查系统
- en: By Pete Nuttall, Matt Linton‎, and David Seidman
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Pete Nuttall、Matt Linton和David Seidman
- en: with Vera Haas, Julie Saracino, and Amaya Booker
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与Vera Haas、Julie Saracino和Amaya Booker
- en: In an ideal world, we would all build perfect systems, and our users would have
    only the best of intentions. In reality, you’ll encounter bugs and need to conduct
    security investigations. As you observe a system running in production over time,
    you’ll identify areas for improvement and places where you can streamline and
    optimize processes. All of these tasks require debugging and investigation techniques,
    and appropriate system access.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界中，我们都会构建完美的系统，我们的用户只会怀有最好的意图。然而，在现实中，您会遇到错误，并需要进行安全调查。当您观察生产中运行的系统时，您会确定需要改进的地方，以及可以简化和优化流程的地方。所有这些任务都需要调试和调查技术，以及适当的系统访问。
- en: However, granting even read-only debugging access creates a risk that this access
    may be abused. To address this risk, you need proper security mechanisms in place.
    You also need to strike a careful balance between the debugging needs of developers
    and operations staff, and the security requirements of storing and accessing sensitive
    data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使是只读调试访问也会带来滥用的风险。为了解决这一风险，您需要适当的安全机制。您还需要在开发人员和运营人员的调试需求与存储和访问敏感数据的安全要求之间取得谨慎的平衡。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: In this chapter, we use the term *debugger* to mean a human who is debugging
    software problems—not [GDB (the GNU Debugger)](https://oreil.ly/Fl82Z) or similar
    tools. Unless otherwise noted, we use the term “we” to refer to the authors of
    this chapter, not Google as a whole.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用术语*调试器*来指代调试软件问题的人类，而不是[GDB（GNU调试器）](https://oreil.ly/Fl82Z)或类似的工具。除非另有说明，我们使用“我们”一词来指代本章的作者，而不是整个谷歌公司。
- en: From Debugging to Investigation
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从调试到调查
- en: '[T]he realization came over me with full force that a good part of the remainder
    of my life was going to be spent in finding errors in my own programs.'
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “我完全意识到，我余生的很大一部分时间将花在查找自己程序中的错误上。”
- en: '>'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: —Maurice Wilkes, Memoirs of a Computer Pioneer (MIT Press, 1985)
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —Maurice Wilkes，《计算机先驱的回忆录》（麻省理工学院出版社，1985年）
- en: Debugging has a bad reputation. Bugs surface at the worst of times. It can be
    hard to estimate when a bug will be fixed, or when a system will be “good enough”
    to let many people use it. For most people, it’s more fun to write new code than
    to debug existing programs. Debugging can be perceived as unrewarding. However,
    it’s necessary, and you may even find the practice enjoyable when viewed through
    the lens of learning new facts and tools. In our experience, debugging also makes
    us better programmers, and reminds us that sometimes we’re not as smart as we
    think we are.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 调试声誉不佳。错误总是在最糟糕的时候出现。很难估计错误何时会被修复，或者何时系统会“足够好”让许多人使用。对大多数人来说，编写新代码比调试现有程序更有趣。调试可能被认为是没有回报的。然而，它是必要的，当通过学习新的事实和工具的视角来看待时，你甚至可能会发现这种实践是令人愉快的。根据我们的经验，调试也使我们成为更好的程序员，并提醒我们有时我们并不像我们认为的那么聪明。
- en: 'Example: Temporary Files'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：临时文件
- en: 'Consider the following outage, which we (the authors) debugged two years ago.^([1](ch15.html#ch15fn2))
    The investigation began when we received an alert that a [Spanner database](https://oreil.ly/ZYr1W)
    was running out of storage quota. We went through the process of debugging, asking
    ourselves the following questions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下停机事件，我们（作者）在两年前调试过。[1]调查开始时，我们收到了一个警报，称[Spanner数据库](https://oreil.ly/ZYr1W)的存储配额即将用完。我们经历了调试过程，问自己以下问题：
- en: What caused the database to run out of storage?
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是什么导致数据库存储空间不足？
- en: Quick triage indicated the problem was caused by an accumulation of many small
    files being created in Google’s massive distributed filesystem, [Colossus](https://oreil.ly/dkocj),
    which was likely triggered by a change in user request traffic.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 快速分诊表明，问题是由谷歌庞大的分布式文件系统[Colossus](https://oreil.ly/dkocj)中创建了许多小文件积累导致的，这可能是由用户请求流量的变化触发的。
- en: What was creating all the tiny files?
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是什么在创建所有这些小文件？
- en: We looked at service metrics, which showed the files resulted from the Spanner
    server running low on memory. According to normal behavior, recent writes (updates)
    were buffered in memory; as the server ran low on memory, it flushed the data
    to files on Colossus. Unfortunately, each server in the Spanner zone had only
    a small amount of memory to accommodate updates. As a result, rather than flushing
    a manageable number of larger, compressed files,^([2](ch15.html#ch15fn3)) each
    server flushed many tiny files to Colossus.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看了服务指标，显示这些文件是Spanner服务器内存不足导致的。根据正常行为，最近的写入（更新）被缓存在内存中；当服务器内存不足时，它将数据刷新到Colossus上的文件中。不幸的是，Spanner区中的每台服务器只有少量内存来容纳更新。因此，与其刷新可管理数量的较大、压缩的文件，[2]每台服务器都会刷新许多小文件到Colossus。
- en: Where was the memory being used?
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存使用在哪里？
- en: Each server ran as a Borg task (in a container), which capped the memory available
    to it.^([3](ch15.html#ch15fn4)) To determine where within the kernel memory was
    used, we directly issued the `slabtop` command on the production machine. We determine
    that the directory entry (dentry) cache was the largest user of memory.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务器都作为一个Borg任务（在容器中）运行，这限制了可用的内存。[3]为了确定内核内存的使用位置，我们直接在生产机器上发出了`slabtop`命令。我们确定目录条目（dentry）缓存是内存的最大使用者。
- en: Why was the dentry cache so big?
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么dentry缓存这么大？
- en: We made an educated guess that the Spanner database server was creating and
    deleting vast numbers of temporary files—a few for each flush operation. Each
    flush operation increased the size of the dentry cache, making the problem worse.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做出了一个合理的猜测，即Spanner数据库服务器正在创建和删除大量临时文件——每次刷新操作都会有一些。每次刷新操作都会增加dentry缓存的大小，使问题变得更糟。
- en: How could we confirm our hypothesis?
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何确认我们的假设？
- en: To test this theory, we created and ran a program on Borg to reproduce the bug
    by creating and deleting files in a loop. After a few million files, the dentry
    cache had used all the memory in its container, confirming the hypothesis.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这个理论，我们在Borg上创建并运行了一个程序，通过在循环中创建和删除文件来复现这个错误。几百万个文件后，dentry缓存已经使用了容器中的所有内存，证实了假设。
- en: Was this a kernel bug?
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个内核bug吗？
- en: We researched expected behavior of the Linux kernel, and determined that the
    kernel caches the nonexistence of files—some build systems need this feature to
    ensure acceptable performance. In normal operation, the kernel evicts entries
    from the dentry cache when the container is full. However, because the Spanner
    server repeatedly flushed updates, the container never became full enough to trigger
    evictions. We addressed this issue by designating that temporary files didn’t
    need to be cached.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了Linux内核的预期行为，并确定内核缓存了文件的不存在——一些构建系统需要这个特性来确保可接受的性能。在正常操作中，当容器满时，内核会从dentry缓存中驱逐条目。然而，由于Spanner服务器反复刷新更新，容器从未变得足够满以触发驱逐。我们通过指定临时文件不需要被缓存来解决了这个问题。
- en: 'The debugging process described here illustrates many of the concepts we discuss
    in this chapter. However, the most important takeaway from this story is that
    *we debugged this issue*—and you can, too! Solving and fixing the problem didn’t
    require any magic; it just required slow and structured investigation. To break
    down the characteristics of our investigation:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的调试过程展示了我们在本章讨论的许多概念。然而，这个故事最重要的收获是*我们调试了这个问题*—而你也可以！解决和修复问题并不需要任何魔法；它只需要缓慢和有条理的调查。要分解我们调查的特征：
- en: After the system showed signs of degradation, we debugged the problem using
    existing logs and monitoring infrastructure.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在系统显示出退化迹象后，我们使用现有的日志和监控基础设施调试了这个问题。
- en: We were able to debug the issue even though it occurred in kernel space and
    code that the debuggers had not seen before.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能够调试这个问题，即使它发生在内核空间和调试人员以前没有见过的代码中。
- en: We’d never noticed the issue before this outage, even though it had likely been
    present for several years.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在这次停机之前从未注意到这个问题，尽管它可能已经存在了几年。
- en: No part of the system was broken. All parts were working as intended.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的任何部分都没有损坏。所有部分都按预期工作。
- en: The developers of the Spanner server were surprised that temporary files could
    consume memory long after the files had been deleted.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spanner服务器的开发人员惊讶地发现，临时文件在文件被删除后仍然可以消耗内存。
- en: We were able to debug the kernel’s memory usage by using tools provided by the
    kernel developers. Even though we’d never used these tools before, we were able
    to make progress relatively quickly because we were trained and well practiced
    in debugging techniques.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能够通过使用内核开发人员提供的工具来调试内核的内存使用情况。尽管我们以前从未使用过这些工具，但由于我们在调试技术上接受了培训并且有丰富的实践经验，我们能够相对快速地取得进展。
- en: We initially misdiagnosed the bug as a user error. We changed our minds only
    after examining our data.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们最初误诊了错误为用户错误。只有在检查了我们的数据后，我们才改变了主意。
- en: By developing a hypothesis and then creating a way to test our theory, we confirmed
    the root cause before we introduced changes to the system.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提出假设，然后创建一种测试我们理论的方法，我们在引入系统更改之前确认了根本原因。
- en: Debugging Techniques
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试技术
- en: 'This section shares some techniques for systematic debugging.^([4](ch15.html#ch15fn5))
    Debugging is a skill that you can learn and practice. [Chapter 12 of the SRE book](https://landing.google.com/sre/sre-book/chapters/effective-troubleshooting/)
    offers two requirements for successful debugging:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本节分享了一些系统化调试技术。([4](ch15.html#ch15fn5)) 调试是一种可以学习和实践的技能。[SRE书的第12章](https://landing.google.com/sre/sre-book/chapters/effective-troubleshooting/)提供了成功调试的两个要求：
- en: Know how the system is supposed to work.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解系统应该如何工作。
- en: 'Be systematic: collect data, hypothesize causes, and test theories.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要有系统性：收集数据，假设原因，测试理论。
- en: The first of these requirements is trickier. Take the canonical example of a
    system built by a single developer who suddenly leaves the company, taking all
    knowledge of the system with them. The system may continue to work for months,
    but one day it mysteriously breaks and no one can fix it. Some of the advice that
    follows can help, but there’s no real substitute for understanding the system
    ahead of time (see [Chapter 6](ch06.html#design_for_understandability)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个要求更加棘手。以一个由单个开发人员构建的系统为例，突然离开公司，带走了对系统的所有了解。系统可能会继续工作数月，但有一天它神秘地崩溃了，没有人能够修复它。接下来的一些建议可能有所帮助，但事先了解系统是没有真正替代品的（参见[第6章](ch06.html#design_for_understandability)）。
- en: Distinguish horses from zebras
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区分马和斑马
- en: 'When you hear hoofbeats, do you first think of horses, or zebras? Instructors
    sometime pose this question to medical students learning how to triage and diagnose
    diseases. It’s a reminder that most ailments are common—most hoofbeats are caused
    by horses, not zebras. You can imagine why this is helpful advice for a medical
    student: they don’t want to assume symptoms add up to a rare disease when, in
    fact, the condition is common and straightforward to remedy.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你听到马蹄声时，你首先想到的是马还是斑马？教师有时会向学习如何分诊和诊断疾病的医学生提出这个问题。这是一个提醒，大多数疾病是常见的——大多数马蹄声是由马引起的，而不是斑马。你可以想象为什么这对医学生是有帮助的建议：他们不想假设症状会导致罕见疾病，而实际上这种情况是常见的，而且很容易治疗。
- en: 'In contrast, given a large enough scale, experienced engineers will observe
    both common *and* rare events. People building computer systems can (and must)
    work to completely eliminate all problems. As a system grows in scale, and its
    operators eliminate common problems over time, rare problems appear more frequently.
    To quote [Bryan Cantrill](https://oreil.ly/eYfUO): “Over time, the horses are
    found; only the zebras are left.”'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，经验丰富的工程师在足够大的规模下会观察到常见的*和*罕见的事件。构建计算机系统的人可以（也必须）努力完全消除所有问题。随着系统规模的增长，运营商随着时间消除了常见问题，罕见问题出现得更频繁。引用[Bryan
    Cantrill](https://oreil.ly/eYfUO)的话：“随着时间的推移，马被找到了；只有斑马留下了。”
- en: Consider the very rare issue of memory corruption by bit flip. A modern error-correcting
    memory module has a less than 1% chance per year of encountering an uncorrectable
    bit flip that can crash a system.^([5](ch15.html#ch15fn6)) An engineer debugging
    an unexpected crash probably won’t think, “I bet this was caused by an extremely
    unlikely electrical malfunction in the memory chips!” However, at very large scale,
    these rarities become certainties. A hypothetical cloud service utilizing 25,000
    machines might use memory across 400,000 RAM chips. Given the odds of a 0.1% yearly
    risk of uncorrectable errors *per chip,* the scale of the service could lead to
    400 occurrences annually. People running the cloud service will likely observe
    a memory failure every day.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一种非常罕见的内存损坏问题：位翻转引起的内存损坏。现代纠错内存模块每年遇到无法纠正的位翻转的概率不到1%^([5](ch15.html#ch15fn6))。一位工程师调试一个意外的崩溃可能不会想到，“我打赌这是由于内存芯片中极不可能的电气故障引起的！”然而，在非常大的规模下，这些罕见事件变得确定。一个假设的云服务使用25,000台机器，可能使用400,000个RAM芯片的内存。考虑到每个芯片每年发生无法纠正错误的风险不到0.1%，服务的规模可能导致每年发生400次。运行云服务的人可能每天都会观察到内存故障。
- en: 'Debugging these kinds of rare events can be challenging, but it’s achievable
    with the right kind of data. To provide one example, Google hardware engineers
    once noticed that certain RAM chips failed much more often than expected. Asset
    data allowed them to track the source of the failing DIMMs (memory modules), and
    they were able to trace the modules to a single provider. After extensive debugging
    and investigation, the engineers identified the root cause: an environmental failure
    in a clean room, in a single factory where the DIMMs were produced. This problem
    was a “zebra”—a rare bug visible only at scale.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 调试这些罕见事件可能具有挑战性，但通过正确类型的数据是可以实现的。举个例子，谷歌的硬件工程师曾经注意到某些RAM芯片的故障率远远超出预期。资产数据使他们能够追踪故障DIMM（内存模块）的来源，并且他们能够将这些模块追溯到单个供应商。经过大量的调试和调查，工程师们确定了根本原因：在生产DIMM的单个工厂的无尘室中发生了环境故障。这个问题是一个“斑马”——一个只在规模上可见的罕见错误。
- en: As a service grows, today’s strange outlier bug may become next year’s routine
    bug. In the year 2000, [memory hardware corruption was a surprise for Google](https://oreil.ly/CicjH).
    Today, such hardware failures are routine, and we plan for them with end-to-end
    integrity checking and other reliability measures.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 随着服务的增长，今天的奇怪异常错误可能会成为明年的常见错误。在2000年，[谷歌对内存硬件损坏感到惊讶](https://oreil.ly/CicjH)。如今，这样的硬件故障是常见的，我们通过端到端的完整性检查和其他可靠性措施来计划处理它们。
- en: 'In recent years, we’ve encountered some other zebras:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，我们遇到了一些其他罕见事件：
- en: Two web search requests hashed to the same 64-bit cache key, causing results
    for one request to be served in place of the other.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个网络搜索请求散列到相同的64位缓存密钥，导致一个请求的结果被用来替代另一个请求。
- en: C++ converted an `int64` to an `int` (only 32 bits), resulting in problems after
    2^(32) requests (for more about this bug, see [“Clean up code”](#clean_up_code)).
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++将`int64`转换为`int`（只有32位），导致在2^(32)个请求后出现问题（有关此错误的更多信息，请参见[“清理代码”](#clean_up_code)）。
- en: A bug in a distributed rebalancing algorithm was triggered only when the code
    ran simultaneously on hundreds of servers.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式再平衡算法中的一个错误只有在代码同时在数百台服务器上运行时才会触发。
- en: Someone left a load test running for a week, causing performance to slowly degrade.
    We eventually determined that the machine was gradually suffering from memory
    allocation issues, leading to the degradation. We discovered this particular zebra
    because a normally short-lived test was left running for much longer than normal.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有人让负载测试运行了一个星期，导致性能逐渐下降。我们最终确定机器逐渐出现了内存分配问题，导致了性能下降。我们发现了这个罕见的错误，因为一个通常寿命较短的测试运行时间比正常情况下长得多。
- en: 'Investigating slow C++ tests showed that the dynamic linker’s loading time
    was superlinear in terms of the number of shared libraries loaded: at 10,000 shared
    libraries, it could take minutes to start running `main`.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查缓慢的C++测试表明，动态链接器的加载时间与加载的共享库数量呈超线性关系：在加载了10,000个共享库时，启动运行`main`可能需要几分钟。
- en: When dealing with smaller, newer systems, expect horses (common bugs). When
    dealing with older, larger, and relatively stable systems, expect zebras (rare
    bugs)—operators have likely observed and fixed common bugs that surfaced over
    time. Issues are more likely to crop up in new parts of the system.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理较小、较新的系统时，预计会出现常见的错误。在处理较老、较大和相对稳定的系统时，预计会出现罕见的错误——操作员可能已经观察到并修复了随时间出现的常见错误。问题更有可能在系统的新部分出现。
- en: Set aside time for debugging and investigations
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为调试和调查留出时间
- en: Both security investigations (to be discussed later) and debugging often take
    time—many hours of uninterrupted work. The temporary files scenario described
    in the previous section required somewhere between 5 and 10 hours of debugging.
    When running a major incident, give debuggers and investigators the space to focus
    by isolating them from the minute-by-minute response.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 安全调查（稍后讨论）和调试通常需要很长时间，需要连续数小时的工作。前一节中描述的临时文件情况需要5到10小时的调试。在运行重大事件时，通过将调试人员和调查人员与逐分钟的响应隔离开来，为他们提供专注的空间。
- en: 'Debugging rewards slow, methodical, persistent approaches, in which people
    double-check their work and assumptions and are willing to dig deep. The temporary
    files problem also offers a negative example of debugging: the first responder
    initially diagnosed the outage as caused by user traffic and blamed poor system
    behavior on users. At the time, the team was in operational overload and experiencing
    pager fatigue due to nonurgent pages.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 调试奖励缓慢、系统的、持久的方法，人们在这种方法中会反复检查他们的工作和假设，并愿意深入挖掘。临时文件问题也提供了调试的一个负面例子：最初的第一响应者最初诊断停机是由用户流量引起的，并将系统行为不佳归咎于用户。当时，团队处于运营超载状态，并因非紧急页面而感到疲劳。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '[Chapter 17 of the SRE workbook](https://landing.google.com/sre/workbook/chapters/overload/)
    discusses reducing operational overload. [Chapter 11 of the SRE book](https://landing.google.com/sre/sre-book/chapters/being-on-call/)
    suggests keeping ticket and pager volume below two per shift to give engineers
    time to dig deep into issues.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[SRE工作手册的第17章](https://landing.google.com/sre/workbook/chapters/overload/)讨论了减少运营超载。[SRE书的第11章](https://landing.google.com/sre/sre-book/chapters/being-on-call/)建议每班次将工单和寻呼器数量控制在两个以下，以便工程师有时间深入研究问题。'
- en: Record your observations and expectations
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录你的观察和期望
- en: 'Write down what you see. Separately, write down your theories, even if you’ve
    already rejected them. Doing so has several advantages:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 写下你所看到的。另外，写下你的理论，即使你已经拒绝了它们。这样做有几个优点：
- en: It introduces structure to the investigation and helps you remember the steps
    you took during your investigation. When you start debugging, you don’t know how
    long it will take to solve the issue—resolution might take five minutes or five
    months.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这为调查引入了结构，并帮助你记住调查过程中所采取的步骤。当你开始调试时，你不知道解决问题需要多长时间——解决可能需要五分钟或五个月。
- en: Another debugger can read your notes, understand what you observed, and quickly
    participate in or take over the investigation. Your notes can help teammates avoid
    duplicative work, and may inspire others to think of new avenues for investigation.
    For more on this topic, see “Negative Results Are Magic” in [Chapter 12 of the
    SRE book](https://landing.google.com/sre/sre-book/chapters/effective-troubleshooting/).
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个调试器可以阅读你的笔记，了解你观察到的情况，并快速参与或接管调查。你的笔记可以帮助队友避免重复工作，并可能激发其他人想到新的调查途径。有关这个主题的更多信息，请参见[SRE书的第12章](https://landing.google.com/sre/sre-book/chapters/effective-troubleshooting/)中的“负面结果是魔术”。
- en: In the case of potential security issues, it can be helpful to keep a log of
    each access and investigation step. Later, you may need to prove (sometimes in
    a court of law) which actions were performed by the attacker and which were performed
    by investigators.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在潜在的安全问题的情况下，保留每次访问和调查步骤的日志可能是有帮助的。以后，你可能需要证明（有时是在法庭上）哪些行动是攻击者执行的，哪些是调查人员执行的。
- en: After you’ve written down what you observed, write down what you expected to
    observe and why. Bugs often lurk in the space between your mental model of the
    system and its actual implementation. In the temporary files example, the developers
    assumed that deleting a file removed all references to it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在你写下你观察到的内容之后，写下你期望观察到的内容以及原因。错误经常隐藏在你对系统的心理模型和实际实现之间的空间中。在临时文件的例子中，开发人员假设删除文件会删除所有对它的引用。
- en: Know what’s normal for your system
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解你的系统的正常情况
- en: 'Often, debuggers start debugging what is actually an expected system behavior.
    Here are a few examples from our experience:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，调试人员开始调试实际上是预期的系统行为。以下是我们经验中的一些例子：
- en: A binary called `abort` near the end of its `shutdown` code. New developers
    saw the `abort` call in the logs and started debugging the call, not noticing
    that the interesting failure was actually the reason for the call to `shutdown`.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`abort`的二进制文件在其`shutdown`代码的末尾。新开发人员在日志中看到了`abort`调用，并开始调试该调用，没有注意到有趣的故障实际上是`shutdown`调用的原因。
- en: When the Chrome web browser starts, it attempts to resolve three random domains
    (such as `cegzaukxwefark.local`) to determine whether the network is illicitly
    tampering with DNS. Even Google’s own investigation team has mistaken these DNS
    resolutions for malware trying to resolve a command-and-control server hostname.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当Chrome网页浏览器启动时，它会尝试解析三个随机域名（比如`cegzaukxwefark.local`）以确定网络是否在非法篡改DNS。甚至Google自己的调查团队也曾将这些DNS解析误认为是恶意软件试图解析命令和控制服务器主机名。
- en: Debuggers often need to filter out these normal events, even if the events look
    relevant or suspicious. Security investigators have the added problem of a steady
    level of background noise and active adversaries that may be trying to hide their
    actions. You often need to filter out routine noisy activity like automated SSH
    login brute forcing, authentication errors caused by users’ mistyped passwords,
    and port scanning before you can observe more serious issues.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器经常需要过滤掉这些正常事件，即使这些事件看起来与问题相关或可疑。安全调查人员面临的额外问题是持续的背景噪音和可能试图隐藏行动的积极对手。你通常需要过滤掉常规的嘈杂活动，比如自动SSH登录暴力破解、用户输错密码导致的认证错误以及端口扫描，然后才能观察到更严重的问题。
- en: One way to understand normal system behavior is to establish a baseline of system
    behavior when you don’t suspect any problems. If you have a problem already, you
    may be able to infer your baseline by examining historical logs from before the
    problem began.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 了解正常系统行为的一种方法是在你不怀疑有任何问题时建立系统行为的基线。如果你已经有了问题，你可以通过检查问题发生之前的历史日志来推断你的基线。
- en: For example, in [Chapter 1](ch01.html#the_intersection_of_security_and_reliab)
    we described a global YouTube outage caused by a change to a generic logging library.
    The change caused the servers to run out of memory (OOM) and fail. Because the
    library was widely used within Google, our post-outage investigation questioned
    whether the outage had affected the number of OOMs for all other Borg tasks. While
    logs suggested that we had many OOM conditions that day, we were able to compare
    that data against a baseline of data from the previous two weeks, which showed
    that Google has many OOM conditions *every* day. Although the bug was serious,
    it did not meaningfully affect the OOM metric for Borg tasks.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[第1章](ch01.html#the_intersection_of_security_and_reliab)中，我们描述了由于对通用日志库的更改而导致的全球YouTube中断。这个更改导致服务器耗尽内存（OOM）并失败。由于该库在Google内部被广泛使用，我们在事后调查中质疑这次中断是否影响了所有其他Borg任务的OOM数量。虽然日志表明那天我们有很多OOM条件，但我们能够将这些数据与前两周的数据基线进行比较，结果显示Google每天都有很多OOM条件。尽管这个错误很严重，但它并没有对Borg任务的OOM指标产生实质性影响。
- en: Beware of normalizing deviance from best practices. Often, bugs become “normal
    behavior” over time, and you no longer notice them. For example, we once worked
    on a server that had spent ~10% of its memory in heap fragmentation. After many
    years of asserting that ~10% was the expected and therefore acceptable amount
    of loss, we examined a fragmentation profile and quickly found major opportunities
    for saving memory.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不要将最佳实践的偏差标准化。通常，错误会随着时间变成“正常行为”，您不再注意到它们。例如，我们曾经在一台服务器上工作，其堆内存碎片化达到了约10%。经过多年的断言，约10%是预期的，因此是可以接受的损失量，我们检查了碎片化配置文件，很快发现了节省内存的重大机会。
- en: '[Operational overload](https://oreil.ly/L144H) and alert fatigue can lead you
    to grow a blind spot, and thus normalize deviance. To address normalized deviance,
    we actively listen to newcomers to the team, and to facilitate fresh perspectives,
    we rotate people in and out of on-call rotations and response teams—the process
    of writing documentation and explaining a system to others can also prompt you
    to question how well you understand a system. Additionally, we use Red Teams (see
    [Chapter 20](ch20.html#twozero_understanding_roles_and_respons)) to test our blind
    spots.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[运营超载](https://oreil.ly/L144H)和警报疲劳可能导致您产生盲点，并因此标准化偏差。为了解决标准化偏差，我们积极倾听团队中的新人，并为了促进新的视角，我们轮换人员参与值班轮换和响应团队——编写文档和向他人解释系统的过程也可能促使您质疑自己对系统的了解程度。此外，我们使用红队（见[第20章](ch20.html#twozero_understanding_roles_and_respons)）来测试我们的盲点。'
- en: Reproduce the bug
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重现错误
- en: 'If possible, attempt to reproduce the bug outside of the production environment.
    This approach has two main advantages:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，尝试在生产环境之外重现错误。这种方法有两个主要优点：
- en: You don’t impact systems serving actual users, so you can crash the system and
    corrupt data as much as you want.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不会影响为实际用户提供服务的系统，因此可以随意使系统崩溃并损坏数据。
- en: Because you don’t expose any sensitive data, you can involve many people in
    the investigation without raising data security issues. You can also enable operations
    that aren’t appropriate with actual user data, and capabilities like extra logging.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为您没有暴露任何敏感数据，所以您可以在不引起数据安全问题的情况下让许多人参与调查。您还可以启用与实际用户数据不适当的操作和额外日志记录等功能。
- en: 'Sometimes, debugging outside of the production environment isn’t feasible.
    Perhaps the bug triggers only at scale, or you can’t isolate its trigger. The
    temporary files example is one such situation: we couldn’t reproduce the bug with
    a full serving stack.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在生产环境之外进行调试是不可行的。也许错误只会在规模上触发，或者您无法隔离其触发器。临时文件示例就是这样一种情况：我们无法通过完整的服务堆栈重现错误。
- en: Isolate the problem
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隔离问题
- en: If you can reproduce the issue, the next step is to isolate the problem—ideally,
    to the smallest subset of code that still manifests it. You can do this by disabling
    components or temporarily commenting out subroutines until the problem is revealed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能重现问题，下一步是隔离问题，理想情况下是将问题隔离到仍然出现问题的代码最小子集。您可以通过禁用组件或临时注释子程序来做到这一点，直到问题显现出来。
- en: 'In the temporary files example, once we observed that the memory management
    was acting strangely on all servers, we no longer had to debug all components
    on every affected machine. For another example, consider a single server (out
    of a large cluster of systems) that suddenly starts introducing high latency or
    errors. This scenario is the standard test of your monitoring, logs and other
    observability systems: can you quickly find a single bad server among the many
    servers in your system? See [“What to Do When You’re Stuck”](#what_to_do_when_youapostrophere_stuck)
    for more information.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在临时文件示例中，一旦我们观察到所有服务器上的内存管理表现出异常，我们就不再需要在每台受影响的机器上调试所有组件。再举一个例子，考虑一个单独的服务器（在一个大型系统集群中）突然开始引入高延迟或错误。这种情况是对您的监控、日志和其他可观察性系统的标准测试：您能否快速找到系统中众多服务器中的一个坏服务器？有关更多信息，请参见[“卡住时该怎么办”](#what_to_do_when_youapostrophere_stuck)。
- en: You can also isolate problems within code. To provide a concrete example, we
    recently investigated memory usage for a program with a very limited memory budget.
    In particular, we examined the memory mappings for thread stacks. Although our
    mental model assumed that all threads had the same stack size, to our surprise
    we found that different thread stacks had many different sizes. Some stacks were
    quite large and risked consuming a big chunk of our memory budget. The initial
    debugging scope included the kernel, glibc, Google’s threading library, and all
    code that started threads. A trivial example based around glibc’s `pthread_create`
    created thread stacks of the same size, so we could rule out the kernel and glibc
    as the sources of the different sizes. We then examined the code that started
    threads, and discovered that many libraries just picked a thread size at random,
    explaining the variation of sizes. This understanding enabled us to save memory
    by focusing on the few threads with large stacks.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在代码内部隔离问题。举一个具体的例子，我们最近调查了一个具有非常有限内存预算的程序的内存使用情况。特别是，我们检查了线程堆栈的内存映射。尽管我们的心理模型假设所有线程具有相同的堆栈大小，但令我们惊讶的是，我们发现不同的线程堆栈有许多不同的大小。一些堆栈非常大，有可能消耗大量内存预算。最初的调试范围包括内核、glibc、Google的线程库以及所有启动线程的代码。基于glibc的`pthread_create`的一个简单示例创建了相同大小的线程堆栈，因此我们可以排除内核和glibc作为不同大小的来源。然后我们检查了启动线程的代码，发现许多库只是随机选择了线程大小，解释了大小的变化。这种理解使我们能够通过专注于少数具有大堆栈的线程来节省内存。
- en: Be mindful of correlation versus causation
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 谨慎对待相关性与因果关系
- en: Sometimes debuggers assume that two events that start at the same time, or that
    exhibit similar symptoms, have the same root cause. However, correlation does
    not always imply causation. Two mundane problems might occur at the same time
    but have different root causes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有时调试器会假设同时开始的两个事件或表现出类似症状的事件具有相同的根本原因。然而，相关性并不总是意味着因果关系。两个平凡的问题可能同时发生，但有不同的根本原因。
- en: Some correlations are trivial. For example, an increase in latency might lead
    to a reduction in user requests, simply because users are waiting longer for the
    system to respond. If a team repeatedly discovers correlations that in retrospect
    are trivial, there might be a gap in their understanding of how the system is
    supposed to work. In the temporary files example, if you know that the failure
    to delete files results in full disks, you won’t be surprised by the correlation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有些相关性是微不足道的。例如，延迟增加可能导致用户请求减少，仅仅是因为用户等待系统响应的时间更长。如果一个团队反复发现事后看来微不足道的相关性，可能是因为他们对系统应该如何工作的理解存在差距。在临时文件的例子中，如果你知道删除文件失败会导致磁盘满，你就不会对这种相关性感到惊讶。
- en: However, our experience has shown that investigating correlations is often useful—notably,
    correlations that occur at the start of outages. You can home in on likely causes
    by thinking, “*X* is broken, *Y* is broken, *Z* is broken; what’s the common element
    among the three?” We’ve also had some success with correlation-based tooling.
    For example, we deployed a system that automatically correlates machine problems
    with the Borg tasks running on the machine. As a result, we can often identify
    a suspicious Borg task causing a widespread problem. This kind of automated tooling
    produces much more effective, statistically stronger, and faster correlations
    than human observation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的经验表明，调查相关性通常是有用的，特别是在停机开始时发生的相关性。通过思考，“*X*出问题了，*Y*出问题了，*Z*出问题了；这三者之间有什么共同点？”你可以找到可能的原因。我们还在基于相关性的工具上取得了一些成功。例如，我们部署了一个系统，可以自动将机器问题与机器上运行的Borg任务进行相关联。因此，我们经常可以确定一个可疑的Borg任务导致了广泛的问题。这种自动化工具产生的相关性比人类观察更有效、统计学上更强大，而且更快。
- en: Errors can also manifest during deployment—see [Chapter 12 in the SRE book](https://landing.google.com/sre/sre-book/chapters/effective-troubleshooting/).
    In simple situations, the new code being deployed may have problems, but deployments
    can also trigger latent bugs in old systems. In these situations, debugging may
    erroneously focus on the new code being deployed, rather than the latent issues.
    Systematic investigation—determining what is happening, and why—helps in these
    cases. In one example we witnessed, the old code had much worse performance than
    the new code, which resulted in an accidental throttle on the system as a whole.
    When its performance improved, other parts of the system became overloaded instead.
    The outage was correlated with the new deployment, but the deployment was not
    the root cause.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 错误也可能在部署过程中显现——参见[SRE书中的第12章](https://landing.google.com/sre/sre-book/chapters/effective-troubleshooting/)。在简单的情况下，正在部署的新代码可能存在问题，但部署也可能触发旧系统中的潜在错误。在这些情况下，调试可能错误地集中在正在部署的新代码上，而不是潜在的问题。系统性的调查——确定发生了什么，以及为什么——在这些情况下是有帮助的。我们曾经见过的一个例子是，旧代码的性能比新代码差得多，这导致了对整个系统的意外限制。当其性能改善时，系统的其他部分反而过载。停机与新部署相关联，但部署并不是根本原因。
- en: Test your hypotheses with actual data
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用实际数据测试你的假设
- en: When debugging, it can be tempting to speculate about the root causes of issues
    before actually looking at the system. When it comes to performance issues, this
    tendency introduces blind spots, as the problems often lie in code the debuggers
    have not looked at in a long time. As an example, once we were debugging a web
    server that was running slowly. We assumed the problem lay in the backends, but
    a [profiler](https://oreil.ly/3YrvQ) showed that the practice of logging every
    possible scrap of input to disk and then calling `sync` was causing vast amounts
    of delay. We discovered this only when we set aside our initial assumptions and
    dug into the system more deeply.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试时，很容易在实际查看系统之前就对问题的根本原因进行推测。在处理性能问题时，这种倾向会引入盲点，因为问题通常出现在调试人员长时间没有查看的代码中。例如，有一次我们在调试一个运行缓慢的Web服务器。我们假设问题出在后端，但[分析器](https://oreil.ly/3YrvQ)显示，将每一点可能的输入记录到磁盘，然后调用`sync`导致了大量的延迟。只有当我们放下最初的假设并深入研究系统时，我们才发现了这一点。
- en: '*Observability* is the property of being able to determine what your system
    is doing by examining its outputs. Tracing solutions like [Dapper](https://oreil.ly/9qDWj)
    and [Zipkin](https://zipkin.io) are very useful for this kind of debugging. Debugging
    sessions start with basic questions like, “Can you find a slow Dapper trace?”^([6](ch15.html#ch15fn7))'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*可观察性*是通过检查系统的输出来确定系统正在做什么的属性。像[Dapper](https://oreil.ly/9qDWj)和[Zipkin](https://zipkin.io)这样的追踪解决方案对这种调试非常有用。调试会话从基本问题开始，比如，“你能找到一个慢的Dapper跟踪吗？”^([6](ch15.html#ch15fn7))'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It can be challenging for beginners to determine what tool is best for the job,
    or even what tools exist. Brendan Gregg’s *Systems Performance* (Prentice Hall,
    2013), which provides an exhaustive tour of tooling and techniques, is a fantastic
    reference for performance debugging.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，确定最适合工作的工具，甚至了解存在哪些工具可能是具有挑战性的。Brendan Gregg的《系统性能》（Prentice Hall，2013）提供了全面的工具和技术介绍，是性能调试的绝佳参考。
- en: Reread the docs
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新阅读文档
- en: 'Consider the following guidance from the [Python documentation](https://oreil.ly/PudXU):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑来自[Python文档](https://oreil.ly/PudXU)的以下指导：
- en: There are no implied relationships among the comparison operators. The truth
    of `x==y` does not imply that `x!=y` is false. Accordingly, when defining `__eq__()`,
    one should also define `__ne__()` so that the operators will behave as expected.
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 比较运算符之间没有暗示的关系。`x==y`的真实性并不意味着`x!=y`是假的。因此，在定义`__eq__()`时，应该同时定义`__ne__()`，以便运算符的行为符合预期。
- en: Recently, a Google team spent a good amount of time debugging an internal dashboard
    optimization. When they got stuck, the team reread the documentation and discovered
    a plainly written warning message that explained why the optimization had never
    worked at all. People were so used to the dashboard’s slow performance, they failed
    to notice that the optimization was completely ineffective.^([7](ch15.html#ch15fn9))
    Initially, the bug seemed remarkable; the team thought it was an issue in Python
    itself. After they found the warning message, they determined that it wasn’t a
    zebra, it was a horse—their code had never worked.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，谷歌团队花了大量时间调试内部仪表板优化。当他们陷入困境时，团队重新阅读了文档，并发现了一个明确的警告消息，解释了为什么优化从未起作用。人们习惯了仪表板的性能缓慢，他们没有注意到优化完全无效。^([7](ch15.html#ch15fn9))最初，这个错误似乎很显著；团队认为这是Python本身的问题。在他们找到警告消息后，他们确定这不是斑马，而是马——他们的代码从未起作用。
- en: Practice!
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习！
- en: Debugging skills stay fresh only if you use them often. You can speed up your
    investigations and keep the tips we’ve provided here fresh in your mind by staying
    familiar with relevant tools and logs. Regularly practicing debugging also provides
    the opportunity to script the common and tedious parts of the process—for example,
    automation to examine logs. To get better at debugging (or to stay sharp), practice,
    and keep the code you write during debugging sessions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 调试技能只有经常使用才能保持新鲜。通过熟悉相关工具和日志，您可以加快调查的速度，并将我们在这里提供的提示保持在脑海中。定期练习调试还提供了机会来脚本化过程中常见和乏味的部分，例如自动化检查日志。要提高调试能力（或保持敏锐），请练习，并保留在调试会话期间编写的代码。
- en: At Google, we formally practice debugging with regular large-scale disaster
    recovery tests (referred to as DiRT, or the Disaster Recovery Testing program)^([8](ch15.html#ch15fn10))
    and security penetration tests (see [Chapter 16](ch16.html#onesix_disaster_planning)).
    Smaller-scale tests, involving one or two engineers in a room for an hour, are
    much easier to set up and are still quite valuable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在谷歌，我们通过定期的大规模灾难恢复测试（称为DiRT，或灾难恢复测试计划）^([8](ch15.html#ch15fn10))和安全渗透测试（见[第16章](ch16.html#onesix_disaster_planning)）来正式练习调试。规模较小的测试，涉及一两名工程师在一个小时内进行测试，更容易设置，但仍然非常有价值。
- en: What to Do When You’re Stuck
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当你陷入困境时该怎么办
- en: What should you do when you’ve been investigating an issue for days and still
    have no idea what caused the problem? Maybe it manifests only in the production
    environment, and you can’t reproduce the bug without affecting live users. Maybe
    while mitigating the problem, you lost important debugging information when the
    logs rotated. Maybe the nature of the problem prevents useful logging. We once
    debugged an issue where a memory container ran out of RAM and the kernel issued
    a SIGKILL for all processes in the container, stopping all logging. Without logs,
    we couldn’t debug the issue.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调查一个问题已经几天了，仍然不知道问题的原因时，您应该怎么办？也许它只在生产环境中表现出来，而且您无法在不影响实际用户的情况下重现错误。也许在缓解问题时，日志轮转时丢失了重要的调试信息。也许问题的性质阻止了有用的日志记录。我们曾经调试过一个问题，其中一个内存容器耗尽了RAM，内核为容器中的所有进程发出了SIGKILL，停止了所有日志记录。没有日志，我们无法调试这个问题。
- en: A key strategy in these situations is to improve the debugging process. Sometimes,
    using the methods for developing postmortems (as described in [Chapter 18](ch18.html#oneeight_recovery_and_aftermath))
    may suggest ways forward. Many systems are in production for years or decades,
    so efforts to improve debugging are nearly always worthwhile. This section describes
    some approaches to improving your debugging methods.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下的一个关键策略是改进调试过程。有时，使用开发事后总结的方法（如[第18章](ch18.html#oneeight_recovery_and_aftermath)中所述）可能会提出前进的方法。许多系统已经投入生产多年甚至几十年，因此改进调试的努力几乎总是值得的。本节描述了改进调试方法的一些途径。
- en: Improve observability
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提高可观察性
- en: Sometimes you need to see what a bit of code is doing. Is this code branch used?
    Is this function used? Could this data structure be large? Is this backend slow
    at the 99th percentile? What backends is this query even using? In these situations,
    you need better visibility into the system.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要查看一些代码在做什么。这段代码分支被使用了吗？这个函数被使用了吗？这个数据结构可能很大吗？这个后端在99th百分位数上很慢吗？这个查询使用了哪些后端？在这些情况下，您需要更好地了解系统。
- en: In some cases, methods like adding more structured logging to improve observability
    are straightforward. We once investigated a system that monitoring showed was
    serving too many 404 errors,^([9](ch15.html#ch15fn11)) but the web server wasn’t
    logging these errors. After adding additional logging for the web server, we discovered
    that malware was attempting to fetch erroneous files from the system.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，像添加更多结构化日志以提高可观察性的方法是直接的。我们曾经调查过一个系统，监控显示它服务了太多的404错误，^([9](ch15.html#ch15fn11))但是Web服务器没有记录这些错误。在为Web服务器添加额外的日志记录后，我们发现恶意软件试图从系统中获取错误文件。
- en: Other debugging improvements take serious engineering effort. For example, debugging
    a complex system like [Bigtable](https://oreil.ly/31cv1) requires sophisticated
    instrumentation. The Bigtable master is the central coordinator for a Bigtable
    zone. It stores the list of servers and tablets in RAM, and several mutexes protect
    these critical sections. As Bigtable deployments at Google grew over time, the
    Bigtable master and these mutexes became a scaling bottleneck. To get more visibility
    into possible problems, we implemented a wrapper around a mutex that exposes stats
    such as queue depth and the time the mutex is held.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 其他调试改进需要严肃的工程努力。例如，调试像[Bigtable](https://oreil.ly/31cv1)这样的复杂系统需要复杂的仪器。Bigtable主节点是Bigtable区域的中央协调器。它在RAM中存储服务器和平板的列表，并且几个互斥体保护这些关键部分。随着谷歌的Bigtable部署随着时间的推移而增长，Bigtable主节点和这些互斥体成为了扩展瓶颈。为了更好地了解可能的问题，我们实现了一个包装器，围绕互斥体暴露诸如队列深度和互斥体持有时间等统计信息。
- en: Tracing solutions like Dapper and Zipkin are very useful for this kind of complex
    debugging. For example, suppose you have a tree of RPCs, with the frontend calling
    a server, which calls another server, and so on. Each RPC tree has a unique ID
    assigned at the root. Each server then logs traces about the RPCs it receives,
    sends, and so on. Dapper collects all traces centrally and joins them via ID.
    This way, a debugger can see all the backends touched by the user’s request. We’ve
    found Dapper to be critical to understanding latency in distributed systems. Similarly,
    Google embeds a simple web server in nearly every binary to provide visibility
    into each binary’s behavior. The server has debugging endpoints that provide counters,
    a symbolized dump of all the running threads, inflight RPCs, and so on. For more
    information, see Henderson (2017).^([10](ch15.html#ch15fn12))
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 像Dapper和Zipkin这样的追踪解决方案对于这种复杂的调试非常有用。例如，假设您有一个RPC树，前端调用一个服务器，服务器调用另一个服务器，依此类推。每个RPC树在根处分配了一个唯一的ID。然后，每个服务器记录有关其接收的RPC、发送的RPC等的跟踪。Dapper集中收集所有跟踪，并通过ID将它们连接起来。这样，调试器可以看到用户请求所触及的所有后端。我们发现Dapper对于理解分布式系统中的延迟至关重要。同样，Google在几乎每个二进制文件中嵌入了一个简单的Web服务器，以便提供对每个二进制文件行为的可见性。该服务器具有调试端点，提供计数器、所有运行线程的符号化转储、正在进行的RPC等。有关更多信息，请参阅Henderson（2017）。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Observability is not a substitute for understanding your system. Nor is it a
    substitute for critical thinking when debugging (sadly!). Often, we’ve found ourselves
    frantically adding more logging and counters in an effort to see what the system
    is doing, but what’s really going on becomes clear only when we’ve taken a step
    back and thought about the problem.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察性并不是了解系统的替代品。它也不是调试时批判性思维的替代品（遗憾！）。我们经常发现自己在疯狂地添加更多日志记录和计数器，以便了解系统正在做什么，但只有当我们退后一步并思考问题时，真正发生的情况才会变得清晰。
- en: Observability is a large and quickly evolving topic, and it’s useful for more
    than debugging.^([11](ch15.html#ch15fn13)) If you’re a smaller organization with
    limited developer resources, you can consider using open source systems or purchasing
    a third-party observability solution.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察性是一个庞大且快速发展的主题，它不仅对调试有用。如果您是一个开发资源有限的较小组织，可以考虑使用开源系统或购买第三方可观察性解决方案。
- en: Take a break
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 休息一下
- en: 'Giving yourself a bit of distance from an issue can often lead to new insights
    when you return to the problem. If you’ve been working heads-down on debugging
    and hit a lull, take a break: drink some water, go outside, get some exercise,
    or read a book. Bugs sometimes make themselves evident after a good sleep. A senior
    engineer in our forensic investigation team keeps a cello in the team’s lab. When
    he’s truly stuck on a problem, it’s common for him to retreat into the lab for
    20 minutes or so to play; he then comes back [reenergized and refocused](https://oreil.ly/axc_Y).
    Another investigator keeps a guitar handy, and others keep sketching and doodling
    pads in their desks so they can draw or create a silly animated GIF to share with
    the team when they need that mental realignment.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与问题保持一定的距离往往会在回到问题时带来新的见解。如果您一直在进行调试并遇到停顿，请休息一下：喝点水，出去走走，锻炼一下，或者读一本书。有时候，好好睡一觉后，bug会显露出来。我们的法医调查团队的一位资深工程师在团队的实验室里放了一把大提琴。当他真正陷入问题时，他通常会退到实验室20分钟左右来演奏；然后他重新充满活力和专注。另一位调查员随时保持一把吉他，其他人在桌子上保留着素描和涂鸦本，这样他们在需要进行心智调整时可以画画或制作一个愚蠢的动画GIF与团队分享。
- en: Make sure to also maintain good team communication. When you step aside to take
    a break, let the team know that you need a recharge and are following best practices.
    It’s also helpful to document where you are in the investigation and why you’re
    stuck. Doing so makes it easier for another investigator to pick up your work,
    and for you to return to the place where you left off. [Chapter 17](ch17.html#oneseven_crisis_management)
    has more advice on maintaining morale.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 还要确保保持良好的团队沟通。当您离开一会儿休息时，让团队知道您需要休息并且正在遵循最佳实践。记录调查的进展和您陷入困境的原因也是有帮助的。这样做可以使另一位调查员更容易接手您的工作，也可以让您回到离开的地方。第17章有关于保持士气的更多建议。
- en: Clean up code
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清理代码
- en: Sometimes you suspect there’s a bug in a chunk of your code, but can’t see it.
    Trying to generically improve code quality may help in this situation. As mentioned
    earlier in this chapter, we once debugged a bit of code that failed in production
    after 2^(32) requests because C++ was converting an `int64` into an `int` (only
    32 bits) and truncating it. Although the compiler can warn you about such conversions
    using [`-Wconversion`](https://oreil.ly/BUPuH), we weren’t using the warning because
    our code had many benign conversions. Cleaning up the code enabled us to use the
    compiler warning to detect more possible bugs and prevent new bugs related to
    conversion.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您怀疑代码块中存在bug，但却看不到它。在这种情况下，试图通用地提高代码质量可能会有所帮助。正如本章前面提到的，我们曾经调试过一段代码，它在2^(32)个请求后在生产环境中失败，因为C++将`int64`转换为`int`（仅32位）并截断了它。尽管编译器可以使用[`-Wconversion`](https://oreil.ly/BUPuH)警告您有关此类转换，但我们没有使用该警告，因为我们的代码有许多良性转换。清理代码使我们能够使用编译器警告来检测更多可能的bug，并防止与转换相关的新bug。
- en: 'Here are some other tips for cleanup:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些清理的其他提示：
- en: Improve unit test coverage. Target functions where you suspect bugs may lie,
    or that have a track record of being buggy. (See [Chapter 13](ch13.html#onethree_testing_code)
    for more information.)
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高单元测试覆盖率。针对您怀疑可能存在bug的函数，或者具有出现bug的记录的函数。 （有关更多信息，请参见[第13章](ch13.html#onethree_testing_code)。）
- en: For concurrent programs, use [sanitizers](https://oreil.ly/GJJq9) (see [“Sanitize
    Your Code”](ch12.html#sanitize_your_code)) and [annotate mutexes](https://oreil.ly/z1BQk).
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于并发程序，请使用[消毒剂](https://oreil.ly/GJJq9)（参见[“消毒您的代码”](ch12.html#sanitize_your_code)）和[注释互斥锁](https://oreil.ly/z1BQk)。
- en: Improve error handling. Often, adding some more context around an error is sufficient
    to expose the problem.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改善错误处理。通常，围绕错误添加一些更多的上下文就足以暴露问题。
- en: Delete it!
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除它！
- en: Sometimes bugs lurk in legacy systems, especially if developers haven’t had
    time to get or stay familiar with the codebase or maintenance has lapsed. A legacy
    system might also be compromised or incur new bugs. Instead of debugging or hardening
    the legacy system, consider deleting it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候错误隐藏在传统系统中，特别是如果开发人员没有时间熟悉或保持熟悉代码库，或者维护已经中断。传统系统也可能受到损害或产生新的错误。与其调试或加固传统系统，不如考虑删除它。
- en: Deleting a legacy system can also improve your security posture. For example,
    one of the authors was once contacted (through Google’s Vulnerability Reward Program,
    as described in [Chapter 20](ch20.html#twozero_understanding_roles_and_respons))
    by a security researcher who had found a security issue in one of our team’s legacy
    systems. The team had previously isolated this system to its own network, but
    hadn’t upgraded the system in quite some time. Newer members of the team were
    unaware that the legacy system even existed. To address the researcher’s discovery,
    we decided to remove the system. We no longer needed most of the functionality
    it provided, and we were able to replace it with a considerably simpler modern
    system.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 删除传统系统也可以改善您的安全姿态。例如，有一位作者曾经通过谷歌的漏洞奖励计划（如[第20章](ch20.html#twozero_understanding_roles_and_respons)中所述）被一位安全研究人员联系，后者在我们团队的一个传统系统中发现了一个安全问题。团队之前已经将该系统隔离到自己的网络中，但已经有一段时间没有升级该系统了。团队的新成员甚至不知道传统系统的存在。为了解决研究人员的发现，我们决定删除该系统。我们不再需要它提供的大部分功能，并且我们能够用一个更简单的现代系统来替换它。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Be thoughtful when rewriting legacy systems. Ask yourself why your rewritten
    system will do a better job than the legacy system. Sometimes, you might want
    to rewrite a system because it’s fun to add new code, and debugging old code is
    tedious. There are better reasons for replacing systems: sometimes requirements
    for the system change, and with a small amount of work, you can remove the old
    system. Alternatively, perhaps you’ve learned something from the first system
    and can incorporate this knowledge to make the second system better.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在重写传统系统时要慎重。问问自己，为什么您重写的系统会比传统系统做得更好。有时候，您可能想重写一个系统，因为添加新代码很有趣，而调试旧代码很乏味。替换系统有更好的理由：有时候系统的需求会发生变化，只需少量工作，您就可以删除旧系统。或者，也许您从第一个系统中学到了一些东西，并且可以将这些知识融入到第二个系统中，使其变得更好。
- en: Stop when things start to go wrong
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当事情开始出错时停下来
- en: 'Many bugs are tricky to find because the source and its effects can be far
    apart in the system. We recently encountered an issue where network gear was corrupting
    internal DNS responses for hundreds of machines. For example, programs would perform
    a DNS lookup for the machine `exa1`, but receive the address of `exa2`. Two of
    our systems had different responses to this bug:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 许多错误很难找到，因为错误源和其影响在系统中可能相距甚远。我们最近遇到了一个问题，网络设备正在破坏数百台机器的内部DNS响应。例如，程序将对机器`exa1`进行DNS查找，但收到的是`exa2`的地址。我们的两个系统对这个错误有不同的响应：
- en: One system, an archival service, would connect to `exa2`, the wrong machine.
    However, the system then checked that the machine to which it had connected was
    the expected machine. Since the machine names didn’t match, the archival service
    job failed.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个系统，一个档案服务，会连接到`exa2`，错误的机器。然而，系统随后检查连接的机器是否是预期的机器。由于机器名称不匹配，档案服务作业失败。
- en: Another system that collected machine metrics would collect metrics from the
    wrong machine, `exa2`. The system then triggered repairs on `exa1`. We detected
    this behavior only when a technician pointed out that they’d been asked to repair
    the fifth disk of a machine that didn’t have five disks.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个收集机器指标的系统会从错误的机器`exa2`收集指标。然后，系统会在`exa1`上触发修复。我们只有在一名技术人员指出他们被要求修复一个没有五个磁盘的机器的第五个磁盘时才检测到这种行为。
- en: Of these two responses, we prefer the behavior of the archival service. When
    issues and their effects are far apart in the system—for example, when the network
    is causing application-level errors—having applications fail closed can prevent
    downstream effects (such as suspecting disk failure on the wrong system). We cover
    the topic of whether to fail open or fail closed in greater depth in [Chapter 8](ch08.html#design_for_resilience).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种响应中，我们更喜欢档案服务的行为。当系统中的问题及其影响相距甚远时，例如当网络导致应用程序级错误时，使应用程序失败可以防止下游影响（例如怀疑错误系统上的磁盘故障）。我们在[第8章](ch08.html#design_for_resilience)中更深入地讨论了是选择失败开放还是失败关闭的话题。
- en: Improve access and authorization controls, even for nonsensitive systems
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进访问和授权控制，即使对于非敏感系统也是如此
- en: It’s possible to have “too many cooks in the kitchen”—that is, you may run into
    debugging situations where many people could be the source of a bug, making it
    difficult to isolate the cause. We once responded to an outage caused by a corrupted
    database row, and we couldn’t locate the source of the corrupt data. To eliminate
    the possibility that someone could write to the production database by mistake,
    we minimized the number of roles that had access and required a justification
    for any human access. Even though the data was not sensitive, implementing a standard
    security system helped us prevent and investigate future bugs. Thankfully, we
    were also able to restore that database row from backup.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: “厨房里有太多厨师”是有可能的——也就是说，您可能会遇到许多人可能是错误源的调试情况，这使得难以隔离原因。我们曾经因为一个损坏的数据库行而导致了一次宕机，我们无法找到损坏数据的来源。为了消除有人可能会错误地写入生产数据库的可能性，我们最小化了具有访问权限的角色数量，并要求对任何人类访问进行理由说明。尽管数据并不敏感，但实施标准的安全系统帮助我们预防和调查未来的错误。幸运的是，我们还能够从备份中恢复该数据库行。
- en: 'Collaborative Debugging: A Way to Teach'
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作调试：一种教学方法
- en: 'Many engineering teams teach debugging by working collectively on actual live
    issues in person (or over a videoconference). In addition to keeping experienced
    debuggers’ skills fresh, collaborative debugging helps to build psychological
    safety for new team members: they have the opportunity to see the best debuggers
    on the team get stuck, backtrack, or otherwise struggle, which shows them that
    it’s OK to be wrong and to have a hard time.^([12](ch15.html#ch15fn14)) For more
    on security education, see [Chapter 21](ch21.html#twoone_building_a_culture_of_security_a).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 许多工程团队通过亲自（或通过视频会议）共同解决实际的实时问题来教授调试技术。除了保持经验丰富的调试者的技能更新外，协作调试还有助于为新团队成员建立心理安全感：他们有机会看到团队中最优秀的调试者遇到困难、后退或者有其他困难，这向他们表明，出错和遇到困难是可以接受的。有关安全教育的更多信息，请参见第21章。
- en: 'We’ve found that the following rules optimize the learning experience:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现以下规则优化了学习体验：
- en: 'Only two people should have laptops open:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有两个人可以打开笔记本电脑：
- en: A “driver,” who performs actions requested by the others
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “驱动者”，执行其他人要求的操作
- en: A “note taker”
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “笔记记录者”
- en: Every action should be determined by the audience. Only the driver and the note
    taker are permitted to use computers, but they do not determine the actions taken.
    This way, participants don’t perform solo debugging, only to present an answer
    without sharing their thought processes and troubleshooting steps.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个行动都应由观众决定。只有驱动者和笔记记录者被允许使用计算机，但他们不确定采取的行动。这样，参与者不会独自进行调试，然后提出答案而不分享他们的思考过程和故障排除步骤。
- en: The team collectively identifies one or more problems to examine, but no one
    in the room should know in advance how to solve the issues. Each person can request
    that the driver perform an action to troubleshoot the issue (for example, open
    a dashboard, look at logs, reboot a server, etc.). Since everyone is present to
    witness the suggestions, everyone can learn about tools and techniques that participants
    suggest. Even very experienced team members learn new things from these exercises.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 团队共同确定要检查的一个或多个问题，但房间里没有人事先知道如何解决这些问题。每个人都可以要求驱动者执行一个操作来排除故障（例如，打开仪表板，查看日志，重新启动服务器等）。由于每个人都在场见证这些建议，每个人都可以了解参与者建议的工具和技术。即使是经验丰富的团队成员也会从这些练习中学到新东西。
- en: 'As described in [Chapter 28 of the SRE book](https://landing.google.com/sre/sre-book/chapters/accelerating-sre-on-call/),
    some teams also use “Wheel of Misfortune” simulation exercises. These exercises
    can either be theoretical, with verbal walk-throughs of problem solving, or practical,
    where the test giver induces a fault in a system. These scenarios also involve
    two roles:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如SRE书的第28章所述，一些团队还使用“Wheel of Misfortune”模拟练习。这些练习可以是理论性的，通过口头解决问题的步骤，也可以是实际的，测试者在系统中引入故障。这些场景还涉及两种角色：
- en: The “test giver,” who constructs and presents the test
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “测试者”，构建和呈现测试的人
- en: The “test taker,” who attempts to solve the problem, perhaps with the help of
    their teammates
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “测试者”，试图解决问题，也许在队友的帮助下
- en: Some teams prefer the safe environment of staged exercises, but practical Wheel
    of Misfortune exercises require nontrivial setup, whereas most systems always
    have a live issue to collectively debug. Regardless of the approach, it’s important
    to maintain an inclusive learning environment where everyone feels safe to actively
    contribute.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一些团队更喜欢安全的分阶段练习环境，但实际的Wheel of Misfortune练习需要非常复杂的设置，而大多数系统总是有实时问题需要共同调试。无论采取何种方法，保持一个包容的学习环境非常重要，让每个人都感到安全，积极地做出贡献。
- en: Both collaborative debugging and Wheel of Misfortune exercises are excellent
    ways to introduce new techniques to your team and reinforce best practices. People
    can see how the techniques are useful in real-world situations, often for the
    trickiest of problems. Teams also get some practice debugging issues together,
    making them more effective when a real crisis occurs.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 协作调试和Wheel of Misfortune练习是向团队介绍新技术和强化最佳实践的绝佳方式。人们可以看到这些技术在现实情况下的用处，通常是解决最棘手的问题。团队也可以一起练习调试问题，使他们在真正的危机发生时更加有效。
- en: How Security Investigations and Debugging Differ
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全调查和调试的不同之处
- en: We expect every engineer to debug systems, but we advise that trained and experienced
    security and forensic specialists investigate system compromises. When the line
    between “bug investigation” and “security problem” is unclear, there’s an opportunity
    for collaboration between the two sets of specialist teams.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望每个工程师都能调试系统，但我们建议受过训练和有经验的安全和取证专家来调查系统的妥协。当“错误调查”和“安全问题”之间的界限不清晰时，两组专家团队之间有合作的机会。
- en: 'A *bug investigation* often begins when a system experiences a problem. The
    investigation focuses on what happened in the system: what data was sent, what
    happened with that data, and how the service began acting contrary to its intent.
    *Security investigations* begin a little differently, and quickly pivot to questions
    like: What has the user who submitted that job been doing? What other activity
    is that user responsible for? Do we have a live attacker in the system? What will
    the attacker do next? In short, debugging is more code-focused, while a security
    investigation may quickly focus on the adversary behind an attack.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*错误调查*通常在系统出现问题时开始。调查侧重于系统中发生了什么：发送了什么数据，这些数据发生了什么，服务如何开始与其意图相反。*安全调查*开始有点不同，并迅速转向问题，比如：提交了那份工作的用户在做什么？该用户还负责其他什么活动？我们的系统中有活跃的攻击者吗？攻击者接下来会做什么？简而言之，调试更加关注代码，而安全调查可能很快就会关注攻击背后的对手。'
- en: The steps we recommended previously for debugging issues may also be counterproductive
    during security investigations. Adding new code, deprecating systems, and so on
    may have unintended side effects. We’ve responded to a number of incidents where
    a debugger removed files that normally didn’t belong on the system in the hopes
    of resolving errant behavior, and it turned out that those files had been introduced
    by the attacker, who was thus alerted to the investigation. In one case, the attacker
    even responded in kind by deleting the entire system!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前推荐的用于调试问题的步骤在安全调查期间可能也会适得其反。添加新代码、废弃系统等可能会产生意想不到的副作用。我们曾应对过许多事件，其中调试器删除了通常不属于系统的文件，希望解决错误行为，结果发现这些文件是攻击者引入的，因此提醒了调查。在一个案例中，攻击者甚至以删除整个系统的方式做出了回应！
- en: Once you suspect that a security compromise has occurred, your investigation
    may also take on a new sense of urgency. The possibility that a system is being
    intentionally subverted raises questions that feel serious and pressing. What
    is the adversary after? What other systems may be subverted? Do you need to call
    law enforcement or regulators? Security investigations grow organically in complexity
    as the organization begins to address operational security concerns ([Chapter 17](ch17.html#oneseven_crisis_management)
    discusses this topic further). Experts from other teams, such as Legal, may get
    involved before you can begin your investigation. In short, the moment you suspect
    a security compromise is a good time to get help from security professionals.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您怀疑发生了安全妥协，您的调查可能也会变得更加紧迫。系统被故意颠覆的可能性引发了一些看起来严肃而紧迫的问题。攻击者的目的是什么？还可能颠覆其他系统吗？您是否需要呼叫执法部门或监管机构？随着组织开始解决运营安全问题，安全调查的复杂性会逐渐增加（[第17章](ch17.html#oneseven_crisis_management)进一步讨论了这个话题）。其他团队的专家，如法律团队，可能会在您开始调查之前介入。简而言之，一旦您怀疑发生了安全妥协，现在是向安全专业人员寻求帮助的好时机。
- en: 'Deciding when to stop investigating and declare a security incident can be
    a difficult judgment call. Many engineers have a natural inclination to refrain
    from “making a scene” by escalating issues that aren’t yet proven to be security-related,
    but continuing the investigation to the point of proof may be the wrong move.
    Our advice is to remember “horses versus zebras”: the vast majority of bugs are,
    in fact, bugs, not malicious actions. However, *also* keep a vigilant eye open
    for those black and white stripes zipping by.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 决定何时停止调查并宣布发生了安全事件可能是一个困难的判断。许多工程师天生倾向于避免通过升级尚未被证明与安全相关的问题来“制造场面”，但继续调查直到证明可能是错误的举动。我们的建议是记住“马和斑马”的区别：绝大多数的错误实际上都是错误，而不是恶意行为。然而，*同时*也要警惕那些黑白相间的条纹迅速经过。
- en: Collect Appropriate and Useful Logs
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集适当和有用的日志
- en: At their heart, logs and system crash dumps are both just information you can
    collect to help you understand what happened in a system and to investigate problems—both
    accidental and intentional.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，日志和系统崩溃转储都只是您可以收集的信息，以帮助您了解系统中发生了什么，并调查问题——无论是意外还是故意的。
- en: Before you launch any service, it’s important to consider the kinds of data
    the service will store on behalf of users, and the pathways to access the data.
    Assume that any action that leads to data or system access may be in scope for
    a future investigation, and that someone will need to audit that action. Investigating
    any service issue *or* security issue depends heavily on logs.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动任何服务之前，重要的是考虑服务将代表用户存储的数据类型，以及访问数据的途径。假设任何导致数据或系统访问的行为都可能成为未来调查的范围，并且将需要对该行为进行审计。调查任何服务问题*或*安全问题都严重依赖于日志。
- en: Our discussion here of “logs” refers to structured, timestamped records from
    systems. During investigations, analysts may also rely heavily on other sources
    of data, like core dumps, memory dumps, or stack traces. We recommend handling
    those systems as much like logs as possible. Structured logs are useful for many
    different business purposes, such as per-usage billing. However, we focus here
    on structured logs collected for security investigations—the information you need
    to collect now so it’s available in the event of a future issue.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里讨论的“日志”是指系统中结构化的、带有时间戳的记录。在调查过程中，分析人员可能还会严重依赖其他数据源，如核心转储、内存转储或堆栈跟踪。我们建议尽量像处理日志一样处理这些系统。结构化日志对许多不同的业务目的都很有用，比如按使用量计费。然而，我们这里关注的是为安全调查收集的结构化日志——你现在需要收集的信息，以便在未来出现问题时可以使用。
- en: Design Your Logging to Be Immutable
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计您的日志记录为不可变
- en: 'The system you build to collect logs should be immutable. When log entries
    are written, it should be difficult to alter them (but not impossible; see [“Take
    Privacy into Consideration”](#take_privacy_into_consideration)), and alterations
    should have an immutable audit trail. Attackers commonly erase traces of their
    activity on a system from all log sources as soon as they establish a solid foothold.
    A common best practice to counter this tactic is to write your logs remotely to
    a centralized and distributed log server. This increases the attacker’s workload:
    in addition to compromising the original system, they also have to compromise
    the remote log server. Be sure to harden the log system carefully.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您构建用于收集日志的系统应该是不可变的。当日志条目被写入时，应该很难对其进行更改（但不是不可能；参见[“考虑隐私”](#take_privacy_into_consideration)），并且更改应该有一个不可变的审计跟踪。攻击者通常会在建立牢固立足后立即从所有日志源中擦除其在系统上的活动痕迹。对抗这种策略的一个常见最佳做法是将日志远程写入集中和分布式的日志服务器。这增加了攻击者的工作量：除了攻击原始系统外，他们还必须攻击远程日志服务器。务必仔细加固日志系统。
- en: Before the age of modern computing, extra-critical servers logged directly to
    an attached line printer, like the one in [Figure 15-1](#a_line_printer), which
    printed log records to paper as they were generated. In order to erase their traces,
    a remote attacker would have needed someone to physically remove paper from the
    printer and burn it!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代计算机时代之前，特别关键的服务器直接记录到连接的线打印机上，就像[图15-1](#a_line_printer)中的那个，它会在生成记录时将日志记录到纸上。为了抹去它们的痕迹，远程攻击者需要有人物理上取下打印机上的纸并将其烧掉！
- en: '![A line printer](assets/bsrs_1501.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![线打印机](assets/bsrs_1501.png)'
- en: Figure 15-1\. A line printer
  id: totrans-158
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图15-1. 线打印机
- en: Take Privacy into Consideration
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 考虑隐私
- en: 'The need for privacy-preserving features is an increasingly important factor
    in the design of systems. While privacy is not a focus of this book, you will
    likely need to take into account local regulations and your organization’s privacy
    policies when designing logging for security investigations and debugging. Be
    sure to consult with any privacy and legal colleagues in your organization on
    this topic. Here are some topics you may want to discuss:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 隐私保护功能的需求在系统设计中变得越来越重要。虽然隐私不是本书的重点，但在设计安全调查和调试日志时，您可能需要考虑当地法规和您组织的隐私政策。在这个话题上一定要与您组织内的隐私和法律同事进行咨询。以下是一些您可能想要讨论的话题：
- en: Depth of logging
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 日志深度
- en: To be maximally useful for any investigation, logs need to be as complete as
    possible. A security investigation might need to examine every action a user (or
    an attacker using their account) performed inside a system, the host from which
    they logged in, and the exact times at which the events occurred. Agree on an
    organizational policy about what information is acceptable to log, given that
    many privacy-preserving techniques discourage retaining sensitive user data in
    logs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对任何调查最大限度地有用，日志需要尽可能完整。安全调查可能需要检查用户（或使用其帐户的攻击者）在系统内执行的每个操作，他们登录的主机以及事件发生的确切时间。就日志记录而言，达成组织政策上的一致意见，关于可以记录哪些信息是可以接受的，是很重要的，因为许多隐私保护技术都不鼓励在日志中保留敏感用户数据。
- en: Retention
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 保留
- en: For some investigations, it can be beneficial to retain logs for a long time.
    According to a 2018 study, it takes most organizations an average of about [200
    days](https://oreil.ly/vAunm) to discover a system compromise. Insider threat
    investigations at Google have relied on operating system security logs going back
    several years. How long you can keep logs is an important discussion to have within
    your organization.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些调查，长时间保留日志可能是有益的。根据2018年的一项研究，大多数组织平均需要约[200天](https://oreil.ly/vAunm)才能发现系统被入侵。谷歌的内部威胁调查依赖于可以追溯数年的操作系统安全日志。您组织内部关于保留日志的时间长度的讨论是很重要的。
- en: Access and audit controls
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 访问和审计控制
- en: Many of the controls we recommend for protecting data also apply to logs. Be
    sure to protect logs and metadata just as you protect other data. See [Chapter 5](ch05.html#design_for_least_privilege)
    for relevant strategies.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推荐用于保护数据的许多控制措施也适用于日志。一定要像保护其他数据一样保护日志和元数据。请参阅[第5章](ch05.html#design_for_least_privilege)以获取相关策略。
- en: Data anonymization or pseudonymization
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 数据匿名化或假名化
- en: Anonymizing unnecessary data components—either as they’re written or after a
    period of time—is one increasingly common privacy-preserving method for handling
    logs. You can even implement this functionality such that investigators and debuggers
    can’t determine who a given user is, but can clearly build a timeline of that
    user’s actions throughout their session for debugging purposes. Anonymization
    is tricky to get right. We recommend consulting privacy specialists and reading
    published literature on this topic.^([13](ch15.html#ch15fn15))
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名化不必要的数据组件——无论是在写入时还是一段时间后——是一种越来越常见的隐私保护方法，用于处理日志。您甚至可以实现此功能，以便调查人员和调试人员无法确定给定用户是谁，但可以清楚地构建该用户在调试过程中的会话期间的时间线。匿名化很难做到。我们建议咨询隐私专家并阅读有关此话题的已发表文献。^([13](ch15.html#ch15fn15))
- en: Encryption
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 加密
- en: 'You can also implement privacy-preserving logging using asymmetric encryption
    of data. This encryption method is ideal for protecting log data: it uses a nonsensitive
    “public key” that anyone can use to write data securely, but requires a secret
    (private) key to decrypt the data. Design options like daily key pairs can allow
    debuggers to obtain small subsets of log data from recent system activity, while
    preventing someone from obtaining large amounts of log data in aggregate. Be sure
    to carefully consider how you store keys.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用数据的非对称加密来实现隐私保护的日志记录。这种加密方法非常适合保护日志数据：它使用一个非敏感的“公钥”，任何人都可以使用它来安全地写入数据，但需要一个秘密（私钥）来解密数据。像每日密钥对这样的设计选项可以让调试人员从最近的系统活动中获取小的日志数据子集，同时防止某人获取大量的日志数据。一定要仔细考虑如何存储密钥。
- en: Determine Which Security Logs to Retain
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定要保留哪些安全日志
- en: Although security engineers would often prefer having too many logs to having
    too few, it pays to be a bit selective in what you log and retain. Storing an
    overabundance of logs can be costly (as discussed in [“Budget for Logging”](#budget_for_logging)),
    and sifting through excessively large data sets can slow down an investigator
    and use a large amount of resources. In this section, we discuss some types of
    logs you may want to capture and retain.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管安全工程师通常更喜欢有太多的日志而不是太少的日志，但在记录和保留日志时要有所选择也是值得的。存储过多的日志可能会很昂贵（如[“日志预算”](#budget_for_logging)中所讨论的），并且筛选过大的数据集可能会减慢调查人员的速度并使用大量资源。在本节中，我们讨论了一些您可能想要捕获和保留的日志类型。
- en: Operating system logs
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作系统日志
- en: Most modern operating systems have built-in logging. Windows has Windows Event
    logs, while Linux and Mac have syslog and auditd logs. Many vendor-supplied appliances
    (such as camera systems, environmental controls, and fire alarm panels) have a
    standard operating system that also produces logs (such as Linux) under the hood.
    Built-in logging frameworks are useful for investigations, and using them requires
    almost no effort because they’re often enabled by default or easily configured.
    Some mechanisms, like auditd, are not enabled by default for performance reasons,
    but enabling them can be an acceptable tradeoff in real-world use.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代操作系统都内置了日志记录功能。Windows拥有Windows事件日志，而Linux和Mac拥有syslog和auditd日志。许多供应商提供的设备（如摄像头系统、环境控制和火警面板）也有标准操作系统，同时也会产生日志（如Linux）在幕后。内置的日志框架对于调查非常有用，而且几乎不需要任何努力，因为它们通常默认启用或者很容易配置。一些机制，比如auditd，出于性能原因默认情况下未启用，但在现实世界的使用中启用它们可能是可以接受的折衷方案。
- en: Host agents
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主机代理
- en: Many companies choose to enable additional logging capabilities by installing
    a *host intrusion detection system* (HIDS) or *host agent* on workstations and
    servers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 许多公司选择通过在工作站和服务器上安装*主机入侵检测系统*（HIDS）或*主机代理*来启用额外的日志记录功能。
- en: Modern (sometimes referred to as “next-gen”) host agents use innovative techniques
    aimed at detecting increasingly sophisticated threats. Some agents blend system
    and user behavior modeling, machine learning, and threat intelligence to identify
    previously unknown attacks. Other agents are more focused on gathering additional
    data about the system’s operation, which can be useful for offline detection and
    debugging activities. Some, such as [OSQuery](https://osquery.io) and [GRR](https://github.com/google/grr),
    provide real-time visibility into a system.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现代（有时被称为“下一代”）主机代理使用旨在检测日益复杂威胁的创新技术。一些代理结合了系统和用户行为建模、机器学习和威胁情报，以识别以前未知的攻击。其他代理更专注于收集有关系统操作的额外数据，这对离线检测和调试活动很有用。一些代理，如[OSQuery](https://osquery.io)和[GRR](https://github.com/google/grr)，提供了对系统的实时可见性。
- en: Host agents always impact performance, and are often a source of friction between
    end users and IT teams. Generally speaking, the more data an agent can gather,
    the greater its performance impact may be because of deeper platform integration
    and more on-host processing. Some agents run as part of the kernel, while others
    run as userspace applications. Kernel agents have more functionality, and are
    therefore typically more effective, but they can suffer from reliability and performance
    issues as they try to keep up with operating system functionality changes. Agents
    that run as applications are much easier to install and configure, and tend to
    have fewer compatibility problems. The value and performance of host agents varies
    widely, so we recommend thoroughly evaluating a host agent before using it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 主机代理总是会影响性能，并且经常成为最终用户和IT团队之间摩擦的源头。一般来说，代理可以收集的数据越多，其性能影响可能就越大，因为它需要更深入的平台集成和更多的主机处理。一些代理作为内核的一部分运行，而另一些作为用户空间应用程序运行。内核代理具有更多功能，因此通常更有效，但它们可能会因为要跟上操作系统功能变化而遭受可靠性和性能问题。作为应用程序运行的代理更容易安装和配置，并且往往具有较少的兼容性问题。主机代理的价值和性能差异很大，因此我们建议在使用之前对主机代理进行彻底评估。
- en: Application logs
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序日志
- en: Logging applications—whether vendor-supplied like SAP and Microsoft SharePoint,
    open source, or custom-written—generate logs that you can collect and analyze.
    You can then use these logs for custom detection and to augment investigation
    data. For example, we use [application logs from Google Drive](https://oreil.ly/Fhckk)
    to determine if a compromised computer has downloaded sensitive data.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录应用程序——无论是供应商提供的，如SAP和Microsoft SharePoint，还是开源的，或者是自定义的——都会生成您可以收集和分析的日志。然后，您可以使用这些日志进行自定义检测，并增强调查数据。例如，我们使用[来自Google
    Drive的应用程序日志](https://oreil.ly/Fhckk)来确定受损计算机是否下载了敏感数据。
- en: When developing custom applications, collaboration between security specialists
    and developers can ensure that the applications log security-relevant actions,
    such as data writes, changes in ownership or state, and account-related activity.
    As we mention in [“Improve observability”](#improve_observability), instrumenting
    your applications for logging can also facilitate debugging for esoteric security
    and reliability issues that would otherwise be difficult to triage.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发自定义应用程序时，安全专家和开发人员之间的合作可以确保应用程序记录安全相关的操作，例如数据写入、所有权或状态的更改以及与帐户相关的活动。正如我们在[“提高可观察性”](#improve_observability)中提到的，为日志记录仪器化您的应用程序也可以促进调试，以解决其他情况下难以排查的安全和可靠性问题。
- en: Cloud logs
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 云日志
- en: Increasingly, organizations are moving parts of their business or IT processes
    to cloud-based services, ranging from data in Software-as-a-Service (SaaS) applications
    to virtual machines running critical customer-facing workloads. All of these services
    present unique attack surfaces and generate unique logs. For example, an attacker
    can compromise the account credentials for a cloud project, deploy new containers
    to the project’s Kubernetes cluster, and use those containers to steal data from
    the cluster’s accessible storage buckets. Cloud computing models commonly launch
    new instances daily, which makes detecting threats in the cloud dynamic and complex.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越多的组织正在将其业务或IT流程的部分转移到基于云的服务，从软件即服务（SaaS）应用程序中的数据到运行关键客户端工作负载的虚拟机。所有这些服务都呈现出独特的攻击面，并生成独特的日志。例如，攻击者可以破坏云项目的帐户凭据，部署新的容器到项目的Kubernetes集群，并使用这些容器从集群的可访问存储桶中窃取数据。云计算模型通常每天启动新实例，这使得在云中检测威胁变得动态和复杂。
- en: When it comes to detecting suspicious activity, cloud services present advantages
    and disadvantages. Using services like Google’s BigQuery, it’s easy and relatively
    cheap to collect and store large amounts of log data, and even to run detection
    rules, directly in the cloud. Google Cloud services also offer built-in logging
    solutions like [Cloud Audit Logs](https://oreil.ly/XF4ta) and [Stackdriver Logging](https://oreil.ly/6SUwV).
    On the other hand, because there are many kinds of cloud services, it can be hard
    to identify, enable, and centralize all the logs you need. Because it’s easy for
    developers to create new IT assets in the cloud, many companies find it difficult
    to identify all of their cloud-based assets. Cloud service providers may also
    predetermine which logs are available to you, and these options may not be configurable.
    It’s important to understand the limitations of your provider’s logging and your
    potential blind spots.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在检测可疑活动时，云服务具有优势和劣势。使用诸如Google的BigQuery之类的服务，收集和存储大量日志数据甚至在云中直接运行检测规则都很容易且相对便宜。Google云服务还提供了内置的日志记录解决方案，如[Cloud
    Audit Logs](https://oreil.ly/XF4ta)和[Stackdriver Logging](https://oreil.ly/6SUwV)。另一方面，由于有许多种云服务，很难识别、启用和集中所有您需要的日志。由于开发人员很容易在云中创建新的IT资产，许多公司发现很难识别所有基于云的资产。云服务提供商还可能预先确定对您可用的日志，并且这些选项可能无法配置。了解您的提供商日志记录的限制以及您潜在的盲点非常重要。
- en: A variety of commercial software, often itself based in the cloud, aims to detect
    attacks against cloud services. Most of the established cloud providers offer
    integrated threat detection services, such as Google’s [Event Threat Detection](https://oreil.ly/yJdVl).
    Many companies combine these built-in services with internally developed detection
    rules or third-party products.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 各种商业软件，通常本身就基于云，旨在检测针对云服务的攻击。大多数成熟的云提供商提供集成的威胁检测服务，例如Google的[事件威胁检测](https://oreil.ly/yJdVl)。许多公司将这些内置服务与内部开发的检测规则或第三方产品结合使用。
- en: '*Cloud access security brokers* (CASBs) are a notable category of detection
    and prevention technology. CASBs function as intermediaries between end users
    and cloud services to enforce security controls and provide logging. For example,
    a CASB might prevent your users from uploading certain kinds of files, or log
    every file downloaded by a user. Many CASBs have a detection function that alerts
    the detection team about potentially malicious access. You can also integrate
    logs from the CASB into custom detection rules.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*云访问安全代理*（CASBs）是一类显着的检测和预防技术。CASBs作为终端用户和云服务之间的中介，以强制执行安全控制并提供日志记录。例如，CASB可能会阻止用户上传某些类型的文件，或记录用户下载的每个文件。许多CASB具有警报检测功能，可向检测团队发出关于潜在恶意访问的警报。您还可以将CASB的日志集成到自定义检测规则中。'
- en: Network-based logging and detection
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于网络的日志记录和检测
- en: Since the late 1990s, the use of *network intrusion detection systems* (NIDSs)
    and *intrusion prevention systems* (IPSs) that capture and inspect network packets
    has been a common detection and logging technique. IPSs also block some attacks.
    For example, they may capture information about which IP addresses have exchanged
    traffic, along with limited information about that traffic, such as packet size.
    Some IPSs may have the ability to record the entire contents of certain packets,
    based on customizable criteria—for example, packets sent to high-risk systems.
    Others can also detect malicious activity in real time and send alerts to the
    appropriate team. Since these systems are very useful and have few downsides beyond
    cost, we highly recommend them for almost any organization. However, think carefully
    about who can effectively triage the alerts they generate.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 自20世纪90年代末以来，捕获和检查网络数据包的*网络入侵检测系统*（NIDSs）和*入侵预防系统*（IPSs）已成为常见的检测和记录技术。IPSs还可以阻止一些攻击。例如，它们可能捕获有关哪些IP地址交换了流量以及有关该流量的有限信息，例如数据包大小。一些IPSs可能具有根据可定制标准记录某些数据包的整个内容的能力，例如发送到高风险系统的数据包。其他人还可以实时检测恶意活动并向适当的团队发送警报。由于这些系统非常有用且成本较低，我们强烈建议几乎任何组织使用它们。但是，请仔细考虑谁能有效地处理它们产生的警报。
- en: Logs of DNS queries are also useful network-based sources. DNS logs enable you
    to see whether any computer at the company has resolved a hostname. For example,
    you might want to see whether any host on your network has performed a DNS query
    for a known malicious hostname, or you may want to examine previously resolved
    domains to identify every machine visited by an attacker that had control of your
    system. A security operations team might also use DNS “sinkholes” that falsely
    resolve known malicious domains so they can’t be effectively used by attackers.
    Detection systems then tend to trigger a high-priority alert when users access
    a sinkholed domain.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: DNS查询日志也是有用的基于网络的来源。DNS日志使您能够查看公司中是否有任何计算机解析了主机名。例如，您可能想查看网络上是否有任何主机对已知恶意主机名执行了DNS查询，或者您可能想检查先前解析的域以识别攻击者控制的每台机器访问的域。安全运营团队还可能使用DNS“陷阱”，虚假解析已知恶意域，以便攻击者无法有效使用。然后，检测系统往往在用户访问陷阱域时触发高优先级警报。
- en: You can also use logs from any web proxies used for internal or egress traffic.
    For example, you can use a web proxy to scan web pages for indicators of phishing
    or known vulnerability patterns. When using a proxy for detection, you’ll also
    want to consider employee privacy and discuss the use of proxy logs with a legal
    team. Generally speaking, we recommend tailoring your detection as closely as
    possible to malicious content in order to minimize the amount of employee data
    you encounter while triaging alerts.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用用于内部或出口流量的任何网络代理的日志。例如，您可以使用网络代理扫描网页以查找钓鱼或已知漏洞模式的指示器。在使用代理进行检测时，您还需要考虑员工隐私，并与法律团队讨论使用代理日志。一般来说，我们建议尽可能将检测调整到恶意内容，以最小化您在处理警报时遇到的员工数据量。
- en: Budget for Logging
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志预算
- en: Debugging and investigative activities use resources. One system we worked on
    had 100 TB of logs, which were mostly never used. Because logging consumes a significant
    amount of resources, and logs are often monitored less frequently in the absence
    of problems, it can be tempting to underinvest in the logging and debugging infrastructure.
    To avoid this, we strongly recommend that you budget for logging in advance, taking
    into account how much data you may need to resolve a service issue or security
    incident.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 调试和调查活动会消耗资源。我们曾经处理过的一个系统有100TB的日志，其中大部分从未被使用过。由于日志记录消耗了大量资源，并且在没有问题的情况下日志通常被监视得较少，因此很容易在日志记录和调试基础设施上投资不足。为了避免这种情况，我们强烈建议您提前预算日志记录，考虑您可能需要多少数据来解决服务问题或安全事件。
- en: 'Modern log systems often incorporate a relational data system (e.g., Elasticsearch
    or BigQuery) to quickly and easily query data in real time. The cost of this system
    grows along with the number of events it needs to store and index, the number
    of machines it needs to process and query the data, and the storage space required.
    When retaining data for long periods of time, it’s therefore useful to prioritize
    logs from relevant data sources for longer-term storage. This is an important
    tradeoff decision: if an attacker is good at hiding their tracks, it may take
    you quite some time to discover that an incident has occurred. If you store only
    a week’s worth of access logs, you may not be able to investigate an intrusion
    at all!'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现代日志系统通常整合了关系型数据系统（例如Elasticsearch或BigQuery），以便实时快速地查询数据。该系统的成本随着需要存储和索引的事件数量、需要处理和查询数据的机器数量以及所需的存储空间而增长。因此，在长时间保留数据时，有必要优先考虑来自相关数据源的日志以进行长期存储。这是一个重要的权衡决定：如果攻击者擅长隐藏自己的行踪，可能需要相当长的时间才能发现发生了事件。如果只存储一周的访问日志，可能根本无法调查入侵事件！
- en: 'We also recommend the following investment strategies for security-focused
    log collection:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还建议以下投资策略用于面向安全的日志收集：
- en: Focus on logs that have a good signal-to-noise ratio. For example, firewalls
    routinely block many packets, most of which are harmless. Even malicious packets
    blocked by a firewall may not be worth paying attention to. Gathering logs for
    these blocked packets could use a tremendous amount of bandwidth and storage for
    almost no benefit.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于具有良好信噪比的日志。例如，防火墙通常会阻止许多数据包，其中大部分是无害的。即使是被防火墙阻止的恶意数据包也可能不值得关注。收集这些被阻止的数据包的日志可能会消耗大量带宽和存储空间，但几乎没有任何好处。
- en: Compress logs whenever possible. Because most logs contain a lot of duplicated
    metadata, compression is typically very effective.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能压缩日志。因为大多数日志包含大量重复的元数据，压缩通常非常有效。
- en: Separate storage into “warm” and “cold.” You can offload logs from the distant
    past to cheap offline cloud storage (“cold storage”), while retaining logs that
    are more recent or related to known incidents on local servers for immediate use
    (“warm storage”). Similarly, you might store compressed raw logs for a long time,
    but put only recent logs in the expensive relational database with full indexing.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将存储分为“热”和“冷”。您可以将过去的日志转移到廉价的离线云存储（“冷存储”），同时保留与最近或已知事件相关的日志在本地服务器上以供立即使用（“热存储”）。同样，您可能会长时间存储压缩的原始日志，但只将最近的日志放入具有完整索引的昂贵关系型数据库中。
- en: Rotate logs intelligently. Generally, it’s best to delete the oldest logs first,
    but you may want to retain the most important log types longer.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能地轮换日志。通常，最好首先删除最旧的日志，但您可能希望保留最重要的日志类型更长时间。
- en: Robust, Secure Debugging Access
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强大、安全的调试访问
- en: 'To debug issues, you often need access to the systems and the data they store.
    Can a malicious or compromised debugger see sensitive information? Can a failure
    of a security system (and remember: all systems fail!) be resolved? You need to
    ensure that your debugging systems are reliable and secure.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试问题，通常需要访问系统和它们存储的数据。恶意或受损的调试器能否看到敏感信息？安全系统的故障（记住：所有系统都会出现故障！）能否得到解决？您需要确保您的调试系统是可靠和安全的。
- en: Reliability
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可靠性
- en: 'Logging is another way systems can fail. For example, a system can run out
    of disk space to store logs. Failing open in this example entails another tradeoff:
    the approach can make your entire system more resilient, but an attacker can potentially
    disrupt your logging mechanism.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是系统可能出现故障的另一种方式。例如，系统可能会因为磁盘空间不足而无法存储日志。在这种情况下，采取开放式失败会带来另一个权衡：这种方法可以使整个系统更具弹性，但攻击者可能会干扰您的日志记录机制。
- en: Plan for situations where you might need to debug or repair the security systems
    themselves. Consider the tradeoffs necessary to make sure you don’t lock yourself
    out of a system, but can still keep it secure. In this case, you might consider
    keeping a set of emergency-only credentials, offline in a secure location, that
    set off high-confidence alarms when used. As an example, [a recent Google network
    outage](https://oreil.ly/hxpj3) caused high packet loss. When responders attempted
    to obtain internal credentials, the authentication system could not reach one
    backend and failed closed. However, emergency credentials enabled the responders
    to authenticate and fix the network.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 计划应对可能需要调试或修复安全系统本身的情况。考虑必要的权衡，以确保您不会被系统锁定，但仍然可以保持安全。在这种情况下，您可能需要考虑在安全位置离线保存一组仅用于紧急情况的凭据，当使用时会触发高置信度的警报。例如，最近的一次[Google网络故障](https://oreil.ly/hxpj3)导致严重的数据包丢失。当响应者试图获取内部凭据时，认证系统无法连接到一个后端并且失败关闭。然而，紧急凭据使响应者能够进行身份验证并修复网络。
- en: Security
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: One system we worked on, used for phone support, allowed administrators to impersonate
    a user and to view the UI from their perspective. As a debugger, this system was
    wonderful; you could clearly and quickly reproduce a user’s problem. However,
    this type of system provides possibilities for abuse. Debugging endpoints—from
    impersonation to raw database access—need to be secured.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们曾经使用的一个用于电话支持的系统允许管理员模拟用户并从他们的角度查看用户界面。作为调试工具，这个系统非常棒；您可以清楚快速地重现用户的问题。然而，这种类型的系统提供了滥用的可能性。从模拟到原始数据库访问的调试端点都需要得到保护。
- en: For many incidents, debugging unusual system behavior need not require access
    to user data. For example, when diagnosing TCP traffic problems, the speed and
    quality of bytes on the wire is often enough to diagnose issues. Encrypting data
    in transit can protect it from any possible attempt by third parties to observe
    it. This has the fortunate side effect of allowing more engineers access to packet
    dumps when needed. However, one possible mistake is to treat metadata as nonsensitive.
    A malicious actor can still learn a lot about a user from metadata by tracking
    correlated access patterns—for instance, by noting the same user accessing a divorce
    lawyer and a dating site in the same session. You should carefully assess the
    risks from treating metadata as nonsensitive.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多事件，调试异常系统行为通常不需要访问用户数据。例如，在诊断TCP流量问题时，线上的速度和质量通常足以诊断问题。在传输数据时加密可以保护数据免受第三方可能的观察尝试。这有一个幸运的副作用，即在需要时允许更多的工程师访问数据包转储。然而，一个可能的错误是将元数据视为非敏感信息。恶意行为者仍然可以通过跟踪相关的访问模式（例如，在同一会话中注意到同一用户访问离婚律师和约会网站）从元数据中了解用户的很多信息。您应该仔细评估将元数据视为非敏感信息的风险。
- en: Also, some analysis *does* require actual data—for example, finding frequently
    accessed records in a database, and then figuring out why these accesses are common.
    We once debugged a low-level storage problem caused by a single account receiving
    thousands of emails per hour. [“Zero Trust Networking”](ch05.html#zero_trust_networking)
    has more information about access control for these situations.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些分析确实需要实际数据，例如，在数据库中查找频繁访问的记录，然后找出这些访问为什么是常见的。我们曾经调试过一个由单个帐户每小时接收数千封电子邮件引起的低级存储问题。["零信任网络"](ch05.html#zero_trust_networking)有关这些情况的访问控制的更多信息。
- en: Conclusion
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'Debugging and investigations are necessary aspects of managing a system. To
    reiterate the key points in the chapter:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 调试和调查是管理系统的必要方面。重申本章的关键点：
- en: '*Debugging* is an essential activity whereby systematic techniques—not guesswork—achieve
    results. You can make debugging vastly easier by implementing tools or logging
    to provide visibility into the system. Practice debugging to hone your skills.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调试*是一种必不可少的活动，通过系统化的技术而不是猜测来取得结果。您可以通过实施工具或记录来提供对系统的可见性，从而使调试变得更加容易。练习调试以磨练您的技能。'
- en: '*Security investigations* are different from debugging. They involve different
    people, tactics, and risks. Your investigation team should include experienced
    security professionals.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全调查*与调试不同。它们涉及不同的人员、策略和风险。您的调查团队应包括经验丰富的安全专业人员。'
- en: '*Centralized logging* is useful for debugging purposes, critical for investigations,
    and often useful for business analysis.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*集中式日志记录*对于调试目的很有用，对于调查至关重要，并且通常对业务分析也很有用。'
- en: '*Iterate* by looking at some recent investigations and asking yourself what
    information would have helped you debug an issue or investigate a concern. Debugging
    is a process of continuous improvement; you will regularly add data sources and
    look for ways to improve observability.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过查看一些最近的调查，并问自己什么信息会帮助您调试问题或调查问题，来*迭代*。调试是一个持续改进的过程；您将定期添加数据源并寻找改进可观察性的方法。
- en: '*Design for safety*. You need logs. Debuggers need access to systems and stored
    data. However, as the amount of data you store increases, both logs and debugging
    endpoints can become targets for adversaries. Design logging systems to collect
    information you’ll need, but also to require robust permissions, privileges, and
    policies to obtain that data.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设计安全性*。您需要日志。调试工具需要访问系统和存储的数据。然而，随着您存储的数据量的增加，日志和调试端点都可能成为对手的目标。设计日志系统以收集您需要的信息，但也要求具有强大的权限、特权和政策来获取这些数据。'
- en: 'Both debugging and security investigations often depend on sudden insight and
    luck, and even the best debuggers are sometimes sadly left in the dark. Remember
    that chance favors the prepared: by being ready with logs, and a system for indexing
    and investigating them, you can take advantage of the chances that come your way.
    Good luck!'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 调试和安全调查通常依赖于突然的洞察力和运气，即使最好的调试工具有时也会不幸地被置于黑暗中。记住，机会青睐有准备的人：通过准备好日志和一个用于索引和调查它们的系统，您可以利用到来的机会。祝你好运！
- en: ^([1](ch15.html#ch15fn2-marker)) Although the outage occurred in a large distributed
    system, people who have maintained smaller and self-contained systems will see
    a lot of similarities—for example, in outages involving a single mail server whose
    hard drive has run out of space!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch15.html#ch15fn2-marker))尽管故障发生在一个大型分布式系统中，但维护较小和自包含系统的人会看到很多相似之处，例如，在涉及单个邮件服务器的故障中，其硬盘已经用完空间！
- en: '^([2](ch15.html#ch15fn3-marker)) Spanner stores data as a Log-Structured Merge
    (LSM) tree. For details on this format, see Luo, Chen, and Michael J. Carey. 2018\.
    “LSM-Based Storage Techniques: A Survey.” arXiv preprint [arXiv:1812.07527v3](https://oreil.ly/DjWJn).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch15.html#ch15fn3-marker)) Spanner将数据存储为日志结构合并（LSM）树。有关此格式的详细信息，请参阅Luo,
    Chen和Michael J. Carey. 2018年的“基于LSM的存储技术：一项调查。”arXiv预印本[arXiv:1812.07527v3](https://oreil.ly/DjWJn)。
- en: '^([3](ch15.html#ch15fn4-marker)) For more on Borg, see Verma, Abhishek et al.
    2015\. “Large-Scale Cluster Management at Google with Borg.” *Proceedings of the
    10th European Conference on Computer Systems*: 1–17\. doi:10.1145/2741948.2741964.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch15.html#ch15fn4-marker))有关Borg的更多信息，请参阅Verma, Abhishek等人2015年的“在Google使用Borg进行大规模集群管理。”*第10届欧洲计算机系统会议论文集*：1-17。doi:10.1145/2741948.2741964。
- en: ^([4](ch15.html#ch15fn5-marker)) You may also be interested in the blog post
    [“What Does Debugging a Program Look Like?”](https://oreil.ly/J2U1R) by Julia
    Evans.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch15.html#ch15fn5-marker)) 您可能还对Julia Evans的博客文章[“调试程序是什么样子？”](https://oreil.ly/J2U1R)感兴趣。
- en: '^([5](ch15.html#ch15fn6-marker)) Schroeder, Bianca, Eduardo Pinheiro, and Wolf-Dietrich
    Weber. 2009\. “DRAM Errors in the Wild: A Large-Scale Field Study.” *ACM SIGMETRICS
    Performance Evaluation Review* 37(1). doi:10.1145/2492101.1555372.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch15.html#ch15fn6-marker)) Schroeder, Bianca, Eduardo Pinheiro和Wolf-Dietrich
    Weber. 2009年。《野外的DRAM错误：大规模实地研究》。*ACM SIGMETRICS Performance Evaluation Review*
    37(1)。doi:10.1145/2492101.1555372。
- en: ^([6](ch15.html#ch15fn7-marker)) These tools often require some setup; we will
    discuss them further in [“What to Do When You’re Stuck”](#what_to_do_when_youapostrophere_stuck).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch15.html#ch15fn7-marker)) 这些工具通常需要一些设置；我们将在[“当你陷入困境时该怎么办”](#what_to_do_when_youapostrophere_stuck)中进一步讨论它们。
- en: ^([7](ch15.html#ch15fn9-marker)) This is another example of normalized deviance,
    where people get used to suboptimal behavior!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch15.html#ch15fn9-marker)) 这是另一个规范偏差的例子，人们习惯于次优行为！
- en: ^([8](ch15.html#ch15fn10-marker)) See Krishnan, Kripa. 2012\. “Weathering the
    Unexpected.” *ACM Queue* 10(9). [*https://oreil.ly/xFPfT*](https://oreil.ly/xFPfT).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch15.html#ch15fn10-marker)) 请参阅Krishnan, Kripa. 2012年。《应对意外情况》。*ACM Queue*
    10(9)。[*https://oreil.ly/xFPfT*](https://oreil.ly/xFPfT)。
- en: ^([9](ch15.html#ch15fn11-marker)) 404 is a standard HTTP error code for “file
    not found.”
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch15.html#ch15fn11-marker)) 404是“文件未找到”的标准HTTP错误代码。
- en: ^([10](ch15.html#ch15fn12-marker)) Henderson, Fergus. 2017\. “Software Engineering
    at Google.” arXiv preprint [arXiv:1702.01715v2](https://oreil.ly/2-6pU).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch15.html#ch15fn12-marker)) 亨德森，弗格斯。2017年。《谷歌的软件工程》。arXiv预印本[arXiv:1702.01715v2](https://oreil.ly/2-6pU)。
- en: ^([11](ch15.html#ch15fn13-marker)) For a comprehensive survey of the topic,
    see Cindy Sridharan’s [“Monitoring in the Time of Cloud Native”](https://oreil.ly/n6-j9)
    blog post.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch15.html#ch15fn13-marker)) 要全面了解这个主题，请参阅Cindy Sridharan的[“云原生时代的监控”](https://oreil.ly/n6-j9)博客文章。
- en: ^([12](ch15.html#ch15fn14-marker)) See Julia Rozovsky’s blog post [“The Five
    Keys to a Successful Google Team”](https://oreil.ly/gpxoL) and the *New York Times*
    article [“What Google Learned from Its Quest to Build the Perfect Team”](https://oreil.ly/YJmwk)
    by Charles Duhigg.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch15.html#ch15fn14-marker)) 请参阅Julia Rozovsky的博客文章[“成功的谷歌团队的五个关键”](https://oreil.ly/gpxoL)和查尔斯·杜希格的*纽约时报*文章[“谷歌从寻求打造完美团队的过程中学到了什么”](https://oreil.ly/YJmwk)。
- en: ^([13](ch15.html#ch15fn15-marker)) See, e.g., Ghiasvand, Siavash, and Florina
    M. Ciorba. 2017\. “Anonymization of System Logs for Privacy and Storage Benefits.”
    arXiv preprint [arXiv:1706.04337](https://oreil.ly/c_a0N). See also Jan Lindquist’s
    article on [pseudonymization of personal data](https://oreil.ly/W3OFr) for General
    Data Protection Regulation (GDPR) compliance.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ^([13](ch15.html#ch15fn15-marker)) 例如，参见Ghiasvand, Siavash和Florina M. Ciorba.
    2017年。《用于隐私和存储收益的系统日志匿名化》。arXiv预印本[arXiv:1706.04337](https://oreil.ly/c_a0N)。另请参阅Jan
    Lindquist关于[个人数据假名化](https://oreil.ly/W3OFr)以符合《通用数据保护条例》（GDPR）的规定。
- en: ^([14](ch15.html#ch15fn16-marker)) See, e.g., Joxean Koret’s presentation [“Breaking
    Antivirus Software”](https://oreil.ly/alqtv) at 44CON 2014.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ^([14](ch15.html#ch15fn16-marker)) 例如，参见Joxean Koret在44CON 2014年的演讲[“破解杀毒软件”](https://oreil.ly/alqtv)。

- en: Building a Serverless Application in AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce the concept of serverless applications using AWS
    Lambda as the tool of choice. This will help you understand the concept, intuition,
    and working components involved in a serverless tool. It will also explain the
    nuances involved in security, user-controls, and versioning code inside Lambda.
    You will be guided via hands-on tutorials and lessons for understanding and learning
    to use AWS Lambda. So, it is recommended that you follow along this chapter with
    a laptop and an AWS account setup to easily execute the given instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Triggers in AWS Lambda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions as containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Lambda functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Versioning Lambda functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating deployment packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggers in AWS Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Serverless functions are on-demand computational concepts. So, there has to
    be an event that needs to trigger a Lambda function so that the entire computational
    process is started. AWS Lambda has several events which can act as a trigger.
    Almost all services of AWS can act as AWS Lambda''s triggers. Here is the list
    of services that you can use for generating events for Lambda to respond to:'
  prefs: []
  type: TYPE_NORMAL
- en: API Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS IoT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudWatch Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudWatch Logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CodeCommit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cognito Sync Trigger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DynamoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kinesis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: S3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SNS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The triggers page of AWS Lambda looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a984ab1-eb98-4ad2-94f8-1f4d6fef5c53.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at some of the following important and widely-used triggers
    that are available, and understand how they can be leveraged as FaaS in the serverless
    paradigm. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API Gateway**: This trigger can be used to create efficient, scalable, and
    serverless APIs. One scenario where a serverless API makes sense would be while
    building a querying interface for S3\. Let us assume that we have a bunch of text
    files in an S3 bucket. Whenever a user hits the API with a query parameter, which
    can be some word that we want to search in the text files in the bucket, the API
    Gateway''s trigger will launch a Lambda function that executes the computational
    logic and workload for executing the query. The Lambda function that we want our
    API to trigger can be specified at the API creation time. The trigger will be
    created accordingly in the corresponding Lambda function''s console. This is what
    it looks like:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/7739cf3b-f508-40b2-bcb5-0e7ead874b3e.png)'
  prefs: []
  type: TYPE_IMG
- en: '**CloudWatch**: It events mostly help the user in setting the cron scheduling
    for Lambda. The CloudWatch Logs trigger is useful whenever a user wants to execute
    a computational workload depending on some keyword in the Cloudwatch Logs. However,
    the CloudWatch Alarms cannot trigger Lambda directly via the CloudWatch trigger.
    They have to be sent via a notification system, such as the **AWS Simple Notification
    Service** (**AWS SNS**). This is how you can create a cron execution in AWS Lambda.
    In the following screenshot, the Lambda function is set to execute every minute:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4c9fd799-c9c5-4366-8fbe-f4f124270bf2.png)'
  prefs: []
  type: TYPE_IMG
- en: '**S3**: This is a document store of AWS. So, whenever a file is added, removed,
    or changed, an event will be sent to AWS Lambda when added as a trigger. So, if
    you want to do some computational workload on a file as soon as the file gets
    uploaded, then this trigger helps to do that. This is what an S3''s event structure
    looks like:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/e83a0e56-4388-4c0c-bd0d-3db52c93c7c9.png)'
  prefs: []
  type: TYPE_IMG
- en: '**AWS SNS**: The SNS service of AWS helps users to send notifications to other
    systems. This service can also be used for catching CloudWatch Alarms and sending
    the notifications to a Lambda function for computational execution. This is what
    a sample SNS event looks like:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/c7c76994-3f94-4d4f-9560-7d0148941068.png)'
  prefs: []
  type: TYPE_IMG
- en: Lambda functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lambda functions** are the core operating parts of a serverless architecture.
    They contain the code which is supposed to be executed. These functions are executed
    whenever the trigger attached to it has been set off. We have already learned
    about some of the most popular Lambda triggers in the previous section.'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a Lambda function is triggered, it creates a container with the respective
    settings set by the user. We'll learn more about the container in our next section.
  prefs: []
  type: TYPE_NORMAL
- en: The spinning up of containers takes a bit of time, which may result in a latency
    whenever a fresh invocation of a Lambda function is done, as it takes time to
    set up the environment and bootstrap the settings mentioned by the user in the
    Advanced settings tab. So, to overcome this latency, AWS thaws a container for
    some time for reuse in case of another Lambda invocation within the thawing time.
    So, using a thawed or a ready-made Lambda function helps in overcoming the latency
    problem. However, the same global namespace of the thawed container would be reused
    for the new invocation too.
  prefs: []
  type: TYPE_NORMAL
- en: So, if the Lambda function has any global variables that get manipulated inside
    the function, it is a good idea to convert them into local namespaces, as the
    manipulated global namespace variables will be reused, leading to faulty execution
    results of the Lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user needs to specify the technical details for the Lambda function in
    the Advanced Settings tab, which include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Memory (MB): This is the maximum memory that the Lambda function needs to be
    allocated for the purpose of your function. The CPU of the container would be
    assigned accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Timeout: The maximum amount of time the function needs to execute before the
    container gets automatically stopped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DLQ Resource: This is a dead-letter setting to AWS Lambda. The user can add
    either an SQS queue or an SNS topic for configuring this. Lambda functions get
    asynchronously retried for at least five times on failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VPC: This enables the Lambda function to access components or services in some
    particular VPCs. The Lambda function executes in a default VPC of its own.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'KMS key: If there are any environment variables entered along with the Lambda
    function, this helps us encrypt them using an **AWS Key Management Service** (**KMS**)
    by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Lambda function''s Advanced settings page looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6883b0ae-4195-4621-9e2a-af3407fd3ee2.png)'
  prefs: []
  type: TYPE_IMG
- en: Functions as containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For understanding the concept of functions being executed as/inside containers,
    we need to properly understand the concept of containers. To cite the definition
    of a container from the Docker documentation ([https://www.docker.com/what-docker](https://www.docker.com/what-docker))[:](https://www.docker.com/what-docker)
  prefs: []
  type: TYPE_NORMAL
- en: 'A container image is a lightweight, stand-alone, executable package of a piece
    of software that includes everything needed to run it: code, runtime, system tools,
    system libraries, settings.'
  prefs: []
  type: TYPE_NORMAL
- en: What is available for both Linux and Windows based applications; containerized
    software will always run the same, regardless of the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Containers isolate software from its surroundings (for example, differences
    between development and staging environments) and help reduce conflicts between
    teams running different software on the same infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the concept of containers is that they are self-sustainable isolated environments
    just like the containers in a container ship that can be hosted and be worked
    upon any host OS, the host OS being the host ship in our analogy. The figurative
    depiction of the analogy would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2c26768-83bf-4ca5-afa0-960f651ce95a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similar to the aforementioned analogy, AWS Lambda''s functions are also launched
    inside a unique container for each function. So, let us understand this topic
    in more detail, point by point:'
  prefs: []
  type: TYPE_NORMAL
- en: The Lambda function can be in the form of a single code file or in the form
    of a **deployment package**. The deployment package is a zipped file that includes
    the core function file along with the libraries which would be used by the function.
    We shall be learning in detail about how to create the deployment package in the
    *Creating deployment packages* section of this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever a function is triggered or started, AWS spins up an EC2 instance with
    the AWS Linux operating system for running the function. The configuration of
    the instance would be dependent on the ones provided by the user in the Advanced
    settings tab of the Lambda function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is a maximum time limit of 300 seconds, or 5 minutes, for a function to
    execute successfully, after which the container would be destroyed. So, this needs
    to be kept in mind while designing the Lambda functions and/or the deployment
    packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will go through the ways of configuring Lambda functions
    and understand all the settings in great detail. Like in the previous section,
    we will learn about each configuration and its settings, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can go to the page of AWS Lambda by selecting it from the drop-down menu
    that is present in the top-left corner of the AWS console. This can be done as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a971c7c0-ac7c-4032-838a-9306e5ac0a07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the Lambda option is selected, it redirects the user to the AWS Lambda
    console, which looks something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5f3040c3-80f1-4d46-ad5f-61968215099a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For creating a function, you need to click on the orange Create a function
    button on the right. This will open a console for the function creation. This
    looks something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/91b67fee-892c-4954-91a5-47b0584f523d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create a function from scratch in order to understand the configurations
    better. So, for doing that, click on the Author from scratch button on the top-right
    corner. After clicking it, the user will be directed to Lambda''s first-run console,
    which looks something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/86d6c931-dd7b-4ee2-8ce5-2f546d3e9569.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This page has three configurations which the user can select, which are Name,
    Role, and Existing role. The Name value is where the user can enter the name of
    the Lambda function. The Role value is how you can define permissions in the AWS
    environment. The Role value''s drop-down list would contain the following options:
    Choose an existing role, Create new role from template(s), and Create a custom
    role. They can be seen as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ee94ac27-0a27-49bb-8c39-dcc09e308f43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Choose an existing role option will enable us to select an already existing
    role with pre-configured permissions. The second option helps the user with creating
    a role from pre-baked templates. The Create a custom role option allows the user
    to create a role with permissions from scratch. The list of pre-baked roles looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/605762e3-0a24-47b9-a644-eb349c5ff5c9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select one from the pre-baked templates for the sake of this tutorial. By pressing Create
    function in the lower-right part of the screen, we will land on the Lambda function''s
    creation page, which looks similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aaa97414-bac6-40c6-9f48-c034de864930.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding page indicates that we have successfully created an AWS Lambda
    function. We shall now explore the advanced settings of this function. They are
    present in the lower part of the same console. They will look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b159cb6f-45db-4ad8-9f75-fc8d1f5c408e.png)'
  prefs: []
  type: TYPE_IMG
- en: We shall now try to understand each of those parts in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The unfurled Environment variables section contains text boxes to enter the
    key-value pair of environment variables that will be used by our function. One
    can also optionally mention details on the encryption setting that we want to
    have for the environment variables. The encryption needs to be done via **AWS
    KMS** (**Key Management Service**). The unfurled settings box of the environment
    variables looks something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1240de6e-18aa-45f9-9ae0-dbe9acc35964.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next settings section is Tags. This is similar to the tagging feature of
    all the available AWS services for easy service discovery purposes. So, similar
    to all AWS services''s tags, this also needs just a key and a value. The unfurled
    Tags section looks something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c81faef8-1e1f-4f68-8ffd-4bf992e09763.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next section that will be visible after the Tags section is the Execution
    role section, in which the user can set the **Identity Access Management (IAM)**
    role for the execution of the Lambda function. As we have already discussed what
    IAM roles are previously in the book, we will not be covering that again here.
    If the user has not set the role when creating the function itself, they can always
    set that here. The section will be visible in the Lambda console as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7125de51-b42f-4c62-879e-d1d4d75c9efa.png)'
  prefs: []
  type: TYPE_IMG
- en: The next section is the Basic settings section, which includes settings such
    as the memory of the Lambda container, time-out for the container, and the description
    for the Lambda function. The memory of the container can range from 128 MB to
    1,536 MB. The user can choose any value within that range and will be billed accordingly.
    The time-out can be set from 1 second to 300 seconds, which is 5 minutes. The
    time-out is the time which the Lambda function and its container would run before
    being stopped or terminated. The next setting is the Description value of the
    Lambda function, which acts as the metadata of a Lambda function. The section
    looks like this in the console:![](img/f710d7d7-5215-4817-81a2-b1ec059106a6.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next section is the Network section, which is also about the network settings
    of the Lambda function related to **AWS's Virtual Private Cloud** (**VPC**) and
    related subnets. Even if No VPC is selected as an option, AWS Lambda runs in its
    own secure VPC. However, if your Lambda function accesses or deals with any other
    service which is in a particular VPC or in a subnet, the corresponding information
    needs to be added in this section so that the network allows traffic from the
    Lambda function's container. This section looks like this in the console:![](img/f75cfc81-b7f7-412c-a8c9-ace0d6d69a21.jpg)The
    sensitive information in the preceding screenshot, such as the IP address and
    the ID of the VPC, are masked for security purposes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next section is the Debugging and error handling section. This section enables
    the user to set up measures for ensuring fault tolerance and exception handling
    of the Lambda function. This includes the **Dead Letter Queue** (**DLQ**) settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lambda automatically retries failed executions for asynchronous invocations.
    So, the payloads that were not processed would be automatically forwarded to the
    DLQ resource. The DLQ settings look like this in the Lambda console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b74e9b2e-a5e1-4007-bea9-82a6be36cf5f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The user can also enable active tracing for the Lambda functions, which would
    help in detailed monitoring of the Lambda container. This setting in the Debugging
    and error handling section of the Lambda console looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a74a9e4c-467c-476a-81ef-81b5a7805148.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing Lambda functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like every other software system and programming paradigm, proper testing
    of Lambda functions and serverless architectures is very important before deploying
    into production. We will try to understand the testing of Lambda functions in
    the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the top-most bar of the Lambda console, one can observe the Save and test
    option, which is represented by an orange button. This button saves the Lambda
    function and then runs the configured tests on that function. This looks something
    like this in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/60f3caa0-0530-4b40-9e10-3dd991c15c94.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, in the same bar, there exists a drop-down menu that reads Select a test
    event…. This contains a list of testing events available for testing Lambda functions.
    The drop-down looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1114f014-a1ad-4033-99b3-8cf90d913e9c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, for further configuration of test events for the Lambda function, the
    user needs to select the Configure test events option in the drop-down. This will
    open a popup with the test events menu, which looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/564fb42c-4c4e-4461-884b-7106e608fa50.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That would open the basic Hello World template, which has three pre-configured
    JSON format test events, or edge cases. However, depending on what the Lambda
    function does, one can select some other test event. The available list of testing
    templates can be seen in the Event template drop-down menu. The list in the drop-down
    looks something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/905d7bd8-21d2-46c3-a276-25ebdd9a786e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, let''s imagine we are building a pipeline that involves the Lambda
    function getting started whenever an image file is added to an S3 bucket, and
    the function does some image processing tasks and puts it back to some data store.
    The test event of the S3 Put notification looks something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/339a2a51-15e7-4502-b96a-1eb712e5514e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After selecting or creating a test event, the user can select the Create option
    in the bottom-right corner of the event creation console, wherein you shall be
    asked to enter a name for the event. After entering the necessary details, the
    user will be re-directed back to the Lambda console. Now, when you check the TestEvent drop-down
    in the Lambda console, you can see the saved test event in the list. This can
    be verified as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7d7b1f3b-595b-4bad-bf33-99ac957fade3.png)'
  prefs: []
  type: TYPE_IMG
- en: As I have named the event as **TestEvent**, the test is visible by the same
    name in the events drop-down menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, when we take a closer look at the event structure of S3 in the
    test event, we can observe the meta-details that are being made available to the
    Lambda function. The event structure looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ff15ffd2-7bb5-4303-bc13-bba656deb732.png)'
  prefs: []
  type: TYPE_IMG
- en: Versioning Lambda functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept of the **Version Control System** (**VCS**) is for controlling
    and managing versions of code. This functionality is available directly from the
    main Lambda console. Let''s try and learn how to version our Lambda functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first option in the Actions drop-down in the Lambda console is the Publish
    new version option. This option can be seen here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7b880937-3308-472d-800e-00ed54ce1452.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the Publish new version option is selected, the versioning popup of the
    Lambda console would be seen on the console. This would ask about the name for
    the new version of your Lambda function. The popup looks something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b78150b6-6c9e-4eee-905f-17633a6a48cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After clicking the Publish button, you will be re-directed to the main Lambda
    console. The successfully created Lambda version in the console looks something
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a117ec47-8651-41bc-b503-6db458194811.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the bottom half of the page, the following message can be noticed: Code
    and handler editing is only available for the $LATEST version. This means that
    one can only edit the code in the version named $LATEST.  The versioned version
    of Lambda functions are read-only and cannot be edited and manipulated. When something
    goes wrong or when the user wants to revert back or refer to a previous version,
    that version will overlay the $LATEST version to make edits possible. The message
    looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6c35f1e1-7d34-4c9d-8119-2f43400a4d43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the Click here to go to $LATEST link is clicked, the user will be re-directed
    to the $LATEST version of the function, which can be edited and manipulated by
    the user. The console of the $LATEST version of the Lambda function looks like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d872e1c7-1d3b-4aa7-afce-6a4e9a8b1117.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating deployment packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lambda functions that have external libraries as dependencies can be packaged
    as deployment packages and be uploaded into the AWS Lambda console. This is very
    similar to creating a virtual environment in Python. So in this section, we shall
    learn and understand the process of creating Python deployment for using in the
    Lambda functions. We shall try and understand the process of creating deployment
    packages in detail, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Deployment packages are generally in the format of ZIP packages. The contents
    of the ZIP package is exactly the same as a normal library of any programming
    language.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The package structure should be such that the library folders and the function
    file are in the same destination or in the same hierarchy inside the folder structure
    of the deployment package. The layout looks something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f46e42f6-0700-481b-be63-584d08bb0682.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Python libraries can be installed by using the `pip install <library_name>
    -t <path_of_the_target_folder>` command. This will install the package inside
    the target folder. This can be done as in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/986316e5-9244-4ed2-bc1c-ff4ed09e6777.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, when we have the entire deployment package''s folder along with the library
    folders ready, we need to zip all of the folders including the Lambda function
    file before uploading it into the console. The following screenshot shows how
    the zipping needs to be done as per the folder hierarchy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d5dac1d7-bb73-4319-ba28-b07c503af622.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, as the zipped package is ready, we shall be trying to upload the package
    to the Lambda console for processing. For uploading a Lambda package, we need
    to select the drop-down list of the Code entry type option in the console. The
    selection looks like this in the Lambda console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6ccd81c5-5cfb-4e7d-a4c5-f46fe32736ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the Upload a .ZIP file option is selected, the uploader will become visible,
    where the user can directly upload the deployment package or even upload it via
    an S3 bucket. The wizard would look like this in the Lambda console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6f4fa67b-53b7-4580-a9a9-c2258507f36c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As mentioned previously, the user can choose to upload the deployment package
    via an S3 file location too. This wizard looks like this in the Lambda console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/12130c7f-5d6e-487a-9c9f-76eb692be568.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The deployment package''s naming should be aligned with the values entered
    in the handler part of the settings. The deployment package''s name and the Lambda
    function file''s name are separated by a dot (`.`) and arranged in that order.
    This can be explicitly seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/406c2dc0-125f-4d22-850a-6be24e2035fe.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`index` should be the name of the Lambda function''s file name deployment package.
    The `handler` function file is the name of the core function handler inside, which
    is the Lambda function. As AWS''s documentation states:'
  prefs: []
  type: TYPE_NORMAL
- en: The module-name export value in your function". For example, index.handler would
    call exports.handler in index.py.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned the concepts of how triggers work for AWS Lambda
    and how to select triggers depending on the problem statement and time intervals,
    in case of cron job triggers. We understood what Lambda functions are, along with
    understanding their functionalities and settings related to memory, VPCs, security,
    and fault tolerance. We also learned about the way container reuse is done under
    the hood specifically for AWS Lambda. Then, we covered event-driven functions
    and how they are implemented under the hood, the concept of containers, and their
    uses and applications in the domain of software engineering in general. Most importantly,
    from the concepts we learned regarding containers, we can now appreciate the options
    for choosing containers for running the Lambda functions.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we talked about all the configuration settings available in the
    AWS Lambda dashboard, which are necessary to build and run a Lambda function from
    start to finish without any settings-related problems. We also learned about and
    understood the security settings inside Lambda so that the necessary VPC details
    and security keys settings are taken care of when configuring our Lambda functions.
    This was followed by testing Lambda functions depending on the choice of trigger
    selected. We learned what the responses of various AWS services look like, as
    they are the inputs for the Lambda functions. We then learned how to write custom
    hand-made tests for custom testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, we saw how versioning happens for the AWS Lambda functions.
    We learned the differences between past and present versions. We also learned
    that the present version is immutable, unlike the past versions, and also how
    to revert to past versions without much effort. We also learned how to create
    deployment packages for functions that have dependencies on external packages,
    which are not included in Python's standard library. We came across the function
    code naming nuances, including the filename and the method handler names, followed
    by the two ways deployment packages can be uploaded to the Lambda console; one
    being a manual upload and the other being from an S3 file location.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be gaining a detailed understanding of the different
    triggers available in the Lambda console and how to use them. We will also learn
    about implementing them in Python code. We will understand the event structures
    and the responses from different AWS services and use that to build our Lambda
    functions. We will understand how to integrate each trigger into a Lambda function
    and do a specific task in Python. Finally, we will also be learning about ideas
    and best practices on how to move your existing infrastructures to serverless
    using the serverless paradigm.
  prefs: []
  type: TYPE_NORMAL

- en: Deploying a Lambda Function with SAM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned about Lambda functions and how to build them. We have
    learned that a Lambda function has a definite set of triggers that would trigger
    the function to carry out a particular task. The task is written as a Python module
    and the script is what we call a function. We have also learned about the different
    settings of Lambda functions, which include its core settings and also other settings,
    such as security and network.
  prefs: []
  type: TYPE_NORMAL
- en: There is also another alternative to creating and deploying Lambda functions,
    which is the **AWS Serverless Application Model** (**AWS SAM**). This format is
    based on the concept of **infrastructure as code**. This concept is inspired by
    **AWS CloudFormation**, which is a form of infrastructure as code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be learning about AWS CloudFormation and using that knowledge to understand
    and build AWS SAM models for creating Lambda functions. We will be covering the
    following concepts in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Lambda functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CloudFormation for serverless services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying with SAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding security in SAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to SAM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn about SAM, which will help us build and deploy
    serverless functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, SAM is about writing infrastructure as code. So, this
    is what a Lambda function would be described as in SAM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this block of code, we enter the details—the name of the function, and the
    URI of the S3 bucket where our code package is hosted. In the same way that we
    named the index and the handler in our Lambda settings, we need to enter those
    details here, too. The `index.handler` is the file in which our function code
    is located. The `Handler` is the name of the function in which our Lambda logic
    is written. Also, the `Runtime` is user-defined. You can select from all the available
    languages that are supported by AWS Lambda. The scope of this book is limited
    to the Python language, so we will stick to either of the available Python versions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e5c44dfc-c294-4529-b260-6e13e760861a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also add environment variables, as shown here, in our Lambda function,
    too. These can be very easily edited and configured just as we add, update, and/or
    delete code, which is an added advantage of the infrastructure as code style of
    building infrastructures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding SAM code invokes two Lambda functions that point to an AWS `DynamoDB`
    table. The entire SAM code is an application that consists of a couple of Lambda
    functions. You need to enter the necessary details for making this work. The `Runtime`
    needs to be updated with either of the available Python runtimes. The corresponding
    policy for dealing with the `DynamoDB` tables needs to be updated in the `Policies`
    section. The `CodeUri` section needs to be updated with the S3 URI of the code
    package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is to be noted that the meta information should always be included for all
    SAM, which includes the `AWSTemplateFormatVersion` and `Transform`. This would
    tell `CloudFormation` that the code you have written is an AWS SAM code and a
    serverless application. The two lines are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If your serverless function needs to access a single table of `DynamoDB`, you
    can start by creating a `DynamoDB` table via your SAM function itself using the
    `SimpleTable` attribute. This can be done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will learn how to create a Lambda function with a trigger. As we are
    already using `DynamoDB` for the examples, we will use the same as a trigger in
    this step. The SAM code for this would look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: CloudFormation for serverless services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how CloudFormation can be used to build and
    deploy Lambda functions. We will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write a CloudFormation template for a Lambda function that periodically
    pings a website and gives an error if there is any failure in the process. The
    CloudFormation template for this is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a lot of syntax in this CloudFormation snippet. We will now try to
    understand it in a bit more detail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the first three lines that contain the meta details of the Lambda function,
    we have the following line—`Transform: ''AWS::Serverless-2016-10-31''`. This line
    is used to define the resources that a user will be using/accessing, through a
    CloudFormation template. As we are using a Lambda function, we have specified
    it as `Serverless`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have also defined the memory size that our function will be using. It is
    similar to how we learned to view and change the memory settings in the Lambda's
    console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Timeout` is the amount of time the Lambda function can keep retrying before
    considering the attempt as a failure.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also see that we have added environment variables to our Lambda function
    that will be stored in the Lambda container and used when needed by the system.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying with SAM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to deploy the SAM applications. We have
    already learned what SAM applications and code look like, so we will learn how
    to deploy them via AWS CloudFormation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, let''s set up our local environment for deployment purposes, and then
    start by installing `awscli` from `pip`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4b67d323-8d3f-49e0-9ce3-18ec5b70932f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, you will need to configure your AWS environment using your credentials:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/637bc3a8-4fed-43bb-8bda-53b235b4b91e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will need to enter the following details to make sure your AWS environment
    is successfully configured:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your AWS Access Key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your AWS Secret Key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default region in which you want to operate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default output format in which you want your data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's try to deploy a simple `Hello World` Lambda application via SAM.
    We will have two code files for this. One is the Python file and the other is
    the template `yaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will use the default `Hello World` example for Python, as we are trying
    to understand how SAM deployments work instead of stressing too much about the
    code for now. The Python script will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use a basic template `yaml` file for the SAM function too, whose only
    job is to define its meta information and to run the Python script that is mentioned
    previously. The template `yaml` file will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will package the SAM template we just created, using the command line.
    The instructions for packaging the code are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fcd53c6d-c90b-468e-9044-5d38eaa618fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will create an output `yaml` file that needs to be deployed, as mentioned
    in the preceding trace. The `output.yaml` file looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as we have packaged the SAM template, we will now deploy it. We will use
    the instructions shown in the trace when we did the packaging for the deployment
    process. The instructions for deployment are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09093362-05ed-484f-a743-9a4fd649b5c3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can head over to the CloudFormation console to look at the template we just
    deployed. The deployed template will look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/64976600-cef8-40d9-a198-c103442f1e8d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Template tab shown here, we can see both the original template and the
    processed template. The original template can be seen by selecting the first radio
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/966b6d7b-130a-47fb-94b5-13b5d8d9a579.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The processed template can be seen by selecting the second radio button under
    the Template tab at the bottom:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9240398c-977a-4df1-8be0-d4243a8bb0cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we head over to the Lambda console, we will see the newly created Lambda
    function via SAM with the corresponding name given:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1ceead11-6d47-4396-92fb-72ac2559a00b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the Functions will give us more information about it. It also mentions
    the SAM template and the CloudFormation template from which it was created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9dd6e2a3-ffce-4908-9b99-0852f557a72c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create basic tests for the Lambda function. The test creation console
    can be opened by clicking on the Test button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1b29cf18-4b82-448e-9eb6-4954f9acf933.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, once the tests have been created, you can again click on the Test button.
    This will run the testing with the updated test cases. The logs from a successful
    run will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1797719e-ca71-4599-84e2-7688090e3623.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s go through each component of the Lambda function properly. The
    Configuration shows the triggers and the logging settings of our Lambda function.
    We are logging into the CloudWatch service of AWS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f4a0fbe7-f92c-4b29-a542-0431875b09ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also see the invocation metrics in the Monitoring option in the Lambda
    console. We can see exactly one Lambda invocation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a6f5218c-df89-4d30-8af3-6d232cb54679.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see the code files in the Function code section. You can see the folder
    structure in the left-hand corner of the interactive code editor that contains
    both the `template.yaml` file and the function code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/38614b15-0ddb-4f68-943c-6800adb930ac.png)'
  prefs: []
  type: TYPE_IMG
- en: And further below, you can see the pre-existing environment variable named `lambda:createdBy`, and
    also the timeout setting we mentioned in our template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding security in SAM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have learned how to write, build, package, and deploy Lambda functions
    using the SAM. We will now understand how security works inside them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can scroll to the bottom of the Lambda console to see the network and security
    settings, where the VPC and the subnet details are mentioned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/22126210-d869-47c4-a585-d7a2b6fef3d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will add in the network settings, which include the security groups
    and the subnet IDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, package and deploy the newly updated SAM template like we did in the previous
    section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/458ee721-6aeb-49ed-8c80-28c9a66acf41.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now you will see the corresponding network and security settings, once you
    have packaged and deployed the CloudFormation template after the corresponding
    edits. The Network section looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a7c165d6-9163-477b-996d-bb12e2f8a9ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also see the inbound rules of your corresponding security groups that
    are linked with the VPC in your Network settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5906e5fe-a674-4736-832d-2965d8cdda49.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also see the completed CloudFormation template in your console with
    the updated network and security settings, which means that deployment has been
    successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b48301ca-6100-40fb-a102-742bfb935c3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also see the original template under the Templates option in the bottom
    corner of the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9f8acd7b-4831-4bcc-a39e-dc1219c9764b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The processed template can be found by selecting the View processed template
    option beside the original template option at the bottom of the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ec93f03d-badb-46e9-90ae-ff408f1a16ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to deploy Lambda functions as infrastructure
    as code via SAM, which is a new way of writing and deploying Lambda functions.
    This makes it easier to integrate with other IaaS services, such as CloudFormation.
    We also learned about the AWS CloudFormation service, which is the service that
    allows and facilitates infrastructure as code. We also learned how security works
    inside SAM code and how to configure VPC and subnet settings.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will be introduced to Microsoft Azure functions, along
    with configuring and understanding the components of the tool.
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 8. Pointers, the Standard Template Library, and Texture Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will learn a lot, as well as get plenty done to the game in this chapter.
    We will first learn about the fundamental C++ topic of **pointers**. Pointers
    are variables that hold memory addresses. Typically, a pointer will hold the memory
    address of another variable. This sounds a bit like a reference but we will see
    how they are much more powerful. We will also use a pointer to handle an ever-expanding
    horde of zombies.
  prefs: []
  type: TYPE_NORMAL
- en: We will also learn about the **Standard Template Library** (**STL**) which is
    a collection of classes that allow us to quickly and easily implement common data
    management techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Once we understand the basics of the STL, we will be able to use that new knowledge
    to manage all the textures from the game, because if we have 1000 zombies, we
    don't really want to load a copy of a zombie graphic into the GPU for each and
    every one.
  prefs: []
  type: TYPE_NORMAL
- en: We will also dig a little deeper into OOP and use a **static** function which
    is a function of a class that can be called without an instance of the class.
    At the same time, we will see how we can design a class to ensure that only one
    instance can ever exist. This is ideal when we need to guarantee that different
    parts of our code will use the same data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about the STL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the `Texture Holder` class using static functions and a **singleton**
    class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a pointer to a horde of zombies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit some existing code to use the `TextureHolder` class for the player and
    background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pointers can be the cause of frustration while learning to code C++. Actually,
    however, the concept is simple.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **pointer** is a variable that holds a memory address.
  prefs: []
  type: TYPE_NORMAL
- en: That's it! Nothing there to get concerned about. What probably causes the frustration
    to beginners is the syntax, the code we use to handle pointers. With this in mind
    we will step through each part of the code for using pointers. You can then begin
    the ongoing process of mastering them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will actually learn more about pointers than we need for
    this project. In the next project, we will make greater use of pointers. Despite
    this, we will only scratch the surface of the topic. Further study is definitely
    recommended and we will talk more about that in the final chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Rarely do I suggest that memorizing facts, figures, or syntax is the best way
    to learn. However, memorizing the fairly brief but crucial syntax related to pointers
    might be worthwhile. This is so that it sinks so deep into our brains we can never
    forget it. We can then talk about why we need pointers and examine their relationship
    to references. A pointer analogy might help.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a variable is a house and its contents are the value it holds, then a pointer
    is the address of the house.
  prefs: []
  type: TYPE_NORMAL
- en: We learned in the previous chapter while discussing references that when we
    pass values to, or return values from, a function, we are actually making a completely
    new house the exact same as the previous one. We are making a copy of the value
    passed to or from a function.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, pointers are probably starting to sound a bit like references.
    That's because they are a bit like references. Pointers, however, are much more
    flexible, powerful, and have their own special and unique uses. These special
    and unique uses require a special and unique syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Pointer syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two main operators associated with pointers. The first is the **address
    of** operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And the second is the **dereference** operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will take a look now at the different ways we use these operators with pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you will notice is that the address of operator is the same
    as the reference operator. To add to the woes of an aspiring C++ game programmer,
    the operators do different things in different contexts. Knowing this from the
    outset is valuable. If you are staring at some code involving pointers and it
    seems like you are going mad, know this:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You are perfectly sane! You just need to look at the detail of the context.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know that if something isn't clear and immediately obvious it is not
    your fault. Pointers are not clear and immediately obvious, but looking carefully
    at the context will reveal what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with the knowledge that you need to pay more attention to pointers than
    to previous syntax, as well as what the two operators are (address of and dereference),
    we can now start to actually see some real pointer code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure you have memorized the two operators before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a pointer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To declare a new pointer, we use the dereference operator along with the type
    of variable the pointer will be holding the address of. Take a look at the code
    and we will go into it some more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code declares a new pointer called `pHealth` that can hold the address
    of a variable of type `int`. Notice I said can hold a variable of type `int`.
    As with other variables a pointer also needs to be initialized with a value to
    make proper use of it. The name `pHealth` as with other variables is arbitrary.
  prefs: []
  type: TYPE_NORMAL
- en: It is common practice to prefix the names of variables that are pointers with
    a `p`. It is then much easier to remember when we are dealing with a pointer and
    to distinguish them from regular variables.
  prefs: []
  type: TYPE_NORMAL
- en: The white space used around the dereference operator is optional (because C++
    rarely cares about spaces in syntax), but recommended because it aids readability.
    Take a look at the following three lines of code, which do exactly the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This format we have just seen, in the previous example, with the dereference
    operator next to the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'White space either side of the dereference operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The dereference operator next to the name of the pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is worth being aware of these possibilities so that when you read code, perhaps
    on the Web, you will understand they are all the same. In this book, we will always
    use the first option with the dereference operator next to the type.
  prefs: []
  type: TYPE_NORMAL
- en: Just like a regular variable can only successfully contain data of the appropriate
    type, a pointer should only hold the address of a variable of the appropriate
    type.
  prefs: []
  type: TYPE_NORMAL
- en: A pointer to type `int` should not hold the address of a String, Zombie, Player,
    Sprite, float, or any other type.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a pointer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next we can see how to get the address of a variable into a pointer. Take a
    look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we declare an `int` variable called `health` and initialize
    it to `5`. It makes sense, although we have never discussed it before, that this
    variable must be somewhere in our computer's memory. It must have a memory address.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access this address using the address of operator. Look closely at the
    last line of the previous code. We initialize `pHealth` with the address of `health`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our `pHealth`, now holds the address of the regular `int`, `health`. In C++
    terminology we say that `pHealth` points to health.
  prefs: []
  type: TYPE_NORMAL
- en: We can use `pHealth` by passing it to a function, so that function can work
    on `health`, just like we did with references. There would be no reason for pointers
    if that was all we were going to do with them.
  prefs: []
  type: TYPE_NORMAL
- en: Reinitializing pointers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A pointer, unlike a reference, can be reinitialized to point to a different
    address. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now `pHealth` points to the `int` variable, `score`.
  prefs: []
  type: TYPE_NORMAL
- en: Of course the name of our pointer, `pHealth`, is now slightly ambiguous and
    should perhaps have been called `pIntPointer`. The key thing to understand here
    is that we can do this reassignment.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage we haven't actually used a pointer for anything other than simply
    pointing (holding a memory address). Let's see how we can access the value stored
    at the address pointed to by a pointer. This will make them genuinely useful.
  prefs: []
  type: TYPE_NORMAL
- en: Dereferencing a pointer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So we know that a pointer holds an address in memory. If we were to output
    this address in our game, perhaps in our HUD, after it has been declared and initialized,
    it might look something like this: `9876`.'
  prefs: []
  type: TYPE_NORMAL
- en: It is just a value. A value that represents an address in memory. On different
    operating systems and hardware types, the range of these values will vary. In
    the context of this book we never need to manipulate an address directly. We only
    care what the value stored at the address that is pointed to is.
  prefs: []
  type: TYPE_NORMAL
- en: The actual addresses used by variables are determined when the game is executed
    (at run-time) and therefore, there is no way of knowing the address of a variable
    and hence the value stored in a pointer, while we are coding the game.
  prefs: []
  type: TYPE_NORMAL
- en: We access the value stored at the address pointed to by a pointer by using the
    dereference operator, `*`. The following code manipulates some variables directly,
    and by using a pointer. Try and follow along and then we will go through it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Warning! The code that follows is pointless (pun intended). It just demonstrates
    using pointers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we declare two int variables, `score` and `hiScore`. We
    then initialize them with the values zero and ten respectively. We next declare
    two pointers to `int`. They are `pIntPointer1` and `pIntPointer2`. We initialize
    them in the same step as declaring them to hold the addresses of (point to) the
    variables `score` and `hiScore` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we add ten to `score` in the usual way, `score += 10`. Then we see that
    by using the dereference operator on a pointer we can access the value stored
    at the address they point to. The following code actually changed the value stored
    by the variable pointed to by `pIntPointer1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of the previous code dereferences both of the pointers to assign
    the value pointed to by `pIntPointer1` as the value pointed to by `pIntPointer2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Both `score` and `hiScore` are now equal to `20`.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers are versatile and powerful
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can do so much more with pointers. Here are just a few useful things we can
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically allocated memory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the pointers we have seen so far point to memory addresses that have a scope
    limited only to the function they are created in. So if we declare and initialize
    a pointer to a local variable, when the function returns, the pointer, the local
    variable, and the memory address is gone. It is out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: Up until now we have been using a fixed amount of memory that is decided in
    advance of the game being executed. Furthermore, the memory we have been using
    is controlled by the operating system and variables are lost and created as we
    call and return from functions. What we need is a way to use memory that is always
    in scope, until we are finished with it. We want to have access to memory we can
    call our own and take responsibility for.
  prefs: []
  type: TYPE_NORMAL
- en: When we declare variables (including pointers), they are in an area of memory
    known as the **stack**. There is another area of memory, which although allocated/controlled
    by the operating system, can be allocated at runtime. This other area of memory
    is called the **free store** or sometimes the **heap**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Memory on the heap does not have scope to a particular function. Returning from
    a function does not delete the memory on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: This gives us great power. With access to memory that is only limited by the
    resources of the computer our game is running on, we can plan games with a huge
    amount of objects. In our case we want a vast horde of zombies. As Spider-man's
    uncle wouldn't hesitate to remind us, however, *with great power comes great responsibility*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how we can use pointers to take advantage of the memory on the
    free store and also how we release that memory back to the operating system when
    we are finished with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a pointer that points to a value on the heap, first we need a pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the previous line of code, we declare a pointer as we have seen before, but
    as we are not initializing it to point to a variable, we initialize it to `nullptr`.
    We do this because it is good practice. Consider dereferencing a pointer (changing
    a value at the address it points to) when you don't even know what it is pointing
    to. It would be the programming equivalent of going to the shooting range, blindfolding
    someone, spinning them around, and telling them to shoot. By pointing a pointer
    to nothing (`nullptr`) we can't do any harm with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are ready to request memory on the free store we use the new keyword
    as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The pointer `pToInt` now holds the memory address of space on the free store
    that is just the right size to hold an `int` value.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any allocated memory is returned when the program ends. It is, however, important
    to realize that this memory will never be freed (within the execution of our game),
    unless we free it. If we continue to take memory from the free store without giving
    it back, eventually it will run out and the game will crash.
  prefs: []
  type: TYPE_NORMAL
- en: It is unlikely that we would ever run out of memory by occasionally taking `int`
    sized chunks of the free store. But if our program has a function or loop that
    requests memory, and this function or loop is executed regularly throughout the
    game, eventually the game will slow and then crash. Furthermore, if we allocate
    lots of objects on the free store and don't manage them correctly, then this situation
    can happen quite quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line of code, hands back (deletes) the memory on the free store
    that was previously pointed to by `pToInt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now the memory that was previously pointed to by `pToInt` is no longer ours
    to do what we like with, we must make take precautions. Although the memory has
    been handed back to the operating system, `pToInt` still holds the address of
    this memory, which no longer belongs to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line of code ensures that `pToInt` can''t be used to attempt
    to manipulate or access this memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a pointer points to an address that is invalid it is called a **wild** or
    **dangling** pointer. If you attempt to dereference a dangling pointer, if you
    are lucky the game will crash and you will get a memory access violation error.
    If you are unlucky you will create a bug that will be incredibly difficult to
    find. Furthermore, if we use memory on the free store that will persist beyond
    the life of a function, we must make sure to keep a pointer to it or we will have
    leaked memory.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can declare pointers and point them to newly allocated memory on the
    free store. We can manipulate and access the memory they point to by dereferencing
    them. We can return memory to the free store when we are done with it and we know
    how to avoid having a dangling pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some more advantages of pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Passing a pointer to a function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First we would need to write a function that has a pointer in the signature,
    like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The previous function simply dereferences the pointer and adds one to the value
    stored at the pointed address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use that function and pass the address of a variable or another
    pointer to a variable explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, as shown in the previous code, within the function we are actually manipulating
    the variable from the calling code and can do so using the address of a variable
    or a pointer to that variable.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and using a pointer to an object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pointers are not just for regular variables. We can also declare pointers to
    user-defined types like our classes. This is how we would declare a pointer to
    an object of type `Player`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even access the member functions of a `Player` object directly from
    the pointer, like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We won't need to use pointers to objects in this project and we will explore
    them more carefully before we do, in the next project.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers and arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays and pointers have something in common. An array name is a memory address.
    More specifically the name of an array is the memory address of the first element
    in that array. To put, yet another way, an array name points to the first element
    of an array. The best way to understand this is to read on to see the next example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a pointer to the type that an array holds and then use the pointer
    in exactly the same way using exactly the same syntax that we would the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This also means that a function that has a prototype that accepts a pointer,
    also accepts arrays of the type the pointer is pointing to. We will use this fact
    when we build our ever-increasing horde of zombies.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regarding the relationship between pointers and references, the compiler actually
    uses pointers when implementing our references. This means that references are
    just a handy tool (that uses pointers under the hood). You could think of a reference
    as an automatic gearbox that is fine and convenient for driving around town, whereas
    pointers are a manual gearbox, more complicated but with the correct use, gives
    better results/performance/flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Summary of pointers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pointers are a bit fiddly at times. In fact, our discussion of pointers was
    only an introduction to the subject. The only way to get comfortable with them
    is to use them as much as possible. All you need to understand about pointers
    in order to complete this project is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Pointers are variables that store a memory address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can pass pointers to functions to directly manipulate values from the calling
    function's scope, within the called function. Arrays are the memory address of
    the first element. We can pass this address as a pointer because that is exactly
    what it is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use pointers to point to memory on the free store. This means we can
    dynamically allocate large amounts of memory while the game is running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To further mystify the issue of pointers, C++ got upgraded fairly recently.
    There are now yet more ways to use pointers. We will learn a little about smart
    pointers in the final chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There is just one more topic to cover and we can get coding the Zombie Arena
    project again.
  prefs: []
  type: TYPE_NORMAL
- en: The Standard Template Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The STL is a collection of data containers and ways to manipulate the data we
    put in those containers. Or to be more specific, it is a way to store and manipulate
    different types of C++ variables and classes.
  prefs: []
  type: TYPE_NORMAL
- en: We can think of the different containers as customized and more advanced arrays.
    The STL is part of C++. It is not an optional thing that needs to be set up, such
    as SFML.
  prefs: []
  type: TYPE_NORMAL
- en: The STL is part of C++ because its containers and the code that manipulates
    them is fundamental to many types of code that many apps will need to use.
  prefs: []
  type: TYPE_NORMAL
- en: In short, the STL implements code that we and just about every C++ programmer
    is almost bound to need, at least at some point and probably quite regularly.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to write our own code to contain and manage our data, then it is
    unlikely we would write it as efficiently as the people who wrote the STL.
  prefs: []
  type: TYPE_NORMAL
- en: So by using the STL we guarantee that we are using the best-written code possible
    to manage our data. Even SFML uses the STL. For example, under the hood, the `VertexArray`
    class uses the STL.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is to choose the right type of container from those that
    are available. The types of container that are available through the STL include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vector**: Like an array with boosters. Dynamic resizing, sorting, and searching.
    This is probably the most useful container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**List**: A container that allows the ordering of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Map**: An associative container that allows the user to store data as key/value
    pairs. This is where one piece of data is the key to finding the other piece.
    A Map can also grow and shrink, as well as be searched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set**: A container that guarantees that each and every element is unique.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For a full list of STL container types and explanations, visit the following
    link: [http://www.tutorialspoint.com/cplusplus/cpp_stl_tutorial.htm](http://www.tutorialspoint.com/cplusplus/cpp_stl_tutorial.htm)'
  prefs: []
  type: TYPE_NORMAL
- en: In the Zombie Arena game, we will use a Map.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want a glimpse into the kind of complexity that the STL is sparing us,
    then take a look at this tutorial which implements the kind of thing that a list
    would do. Note that the tutorial implements only the very simplest barebones of
    a list: [http://www.sanfoundry.com/cpp-program-implement-single-linked-list/](http://www.sanfoundry.com/cpp-program-implement-single-linked-list/).'
  prefs: []
  type: TYPE_NORMAL
- en: We can easily see that we will save a lot of time and definitely end up with
    a better game if we explore the STL. Let's take a closer look at how to use Map
    and then we will see how it will be useful to us in the Zombie Arena game.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Map** is a container that is dynamically resizable. We can add and remove
    elements with ease. What makes a Map special compared to the other containers
    in the STL is the way that we access the data within it.
  prefs: []
  type: TYPE_NORMAL
- en: The data in a Map is stored in pairs. Consider the situation where you log in
    to an account, perhaps with a username and password. A Map would be perfect for
    looking up the username and then checking the value of the associated password.
  prefs: []
  type: TYPE_NORMAL
- en: A Map would also be just right for things like account names and numbers or
    perhaps company names and share prices.
  prefs: []
  type: TYPE_NORMAL
- en: Note that when we use Map from the STL, we decide the type of values that form
    the key-value pairs. The values could be data types such as `string` and `int`,
    such as account numbers, strings such as usernames and passwords, or user-defined
    types like objects.
  prefs: []
  type: TYPE_NORMAL
- en: What follows is some real code to make us familiar with Map.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is how we could declare a Map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The previous line of code declares a new `map` called `accounts` that has a
    key of String objects, each of which will refer to a value that is int.
  prefs: []
  type: TYPE_NORMAL
- en: We can now store key-value-pairs of Strings that refer to data type such as
    `int` and we will see how next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding data to a Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go ahead and add a key-value pair to accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now there is an entry in the `map` that can be accessed using the key of John.
    The following code adds two more entries to the accounts `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Our Map has three entries in it. Let's see how we can access the account numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Finding data in a Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We would access the data in exactly the same way that we added it, by using
    the key. As an example, we could assign the value stored by the key `Onkar` to
    a new `int`, `accountNumber`, like this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The int variable `accountNumber` now stores the value `7654321`. We can do anything
    to a value stored in a Map that we can do to that type.
  prefs: []
  type: TYPE_NORMAL
- en: Removing data from a Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Taking values out of our Map is also straightforward. This next line of code
    removes the key, `John`, and its associated value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at a few more things we can do with a Map.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the size of a Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We might like to know how many key-value pairs we have in our Map. This next
    line of code does just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The int variable size now holds the value of two. This is because accounts holds
    values for `Onkar` and Wilson, we deleted John.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for keys in a Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most relevant feature of a Map is the ability to find a value using the
    key. We can test for the presence or otherwise of a specific key like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, the value `!= accounts.end` is used to determine when
    a key doesn't exist or does exist. If the searched for key is not present in the
    Map, then `accounts.end` will be the result of the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Looping/iterating through the key-value pairs of a Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how we can use a `forloop` to loop/iterate through all the values
    of an array. What if we want to do something similar to a Map?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how we could loop through each key-value pair of the
    accounts Map and add one to each of the account numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The condition of the for loop is probably the most interesting part of the previous
    code. The first part of the condition is the longest part. The `map<string,int>::iterator
    it = accounts.begin()` code is more understandable if we break it down.
  prefs: []
  type: TYPE_NORMAL
- en: The `map<string,int>::iterator` code is a type. We are declaring an `iterator`
    suitable for a `map` with key-value pairs of `string` and `int`. The iterators,
    name is `it`. We assign the value returned from `accounts.begin()` to `it`. The
    iterator `it` now holds the first key-value-pair in the accounts `map`.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the condition of the `for` loop works as follows. The code `it !=
    accounts.end()` means the loop will continue until the end of the `map` is reached
    and `it++` simply steps to the next key-value-pair in the `map`, each pass through
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the for loop, `it->second` accesses the second element of the key-value
    pair and `+=1` adds one to the value. Note that we can access the key (which is
    the first part of the key-value pair) with `it->first`.
  prefs: []
  type: TYPE_NORMAL
- en: The auto keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code in the condition of the for loop was quite verbose, especially the
    `map<string,int>::iterator` type. C++ supplies a neat way to reduce verbosity
    with the `auto` keyword. Using the `auto` keyword, we could improve the previous
    code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The auto keyword instructs the compiler to automatically deduce the type for
    us. This will be especially useful with the next class that we write.
  prefs: []
  type: TYPE_NORMAL
- en: STL summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with almost every C++ concept that we have covered in this book, the STL
    is a massive topic. Whole books have been written covering just the STL. At this
    point, however, we know enough to build a class that uses an STL Map to store
    SFML `Texture` objects. We can then have textures that can be retrieved/loaded
    by using the filename as the key of the key-value pair.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why we would go to this extra level of complexity and not just carry
    on using the `Texture` class as we have been so far, will become apparent as we
    proceed.
  prefs: []
  type: TYPE_NORMAL
- en: The TextureHolder Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thousands of zombies represent a new challenge. Not only would loading, storing,
    and manipulating thousands of copies of three different zombie textures take up
    a lot of memory, but also a lot of processing power. We will create a new type
    of class that overcomes this problem and allows us to store just one of each texture.
  prefs: []
  type: TYPE_NORMAL
- en: We will also code the class in such a way that there can only ever be one instance
    of it. This type of class is called a **singleton**.
  prefs: []
  type: TYPE_NORMAL
- en: A singleton is a design pattern, a way to structure our code that is proven
    to work.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we will also code the class so that it can be used anywhere in
    our game code directly through the class name, without access to an instance.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the TextureHolder header file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make the new header file. Right-click **Header Files** in the **Solution Explorer**
    and select **Add** | **New Item...**. In the **Add New Item** window, highlight
    (by left-clicking) **Header File (** `.h` **)** and then in the **Name** field
    type `TextureHolder.h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code that follows into the `TextureHolder.h` file and then we can discuss
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, notice that we have an include directive for `map` from
    the STL. We declare a `map` that holds String and SFML `Texture` key-value pairs.
    The `map` is called `m_Textures`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous code, this line is next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The previous line of code is quite interesting. We are declaring a static pointer
    to an object of type `TextureHolder` called `m_s_Instance`. This means that the
    `TextureHolder` class has an object that is the same type as itself. Not only
    that, but because it is static, it can be used through the class itself, without
    an instance of the class. When we code the related `.cpp` file we will see how
    we use this.
  prefs: []
  type: TYPE_NORMAL
- en: In the `public` part of the class we have the prototype for the constructor
    function, `TextureHolder`. The constructor takes no arguments and, as usual, has
    no return type. This is the same as the default constructor. We are going to override
    the default constructor with a definition that makes our singleton work how we
    want it to.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have another function called `GetTexture`. Let''s look at the signature
    again and analyze exactly what is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: First, notice that the function returns a reference to a `Texture`. This means
    that `GetTexture` will return a reference, which is efficient because it avoids
    making a copy of what could be a fairly large graphic. Also notice the function
    is declared as `static`. This means the function can be used without an instance
    of the class. The function takes a `String` as a constant reference, as a parameter.
    The effect of this is twofold. Firstly, the operation is efficient and secondly,
    because the reference is constant, it can't be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the TextureHolder function definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we can create a new `.cpp` file that will contain the function definition.
    This will enable us to see the reasons behind our new types of functions and variables.
    Right-click **Source Files** in the **Solution Explorer** and select **Add | New
    Item...**. In the **Add New Item** window, highlight (by left-clicking), **C++
    File** ( **`.cpp`** ) and then in the **Name** field type `TextureHolder.cpp`.
    Finally, click the **Add** button. We are now ready to code the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code and then we can discuss it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we initialize our pointer to type `TextureHolder` to `nullptr`.
    In the constructor, the code `assert(m_s_Instance == nullptr)` ensures that `m_s_Instance`
    equals `nullptr`. If it doesn't, the game will exit execution. Then the code `m_s_Instance
    = this` assigns the pointer to this instance. Now consider where this code is
    taking place. The code is in the constructor. The constructor is the way that
    we create instances of objects from classes. So effectively we now have a pointer
    to a `TextureHolder` that points to the one and only instance of itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the final part of the code to the `TextureHolder.cpp` file. There are more
    comments than code next. Examine the code and read the comments as you add the
    code and then we can go through it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The first thing you will probably notice about the previous code is the `auto`
    keyword. The `auto` keyword was explained in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to know what the actual types that have been replaced by `auto`
    are, then take a look at the comments immediately after each use of `auto` in
    the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: At the start of the code we get a reference to `m_textures`. Then we attempt
    to get an iterator to the key-value pair represented by the passed-in filename
    (`filename`). If we find a matching key, we return the texture with `return keyValuePair->second`.
    Otherwise we add the texture to the `map` and then return it to the calling code.
  prefs: []
  type: TYPE_NORMAL
- en: Admittedly, the `TextureHolder` class introduced lots of new concepts (singletons,
    `static` functions, constant references, `this`, and the `auto` keyword) and syntax.
    Add to this the fact that we have only just learned about pointers and the STL,
    and this section's code might have been a little daunting.
  prefs: []
  type: TYPE_NORMAL
- en: What exactly have we achieved with TextureHolder?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The point is that now we have this class, we can go wild using textures wherever
    we like in our code and not worry about running out of memory or having access
    to a particular texture in a particular function or class. We will see how to
    use `TextureHolder` really soon.
  prefs: []
  type: TYPE_NORMAL
- en: Building a horde of zombies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are armed with the `TextureHolder` class to make sure that our zombie
    textures are easily available, as well as only loaded into the GPU once, we can
    look into creating a whole horde of them.
  prefs: []
  type: TYPE_NORMAL
- en: We will store zombies in an array and as the process of building and spawning
    a horde of zombies involves quite a few lines of code, it is a good candidate
    for abstracting to a separate function. Soon we will code the `CreateHorde` function
    but first, of course, we need a `Zombie` class.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Zombie.h file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step to building a class to represent a zombie is to code the member
    variables and function prototypes in a header file.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click **Header Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking) **Header
    File (`.h`)** and then in the **Name** field type `Zombie.h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code into the `Zombie.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The previous code declares all the private member variables of the `Zombie`
    class. At the top of the previous code, we have three constant variables to hold
    the speeds of each type of zombie. A very slow **Crawler**, a slightly faster
    **Bloater**, and a somewhat speedy **Chaser**. We can experiment with the value
    of these three constants to help balance the difficulty level of the game. Also
    worth mentioning here is that these three values are only used as a starting value
    for the speed of each zombie type. As we will see later in this chapter, we will
    vary the speed of every zombie by a small percentage from these values. This stops
    zombies of the same type from bunching up together as they pursue the player.
  prefs: []
  type: TYPE_NORMAL
- en: The next three constants, determine the health level for each zombie type. Note
    that Bloaters are the toughest followed by Crawlers. As a matter of balance, the
    Chaser zombies will be the easiest to kill.
  prefs: []
  type: TYPE_NORMAL
- en: Next we have two more constants `MAX_VARIANCE` and `OFFSET;` these will help
    us determine the individual speed of each zombie. We will see exactly how when
    we code the `Zombie.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'After these constants we declare a bunch of variables that should look familiar
    because we had very similar variables in our `Player` class. The `m_Position`,
    `m_Sprite`, `m_Speed`, and `m_Health` variables are for what their names imply:
    the position, sprite, speed, and health of the zombie object.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the previous code, we declare a `Boolean` `m_Alive` which will be
    `true` when the zombie is alive and hunting but `false` when its health gets to
    zero and it is just a splurge of blood on our otherwise pretty background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to complete the `Zombie.h` file. Add the function prototypes highlighted
    below and then we will talk about them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, there is a `hit` function which we can call every time
    the zombie is hit by a bullet. The function can then take the necessary steps,
    such as taking health from the zombie (reducing the value of `m_Health`) or killing
    it dead (setting `m_Alive` to false).
  prefs: []
  type: TYPE_NORMAL
- en: The `isAlive` function returns a `Boolean`, which lets the calling code know
    whether the zombie is alive or dead. We don't want to perform collision detection
    or remove health from the player for walking over a blood splat.
  prefs: []
  type: TYPE_NORMAL
- en: The `spawn` function takes a starting position, a type (Crawler, Bloater, or
    Chaser, represented by an int), as well as a seed to use in some random number
    generation that we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Just as we have in the `Player` class, the `Zombie` class has `getPosition`
    and `getSprite` functions to get a rectangle that represents the space occupied
    by the zombie and the sprite that can be drawn each frame.
  prefs: []
  type: TYPE_NORMAL
- en: The last prototype in the previous code is the `update` method. We could probably
    have guessed that it would receive the elapsed time since the last frame but also
    notice that it receives a `Vector2f` called `playerLocation`. This vector will
    indeed be the exact coordinates of the center of the player. We will see soon
    how we use this vector to chase after the player.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Zombie.cpp file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next we will code the actual functionality of the Zombie class, the function
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `.cpp` file that will contain the function definitions. Right-click
    **Source Files** in the **Solution Explorer** and select **Add | New Item...**.
    In the **Add New Item** window, highlight (by left-clicking) **C++ File** ( **`.cpp`**
    ) and then in the **Name** field type `Zombie.cpp`. Finally, click the **Add**
    button. We are now ready to code the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `Zombie.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: First we add the necessary include directives and then the line `using namespace
    std`. You might remember a few instances when we have prefixed our object declarations
    with `std::`. This `using` directive means we don't need to do that for the code
    in this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code, which is the definition of the `spawn` function.
    Study the code once you have added it and then we will go through it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The first thing the function does is `switch` based on the `int` type which
    is passed in as a parameter. Within the `switch`, block there is a case for each
    zombie type. Depending upon the type and the appropriate texture, speed and health
    are initialized to the relevant member variables.
  prefs: []
  type: TYPE_NORMAL
- en: Of interest here is that we use the static `TextureHolder::GetTexture` function
    to assign the texture. This means that no matter how many zombies we spawn, there
    will be a maximum of three textures in the memory of the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next three lines of code (excluding comments) do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Seed the random number generator with the `seed` variable that was passed in
    as a parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare and initialize the `modifier` float variable using the `rand` function
    and the `MAX_VARIANCE` and `OFFSET` constants. The result is a fraction between
    zero and one which can be used to make each and every zombie's speed unique. The
    reason we want to do this is so that the zombies don't bunch up on top of each
    other too much.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can now multiply `m_Speed` by `modifier` and we have a zombie whose speed
    is within `MAX_VARRIANCE` percent of the constant defined for this particular
    type of zombie's speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After we have resolved the speed, we assign the passed in position held in `startX`
    and `startY` to `m_Position.x` and `m_Position.y` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The last two lines of code in the previous listing set the origin of the sprite
    to the center and use the `m_Position` vector to set the position of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add this code for the `hit` function to the `Zombie.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `hit` function is nice and simple. Reduce `m_Health` by one then check whether
    `m_Health` is below zero.
  prefs: []
  type: TYPE_NORMAL
- en: If it is below zero, set `m_Alive` to false, swap the zombie's texture for a
    blood splat, and return `true` to the calling code, so it knows the zombie is
    now dead.
  prefs: []
  type: TYPE_NORMAL
- en: If the zombie has survived the hit, return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the next three getter functions, which just return a value to the calling
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The previous three functions are quite self-explanatory, perhaps with the exception
    that the `getPosition` function uses the `m_Sprite.getLocalBounds` function to
    get the `FloatRect`, which is returned to the calling code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, for the `Zombie` class, add the code for the `update` function; look
    closely at the code and then we will go through it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: First we copy `playerLocation.x` and `playerLocation.y` into the local variables
    `playerX` and `playerY`.
  prefs: []
  type: TYPE_NORMAL
- en: Next there are four `if` statements. They test to see whether the zombie is
    to the left, right, above, or below the current player's position. These four
    `if` statements, when they evaluate to `true`, adjust the zombie's `m_Position.x`
    and `m_Position.y` values appropriately using the usual formula, `speed * time`
    since last frame. More specifically, the code is `m_Speed * elapsedTime`.
  prefs: []
  type: TYPE_NORMAL
- en: After the four `if` statements, `m_Sprite` is moved to its new location.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the same calculation we previously used with the player and the
    mouse pointer; this time, however, we do so for the zombie and the player. This
    calculation finds the angle needed to face the zombie toward the player.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call `m_Sprite.setRotation` to actually rotate the zombie sprite.
    Remember that this function will be called for every zombie (that is alive) on
    every frame of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Zombie class to create a horde
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we have a class to create a living, attacking, and killable zombie, we want
    to spawn a whole horde of them.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we will write a separate function and we will use a pointer
    so that we can refer to our horde that will be declared in `main` but configured
    in a different scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ZombieArena.h` file in Visual Studio and add the highlighted lines
    of code shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a prototype, we can code the function definition.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `.cpp` file that will contain the function definition. Right-click
    **Source Files** in the **Solution Explorer** and select **Add | New Item...**.
    In the **Add New Item** window, highlight (by left-clicking) **C++ File** (`.cpp`)
    and then in the **Name** field type `CreateHorde.cpp`. Finally, click the **Add**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add and study the code shown next into the `CreateHorde.cpp` file. Afterwards,
    we will break it down into chunks and discuss it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at all the previous code again, in bite-size pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we add the now familiar include directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Next comes the function signature. Notice that the function must return a pointer
    to a `Zombie` object. We will be creating an array of `Zombie` objects. Once we
    are done creating the horde, we will return the array. When we return the array,
    we are actually returning the address of the first element of the array. This,
    as we learned in the section earlier in this chapter, is the same thing as a pointer.
    The signature also shows that we have two parameters. The first, `numZombies`,
    will be the number of zombies this current horde requires and the second, arena,
    is an `IntRect` that holds the size of the current arena in which to create this
    horde.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the function signature, we declare a pointer to type `Zombie` called
    `zombies` and initialize with the memory address of the first element of an array,
    which we dynamically allocate on the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The next code simply copies the extremities of the arena into `maxY`, `minY`,
    `maxX`, and `minX`. We subtract twenty pixels from the right and bottom while
    adding twenty pixels to the top and left. We use these four local variables to
    help position each of the zombies. We made the twenty-pixel adjustments to stop
    the zombies appearing on top of the walls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we enter a `for` loop that will loop through each of the `Zombie` objects
    in the zombies array from zero through to `numZombies`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `for` loop, the first thing the code does is seed the random number
    generator and then generate a random number between zero and three. This number
    is stored in the `side` variable. We will use the `side` variable to decide whether
    the zombie spawns at the left, top, right, or bottom of the arena. We also declare
    two `int` variables, `x` and `y`. These two variables will temporarily hold the
    actual horizontal and vertical coordinates of the current zombie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Still inside the `for` loop we have a `switch` block with four `case` statements.
    Notice the `case` statements are for 0, 1, 2, and 3 and the argument in the switch
    statement is side. Inside each of the case blocks, we initialize x and y with
    one predetermined value, either minX, maxX, minY, or maxY, and one randomly generated
    value. Look closely at the combinations of each predetermined and random value.
    You will see that they are appropriate for positioning the current zombie randomly
    across either the left side, top side, right side, or bottom side. The effect
    of this will be that each zombie can spawn randomly, anywhere on the outside edge
    of the arena:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Still inside the `for` loop, we seed the random number generator again and generate
    a random number between 0 and 2\. We store this number in the type variable. The
    type variable will determine whether the current zombie will be a Chaser, Bloater,
    or Crawler.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the type is determined, we call the `spawn` function on the current `Zombie`
    object in the `zombies` array. As a reminder, the arguments sent into the `spawn`
    function determine the starting location of the zombie and the type of zombie
    it will be. The apparently arbitrary `i` is passed in as it is used as a unique
    seed that randomly varies the speed of a zombie within an appropriate range. This
    stops our zombies **bunching up** and becoming a blob rather than a horde:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for` loop repeats itself once for each zombie contained in `numZombies`
    and then we return the array. The array, as another reminder, is simply an address
    of the first element of itself. The array is dynamically allocated on the heap
    so it persists after the function returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now we can bring our zombies to life.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing the horde to life (back to life)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have a `Zombie` class and a function to make a randomly spawning horde of
    them. We have the `TextureHolder` singleton as a neat way to hold just three textures
    that can be used for dozens, even thousands, of zombies. Now we can add the horde
    to our game engine in `main`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted code to include the `TextureHolder` class. Then,
    just inside `main`, we initialize the one and only instance of `TextureHolder`
    that can be used from anywhere within our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The next few lines of highlighted code declare some control variables for the
    number of zombies at the start of the wave, the number of zombies still to be
    killed, and, of course, a pointer to `Zombie` called `zombies` which we initialize
    to `nullptr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the `PLAYING` section nested inside the `LEVELING_UP` section, we
    add code that does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Initializes `numZombies` to `10`. As the project progresses this will eventually
    be dynamic and based on the current wave number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deletes any pre-existing allocated memory, otherwise each new call to `createHorde`
    would take up progressively more memory but without freeing the previous horde's
    memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then calls `createHorde` and assigns the returned memory address to `zombies`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializes `zombiesAlive` with `numZombies` because we haven't killed any at
    this point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the highlighted code we have just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add the following highlighted code to the `ZombieArena.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: All that the new code does is loop through the array of zombies, check the current
    zombie is alive, and if it is, calls its `update` function with the necessary
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to draw all the zombies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The previous code loops through all the zombies and calls the `getSprite` function
    to allow the `draw` method to do its work. We don't check whether the zombie is
    alive because even if the zombie is dead we want to draw the blood splatter.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the main function, we make sure to delete our pointer, although
    technically this isn''t essential because the game is about to exit and the operating
    system will reclaim all the memory used after the `return 0` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: You can run the game and see the zombies spawn around the edge of the arena.
    They will immediately head straight toward the player at their various speeds.
    Just for fun I increased the size of the arena and increased the number of zombies
    to 1000.
  prefs: []
  type: TYPE_NORMAL
- en: '![Bringing the horde to life (back to life)](img/image_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is going to end badly!
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that you can also pause and resume the onslaught of the horde using
    the **Enter** key because of the code we wrote in [Chapter 6](ch06.html "Chapter 6. 
    Object-Oriented Programming, Classes, and SFML Views"): *Object-Oriented Programming,
    Classes, and SFML Views*.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the TextureHolder class for all textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have our `TextureHolder` class, we might as well be consistent and
    use it to load all our textures. Let's make some very small alterations to the
    existing code that loads textures for the background sprite sheet and the player.
  prefs: []
  type: TYPE_NORMAL
- en: Change the way the background gets its textures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `ZombieArena.cpp` file, find this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the code highlighted previously and replace it with the following highlighted
    code, which uses our new `TextureHolder` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Change the way Player gets its texture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Player.cpp` file, inside the constructor, find this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the code highlighted previously and replace it with this code, which
    uses our new `TextureHolder` class. In addition, add the include directive to
    add the `TextureHolder` header to the file. The new code is shown highlighted,
    in context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: From now on we will use the `TextureHolder` class for loading all textures.
  prefs: []
  type: TYPE_NORMAL
- en: FAQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some questions that might be on your mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Q) What's the difference between pointers and references?
  prefs: []
  type: TYPE_NORMAL
- en: A) Pointers are like references with boosters. Pointers can be changed to point
    to different variables (memory addresses), as well as point to dynamically allocated
    memory on the free store.
  prefs: []
  type: TYPE_NORMAL
- en: Q) What's the deal with arrays and pointers?
  prefs: []
  type: TYPE_NORMAL
- en: A) Arrays are really constant pointers to their first element.
  prefs: []
  type: TYPE_NORMAL
- en: Q) Can you remind me about the `new` keyword and memory leaks?
  prefs: []
  type: TYPE_NORMAL
- en: A) When we use memory on the free store using the `new` keyword, it persists
    even when the function it was created in has returned and all the local variables
    are gone. When we are done with using memory on the free store we must release
    it. So if we use memory on the free store, that we want to persist, beyond the
    life of a function, we must make sure to keep a pointer to it or we will have
    leaked memory. It would be like putting all our belongings in our house and then
    forgetting where we live! When we return the zombies array from `createHorde`,
    it is like passing the relay baton (memory address) from `createHorde` to `main`.
    It's like saying OK, here is your horde of zombies - they are your responsibility
    now. We wouldn't want any leaked zombies running around in our RAM so we must
    remember to call `delete` on pointers to dynamically allocated memory.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed that the zombies don't appear to be very dangerous. They
    just drift through the player without leaving a scratch. At the moment this is
    a good thing because the player has no way to defend himself.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will make two more classes. One will be for ammo and
    health pickups, and one for bullets that the player can shoot. After we have done
    that, we will learn how to detect collisions, so that the bullets and zombies
    do some damage and the pickups can be collected by the player.
  prefs: []
  type: TYPE_NORMAL

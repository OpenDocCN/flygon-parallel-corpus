- en: Chapter 9. Collision Detection, Pickups, and Bullets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have implemented the main visual aspects of our game. We have a controllable
    character running around in an arena full of zombies that chase him. The problem
    is that they don't interact with each other. A zombie can wander right through
    the player without leaving a scratch. We need to detect collisions between the
    zombies and the player.
  prefs: []
  type: TYPE_NORMAL
- en: If the zombies are going to be able to injure and eventually kill the player,
    it is only fair that we give the player some bullets for his gun. We will then
    need to make sure that the bullets can hit and kill the zombies.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, if we are writing collision detection code for bullets, zombies,
    and the player, it would be a good time to add a class for health and ammo pickups
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we will do and the order we will cover the topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Shooting bullets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a crosshair and hiding the mouse pointer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawning pickups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting collisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding the Bullet class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the SFML `RectangleShape` class to visually represent a bullet.
    We will code a `Bullet` class that has a `RectangleShape` member as well as other
    member data and functions. We will add bullets to our game in a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First we will code the `Bullet.h` file. This will reveal all the details of
    the member data and the prototypes for the functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next we will code the `Bullet.cpp` file which, of course, will contain the definitions
    for all the functions of the `Bullet` class. As we step through it, I will explain
    exactly how an object of type `Bullet` will work and be controlled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will declare a whole array full of bullets in the `main` function.
    We will also implement a control scheme for shooting, managing the player's remaining
    ammo, and reloading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's get started with step 1.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Bullet header file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the new header file, **right-click on Header Files** in the **Solution
    Explorer** and select **Add | New Item...**. In the **Add New Item** window, highlight
    (by left-clicking) **Header File (** `.h` **)** and then in the **Name** field
    type `Bullet.h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following private member variables along with the `Bullet` class declaration
    to the `Bullet.h` file. We can then run through and explain what they are for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, the first member is a `Vector2f` called `m_Position`,
    which will hold the bullets location in the game-world.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare a `RectangleShape` called `m_BulletShape` as we are using a
    simple non-texture graphic for each bullet, a bit like we did for the time-bar
    in Timber!!!
  prefs: []
  type: TYPE_NORMAL
- en: The code then declares a `Boolean m_InFlight`, which will keep track of whether
    the bullet is currently whizzing through the air, or not. This will enable us
    to decide whether we need to call its `update` function each frame and whether
    or not we need to run collision detection checks.
  prefs: []
  type: TYPE_NORMAL
- en: The `float` variable `m_BulletSpeed` will (you can probably guess) hold the
    speed in pixels per second that the bullet will travel at. It is initialized to
    the value of `1000`, which is a little arbitrary—but it works well.
  prefs: []
  type: TYPE_NORMAL
- en: Next we have two more `float` variables, `m_BulletDistanceX` and `m_BulletDistanceY`.
    As the calculations to move a bullet are a little more complex than those used
    to move a zombie or the player, we will benefit from having these two variables
    that we will perform calculations on. They will be used to decide the horizontal
    and vertical change in the bullets position in each frame.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for the previous code, we have four more `float` variables (`m_MaxX`,
    `m_MinX`, `m_MaxY`, and `m_MinY`) which will later be initialized to hold the
    maximum and minimum, horizontal and vertical positions for the bullet.
  prefs: []
  type: TYPE_NORMAL
- en: It is likely that the need for some of these variables is not immediately apparent,
    but it will become clearer when we see each of them in action in the `Bullet.cpp`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add all the public function prototypes to the `Bullet.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's run through each of the functions in turn, then we can move on to coding
    their definitions.
  prefs: []
  type: TYPE_NORMAL
- en: First we have the `Bullet` function, which is of course the constructor. In
    this function, we will set up each `Bullet` instance ready for action.
  prefs: []
  type: TYPE_NORMAL
- en: The `stop` function will be called when the bullet has been in action but needs
    to stop.
  prefs: []
  type: TYPE_NORMAL
- en: The `isInFlight` function returns a `Boolean` and will be used to test whether a
    bullet is currently in flight or not.
  prefs: []
  type: TYPE_NORMAL
- en: The `shoot` function's use is given away by its name, but how it will work deserves
    some discussion. For now, just note that it has four `float` parameters that will
    be passed in. The four values represent the starting (where the player is) horizontal
    and vertical position of the bullet, as well as the vertical and horizontal target
    position (where the crosshair is).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getPosition` function returns a `FloatRect` that represents the location
    of the bullet. This function will be used to detect collisions with zombies. You
    might remember from [Chapter 8](ch08.html "Chapter 8. Pointers, the Standard Template
    Library, and Texture Management"): *Pointers, Standard Template Library, and Texture
    Management* that zombies also had a `getPosition` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Next we have the `getShape` function, which returns an object of type `RectangleShape`.
    As we have discussed, each bullet is represented visually by a `RectangleShape`
    object. The `getShape` function, therefore, will be used to grab a copy of the
    current state of the `RectangleShape`, in order to draw it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, and hopefully as expected, there is the `update`, function which has
    a `float` parameter that represents the fraction of one second that has passed
    since the last time `update` was called. The `update` method will change the position
    of the bullet each frame.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at and code the function definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Bullet source file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we can create a new `.cpp` file that will contain the function definitions.
    Right-click **Source Files** in the **Solution Explorer** and select **Add | New
    Item...**. In the **Add New Item** window, highlight (by left-clicking) **C++
    File** (`.cpp`) and then in the **Name** field type `Bullet.cpp`. Finally, click
    the **Add** button. We are now ready to code the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code, which is the include directives and the constructor.
    We know it is the constructor because the function has the same name as the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The only thing that the `Bullet` constructor needs to do is set the size of
    `m_BulletShape`, which is the `RectangleShape` object. The code sets the size
    to two pixels by two pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we have the more substantial `shoot` function. Add the following code
    to the `Bullet.cpp` file, study it, and then we can talk about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In order to demystify the shoot function, we will split it up and talk about
    the code we have just added, in chunks.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let''s remind ourselves about the signature. The shoot function receives
    the starting and target horizontal and vertical positions of a bullet. The calling
    code will supply these based on the position of the player sprite and the position
    of the crosshair. Here it is again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the shoot function, we set `m_InFlight` to `true` and position the bullet
    using the parameters `startX` and `startY`. Here is that piece of code again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now we use a bit of simple trigonometry to determine the gradient of travel
    for a bullet. The progression horizontally and vertically of a bullet must vary
    based on the slope of the line created by drawing between the start and target
    of a bullet. The rate of change cannot be the same or very steep shots will arrive
    at the horizontal location before the vertical location, and vice versa for shallow
    shots.
  prefs: []
  type: TYPE_NORMAL
- en: The following code first derives the gradient based on the equation of a line.
    Then it checks whether the gradient is less than zero and if it is, multiplies
    it by `-1`. This is because the start and target coordinates passed in can be
    negative or positive and we always want the amount of progression each frame to
    be positive. Multiplying by `-1` simply makes the negative number into its positive
    equivalent, because a minus multiplied by a minus gives a positive. The actual
    direction of travel will be handled in the `update` function by adding or subtracting
    the positive values we arrive at in this function.
  prefs: []
  type: TYPE_NORMAL
- en: Next we calculate a ratio of horizontal to vertical distance by dividing our
    bullet's speed (`m_BulletSpeed`) by one plus the gradient. This will allow us
    to change the bullet's horizontal and vertical position by the correct amount
    each frame, based on the target the bullet is heading toward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in this part of the code we assign the values to `m_BulletDistanceY`
    and `m_BulletDistanceX`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is much more straightforward. We simply set a maximum horizontal
    and vertical location that the bullet can reach. We don''t want a bullet carrying
    on forever. We will see this in the `update` function where we test to see whether
    a bullet has passed its maximum or minimum locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code moves the **RectangleShape** which represents the bullet
    to its starting location. We use the `setPosition` function as we have often done
    before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we have four straightforward functions. Add the `stop`, `isInFlight`,
    `getPosition`, and `getShape` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `stop` function simply sets the `m_InFlight` variable to `false`. The `isInFlight`
    function returns whatever the value of this same variable currently is. So we
    can see that `shoot` sets the bullet going, `stop` makes it stop, and `isInFlight`
    let us know what the current state is.
  prefs: []
  type: TYPE_NORMAL
- en: The `getPosition` function returns a `FloatRect` and we will see how we use
    the `FloatRect` from each game object to detect collisions, soon.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for the previous code, `getShape` returns a `RectangleShape` so we
    can draw the bullet once each frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last function we need to implement before we can start using `Bullet` objects
    is `update`. Add the following code, study it, and then we can talk about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the `update` function, we use `m_BulletDistanceX` and `m_BulletDistanceY`
    multiplied by the time since the last frame to move the bullet. Remember that
    the values of the two variables were calculated in the `shoot` function and represent
    the gradient (ratio to each other) required to move the bullet at just the right
    angle. Then we use the `setPosition` function to actually move the `RectangleShape`.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we do in `update` is test to see whether the bullet has moved
    beyond its maximum range. The slightly convoluted `if` statement checks `m_Position.x`
    and `m_Position.y` against the maximum and minimum values that were calculated
    in the `shoot` function. These maximum and minimum values are stored in `m_MinX`,
    `m_MaxX`, `m_MinY`, and `m_MaxY`. If the test is true, then `m_InFlight` is set
    to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Bullet` class is done. Now we can see how to shoot some in the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: Making the bullets fly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will make the bullets usable with the following six steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the necessary include directive for the `Bullet` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add some control variables and an array to hold some `Bullet` instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle the player pressing *R* to reload.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle the player pressing the left mouse button to fire a bullet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update all bullets that are in flight, in each frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the bullets that are in flight, in each frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Including the Bullet class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the include directive to make the Bullet class available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let's move on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Control variables and the bullet array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are some variables to keep track of bullets, clip sizes, bullets spare/remaining,
    bullets in the clip, the current rate of fire (starting at one per second), and
    the time when the last bullet was fired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted code and we can move on to seeing all these variables in
    action in the rest of this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's handle what happens when the player presses the ***R*** keyboard
    key, which is used for reloading a clip.
  prefs: []
  type: TYPE_NORMAL
- en: Reloading the gun
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we handle the player input related to shooting bullets. First we will handle
    pressing the ***R*** key to reload the gun. We do so with an SFML event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code shown highlighted in the following code block. It is shown with
    lots of context to make sure the code goes in the right place. Study the code
    and then we can talk about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is nested within the event handling part of the game loop
    (`while(window.pollEvent)`), within the block that only executes when the game
    is actually being played (`if(state == State::Playing)`). It is obvious that we
    don't want the player reloading when the game has finished or is paused and wrapping
    the new code as described achieves this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the new code itself, the first thing we do is test for the **R** key being
    pressed, with `if (event.key.code == Keyboard::R)`. Once we have detected that
    the **R** key was pressed the remaining code is executed. Here is the structure
    of the `if`, `else if`, and `else` blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The previous structure allows us to handle three possible scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: The player has pressed `R` and they have more bullets spare than the clip can
    take. In this scenario, the clip is refilled and the number of spare bullets is
    reduced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player has some spare bullets but not enough to fill the clip completely.
    In this scenario, the clip is filled with as many spare bullets as the player
    has and the number of spare bullets is set to zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The player has pressed R but they have no spare bullets at all. For this scenario,
    we don''t actually need to alter the variables. However, we will play a sound
    effect here when we implement our sound in [C](ch11.html "Chapter 11. Sound Effects,
    File I/O, and Finishing the Game")[hapter 11](ch11.html "Chapter 11. Sound Effects,
    File I/O, and Finishing the Game"): *Sound Effects, File I/O, and Finishing the
    Game*,so we leave the empty `else` block ready.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's actually shoot a bullet at last.
  prefs: []
  type: TYPE_NORMAL
- en: Shooting a bullet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next we can handle the left mouse button being clicked to actually fire a bullet.
    Add the highlighted code and study it carefully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: All of the previous code is wrapped in an `if` statement, which executes whenever
    the left mouse button is pressed, `if (Mouse::isButtonPressed(sf::Mouse::Left))`.
    Note that the code will execute repeatedly, even if the player just holds down
    the button. The code we will go through now controls the rate of fire.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous code, we then check whether the total time elapsed in the game
    (`gameTimeTotal`), minus the time the player last shot a bullet (`lastPressed`),
    is greater than `1000` divided by the current rate of fire, and that the player
    has at least one bullet in the clip. We use `1000` because this is the number
    of milliseconds in a second.
  prefs: []
  type: TYPE_NORMAL
- en: If this test is successful, the code that actually fires a bullet is executed.
    Shooting a bullet is easy because we did all the hard work in the `Bullet` class.
    We simply call `shoot` on the current bullet from the `bullets` array. We pass
    in the player's and crosshair's current horizontal and vertical locations. The
    bullet will be configured and set in flight by the code in the `shoot` function
    of the `Bullet` class.
  prefs: []
  type: TYPE_NORMAL
- en: All we have to do is keep track of the array of bullets. First we increment
    the `currentBullet` variable. Then we check to see whether  we fired the last
    bullet (`99`) with the statement `if (currentBullet > 99)`. If it was the last
    bullet, we set `currentBullet` to zero. If it wasn't the last bullet, then the
    next bullet is ready to go whenever the rate of fire permits it and the player
    presses the left mouse button.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for the previous code, we store the time that the bullet was fired
    in `lastPressed` and decrement `bulletsInClip`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can update every bullet, each frame.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the bullets each frame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the highlighted code to loop through the bullets array, check whether the
    bullet is in flight, and if it is, call its update function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: And lastly, we can draw all the bullets.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the bullets each frame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the highlighted code to loop through the `bullets` array, check whether
    the bullet is in flight and if it is, draw it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Run the game to try out the bullets. Notice you can fire six shots before you
    need to press ***R*** to reload. The obvious things that are missing are some
    visual indicator of the number of bullets in the clip and the number of spare
    bullets. Another problem is that the player can very quickly run out of bullets,
    especially as the bullets have no stopping power whatsoever. They fly straight
    through the zombies. Add to this that the player is expected to aim at a mouse
    pointer instead of a precision crosshair, and it is plain we have work to do.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will give visual feedback through a HUD. We will replace
    the mouse cursor with a crosshair next and then spawn some pickups to replenish
    bullets and health after that. Finally, in this chapter, we will handle collision
    detection to make the bullets and the zombies do damage and make the player able
    to actually get the pickups.
  prefs: []
  type: TYPE_NORMAL
- en: Giving the player a crosshair
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding a crosshair is easy and only requires one new concept. Add the highlighted
    code and then we can run through it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: First we call the `setMouseCursorVisible` function on our `window` object. We
    then load a `Texture`, declare a `Sprite`, and initialize it in the usual way.
    Furthermore, we set the sprite's origin to its center to make it convenient and
    simpler to make the bullets fly to the middle, as you would expect to happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to update the crosshair each frame with the world coordinates of
    the mouse. Add the highlighted line of code, which uses the `mouseWorldPosition`
    vector to set the crosshair position each frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, as you have probably come to expect, we can draw the crosshair for each
    frame. Add the highlighted line of code in the position shown. The line of code
    needs no explanation, but its position after all the other game objects is important
    so it is drawn on top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can run the game and see the cool crosshair instead of a mouse cursor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Giving the player a crosshair](img/image_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice how the bullet fires neatly through the center of the crosshair. The
    way the shooting mechanic works is analogous to allowing the player to choose
    to shoot from the hip or aim down the sights. If the player keeps the crosshair
    close to the center, he can fire and turn rapidly, yet has to carefully judge
    the position of distant zombies.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the player can hover his crosshair directly over the head of
    a distant zombie and score a precise hit; however, he then has much further to
    move the crosshair back if a zombie attacks from another direction.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting improvement to the game would be to add a small random amount
    of inaccuracy to each shot. This inaccuracy could perhaps be mitigated with an
    upgrade between waves.
  prefs: []
  type: TYPE_NORMAL
- en: Coding a class for pickups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will code a `Pickup` class that has a `Sprite`, member as well as other
    member data and functions. We will add pickups to our game in just a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will code the `Pickup.h` file. This will reveal all the details of
    the member data and the prototypes for the functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we will code the `Pickup.cpp` file which, of course, will contain the definitions
    for all the functions of the `Pickup` class. As we step through it, I will explain
    exactly how an object of type `Pickup` will work and be controlled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will use the `Pickup` class in the `main` function to spawn them,
    update them and draw them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's get started with step 1.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Pickup header file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the new header file, **right-click Header Files** in the **Solution
    Explorer** and select **Add | New Item...**. In the **Add New Item** window, highlight
    (by left-clicking) **Header File (** `.h` **)** and then in the **Name** field
    type `Pickup.h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add and study the following code in the `Pickup.h` file and then we can go
    through it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code declares all the private variables of the `Pickup` class.
    Although the names should be quite intuitive, it might not be obvious why many
    of them are needed at all. Let''s go through them, starting from the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const int HEALTH_START_VALUE = 50`: This constant variable is used to set
    the starting value of all health pickups. The value will be used to initialize
    the `m_Value` variable, which will need to be manipulated throughout the course
    of a game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const int AMMO_START_VALUE = 12`: This constant variable is used to set the
    starting value of all ammo pickups. The value will be used to initialize the `m_Value`
    variable, which will need to be manipulated throughout the course of a game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const int START_WAIT_TIME = 10`: This variable is how long a pickup will wait
    before it re-spawns after disappearing. It will be used to initialize the `m_SecondsToWait`
    variable which can be manipulated throughout the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const int START_SECONDS_TO_LIVE = 5`: This variable determines how long a
    pickup will last between spawning and being de-spawned. Like the previous three
    constants, it has a non-constant associated with it that can be manipulated throughout
    the course of the game. The non-constant it is used to initialize is `m_SecondsToLive`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sprite m_Sprite`: This is the sprite to visually represent the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntRect m_Arena`: This will hold the size of the current arena to help the
    pickup spawn in a sensible position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int m_Value`: How much health or ammo is this pickup worth? This value is
    used when the player levels-up the value of the health or ammo pickup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int m_Type`: This will be either zero or one for health or ammo. We could
    have used an enumeration class but that seemed like overkill for just two options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool m_Spawned`: Is the pickup currently spawned?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float m_SecondsSinceSpawn`: How long is it since the pickup was spawned?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float m_SecondsSinceDeSpawn`: How long is it since the pickup was de-spawned
    (disappeared)?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float m_SecondsToLive`: How long should this pickup stay spawned before de-spawning?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float m_SecondsToWait`: How long should this pickup stay de-spawned before
    re-spawning?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that most of the complexity of this class is due to the variable spawn
    time and its upgradeable nature. If the pickups just re-spawned when collected
    and had a fixed value this would be a very simple class. We need our pickups to
    be upgradeable, so the player is forced to develop a strategy to progress through
    the waves of zombies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following public function prototypes to the `Pickup.h` file.
    Be sure to familiarize yourself with the new code so we can go through it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s talk briefly about each of the function definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: The first function is the constructor, named after the class. Note that it takes
    a single `int` parameter. This will be used to initialize the type of pickup it
    will be (health or ammo).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `setArena` function receives an `IntRect`. This function will be called
    for each `Pickup` instance at the start of each wave. The `Pickup` objects will
    then know the areas into which they can spawn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `spawn` function will, of course, handle spawning the pickup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getPosition` function, just like in the `Player`, `Zombie`, and `Bullet` classes
    will return a `FloatRect` that represents the current location of the object in
    the game world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getSprite` function returns a `Sprite` object that enables the pickup to
    be drawn, once each frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `update` function receives the time the previous frame took. It uses this
    value to update its private variables and make decisions about when to spawn and
    de-spawn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `isSpawned` function returns a Boolean that will let the calling code know
    whether or nor the pickup is currently spawned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `gotIt` function will be called when a collision is detected with the player.
    The `Pickup` class code can then prepare itself for re-spawning at the appropriate
    time. Note that it returns an `int` so that the calling code knows how much the
    pickup is worth in either health or ammo.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `upgrade` function will be called when the player chooses to levelup the
    properties of a pickup during the levelingup phase of the game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we have gone through the member variables and function prototypes, it should
    be quite easy to follow along as we code the function definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Pickup class function definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we can create a new `.cpp` file that will contain the function definitions.
    Right-click **Source Files** in the **Solution Explorer** and select **Add | New
    Item...**. In the **Add New Item** window, highlight (by left-clicking) **C++
    File (** `.cpp` **)** and then in the **Name** field type `Pickup.cpp`. Finally,
    click the **Add** button. We are now ready to code the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code shown here to the `Pickup.cpp` file. Be sure to review the code
    so we can discuss it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we added the familiar include directives. Then we added
    the `Pickup` constructor. We know it is the constructor because it has the same
    name as the class.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor receives an `int` called `type` and the first thing the code
    does is assign the value received from `type` to `m_Type`. After this, there is
    an `if…else` block that checks whether `m_Type` is equal to `1`. If it is, `m_Sprite`
    is associated with the health pickup texture and `m_Value` is set to `HEALTH_START_VALUE`.
  prefs: []
  type: TYPE_NORMAL
- en: If `m_Type` is not equal to `1`, the `else` block associates the ammo pickup
    texture with `m_Sprite` and assigns the value of `AMMO_START_VALUE` to `m_Value`.
  prefs: []
  type: TYPE_NORMAL
- en: After the `if…else` block, the code sets the origin of `m_Sprite` to the center
    using the `setOrigin` function and assigns `START_SECONDS_TO_LIVE` and `START_WAIT_TIME`
    to `m_SecondsToLive` and `m_SecondsToWait`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor has successfully prepared a `Pickup` object that is ready for
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we will add the `setArena` function. Examine the code as you add it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `setArena` function that we just coded simply copies the values from the
    passed in `arena`, object but varies the values by plus fifty on the left and
    top and minus fifty on the right and bottom. The Pickup object is now aware of
    the area in which it can spawn. The `setArena` function then calls its own `spawn`
    function to make the final preparations for being drawn and updated each frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `spawn` function is next. Add the following code after the `setArena` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `spawn` function does everything necessary to prepare the pickup. First
    it seeds the random number generator and gets a random number for both the horizontal
    and vertical position of the object. Notice that it uses `m_Arena.width` and `m_Arena.height`
    as the ranges for the possible horizontal and vertical positions.
  prefs: []
  type: TYPE_NORMAL
- en: The `m_SecondsSinceSpawn` is set to zero so the length of time allowed before
    it is de-spawned is reset. The `m_Spawned` variable is set to `true` so that when
    we call `isSpawned`, from `main`, we will get a positive response. Finally, `m_Sprite`
    is moved into position with `setPosition`, ready for drawing to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In the following block of code, we have three simple getter functions. The `getPosition`
    function returns a `FloatRect` of the current position of `m_Sprite`, `getSprite`
    returns a copy of `m_Sprite` itself, and `isSpawned` returns `true` or `false`
    depending upon whether the object is currently spawned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add and examine the code we have just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we will code the `gotIt` function. This function will be called from `main`
    when the player touches/collides with (gets) the pickup. Add the `gotIt` function
    after the `isSpawned` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `gotIt` function sets `m_Spawned` to `false` so we know not to draw and
    check for collisions at the moment. The `m_SecondsSinceDespawn` is set to zero
    so the countdown to spawning begins again from the start and `m_Value` is returned
    to the calling code so the calling code can handle adding extra ammunition or
    health, as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we have the `update` function, which ties together many of the variables
    and functions we have seen so far. Add and familiarize yourself with the `update`
    function and then we can talk about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The update function is divided into four blocks that are considered for execution
    each frame:'
  prefs: []
  type: TYPE_NORMAL
- en: An `if` block that executes if `m_Spawned` is true—`if (m_Spawned)`. This block
    of code adds the time of this frame to `m_SecondsSinceSpawned`, which keeps track
    of how long the pickup has been spawned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A corresponding `else` block that executes if `m_Spawned` is `false`. This block
    adds the time this frame took to `m_SecondsSinceDeSpawn`, which keeps track of
    how long the pickup has waited since it was last de-spawned (hidden).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another `if` block that executes when the pickup has been spawned for longer
    than it should have been—`if (m_SecondsSinceSpawn > m_SecondsToLive && m_Spawned)`.
    This block sets `m_Spawned` to `false` and resets `m_SecondsSinceDeSpawn` to zero.
    Now block 2 will execute until it is time to spawn again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A final `if` block that executes when the time to wait since de-spawning has
    exceeded the necessary wait time, and the pickup is not currently spawned—`if
    (m_SecondsSinceDeSpawn > m_SecondsToWait && !m_Spawned)`. When this block is executed,
    it is time to spawn again and the spawn function is called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These four tests and code are what controls the hiding and showing of a pickup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the definition for the `upgrade` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `upgrade` function tests for the type of pickup, either health or ammo,
    and then adds 50 percent of the (appropriate) starting value on to `m_Value`.
    The next two lines after the `if…else` blocks increase the amount of time the
    pickup will remain spawned and decrease the amount of time the player has to wait
    between spawns.
  prefs: []
  type: TYPE_NORMAL
- en: This function is called when the player chooses to levelup the pickups during
    the `LEVELING_UP` state. Our `Pickup` class is ready for use.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Pickup class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After all that hard work implementing the `Pickup` class, we can now go ahead
    and write code in the game engine to actually put some pickups into the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we do is add an include directive to the `ZombieArena.cpp`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, we add two `Pickup` instances, one called `healthPickup`
    and the other called `ammoPickup`. We pass the values `1` and `2` respectively
    into the constructor so that they are initialized to the correct type of pickup.
    Add the highlighted code we have just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `LEVELING_UP` state of the keyboard handling, add the highlighted lines
    within the nested `PLAYING` code block shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The previous code simply passes `arena` into the `setArena` function of each
    pickup. The pickups now know where they can spawn. This code executes for each
    new wave, so as the arena size grows, the `Pickup` objects will get updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code simply calls the `update` function for each `Pickup` object,
    on each frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code in the draw part of the game loop, checks if the pickup
    is currently spawned and if it is, draws it. Add the highlighted code we have
    just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now you can run the game and see the pickups spawn and de-spawn. You can't,
    however, actually pick them up yet.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Pickup class](img/image_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have all the objects in our game, it is a good time to make them
    interact (collide) with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting collisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We just need to know when certain objects from our game touch certain other
    objects. We can then respond to that event in an appropriate manner. In our classes,
    we have already added functions to call when our objects collide. They are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Player` class has a `hit` function. We will call it when a zombie collides
    with the player.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Zombie` class has a `hit` function. We will call it when a bullet collides
    with a zombie.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Pickup` class has a `gotIt` function. We will call it when the player collides
    with a pickup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If necessary, look back to refresh your memory on how each of those functions
    works. All we need to do now is detect the collisions and call the appropriate
    functions. We will use **rectangle intersection** to detect collisions. This type
    of collision detection is really straightforward (especially with SFML). We can
    think of drawing an imaginary rectangle—we can call it a **hitbox** or **bounding
    rectangle**—around the objects we want to test for collision, and then test to
    see whether they intersect. If they do, we have a collision:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting collisions](img/image_09_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the previous image, this is far from perfect. But in this
    situation it is sufficient. To implement this method, all we need to do is test
    for the intersection using the x and y coordinates of both object hit boxes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for testing the intersection of two rectangles would look something
    like this. Don''t use the following code. It is for demonstration purposes only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We don't need to write this code, however. We will be using the SFML `intersects`
    function, which works on `FloatRect` objects. Think or look back to the `Zombie`,
    `Player`, `Bullet`, and `Pickup` classes, they all had a `getPosition` function,
    which returned a `FloatRect` of the object's current location. We will see how
    we use `getPosition` along with `intersects` to do all our collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: We will deal with this in three sections of code that will all follow on from
    one another, and they will all go at the end of the update part of our game engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to know the answer to the following three questions, each frame:'
  prefs: []
  type: TYPE_NORMAL
- en: Has a zombie been shot?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has the player been touched by a zombie?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has the player touched a pickup?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First let''s add a couple more variables for `score` and `hiscore`. We can
    then change them when a zombie is killed. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now let's start by detecting whether a zombie is colliding with a bullet.
  prefs: []
  type: TYPE_NORMAL
- en: Has a zombie been shot?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code might look complicated, but when we step through it we will
    see it is actually nothing we haven''t seen before. Add the following code just
    after the call to update the pickups each frame. Then we can go through it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next section, we will see all of the zombie and bullet collision detection
    code again. We will do so a bit at a time so we can discuss it. First of all,
    notice the structure of the nested `for` loops (with the code stripped out) as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The code loops through each and every bullet (0 to 99) for each and every zombie
    (0 to < `numZombies`.).
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the nested `for` loops, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check whether the current bullet is in flight and the current zombie is still
    alive with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Provided the zombie is alive and the bullet is in flight, we test for a rectangle
    intersection with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If the current bullet and zombie have collided, then we take a number of steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop the bullet with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Register a hit with the current zombie by calling its `hit` function. Note
    that the `hit` function returns a `Boolean` that let''s the calling code know
    if the zombie is dead yet. This is shown in the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this `if` block, which detects when the zombie is dead and not just
    wounded, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add ten to `score`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change `hiScore` if score has exceeded (beaten) `score`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce `numZombiesAlive` by one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether all the zombies are dead, `(numZombiesAlive == 0)`, and if so,
    change `state` to `LEVELING_UP`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the block of code inside `if(zombies[j].hit())` that we have just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: That's the zombies and the bullets taken care of. You could run the game and
    see the blood. Of course you won't see the score until we implement the HUD in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Has the player been touched by a zombie?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This code is much shorter and simpler than the zombie and bullet collision
    detection. Add the highlighted code just after the previous code we wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We detect whether a zombie has collided with the player by using a `for` loop
    to loop through all the zombies. For each zombie that is alive, the code uses
    the `intersects` function to test for a collision with the player. When a collision
    has occurred, we call `player.hit`. Then we check whether the player is dead by
    calling `player.getHealth`. If the player's health is equal to or less than zero,
    then we change `state` to `GAME_OVER`.
  prefs: []
  type: TYPE_NORMAL
- en: You can run the game and collisions will be detected. However, as there is no
    HUD or sound effects yet, it is not clear that this is happening. In addition,
    we need to do some more work on resetting the game when the player dies and a
    new game is starting. So, although the game runs, the results are not especially
    satisfying at the moment. We will improve this over the next two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Has the player touched a pickup?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The collision detection code between the player and each of the two pickups
    follows. Add the highlighted code just after the previous code that we added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The previous code uses two simple `if` statements to see whether either `healthPickup`
    or `ammoPickup` has been touched by the player.
  prefs: []
  type: TYPE_NORMAL
- en: If a health pickup has been collected, then the `player.increaseHealthLevel`
    function uses the value returned from the `healthPickup.gotIt` function to increase
    the player's health.
  prefs: []
  type: TYPE_NORMAL
- en: If an ammo pickup has been collected, then `bulletsSpare` is increased by the
    value returned from `ammoPickup.gotIt`.
  prefs: []
  type: TYPE_NORMAL
- en: You can run the game, kill zombies, and collect pickups! Note that when your
    health equals zero, the game will enter the `GAME_OVER` state and pause. To restart
    it, you will need to press *Enter* followed by a number between *1* and *6*. When
    we implement the HUD, the home screen, and the leveling up screen, these steps
    will be intuitive and straightforward for the player. We will do so in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: FAQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some questions that might be on your mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Q) Are there any better ways of doing collision detection?
  prefs: []
  type: TYPE_NORMAL
- en: 'A) Yes. There are lots more ways to do collision detection, including but not
    limited to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You can divide objects into multiple rectangles which better fit the shape of
    the sprite. It is perfectly manageable for C++ to check on thousands of rectangles
    each frame. This is especially true when you use techniques such as neighbor checking
    to reduce the number of tests that are necessary each frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For circular objects, you can use the radius overlap method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For irregular polygons, you can use the crossing number algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these techniques can be investigated at the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Neighbor checking**: [http://gamecodeschool.com/essentials/collision-detection-neighbor-checking/](http://gamecodeschool.com/essentials/collision-detection-neighbor-checking/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Radius overlap method**: [http://gamecodeschool.com/essentials/collision-detection-radius-overlap/](http://gamecodeschool.com/essentials/collision-detection-radius-overlap/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Crossing number algorithm**: [http://gamecodeschool.com/essentials/collision-detection-crossing-number/](http://gamecodeschool.com/essentials/collision-detection-crossing-number/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That was a busy chapter but we have achieved a lot. Not only did we add bullets
    and pickups to the game through two new classes, but we also made all the objects
    interact as they should by detecting when they collide with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Despite these achievements, we need to do more work to set up each new game
    and to give the player feedback through a HUD. In the next chapter, we will build
    the HUD.
  prefs: []
  type: TYPE_NORMAL

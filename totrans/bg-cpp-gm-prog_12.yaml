- en: Chapter 12. Abstraction and Code Management – Making Better Use of OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will take a first look at the final project of the book.
    The project will have advanced features such as directional sound, which comes
    out of the speakers relative to the position of the player. It will also have
    split screen cooperative gameplay. In addition, this project will introduce the
    concept of **Shaders**, which are programs written in another language that run
    directly on the graphics card. By the end of [Chapter 16](ch16.html "Chapter 16. 
    Extending SFML Classes, Particle Systems, and Shaders"), *Extending SFML Classes,
    Particle Systems, and Shaders*, you will have a fully functioning multiplayer
    platform game built in the style of the hit classic **Thomas Was Alone**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter''s main focus will be getting the project started—in particular,
    exploring how the code will be structured to make better use of OOP. The following
    topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the final project, **Thomas Was Late**, including the gameplay
    features and project assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A detailed discussion of how we will improve the structure of the code compared
    to previous projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding the Thomas Was Late game engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing split screen functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Thomas Was Late game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, if you haven't already, I would suggest you go and watch a video
    of Thomas Was Alone at [http://store.steampowered.com/app/220780/](http://store.steampowered.com/app/220780/). Notice
    the really simple but aesthetically excellent graphics. The video also shows a
    variety of gameplay challenges such as using the character's different attributes
    (height, jump, power, and so on). To keep our game simple without losing the challenge,
    we will have fewer puzzle features than Thomas Was Alone, but will have the additional
    challenge of creating the need for two players to play cooperatively. Just to
    make sure the game is not too easy, we will also make the players race against
    the clock, hence why the name of our game is Thomas Was Late.
  prefs: []
  type: TYPE_NORMAL
- en: Features of Thomas Was Late
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our game will not be nearly as advanced as the masterpiece that we are attempting
    to emulate, but it will have a good selection of exciting gameplay features:'
  prefs: []
  type: TYPE_NORMAL
- en: A clock that count downs from a time appropriate to the challenge of the level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fire pits that emit a roar relative to the position of the player and re-spawn
    the player at the start if they fall in. Water pits have the same effect but without
    the directional sound effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cooperative gameplay—both the players will have to get their characters to the
    goal within the allotted time. They will frequently need to work together, for
    example the shorter, lower-jumping Bob will need to stand on his friend's (Thomas's)
    head.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player will have the option of switching between full and split screen,
    so he can attempt to control both characters himself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each level will be designed in and loaded from a text file. This will make it
    really easy to design varied and numerous levels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at this annotated screenshot of the game to see some of the features
    in action and the components/assets that make up the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Features of Thomas Was Late](img/B05523_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at each of those features and describe a few more:'
  prefs: []
  type: TYPE_NORMAL
- en: The screenshot shows a simple HUD that details the level number and the number
    of seconds remaining until the players fail and have to restart the level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also clearly see the split screen co-op in action. Remember that this
    is optional. A single player can take on the game, fullscreen, while switching
    the camera focus between Thomas and Bob.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not very clear in the screenshot (especially in print), but when a character
    dies, he will explode in a starburst/firework-like particle effect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The water and fire tiles can be strategically placed to make the level fun and
    force cooperation between the characters. More on this in [Chapter 14](ch14.html
    "Chapter 14. Building Playable Levels and Collision Detection"), *Building Playable
    Levels and Collision Detection*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice Thomas and Bob—not only are they different in heights, but they also
    have significantly different jumping abilities. This means that Bob is dependent
    upon Thomas for big jumps, and levels can be designed to force Thomas to take
    a route that avoids him banging his head.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, the fire tiles will emit a roaring sound. These will be relative
    to the position of Thomas. Not only will they be directional and come from either
    the left or right speaker, they will also get louder and quieter as Thomas moves
    closer or further away from the source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, in the annotated screenshot, you can see the background. If you compare
    how that looks to the `background.png` file (shown later in this chapter), you
    will see it is quite different. We will use OpenGL shader effects in [Chapter
    16](ch16.html "Chapter 16.  Extending SFML Classes, Particle Systems, and Shaders"), *Extending
    SFML Classes, Particle Systems, and Shaders*, to achieve the moving—almost bubbling—effect
    in the background.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All those features warrant a few more screenshots so we can keep the finished
    product in mind as we write the C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows Thomas and Bob arriving at a fire pit that Bob
    has no chance of jumping over without help:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Features of Thomas Was Late](img/image_12_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows Bob and Thomas collaborating to clear a precarious
    jump:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Features of Thomas Was Late](img/image_12_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows how we can design puzzles where a "leap of faith"
    is required in order to reach the goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Features of Thomas Was Late](img/image_12_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot demonstrates how we can design oppressive cave systems
    of almost any size. We can also devise levels where Bob and Thomas are forced
    to split up and go different routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Features of Thomas Was Late](img/image_12_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a project from the template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating the Thomas Was Late project is the same as the other two projects.
    Just follow these straightforward steps in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **File** | **New Project** from the main menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that **Visual C++** is selected in the left-hand menu and then select
    **HelloSFML** from the list of presented options. The following screenshot should
    make this clear:![Creating a project from the template](img/image_12_006.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Name:** field, type `TWL` and also make sure that the **Create directory
    for solution** option is checked. Now click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to copy the SFML `.dll` files into the main project directory. My
    main project directory is `D:\Visual Studio Stuff\Projects\ TWL\TWL`. This folder
    was created by Visual Studio in the previous step. If you put your `Projects`
    folder somewhere else, perform this step there instead. The files we need to copy
    into the `project` folder are located in your `SFML\bin` folder. Open a window
    for each of the two locations and highlight the required `.dll` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now copy and paste the highlighted files into the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The project is now set up and ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: The project assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The assets in this project are even more numerous and diverse than the Zombie
    Arena game. As usual, the assets include a font for the writing on the screen,
    sound effects for different actions such as jumping, reaching the goal, or the
    distant roar of fire, and, of course, graphics for Thomas and Bob as well as a
    sprite sheet for all the background tiles.
  prefs: []
  type: TYPE_NORMAL
- en: All the assets required for the game are included in the download bundle. They
    can be found in the `Chapter 12/graphics` and `Chapter 12/sound` folders, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The font that is required has not been supplied. This is because I wanted to
    avoid any possible ambiguity regarding the license. This will not cause a problem
    though, as I will show you exactly where and how to choose and download fonts
    for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Although I will provide either the assets themselves or information on where
    to get them, you might like to create and acquire them for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the graphics, sound, and fonts that we have come to expect, this
    game has two new asset types. They are level design files and GLSL shader programs.
    Let's find out about each of them next.
  prefs: []
  type: TYPE_NORMAL
- en: Game level designs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Levels are all created in a text file. By using the numbers 0 through 3, we
    can build level designs to challenge players. All the level designs are in the
    levels folder in the same directory as the other assets. Feel free to take a peek
    at one now, but we will look at them in detail in [Chapter 14](ch14.html "Chapter 14. Building
    Playable Levels and Collision Detection"), *Building Playable Levels and Collision
    Detection*.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these level design assets, we have a special type of graphical
    asset, called shaders.
  prefs: []
  type: TYPE_NORMAL
- en: GLSL Shaders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shaders are programs written in **GLSL** (**Graphics Library Shading Language**).
    Don't worry about having to learn another language, as we don't need to get too
    in-depth to take advantage of shaders. Shaders are special, as they are entire
    programs, separate from our C++ code, which are executed by the GPU each and every
    frame. In fact, some of these shader programs are run every frame, for every pixel!
    We will find out more details in [Chapter 16](ch16.html "Chapter 16.  Extending
    SFML Classes, Particle Systems, and Shaders"), *Extending SFML Classes, Particle
    Systems, and Shaders*. If you can't wait that long, take a look at the files in
    the `Chapter 12/shaders` folder of the download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: The graphical assets close-up
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The graphical assets make up the parts of the scene of our game. Take a look
    at the graphical assets and it should be clear where in our game they will be
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The graphical assets close-up](img/image_12_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the tiles on the `tiles_sheet` graphic look a little different to the screenshots
    of the game, this is because they are partly transparent and the background showing
    through changes them a little. If the background graphic looks totally different
    to the actual background in the game screenshots, that is because the shader programs
    we will write will manipulate each and every pixel, each and every frame, to create
    a kind of "molten" effect.
  prefs: []
  type: TYPE_NORMAL
- en: The sound assets close-up
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The sound files are all `.wav` format. These are files that contain the sound
    effects we will play at certain events throughout the game. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fallinfire.wav`: A sound that will be played when the player''s head goes
    into fire and the player has no chance of escape.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fallinwater.wav`: Water has the same end effect as fire: death. This sound
    effect notifies the player they need to start from the beginning of the level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fire1.wav`: This sound effect is recorded in mono. It will be played at different
    volumes based on the player''s distance from fire tiles, and from different speakers
    based on whether the player is to the left or the right of the fire tile. Clearly,
    we will need to learn a few more tricks to implement this functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jump.wav`: A pleasing (slightly predictable) whooping sound for when the player
    jumps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reachgoal.wav`: A pleasing victory sound for when the player (or players)
    gets both characters (Thomas and Bob) to the goal tile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sound effects are very straightforward and you can easily create your own.
    If you intend to replace the `fire1.wav` file, be sure to save your sound in a
    mono (not stereo) format. The reasons for this will be explained in [Chapter 15](ch15.html
    "Chapter 15. Sound Spatialization and HUD"), *Sound Spacialization and HUD*.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the assets to the project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have decided which assets you will use, it is time to add them to the
    project. The following instructions will assume you are using all the assets supplied
    in the book's download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where you are using your own, simply replace the appropriate sound or graphic
    file with your chosen file, using exactly the same filename:'
  prefs: []
  type: TYPE_NORMAL
- en: Browse to the Visual `D:\Visual Studio Stuff\Projects\TWL\TWL` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create five new folders within this folder and name them as `graphics`, `sound`,
    `fonts`, `shaders`, and `levels`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the download bundle, copy the entire contents of `Chapter 12/graphics`
    into the `D:\Visual Studio Stuff\Projects\TWL\TWL\graphics` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the download bundle, copy the entire contents of `Chapter 12/sound` into
    the `D:\Visual Studio Stuff\Projects\TWL\TWL\sound` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now visit [http://www.dafont.com/roboto.font](http://www.dafont.com/roboto.font)
    in your web browser and download the **Roboto Light** font.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the contents of the zipped download and add the `Roboto-Light.ttf` file
    to the `D:\Visual Studio Stuff\Projects\TWL\TWL\fonts` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the download bundle, copy the entire contents of `Chapter 12/levels` into
    the `D:\Visual Studio Stuff\Projects\TWL\TWL\levels` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the download bundle, copy the entire contents of `Chapter 12/shaders` into
    the `D:\Visual Studio Stuff\Projects\TWL\TWL\shaders` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have a new project, along with all the assets we will need for the
    entire project, we can talk about how we will structure the game engine code.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring the Thomas Was Late code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the problems that has been quite pronounced in both projects so far is
    how long and unwieldy the code gets. OOP allows us to break our projects up into
    logical and manageable chunks called classes.
  prefs: []
  type: TYPE_NORMAL
- en: We will make a big improvement to the manageability of the code in this project
    with the introduction of an **Engine class**. Among other functions, the Engine
    class will have three private functions. They are `input`, `update`, and `draw`.
    This should sound very familiar. Each of these functions will hold a chunk of
    the code that was previously all in the `main` function. Each of these functions
    will be in a code file of its own, `Input.cpp`, `Update.cpp`, and `Draw.cpp` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'There will also be one public function in the `Engine` class, which can be
    called with an instance of `Engine`. This function is `run` and will be responsible
    for calling `input`, `update`, and `draw`, once for each frame of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Structuring the Thomas Was Late code](img/image_12_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Furthermore, because we have abstracted the major parts of the game engine
    to the `Engine` class, we can also move many of the variables from `main` and
    make them members of `Engine`. All we need to do to get our game engine fired
    up is create an instance of `Engine` and call its `run` function. Here is a sneak
    preview of the super-simple main function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't add the preceding code just yet.
  prefs: []
  type: TYPE_NORMAL
- en: To make our code even more manageable and readable, we will also abstract responsibility
    for big tasks, such as loading a level and collision detection, to separate functions
    (in separate code files). These two functions are `loadLevel` and `detectCollisions`.
    We will also code other functions to handle some of the new features of the Thomas
    Was Late project. We will cover them in detail as and when they occur.
  prefs: []
  type: TYPE_NORMAL
- en: To further take advantage of OOP, we will delegate responsibility for particular
    areas of the game entirely to new classes. You probably remember that the sound
    and HUD code was quite lengthy in previous projects. We will build a `SoundManager`
    and `HUD` class to handle these aspects in a cleaner manner. Exactly how they
    work will be explored in depth when we implement them.
  prefs: []
  type: TYPE_NORMAL
- en: The game levels themselves are much more in-depth than previous games, so we
    will also code a `LevelManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: As you would expect, the playable characters will be made with classes as well.
    For this project, however, we will learn some more C++ and implement a `PlayableCharacter`
    class with all the common functionality of Thomas and Bob, and then `Thomas` and
    `Bob` classes, which will inherit this common functionality as well as implement
    their own unique functions and abilities. This, perhaps unsurprisingly, is called
    **inheritance**. I will go into more detail about inheritance in the following
    [Chapter 13](ch13.html "Chapter 13. Advanced OOP – Inheritance and Polymorphism"), *Advanced
    OOP, Inheritance, and Polymorphism*.
  prefs: []
  type: TYPE_NORMAL
- en: We will also implement a number of other classes to perform specific responsibilities.
    For example, we will make some neat explosions using particle systems. You might
    be able to guess that to do this, we will code a `Particle` class and a `ParticleSystem`
    class. All of these classes will have instances that are members of the `Engine`
    class. Doing things this way will make all the features of the game accessible
    from the game engine, but encapsulate the details into appropriate classes.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing to mention before we move on to see the actual code that will
    make the Engine class is that we will reuse, without any changes whatsoever, the
    `TextureHolder` class, which we discussed and coded for the Zombie Arena game.
  prefs: []
  type: TYPE_NORMAL
- en: Building the game engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As suggested in the previous discussion, we will code a class called `Engine`
    that will control and bind together the different parts of the Thomas Was Late
    game.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we will do is make the `TextureHolder` class from the previous
    project available in this one.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing the TextureHolder class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TextureHolder` class that we discussed and coded for the Zombie Arena game
    will also be useful in this project. While it is possible to add the files (`TextureHolder.h`
    and `TextureHolder.cpp`) directly from the previous project without recoding them
    or recreating the files, I don't want to make the assumption that you haven't
    jumped straight to this project. What follows is very brief instructions, along
    with the complete code listing to create the `TextureHolder` class. If you want
    the class or the code explained, please see [Chapter 8](ch08.html "Chapter 8. Pointers,
    the Standard Template Library, and Texture Management"), *Pointers, Standard Template
    Library, and Texture Management*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you did complete the previous project and you *do* want to add the class
    from the Zombie Arena project, simply do the following: in the **Solution Explorer**
    window, right-click **Header Files** and select **Add** | **Existing Item...**.
    Browse to `TextureHolder.h` from the previous project and select it. In the **Solution
    Explorer** window, right-click on **Source Files** and select **Add** | **Existing
    Item...**. Browse to `TextureHolder.cpp` from the previous project and select
    it. You can now use the `TextureHolder` class in this project. Note that the files
    are shared between projects and any changes will take effect in both projects.'
  prefs: []
  type: TYPE_NORMAL
- en: To create the `TextureHolder` class from scratch, right-click **Header Files**
    in the **Solution Explorer** and select **Add** | **New Item...**. In the **Add
    New Item** window, highlight (by left-clicking) **Header File (.h)** and then
    in the **Name** field, type `TextureHolder.h`. Finally, click the **Add** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `TextureHolder.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then, in the **Name** field, type `TextureHolder.cpp`.
    Finally, click the **Add** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `TextureHolder.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can now get on with our new `Engine` class.
  prefs: []
  type: TYPE_NORMAL
- en: Coding Engine.h
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, we will start with the header file, which holds the function declarations
    and member variables. Note that we will revisit this file throughout the project
    to add more functions and member variables. For now, we will add just the code
    that is necessary at this stage.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click **Header Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **Header File (** `.h` **)** and then in the **Name** field, type `Engine.h`.
    Finally, click the **Add** button. We are now ready to code the header file for
    the `Engine` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following member variables as well as the function declarations. Many
    of them we have seen before in the other projects, and some of them we discussed
    in the *Structuring the Thomas Was Late* code section. Take note of the function
    and variable names, as well as whether they are private or public. Add the following
    code to the `Engine.h` file, and then we will talk about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a complete run-down of all the private variables and functions. Where
    appropriate, I spend a little longer on the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TextureHolder th`: The one and only instance of the `TextureHolder` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TILE_SIZE`: A useful constant to remind us that each tile in the sprite sheet
    is fifty pixels wide and fifty pixels high.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VERTS_IN_QUAD`: A useful constant to make our manipulation of a `VertexArray`
    less error prone. There are, in fact, four vertices in a quad. Now we can''t forget
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GRAVITY`: A constant `int` value representing the number of pixels by which
    the game characters will be pushed downward each second. This is quite a fun value
    to play with once the game is done. We initialize it to `300`, as this works well
    for our initial level designs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m_Window`: The usual `RenderWindow` object, like we have had in all our projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The SFML `View` objects, `m_MainView`, `m_LeftView`, `m_RightView`, `m_BGMainView`,
    `m_BGLeftView`, `m_BGRightView`, and `m_HudView`: The first three `View` objects
    are for the fullscreen view, and left and right split screen views of the game.
    We also have a separate SFML `View` object for each of those three, which will
    draw the background behind. The last `View` object, `m_HudView`, will be drawn
    on top of the appropriate combination of the other six views to display the score,
    the remaining time, and any messages to the players. Having seven different `View`
    objects might imply complexity, but when you see how we deal with them as the
    chapter progresses, you will see they are quite straightforward. We will have
    the whole split screen/fullscreen conundrum sorted out by the end of this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sprite m_BackgroundSprite` and `Texture m_BackgroundTexture`: Somewhat predictably,
    this combination of SFML `Sprite` and `Texture` will be for showing and holding
    the background graphic from the graphics assets folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m_Playing`: This Boolean will keep the game engine informed about whether
    the level has started yet (by pressing the ***Enter*** key). The player does not
    have the option to pause the game once they have started it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m_Character1`: When the screen is fullscreen, should it center on Thomas (m_Character1
    = true), or Bob (m_Character1 = false)? Initially, it is initialized to true,
    to center on Thomas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m_SplitScreen`: Is the game currently being played in split screen mode or
    not? We will use this variable to decide how exactly to use all the View objects
    we declared a few steps ago.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m_TimeRemaining` variable: This `float` variable holds how much time is remaining
    to get to the goal of the current level. In the previous code, it is set to `10`
    for the purposes of testing, until we actually get to set a specific time for
    each level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m_GameTimeTotal` variable: This variable is an SFML Time object. It keeps
    track of how long the game has been played for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m_NewLevelRequired` Boolean variable: This variable keeps a check on whether
    the player has just completed or failed a level. We can then use it to trigger
    the loading of the next level or the restarting of the current level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `input` function: This function will handle all of the player''s input,
    which in this game is entirely from the keyboard. At first glance, it would appear
    that it handles all the keyboard input directly. In this game, however, we will
    be handling keyboard input that directly affects Thomas or Bob within the `Thomas`
    and `Bob` classes directly. We will call the `input` function, and this function
    will directly handle keyboard inputs such as quitting, switching to split screen,
    and any other keyboard input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `update` function: This function will do all the work that we previously
    did in the update section of the `main` function. We will also call some other
    functions from the `update` function in order to keep the code organized. If you
    look back at the code, you will see that it receives a `float` parameter, which
    will hold the fraction of a second that has passed since the previous frame. This,
    of course, is just what we need to update all our game objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `draw` function: This function will hold all the code that used to go in
    the drawing section of the main function in previous projects. We will, however,
    have some drawing code that is not kept in this function when we look at other
    ways to draw with SFML. We will see this new code when we learn about particle
    systems in [Chapter 16](ch16.html "Chapter 16.  Extending SFML Classes, Particle
    Systems, and Shaders"), *Extending SFML Classes, Particle Systems, and Shaders*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s run through all the public functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Engine` constructor function: As we have come to expect, this function
    will be called when we first declare an instance of `Engine`. It will do all the
    setup and initialization of the class. We will see exactly what when we code the
    `Engine.cpp` file shortly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `run` function: This is the only public function that we need to call.
    It will trigger the execution of input, update, and draw, which will do all the
    work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will see the definition of all these functions and some of the variables
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: Coding Engine.cpp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In all our previous classes, we have put all the function definitions into the
    `.cpp` file, prefixed with the class name. As our aim for this project is to make
    the code more manageable, we are doing things a little differently.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Engine.cpp` file, we will put the constructor (`Engine`) and the public
    `run` function. All the rest of the functions will go in their own `.cpp` file,
    with a name that makes it clear what function goes where. This will not be a problem
    for the compiler as long as we add the appropriate include directive (`#include
    "Engine.h"`) at the top of all the files that contain function definitions from
    the `Engine` class.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started by coding `Engine` and run it in `Engine.cpp`. Right-click
    **Source Files** in the **Solution Explorer** and select **Add** | **New Item...**.
    In the **Add New Item** window, highlight (by left-clicking) **C++ File (.cpp)**
    and then in the **Name** field, type `Engine.cpp`. Finally, click the **Add**
    button. We are now ready to code the `.cpp` file for the `Engine` class.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Engine class constructor definition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code for this function will go in the `Engine.cpp` file we have recently
    created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code and then we can discuss it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Much of the code we have seen before. For example, there are the usual lines
    of code to get the screen resolution as well as to create a `RenderWindow`. At
    the end of the previous code we use the now familiar code to load a texture and
    assign it to a Sprite. In this case we are loading the `background.png` texture
    and assigning it to `m_BackgroundSprite`.
  prefs: []
  type: TYPE_NORMAL
- en: It is the code in between, the four calls to the `setViewport` function, that
    needs some explanation. The `setViewport` function assigns a portion of the screen
    to an SFML `View` object. It doesn't work using pixel coordinates, however. It
    works using a ratio. Where "1" is the entire screen (width or height), the first
    two values in each call to `setViewport` are the starting position (horizontally,
    then vertically) and the last two are the ending position.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `m_LeftView` and `m_BGLeftView` are placed in exactly the same
    place, starting at virtually the far left (0.001) of the screen, and ending two
    1,000ths from the center (0.498).
  prefs: []
  type: TYPE_NORMAL
- en: The `m_RightView` and `m_BGRightView` are also in exactly the same position,
    starting just left of the previous two `View` objects (0.5) and extending to almost
    the far right-hand side (0.998) of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, all the views leave a tiny sliver of a gap at the top and bottom
    of the screen. When we draw these `View` objects on the screen on top of a white
    background, it will have the effect of splitting the screen with a thin white
    line between the two sides of the screen, as well as a thin white border around
    the edges.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have tried to represent this effect in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding the Engine class constructor definition](img/image_12_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The best way to understand it is to finish this chapter, run the code, and see
    it in action.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the run function definition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code for this function will go in the `Engine.cpp` file we have recently
    created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code immediately after the previous constructor code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The run function is the center of our engine—it initiates all the other parts.
    First, we declare a Clock object. Next, we have the familiar `while(window.isOpen())`
    loop, which creates the game loop. Inside this while loop, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Restart `clock` and save the time that the previous loop took in `dt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep track of the total time elapsed in `m_GameTimeTotal`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare and initialize a `float` to represent the fraction of a second that
    elapsed during the previous frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `input`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `update` passing in the elapsed time (`dtAsSeconds`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `draw`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of this should look very familiar. What is new is that it is wrapped in
    the `run` function.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the input function definition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As explained previously, the code for this function will go in its own file
    because it is more extensive than the constructor or the `run` function. We will
    use `#include "Engine.h"` and prefix the function signature with `Engine::` to
    make sure the compiler is aware of our intentions.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `Input.cpp`.
    Finally, click the **Add** button. We are now ready to code the `input` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As with both of the previous projects, we check the `RenderWindow` event queue
    each frame. Also, as we have done before, we detect specific keyboard keys using
    `if (Keyboard::isKeyPressed(Keyboard::E))`. What is most relevant in the code
    we just added is what the keys actually do:'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, the ***Esc*** key closes the window and the game will quit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ***Enter*** key sets `m_Playing` to true, and eventually, this will have
    the effect of starting the level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ***Q*** key alternates the value of `m_Character1` between `true` and `false`.
    This key only has an effect in fullscreen mode. It will switch between Thomas
    and Bob being the center of the main `View`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ***E*** key switches `m_SplitScreen` between `true` and `false`. This will
    have the effect of switching between fullscreen and split screen views.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The majority of this keyboard functionality will be fully working by the end
    of the chapter. We are getting close to being able to run our game engine. Next,
    let's code the `update` function.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the update function definition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As explained previously, the code for this function will go in its own file
    because it is more extensive than the constructor or the `run` function. We will
    use `#include "Engine.h"` and prefix the function signature with `Engine::` to
    make sure the compiler is aware of our intentions.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `Update.cpp`.
    Finally, click the **Add** button. We are now ready to write some code for the
    `update` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `Update.cpp` file to implement the `update` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First of all, notice that the `update` function receives the time the previous
    frame took as a parameter. This, of course, will be essential for the update function
    to fulfill its role.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code doesn't achieve anything visible at this stage. It does put
    in the structure that we will require for future chapters. It subtracts the time
    the previous frame took from `m_TimeRemaining`. It checks whether time has run
    out, and if it has, it sets `m_NewLevelRequired` to `true`. All this code is wrapped
    in an `if` statement that only executes when `m_Playing` is `true`. The reason
    for this is because, as with the previous projects, we don't want time advancing
    and objects updating when the game has not started.
  prefs: []
  type: TYPE_NORMAL
- en: We will build on this code as the project continues.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the draw function definition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As explained previously, the code for this function will go in its own file,
    because it is more extensive than the constructor or the `run` function. We will
    use `#include "Engine.h"` and prefix the function signature with `Engine::` to
    make sure the compiler is aware of our intentions.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `Draw.cpp`. Finally,
    click the **Add** button. We are now ready to add some code to the `draw` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `Draw.cpp` file to implement the `draw` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, there is nothing we haven''t seen before. The code starts,
    as usual, by clearing the screen. In this project, we clear the screen with white.
    What is new is the way the different drawing options are separated by a condition,
    which checks whether the screen is currently split or full:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If the screen is not split, we draw the background sprite in the background
    `View` (`m_BGView`) and then switch to the main fullscreen `View` (`m_MainView`).
    Note that at the moment, we don't actually do any drawing in `m_MainView`.
  prefs: []
  type: TYPE_NORMAL
- en: If, on the other hand, the screen is split, the code in the `else` block is
    executed and we draw `m_BGLeftView` with the background sprite on the left of
    the screen, followed by switching to `m_LeftView`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, still in the `else` block, we draw `m_BGRightView` with the background
    sprite on the right of the screen, followed by switching to `m_RightView`.
  prefs: []
  type: TYPE_NORMAL
- en: Outside of the `if…else` structure just described, we switch to  `m_HUDView`.
    At this stage, we are not actually drawing anything in `m_HUDView`.
  prefs: []
  type: TYPE_NORMAL
- en: As with the other two (`input`, `update`) of the three most significant functions,
    we will be back here at the `draw` function often. We will add new elements of
    our game that need to be drawn. You will notice that each time we do, we will
    add code into each of the main, left, and right sections.
  prefs: []
  type: TYPE_NORMAL
- en: Let's quickly recap the `Engine` class and then we can fire it up.
  prefs: []
  type: TYPE_NORMAL
- en: The Engine class so far
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we have achieved is the abstraction of all the code that used to be in
    the `main` function into the `input`, `update`, and `draw` functions. The continuous
    looping of these functions, as well as the timing, is handled by the `run` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider leaving the **Input.cpp**, **Update.cpp**, and **Draw.cpp** tabs open
    in Visual Studio, perhaps organized in order, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Engine class so far](img/image_12_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will revisit each of these functions throughout the course of the project
    to add more code. Now that we have the basic structure and functionality of the
    `Engine` class, we can create an instance of it in the `main` function and see
    it in action.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the main function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's rename the `HelloSFML.cpp` file as `Main.cpp`. Right-click on the `HelloSFML`
    file in the **Solution Explorer** and select **Rename**. Change the name to `Main.cpp`.
    This will be the file that contains our `main` function and the code that instantiates
    the `Engine` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `Main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: All we do is add an include directive for the `Engine` class, declare an instance
    of `Engine`, then call its `run` function. Everything will be handled by the `Engine`
    class until the player quits and the execution returns to `main` and the `return
    0` statement.
  prefs: []
  type: TYPE_NORMAL
- en: That was easy. Now we can run the game and see the empty background, either
    fullscreen or split screen, which will eventually contain all the action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the game so far, in fullscreen mode, showing just the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding the main function](img/image_12_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now tap the ***E*** key, and you will be able to see the screen neatly partitioned
    into two halves, ready for split screen co-op gameplay:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding the main function](img/image_12_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here are some questions that might be on your mind.
  prefs: []
  type: TYPE_NORMAL
- en: FAQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q) I don't fully understand the structure of the code files.
  prefs: []
  type: TYPE_NORMAL
- en: A) It is true that abstraction can make the structure of our code less clear,
    but the actual code itself becomes so much easier. Instead of cramming everything
    into the main function as we did in previous projects, we will split the code
    up into `Input.cpp`, `Update.cpp`, and `Draw.cpp`. Furthermore, we will use more
    classes to group together related code as we proceed. Study the Structuring the
    Thomas Was Late code section again, especially the diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the Thomas Was Late game and laid the foundations
    of understanding, as well as the code structure, for the rest of the project.
    It is certainly true that there are a lot of files in the Solution Explorer, but
    as long as we understand the purpose of each we will find the implementation of
    the rest of the project much more easy going.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will learn two more fundamental C++ topics, inheritance
    and polymorphism. We will also begin to put them to use, building three classes
    to represent two playable characters.
  prefs: []
  type: TYPE_NORMAL

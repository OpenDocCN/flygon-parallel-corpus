- en: Working with Memory, Arrays, and Pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ allows you to have direct access to memory through pointers. This gives
    you a lot of flexibility, and potentially it allows you to improve the performance
    of your code by eliminating some unnecessary copying of data. However, it also
    provides an extra source of errors; some can be fatal for your application or
    worse (yes, worse than fatal!) because poor use of memory buffers can open security
    holes in your code that can allow malware to take over the machine. Clearly pointers
    are an important aspect of C++.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you'll see how to declare pointers and initialize them to memory
    locations, how to allocate memory on the stack and, C++ free store, and how to
    use C++ arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Using memory in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ uses the same syntax as C to declare pointer variables and assign them to
    memory addresses, and it has C-like pointer arithmetic. Like C, C++ also allows
    you to allocate memory on the stack, so there is automatic memory cleanup when
    the stack frame is destroyed, and dynamic allocation (on the C++ free store) where
    the programmer has the responsibility to release memory. This section will cover
    these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Using C++ pointer syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax to access memory in C++ is straightforward. The `&` operator returns
    the address of an object. That *object* can be a variable, a built-in type or
    the instance of a custom type, or even a function (function pointers will be covered
    in the next chapter). The address is assigned a typed pointer variable or a `void*`
    pointer. A `void*` pointer should be treated as merely storage for the memory
    address because you cannot access data and you cannot perform pointer arithmetic
    (that is, manipulate the pointer value using arithmetic operators) on a `void*`
    pointer. Pointer variables are usually declared using a type and the `*` symbol.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the variable `i` is an integer, and the compiler and linker will
    determine where this variable will be allocated. Usually, a variable in a function
    will be on a stack frame, as described in a later section. At runtime, the stack
    will be created (essentially a chunk of memory will be allocated) and space will
    be reserved in the stack memory for the variable `i`. The program then puts a
    value (42) in that memory. Next, the address of the memory allocated for the variable
    `i` is placed in the variable `pi`. The memory usage of the previous code is illustrated
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89bf3c10-6e3f-4ac5-8ef7-9e801286fa70.png)'
  prefs: []
  type: TYPE_IMG
- en: The pointer holds a value of `0x007ef8c` (notice that the lowest byte is stored
    in the lowest byte in memory; this is for an x86 machine). The memory location
    `0x007ef8c` has a value of `0x0000002a`, that is, a value of 42, the value of
    the variable `i`. Since `pi` is also a variable, it also occupies space in memory,
    and in this case the compiler has put the pointer *lower* in memory than the data
    it points to and, in this case, the two variables are not contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: With variables allocated on the stack like this, you should make no assumptions
    about where in memory the variables are allocated, nor their location in relation
    to other variables.
  prefs: []
  type: TYPE_NORMAL
- en: This code assumes a 32-bit operating system, and so the pointer `pi` occupies
    32 bits and contains a 32-bit address. If the operating system is 64 bits then
    the pointer will be 64 bits wide (but the integer may still be 32 bits). In this
    book, we will use 32-bit pointers for the simple convenience that 32-bit addresses
    take less typing than 64-bit addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The typed pointer is declared with a `*` symbol and we will refer to this as
    an `int*` pointer because the pointer points to memory that holds an `int`. When
    declaring a pointer, the convention is to put the `*` next to the variable name
    rather than next to the type. This syntax emphasizes that the *type pointed* to
    is an `int`. However, it is important to use this syntax if you declare more than
    one variable in a single statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It is clear that the first variable is an `int*` pointer and the second is
    an `int`. The following is not so clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You might interpret this to mean that the type of both variables is `int*`, *but
    this is not the case*, as this declares a pointer and an `int`. If you want to
    declare two pointers, then apply `*` to each variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is probably better just to declare the two pointers on separate lines.
  prefs: []
  type: TYPE_NORMAL
- en: When you apply the `sizeof` operator to a pointer, you will get the size of
    the pointer, not what it points to. Thus, on an x86 machine, `sizeof(int*)` will
    return 4; and on an x64 machine, it will return 8\. This is an important observation,
    especially when we discuss C++ built-in arrays in a later section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the data pointed to by a pointer, you must **dereference** it using
    the `*` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Used like this on the right-hand side of an assignment, the dereferenced pointer
    gives access to the value pointed to by the pointer, so `j` is initialized to
    42\. Compare this to the declaration of a pointer, where the `*` symbol is also
    used, but has a different meaning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dereference operator does more than give read access to the data at the
    memory location. As long as the pointer does not restrict it (using the `const`
    keyword; see later), you can dereference the pointer to write to a memory location
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the pointer `pi` points to the location in memory of the variable
    `i` (in this case, using the brace syntax). Assigning the dereferenced pointer
    assigns the value to the location that the pointer points to. The result is that
    on the last line, the variable `i` will have a value of 99 and not 42.
  prefs: []
  type: TYPE_NORMAL
- en: Using null pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pointer could point to anywhere in the memory installed in your computer,
    and assignment through a dereferenced pointer means that you could potentially
    write over sensitive memory used by your operating system, or (through direct
    memory access) write to memory used by hardware on your machine. However, operating
    systems will usually give an executable a specific memory range that it can access,
    and attempts to access memory out of this range will cause an operating system
    memory access violation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, you should almost always obtain pointer values using the `&`
    operator or from a call to an operating system function. You should not give a
    pointer an absolute address. The only exception to this is the C++ constant for
    an invalid memory address, `nullptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code initializes the pointer `pi` to `nullptr`. Later in the code, the
    pointer is initialized to the address of an integer variable. Still later in the
    code, the pointer is used, but rather than calling it immediately, the pointer
    is first checked to ensure that it has been initialized to a non-null value. The
    compiler will check to see if you are about to use a variable that has not been
    initialized, but if you are writing library code, the compiler will not know whether
    the callers of your code will use pointers correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The type of constant `nullptr` is not an integer, it is `std::nullptr_t`. All
    pointer types can be implicitly converted to this type, so `nullptr` can be used
    to initialize variables of all pointer types.
  prefs: []
  type: TYPE_NORMAL
- en: Types of memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In general, you can regard memory as being one of four types:'
  prefs: []
  type: TYPE_NORMAL
- en: Static or global
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic or stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Free store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you declare a variable at the global level, or if you have a variable declared
    in a function as `static`, then the compiler will ensure that the variable is
    allocated from memory that has the same lifetime as the application--the variable
    is created when the application starts and deleted when the application ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use a string literal, the data will also, effectively, be a global
    variable, but stored in a different part of the executable. For a Windows executable,
    string literals are stored in the `.rdata` PE/COFF section of the executable.
    The `.rdata` section of the file is for read-only initialized data, and hence
    you cannot change the data. Visual C++ allows you to go a step further and gives
    you an option of **string pooling**. Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this code, two pointers are initialized with the address of the string literal
    `hello`. In the following two lines, the address of each pointer is printed on
    the console. Since the `<<` operator for `char*` treats the variable as a pointer
    to a string, it will print the string rather than the address of the pointer.
    To get around this, we call the `reinterpret_cast` operator to convert the pointer
    to an integer and print the value of the integer.
  prefs: []
  type: TYPE_NORMAL
- en: If you compile the code at the command line using the Visual C++ compiler, you
    will see two different addresses printed. These two addresses are in the `.rdata`
    section and are both read-only. If you compile this code with the `/GF` switch
    to enable string pooling (which is default for Visual C++ projects), the compiler
    will see that the two string literals are the same and will only store one copy
    in the `.rdata` section, so the result of this code will be that a single address
    will be printed on the console twice.
  prefs: []
  type: TYPE_NORMAL
- en: In this code, the two variables `p1` and `p2` are automatic variables, that
    is, they are created on the stack created for the current function. When a function
    is called, a chunk of memory is allocated for the function and this contains space
    for the parameters passed to the function and the return address of the code that
    called the function, as well as space for the automatic variables declared in
    the function. When the function finishes, the stack frame is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: The **calling convention** of the function determines whether the calling function
    or the called function has the responsibility to do this. In Visual C++, the default
    is the `__cdecl` calling convention, which means the calling function cleans up
    the stack. The `__stdcall` calling convention is used by Windows operating system
    functions and the stack clean up is carried out by the called function. More details
    will be given in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic variables only last as long as the function and the address of such
    variables only make any sense within the function. Later in this chapter, you
    will see how to create arrays of data. Arrays allocated as automatic variables
    are allocated on the stack to a fixed size determined at compile time. It is possible
    with large arrays that you could exceed the size of the stack, particularly with
    functions that are called recursively. On Windows, the default stack size is 1
    MB, and on x86 Linux, it is 2 MB. Visual C++ allows you to specify a bigger stack
    with the `/F` compiler switch (or the `/STACK` linker switch). The gcc compiler
    allows you to change the default stack size with the `--stack` switch.
  prefs: []
  type: TYPE_NORMAL
- en: The final type of memory is **dynamic memory** created on the **free store**
    or sometimes known as the **heap**. This is the most flexible way of using memory.
    As the name suggests, you allocate memory at runtime of a size determined at runtime.
    The implementation of the free store depends on the C++ implementation but you
    should regard the free store as having the same lifetime as your application,
    so memory allocated from the free store should last at least as long as your application.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are potential dangers here, particularly for long-lived applications.
    All memory allocated from the free store should be returned back to the free store
    when you have finished with it so that the free store manager can reuse the memory.
    If you do not return memory appropriately, then potentially the free store manager
    could run out of memory, which will prompt it to ask the operating system for
    more memory, and consequently, the memory usage of your application will grow
    over time, causing performance issues due to memory paging.
  prefs: []
  type: TYPE_NORMAL
- en: Pointer arithmetic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pointer points to memory, and the type of the pointer determines the type
    of the data that can be accessed through the pointer. So, an `int*` pointer will
    point to an integer in memory, and you dereference the pointer (`*`) to get the
    integer. If the pointer allows it (it is not marked as `const`), you can change
    its value through pointer arithmetic. For example, you can increment or decrement
    a pointer. What happens to the value of the memory address depends on the type
    of the pointer. Since a typed pointer points to a type, any pointer arithmetic
    will change the pointer in units of the *size* of that type.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you increment an `int*` pointer, it will point to the *next* integer in
    memory and the change in the memory address depends on the size of the integer.
    This is equivalent to array indexing, where an expression such as `v[1]` means
    you should start at the memory location of the first item in `v` and then move
    one item further in memory and return the item there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first line allocates an array of five integers on the stack and initializes
    the values to the numbers 1 to 5\. In this example, because an initialization
    list is used, the compiler will create space for the required number of items,
    hence the size of the array is not given. If you give the size of the array between
    the brackets, then the initialization list must not have more items than the array
    size. If the list has fewer items, then the rest of the items in the array are
    initialized to the default value (usually zero).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line in this code obtains a pointer to the first item in the array.
    This line is significant: an array name is treated as a pointer to the first item
    in the array. The following lines alter array items in various ways. The first
    of these (`*pv`) changes the first item in the array by dereferencing the pointer
    and assigning it a value. The second (`v[1]`) uses array indexing to assign a
    value to the second item in the array. The third (`pv[2]`) uses indexing, but
    this time with a pointer, and assigns a value to the third value in the array.
    And the final example (`*(pv + 3)`) uses pointer arithmetic to determine the address
    of the fourth item in the array (remember the first item has an index of 0) and
    then dereferences the pointer to assign the item a value. After these, the array
    contains the values `{ 11, 12, 13, 14, 5 }` and the memory layout is illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5daa49f6-aa94-46a5-b9e8-1e3f60e607a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you have a memory buffer containing values (in this example, allocated via
    an array) and you want to multiply each value by 3, you can do this using pointer
    arithmetic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The loop statement is complicated, and you will need to refer back to the operator
    precedence given in [Chapter 2](92dda5f2-3cee-40d5-8797-cdbbd6b8f59a.xhtml), *Understanding
    Language Features*. The postfix increment operator has the highest precedence,
    the next highest precedence is the dereference operator (`*`), and finally, the
    `*=` operator has the lowest of the three operators, so the operators are run
    in this order: `++`, `*`, `*=`. The postfix operator returns the value *before*
    the increment, so although the pointer is incremented to the next item in memory,
    the expression uses the address before the increment. This address is then dereferenced
    which is assigned by the assignment operator that replaces the item with the value
    multiplied by 3\. This illustrates an important difference between pointers and
    array names; you can increment a pointer but you cannot increment an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can, of course use indexing (with `[]`) on both array names and pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Using arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, a C++ built-in array is zero or more items of data of
    the same type. In C++, square brackets are used to declare arrays and to access
    array elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `squares` variable is an array of integers. The first line allocates enough
    memory for *four* integers and then the `for` loop initializes the memory with
    the first four squares. The memory allocated by the compiler from the stack is
    contiguous and the items in the array are sequential, so the memory location of
    `squares[3]` is `sizeof(int)` following on from `squares[2]`. Since the array
    is created on the stack, the size of the array is an instruction to the compiler;
    this is not dynamic allocation, so the size has to be a constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a potential problem here: the size of the array is mentioned twice,
    once in the declaration and then again in the `for` loop. If you use two different
    values, then you may initialize too few items, or you could potentially access
    memory outside the array. The ranged `for` syntax allows you to get access to
    each item in the array; the compiler can determine the size of the array and will
    use this in the ranged `for` loop. In the following code, there is a deliberate
    mistake that shows an issue with array sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The size of the array and the range of the first `for` loop do not agree and
    consequently the last item will not be initialized. The ranged `for` loop, however,
    will loop through all five items and so will print out some random value for the
    value of the last value. What if the same code is used but the `squares` array
    is declared to have three items? It depends on the compiler you are using and
    whether you are compiling a debug build, but clearly you will be writing to memory
    *outside* of that allocated to the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some ways to mitigate these issues. The first one has been mentioned
    in an earlier chapter: declare a constant for the size of the array and use that
    whenever your code needs to know the array size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The array declaration must have a constant for the size, and that is managed
    by using the `sq_size` constant variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also want to calculate the size of an already allocated array. The
    `sizeof` operator, when applied to an array, returns the size in bytes of the
    *entire* array, so you can determine the size of the array by dividing this value
    by the size of a single item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is safer code, but clearly it is verbose. The C runtime library contains
    a macro called `_countof` that performs this calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Function parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As illustrated, there is an automatic conversion of an array to the appropriate
    pointer type and this occurs if you pass an array to a function, or return it
    from a function. This decay to a dumb pointer means that other code can make no
    assumption about an array size. A pointer could point to memory allocated on the
    stack where the memory lifetime is determined by the function, or a global variable
    where the memory lifetime is that of the program, or it could be to memory that
    is dynamically allocated and the memory is determined by the programmer. There
    is nothing in a pointer declaration that indicates the type of memory or who is
    responsible for the deallocation of the memory. Nor is there any information in
    a dumb pointer of how much memory the pointer points to. When you write code using
    pointers, you have to be disciplined about how you use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function can have an array parameter, but this means a lot less than it appear
    to indicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will check that each member of the array has a value between
    the minimum and maximum values allowed. There are four tires in use at any one
    time on a car, so the function *should* be called with an array of four values.
    The problem is that although it appears that the compiler *should* check that
    the array passed to the function is the appropriate size, it doesn''t. You can
    call this function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Of course, it should have been obvious to the developer that a truck is not
    a car, and so this developer should not have written this code, but the usual
    advantage of a compiled language is that the compiler will perform some *sanity
    checks* for you. In the case of array parameters, it won't.
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that the array is passed as a pointer, so although the parameter
    appears to be a built-in array, you cannot use facilities you are used to using
    with arrays like ranged `for`. In fact, if the `safe_car` function calls `sizeof(tire_pressures)`,
    it will get the size of a double pointer and not 16, the size in bytes of a four
    `int` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'This *decay to a pointer* feature of array parameters means that functions
    will only ever know the size of an array parameter if you explicitly tell it the
    size. You can use an empty pair of square brackets to indicate that the item should
    be passed an array, but it really is just the same as a pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the function has a parameter that indicates the size of the array. The
    preceding function is exactly the same as declaring the first parameter to be
    a pointer. The following is not an overload of the function; it is the *same*
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The important point is that when you pass an array to a function, the *first
    dimension* of the array is treated as a pointer. So far arrays have been single
    dimensional, but they may have more than one dimension.
  prefs: []
  type: TYPE_NORMAL
- en: Multidimensional arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arrays can be multidimensional and to add another dimension you add another
    set of square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first example creates an array of two integers, the second creates a two-dimensional
    array with 12 integers arranged so that there are four rows of three columns.
    Of course, *row* and *column* are arbitrary and treat the two-dimensional array
    like a conventional spreadsheet table, but it helps to visualize how the data
    is arranged in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are square brackets around every dimension. C++ is different
    to other languages in this respect, so a declaration of `int x[10,10]` will be
    reported as an error by the C++ compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initializing multidimensional arrays involves a pair of braces and the data
    in the order that it will be used to initialize the dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the values having the highest digit reflect the left-most
    index and the lower digit reflect, the right-most index (in both cases, one more
    than the actual index). Clearly, you can split this over several lines and use
    whitespace to group values together to make this more readable. You can also use
    nested braces. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you read the dimensions going left to right, you can read the initialization
    going into deeper levels of nesting. There are four rows, so within the outer
    braces there are four sets of nested braces. There are three columns, and so within
    the nested braces there are three initialization values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nested braces are not just a convenience for formatting your C++ code, because
    if you provide an empty pair of braces the compiler will use the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, the second-row items are initialized to 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you increase the dimensions, the principle applies: increase the nesting
    for the right most dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is four rows of three columns of pairs (as you can see, when the dimensions
    increase it becomes apparent that the terms **rows** and **columns** are largely
    arbitrary).
  prefs: []
  type: TYPE_NORMAL
- en: 'You access items using the same syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In terms of the memory layout, the compiler interprets the syntax in the following
    way. The first index determines the offset from the beginning of the array in
    chunks of six integers (3 * 2), the second index indicates the offset within one
    of these six integer *chunks* itself in chunks of two integers, and the third
    index is the offset in terms of individual integers. Thus `[3][2][0]` is *(3 *
    6) + (2 * 2) + 0 = 22* integers from the beginning, treating the first integer
    as index zero.
  prefs: []
  type: TYPE_NORMAL
- en: A multidimensional array is treated as arrays of arrays, so the type of each
    "row" is `int[3][2]` and we know from the declaration that there are four of them.
  prefs: []
  type: TYPE_NORMAL
- en: Passing multidimensional arrays to functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can pass a multidimensional array to a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This compiles and you can access the parameter as a 4x5 array, assuming that
    this vehicle has four wheels with five nuts on each one.
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated earlier, when you pass an array, the first dimension will be treated
    as a pointer, so while you can pass a 4x5 array to this function, you can also
    pass a 2x5 array and the compiler will not complain. However, if you pass a 4x3
    array (that is, the second dimension is not the same as declared in the function),
    the compiler will issue an error that the array is incompatible. The parameter
    may be more accurately described as being `double row[][5]`. Since the size of
    the first dimension is not available, the function should be declared with the
    size of that dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This says that `nut_torques` is one or more "rows", each of which has five
    items. Since the array does not provide information about the number of rows it
    has, you should provide it. Another way to declare this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The brackets are important here, if you omit them and use `double *nut_torques[5]`,
    then it means the `*` will refer to the type in the array, that is, the compiler
    will treat `nut_torques` as a five-element array of `double*` pointers. We have
    seen an example of such an array before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `argv` parameter is an array of `char*` pointers. You can also declare the
    `argv` parameter as `char**` which has the same meaning.
  prefs: []
  type: TYPE_NORMAL
- en: In general, if you intend to pass arrays to a function it is best to use custom
    types, or use the C++ array types.
  prefs: []
  type: TYPE_NORMAL
- en: Using ranged `for` with multidimensional arrays is a bit more complicated than
    appears on first sight, and requires the use of a reference as explained in the
    section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using arrays of characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings will be covered in more detail in [Chapter 9](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml),
    *Using Strings*, but it is worth pointing out here that C strings are arrays of
    characters and are accessed through pointer variables. This means that if you
    want to manipulate strings, you must manipulate the memory that the pointer points
    to, and not manipulate the pointer itself.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following allocates two string buffers and it calls the `strcpy_s` function
    to initialize each with the same string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `strcpy_c` function will copy characters from the pointer given in the last
    parameter (until the terminating `NUL`), into the buffer given in the first parameter,
    whose maximum size is given in the second parameter. These two pointers are compared
    in the final line, and this will return a value of `false`. The problem is that
    the compare function is comparing the values of the pointers, not what the pointers
    point to. The two buffers have the same string, but the pointers are different,
    so `b` will be `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct way to compare strings is to compare the data character by character
    to see if they are equal. The C runtime provides `strcmp` that compares two string
    buffers character by character, and the `std::string` class defines a function
    called `compare` that will also perform such a comparison; however, be wary of
    the value returned from these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The return value is not a `bool` type indicating if the two strings are the
    same; it is an `int`. These compare functions carry out a lexicographical compare
    and return a negative value if the parameter (`s2` in this code) is greater than
    the operand (`s1`) lexicographically, and a positive number if the operand is
    greater than the parameter. If the two strings are the same, the function returns
    0\. Remember that a `bool` is `false` for a value of 0 and `true` for non-zero
    values. The standard library provides an overload for the `==` operator for `std::string`,
    so it is safe to write code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The operator will compare the strings contained in the two variables.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing buffer overruns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C runtime library for manipulating strings is notorious for allowing buffer
    overruns. For example, the `strcpy` function copies one string to another, and
    you get access to this through the `<cstring>` header, which is included by the
    `<iostream>` header. You may be tempted to write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that `strcpy` will copy all the character up to, and including
    the terminating `NULL` character and so you will be copying six characters into
    an array with space for only *five*. You could be taking a string from the user
    input (say, from a text box on a web page) and think that the array you have allocated
    is big enough, but a malicious user could provide an excessively long string deliberately
    bigger than the buffer so that it overwrites other parts of your program. Such
    *buffer overruns* have caused a lot of programs to be subjected to hackers taking
    control of servers, so much so that the C string functions have all been replaced
    by safer versions. Indeed, if you are tempted to type the preceding code, you''ll
    find that `strcpy` is available, but the Visual C++ compiler will issue an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have existing code that uses `strcpy`, and you need to make that code
    compile, you can define the symbol before `<cstring>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'An initial attempt to prevent this issue is to call `strncpy`, which will copy
    a specific number of characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The function will copy up to five characters and then stop. The problem is
    that the string to copy has five characters and so the result will be no `NULL`
    termination. The safer version of this function has a parameter that you can use
    to say how big the destination buffer is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: At runtime this will still cause a problem. You have told the function that
    the buffer is five characters in size and it will determine that this is not big
    enough to hold the six characters that you have asked it to copy. Rather than
    allowing the program to silently continue and the buffer overrun to cause problems,
    the safer string functions will call a function called the **constraint handler**
    and the default version will shut down the program on the rationale that a buffer
    overrun means that the program is compromised.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C runtime library strings functions were originally written to return the
    result of the function, the safer versions now return an error value. The `strncpy_s`
    function can also be told to truncate the copy rather than call the constraint
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The C++ `string` class protects you from such issues.
  prefs: []
  type: TYPE_NORMAL
- en: Using pointers in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pointers are clearly very important in C++, but as with any powerful feature,
    there are issues and dangers, so it is worth pointing out some of the major issues.
    A pointer points to a single location in memory, and the type of the pointer indicates
    how the memory location should be interpreted. The very most you can assume is
    the number of bytes at that position in memory is the size of the type of the
    pointer. That's it. This means that pointers are inherently unsafe. However, in
    C++ they are the quickest way to enable code within your process to access large
    amounts of data.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing out of bounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you allocate a buffer, whether on the stack or on the free store, and
    you get a pointer, there is little to stop you from accessing memory you have
    not allocated--either before or after the position of the buffer. This means that
    when you use pointer arithmetic, or indexed access on arrays, that you check carefully
    that you are not going to access data out of bounds. Sometimes the error may not
    be immediately obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: When you use indexing, you have to keep reminding yourself that arrays are indexed
    from zero so the highest index is the size of the array minus 1.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers to deallocated memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This applies to memory allocated on the stack and to memory dynamically allocated.
    The following is a poorly written function that returns a string allocated on
    the stack in a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code allocates a buffer of six characters and then initializes
    it with the five characters of the string literal `hello`, and the `NULL` termination
    character. The problem is that once the function finishes the stack frame is torn
    down so that the memory can be re-used, and the pointer will point to memory that
    could be used by something else. This error is caused by poor programming, but
    it may not be as obvious as in this example. If the function uses several pointers
    and performs a pointer assignment, you may not immediately notice that you have
    returned a pointer to a stack-allocated object. The best course of action is simply
    not to return raw pointers from functions, but if you do want to use this style
    of programming, make sure that the memory buffer is passed in through a parameter
    (so the function does not own the buffer) or is dynamically allocated and you
    are passing ownership to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: This leads on to another issue. If you call `delete` on a pointer and then later
    in your code, try to access the pointer, you will be accessing memory that is
    potentially being used by other variables. To alleviate this problem, you can
    get into the habit of assigning a pointer to `null_ptr` when you delete it and
    check for `null_ptr` before using a pointer. Alternatively, you can use a smart
    pointer object which will do this for you. Smart pointers will be covered in [Chapter
    6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: Converting pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can either have typed pointers, or the `void*` pointer. Typed pointers will
    access the memory as if it is the specified type (this has interesting consequences
    when you have inheritance with classes, but that will be left for [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes* and [Chapter 7](2f4184a2-fec8-4119-a155-389ab43e9f5b.xhtml), *Introduction
    to Object-Oriented Programming*). Thus, if you cast a pointer to a different type
    and dereference it, the memory will be treated as containing the cast type. It
    rarely makes sense to do this. The `void*` pointer cannot be dereferenced, so
    you can never access data through a `void*` pointer, to access the data you have
    to cast the pointer. The whole reason for the `void*` pointer type is that it
    can point to anything. In general, `void*` pointers should only be used when the
    type does not matter to that function. For example, the C `malloc` function returns
    a `void*` pointer because the function merely allocates memory; it does not care
    what that memory will be used for.
  prefs: []
  type: TYPE_NORMAL
- en: Constant pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pointers can be declared as `const` which, depending on where you apply it,
    means that the memory the pointer points to is read-only through the pointer,
    or the value of the pointer is read-only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, `ptc` is a pointer to constant `char`, that is, although you can change
    what `ptc` points to, and you can read what it points to, you cannot use it to
    change the memory. On the other hand, `cp` is a constant pointer, which means
    you can both read and write the memory which the pointer points to, but you cannot
    change where it points to. It is typical to pass the `const char*` pointers to
    functions because the functions do not know where the string has been allocated
    or the size of the buffer (the caller may pass a literal which cannot be changed).
    Note that there is no `const*` operator so `char const*` is treated as `const
    char*`, a pointer to a constant buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make a pointer constant, change it, or remove it using casts. The following
    does some fairly pointless changing around of the `const` keyword to prove the
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The pointers `cp1` and `cp2` can be used to change the memory they point to,
    but once assigned neither can point to other memory. The first `const_cast` casts
    away the `const`-ness to a pointer that can be changed to point to other memory,
    but cannot be used to alter that memory, `ptc`. The second `const_cast` casts
    away the `const`-ness of `ptc` so that the memory can be changed through the pointer,
    `cp2`.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the type pointed to
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `static_cast` operator is used to convert with a compile time check, but
    not a runtime check, so this means that the pointers must be related. The `void*`
    pointer can be converted to any pointer, so the following compiles and makes sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The C `malloc` function returns a `void*` pointer so you have to convert it
    to be able to use the memory. (Of course, the C++ `new` operator removes the need
    for such casting.) The built-in types are not "related" enough for `static_cast`
    to convert between pointer types, so you cannot use `static_cast` to convert an
    `int*` pointer to a `char*` pointer, even though `int` and `char` are both integer
    types. For custom types that are related through inheritance, you can cast pointers
    using `static_cast`, but there is no runtime check that the cast is correct. To
    cast with runtime checks you should use `dynamic_cast`, and more details will
    be given in [Chapters 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*
    and [Chapter 7](2f4184a2-fec8-4119-a155-389ab43e9f5b.xhtml), *Introduction to
    Object-Oriented Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `reinterpret_cast` operator is the most flexible, and dangerous, of the
    cast operators because it will convert between any pointer types without any type
    checks. It is inherently unsafe. For example, the following code initializes a
    wide character array with a literal. The array `wc` will have six characters,
    `hello` followed by `NULL`. The `wcout` object interprets a `wchar_t*` pointer
    as a pointer to the first character in a `wchar_t` string, so inserting `wc` will
    print the string (every character until the `NUL`). To get the actual memory location,
    you have to convert the pointer to an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if you insert a `wchar_t` into the `wcout` object, it will print
    the character, not the numeric value. So, to print out the codes for the individual
    characters, we need to cast the pointer to a suitable integer pointer. This code
    assumes that a `short` is the same size as a `wchar_t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Allocating memory in code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ defines two operators, `new` and `delete`, that allocate memory from the
    free store and release memory back into the free store.
  prefs: []
  type: TYPE_NORMAL
- en: Allocating individual objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `new` operator is used with the type to allocate memory, and it will return
    a typed pointer to that memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `new` operator will call the *default constructor* for custom types for
    every object it creates (as explained in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*). Built-in types do not have constructors, so instead a type initialization
    will occur and this will usually initialize the object to zero (in this example,
    a zero integer).
  prefs: []
  type: TYPE_NORMAL
- en: In general, you should not use memory allocated for built-in types without explicitly
    initializing it. In fact, in Visual C++ the debug version of the `new` operator
    will initialize memory to a value of `0xcd` for every byte, as a visual reminder
    in the debugger that you have not initialized the memory. For custom types, it
    is left to the author of the type to initialize allocated memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important that when you have finished with memory that you return it
    back to the free store so that the allocator can reuse it. You do this by calling
    the `delete` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: When you delete a pointer, the **destructor** for the object is called. For
    built-in types, this does nothing. It is good practice to initialize a pointer
    to `nullptr`, after you have deleted it, and if you use the convention of checking
    the value of a pointer before using it, this will protect you from using a deleted
    pointer. The C++ standard says that the `delete` operator will have no effect
    if you delete a pointer that has a value of `nullptr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ allows you to initialize a value at the time you call the `new` operator,
    in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: For a custom type, the `new` operator will call a constructor on the type; for
    a built in type, the end result is the same, and is carried out by initializing
    the item to the value provided. You can also use initialized list syntax, as shown
    in the second line in the preceding code. It is important to note that the initialization
    is the memory pointed to, not the pointer variable.
  prefs: []
  type: TYPE_NORMAL
- en: Allocating arrays of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also create arrays of objects in dynamic memory using the `new` operator.
    You do this by providing the number of items you want created in a pair of square
    brackets. The following code allocates memory for two integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The operator returns a pointer to the type allocated, and you can use pointer
    arithmetic or array indexing to access the memory. You cannot initialize the memory
    in the `new` statement; you have to do that after creating the buffer. When you
    use `new` to create a buffer for more than one object, you must use the appropriate
    version of the `delete` operator: the `[]` is used to indicate that more than
    one item is deleted and the destructor for each object will be called. It is important
    that you always use the right version of `delete` appropriate to the version of
    `new` used to create the pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom types can define their own operator `new` and operator `delete` for individual
    objects, as well as operator `new[]` and operator `delete[]` for arrays of objects.
    The custom type author can use these to use custom memory allocation schemes for
    their objects.
  prefs: []
  type: TYPE_NORMAL
- en: Handling failed allocations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the `new` operator cannot allocate the memory for an object, it will throw
    the `std::bad_alloc` exception and the pointer returned will be `nullptr`. Exceptions
    are covered in [Chapter 10](5a2f36d4-7d0b-4f2d-ae7c-f9e51f5d7dc4.xhtml), *Diagnostics
    and Debugging*, so only a brief outline of the syntax will be given here. It is
    important that you check for failure to allocate memory in production code. The
    following code shows how to guard the allocation so that you can catch the `std::bad_alloc`
    exception and handle it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If any code in the `try` block throws an exception control it is passed to the
    `catch` clause, ignoring any other code that has not been executed yet. The `catch`
    clause checks the type of the exception object and if it is the correct type (in
    this case an allocation fault), it creates a reference to that object and passes
    control to the `catch` block, and the scope of the exception reference is this
    block. In this example, the code merely prints an error, but you would use it
    to take action to ensure that the memory allocation failure does not affect subsequent
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Using other versions of the new operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Further, a custom type can define a placement operator `new`, which allows you
    to provide one or more parameters to the custom `new` function. The syntax of
    the placement `new` is to provide the placement fields through parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The C++ Standard Library version of the `new` operator provides a version that
    can take the constant `std::nothrow` as a placement field. This version will not
    throw an exception if the allocation fails, instead, the failure can only be assessed
    from the value of the returned pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The parentheses before the type are used to pass placement fields. If you use
    parentheses after the type, these will give a value to initialize the object if
    the allocation is successful.
  prefs: []
  type: TYPE_NORMAL
- en: Memory lifetime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The memory allocated by `new` will remain valid until you call `delete`. This
    means that you may have memory with long lifetimes, and the code may be passed
    around various functions in your code. Consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates a pointer and initializes the memory it points to and then
    passes the pointer to a function, which itself returns a pointer. Since the `p1`
    pointer is no longer needed, it is deleted and assigned to `nullptr` so that it
    cannot be used again. This code looks fine, but the problem is what do you do
    with the pointer returned by the function? Imagine that the function simply manipulates
    the data pointed to by the pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In effect, calling `do_something` creates a copy of a pointer, but not a copy
    of what it points to. This means that when the `p1` pointer is deleted, the memory
    it points to is no longer available, and so the pointer `p2` points to the invalid
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: This problem can be addressed using a mechanism called **Resource Acquisition
    Is Initialization** (**RAII**), which means using the features of C++ objects
    to manage resources. RAII in C++ needs classes and in particular, copy constructors
    and destructors. A smart pointer class can be used to manage a pointer so that
    when it is copied, the memory it points to is also copied. A destructor is a function
    that is called automatically when the object goes out of scope and so a smart
    pointer can use this to free memory. Smart pointers and destructors will be covered
    in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: The Windows SDK and pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Returning a pointer from a function has its inherent dangers: the responsibility
    for the memory is passed to the caller, and the caller must ensure that the memory
    is appropriately de-allocated, otherwise this could cause a memory leak with a
    corresponding loss of performance. In this section, we will look at some ways
    that the Window''s **Software Development Kit** (**SDK**) provides access to memory
    buffers and learn some techniques used in C++.'
  prefs: []
  type: TYPE_NORMAL
- en: First, it is worth pointing out that any function in the Windows SDK that returns
    a string, or has a string parameter, will come in two versions. The version suffixed
    with `A` indicates that the function uses ANSI strings, and the `W` version will
    use wide character strings. For the purpose of this discussion, it is easier to
    use the ANSI functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GetCommandLineA` function has the following prototype (taking into account
    the Windows SDK `typedef`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: All Windows functions are defined as using the `__stdcall` calling convention.
    Usually, you will see the `typedef` of `WINAPI` used for the `__stdcall` calling
    convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function can be called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are making no effort to do anything about freeing the returned
    buffer. The reason is that the pointer points to memory that lives the lifetime
    of your process, so you *should not* release it. Indeed, if you were to release
    it, how would you do it? You cannot guarantee that the function was written with
    the same compiler, or the same libraries that you are using, so you cannot use
    the C++ `delete` operator or the C `free` function.
  prefs: []
  type: TYPE_NORMAL
- en: When a function returns a buffer, it is important to consult the documentation
    to see who allocated the buffer, and who should release it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example is `GetEnvironmentStringsA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This also returns a pointer to a buffer, but this time the documentation is
    clear that after using the buffer you should release it. The SDK provides a function
    to do this called `FreeEnvironmentStrings`. The buffer contains one string for
    each environment variable in the form `name=value` and each string is terminated
    by a `NUL` character. The last string in the buffer is simply a `NUL` character,
    that is, there are two `NUL` characters at the end of the buffer. These functions
    can be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `strlen` function is part of the C runtime library and it returns the length
    of a string. You do not need to know how the `GetEnvironmentStrings` function
    allocates the buffer because the `FreeEnvironmentStrings` will call the correct
    deallocation code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are cases when the developer has the responsibility of allocating a buffer.
    The Windows SDK provides a function called `GetEnvironmentVariable` to return
    the value of a named environment variable. When you call this function, you do
    not know if the environment variable is set, or if it is set, or how big its value
    is, so this means that you will most likely have to allocate some memory. The
    prototype of the function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: There are two parameters that are pointers to C strings. There is a problem
    here, a `char*` pointer could be passing *in* a string to the function, or it
    could be used to pass in a buffer for a string to be returned *out*. How do you
    know what a `char*` pointer is intended to be used for?
  prefs: []
  type: TYPE_NORMAL
- en: You are given a clue with the full parameter declaration. The `lpName` pointer
    is marked `const` so the function will not alter the string it points to; this
    means that it is an *in* parameter. This parameter is used to pass in the name
    of the environment variable you want to obtain. The other parameter is simply
    a `char*` pointer, so it could be used to pass a string *in* to the function or
    *out*, or indeed, both *in* and *out*. The only way to know how to use this parameter
    is to read the documentation. In this case, it is an *out* parameter; the function
    will return the value of the environment variable in `lpBuffer` if the variable
    exists, or if the variable does not exist, the function will leave the buffer
    untouched and return the value 0\. It is your responsibility to allocate this
    buffer in whatever way you see fit, and you pass the size of this buffer in the
    last parameter, `nSize`.
  prefs: []
  type: TYPE_NORMAL
- en: The function's return value has two purposes. It is used to indicate that an
    error has occurred (just one value, 0, which means you have to call the `GetLastError`
    function to get the error), and it is also used to give you information about
    the buffer, `lpBuffer`. If the function succeeds, then the return value is the
    number of characters copied into the buffer excluding the `NULL` terminating character.
    However, if the function determines that the buffer is too small (it knows the
    size of the buffer from the `nSize` parameter) to hold the environment variable
    value, no copy will happen, and the function will return the required size of
    the buffer, which is the number of characters in the environment variable including
    the `NULL` terminator.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common way to call this function is to call it twice, first with a zero-sized
    buffer and then use the return value to allocate a buffer before calling it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In general, as with all libraries, you have to read the documentation to determine
    how the parameters are used. The Windows documentation will tell you if a pointer
    parameter is in, out, or in/out. It will also tell you who owns the memory and
    whether you have the responsibility for allocating and/or freeing the memory.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you see a pointer parameter for a function, take special care to check
    the documentation as to what the pointer is used for and how the memory is managed.
  prefs: []
  type: TYPE_NORMAL
- en: Memory and the C++ Standard Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ Standard Library provides various classes to allow you to manipulate
    collections of objects. These classes, called the **Standard Template Library**
    (**STL**), provide a standard way to insert items into collection objects and
    ways to access the items and iterate through entire collections (called iterators).
    The STL defines collection classes that are implemented as queues, stacks, or
    as vectors with random access. These classes will be covered in depth [Chapter
    8](b2eeebba-fe22-4565-a40f-6d0bfaee813b.xhtml), *Using the Standard Library Containers*,
    so in this section we will limit the discussion to just two classes that behave
    like C++ built in arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Standard Library arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C+ Standard Library provides two containers that give random access via
    an indexer to the data. These two containers also allow you to access the underlying
    memory and since they guarantee to store the items sequentially and contiguous
    in memory, they can be used when you are required to provide a pointer to a buffer.
    These two types are both templates, which means that you can use them to hold
    built-in and custom types. These two collection classes are `array` and `vector`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the stack-based array class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `array` class is defined in the `<array>` header file. The class allows
    you to create fixed sized arrays on the stack and, as with built-in arrays, they
    cannot shrink or expand at runtime. Since they are allocated on the stack, they
    do not require a call to a memory allocator at runtime, but clearly, they should
    be smaller than the stack frame size. This means that an `array` is a good choice
    for small arrays of items. The size of an `array` must be known at compile time
    and it is passed as a template parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the first template parameter in the angle brackets (`<>`) is
    the type of each item in the array, and the second parameter is the number of
    items. This code initializes the array with an initialize list, but note that
    you still have to provide the size of the array in the template. This object will
    work like a built-in array (or indeed, any of the Standard Library containers)
    with ranged `for`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason is that `array` implements the `begin` and `end` functions that
    are required for this syntax. You can also use indexing to access items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `size` function will return the size of the array and the square bracket
    indexer gives random access to members of the array. You can access memory outside
    of the bounds of the array, so for the previously defined array that has four
    members, you can access `arr[10]`. This may cause unexpected behavior at runtime,
    or even some kind of memory fault. To guard against this, the class provides a
    function, `at`, which will perform a range check and if the index is out of range
    the class will throw the C++ exception `out_of_range`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main advantage of using an `array` object is that you get compile time
    checks to see if you are inadvertently passing the object to a function as a dumb
    pointer. Consider this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'At runtime, the function does not know the size of the buffer passed to it,
    and in this case the documentation says that you must pass a buffer with 10 `int`
    type variables, but, as we have seen, C++ allows a built-in array to be used as
    a pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no compiler check, nor any runtime check to catch this error. The
    `array` class will not allow such an error to happen because there is no automatic
    conversion into a dumb pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'If you really insist in obtaining a dumb pointer, you can do this and be guaranteed
    to have access to the data as a contiguous block of memory where the items are
    stored sequentially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The class is not just a wrapper around a built-in array, it also provides some
    additional functionality. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Using the dynamically allocated vector class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Standard Library also provides the `vector` class in the `<vector>` header.
    Again, this class is a template, so you can use it with built-in and custom types.
    However, unlike `array`, the memory is dynamically allocated, which means that
    a `vector` can be expanded or shrunk at runtime. The items are stored contiguously
    so you can access the underlying buffer by calling the `data` function or accessing
    the address of the first item (to support resizing the collection, the buffer
    may change, so such pointers should only be used temporarily). And, of course,
    as with `array`, there is no automatic conversion to a dumb pointer. The `vector`
    class provides indexed random access with square bracket syntax and a range check
    with the `at` function. The class also implements the methods to allow the container
    to be used with Standard Library functions and with ranged `for`.
  prefs: []
  type: TYPE_NORMAL
- en: The `vector` class has more flexibility than the `array` class because you can
    insert items, and move items around, but this does come with some overhead. Because
    instances of the class allocate memory dynamically at runtime there is a cost
    of using an allocator and there is some extra overhead in initialization and destruction
    (when the `vector` object goes out of scope). Objects of the `vector` class also
    take more memory than the data it holds. For this reason, it is not suitable for
    small numbers of items (when `array` is a better choice).
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A reference is an alias to an object. That is, it is another name for the object,
    and so access to the object is the same through a reference as it is through the
    object''s variable name. A reference is declared using a `&` symbol on the reference
    name and it is initialized and accessed in exactly the same way as a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In this code, a variable is declared and initialized, then a pointer is initialized
    to point to this data, and a reference is initialized as an alias for the variable.
    Reference `ri1` is initialized with an assignment operator, whereas reference
    `ri2` is initialized using initializer list syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The pointer and reference have two different meanings. The reference is not
    initialized to the value of the variable, the variable's data; it is an alias
    for the variable name.
  prefs: []
  type: TYPE_NORMAL
- en: Wherever the variable is used, the reference can be used; whatever you do to
    the reference is actually the same as performing the same operation on the variable.
    A pointer points to data, so you can change the data by dereferencing the pointer,
    but equally so, you can make the pointer point to any data and change that data
    by dereferencing the pointer (this is illustrated in the last two lines of the
    preceding code). You can have several aliases for a variable, and each must be
    initialized to the variable at the declaration. Once declared, you cannot make
    a reference refer to a different object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Since a reference is an alias for another variable, it cannot exist without
    being initialized to a variable. Likewise, you cannot initialize it to anything
    other than a variable name, so there is no concept of a *null reference*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once initialized, a reference is only ever an alias to the one variable. Indeed,
    when you use a reference as an operand to any operator, the operation is performed
    on the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, `rx` is an alias to the variable `x`, so the assignment in the
    last line simply assigns `x` with the value of `y`: the assignment is performed
    on the aliased variable. Further, if you take the address of a reference, you
    are returned the address of the variable it references. While you can have a reference
    to an array, you cannot have an array of references.'
  prefs: []
  type: TYPE_NORMAL
- en: Constant references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reference used so far allows you to change the variable it is an alias for,
    therefore it has lvalue semantics. There are also `const` lvalue references, that
    is, a reference to an object that you can read, but not write to.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with `const` pointers, you declare a `const` reference using the `const`
    keyword on a lvalue reference. This essentially makes the reference read-only:
    you can access the variable''s data to read it, but not to change it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Returning references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes an object will be passed to a function and the semantics of the function
    is that the object should be returned. An example of this is the `<<` operator
    used with the stream objects. Calls to this operator are *chained*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This is actually a series of calls to functions called `operator<<`, one that
    takes a `const char*` pointer, and another that takes an `int` parameter. These
    functions also have an `ostream` parameter for the stream object that will be
    used. However, if this is simply an `ostream` parameter then it would mean that
    a copy of the parameter would be made, and the insertion would be performed on
    the copy. Stream objects often use buffering, so changes to a copy of a stream
    object may not have the desired effect. Further, to enable the *chaining* of the
    insertion operators, the insertion functions will return the stream object passed
    as a parameter. The intention is to pass the same stream object through multiple
    function calls. If such a function returned an object then it would be a copy
    and not only would this means that a series of insertions would involve lots of
    copies being made, these copies would also be temporary and so any changes to
    the stream (for example, manipulators such as `std::hex`) would not persist. To
    address these issues, references are used. A typical prototype of such a function
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly you have to be careful about returning a reference since you have to
    ensure that the object lifetime lasts as long as the reference. This `operator<<`
    function will return the reference passed in the first parameter, but in the following
    code a reference is returned to an automatic variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `string` object only lives as long as the function,
    so the reference returned by this function will refer to an object that does not
    exist. Of course, you can return a reference to a `static` variable declared in
    a function.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a reference from a function is a common idiom, but whenever you consider
    doing this make sure that the lifetime of the aliased variable is not the scope
    of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Temporaries and references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The lvalue references must refer to a variable, but C++ has some odd rules
    when it comes to `const` references declared on the stack. If the reference is
    a `const`, the compiler will extend the lifetime of a temporary for the lifetime
    of the reference. For example, if you use the initialization list syntax, the
    compiler will create a temporary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the compiler will create a temporary `int` and initialize it
    to a value and then alias it to the `cri` reference (it is important that this
    reference is `const`). The temporary is available through the reference while
    it is in scope. This may look a little odd, but consider using a `const` reference
    in this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call this function with a `string` variable, a variable that will explicitly
    convert to a `string` or with a `string` literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In most cases, you'll not want to have a `const` reference to a built-in type,
    but with custom types where there will be an overhead in making copies there is
    an advantage and, as you can see here, the compiler will fall back to creating
    a temporary if required.
  prefs: []
  type: TYPE_NORMAL
- en: The rvalue references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++11 defines a new type of reference, rvalue references. Prior to C++11, there
    was no way that code (like an assignment operator) could tell if the rvalue passed
    to it was a temporary object or not. If such a function is passed a reference
    to an object, then the function has to be careful not to change the reference
    because this would affect the object it refers to. If the reference is to a temporary
    object, then the function can do what it likes to the temporary object because
    the object will not live after the function completes. C++11 allows you to write
    code specifically for temporary objects, so in the case of the assignment, the
    operator for temporary objects can just *move* the data from the temporary into
    the object being assigned. In contrast, if the reference is not to a temporary
    object then the data will have to be *copied*. If the data is large, then this
    prevents a potentially expensive allocation and copy. This enables so-called *move
    semantics*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this rather contrived code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The three functions return a `string` object. In the first two cases, the `string`
    has the lifetime of the program and so a reference can be returned. In the last
    function, the function returns a string literal, so a temporary `string` object
    is constructed. All three can be used to provide a `string` value. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: All three can provide a string that can be used to assign a `string` object.
    The important point is that the first two functions return along a lived object,
    but the third function returns a temporary object, but these objects can be used
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'If these functions returned access to a large object, you would not want to
    pass the object to another function, so instead, in most cases, you''ll want to
    pass the objects returned by these functions as references. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The reference parameter prevents another copy of the string. However, this
    is just half of the story. The `use_string` function could manipulate the string.
    For example, the following function creates a new `string` from the parameter,
    but replaces the letters a, b, and o with an underscore (indicating the gaps in
    words without those letters, replicating what life would be like without donations
    of the blood types A, B, and O). A simple implementation would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The string object has an index operator (`[]`), so you can treat it like an
    array of characters, both reading the values of characters and assigning values
    to character positions. The size of the `string` is obtained through the `length`
    function, which returns an `unsigned int` (`typedef` to `size_t`). Since the parameter
    is a reference, it means that any change to the `string` will be reflected in
    the `string` passed to the function. The intention of this code is to leave other
    variables intact, so it first makes a copy of the parameter. Then on the copy,
    the code iterates through all of the characters changing the `a`, `b`, and `o`
    characters to an underscore before printing out the result.
  prefs: []
  type: TYPE_NORMAL
- en: This code clearly has a copy overhead--creating the `string`, `s`, from the
    reference, `rs`; but this is necessary if we want to pass strings like those from
    `get_global` or `get_static` to this function because otherwise the changes would
    be made to the actual global and `static` variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the temporary `string` returned from `get_temp` is another situation.
    This temporary object only exists until the end of the statement that calls `get_temp`.
    Thus, it is possible to make changes to the variable knowing that it will affect
    nothing else. This means that you can use move semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'There are just two changes here. The first is that the parameter is identified
    as an rvalue reference using the `&&` suffix to the type. The other change is
    that the changes are made on the object that the reference refers to because we
    know that it is a temporary and the changes will be discarded, so it will affect
    no other variables. Note that there are now *two* functions, overloads with the
    same name: one with an lvalue reference, and one with an rvalue reference. When
    you call this function, the compiler will call the right one according to the
    parameter passed to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that `get_global` and `get_static` return references to objects that
    will live the lifetime of the program, and for this reason the compiler chooses
    the `use_string` version that takes an lvalue reference. The changes are made
    on a temporary variable within the function, and this has a copy overhead. The
    `get_temp` returns a temporary object and so the compiler calls the overload of
    `use_string` that takes an rvalue reference. This function alters the object that
    the reference refers to, but this does not matter because the object will not
    last beyond the semicolon at the end of the line. The same can be said for calling
    `use_string` with a C-like string literal: the compiler will create a temporary
    `string` object and call the overload that has an rvalue reference parameter.
    In the final example in this code, a C++ `string` object is created on the stack
    and passed to `use_string`. The compiler sees that this object is an lvalue and
    potentially can be altered, so it calls the overload that takes an lvalue reference
    that is implemented in a way that only alters a temporary local variable in the
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: This example shows that the C++ compiler will detect when a parameter is a temporary
    object and will call the overload with an rvalue reference. Typically, this facility
    is used when writing *copy constructors* (special functions used to create a new
    custom type from an existing instance) and assignment operators so that these
    functions can implement the lvalue reference overload to copy the data from the
    parameter, and the rvalue reference overload to move the data from the temporary
    to the new object. Other uses are for writing custom types that are *move only*,
    where they use resources that cannot be copied, for example file handles.
  prefs: []
  type: TYPE_NORMAL
- en: Ranged for and references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an example of what you can do with references, it is worth looking at the
    ranged `for` facility in C++11\. The following code is quite straightforward;
    the array `squares` is initialized with the squares of 0 to 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler knows the size of the array so you can use ranged `for` to print
    out the values in the array. In the following, on each iteration, the local variable
    `j` is a copy of the item in the array. As a copy, it means that you can read
    the value, but any changes made to the variable will not be reflected to the array.
    So, the following code works as expected; it prints out the contents of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to change the values in the array, then you have to have access
    to the actual values, and not a copy. The way to do this in a ranged `for` is
    to use a reference as the loop variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Now, on every iteration, the `k` variable is an alias to an actual member in
    the array, so whatever you do to the `k` variable is actually performed on the
    array member. In this example, every member of the `squares` array is multiplied
    by 2\. You cannot use `int*` for the type of `k` because the compiler sees that
    the type of the items in the array is `int` and will use this as the loop variable
    in the ranged `for`. Since a reference is an alias for a variable, the compiler
    will allow a reference as the loop variable, and moreover, since the reference
    is an alias, you can use it to change the actual array member.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ranged `for` becomes interesting for multidimensional arrays. For example,
    in the following, a two-dimensional array is declared and an attempt is made to
    use nested loops using `auto` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Since a two-dimensional array is an array of arrays (each row is a one-dimensional
    array), the intention is to obtain each row in the outer loop and then in the
    inner loop access each item in the row. There are several issues with this approach,
    but the immediate issue is that this code will not compile.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler will complain about the inner loop, saying that it cannot find
    a `begin` or `end` function for the type `int*`. The reason is that ranged `for`
    uses iterator objects and for arrays it uses the C++ Standard Library functions,
    `begin` and `end,` to create these objects. The compiler will see from the `arr`
    array in the outer ranged for that each item is an `int[3]` array, and so in the
    outer `for` loop the loop variable will be a *copy* of each element, in this case
    an `int[3]` array. You cannot copy arrays like this, so the compiler will provide
    a pointer to the first element, an `int*`, and this is used in the inner `for`
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler will attempt to obtain iterators for `int*`, but this is not possible
    because an `int*` contains no information about how many items it points to. There
    is a version of `begin` and `end` defined for `int[3]` (and all sizes of arrays)
    but not for `int*`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple change makes this code compile. Simply turn the `row` variable into
    a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The reference parameter indicates that an alias is used for the `int[3]` array
    and, of course, an alias is the same as the element. Using `auto` hides the ugliness
    of what is actually going on. The inner loop variable is, of course, an `int`
    since this is the type of the item in the array. The outer loop variable is in
    fact `int (&)[3]`. That is, it is a reference to an `int[3]` (the parentheses
    used to indicate that it references an `int[3]` and is not an array of `int&`).
  prefs: []
  type: TYPE_NORMAL
- en: Using pointers in practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common requirement is to have a collection that can be an arbitrary size and
    can grow and shrink at runtime. The C++ Standard Library provides various classes
    to allow you to do this, as will be described in [Chapter 8](b2eeebba-fe22-4565-a40f-6d0bfaee813b.xhtml),
    *Using the Standard Library Containers*. The following example illustrates some
    of the principles of how these standard collections are implemented. In general,
    you should use the C++ Standard Library classes rather than implementing your
    own. Further, the Standard Library classes *encapsulate* code together in a class
    and since we have not covered classes yet, the following code will use functions
    that potentially can be called incorrectly. So, you should regard this example
    as just that, example code. A linked list is a common data structure. These are
    typically used for queues where the order of items is important. For example,
    a first-in-first-out queue where tasks are performed in the order that they are
    inserted in the queue. In this example, each task is represented as a structure
    that contains the task description and a pointer to the next task to be performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the pointer to the next task is `nullptr` then this means the current task
    is the last task in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall from the last chapter that you access members of a structure using the
    dot operator through an instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the compiler will create a `string` object initialized with the
    string literal `do something` and assign it to the `description` member of the
    instance called `item`. You can also create a `task` on the free store using the
    `new` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the members of the object have to be accessed through a pointer,
    and C++ provides the `->` operator to give you this access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Here the `description` member is assigned to the string. Note that since `task`
    is a structure there are no access restrictions, something that is important with
    classes and described in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new folder under `C:\Beginning_C++` called `Chapter_04`. Start Visual
    C++ and create a C++ source file and save it to the folder you just created, as
    `tasks.cpp`. Add a simple `main` function without parameters, and provide support
    for input and output using C++ streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Above the `main` function, add a definition for the structure that represents
    a task in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This has two members. The guts of the object is the `description` item. In our
    example, executing a task will involve printing the `description` item to the
    console. In an actual project, you'll most likely have many data items associated
    with the task, and you may even have member functions to execute the task, but
    we have not yet covered member functions; that's a topic for [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: The plumbing of the linked list is the other member, `pNext`. Note that the
    `task` structure has not been completely defined at the point that the `pNext`
    member is declared. This is not a problem because `pNext` is a *pointer*. You
    cannot have a data member of an undefined, or a partially defined type, because
    the compiler will not know how much memory to allocate for it. You can have a
    pointer member to a partially defined type because a pointer member is the same
    size irrespective of what it points to.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we know the first link in a list, then we can access the whole list and,
    in our example, this will be a global variable. When constructing the list, the
    construction functions need to know the end of the list so that they can attach
    a new link to the list. Again, for convenience, we will make this a global variable.
    Add the following pointers after the definition of the `task` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'As it stands, the code does nothing, but it is a good opportunity to compile
    the file to test that there are no typos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Adding a task object to the list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next thing to do to provide the code is to add a new task to the task list.
    This needs to create a new `task` object and initialize it appropriately and then
    add it to the list by altering the last link in the list to point to the new link.
  prefs: []
  type: TYPE_NORMAL
- en: 'Above the `main` function, add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter is a `const` reference because we will not change the parameter
    and we do not want the overhead of a copy being made. The first thing this function
    must do is create a new link, so add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates a new link on the free store, and the following lines
    initialize it. This is not necessarily the best way of initializing such an object,
    and a better mechanism, a constructor, will be covered in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*. Notice that the `pNext` item is initialized to `nullptr`; this indicates
    that the link will be at the end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final part of this function adds the link to the list, that is, it makes
    the link the last in the list. However, if the list is empty, it means that this
    link is also the *first* link in the list. The code must perform both actions.
    Add the following code to the end of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The first line checks to see if the list is empty. If `pHead` is `nullptr`,
    it means that there are no other links and so the current link is the first link,
    and so both `pHead` and `pCurrent` are initialized to the new link pointer. If
    there are existing links in the list, the link has to be added to the last link,
    so in the `else` clause the first line makes the last link point to the new link
    and the second line initializes `pCurrent` with the new link pointer, making the
    new link the last link for any new insertions to the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The items are added to the list by calling this function in the `main` function.
    In this example, we will queue the tasks to wallpaper a room. This involves removing
    the old wallpaper, filling any holes in the wall, sizing the wall (painting it
    with diluted paste to make the wall sticky), and then hanging the pasted wallpaper
    to the wall. You have to do these tasks in this order, you cannot change the order,
    so these tasks are ideal for a linked list. In the `main` function add the following
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: After the last line, the list has been created. The `pHead` variable points
    to the first item in the list and you can access any other item in the list simply
    by following the `pNext` member from one link to the next.
  prefs: []
  type: TYPE_NORMAL
- en: You can compile the code, but there is no output. Worse, as the code stands,
    there is a memory leak. The program has no code to `delete` the memory occupied
    by the `task` objects created on the free store by the `new` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting the task list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Iterating through the list is simple, you follow the `pNext` pointer from one
    link to the next. Before doing this, let''s first fix the memory leak introduced
    in the last section. Above the `main` function, add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: This function will remove the link at the beginning of the list and make sure
    that the `pHead` pointer points to the next link, which will become the new beginning
    of the list. The function returns a `bool` value indicating if there are any more
    links in the list. If this function returns `false` then it means the entire list
    has been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line checks to see if this function has been called with an empty
    list. Once we are reassured that the list has at least one link, we create a temporary
    copy of this pointer. The reason is that the intention is to delete the first
    item and make `pHead` point to the next item, and to do that we have to do those
    steps in reverse: make `pHead` point to the next item and then delete the item
    that `pHead` previously pointed to.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete the entire list, you need to iterate through the links, and this
    can be carried out using a `while` loop. Below the `remove_head` function, add
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: To delete the entire list, and address the memory leak, add the following line
    to the bottom of the main function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: You can now compile the code, and run it. However, you'll see no output because
    all the code does is create a list and then delete it.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating the task list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to iterate the list from the first link following each `pNext`
    pointer until we get to the end of the list. For each link accessed, the task
    should be executed. Start by writing a function that performs the execution by
    printing out the description of the task and then returning a pointer to the next
    task. Just above the `main` function, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter here is marked as `const` because we will not change the `task`
    object pointed to by the pointer. This indicates to the compiler that if the code
    does try to change the object there is an issue. The first line checks to make
    sure that the function is not called with a null pointer. If it was then the following
    line would dereference an invalid pointer and cause a memory access fault. The
    last line returns the pointer to the next link (which could be `nullptr` for the
    last link in the list), so that the function can be called in a loop. After this
    function, add the following to iterate the entire list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'This code starts at the beginning, `pHead`, and calls `execute_task` on each
    link in the list until the function returns a `nullptr`. Add a call to this function
    towards the end of the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now compile and run the code. The result will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Inserting items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the advantages of linked lists is that you can insert items into the
    list by only allocating one new item and changing the appropriate pointers to
    point to it, and make it point to the next item in the list. Contrast this to
    allocating an array of `task` objects; if you want to insert a new item somewhere
    in the middle, you would have to allocate a new array big enough for the old items
    and the new one and then copy the old items to the new array, copying in the new
    item in the right position.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with the wallpaper task list is that the room has some painted wood
    and, as any decorator knows, it is best to paint the woodwork before hanging the
    wallpaper, and usually before sizing the walls. We need to insert a new task between
    filling any holes and sizing the walls. Further, before you do any decorating,
    you should cover any furniture in the room before doing anything else, so you
    need to add a new task to the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to find the position where we want to put our new task to
    paint the woodwork. We will look for the task that we want to be before the task
    we are inserting. Before `main` add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: This code searches the entire list for a link with the `description` that matches
    the parameter. This is carried out through a loop which uses the `string` comparison
    operator, and if the required link is found, a pointer to that link is returned.
    If the comparison fails, the loop initializes the loop variable to the address
    of the next link and if this address is `nullptr` it means that the required task
    is not in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the list is created in the main function, add the following code to search
    for the `fill holes` task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: If the `find_task` function returns a valid pointer, then we can add an item
    at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function to do this will allow you to add a new item after any item in
    the list that you pass to it and, if you pass `nullptr`, it will add the new item
    to the beginning. It''s called `insert_after`, but clearly, if you pass `nullptr`
    it also means *insert before the beginning*. Add the following just above the
    `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The second parameter is a `const` reference because we will not change the `string`,
    but the first parameter is not a `const` pointer because we will be changing the
    object that it points to. This function creates a new `task` object and initializes
    the `description` member to the new task name. It then checks to see if the `task`
    pointer passed to the function is null. If it is not, then the new item can be
    inserted *after* the specified link in the list. To do this, the new link `pNext`
    member is initialized to be the next item in the list, and the `pNext` member
    of the previous link is initialized to the address of the new link.
  prefs: []
  type: TYPE_NORMAL
- en: What about inserting an item at the beginning, when the function is passed `nullptr`
    as the item to insert after? Add the following `else` clause.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Here, we make the `pNext` member of the new item to point to the old beginning
    of the list and then change `pHead` to point to the new item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `main` function, you can add a call to insert a new task to paint
    the woodwork, and since we also forgot to indicate that it is best to decorate
    a room after covering all furniture with dustsheets, add a task to do that first
    in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now compile the code. When you run the code, you should see the tasks
    performed in the required order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It can be argued that one of the main reasons to use C++ is that you have direct
    access to memory using pointers. This is a feature that programmers of most other
    languages are prevented from doing. This means that as a C++ programmer, you are
    a special type of programmer: someone who is trusted with memory. In this chapter,
    you have seen how to obtain and use pointers and some examples of how inappropriate
    use of pointers can make your code go horribly wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will cover functions which will include the description
    of another type of pointer: function pointers. If you are trusted with pointers
    to data and function pointers, you really are a special type of programmer.'
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 1. Images and Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This lesson will cover fundamental concepts about containerization as a foundation
    for the images and containers we will later build. We will also get to understand
    how and why Docker gets involved in the DevOps ecosystem. Before we begin, we
    will see how virtualization differs from containerization in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Lesson Objectives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By the end of this lesson, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Describe how Docker improves a DevOps workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpret Dockerfile syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up containers and images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up a local dynamic environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run applications in Docker containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtain a basic overview of how Docker manages images via Docker Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy a Docker image to Docker Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtualization versus Containerization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This block diagram gives an overview of a typical virtual machine setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Virtualization versus Containerization](graphics/image01_01a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In virtual machines, the physical hardware is abstracted, therefore we have
    many servers running on one server. A hypervisor helps do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Virtual machines do sometimes take time to start up and are expensive in capacity
    (they can be GBs in size), although the greatest advantage they have over containers
    is the ability to run different Linux distributions such as CentOS instead of
    just Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Virtualization versus Containerization](graphics/image01_02a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In containerization, it is only the app layer (where code and dependencies are
    packaged) that is abstracted, making it possible for many containers to run on
    the same OS kernel but on separate user space.
  prefs: []
  type: TYPE_NORMAL
- en: Containers use less space and boot fast. This makes development easier, since
    you can delete and start up containers on the fly without considering how much
    server or developer working space you have.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin the lesson with a quick overview on how Docker comes into play in
    a DevOps workflow and the Docker environment.
  prefs: []
  type: TYPE_NORMAL
- en: How Docker Improves a DevOps Workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DevOps is a mindset, a culture, and a way of thinking. The ultimate goal is
    to always improve and automate processes as much as possible. In layman language,
    DevOps requires one to think in the laziest point of view, which puts most, if
    not all, processes as automatic as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is an open source containerization platform that improves the shipping
    process of a development life cycle. Note it is neither a replacement for the
    already existing platforms nor does the organization want it to be.
  prefs: []
  type: TYPE_NORMAL
- en: Docker abstracts the complexity of configuration management like Puppet. With
    this kind of setup, shell scripts become unnecessary. Docker can also be used
    on small or large deployments, from a hello world application to a full-fledged
    production server.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer on different levels, whether beginner or expert, you may have
    used Docker and you didn't even realize it. If you have set up a continuous integration
    pipeline to run your tests online, most servers use Docker to build and run your
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker has gained a lot of support in the tech community because of its agility
    and, as such, a lot of organizations are running containers for their services.
    Such organizations include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration and continuous delivery platforms such as Circle CI,
    Travis CI, and Codeship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud platforms such as **Amazon Web Services** **(AWS)** and **Google Cloud
    Platform** **(GCP)** allow developers to run applications out of containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cisco and the Alibaba group also run some of their services in containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker''s place in the DevOps workflow involves, but is not limited to, the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Examples of Docker's use cases in a development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Unifying requirements refers to using a single configuration file. Docker abstracts
    and limits requirements to a single Dockerfile file.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction of OS means one doesn't need to worry about building the OS because
    there exist prebuilt images.
  prefs: []
  type: TYPE_NORMAL
- en: Velocity has to define a Dockerfile and build containers to test in, or use
    an already built image without writing a Dockerfile.Docker allows development
    teams to avoid investment on steep learning curves through shell scripts because
    "automation tool X" is too complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Recap of the Docker Environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We walked through the fundamentals of containerization earlier. Allow me to
    emphasize the alternative workflow that Docker brings to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, we have two pieces to a working application: the project code base
    and the provisioning script. The code base is the application code. It is managed
    by version control and hosted in GitHub, among other platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: The provisioning script could be a simple shell script to be run in a host machine,
    which could be anywhere from a Windows workstation to a fully dedicated server
    in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Docker does not interfere with the project code base, but innovates on
    the provisioning aspect, improving the workflow and delivery velocity. This is
    a sample setup of how Docker implements this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recap of the Docker Environment](graphics/image01_03a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Dockerfile** takes the place of the provisioning script. The two combined
    (project code and Dockerfile) make a **Docker image.** A Docker image can be run
    as an application. This running application sourced from a Docker image is called
    a **Docker container.**
  prefs: []
  type: TYPE_NORMAL
- en: The Docker container allows us to run the application in a completely new environment
    on our computers, which is completely disposable. What does this mean?
  prefs: []
  type: TYPE_NORMAL
- en: It means that we are able to declare and run Linux or any other operating system
    on our computers and then, run our application in it. This also emphasizes that
    we can build and run the container as many times as we want without interfering
    with our computer's configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, I have brought to your attention four key words: **image**, **container**,
    **build**, and **run**. We will get to the nitty-gritty of the Docker CLI next.'
  prefs: []
  type: TYPE_NORMAL
- en: Basic Docker Terminal Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open Command Prompt to check that Docker is installed in your workstation.
    Entering the command `docker` on your terminal should show the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic Docker Terminal Commands](graphics/image01_04a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the list of available subcommands for Docker. To understand what each
    subcommand does, enter `docker-subcommand –help` on the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic Docker Terminal Commands](graphics/image01_05a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run `docker info` and note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server Version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Basic Docker Terminal Commands](graphics/image01_06a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This command displays system-wide information. The server version number is
    important at times, especially when new releases introduce something that is not
    backward-compatible. Docker has stable and edge releases for their Community Edition.
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at a few commonly used commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command searches **Docker Hub** for images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Docker Hub is the default Docker registry. A Docker registry holds named Docker
    images. Docker Hub is basically the "GitHub for Docker images". Earlier, we looked
    at running an Ubuntu container without building one; this is where the Ubuntu
    image is stored and versioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic Docker Terminal Commands](graphics/image01_07a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '"There are private Docker registries, and it is important that you are aware
    of this now."? Docker Hub is at [hub.docker.com](http://hub.docker.com). Some
    images are hosted at [store.docker.com](http://store.docker.com) but Docker Store
    contains official images. However, it mainly focuses on the commercial aspect
    of an app store of sorts for Docker images and provides workflows for use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The register page is as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic Docker Terminal Commands](graphics/image01_08a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The log in page is as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic Docker Terminal Commands](graphics/image01_09a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the results, you can tell how users have rated the image by the number
    of stars. You can also tell whether the image is official. This means that the
    image is promoted by the registry, in this case, Docker Hub. New Docker users
    are advised to use official images since they have great documentation, are secure,
    promote best practices, and are designed for most use cases. As soon as you have
    settled on one image, you'll need to have it locally.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ensure you are able to search for at least one image from Docker Hub. Image
    variety ranges from operating systems to libraries, such as Ubuntu, Node.js, and
    Apache.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command allows you to search from Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For example, `docker search ubuntu`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command pulls an image from the registry to your local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For example, `docker pull ubuntu`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as this command is running, you''ll notice that it is using the default
    tag: `latest`. In Docker Hub, you can see the list of tags. For **Ubuntu**, they
    are listed here: [https://hub.docker.com/r/library/ubuntu/](https://hub.docker.com/r/library/ubuntu/)
    plus their respective Dockerfiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic Docker Terminal Commands](graphics/image01_010a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Download the Ubuntu image profile on Docker Hub from: [https://hub.docker.com/r/library/ubuntu/](https://hub.docker.com/r/library/ubuntu/).'
  prefs: []
  type: TYPE_NORMAL
- en: Activity 1 — Utilizing the docker pull Command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get you conversant with the `docke`r `pull` command.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this activity is to gain a firm understanding of the `docker-pull`
    CLI, not only by running the listed commands, but also by seeking help on other
    commands while exploring, through manipulating the built containers.
  prefs: []
  type: TYPE_NORMAL
- en: Is Docker up and running? Type `docker` on the terminal or command-line application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This command is used to pull the image from the Docker Hub`.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Image variety ranges from operating systems to libraries, such as Ubuntu, Node.js,
    and Apache. This command allows you to pull images from Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: For example, `docker pull ubuntu`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command lists the Docker images we have locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker images`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we run the command, if we have pulled images from Docker Hub, we will
    be able to see a list of images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Activity 1 — Utilizing the docker pull Command](graphics/image01_11a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: They are listed according to the repository, tag, image ID, date created, and
    size. The repository is simply the image name unless it is sourced from a different
    registry. In this case, you'll have a URL without the `http://` and the **top
    level domain (TLD)** such as `>registry.heroku.com/<image-name>` from the Heroku
    registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will check whether the image by the name `hello-world` exists
    locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, `docker run hello-world`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Activity 1 — Utilizing the docker pull Command](graphics/image01_12a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the image is not local, it will be pulled from the default registry, Docker
    Hub, and run as a container, by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command lists the running containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If there aren''t any running containers, you should have a blank screen with
    the headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Activity 1 — Utilizing the docker pull Command](graphics/image01_13a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Activity 2 — Analyzing the Docker CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ensure you have the Docker CLI running by typing `docker` on your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: You have been asked to demonstrate the commands covered so far.
  prefs: []
  type: TYPE_NORMAL
- en: To get you conversant with the Docker CLI. The goal of this activity is to gain
    a firm understanding of the `docker-compose` CLI, not only by running the listed
    commands, but also by seeking help on other commands while exploring, through
    manipulating the built containers. The goal is to be flexible enough with the
    CLI to be able to use it in a real-world scenario such as running an automated
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Is Docker up and running? Type `docker` on the terminal or command-line application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for the official Apache image using the CLI, using `docker search apache:`![Activity
    2 — Analyzing the Docker CLI](graphics/image01_14a.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attempt to pull the image using `docker pull apache.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm the availability of the image locally using `docker images.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Bonus: Run the image as a container using `docker run apache.`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Bonus: Stop the container using `docker stop <container ID>.`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Bonus: Delete the container and the image using `docker rm <contai``ner ID>.`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dockerfile Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every Docker image starts from a **Dockerfile**. To create an image of an application
    or script, simply create a file called **Dockerfile**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It does not have an extension and begins with a capital letter D.
  prefs: []
  type: TYPE_NORMAL
- en: A Dockerfile is a simple text document where all the commands that template
    a container are written. The Dockerfile always starts with a base image. It contains
    steps to create the application or to run the script in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Before we build, let's take a quick look at a few best practices on writing
    Dockerfiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some best practices include, but are not limited to, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation of concern**: Ensure each Dockerfile is, as much as possible,
    focused on one goal. This will make it so much easier to reuse in multiple applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid unnecessary installations**: This will reduce complexity and make the
    image and container compact enough.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reuse already built images**: There are several built and versioned images
    on Docker Hub; thus, instead of implementing an already existing image, it''s
    highly advisable to reuse by importing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Have a limited number of layers**: A minimal number of layers will allow
    one to have a compact or smaller build. Memory is a key factor to consider when
    building images and containers, because this also affects the consumers of the
    image, or the clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll start simply with a Python and JavaScript script. The choice of these
    languages is based on their popularity and ease of demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Dockerfiles for Python and JavaScript examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No prior experience is required on the selected languages as theyare meant to
    give a dynamic view of how any language can adopt containerization.
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we begin, create a new directory or folder; let's use this as our workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the directory and run `docker search python`. We''ll pick the official
    image: `python`. The official image has the value **[OK]** in the **OFFICIAL**
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Python](graphics/image01_15a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Go to [hub.docker.com](http://hub.docker.com) or [store.docker.com](http://store.docker.com)
    and search for python to get the correct tag or at least know what version the
    Python image with the latest tag is. We will talk more about tags in *Topic D*.
  prefs: []
  type: TYPE_NORMAL
- en: The image tag should be the number with this syntax that looks like `3.x.x`
    or `3.x.x-rc.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file by the name `run.py` and enter the first line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Create a new file on the same folder level and name it **Dockerfile.**
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We do not have an extension for the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following in the **Dockerfile**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The **FROM** command, as alluded to earlier, specifies the base image.
  prefs: []
  type: TYPE_NORMAL
- en: The command can also be used on an **inheritance** point of view. This means
    you do not have to include extra package installations in the Dockerfile if there
    already exists an image with the packages.
  prefs: []
  type: TYPE_NORMAL
- en: The **ADD** command copies the specified files at source to the destination
    within the image's filesystem. This means the contents of the script will be copied
    to the directory specified.
  prefs: []
  type: TYPE_NORMAL
- en: In this case because `run.py` and Dockerfile are on the same level then `run.py`
    is copied to the working directory of the base image's file system that we are
    building upon.
  prefs: []
  type: TYPE_NORMAL
- en: The **RUN** command is executed while the image is being built. `ls` being run
    here is simply for us to see the contents of the image's filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: The **CMD** command is used when a container is run based on the image we'll
    create using this Dockerfile. That means at the end of the Dockerfile execution,
    we are intending to run a container.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Exit the previous directory and create a new one. This one will be demonstrating
    a node application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line in the script and save:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `docker search node` - we''ll pick the official image: `node`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that the official image has the value **[OK]** in the **OFFICIAL**
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JavaScript](graphics/image01_16a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that node is the JavaScript runtime based on Google's high performance,
    open source JavaScript engine, V8.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [hub.docker.com](http://hub.docker.com) and search for node to get the
    correct tag or at least know what version the node image with the latest tag is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new **Dockerfile** and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: This should be on the same file level as the script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We'll cover these for now.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 3 — Building the Dockerfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ensure you have the Docker CLI running by typing `docker` on your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: To get you conversant with Dockerfile syntax. The goal of this activity is to
    help understand and practice working with third-party images and containers. This
    helps get a bigger picture on how collaboration can still be affected through
    containerization. This increases product delivery pace by building features or
    resources that already exist.
  prefs: []
  type: TYPE_NORMAL
- en: You have been asked to write a simple Dockerfile that prints `hello-world`.
  prefs: []
  type: TYPE_NORMAL
- en: Is Docker up and running? Type `docker` on the terminal or command-line application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new directory and create a new Dockerfile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a Dockerfile that includes the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Building Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin building images, let's understand the context first. An image
    is a standalone package that can run an application or allocated service. Images
    are built through Dockerfiles, which are templates that define how images are
    to be built.
  prefs: []
  type: TYPE_NORMAL
- en: A container is defined as a runtime instance or version of an image. Note this
    will run on your computer or the host as a completely isolated environment, which
    makes it disposable and viable for tasks such as testing.
  prefs: []
  type: TYPE_NORMAL
- en: With the Dockerfiles ready, let's get to the Python Dockerfile directory and
    build the image.
  prefs: []
  type: TYPE_NORMAL
- en: docker build
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The command to build images is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`-t` stands for the tag. The `<image-name>` can include the specific tag, say,
    latest. It is advised that you do it this way: always tagging the image.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The relative location of the Dockerfile** here would be a `dot (.)` to mean
    that the Dockerfile is on the same level as the rest of the code; that is, it
    is at the root level of the project. Otherwise, you would enter the directory
    the Dockerfile is in.'
  prefs: []
  type: TYPE_NORMAL
- en: If, for example, it is in the Docker folder, you would have `docker build -t
    <image-name> docker`, or if it is in a folder higher than the root directory,
    you would have two dots. Two levels higher would be three dots in place of the
    one dot.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The output on the terminal and compare to the steps written on the Dockerfiles.
    You may want to have two or more Dockerfiles to configure different situations,
    say, a Dockerfile to build a production-ready app and another one for testing.
    Whatever reason you may have, Docker has the solution.
  prefs: []
  type: TYPE_NORMAL
- en: The default Dockerfile is, yes, Dockerfile. Any additional one by best practices
    is named `Dockerfile.<name>`,say, `Dockerfile.dev`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build an image using a Dockerfile aside from the default one, run the following:
    `docker build -f Dockerfile.<name> -t <image-name> <relative location of the Dockerfile>`'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you rebuild the image with a change to the Dockerfile, without specifying
    a different tag, a new image will be built and the previous image is named `<none>.`
  prefs: []
  type: TYPE_NORMAL
- en: The `docker` build command has several options that you can see for yourself
    by running `docker build --help`. Tagging images with names such as latest is
    also used for versioning. We will talk more on this in the *Topic F*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the image, run the following command in the Python workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The trailing dot is an important part of the syntax here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![docker build](graphics/image01_17a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The trailing dot is an important part of the syntax here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![docker build](graphics/image01_18a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the JavaScript directory and build the JavaScript image as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Running the commands will outline the four steps based on the four lines of
    commands in the **Dockerfile**.
  prefs: []
  type: TYPE_NORMAL
- en: Running `docker images` lists the two images you have created and any other
    image you had pulled before.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Docker Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `docker rmi <image-id>` command is used to delete an image. Let me remind
    you that the image ID can be found by running the `docker images` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete the images that are non-tagged (assumed not to be relevant), knowledge
    of bash scripting comes in handy. Use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This simply searches for images with <none> within their row of the `docker
    images` command and returns the image IDs that are in the third column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing Docker Images](graphics/image01_19a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Activity 4 — Utilizing the Docker Image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ensure you have the Docker CLI running by typing `docker` on your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: To get you conversant with running containers out of images.
  prefs: []
  type: TYPE_NORMAL
- en: You have been asked to build an image from the Dockerfile written in *Activity
    C*. Stop the running container, delete the image, and rebuild it using a different
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Is Docker up and running? Type `docker` on the terminal or command-line application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the JavaScript example directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `docker build -t <choose a name>` (observe the steps and take note of the
    result).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `docker run <the-name-you-chose>.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `docker stop <container ID>.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `docker rmi <add the image ID here>.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `docker build -t <choose new name>.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `docker ps` (note the result; the old image should not exist).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running Containers From Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember when we mentioned containers are built from images? The command `docker
    run <image>` creates a container based on that image. One can say that a container
    is a running instance of an image. Another reminder is that this image could either
    be local or in the registry.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and run the already created images `docker run python-docker` and `docker
    run js-docker:`
  prefs: []
  type: TYPE_NORMAL
- en: '![Running Containers From Images](graphics/image01_20a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What do you notice? The containers run outputs to the terminal''s respective
    lines. Notice that the command preceded by CMD in the Dockerfile is the one that
    runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will not see any output on the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: This is not because we don't have a command `CMD` to run as soon as the container
    is up. For both images built from **Python** and **Node**, there is a `CMD` inherited
    from the base images.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Images created always inherit from the base image.
  prefs: []
  type: TYPE_NORMAL
- en: The two containers we have run contain scripts that run once and exit. Examining
    the results of `docker ps`, you'll have nothing listed from the two containers
    run earlier. However, running `docker ps -a` reveals the containers and their
    state as exited.
  prefs: []
  type: TYPE_NORMAL
- en: There is a command column that shows the CMD of the image from which the container
    is built from.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running a container, you can specify the name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker run --name <container-name> <image-name>` (for example, `docker run
    --name py-docker-container python-docker`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running Containers From Images](graphics/image01_21a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We outlined earlier that you only want to have relevant Docker images and not
    the `<none>` tagged Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: As for containers, you need to be aware that you can have several containers
    from one image. `docker rm <container-id>` is the command for removing containers.
    This works for exited containers (those that are not running).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the containers that are still running, you would have to either:'
  prefs: []
  type: TYPE_NORMAL
- en: Stop the containers before removing them (`docker stop <container-id>)`
  prefs: []
  type: TYPE_NORMAL
- en: Remove the containers forcefully (`docker rm <container-id> -f`)
  prefs: []
  type: TYPE_NORMAL
- en: 'No container will be listed if you run `docker ps`,but sure enough if we run
    `docker ps -a`, you will notice that the containers are listed and their command
    columns will show the inherited CMD commands: `python3` and `node`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running Containers From Images](graphics/image01_22a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The CMD in Dockerfile for Python's image is `python3`. This means that the `python3`
    command is run in the container and the container exits.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With this in mind, one gets to run Python without installing Python in one's
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try running this: `docker run -it python-docker:test` (with the image we created
    last).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We get into an interactive bash shell in the container. `-it` instructs the
    Docker container to create this shell. The shell runs `python3`, which is the
    CMD in the Python base image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Python](graphics/image01_23a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the command `docker run -it python-docker:test python3 run.py, python3 run.py`
    is run as you would in the terminal within the container. Note that `run.py` is
    within the container and so runs. Running `docker run -it python python3 run.py`
    would indicate the absence of the `run.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Python](graphics/image01_24a.jpg)![Python](graphics/image01_25a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The same applies to JavaScript, showing that the concept applies across the
    board.
  prefs: []
  type: TYPE_NORMAL
- en: '`docker run -it js-docker:test` (the image we created last) will have a shell
    running node (the CMD in the node base image):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Python](graphics/image01_26a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`docker run -it js-docker:test node run.js` will output `Hello Docker - JS:`'
  prefs: []
  type: TYPE_NORMAL
- en: '![Python](graphics/image01_27a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That proves the inheritance factor in Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Now, return the Dockerfiles to their original state with the **CMD commands**
    on the last line.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning Images and Docker Hub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember talking about versioning images in *Topic D*? We did that by adding
    latest and using some numbers against our images, such as `3.x.x` or `3.x.x-rc.`
  prefs: []
  type: TYPE_NORMAL
- en: In this topic, we'll go through using tags for versioning and look at how official
    images have been versioned in the past, thereby learning best practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command in use here is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Say, for example, we know that Python has several versions: Python 3.6, 3.5,
    and so on. Node.js has several more. If you take a look at the official Node.js
    page on Docker Hub, you see the following at the top of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '9.1.0, 9.1, 9, latest (9.1/Dockerfile) (as of November 2017):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Versioning Images and Docker Hub](graphics/image01_28a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This versioning system is called semver: semantic versioning. This version
    number has the format MAJOR, MINOR, PATCH in an incremental manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MAJOR**: For a change that is backward-incompatible'
  prefs: []
  type: TYPE_NORMAL
- en: '**MINOR**: For when you have a backward-compatible change'
  prefs: []
  type: TYPE_NORMAL
- en: '**PATCH**: For when you make bug fixes that are backward-compatible'
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice labels such as `rc` and other prerelease and build metadata attached
    to the image.
  prefs: []
  type: TYPE_NORMAL
- en: When building your images, especially for release to the public or your team,
    using semver is the best practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, I advocate that you do this always and have this as a personal mantra:
    semver is key. It will remove ambiguity and confusion when working with your images.'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Docker Image to Docker Hub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every time we run `docker build`, the image created is locally available. Normally,
    the Dockerfile is hosted together with the code base; therefore, on a new machine,
    one would need to use `docker build` to create the Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Docker Hub, any developer has the opportunity to have a Docker image hosted
    to be pulled into any machine running Docker. This does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Eliminates the repetitive task of running `docker build`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds an additional way of sharing your application which is simple to set up
    compared to sharing a link of your app's code base and **README** detailing the
    setup process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker login` is the command to run to connect to **Docker Hub** via the CLI.
    You need to have an account in hub.docker.com and enter the username and password
    through the terminal.'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker push <docker-hub-username/image-name[:tag]>` is the command to send
    the image to the registry, Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying a Docker Image to Docker Hub](graphics/image01_30a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A simple search of your image on [hub.docker.com](http://hub.docker.com) will
    give the output to your Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: In a new machine, a simple `docker pull <docker-hub-username/your-image-name>`
    command will produce a copy of your image locally.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this lesson, we have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewed the DevOps workflow and a few use cases for Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walked through Dockerfile syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gained a high-level understanding of the build images for applications and running
    containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructed a number of images, versioned them, and pushed them to Docker Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

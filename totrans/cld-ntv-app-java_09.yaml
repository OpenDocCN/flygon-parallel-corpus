- en: Cloud-Native Application Runtime
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云原生应用程序运行时
- en: 'Having developed, tested, and deployed the applications using a deployment
    pipeline such as Jenkins, in this chapter, we will look at the runtime ecosystems
    in which our applications or services run. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究我们的应用程序或服务运行的运行时生态系统。我们将涵盖以下主题：
- en: The need for a comprehensive runtime, including a recap of the problems in operating
    and managing a large number of services
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全面运行时的需求，包括操作和管理大量服务中的问题的总结
- en: 'Implementing the reference runtime architecture, including:'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施参考运行时架构，包括：
- en: Service registry
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务注册表
- en: Config server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置服务器
- en: Service frontends, API gateway, reverse proxy, and load balancer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务前端、API网关、反向代理和负载均衡器
- en: A look at Zuul as a reverse proxy
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以Zuul作为反向代理的介绍
- en: Container management and orchestration through Kubernetes and Minikube
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Kubernetes和Minikube进行容器管理和编排
- en: 'Running on **Platform as a Service** (**PaaS**):'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**平台即服务**（PaaS）上运行：
- en: How the PaaS platforms help realize service runtime reference architecture that
    we discussed in previous chapter
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PaaS平台如何帮助实现我们在前一章讨论的服务运行时参考架构
- en: Installing Cloud Foundry and running our `product` service on the Cloud Foundry
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Cloud Foundry并在Cloud Foundry上运行我们的`product`服务
- en: The need for a runtime
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时的需求
- en: We have developed our services, written tests for them, automated the continuous
    integration, and are running them in the container. What else do we need?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开发了我们的服务，为它们编写了测试，自动化了持续集成，并在容器中运行它们。我们还需要什么？
- en: 'Running many services at scale in production is not easy. As more services
    are released in production, their management starts getting complex. Hence, here
    is a recap of the problems, discussed in the microservices ecosystem and solved
    in some code samples in a previous chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中运行许多服务并不容易。随着更多服务在生产环境中发布，它们的管理变得复杂。因此，这里是对在微服务生态系统中讨论的问题的总结，并在前一章的一些代码示例中得到解决：
- en: '**Service running in the cloud: **A traditional large application was hosted
    on an application server and ran at an IP address and port. On the other hand,
    microservices run in multiple containers at various IP addresses and ports so
    the tracking production service can get complex.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在云中运行的服务：**传统的大型应用程序托管在应用服务器上，并在IP地址和端口上运行。另一方面，微服务在多个容器中以各种IP地址和端口运行，因此跟踪生产服务可能会变得复杂。'
- en: '**Services come up and go down like moles in a Whack-a-Mole game: **There are
    100s of services with their loads balanced and failover instances running all
    over the cloud space. Many teams, thanks to DevOps and agility, are deploying
    new services and taking down old services. Thus, as we can see, a microservice-driven
    cloud environment is very dynamic.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务像打地鼠游戏中的鼹鼠一样上下运行：**有数百个服务，它们的负载被平衡和故障转移实例在云空间中运行。由于DevOps和敏捷性，许多团队正在部署新服务并关闭旧服务。因此，正如我们所看到的，基于微服务的云环境非常动态。'
- en: These two issues are addressed by the service registry tracking the services.
    So, the clients can look up where the services corresponding to a name are running
    using a client-side load balancing pattern. However, if we want to abstract the
    clients from the look up, then we use the pattern of server-side load balancing,
    where a load balancer, such as Nginx, an API gateway like Apigee, or reverse proxy
    or router, such as Zuul, abstracts the clients from the actual address of the
    services.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 服务注册表跟踪服务来解决这两个问题。因此，客户端可以查找与名称对应的服务在哪里运行，使用客户端负载平衡模式。然而，如果我们想要将客户端与查找分离，那么我们使用服务器端负载平衡模式，其中负载均衡器（如Nginx）、API网关（如Apigee）或反向代理或路由器（如Zuul）将客户端与服务的实际地址抽象出来。
- en: '**Managing my configuration across microservices: **If the deployment unit
    has broken into multiple services, so has the property file containing the packaged
    configuration items such as connection addresses, user ID, logging levels, and
    so on. So, if I have to change a logging level for a set of services or a flow,
    do I have to change it across all the application''s property files? Here, we
    will see how centralizing the property files in a config server like Spring Config
    Server or Consul helps to manage the properties in a hierarchical fashion.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨微服务管理我的配置：**如果部署单元已分解为多个服务，那么打包的配置项（如连接地址、用户ID、日志级别等）也会分解为属性文件。因此，如果我需要更改一组服务或流程的日志级别，我是否需要在所有应用程序的属性文件中进行更改？在这里，我们将看到如何通过Spring
    Config Server或Consul将属性文件集中化，以按层次结构管理属性。'
- en: '**So many log files to handle: **Each microservice is generating one (or more)
    log files like `.out` and `.err` and Log4j files. How do we search for log messages
    across multiple log files from multiple services?'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理如此多的日志文件：**每个微服务都会生成一个（或多个）日志文件，如`.out`和`.err`以及Log4j文件。我们如何在多个服务的多个日志文件中搜索日志消息？'
- en: The pattern to solve this is log aggregation, implemented with commercial tools
    such as Splunk or open source tools like Logstash or Galaxia. They are also present
    by default in PaaS offerings like Pivotal Cloud Foundry.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的模式是日志聚合，使用商业工具（如Splunk）或开源工具（如Logstash或Galaxia）实现。它们也默认存在于PaaS提供的工具中，如Pivotal
    Cloud Foundry。
- en: The other option is to stream logs to the aggregators such as Kafka from where
    they can be centrally stored.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是将日志流式传输到聚合器（如Kafka），然后可以在其中进行集中存储。
- en: '**Metrics from each service**:In [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application*, we added Spring actuator metrics,
    which are exposed as endpoints. There are many other metrics, such as Dropwizard
    metrics, that can be captured and exposed.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**来自每个服务的指标：**在[第2章](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml)中，*编写您的第一个云原生应用程序*，我们添加了Spring执行器指标，这些指标会暴露为端点。还有许多其他指标，如Dropwizard指标，可以被捕获和暴露。'
- en: Either an agent has to monitor all services actuator metrics, or they can be
    exported and then aggregated in a monitoring and reporting tool.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要么一个代理必须监视所有服务执行器指标，要么它们可以被导出，然后在监控和报告工具中进行聚合。
- en: Another option is for application monitoring tools like Dynatrace, AppDynamics
    to monitor application, and extract metrics at Java level. We will take a look
    at these in the next chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是应用程序监控工具，如Dynatrace、AppDynamics来监控应用程序，并在Java级别提取指标。我们将在下一章中介绍这些。
- en: Implementing runtime reference architecture
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施运行时参考架构
- en: 'The problems discussed in the previous section are addressed by the following
    reference runtime architecture:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节讨论的问题由以下参考运行时架构解决：
- en: '![](img/49927155-cba6-4fad-a513-b546c7d4fffb.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49927155-cba6-4fad-a513-b546c7d4fffb.png)'
- en: All these components were already discussed in [Chapter 1](ba2b049f-679d-493c-9861-b655f91065bc.xhtml), *Introduction
    to Cloud-Native*. Now, we proceed to choose technologies and show an implementation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些组件已经在[第1章](ba2b049f-679d-493c-9861-b655f91065bc.xhtml)中讨论过，*云原生简介*。现在，我们继续选择技术并展示实现。
- en: Service registry
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册表
- en: Running the service registry Eureka was discussed in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application*. Please refer to that chapter to
    refresh your memory on how a `product` service registers itself with Eureka and
    how the client uses Ribbon and Eureka to find the `product` service.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 运行服务注册表Eureka在[第2章](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml)中已经讨论过，*编写您的第一个云原生应用程序*。请参考该章节，回顾一下`product`服务如何在Eureka中注册自己以及客户端如何使用Ribbon和Eureka找到`product`服务。
- en: The importance of service registry is slightly diminished if we are using Docker
    Orchestration, such as Kubernetes. In this case, Kubernetes itself manages the
    registration of a service, which a proxy looks up and redirects to.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用Docker编排（如Kubernetes），服务注册表的重要性会稍微降低。在这种情况下，Kubernetes本身管理服务的注册，代理查找并重定向到服务。
- en: Configuration server
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置服务器
- en: The config server stores configurations in a hierarchical manner. This way,
    the application only needs to know the address of the config server and then connect
    to it to get the remaining configurations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 配置服务器以分层方式存储配置。这样，应用程序只需要知道配置服务器的地址，然后连接到它以获取其余的配置。
- en: There are two popular config servers. One is Hashicorp's Consul and the other
    is Spring Config Server. We will use Spring Config Server to keep the stack consistent
    to Spring.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个流行的配置服务器。一个是Hashicorp的Consul，另一个是Spring Config Server。我们将使用Spring Config
    Server来保持堆栈与Spring一致。
- en: 'Let''s go over the steps to start using a config server. There are two parts
    to using externalized configuration: the server (serving the properties) and the
    client.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看启动使用配置服务器的步骤。使用外部化配置有两个部分：服务器（提供属性）和客户端。
- en: The server part of the config server
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置服务器的服务器部分
- en: There are many options to serve the properties over an HTTP connection,  Consul
    and Zookeeper being popular ones. However, for Spring projects, Spring Cloud provides
    a flexible config server that can connect to multiple backends, including Git,
    databases, and filesystems. Given that the properties are best stored in a version
    control, we will use the Git backend for Spring Cloud Config for this example.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多选项可以通过HTTP连接提供属性，Consul和Zookeeper是流行的选项之一。然而，对于Spring项目，Spring Cloud提供了一个灵活的配置服务器，可以连接到多个后端，包括Git、数据库和文件系统。鉴于最好将属性存储在版本控制中，我们将在此示例中使用Spring
    Cloud Config的Git后端。
- en: The Spring Cloud Config server code, configuration, and runtime is very similar
    to Eureka and it is easy to fire up an instance like we did for Eureka in [Chapter
    2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml), *Writing Your First Cloud-Native
    Application*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config服务器的代码、配置和运行时与Eureka非常相似，像我们在[第2章](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml)中为Eureka做的那样，很容易启动一个实例，*编写您的第一个云原生应用程序*。
- en: 'Follow these steps to get a service registry running:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤运行服务注册表：
- en: Create a new Maven project with the artifact ID set to `config-server`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Maven项目，将artifact ID设置为`config-server`。
- en: 'Edit the POM file and add the following:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑POM文件并添加以下内容：
- en: 1\. The parent as `spring-boot-starter-parent`
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 父项为`spring-boot-starter-parent`
- en: 2\. The dependency as `spring-cloud-config-server`
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 依赖项为`spring-cloud-config-server`
- en: 3\. The dependency management as `spring-cloud-config`
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 依赖管理为`spring-cloud-config`
- en: '![](img/f3b5ae42-0431-4516-97ee-0e3b8c44f1a7.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3b5ae42-0431-4516-97ee-0e3b8c44f1a7.png)'
- en: 'Create an `ConfigServiceApplication` class that will have annotation to start
    the config server:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ConfigServiceApplication`类，该类将有注解来启动配置服务器：
- en: '![](img/a37f8d13-eb00-4a4f-aa5f-b9a7f9c47c46.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a37f8d13-eb00-4a4f-aa5f-b9a7f9c47c46.png)'
- en: 'Create an `application.yml` file in the `config-server/src/main/resources`
    folder of the application and put the following:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的`config-server/src/main/resources`文件夹中创建一个`application.yml`文件，并添加以下内容：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The port number is where the config server will listen for configuration requests
    over an HTTP connection.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 端口号是配置服务器将在HTTP连接上监听配置请求的地方。
- en: The other property of `spring.cloud.config.server.git.uri` is the location of
    Git, which we have configured a local folder for development. This is where Git
    should be running on the local machine. If not, run a `git init` command on this
    folder.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring.cloud.config.server.git.uri`的另一个属性是Git的位置，我们已经为开发配置了一个本地文件夹。这是Git应该在本地机器上运行的地方。如果不是，请在此文件夹上运行`git
    init`命令。'
- en: We are not covering Git authentication or encryption here. Please check the
    Spring Cloud Config manual ([https://spring.io/guides/gs/centralized-configuration/](https://spring.io/guides/gs/centralized-configuration/))
    for more details.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不涵盖Git身份验证或加密。请查看Spring Cloud Config手册（[https://spring.io/guides/gs/centralized-configuration/](https://spring.io/guides/gs/centralized-configuration/)）了解更多详情。
- en: 'In the `product.properties` file, we will hold the properties that were initially
    held in the `application.properties` file of the actual `product` project. These
    properties will be loaded by the config server. We will start with a small property,
    as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`product.properties`文件中，我们将保存最初保存在实际`product`项目的`application.properties`文件中的属性。这些属性将由配置服务器加载。我们将从一个小属性开始，如下所示：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This property file should be present in the Git folder we just referenced in
    the previous step. Please add the property file to the Git folder, using the following
    command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性文件应该存在于我们刚刚在上一步中引用的Git文件夹中。请使用以下命令将属性文件添加到Git文件夹中：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a `bootstrap.yml` file in the `resources` folder of application and
    input the name of this project:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的`resources`文件夹中创建一个`bootstrap.yml`文件，并输入此项目的名称：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Build the Maven project and then run it.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建Maven项目，然后运行它。
- en: 'You should see a Tomcat started message, as follows:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到一个`Tomcat started`消息，如下所示：
- en: '![](img/a4aa6729-ccc4-4b69-9a14-a99dbe98bef7.png)`ConfigurationServiceApplication`
    has started and is listening on port `8888`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/a4aa6729-ccc4-4b69-9a14-a99dbe98bef7.png)`ConfigurationServiceApplication`已启动，并在端口`8888`上监听'
- en: Let's check if the property we added is available for consumption.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们添加的属性是否可供使用。
- en: 'Fire up a browser and check for `product.properties`. There are two ways you
    can do this. The first is by viewing the property file as JSON and the second
    is by viewing it as a text file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器，检查`product.properties`。有两种方法可以做到这一点。第一种是将属性文件视为JSON，第二种是将其视为文本文件：
- en: '`http://localhost:8888/product/default`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8888/product/default`:'
- en: '![](img/a2e7f686-89d5-4e86-8cf4-b7daf8ae13c0.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2e7f686-89d5-4e86-8cf4-b7daf8ae13c0.png)'
- en: '`http://localhost:8888/product-default.properties`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8888/product-default.properties`:'
- en: '![](img/23b88c7c-b0fe-44a4-8ca1-62516d6ec7c1.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23b88c7c-b0fe-44a4-8ca1-62516d6ec7c1.png)'
- en: 'In case you are wondering, the default is the profile name. Spring Boot applications
    support profile overrides, for example, for test and **user acceptance testing**
    (**UAT**) environments, where the production properties can be replaced with the
    `product-test.properties` file. Hence, the config server supports the following
    form of URL reads: `http://configsvrURL/{application}/{profile}` or `http://configsvrURL/{application-profile}.properties`
    or `.yml`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在想，默认是配置文件名称。Spring Boot应用程序支持配置文件覆盖，例如，用于测试和用户验收测试（UAT）环境，其中可以用`product-test.properties`文件替换生产配置。因此，配置服务器支持以下形式的URL读取：`http://configsvrURL/{application}/{profile}`或`http://configsvrURL/{application-profile}.properties`或`.yml`。
- en: In production, it is highly unlikely that we will access the config server directly,
    as shown previously. It will be the clients who will access the config server;
    we shall see this next.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，我们几乎不太可能直接访问配置服务器，就像之前展示的那样。将是客户端访问配置服务器；我们将在下面看到这一点。
- en: The config client
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置客户端
- en: We will use the `product` service code developed earlier as a baseline to start
    extracting the properties out of the application into the config server.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用先前开发的`product`服务代码作为基线，开始将属性从应用程序中提取到配置服务器中。
- en: Copy the `product` service project from eclipse to create a new project for
    this chapter.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从eclipse中复制`product`服务项目，创建一个新的项目用于本章。
- en: 'Add the `spring-cloud-starter-config` dependency to the list of the dependencies
    in the POM file:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`spring-cloud-starter-config`依赖项添加到POM文件的依赖项列表中：
- en: '![](img/2dd748c2-9e31-4aba-b8c0-67ffad5887eb.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2dd748c2-9e31-4aba-b8c0-67ffad5887eb.png)'
- en: Our main work will be on the resources. Tell the `product` service to use the
    config server running at: `http://localhost:8888`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的主要工作将在资源上进行。告诉`product`服务使用运行在`http://localhost:8888`的配置服务器。
- en: 'The `failFast` flag indicates that we do not want the application loading to
    continue if we don''t find the config server. This is important, as it will ensure
    that the `product` service should not assume defaults if it does not find the
    config server:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`failFast`标志表示如果找不到配置服务器，我们不希望应用程序继续加载。这很重要，因为它将确保`product`服务在找不到配置服务器时不应假定默认值：'
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Shift all properties in the `application.properties` section of the resources
    folder of the `product` service to the `product.properties` that we had defined
    as part of the `git` folder loaded by the config server in the previous section.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`product`服务的`resources`文件夹中的`application.properties`部分中的所有属性转移到我们在上一节中定义的`git`文件夹的`product.properties`中。
- en: 'Your `product.properties` file will now have useful configuration, in addition
    to the `Hi There` message that we had put in for testing:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`product.properties`文件现在将具有有用的配置，除了我们之前放入进行测试的`Hi There`消息之外：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can now delete the `application.properties` file that is present in the `resources`
    folder of the `product` service.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以删除`product`服务的`resources`文件夹中存在的`application.properties`文件。
- en: 'Let''s add a test method to our `product` service to check the property being
    set from the config server:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们向`product`服务添加一个测试方法，以检查从配置服务器设置的属性：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Fire up the Eureka server, as done in the previous chapters.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Eureka服务器，就像在之前的章节中所做的那样。
- en: Ensure the config server from the previous section is still running.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保上一节中的配置服务器仍在运行。
- en: 'Now, start the `product` service from the `ProductSpringApp` main class. Right
    at the beginning of the logs, you will see the following statements:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从`ProductSpringApp`的主类开始启动`product`服务。在日志的开头，您将看到以下语句：
- en: '![](img/90a0ed0d-cd2a-4bfe-a79c-5ba82e82a130.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90a0ed0d-cd2a-4bfe-a79c-5ba82e82a130.png)'
- en: When the ProductSpringApp starts, it first goes and gets the configuration from
    the external configuration service running on port 8888
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当ProductSpringApp启动时，它首先从运行在8888端口的外部配置服务获取配置
- en: The environment with `name=product` is picked as our application name in the `bootstrap.yml`
    file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bootstrap.yml`文件中，选择`name=product`的环境作为我们的应用程序名称。
- en: 'The port number at which `product` service should listen is picked up from
    this config server, along with the other properties, such as the test message
    which we will see now:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`product`服务应该监听的端口号是从这个配置服务器中获取的，还有其他属性，比如我们现在将看到的测试消息：'
- en: '![](img/8d347e80-79b2-445a-99d5-7c95034216f5.png)`ProductSpringApp` starts
    on port `8082` picked up from the externalized configuration.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/8d347e80-79b2-445a-99d5-7c95034216f5.png)`ProductSpringApp`在端口`8082`上启动，从外部化配置中获取。'
- en: 'Test the application with two URLs as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下两个URL测试应用程序：
- en: '`http://localhost:8082/testMessage`: This returns `Hi There`, which was our
    configured message'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8082/testMessage`：这将返回我们配置的消息`Hi There`'
- en: Run one of the other REST services, such as product view. You will see the required
    product information to indicate our services are working fine.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 运行其他REST服务之一，例如产品视图。您将看到所需的产品信息，以表明我们的服务正常运行。
- en: '`http://localhost:8082/product/1`: This will return `{"id":1,"name":"Apples","catId":1}`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8082/product/1`：这将返回`{"id":1,"name":"Apples","catId":1}`'
- en: Refreshing the properties
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刷新属性
- en: Now, what if there is a change in the properties that you want to reflect centrally
    on all the services?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您想要在所有服务上集中反映属性的更改，该怎么办？
- en: You can change the message in the `product.properties` file to a new message,
    such as `Hi Spring`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以将`product.properties`文件中的消息更改为新消息，例如`Hi Spring`。
- en: 'You will notice that the config server picks up this change on the next read,
    as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到配置服务器在下一次读取时接收到了这一更改，如下所示：
- en: '![](img/9879ad35-2cef-452e-b850-506ab2f3d11c.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9879ad35-2cef-452e-b850-506ab2f3d11c.png)'
- en: However, this property is not picked up by the service immediately, as calling
    `http://localhost:8082/testMessage` results in the older `Hi There` message. How
    do we refresh the properties on the command line?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，该属性不会立即被服务接收，因为调用`http://localhost:8082/testMessage`会导致旧的`Hi There`消息。我们如何在命令行上刷新属性？
- en: 'This is where the actuator command `/refresh` comes in handy. We configure
    the beans to be part of  the `@RefreshScope` annotation. These beans will get
    reloaded when the `POST` method call to `http://localhost:8082/refresh` is executed
    from the Postman application. See the following log to check what calling refresh
    results in reloading of properties looks like:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是执行器命令`/refresh`派上用场的地方。我们配置这些bean作为`@RefreshScope`注解的一部分。当从Postman应用程序执行`POST`方法调用`http://localhost:8082/refresh`时，这些bean将被重新加载。查看以下日志，以查看调用刷新会导致重新加载属性的结果：
- en: '![](img/b15ea384-b8cd-4120-8087-a6660da3fc11.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b15ea384-b8cd-4120-8087-a6660da3fc11.png)'
- en: The first line shows in the logs how `product` service refreshes its properties
    on executing `http://localhost:8082/refresh`
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行显示了`product`服务在执行`http://localhost:8082/refresh`时刷新其属性的日志
- en: You can check how, after the marked line, the property loading started again
    and the message after calling `http://localhost:8082/testMessage` gets reflected.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以查看，在标记线之后，属性加载重新开始，并在调用`http://localhost:8082/testMessage`后反映出消息。 '
- en: The microservice frontend
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务前端
- en: It is a popular pattern to frontend a microservice with a reverse proxy, a load
    balancer, an edge gateway or an API gateway, in an increasing order of complexity.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反向代理、负载均衡器、边缘网关或API网关来作为微服务的前端是一种流行的模式，复杂度逐渐增加。
- en: '**Reverse proxy**: A reverse proxy is defined as a process that makes the downstream
    resource available as though it originated from itself. In that respect, the webserver
    frontend and the application server also act as reverse proxies. The reverse proxy
    is useful in cloud-native applications, as it ensures that the clients do not
    need to look up services and then access them like we did in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application*. They have to access the reverse
    proxy, which looks up the microservices, calls them, and makes the response available
    to the client.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反向代理**：反向代理被定义为使下游资源可用，就好像它是自己发出的一样。在这方面，Web服务器前端和应用服务器也充当反向代理。反向代理在云原生应用中非常有用，因为它确保客户端无需像我们在[第2章](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml)中所做的那样查找服务然后访问它们。他们必须访问反向代理，反向代理查找微服务，调用它们，并使响应可用于客户端。'
- en: '**Load balancer**: The load balancer is an extended form of reverse proxy that
    can balance the request it receives from clients across multiple services. This
    increases the availability of the services. The load balancer can work with service
    registry to find out which are the active services and then balance the requests
    between them. Nginx and HAProxy are good examples of load balancers that can be
    used to frontend microservices.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡器**：负载均衡器是反向代理的扩展形式，可以平衡来自客户端的请求，使其分布在多个服务之间。这增加了服务的可用性。负载均衡器可以与服务注册表一起工作，找出哪些是活动服务，然后在它们之间平衡请求。Nginx和HAProxy是可以用于微服务前端的负载均衡器的良好例子。'
- en: '**Edge gateway**: As the name implies, the edge gateway is a higher-order component
    that is deployed on the edge of the enterprise or division and has more capabilities
    than a load balancer, such as authentication, authorization, traffic control,
    and routing functions. Netfix Zuul is a good example of this pattern. We will
    cover code examples of using Zuul in this section.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边缘网关**：顾名思义，边缘网关是部署在企业或部门边缘的高阶组件，比负载均衡器具有更多功能，如身份验证、授权、流量控制和路由功能。Netfix Zuul是这种模式的一个很好的例子。我们将在本节中介绍使用Zuul的代码示例。'
- en: '**API gateway**: With the popularity of Mobile and APIs, this component provides
    more complex capabilities, such as fanning out requests to multiple services doing
    orchestration between them, intercepting and enhancing the requests or responses
    or converting their formats, doing sophisticated analysis on the requests. It
    is also possible to use both an API gateway and a load balancer, reverse proxy,
    or edge in a single flow. This approach helps with the segregation of responsibilities,
    but also adds latency due to an additional hop. We will see API gateway in later
    chapters.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API网关**：随着移动和API的流行，这个组件提供了更复杂的功能，比如将请求分发到多个服务之间进行编排，拦截和增强请求或响应，或转换它们的格式，对请求进行复杂的分析。也可以同时使用API网关和负载均衡器、反向代理或边缘在一个流中。这种方法有助于责任的分离，但也会因为额外的跳跃而增加延迟。我们将在后面的章节中看到API网关。'
- en: Netflix Zuul
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Netflix Zuul
- en: Netflix Zuul is a popular Edge gateway popularized by Netflix and then offered
    as part of Spring Cloud. Zuul means gatekeeper and performs all those functions,
    including authentication, traffic control, and most importantly, routing, as discussed
    earlier. It is well-integrated with Eureka and Hystrix in looking up services
    and reporting metrics. The services in an enterprise or a domain can be frontended
    by Zuul.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Zuul是Netflix推广的一种流行的边缘网关，后来作为Spring Cloud的一部分提供。Zuul意味着守门人，并执行所有这些功能，包括身份验证、流量控制，最重要的是路由，正如前面讨论的那样。它与Eureka和Hystrix很好地集成，用于查找服务和报告指标。企业或域中的服务可以由Zuul前端化。
- en: 'Let''s put a Zuul gateway in front of our `product` service:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的`product`服务前面放一个Zuul网关：
- en: Create a new Maven project and set its artifact ID as `zuul-server`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Maven项目，并将其artifact ID设置为`zuul-server`。
- en: 'Edit the POM file and add the following:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑POM文件并添加以下内容：
- en: 1\. Set the parent as `spring-boot-starter-parent`
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 将父级设置为`spring-boot-starter-parent`
- en: 2\. Set the dependency on `spring-cloud-starter-zuul`, `-eureka`, and `-web`
    projects
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 在`spring-cloud-starter-zuul`，`-eureka`和`-web`项目上设置依赖管理
- en: '3\. Set dependency management on `spring-cloud-starter-netflix`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 在`spring-cloud-starter-netflix`上设置依赖管理。
- en: '![](img/874b6f33-752e-4d1f-a421-1e97b627db71.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/874b6f33-752e-4d1f-a421-1e97b627db71.png)'
- en: 'Create an application class with an annotation to enable Zuul Proxy:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有注释以启用Zuul代理的应用程序类：
- en: '![](img/19a8af5c-bdd0-4f89-8ab1-9fdc1b91353b.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19a8af5c-bdd0-4f89-8ab1-9fdc1b91353b.png)'
- en: The configuration information in `application.yml` is very critical for Zuul.
    This is where we configure the routing capabilities of Zuul to redirect it to
    the correct microservice.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`application.yml`中的配置信息对于Zuul非常重要。这是我们配置Zuul的路由能力以将其重定向到正确的微服务的地方。'
- en: 'Since Zuul interacts well with Eureka, we will leverage that to our advantage:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Zuul与Eureka的交互良好，我们将利用这一点：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This tells Zuul to look for services in the Eureka registry running at that
    port.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Zuul在运行该端口的Eureka注册表中查找服务。
- en: Configure the port to listen at `8080`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将端口配置为`8080`。
- en: Finally, configure the routes.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，配置路由。
- en: 'These are the mappings of the URL in the REST request to the respective service
    that can handle it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是REST请求中URL到相应服务的映射：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What happens behind the scenes
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 幕后发生了什么
- en: 'Let''s have a look at what happens behind the scenes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看幕后发生了什么：
- en: The `product` section in the route definition tells Zuul that the paths configured
    after `/product*/**` are to be redirected to the `product` service, if it is present
    in the Eureka registry configured in the Zuul server.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由定义中的`product`部分告诉Zuul，配置在`/product*/**`之后的路径应该被重定向到`product`服务，如果它在Zuul服务器中配置的Eureka注册表中存在。
- en: 'The path is configured to be `/product*/**`. Why three `*` ? If you remember,
    our `product` service can handle two types of REST services: `/product/1 GET`
    and `/product PUT`, `DELETE`, `POST` requests. The `/products?id=1 GET` requests
    that it return a list of products for the given category ID. Hence, the `product*`
    maps to both `/product` and `/products` in the URL.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路径配置为`/product*/**`。为什么有三个`*`？如果您记得，我们的`product`服务可以处理两种类型的REST服务：`/product/1
    GET`和`/product PUT`，`DELETE`，`POST`请求。`/products?id=1 GET`请求要求它返回给定类别ID的产品列表。因此，`product*`映射到URL中的`/product`和`/products`。
- en: The `false` setting of `stripPrefix` lets the `/product/` pass on to the `product`
    service. If the flag is not set, then only the rest of the URL after `/product*/`
    will be passed on to the microservice. Our `product` microservice has mapping
    including the `/product`, hence we want the prefix to be preserved when forwarding
    to the `product` service.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`stripPrefix`的`false`设置允许`/product/`传递到`product`服务。如果未设置该标志，则仅在`/product*/`之后的URL的其余部分将传递给微服务。我们的`product`微服务包括`/product`，因此我们希望在转发到`product`服务时保留前缀。'
- en: Running them all at once
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一次性运行它们
- en: 'Let''s now try to run our `product` service, along with the rest of the ecosystem:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试运行我们的`product`服务，以及其他生态系统的其余部分：
- en: Start the services in the reverse order of dependency.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照依赖关系的相反顺序启动服务。
- en: Start the config server and the Eureka server by running the main class of the
    projects or through Maven.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行项目的主类或通过Maven启动配置服务器和Eureka服务器。
- en: Start the `product` service.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`product`服务。
- en: Start the Zuul service.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Zuul服务。
- en: Watch the log windows and wait till all servers start.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 观察日志窗口，并等待所有服务器启动。
- en: 'Now, run the following requests in your browser:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在浏览器中运行以下请求：
- en: '`http://localhost:8080/product/3`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/product/3`'
- en: '`http://localhost:8080/products?id=1`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/products?id=1`'
- en: You should see product `3` listed in the first request and the products corresponding
    to category `1` in the second request.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在第一个请求中看到产品`3`，在第二个请求中看到与类别`1`对应的产品。
- en: 'Let''s have a look at the logs of Zuul and `product` service:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Zuul和`product`服务的日志：
- en: 'In Zuul, you can see that the mapping of the `/product*/**` was resolved and
    the endpoint to the `product` service was fetched from the Eureka registry:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Zuul中，您可以看到`/product*/**`的映射已经解析，并且从Eureka注册表中获取了指向`product`服务的端点：
- en: '![](img/24bb51b3-7381-4e33-804a-df7c8fa71fdd.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24bb51b3-7381-4e33-804a-df7c8fa71fdd.png)'
- en: Zuul edge is now registered to map requests for `product` service, and forward
    it to the service address pointed by Eureka
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `product` service, the service execution has happened by running the
    queries on the database:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/52c0c7ce-1671-49fe-8722-fd28fa7b3c6d.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: Kubernetes – container orchestration
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been individually deploying the services such as Eureka, the
    config server, the `product` service, and Zuul.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Recollecting from the previous chapter, we can automate their deployment through
    CI, such as Jenkins. We also saw how the deployment could be done with Docker
    containers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: However, during runtime, the containers still run independently of each other.
    There is no mechanism to scale the containers, or to restart them if one has failed.
    Also, the decision on which service to deploy on which VM is manual, which means
    that the services always get deployed onto the static VMs that are designated
    for the services to run, instead of being mixed and matched intelligently. In
    short, the orchestration layer managing our application services is missing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes is a popular orchestration mechanism that makes deployment and runtime
    management an easier task.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes architecture and services
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes is an open source project spearheaded by Google. It attempts to
    implement some of the tried-and-tested ideas that were implemented in its own
    internal container orchestration system called Borg. Kubernetes architecture is
    composed of two components: the master and minion nodes. The master nodes have
    the following components:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '**Controller**: To manage the nodes, replicas, and services'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API Server**: To provide REST endpoints used by the `kubectl` client and
    the minion nodes'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheduler**: To decide where a particular container must be spawned'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Etcd**: To store the state of the cluster and configurations'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The minion nodes contain two components:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubelet**: An agent to communicate resource availability to the master and
    launch the containers specified by the scheduler'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proxy**: To route network requests to the kubernetes services'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/5d4b9703-fa3e-4db5-a199-03ea0c786a63.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: 'Kubernetes is a container scheduler which uses two primitives, namely Pod and
    Service. A Pod is a collection of related containers which may be tagged with
    certain Labels; a service can target Pods using these Labels and expose endpoints.
    The following diagram illustrates the concept:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41cab5e8-0a49-4c89-9726-46c9fd266bda.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: Pods are considered ephemeral in kubernetes and may be killed. However, if the
    Pods were created using a `ReplicaSet`, where we can specify how many replicas
    or instances of a certain Pod have to be present in the system, then the kubernetes
    scheduler will automatically schedule new instances of the Pod and once the Pod
    becomes available, the service will start routing traffic to it. As you may notice
    that a Pod may be targeted by multiple services provided the labels match, this
    feature is useful to do rolling deployments.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: We will now look at how to deploy a simple API on kubernetes and do a rolling
    upgrade.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Minikube
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Minikube is a project that helps in running a working, single-node Kubernetes
    on a virtual machine.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: You can install Minikube by following the instructions at: [https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows, ensure that the following steps have been completed:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The kubectl binary also needs to be downloaded and placed in the path so that
    once Minikube gets kubernetes running, we can communicate and manage the kubernetes
    resources from the command prompt. You can download it from: [https://storage.googleapis.com/kubernetes-release/release/v1.9.0/bin/windows/amd64/kubectl.exe.](https://storage.googleapis.com/kubernetes-release/release/v1.9.0/bin/windows/amd64/kubectl.exe)
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to run Minikube from the same drive (say, `C:`) where your `Users`
    directory is present.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running product service in Kubernetes
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s change our existing `product` service to run through Kubernetes container
    orchestration:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f01f2726-0de2-4bfd-87d7-0f8cf6e4e413.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: 'You can test if the configuration is working by running it, as shown in the
    following screenshot:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/19de38b0-2e91-45bd-ae55-83c6ba149d05.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: 'Set up the Docker client to connect to the Docker daemon running within the
    Minikube VM as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/84475ab0-4a51-42ae-b1e4-98c7e510e0b4.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: 'Build the Docker image from the instructions in the previous chapters where
    we created a Docker image as follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d987e67b-6356-4a15-b07e-c2f3c3bb0399.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: 'Create a `deployment` file (note that the `imagePullPolicy` is set to `never`,
    because otherwise, the default behavior of Kubernetes is to pull from the Docker
    registry):'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/30100249-a874-4443-ab31-f3181c8231c5.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: 'Verify that the three instances are running:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/91f1f85e-0fb3-41e5-ab63-c0c77010337a.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: 'Create a `service.yml` file, so that we can access the Pods:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0b2f2649-3ddf-42bd-aa5e-03d1c68cb9e8.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: 'Now, run the `service.yml` file as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef8eb953-aca4-49d1-b4be-74afbec0f24c.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: 'Now, you can get the address of the service:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d34e0441-3d00-4e5a-83b5-ca4fd0ba12fe.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: 'You can now access the API, which will route requests to all three Pods:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92706603-f244-4aec-85a9-7ed96aa943e3.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: 'You may use `-v` for individual commands to get the following details:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac351569-8874-4233-a5b9-c9c170c309e7.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: 'Change the code, as follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5cccf822-15ce-4697-b58d-f8c4f8b289ea.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: 'Build Docker image with a new tag:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/de76ca1a-c146-4a34-a441-4f337b4f8b36.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: 'Update the `deployment.yml` file:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/29c79439-0779-47a2-902c-956032ec8497.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: 'Apply the change:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1ef3e6a9-e013-4f80-8ef7-2e97781e9176.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: Platform as a Service (PaaS)
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another popular runtime for cloud-native applications is to use a PaaS platform,
    specifically, application PaaS platforms. PaaS provides an easy way to deploy
    cloud-native applications. They provide additional services like file storage,
    encryption, key-value storage, and databases which can be easily bound to the
    applications. PaaS platforms also provide an easy mechanism to scale cloud-native
    applications. Let's now understand why PaaS platforms provide an excellent runtime
    for cloud-native applications.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The case for PaaS
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the runtime architecture realization, we saw that a number of components,
    such as the config server, the service registry, the reverse proxy, monitoring,
    log aggregation, and metrics have to come together to realize a scalable microservices
    architecture. With the exception of the business logic in `ProductService`, the
    rest of the services and components were pure supporting components, thus involving
    a lot of platform building and engineering.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: What if all the components we built came out of the box in a platform which
    was provided as a service? Thus, PaaS is a higher level of abstraction over container
    orchestration. PaaS provides all the basic infrastructure services which we discussed
    in container orchestration, such as restarting services, scaling them, and load
    balancing, out of the box. In addition, PaaS offers additional services that complement
    the development, scaling, and maintenance of cloud-native applications. This approach
    has a trade-off that it reduces the choices in the selection and fine-tuning of
    the components. However, for most enterprises focusing on the business problem,
    this will be a fine trade-off to have.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Thus, with PaaS, the developer can now concentrate on writing the code and not
    worrying about the infrastructure he/she is going to deploy on. All the engineering
    now becomes configuration that the developers and operations team can configure.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b373ec4d-7682-4bd1-b02e-ffad352f4447.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: 'Another few advantages of the PaaS include:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '**Runtimes**: Providing various runtimes for developer to develop services,
    such as Java, Go, Node.js, or .NET. Thus, the developer focuses on generating
    a deployment, which can run in the various runtimes provided by the PaaS environment.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时**：为开发人员提供各种运行时，如Java、Go、Node.js或.NET。因此，开发人员专注于生成部署，可以在PaaS环境提供的各种运行时中运行。'
- en: '**Services**: PaaS provides application services, such as databases and messaging
    out of the box for the applications to use. This is beneficial, as the developers
    and the operations do not have to install or manage them separately.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：PaaS提供应用程序服务，如数据库和消息传递，供应用程序使用。这是有益的，因为开发人员和运营人员不必单独安装或管理它们。'
- en: '**Multi-cloud**: PaaS abstracts the developer from the underlying infrastructure
    (or IaaS). Thus, the developer can develop for the PaaS environment, without worrying
    about deploying it in a data center or to various cloud providers such as AWS,
    Azure, or the Google Cloud Platform, if the PaaS runs on these infrastructures.
    This avoids lock-in to an infrastructure or cloud environment.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多云**：PaaS将开发人员与基础架构（或IaaS）抽象出来。因此，开发人员可以为PaaS环境开发，而不必担心将其部署在数据中心或各种云提供商（如AWS、Azure或Google
    Cloud Platform）上，如果PaaS在这些基础设施上运行。这避免了对基础设施或云环境的锁定。'
- en: The trade-off of the PaaS environment is that they can be restrictive and reduce
    flexibility. The default services and runtime selected may not be suitable for
    all use cases. However, most PaaS providers provide plug points and APIs to include
    more services and configurations, and policies to fine tune the runtime behaviors,
    which can mitigate the trade-offs.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: PaaS环境的权衡是它们可能会限制并降低灵活性。默认选择的服务和运行时可能不适用于所有用例。然而，大多数PaaS提供商提供插入点和API来包含更多服务和配置，并提供策略来微调运行时行为，以减轻权衡。
- en: Cloud Foundry
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cloud Foundry
- en: Cloud Foundry is one of the most mature open source PaaS owned by the Cloud
    Foundry foundation.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Foundry是Cloud Foundry基金会拥有的最成熟的开源PaaS之一。
- en: 'It is primarily composed of, following parts:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 它主要由以下部分组成：
- en: '**Application runtime**: The foundation platform, where the developer deploys
    the application workloads like Java or Node.js applications. Application runtime
    provides for capabilities like application life cycle, application execution,
    and supporting functions, such as routing, authentication, platform services,
    including messaging, metrics, and logging.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序运行时**：开发人员部署Java或Node.js应用程序等应用程序工作负载的基础平台。应用程序运行时提供应用程序生命周期、应用程序执行和支持功能，如路由、身份验证、平台服务，包括消息传递、指标和日志记录。'
- en: '**Container runtime**: The runtime abstraction where the containers run. This
    provides deployment, management, and integration of the containers on which the
    applications run, using Kubernetes as the base platform. It is based on project
    Kubo.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器运行时**：容器运行的运行时抽象。这提供了基于Kubernetes的容器的部署、管理和集成，应用程序运行在其上，它基于Kubo项目。'
- en: '**Application services**: These are services like databases that the application
    binds to. Typically, they are provided by third-party providers.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序服务**：这些是应用程序绑定的数据库等服务。通常由第三方提供商提供。'
- en: '**Cloud Foundry components**: There are a lot of them, such as BOSH (for container
    runtime), Diego (for application runtime), **Bulletin Board System** (**BBS**),
    NATS, Cloud Controller, and so on. However, these are responsible for providing
    various capabilities of PaaS and can be abstracted from the developers. They are
    of relevance and interest to the operations and infrastructure.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cloud Foundry组件**：有很多，比如BOSH（用于容器运行时）、Diego（用于应用程序运行时）、**公告板系统**（**BBS**）、NATS、Cloud
    Controller等等。然而，这些组件负责提供PaaS的各种功能，并可以从开发人员中抽象出来。它们与运营和基础设施相关且感兴趣。'
- en: The concept of org, account, and space
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织、帐户和空间的概念
- en: 'Cloud Foundry has an elaborate **role-based access control** (**RBAC**) for
    managing the applications and its various resources:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Foundry具有详细的**基于角色的访问控制**（**RBAC**）来管理应用程序及其各种资源：
- en: '**Org**: This represents an organization, to which multiple users can be bound.
    An org shares the applications, service availability, resource quota, and plans.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组织**：这代表一个组织，可以将多个用户绑定到其中。一个组织共享应用程序、服务可用性、资源配额和计划。'
- en: '**User account**: The user account represents an individual login that can
    act on the applications or operations in cloud foundry.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户帐户**：用户帐户代表可以在Cloud Foundry中操作应用程序或操作的个人登录。'
- en: '**Space**: Every application or service runs in a space that is bound to org
    and managed by a user account. An org has at least one space.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空间**：每个应用程序或服务都在一个空间中运行，该空间绑定到组织，并由用户帐户管理。一个组织至少有一个空间。'
- en: '**Roles and permissions**: The users belonging to org have roles which can
    do restricted actions (or permissions). The details are documented at: [https://docs.cloudfoundry.org/concepts/roles.html](https://docs.cloudfoundry.org/concepts/roles.html).'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角色和权限**：属于组织的用户具有可以执行受限操作（或权限）的角色。详细信息已记录在：[https://docs.cloudfoundry.org/concepts/roles.html](https://docs.cloudfoundry.org/concepts/roles.html)。'
- en: The need for implementations of Cloud Foundry
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cloud Foundry实施的需求
- en: There is a lot of engineering involved in getting the vanilla Cloud Foundry
    installed and running. Hence, there are many PaaS implementations that use Cloud
    Foundry as a foundation and provide additional features, the most popular ones
    being Bluemix from IBM, OpenShift from Redhat, and **Pivotal Cloud Foundry** (**PCF**)
    from Pivotal.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装和运行原始Cloud Foundry中涉及了大量的工程工作。因此，有许多PaaS实现使用Cloud Foundry作为基础，并提供额外的功能，最流行的是IBM的Bluemix、Redhat的OpenShift和Pivotal的**Pivotal
    Cloud Foundry**（PCF）。
- en: Pivotal Cloud Foundry (PCF)
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pivotal Cloud Foundry（PCF）
- en: Pivotal's Cloud Foundry aims to increase developer productivity and operator
    efficiency and to provide security and availability.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Pivotal的Cloud Foundry旨在提高开发人员的生产力和运营效率，并提供安全性和可用性。
- en: 'Though readers of this book are free to choose the PaaS implementations that
    are based on Cloud Foundry, we have chosen Pivotal for a few reasons:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Pivotal has been behind Spring Framework, which we have used amply in the book.
    Pivotal's Cloud Foundry implementation has native support of the Spring Framework
    and its components, such as Spring Boot and Spring Cloud. Hence, the Spring Boot
    deployable that we create can be directly deployed to the application runtime
    of the Cloud Foundry and managed.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pivotal's service marketplace is rich, covering most of the platform components
    by partners including MongoDB, PostgreSQL, Redis, and native support (Pivotal
    developed) services for MySQL and Cloud Cache.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pivotal has been doing a number of releases in this space and hence the service
    offerings are updated frequently.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PCF components
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Pivotal website [pivotal.io/platform](https://pivotal.io/platform) gives
    a very simple diagram for the implementation of Cloud Foundry, which maps to our
    earlier discussion:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '**Pivotal Application Service** (**PAS**): This is an abstraction for applications
    that map to application runtime in Cloud Foundry. Internally, it uses Diego, but
    that is hidden from the developer. PAS has excellent support for Spring Boot and
    Spring Cloud, but can run other Java, .NET, and Node apps as well. It is suitable
    for running custom written application workloads.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pivotal Container Service** (**PKS**): This is an abstraction for containers
    and maps to container runtime in Cloud Foundry. It uses BOSH internally. It is
    suitable for running workloads that are provided as containers, that is, **independent
    service vendor** (**ISV**) applications like Elasticsearch.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pivotal Function Service** (**PFS**): This is a new offering of Pivotal outside
    of the Cloud Foundry platform. It provides abstraction for functions. It promotes
    serverless computing. The functions are invoked on a HTTP request (synchronous)
    or when messages arrive (asynchronous).'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Marketplace**: This maps to the application services in Cloud Foundry. Given
    the popularity of the PCF, there are a lot of services available in the marketplace.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shared components**: These include the supporting services to run functions,
    applications, and containers, such as authentication, authorization, logging,
    monitoring (PCF watch), scaling, networking, and so on.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/adf88116-bf09-47c7-94da-654596b2450f.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: PCF can be run on most of the popular clouds, including Google Compute Platform,
    Azure, AWS, and Open Stack (IaaS), hosted on a data center.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: While PCF and its components are great for the server-side loads, it might be
    cumbersome for developers who are building software on their local machines. We
    are at that stage now. We have developed `product` service and matured through
    various stages to reach cloud-native runtime.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The entire PCF with its runtime components is difficult to fit on a laptop for
    development.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: PCF Dev
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PCF Dev is a condensed PCF distribution that can run locally on a VM on a desktop
    or laptop. It promises to enable the same environment that the developers would
    have on the main PCF environment, so that there is no difference when an application
    meant for PCF Dev runs on the main PCF environment. Refer to the table in [https://docs.pivotal.io/pcf-dev/index.html](https://docs.pivotal.io/pcf-dev/index.html)
    for an exact comparison of the size and capabilities provided by PCF Dev vis-à-vis
    the full PCF and **Cloud Foundry** (**CF**):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: It supports the application runtime for Java, Ruby, PHP, and Python.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a mini version of PAS that gives the essential capabilities for our service
    development that we have discussed so far, such as logging and metrics, routing,
    Diego (Docker) support, application services, scaling, monitoring, and failure
    recovery.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It also comes with four application services built-in, these are: **Spring
    Cloud Services** (**SCS**), Redis, RabbitMQ, and MySQL.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, it is not meant for production. It does not have BOSH, which orchestrates
    over the infrastructure layer.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your desktop/laptop has over 8 GB of memory and disk space over 25 GB, let's
    get started.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PCF Dev can run in a Mac, Linux, or Windows environment. Follow the instructions,
    for example, [https://docs.pivotal.io/pcf-dev/install-windows.html](https://docs.pivotal.io/pcf-dev/install-windows.html)
    for Windows, to get PCF Dev running on your machine. This essentially is in three
    steps:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Getting Virtual Box
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CF command line interface
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the PCF Dev
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting PCF Dev
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first time we start using cf dev start, it will take a long time to download
    the VM image (4 GB), extract it (20 GB), and then start the various services of
    the PCF. Hence, once the VM is downloaded and running, we would just suspend and
    resume the VM with the Cloud Foundry services running.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Command line options for starting PCF Dev are as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Assuming you have a multi-core machine, you can allocate half the cores for
    this VM, such as `-c 2` for a four core machine.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The SCS version will use 8 GB of memory; to keep the buffer, let's use 10 GB
    of memory which is expressed in terms of MB on the command line.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will need the services of MySQL and SCS for the next chapter. Internally,
    SCS needs RabbitMQ to run. Hence, let's include all servers while running the
    instance.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is optional to give the domain and IP address, and hence, we will skip `-d`
    and `-i` options.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the environment variable `PCFDEV_HOME` to a specific folder on a drive that
    has a good amount of space, so that it does not default to the home folder on
    the home drive. We would recommend the home folder to be a fast drive like SSD,
    as the Cloud Foundry start and stop operations are very I/O intensive.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, our start command will be as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will take a long time till finally your PCF Dev environment is ready.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '**Speeding up development time**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: It is difficult to wait 20 minutes while the entire PCF Dev environment is started
    each time. Once you finish working for the day or before shutting down your laptop,
    you can suspend the PCF Dev by  using `cf dev suspend` and resume it the next
    day by using the `cf dev resume` command.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'Other useful commands include:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: A default PCF Dev creates two users—admin and user. To install or manage the
    applications, you should login as one of the users. The command `cf dev target`
    logs you in as a default user.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cf dev trust` command installs a certificate to enable SSL communication,
    so that you don't need to use parameter `-skip ssl` every time you log in on the
    command line or on an application manager in the browser.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cf marketplace` command (once you have logged in as a user) shows the various
    services that can be installed in the org and space.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the output of the commands discussed so far:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46e17970-de5f-4b07-a292-77961ee32592.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
- en: As we can see in the marketplace, since we started the PCF Dev with the all
    services option, we can see the marketplace ready with the seven services.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Creating the MySQL service on PCF
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the list, in this chapter, we will configure our `product` service to work
    with the MySQL database and look at Spring Cloud services, such as the circuit
    breaker dashboard and other services in the next chapter.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Check whether the services are running:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bcb84930-b49d-4642-b4a1-0f83e00a4ed1.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
- en: Running the product service on PCF Dev
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a simplified version of the `product` service that just connects
    to a MySQL service that we created earlier to run queries.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'You can write the practice code from Chapter 3, *Designing Your Cloud-Native
    Application* or download the file from Git to your Eclipse environment. The artifacts
    worth noting are:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Maven file:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that, in the following screenshot, we have renamed our artifact to `pcf-product`.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new dependency worth noting is the `spring-cloud-cloudfoundry-connector`.
    This discovers the services bound to the Cloud Foundry application, such as MySQL
    configuration, and uses them.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have included a MySQL connector for the JPA to connect to the MySQL database:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d4741437-8ef6-4cd0-9131-b22e87c22639.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
- en: 'In the `application.properties` file:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that we have not given any MySQL connection properties, such as database,
    user, or password. These are picked up automatically by the Spring application,
    when the application is uploaded into Cloud Foundry and binds with the MySQL database
    service.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The auto create setting in case of MySQL should be `true` only for development
    purposes as it will recreate the database on every application deploy. In the
    UAT or production profile, this setting will be `none`:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `ProductSpringApp` class is simplified to a plain Spring Boot start up
    application. We will enhance this in the next chapter for metrics, lookup, load
    balancing, monitoring, and management:'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/39007215-027d-4e62-be46-f8704956ab5c.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
- en: The `ProductRepository` class only has one method, called `findByCatId`, listed.
    The rest of the methods, such as `get`, `save`, `delete`, and `update` are automatically
    derived in the repository.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ProductService`, `product`, and other classes are unchanged from those
    in [Chapter 3](dba50b25-08ed-48b1-9d28-6f0faff42ecb.xhtml), *Designing Your Cloud-Native
    Application*.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `manifest.yml` file:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the new file containing instructions for deploying into cloud foundry
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will write the most basic version that has the application name, allotment
    of 1 GB of memory space, and the binding to the MySQL service from CloudFoundry
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The random route lets the application take a route to reach the URL without
    having collisions in case of multiple versions:'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/ea27a340-3fdf-41f8-84bd-a380bb139f74.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
- en: Once your project is ready, run `mvn install` to create the comprehensive `.jar`
    file in the `target` directory. Its name should match the name of the `.jar` in
    the `manifest.yml` file.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to Cloud Foundry
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deploying to Cloud Floundry is simple, use the command `cf push pcf-product`,
    as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51738f77-7096-4b77-8a42-a027d0256861.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
- en: Cloud Foundry does a lot of work creating the application in the space, creating
    routes to reach the application, and then binding the various services with the
    application. You should perhaps read more on Cloud Foundry if you are interested
    in what happens under the hood.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the deployment is complete, you will see the success method, as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61d3c1bf-dda6-43d5-bc43-9285ba8913b7.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: Note the URL which is generated in the preceding screenshot.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: It is `http://pcf-product-undedicated-spirketting.local.pcfdev.io`. We will
    see how to make this URL shorter in the next chapter.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you got an error on startup, for example, with a wrong configuration
    or missing a few steps, you can always check the logs by giving the following
    command in the command line:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, it is time to test our service. In the browser window, run the two services
    that we generally run:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '`http://pcf-product-undedicated-spirketting.local.pcfdev.io/product/1`'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://pcf-product-undedicated-spirketting.local.pcfdev.io/products?id=1`'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will see the response coming from the database, that is, the output and
    logs, as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47e191d7-5992-4cff-ba9b-fffafa2822d3.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
- en: This completes deploying our simple `product` service into PCF on PCF Dev.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw the various runtime components supporting cloud-native
    applications and ran our application on various runtimes, such as Kubernetes and
    Cloud Foundry.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will deploy our service on AWS Cloud.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL

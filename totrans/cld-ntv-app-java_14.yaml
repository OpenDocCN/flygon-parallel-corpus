- en: Digital Transformation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The advent of cloud computing is impacting every facet of the enterprise landscape.
    From the core infrastructure to the client-facing applications, the enterprise
    landscape is seeing the impact of the forces of change. Some enterprises are the
    leading harbingers of these transformations, while others are still trying to
    figure out where to start and what to do. Depending upon the maturity of the industry
    domain, the transformation journey can be very different. Some domains are the
    first to adopt technology trends (such as BFSI), while others wait for technology
    obsolescence to adopt new technology (manufacturing, utilities). In this chapter,
    we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Mapping the application portfolio for digital transformation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking an existing monolithic application into a distributed cloud-native
    application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes required at the process, people, and technology levels
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your own platform services (control versus delegation)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application portfolio rationalization
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The decision for digital transformation is typically mapped to a larger application
    portfolio. The external forces in terms of customer-centricity, better customer
    experiences, compliance/regulatory, the advent of cloud computing, open source,
    and so on lead to enterprises looking at their entire application landscape and
    identifying areas to improve, enhance, and rework.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The initial step is to identify the opportunities or the applications that need
    to be transformed for cloud deployment. In this step, we typically do an overall
    portfolio analysis across business and technical parameters. These parameters
    help provide a weighted score of the portfolio. Using the score, we can map the
    applications across four quadrants. These quadrants help us identify where to
    focus and where we will see the maximum value.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Portfolio analysis – business and technical parameters
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application is measured and scored across business and technical parameters.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters for technical value are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: IT standards compliance
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture standards compliance
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quality of service
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintainability
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operational considerations
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: License/support cost
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure cost
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project/change cost
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application maintenance cost
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sourcing (insourcing/outsourcing)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The parameters for business value are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Financial impact
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application user impact
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customer impact
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Criticality
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business alignment
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional overlap/redundancy
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regulatory / compliance risk
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service failure risk
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product/vendor stability
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can rate these parameters on a scale of 1-5 (one being the lowest and five
    being the highest).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Mapping these parameters helps us identify cost and complexity hotspots and
    segregate applications based on business capability areas. These application categories
    are further analyzed for inter-dependencies, touch points, integration points,
    and the underlying infrastructure. Using all these, we can analyze the benefits
    and provide recommendations for a transformation roadmap. The next step is based
    on the business value and technical value; we plot the applications in one of
    the following quadrants:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74c6700a-b4de-41c3-9191-68a0df37c21b.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: The scores help us provide the cost-benefit analysis at the application and
    portfolio level. It also helps to identify where there is a functional overlap
    (because of mergers and acquisition activities), understand the lack of business,
    IT alignment, and where the business priorities lie. These can help identify where
    the investment opportunities are and the potential non-core areas.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the preceding basis, the applications in each of the quadrants can be
    further mapped to one of the dispositions as shown in the following diagram:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52b5ea01-ecdf-48e4-b449-9269a51bd586.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: These dispositions provide us with rational opportunities for application across
    the areas which we will discuss in the following sections.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Retire
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the applications that fall into the low business value and low technical
    value can be marked for retirement. These are typically applications that have
    either lost relevance in a different business environment or had new functionality
    implemented.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有属于低商业价值和低技术价值的应用程序都可以被标记为退役。这些通常是在不同的商业环境中失去了相关性或实施了新功能的应用程序。
- en: These applications are marked by low usage and come with a very low business
    risk. One can also identify such applications by aggregating the tickets against
    these applications and usage volumes. Applications with low usage and lower numbers
    of tickets are typically candidates for decommissioning.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用程序的使用率低，商业风险非常低。也可以通过对这些应用程序的工单和使用量进行汇总来确定这类应用程序。使用率低、工单数量较少的应用程序通常是退役的候选者。
- en: Retain
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保留
- en: All applications that come with low technical value and high business value
    fall into this category. The technical maturity might be low, but they provide
    significant value to the business. These applications do not cost too much to
    run from an IT perspective. We can keep the lights switched on for these applications,
    as these still provide significant value to the business.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所有具有低技术价值和高商业价值的应用程序都属于这一类。技术成熟度可能较低，但它们为业务提供了重大价值。从IT角度来看，这些应用程序的运行成本并不高。我们可以保持这些应用程序的运行，因为它们仍然为业务提供了重大价值。
- en: Consolidate
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整合
- en: All applications that come with a high technical value and low business value
    fall into this category. The high technical value might be a result of the high
    cost of technical support, lack of people with technical skills, lack of documentation,
    and so on. The business can articulate the value of the applications, but the
    current spend on these applications might not be justifiable. These sets of applications
    need to be migrated and consolidated to upgrade the technical currency.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所有具有高技术价值和低商业价值的应用程序都属于这一类。高技术价值可能是由于技术支持成本高、缺乏技术技能的人员、缺乏文档等。业务可以阐明这些应用程序的价值，但目前对这些应用程序的支出可能无法证明合理。这些应用程序需要迁移和整合以升级技术水平。
- en: Transform
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换
- en: These are the applications that have high technical value and high business
    value. This means the applications have a large user base, multiple releases,
    a large number of tickets, and high infrastructure support costs, but still provide
    a significant advantage to the business. These applications are where the effort
    needs to be put in, because they provide significant differentiators for the organization.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是具有高技术价值和高商业价值的应用程序。这意味着这些应用程序拥有大量用户、多次发布、大量工单和高基础设施支持成本，但仍然为业务提供了重大优势。这些应用程序是需要付出努力的地方，因为它们为组织提供了重大的差异化。
- en: Using the preceding methodology, we can identify the applications that are ripe
    for transformation. For our example, we can take an existing Java/JEE application
    that is currently running on-premises and needs to be transformed for a distributed
    application design model.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述方法，我们可以确定哪些应用程序适合进行转换。例如，我们可以采取一个目前在本地运行并需要转换为分布式应用程序设计模型的现有Java/JEE应用程序。
- en: Monolithic application to distributed cloud-native application
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单片应用程序转换为分布式云原生应用程序
- en: 'The advent of the J2EE specification coupled with application servers providing
    the requisite services led to the design and development of monolithic applications:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: J2EE规范的出现，加上应用服务器提供的必要服务，导致了单片应用程序的设计和开发：
- en: '![](img/8e333613-c3c5-4408-bf91-506c0c9a7944.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e333613-c3c5-4408-bf91-506c0c9a7944.png)'
- en: 'Some of the characteristics of the monolithic application and its ecosystem
    are:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 单片应用程序及其生态系统的一些特征是：
- en: Everything is packaged into a single `.ear` file. The single `.ear` file requires
    a multi-month test cycle, which results in a reduced velocity of change in production.
    Typically, a *big* push to production once or twice a year.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有内容都打包到一个单一的`.ear`文件中。 单一的`.ear`文件需要进行为期数月的测试周期，这导致了生产中变更速度的降低。通常一年或两年进行一次*大规模*的生产推动。
- en: Application build complexity is very high with dependencies across various modules.
    At times, there is a clash between the versions of the JAR files used by the application.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序构建复杂性非常高，跨各种模块存在依赖关系。有时，应用程序使用的JAR文件版本之间会发生冲突。
- en: Reuse between application is primarily performed by sharing `.JAR` files.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序之间的重复使用主要通过共享`.JAR`文件来实现。
- en: Huge bug and feature databases—from a backlog perspective, there are many feature
    sets/bugs across the various application modules. At times, some of the backlogs
    might be at loggerheads with each other.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 庞大的错误和功能数据库——从积压的角度来看，各种应用程序模块中存在许多功能集/错误。有时，一些积压可能会相互冲突。
- en: User acceptance criteria usually undefined. There are some smoke tests, but
    by and large, new features and integration is mostly visible in production only.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户验收标准通常未定义。有一些冒烟测试，但大多数新功能和集成大多只在生产中可见。
- en: Requiring multiple team involvement and significant oversight (business team,
    architecture team, development team, testing team, operations teams, and so on)
    for design, development, and operations management. During the release cycles,
    coordinating between the various teams is a Herculean effort.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要多个团队的参与和重大监督（业务团队、架构团队、开发团队、测试团队、运营团队等）进行设计、开发和运营管理。在发布周期中，协调各个团队之间是一项艰巨的工作。
- en: Technical debt accumulation over a period of time—as new features/functions
    are added to the application, the original design never undergoes any change/refactor
    to account for new requirements. This results in a lot of dead and duplicate code
    accumulating in the application.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着时间的推移，技术债务不断积累——随着新功能/功能添加到应用程序中，原始设计从未进行任何更改/重构以适应新的需求。这导致应用程序中积累了大量死代码和重复代码。
- en: Outdated runtimes (licenses, complex updates)—the application might be running
    on an older version of JVM, older application servers and/or database. Upgrade
    costs are high and usually very complex. Planning an upgrade means foregoing any
    feature release during that development cycle. The involvement of multiple teams
    requires complex project management models. The absence of regression test scripts
    makes this even worse.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过时的运行时环境（许可证、复杂的更新）——应用程序可能在较旧版本的JVM、较旧的应用服务器和/或数据库上运行。升级成本高且通常非常复杂。规划升级意味着在该开发周期内放弃任何功能发布。多个团队的参与需要复杂的项目管理模型。缺乏回归测试脚本使情况变得更糟。
- en: The technical design-led approach followed by the team. The architecture and
    design is frozen upfront before development starts. As the application grows,
    new features/functions are getting added, there is no second look at the application
    architecture/design.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队采用了技术设计导向的方法。架构和设计在开发开始之前就已经确定。随着应用程序的增长，新的功能/功能被添加，不再重新审视应用程序架构/设计。
- en: Barely any business components or domains are used. The application design is
    usually sliced horizontally based on the tiers (presentation tier, business tier,
    integration tier, and database tier) and on the customer/application flows into
    specific modules/patterns. For example, applications making use of the MVC pattern
    will create packages along the lines of model, views, and controllers, with value
    and common thrown in.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎没有使用业务组件或域。应用程序设计通常是根据层（表示层、业务层、集成层和数据库层）和客户/应用程序流程切片，进入特定的模块/模式。例如，使用MVC模式的应用程序将创建类似于模型、视图和控制器的包，还有值和常用包。
- en: Usually, there is a single database schema for the entire application. There
    is no segregation of the functionality at the database level. The domains are
    linked to each other with foreign keys and databases following the third normalization
    form. The application design is usually bottom-up, with the DB schema determining
    the application database tier design.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，整个应用程序只有一个数据库模式。在数据库级别没有功能的分离。域通过外键相互连接，数据库遵循第三范式。应用程序设计通常是自下而上的，数据库模式决定了应用程序数据库层的设计。
- en: The average enterprise application will have more than 500k lines of code, with
    plenty of boilerplate code. As the application grows, there will be plenty of
    dead and duplicate code in the source code base.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均企业应用程序将有超过50万行代码，其中有大量样板代码。随着应用程序的增长，源代码库中将有大量死代码和重复代码。
- en: Applications typically supported by heavyweight infrastructure—the abilities
    of the application are managed by adding more and more hardware. Server clustering
    is used to scale the application.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序通常由笨重的基础设施支持——通过增加更多硬件来管理应用程序的能力。服务器集群用于扩展应用程序。
- en: Thousands of test cases lead to increased time to run the regression test suite.
    At times, the release will skip the regression test suite to speed up the cycle.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成千上万的测试用例导致回归测试套件运行时间增加。有时，发布将跳过回归测试套件以加快周期。
- en: The team size is higher than 20 in most of these projects.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数这类项目的团队规模超过20人。
- en: We can see that, in the case of monolithic applications, the business velocity
    and rate of change is very low. This model may have worked 10-15 years back. In
    today's competitive market, the ability to release features/functions at an incredible
    pace is paramount. You are not just competing with other large enterprises but
    with a lot of smaller nimbler start-ups that do not have the baggage of legacy
    applications, technologies, and processes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在单片应用程序的情况下，业务速度和变化速度非常低。这种模式可能在10-15年前有效。在当今竞争激烈的市场中，以令人难以置信的速度发布功能/功能的能力至关重要。你不仅仅是在与其他大型企业竞争，还要与许多没有传统应用程序、技术和流程包袱的更灵活的初创企业竞争。
- en: The advent of open source growth of consumer companies, and growing mobile devices,
    among other factors, led to innovation in the application architecture space and
    more distributed applications driven by microservices and reactive models. The
    monolithic applications got decomposed into smaller sets of applications/services.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 开源的兴起、消费者公司的增长以及移动设备的增多等因素导致了应用程序架构领域的创新，以及更多由微服务和反应性模型驱动的分布式应用程序。单片应用程序被分解成更小的应用程序/服务集。
- en: 'Next, we will explore the key architecture concerns that go with a distributed
    application. We will see how these key concerns map to the overall application
    technical capabilities and what capabilities should be hired and what should be
    built:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨与分布式应用程序相关的关键架构问题。我们将看到这些关键问题如何映射到整体应用程序的技术能力，以及应该雇用哪些能力，应该建立哪些能力。
- en: '![](img/cc6c12b2-74b7-46b6-ba1e-f5c665efba34.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc6c12b2-74b7-46b6-ba1e-f5c665efba34.png)'
- en: 'Some of the characteristics of the distributed application and its ecosystem
    are:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式应用程序及其生态系统的一些特征包括：
- en: '**Lightweight runtime containers**: The advent of microservices correlates
    to the demise of the heavyweight JEE containers. As the applications morph into
    microservices with a singular purpose and loose coupling, there is a need to simplify
    the container managing the component lifecycle. The advent of Netty led to the
    development of the reactive framework that was just right for the purpose.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻量级运行时容器：微服务的出现与笨重的JEE容器的消亡相关。随着应用程序变成具有单一目的和松散耦合的微服务，有必要简化管理组件生命周期的容器。Netty的出现导致了反应性框架的发展，正好符合这一目的。
- en: '**Transaction management**: Another causality of the application simplification
    was transaction management. Bounded context means the services are not talking
    to multiple resources and trying to do a two-phase commit transaction. Patterns
    such as CQRS, Event Store, **Multi Version Concurrency Control** (**MVCC**), eventual
    consistency, and so on, helped simplify and move the application to model a where
    locking resources are not needed.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务管理**：应用简化的另一个牺牲品是事务管理。有界上下文意味着服务不会与多个资源交互，并尝试进行两阶段提交事务。诸如CQRS、事件存储、多版本并发控制（MVCC）、最终一致性等模式有助于简化并将应用程序移动到不需要锁定资源的模型。'
- en: '**Service scaling**: Breaking the application allows individual services to
    be scaled up and out independently. Using the Pareto principle, 80% of the incoming
    traffic is handled by 20% of the services. The ability to scale these 20% services
    becomes a significant driver toward the higher availability SLAs.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务扩展**：拆分应用程序允许单独扩展各个服务。使用帕累托法则，80%的流量由20%的服务处理。扩展这20%的服务的能力成为更高可用性SLA的重要驱动因素。'
- en: '**Load balancing**: Unlike the monolithic application, where the load balancing
    was between the application server cluster nodes, in the case of distributed applications,
    the load balancing is across the service instances (running in Docker-like containers).
    These service instances are stateless and typically can go up/down very frequently.
    The ability to discover the instances that are active and which are not active
    becomes a key feature of the load balancing.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡**：与单体应用程序不同，单体应用程序的负载均衡是在应用服务器集群节点之间进行的，而在分布式应用程序的情况下，负载均衡是跨服务实例（在类似Docker的容器中运行）进行的。这些服务实例是无状态的，通常会频繁上下线。发现活动实例和非活动实例的能力成为负载均衡的关键特性。'
- en: '**Flexible deployment**: One of the key abilities of the distributed architecture
    is moving from a rigid cluster deployment model to a more flexible deployment
    model (cattle versus pets), where the deployment instances are deployed as immutable
    instances. Orchestration engines such as Kubernetes allow the optimum utilization
    of the underlying resources and take away the pain of managing/deploying hundreds
    of instances.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活部署**：分布式架构的一个关键能力是从严格的集群部署模型转变为更灵活的部署模型（牛群与宠物），其中部署实例被部署为不可变实例。诸如Kubernetes之类的编排引擎允许最佳利用底层资源，并消除了管理/部署数百个实例的痛苦。'
- en: '**Configuration**: As the service instance becomes immutable, the service configuration
    is abstracted out of the services and held in a central repository (configuration
    management server). The service at boot time, or as part of the service initialization,
    picks up the configuration and starts in the available mode.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：随着服务实例变得不可变，服务配置被抽象出来并保存在中央存储库（配置管理服务器）中。服务在启动时，或作为服务初始化的一部分，获取配置并以可用模式启动。'
- en: '**Service discovery**: The use of stateless immutable service instances running
    over commodity hardware means the services can go up and down at any time. The
    clients invoking these services should be able to discover the service instances
    at runtime. This feature, along with load balancing, helps maintain the service
    availability. Some new products (such as Envoy) have merged service discovery
    with load balancing.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现**：使用无状态不可变服务实例在通用硬件上运行意味着服务可以随时上下线。调用这些服务的客户端应能够在运行时发现服务实例。这一特性，连同负载均衡，有助于维护服务的可用性。一些新产品（如Envoy）已将服务发现与负载均衡合并。'
- en: '**Service versions:** As the services start getting consumers, there will be
    a need to upgrade the service contracts to accommodate new features/changes. In
    this case, running multiple versions of the service becomes paramount. You will
    need to worry about moving the existing consumers to a new service version.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务版本**：随着服务开始获得消费者，将需要升级服务契约以适应新功能/变更。在这种情况下，运行多个版本的服务变得至关重要。您需要担心将现有消费者迁移到新的服务版本。'
- en: '**Monitoring**: Unlike the traditional monolithic monitoring that focused on
    infrastructure and application server monitoring, the distributed architecture
    requires monitoring at the transaction level as it flows through the various service
    instances. **Application performance management** (**APM**) tools such as AppDynamics,
    New Relic, and so on are used to monitor the transactions.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控**：与传统的单体监控侧重于基础设施和应用服务器监控不同，分布式架构需要在事务级别进行监控，因为它流经各种服务实例。应用性能管理（APM）工具如AppDynamics、New
    Relic等用于监控事务。'
- en: '**Event handling / messaging / asynchronous communication**: Services do not
    talk to each other on a point-to-point basis. Services make use of asynchronous
    communication through events as a means to decouple them from each other. Some
    of the key messaging tools such as RabbitMQ, Kafka, and so on are used to bring
    asynchronous communication between the services.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件处理/消息传递/异步通信**：服务不是基于点对点进行通信的。服务利用事件作为一种异步通信的手段来解耦。一些关键的消息传递工具，如RabbitMQ、Kafka等，用于在服务之间进行异步通信。'
- en: '**Non-blocking I/O**: The services themselves make use of the non-blocking
    I/O models to get the maximum performance from the underlying resources. Reactive
    architecture is being pursued by microservices frameworks (with the likes of Play
    framework, Dropwizard, Vert.x, Reactor, and so on) used to build the underlying
    services.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非阻塞I/O**：服务本身利用非阻塞I/O模型从底层资源中获得最大性能。反应式架构正在被微服务框架追求（如Play框架、Dropwizard、Vert.x、Reactor等）用于构建底层服务。'
- en: '**Polyglot services**: The advent of the distributed application and using
    APIs as integration allows the service instance to be built with best-of-breed
    technologies. Since the integration model is JSON over HTTP, the services can
    be polyglot, allowing the use of the right technologies to build the services.
    The services can also make use of different data stores based on the type of service
    requirements.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High-performance persistence**: With the services owning their own data stores,
    the read/write services need to handle large volumes of concurrent requests. Patterns
    such as **Command Query Request Segregation** (**CQRS**) allow us to segregate
    the read/write requests and move to the data store to an eventual consistency
    model.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API management**: Another key ingredient of the distributed architecture
    is the ability to abstract out concerns such as service throttling, authentication/authorization,
    transformation, reverse proxy, and so on and move to an external layer called
    API management.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Health check and recovery**: Services implement health checks and recovery
    in order for the load balancer to discover the healthy service instances and remove
    the unhealthy ones. The services implement the heartbeat mechanism which is used
    by the service discovery mechanism to track healthy/unhealthy services across
    the application landscape.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-service security:** Service-to-service invocation needs to be secured.
    Data in motion can be protected by a secured communication (HTTPS) or by encrypting
    the data over the wire. The services can also use public/private keys to match
    which client services can call the other services.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We saw some of the architecture concerns needed to build a distributed application.
    To cover the scope of the overall application, built as a bunch of microservices,
    we are looking at the following key architecture concerns across the various areas:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac53a31f-61c7-4325-b819-738e65b2f28f.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: For the application to be cloud-native, it is important to build the application
    using SaaS/PaaS offered by the cloud vendor. This model allows you to focus on
    the pivoting on the business functionality, improve your innovation cadence, and
    improve the customer experience. Unless technology is not a key differentiator
    for the organization, the running of the core infrastructure and platform services
    should be left to the experts. In cases where there is a huge variability in demand,
    cloud elastic scale models provide an impetus. I do not want to do the marketing
    for cloud vendors, but unless the infrastructure is not an important aspect of
    your business, you should not be running the infrastructure.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The only downside of this is you are getting tied to the services offered by
    the cloud provider. Organizations are going with multi-cloud vendor strategies,
    where they spread their application and they take advantage of the key differentiators
    of the cloud vendors. For example, GCP provides a rich library of analytical and
    machine learning capabilities, with the ability to run your analytical workloads
    and decipher meaning insights, and **Machine Learning** (**ML**) models are one
    way to use the best-of-breed features. Similarly, for consumer-facing applications,
    AWS provides a rich set of PaaS services that can be used to launch and pivot
    on client-centric solutions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Transformation of a monolithic application to a distributed application
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a monolithic application and see what steps are
    required for it to be architected into a distributed application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: We are assuming a typical Java application running on an application server,
    scaled through a clustering model and using a typical RDBMS. The application is
    already in production and needs to be refactored/migrated to a distributed architecture.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about multiple parallel tracks that need to work together to refactor/roll
    out the distributed application. We will cover individual tracks initially and
    then see them all come together. In your organization, you might choose to have
    separate teams for each track or one team managing more than one track. The idea
    is to provide you with a glimpse of the activities involved in actual transformation
    of a monolithic application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Customer journey mapping to domain-driven design
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key driver to start the digital transformation is defining new customer
    journeys and building a new customer experience. This customer-centricity is what
    pushes the business to fund the digital transformation program. For our case,
    we can assume that the business has approved the digital transformation program
    and we proceed from there.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'From a service decomposition perspective, we need to follow the steps mentioned
    here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40b2159c-2db2-4bb6-8961-45f4bc9a67a3.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: '**Customer experience journey mapping**: One of the key drivers for digital
    transformation is defining new customer journeys. A customer experience journey
    is a map of initial contact point of customer, through the process engagement
    model. This exercise is typically done by specialists and involves customer focus
    studies, touch points, actors/systems involved, business requirements, and competition
    analysis, among other things. The customer journey is typically created as an
    infographic.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A customer journey helps identify the gaps as the customer interactions move
    across devices, channels, or processes. It helps plug those gaps and identify
    means and ways to enhance the overall customer experience.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '**Deriving the domain models**: The customer experience journey maps are mapped
    for the current and future requirements. These requirements then form the basis
    for the user stories. For new applications, the requirements can form the basis
    for functional decomposition of the system. In case of an existing application,
    the system might already be decomposed into identifiable domains/sub-domains.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have the requirements, we can start identifying the various sub-domains
    within the system. The domain model is documented using ubiquitous language. The
    whole idea is to use a language that is understood both by business and technology
    teams.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The domains are modeled around entities and their functions. We also consider
    dependencies which interoperate among the functions. Usually, as a first pass,
    we end up with a big ball of mud, where all the known entities and functions have
    been identified. For smaller applications, the domain model might be the right
    size, but for larger applications, the big ball will need to be broken down further,
    and that's where the bounded context comes in.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the bounded context**: The big ball of mud needs to be broken down
    into smaller chunks for easy adoptability. Each of these smaller chunks or bounded
    contexts has its own business context that is built around a specific responsibility.
    Context can also be modeled around how the teams are organized or how the existing
    application code base is structured.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no rules to define how the context is defined, but it is very important
    that everybody understands the boundary conditions. You can create context maps
    to map out the domain landscape and make sure that the bounded context is clearly
    defined and mapped. There are various patterns (for example, Shared Kernel, Conformist,
    Producer/Supplier, and so on) that can be applied to map out the bounded context.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '**Service decomposition**: Using the bounded context, we can identify the teams
    that will work as part of one bounded context. They will focus on the services
    that need to be produced/consumed to provide functionality as part of the bounded
    context. The business capabilities are decomposed into individual microservices.
    The service can be decomposed based on the following principles:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single responsibility**: First and foremost is the scope of the service and
    the capability that will be exposed by the service'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一责任**：首先是服务的范围和服务将公开的能力'
- en: '**Independent**: Changes in function/feature requirement should be limited
    to one service, allowing the one team to own and complete the same'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立**：功能/特性需求的更改应该限制在一个服务中，允许一个团队拥有并完成相同的需求。'
- en: '**Loose coupling**: The services should be loosely coupled, allowing them to
    evolve independent of each other'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松耦合**：服务应该松散耦合，允许它们独立演进'
- en: '**Mapping the up/down stream service dependency**: As the services are identified
    in each of the domains, the services can be mapped as for dependency. Core entity
    services that encapsulate the system of records are the upstream services. Changes
    from the upstream services are published as events that are subscribed or consumed
    by the downstream services.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射上/下游服务依赖**：随着在每个领域中识别出的服务，这些服务可以根据依赖关系进行映射。封装记录系统的核心实体服务是上游服务。来自上游服务的更改被发布为事件，由下游服务订阅或消费。'
- en: '![](img/37965ca6-ac3c-49c6-b243-1a2fce68eb0c.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37965ca6-ac3c-49c6-b243-1a2fce68eb0c.jpg)'
- en: Defining the architecture runway
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义架构跑道
- en: The business application needs to sit on the shoulders of a platform. The platform
    can be built or bought, depending on the business and application needs. The organization
    needs to define an intentional architecture model and define the rail guards to
    make sure the teams are building services within the given technical constraints.
    The platform team owns this overarching architecture, chooses the architecture
    and technical components, and helps build any common concerns required for successful
    running of the application services.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 业务应用程序需要建立在一个平台之上。平台可以根据业务和应用程序的需求进行构建或购买。组织需要定义一个有意识的架构模型，并定义铁路护栏，以确保团队在给定的技术约束条件下构建服务。平台团队拥有这个全面的架构，选择架构和技术组件，并帮助构建应用服务成功运行所需的任何共同关注点。
- en: '![](img/1e693cdb-0ced-4d43-b5b6-8d74f605d328.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e693cdb-0ced-4d43-b5b6-8d74f605d328.jpg)'
- en: '**Platform architecture**: One of the key ingredients of a successful distributed
    architecture is the underlying platform. One can choose to build the platform
    by using off-the-shelf, open source / commercial software (Red Hat OpenStack,
    Cloud Foundry, and so on) or can choose a strategic cloud provider (such as AWS,
    Azure) to start building the platform. The elastic nature of the underlying infrastructure
    (compute, network, and storage) provides the fundamental building blocks for the
    platform.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台架构**：成功的分布式架构的关键要素之一是底层平台。可以选择使用现成的、开源/商业软件（如Red Hat OpenStack、Cloud Foundry等）来构建平台，也可以选择战略性的云提供商（如AWS、Azure）来开始构建平台。底层基础设施（计算、网络和存储）的弹性特性为平台提供了基本的构建模块。'
- en: '**Tech selection, validation, and integration**: To build the platform services,
    you might want to evaluate multiple sets of technologies to determine what works
    the best in your ecosystem. The tech stack evaluation is typically a multiple-step
    process where the requirements are mapped to the available technologies/products,
    and a detailed series of steps to validate is undertaken, resulting in a matrix
    with regards to the integration of the technologies.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术选择、验证和集成**：为了构建平台服务，您可能希望评估多组技术，以确定在您的生态系统中哪种技术最有效。技术堆栈评估通常是一个多步骤的过程，其中需求被映射到可用的技术/产品，并进行详细的验证步骤，最终形成一个关于技术集成的矩阵。'
- en: '**Design decisions**: The result of the technology evaluations is mapped to
    the underlying requirements, resulting in a matrix. This matrix is used to determine
    the best fit and help take a design decision. This step works in close conjunction
    with the previous step.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计决策**：技术评估的结果被映射到基本需求，形成一个矩阵。这个矩阵用于确定最佳匹配，并帮助做出设计决策。这一步与前一步密切配合。'
- en: '**Environment setup**: Once the key design decisions are in place, we need
    to start with the environment setup. Depending upon whether the choice is on-premises
    or the cloud, there will be variation in the setup and the related steps. You
    can start with the setup of the development, test, pre-production, and production
    environment. The environments are built in the order of complexity and go through
    multiple iterations (to move from manual to script/automated).'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境设置**：一旦关键的设计决策就位，我们需要开始进行环境设置。根据选择是在本地还是云端，设置和相关步骤会有所不同。您可以从开发、测试、预生产和生产环境的设置开始。环境按复杂性顺序构建，并经历多次迭代（从手动到脚本/自动化）。'
- en: '**DevOps/Maven archetypes**: Next, we start working on the **continuous integration**
    (**CI**) / **continuous deployment** (**CD**) part of the application build and
    deployment. For applications being developed in the Agile model, the CI/CD model
    helps do multiple releases in a day, and bring higher velocity to the entire process.
    We can also develop accelerators to aid the CI/CD process. For example, Maven
    archetypes that come with requisite bindings for creating the deployable artifact.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DevOps/Maven原型**：接下来，我们开始着手应用构建和部署的**持续集成**（**CI**）/ **持续部署**（**CD**）部分。对于在敏捷模型中开发的应用程序，CI/CD模型有助于一天内进行多次发布，并为整个流程带来更高的速度。我们还可以开发加速器来辅助CI/CD流程。例如，Maven原型带有用于创建可部署构件的必要绑定。'
- en: '**Platform services build**: Next comes the set of platform services that need
    to be built/provided to the users of the platform.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台服务构建**：接下来是需要构建/提供给平台用户的一系列平台服务。'
- en: The services are in application development (for example, queuing, workflows,
    API Gateways, email services, and so on), database (for example, NoSQL, RDBMS,
    Cache, and so on), DevOps tooling (for example, CI/CD tools, service registry,
    code repos, and so on), security (such as directory services, key management services,
    certificate management services, **hardware security module** (**HSM**), and so
    on), data analytics (such as Cognitive Services, Data Pipelines, Data lake, and
    so on).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 服务包括应用程序开发（例如排队、工作流、API网关、电子邮件服务等）、数据库（例如NoSQL、RDBMS、缓存等）、DevOps工具（例如CI/CD工具、服务注册表、代码存储库等）、安全性（例如目录服务、密钥管理服务、证书管理服务、硬件安全模块（HSM）等）、数据分析（例如认知服务、数据管道、数据湖等）。
- en: You can buy these services from multiple vendors (such as Tiles, offered as
    part of the **Pivotal Cloud Foundry** (**PCF**), Iron.io platform) or subscribe
    to services provided by cloud vendors or create your own platform services on
    top on products.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从多个供应商那里购买这些服务（例如，作为Pivotal Cloud Foundry（PCF）的一部分提供的Tiles，Iron.io平台），或者订阅云供应商提供的服务，或者在产品的基础上创建自己的平台服务。
- en: '**Non-functional requirements (NFR) concerns**: Once the key platform services
    are in place, and the first set of applications start getting onboarded to the
    platform, we need to start worrying about how to handle the NFR concerns of the
    applications. How will the application scale based on the incoming load, how to
    detect failures, how to maintain minimum threshold of the application, and so
    on. Again, you may want to integrate existing products to your platform that provide/support
    these NFR concerns.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非功能性需求（NFR）问题**：一旦关键平台服务就位，并且第一批应用程序开始接入平台，我们需要开始担心如何处理应用程序的NFR问题。应用程序如何根据传入负载进行扩展，如何检测故障，如何保持应用程序的最低阈值等等。同样，您可能希望将现有产品集成到您的平台，以提供/支持这些NFR问题。'
- en: '**Production concerns**: Last of all, we need to start worrying about the production
    concerns such as service management, monitoring, security, and so on. We will
    need to build services and requisite portals from an operations point of view
    to monitor, detect, and take appropriate actions in case of deviations/defined
    rules. The services are usually built using the organization standards in mind.
    The services mature as more and more uses cases are identified. The idea is to
    automate all possible operations to make sure the platform is ticking all the
    time, without any human intervention.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产问题**：最后，我们需要开始担心生产问题，如服务管理、监控、安全等。我们需要从运营角度构建服务和必要的门户，以监视、检测并在偏离/定义规则的情况下采取适当的行动。这些服务通常是根据组织标准构建的。随着更多用例的识别，服务会不断成熟。其目的是自动化所有可能的操作，以确保平台始终运行，无需任何人为干预。'
- en: Developer build
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发人员构建
- en: Another key aspect of the digital transformation is to focus on your existing
    team managing/maintaining the existing application. The team needs to be upgraded
    in terms of skills and technologies, to be able to refactor/build/deploy the existing
    application into a distributed application. We will cover the steps needed to
    reskill the teams to handle the distributed application story.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 数字转型的另一个关键方面是专注于您现有团队管理/维护现有应用程序。团队需要在技能和技术方面进行升级，以便能够重构/构建/部署现有应用程序为分布式应用程序。我们将介绍重新培训团队处理分布式应用程序故事所需的步骤。
- en: '![](img/bbf06227-fa6f-48b5-ac1d-7941939a775d.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbf06227-fa6f-48b5-ac1d-7941939a775d.jpg)'
- en: '**Developer reskill/training**: First and foremost is teaching developers new
    skills for the new application architecture techniques and design patterns. This
    means classroom training, online technology training, vendor product sessions/training,
    and so on. Another way to raise the skill of a team is to hire people with relevant
    skills and have them spearhead the overall development with support from existing
    developer teams.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发人员再培训/培训**：首要任务是教导开发人员新的应用架构技术和设计模式。这意味着课堂培训、在线技术培训、供应商产品会议/培训等等。提升团队技能的另一种方法是雇佣具有相关技能的人，并让他们在现有开发团队的支持下带头进行整体开发。'
- en: At times, you might want to have two teams—one that changes the business and
    a second that runs the business. In this case, the first business team brings
    the new skills to the team. The other business team manages and operates the existing
    application during the transformation period.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望有两个团队——一个改变业务，另一个运行业务。在这种情况下，第一个业务团队为团队带来新的技能。另一个业务团队在转型期间管理和操作现有应用程序。
- en: '**Dev machine upgrade and setup**: The new technology stack requires upgrades
    of the developer machines. If the machines are running on 4 GB RAM, we might want
    to upgrade them to minimum of 8 GB RAM, better still 16 GB RAM. The newer stack
    requires virtual machines, Docker engine, IDEs, and other software for development
    and unit testing. Slower machines increase the time to build/test the code. Without
    adequate horse power, the developer is simply not productive enough.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发机器升级和设置**：新的技术栈需要升级开发人员的机器。如果机器运行在4GB RAM上，我们可能需要将它们升级到至少8GB RAM，最好是16GB
    RAM。新的技术栈需要虚拟机、Docker引擎、集成开发环境和其他开发和单元测试软件。较慢的机器会增加构建/测试代码的时间。没有足够的性能，开发人员就无法高效工作。'
- en: '**Hands on lab / proof of concept**: Once the machines are upgraded and developer
    training is done, the developer can start doing hands on lab and/or proof of concepts
    with the new technology stack to familiarize themselves with new development techniques.
    The developer can be given small projects or be involved as part of stack evaluation
    to enable them to become familiar with the technology stack.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实验室/概念验证**：一旦机器升级和开发人员培训完成，开发人员可以开始使用新技术栈进行实验室操作和/或概念验证，以熟悉新的开发技术。开发人员可以被分配小项目，或者参与技术栈评估的一部分，以使他们熟悉技术栈。'
- en: The work done by the developer team should be evaluated by an SME in the area
    to point out what they are doing wrong and the correct way of doing it. Having
    an external consultant (either SME or vendor consultant team) helps bridge this
    gap.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '**Code branching and configuration**: Once the developer team is ready to start
    working on the distributed application, the next step is to branch off the code
    from the monolithic application. You may want to branch off the configuration
    data also.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, even with branching, the existing application maintenance continues
    on the main code trunk. The branch version is used to refactor the code. We will
    see more details in the next section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '**Develop/build microservices**: Once the code is branched and refactored,
    the developer should start packaging them as microservices. The team can also
    start creating new microservices that map to new requirements of the application.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code on the branch is regularly synced with the trunk to ensure changes
    made to the trunk are available in the branch code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Movement to specific PaaS services provided by the cloud vendor is also part
    of this phase. If you want to make use of services such as queuing or notification,
    or any of the other services, then this is the phase where you make the relevant
    changes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '**CI/CD process of microservices**: Developers will start creating pipelines
    for continuous integration and deployment of the microservices. Service dependencies
    are mapped out and considered. Various code analysis checks are run as part of
    the CI process to ensure production readiness of the code. Additional service
    governance processes can be built into the various stages of the pipeline.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional/integration test**: Last but not least, developers will write
    functional and integration test suites to verify the correctness of the services.
    These test suites are integrated as part of the CI pipeline. As and when the new
    code is deployed, these tests are run as part of the regression to ensure the
    functional correctness.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking the monolithic application
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the key steps of digital transformation is the actual refactoring of
    the monolithic application. In this case, we are assuming a Java-based application
    that needs to be refactored/broken down into a distributed application:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b7e7f94-e74a-438c-9f26-96673d1305c4.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: '**Initial state**: Before we begin, we take the initial state of the monolithic
    application. In this state, the application is composed of a deployment unit (such
    as a WAR file), which is internally composed of multiple JAR files. The code is
    laid out in a logical manner, with some semblance of logical structuring across
    presentation, business, and data tiers. Each of the layers is further bifurcated
    by the modules or sub-packages modeled based on modules. If not, there is some
    distinction based on the class names to identify the modules. The configuration
    is stored as a set of external properties files. Code coverage is decent (more
    than 60%) and there is potential to write more test cases.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code refactoring**: The next step is to carve pieces of the code from the
    monolithic application that potentially go together. For example, classes across
    the module can be packaged as a separate Java project. Common files or utility
    classes can be packaged as separate JAR(s). As you refactor the code from a single
    code project, you will create multiple, interdependent Java projects. Package
    the JARs as part of the larger WAR or EAR file only. Remember, we are working
    on the master trunk of the code base. Changes are integrated and synchronized
    back on the branch code.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides the code, you will also need to refactor the application configuration.
    As you refactor the code, the configuration needs to be mapped to the respective
    Java projects. The configuration might be specific to the project/module, be shared
    across modules, or global, which is used across the application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '**Build process update**: As you work on the code refactoring part, creating
    smaller independent Java projects, you will need to update your project build
    process. The Java projects need to be built in the order that they are dependent
    on each other. As you carve out the projects, the build process keeps going through
    iterations. The build process is updated in conjunction with the code refactoring
    steps.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建过程更新：在进行代码重构的过程中，创建较小的独立Java项目，您需要更新项目构建过程。Java项目需要按照它们相互依赖的顺序进行构建。随着项目的划分，构建过程不断进行迭代。构建过程与代码重构步骤一起更新。
- en: As the code gets refactored, the updated WAR/EAR needs to be deployed to production.
    This ensures that the code refactoring works, and other metrics—code coverage,
    unit test, regression test, and so on are factored in. This makes sure that the
    work you are doing gets incorporated on a daily basis to production.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 随着代码的重构，更新的WAR/EAR需要部署到生产环境。这确保了代码重构的有效性，并考虑了其他指标——代码覆盖率、单元测试、回归测试等。这确保了您的工作每天都会被纳入生产。
- en: '**Java version update**: Multiple times, we have seen that the JVM version
    being used on the project might not be current. Some of the newer reactive frameworks
    usually work with Java 1.7 upwards. This means the base JVM version needs to be
    upgraded. This might require application code to be refactored for features that
    got deprecated. Some pieces of the code might need to be upgraded for newer features.
    The refactored code needs to go into production along with the upgraded JVM version.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java版本更新：我们多次看到项目中使用的JVM版本可能不是最新的。一些较新的响应式框架通常需要Java 1.7及更高版本。这意味着基本的JVM版本需要升级。这可能需要对应用程序代码进行重构，以适应已弃用的功能。某些代码片段可能需要升级以适应新功能。重构后的代码需要与升级后的JVM版本一起投入生产。
- en: '**Introducing circuit breaker / reactive patterns**: The next step in the code
    refactoring is to upgrade the code for resiliency patterns. You can bring in patterns
    such as a circuit breaker by implementing a Java library such as Hystrix. You
    can also improve the code across the modules by implementing patterns such as
    decoupling the modules by implementing async messaging, bringing in reactive frameworks
    (such as Spring Boot, Vert.x, Dropwizard, and so on), and improving concurrency
    (such as Akka, RxJava, and so on). All the changes are to the production code
    and integrated with branch code.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入断路器/响应式模式：代码重构的下一步是升级代码以实现弹性模式。您可以通过实现Java库（如Hystrix）引入断路器等模式。您还可以通过实现异步消息传递、引入响应式框架（如Spring
    Boot、Vert.x、Dropwizard等）以及改进并发性（如Akka、RxJava等）来改进模块间的代码，并将所有更改应用到生产代码并与分支代码集成。
- en: '**Feature flag implementation**: At times, you might be integrating code coming
    from the branch. In this case, you may not want some piece of code going live.
    You can introduce feature flags in the code, controlled through configuration.
    So you can take code into production which might be dead till the feature is ready
    to go live.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性标志实施：有时，您可能正在集成来自分支的代码。在这种情况下，您可能不希望某些代码立即上线。您可以在代码中引入特性标志，并通过配置进行控制。因此，您可以将可能在特性准备上线之前处于停用状态的代码投入生产。
- en: '**Ongoing functional updates**: The application will be undergoing regular
    functional changes/updates. The changes are made to the code and synchronized
    back to the branched code on regular basis.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续的功能更新：应用程序将不断进行功能性的更改/更新。更改将应用到代码中，并定期与分支代码同步。
- en: Bringing it all together
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: 'We saw how the four tracks are working at the application in their individual
    capacities. Now we bring all four tracks together in a collaborative manner. As
    the monolithic application undergoes transformation, the other tracks set up the
    base platform for carving out the bounded context and related microservices:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到四个轨道在各自的能力上在应用程序中运作。现在我们以协作的方式将所有四个轨道结合起来。随着单片应用程序的转变，其他轨道为划分界限上下文和相关微服务奠定了基础平台：
- en: '![](img/906a6786-8fe8-4162-b8b2-891586ae1516.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/906a6786-8fe8-4162-b8b2-891586ae1516.jpg)'
- en: We can see how the two tracks change the business, run the business overlap,
    and provide the perfect balance to migrate from a monolithic model to a distributed
    application model.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到两个轨道如何改变业务，运行业务重叠，并为从单片模型迁移到分布式应用程序模型提供完美的平衡。
- en: This is akin to changing the tires of a moving car.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于在行驶中更换汽车轮胎。
- en: Building your own platform services (control versus delegation)
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建自己的平台服务（控制与委托）
- en: 'Another key decision for enterprises is how to choose your platform:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 企业面临的另一个关键决定是如何选择平台：
- en: Should I be building my own platform?
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该构建自己的平台吗？
- en: Should I subscribe to an existing platform and develop my application on top
    of it?
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该订阅现有平台并在其上开发我的应用程序吗？
- en: This decision boils down to the factor how do you see technology, as an enabler
    (control) or a differentiator (delegation)?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个决定归结为如何看待技术，是作为一种促进因素（控制）还是作为一种差异化因素（委托）？
- en: 'At the core, all companies are technology companies. But the question is whether
    controlling technology provides you with the additional edge over your competition,
    or helps build a moat that can potentially discourage new players from coming.
    Let''s take a couple of examples and see how it plays out:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上讲，所有公司都是科技公司。但问题是，控制技术是否能为您提供与竞争对手的额外优势，或者帮助构建一个可能阻止新参与者加入的壕沟。让我们举几个例子，看看它是如何发挥作用的：
- en: If you are to planning to compete with a company such as Amazon in the retail
    space, you need to have deep pockets. The low margin business of Amazon retails
    is bankrolled by profitable business from AWS. So, unless you have a sugar daddy
    or alternate revenue models, competing with Amazon is not going to be easy. But
    assuming you have deep pockets, can you start modeling your retail platform on
    top of AWS or any of the cloud providers? Yes! You can start with any of the public
    cloud platforms and once you have predictable demand, you can move into a private
    cloud model. This model saves you the upfront capex.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您计划在零售领域与亚马逊等公司竞争，您需要有雄厚的资金实力。亚马逊零售的低利润业务是由AWS的盈利业务支持的。因此，除非您有一个资金雄厚的支持者或替代收入模式，与亚马逊竞争将不会容易。但是假设您有雄厚的资金实力，您可以开始在AWS或任何云提供商上建模您的零售平台吗？是的！您可以从任何公共云平台开始，一旦您有可预测的需求，您可以转向私有云模型。这种模型可以节省您的前期资本支出。
- en: Let's take an example of a manufacturing domain that sells physical products.
    They can potentially augment their product with **internet of things** (**IoT**)
    devices that provide a regular stream of data about the performance and usage
    of the product. The company collects this data and provides analytics services
    (such as predictive maintenance) as digital services around these products. Now,
    you can model and build the analytics model on any of the cloud providers. The
    choice of the platform can be determined by the choice of cognitive or data churning
    capabilities. You can choose the cognitive services from the platform or even
    create your own. The underlying platform capabilities are delegated to the cloud
    provider. You focus on building the right model to predict.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们以销售实体产品的制造领域为例。他们可以潜在地利用物联网设备来增强他们的产品，这些设备提供关于产品性能和使用情况的定期数据流。公司收集这些数据，并提供围绕这些产品的数字服务（如预测性维护）的分析服务。现在，您可以在任何云提供商上建模和构建分析模型。平台的选择可以由认知或数据处理能力的选择来确定。您可以从平台选择认知服务，甚至创建您自己的认知服务。基础平台能力委托给云提供商。您专注于构建正确的模型来进行预测。
- en: There is no right or wrong model. You may start with a delegate (going with
    a public cloud provider) initially, and then go to a control model (private cloud)
    where you have full control over the features/functionality of your application.
    It is easy to pivot on the cloud provider model without a lot of upfront investment
    and lock in. The idea is to identify where the differentiator lies for you!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 没有正确或错误的模型。您可以从代表（选择公共云提供商）开始，然后转向控制模型（私有云），在那里您可以完全控制应用程序的功能/功能。在没有大量前期投资和锁定的情况下，很容易在云提供商模型上进行转变。关键是要确定您的差异化所在！
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This brings us to the end of digital transformation. We saw how we need to evaluate
    our application portfolio for transformation opportunities. We saw the reasons
    why monolithic applications are becoming a hindrance to achieving our business
    goals.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了数字转型。我们看到了我们需要评估应用程序组合以寻找转型机会。我们看到了单片应用程序对实现业务目标的阻碍原因。
- en: Once a transformation opportunity is identified, we can take an existing monolithic
    application and move to a distributed application model. We saw various steps
    that need to be taken across people, process, and technology levels.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了转型机会，我们可以将现有的单片应用程序转移到分布式应用程序模型。我们看到需要在人员、流程和技术层面采取各种步骤。
- en: This also brings an end to the overall journey for building cloud-native applications
    in Java. We saw the various tools/technologies to build new age microservice-based
    applications, how to build them, how to take these applications to production,
    how to monitor them, and how we adopt these applications for cloud providers such
    as AWS and Azure. We also saw some of the best practices in building API-based
    platforms, and how to take an existing monolithic application and transform it
    into a distributed microservice-based application.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这也结束了在Java中构建云原生应用程序的整体旅程。我们看到了构建基于微服务的新时代应用程序的各种工具/技术，如何构建它们，如何将这些应用程序投入生产，如何监视它们，以及我们如何将这些应用程序用于AWS和Azure等云提供商。我们还看到了构建基于API的平台的一些最佳实践，以及如何将现有的单片应用程序转变为分布式微服务应用程序。

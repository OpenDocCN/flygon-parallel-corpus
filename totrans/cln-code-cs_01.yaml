- en: Coding Standards and Principles in C#
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的编码标准和原则
- en: The primary goal of coding standards and principles in C# is for programmers
    to become better at their craft by programming code that is more performant and
    easier to maintain. In this chapter, we will look at some examples of good code
    contrasted with examples of bad code. This will lead nicely into discussing why
    we need coding standards, principles, and methodologies. We will then move on
    to consider conventions for naming, commenting, and formatting source code, including
    classes, methods, and variables.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C#中编码标准和原则的主要目标是让程序员通过编写性能更好、更易于维护的代码来提高他们的技能。在本章中，我们将看一些好代码的例子，并对比一些坏代码的例子。这将很好地引出我们为什么需要编码标准、原则和方法的讨论。然后，我们将继续考虑命名、注释和格式化源代码的约定，包括类、方法和变量。
- en: A big program can be rather unwieldy to understand and maintain. For junior
    programmers, getting to know the code and what it does can be a daunting prospect.
    Teams can find it hard to work together on such projects. And from a testing viewpoint,
    it can make things rather difficult. Because of this, we will look at how you
    use modularity to break programs down into smaller modules that all work together
    to produce a fully functioning solution that is also fully testable, can be worked
    on by multiple teams simultaneously, and is much easier to read, understand, and
    document.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一个大型程序可能相当难以理解和维护。对于初级程序员来说，了解代码及其功能可能是一个令人望而却步的任务。团队可能会发现很难在这样的项目上共同工作。从测试的角度来看，这可能会使事情变得相当困难。因此，我们将看一下如何使用模块化将程序分解为更小的模块，这些模块共同工作以产生一个完全可测试的解决方案，可以同时由多个团队进行开发，并且更容易阅读、理解和文档化。
- en: We will finish the chapter off by looking at some programming design guidelines,
    mainly, KISS, YAGNI, DRY, SOLID, and Occam's Razor.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过查看一些编程设计准则来结束本章，主要是KISS、YAGNI、DRY、SOLID和奥卡姆剃刀。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The need for coding standards, principles, and methodologies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码标准、原则和方法的必要性
- en: Naming conventions and methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名约定和方法
- en: Comments and formatting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释和格式化
- en: Modularity
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化
- en: KISS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KISS
- en: YAGNI
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAGNI
- en: DRY
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DRY
- en: SOLID
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOLID
- en: Occam's Razor
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奥卡姆剃刀
- en: 'The learning objectives for this chapter are for you to do the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的学习目标是让您做到以下几点：
- en: Understand why bad code negatively impacts projects.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解为什么坏代码会对项目产生负面影响。
- en: Understand how good code positively impacts projects.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解好代码如何积极影响项目。
- en: Understand how coding standards improve code and how to enforce them.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解编码标准如何改进代码以及如何强制执行它们。
- en: Understand how coding principles enhance software quality.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解编码原则如何提高软件质量。
- en: Understand how methodologies aid the development of clean code.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解方法论如何促进清洁代码的开发。
- en: Implement coding standards.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施编码标准。
- en: Choose solutions with the least assumptions.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择假设最少的解决方案。
- en: Reduce code duplication and write SOLID code.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少代码重复，编写SOLID代码。
- en: Technical requirements
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To work on the code in this chapter, you will need to download and install Visual
    Studio 2019 Community Edition or higher. This IDE can be downloaded from [https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本章中处理代码，您需要下载并安装Visual Studio 2019社区版或更高版本。可以从[https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/)下载这个集成开发环境。
- en: You will find the code for this book located at [https://github.com/PacktPublishing/Clean-Code-in-C-](https://github.com/PacktPublishing/Clean-Code-in-C-)[.](https://github.com/PacktPublishing/Clean-Code-in-C-)
    I have put them all under a single solution with each chapter as a solution folder.
    You will find the code for each chapter in the relevant chapter folder. If running
    a project, remember to assign it as the startup project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Clean-Code-in-C-](https://github.com/PacktPublishing/Clean-Code-in-C-)[.]找到本书的代码。我已将它们全部放在一个单一的解决方案中，每个章节都是一个解决方案文件夹。您将在相关的章节文件夹中找到每个章节的代码。如果要运行项目，请记得将其分配为启动项目。
- en: Good code versus bad code
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 好代码与坏代码
- en: 'Both good code and bad code compile. That''s the first thing to understand.
    The next thing to understand is that bad code is bad for a reason, and likewise,
    good code is good for a reason. Let''s have a look at some of those reasons in
    the following comparison table:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 好代码和坏代码都可以编译。这是要理解的第一件事。要理解的下一件事是，坏代码之所以糟糕是有原因的，同样，好代码之所以好也是有原因的。让我们在下面的比较表中看一些原因：
- en: '| **Good Code** | **Bad Code** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|**好代码**|**坏代码**|'
- en: '| Proper indentation. | Improper indentation. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|适当的缩进。|不正确的缩进。|'
- en: '| Meaningful comments. | Comments that state the obvious. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|有意义的注释。|陈述显而易见的注释。|'
- en: '| API documentation comments. | Comments that excuse bad code. Commented out
    lines of code. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|API文档注释。|为糟糕的代码辩解的注释。被注释掉的代码行。|'
- en: '| Proper organization using namespaces. | An improper organization using namespaces.
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|使用命名空间进行适当的组织。|使用命名空间进行不适当的组织。|'
- en: '| Good naming conventions. | Bad naming conventions. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|良好的命名约定。|糟糕的命名约定。|'
- en: '| Classes that do one job. | Classes that do multiple jobs. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '|只做一件工作的类。|做多个工作的类。|'
- en: '| Methods that do one thing. | Methods that do many things. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|只做一件事的方法。|做很多事情的方法。|'
- en: '| Methods with less than 10 lines, and preferably no more than 4. | Methods
    with more than 10 lines of code. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|不超过10行的方法，最好不超过4行。|超过10行的方法。|'
- en: '| Methods with no more than two parameters. | Methods with more than two parameters.
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|方法不超过两个参数。|方法超过两个参数。|'
- en: '| Proper use of exceptions. | Using exceptions to control program flow. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|适当使用异常。|使用异常来控制程序流程。|'
- en: '| Code that is readable. | Code that is difficult to read. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|可读性代码。|难以阅读的代码。|'
- en: '| Code that is loosely coupled. | Code that is tightly coupled. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|松散耦合的代码。|紧密耦合的代码。|'
- en: '| High cohesion. | Low cohesion. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|高内聚性。|低内聚性。|'
- en: '| Objects are cleanly disposed of. | Objects left hanging around. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|对象被清理干净。|对象被搁置不管。|'
- en: '| Avoidance of the `Finalize()` method. | Use of the `Finalize()` method. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 避免使用`Finalize()`方法。 | 使用`Finalize()`方法。 |'
- en: '| The right level of abstraction. | Over-engineering. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 正确的抽象级别。 | 过度工程。 |'
- en: '| Use of regions in large classes. | Lack of regions in large classes. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 在大类中使用区域。 | 在大类中缺乏区域。 |'
- en: '| Encapsulation and information hiding. | Directly exposing information. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 封装和信息隐藏。 | 直接暴露信息。 |'
- en: '| Object-oriented code. | Spaghetti code. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 面向对象的代码。 | 意大利面代码。 |'
- en: '| Design patterns. | Design anti-patterns. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 设计模式。 | 设计反模式。 |'
- en: That's quite an exhaustive list, isn't it? In the following sections, we will
    look at how these features and the differences between good and bad code impact
    the performance of your code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当详尽的列表，不是吗？在接下来的部分中，我们将看看这些特性以及好代码和坏代码之间的差异如何影响你的代码的性能。
- en: Bad code
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 糟糕的代码
- en: We will now take a brief look at each of the bad coding practices that we listed
    earlier, detailing specifically how that practice affects your code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将简要介绍我们之前列出的每个不良编码实践，具体说明这些实践如何影响你的代码。
- en: Improper indentation
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不正确的缩进
- en: Improper indentation can work toward making code really hard to read, especially
    if the methods are large. For code to be easy to read by humans, we need proper
    indentation. If code lacks proper indentation it can be very hard to see which
    part of the code belongs to which block.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不正确的缩进可能导致代码变得非常难读，特别是如果方法很大的话。为了让代码易于人类阅读，我们需要正确的缩进。如果代码缺乏正确的缩进，很难看出代码的哪一部分属于哪个块。
- en: By default, Visual Studio 2019 correctly formats and indents your code when
    parentheses and braces are closed. But sometimes, it incorrectly formats the code,
    to bring to your attention that the code you've written contains an exception.
    But if you are using a simple text editor, then you will have to do your formatting
    by hand.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Visual Studio 2019在括号和大括号关闭时会正确格式化和缩进你的代码。但有时，它会错误地格式化代码，以提醒你你写的代码中包含异常。但如果你使用简单的文本编辑器，那么你就必须手动进行格式化。
- en: 'Incorrectly indented code is also time-consuming to correct, and a frustrating
    waste of programming time when it could easily have been avoided. Let''s look
    at a simple code example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 错误缩进的代码也很耗时，当它本可以很容易避免时，这也是对编程时间的一种沮丧的浪费。让我们看一个简单的代码例子：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code does not look all that nice, yet it is still readable. But
    the more lines of code you add, the harder the code becomes to read.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码看起来并不那么好，但它仍然是可读的。但是你添加的代码行数越多，代码就变得越难读。
- en: It is very easy to miss a closing bracket. If your code is not properly indented,
    then this can make finding the missing bracket that much harder, as you can not
    easily spot which code block is missing its closing bracket.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易错过一个闭合括号。如果你的代码没有正确缩进，那么找到缺失的括号就会变得更加困难，因为你很难看出哪个代码块缺少了闭合括号。
- en: Comments that state the obvious
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显而易见的注释
- en: I've seen programmers get really upset at comments that state the obvious as
    they find them patronizing. In programming discussions that I have been part of,
    programmers have stated how they dislike comments, and how they believe the code
    should be self-documenting.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我见过程序员对显而易见的注释感到非常不满，因为他们觉得这些注释是居高临下的。在我参与的编程讨论中，程序员们表示他们不喜欢注释，认为代码应该是自解释的。
- en: 'I can understand their sentiments. If you can read code without comments like
    you can read a book and understand it, then it is a really good piece of code.
    If you have a variable declared as a string, then why add a comment such as `//
    string`? Let''s look at an example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我能理解他们的情绪。如果你能像读书一样读懂没有注释的代码，那么这就是一段非常好的代码。如果你已经声明了一个变量是字符串，那为什么还要添加`// string`这样的注释呢？让我们看一个例子：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We know here that the value holds an integer by its type of `int`. So there
    really is no need to state the obvious. All you're doing is wasting time and energy
    and cluttering up the code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道值通过其`int`类型来保存整数。所以真的没有必要说明显而易见的事情。你所做的只是浪费时间和精力，以及使代码变得混乱。
- en: Comments that excuse bad code
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 借口糟糕的注释
- en: You may have a tight deadline to meet, but comments such as `// I know this
    code sucks but hey at least it works!` are just awful. Don't do it. It shows a
    lack of professionalism and can really disgruntle fellow programmers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能有一个紧迫的截止日期要满足，但是像`// 我知道这段代码很糟糕，但至少它能工作！`这样的注释真的很糟糕。不要这样做。这显示了缺乏专业精神，可能会让其他程序员感到不满。
- en: 'If you really are pushed to get something working out the door, raise a refactor
    ticket and add it as part of a TODO comment such as `// TODO: PBI23154 Refactor
    Code to meet company coding practices`. Then you or the other developers who are
    assigned to work on technical debt can pick up the **Product Backlog Item** (**PBI**)
    and refactor the code.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你真的被迫让某些东西快速运行，那就提出一个重构的工单，并将其作为`// TODO: PBI23154 重构代码以符合公司编码规范`这样的TODO注释的一部分。然后你或者其他被分配处理技术债务的开发人员可以接手**产品待办事项**（**PBI**）并重构代码。'
- en: 'Here''s another example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一个例子：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This one is really bad. Okay, thank you for letting us know that divide-by-zero
    errors occur here. But have you raised a bug ticket? Have you tried to get to
    the bottom of it and fix it? If everybody who is actively working on the project
    does not touch that code, how will they know that buggy code is there?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的很糟糕。好吧，谢谢你告诉我们这里会发生除零错误。但你提出了一个bug工单吗？你尝试找出问题并修复它了吗？如果所有正在项目中积极工作的人都不碰那段代码，他们怎么会知道有错误的代码存在呢？
- en: At the very minimum, you should at least have a `// TODO:` comment in place.
    Then at least the comment will show up in the Task List so that developers can
    be notified and work on it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 至少你应该在代码中加上一个`// TODO:`注释。这样至少这个注释会出现在任务列表中，开发人员可以收到通知并进行处理。
- en: Commented-out lines of code
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释掉的代码行
- en: 'If you comment out lines of code to try something, fine. But if you are going
    to use the replacement code instead of the commented-out code, then delete the
    commented-out code before you check it in. One or two commented outlines is not
    that bad. But when you have many lines of commented-out code, it becomes distracting
    and makes code hard to maintain; it can even lead to confusion:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注释掉一些代码来尝试一些东西，那没问题。但是如果你要使用替换代码而不是注释掉的代码，那么在提交之前删除注释掉的代码。一两行注释掉的代码并不那么糟糕。但是当你有很多行注释掉的代码时，它会分散注意力，使代码难以维护；甚至会导致混乱：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Why? Just why? If it has been replaced and is no longer needed, then just delete
    it. If your code is in version control, and you need to get the method back, then
    you can always view the history of the file and get the method back.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？为什么？如果它已经被替换并且不再需要，那就删除它。如果你的代码在版本控制中，并且你需要恢复这个方法，那么你可以随时查看文件的历史记录并恢复这个方法。
- en: Improper organization of namespaces
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间的不当组织
- en: 'When using namespaces, do not include code that should be elsewhere. This can
    make finding the right code pretty hard or impossible, especially in large code
    bases. Let''s look at this example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用命名空间时，不要包含应该放在其他地方的代码。这样会使找到正确的代码变得非常困难甚至不可能，特别是在大型代码库中。让我们看看这个例子：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can see that all classes in the preceding code are under one namespace.
    Yet, we have the opportunity to add three further namespaces to better organize
    this code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到前面的代码中所有的类都在一个命名空间下。然而，我们有机会添加三个更好地组织这些代码的命名空间：
- en: '`MyProject.TextFileMonitor.Core`: Core classes that define commonly used members
    will be placed here, such as our `DateTime` class.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyProject.TextFileMonitor.Core`：定义常用成员的核心类将放置在这里，比如我们的`DateTime`类。'
- en: '`MyProject.TextFileMonitor.Services`: All classes that act as a service will
    be placed in this namespace, such as `FileMonitorService`.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyProject.TextFileMonitor.Services`：所有充当服务的类都将放置在这个命名空间中，比如`FileMonitorService`。'
- en: '`MyProject.TextFileMonitor.Security`: All security-related classes will be
    placed in this namespace, including the `Cryptography` class in our example.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MyProject.TextFileMonitor.Security`：所有与安全相关的类都将放置在这个命名空间中，包括我们示例中的`Cryptography`类。'
- en: Bad naming conventions
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 糟糕的命名约定
- en: In the days of Visual Basic 6 programming, we used to use Hungarian Notation.
    I remember using it when I first switched to Visual Basic 1.0\. It is no longer
    necessary to use Hungarian Notation. Plus, it makes your code look ugly. So instead
    of using names such as `lblName`, `txtName`, or `btnSave`, the modern way is to
    use `NameLabel`, `NameTextBox`, and `SaveButton`, respectively
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Basic 6编程时代，我们曾经使用匈牙利命名法。我记得我第一次转到Visual Basic 1.0时使用它。现在不再需要使用匈牙利命名法。而且，它会让你的代码看起来很丑。所以，现代的做法是使用`NameLabel`、`NameTextBox`和`SaveButton`，而不是使用`lblName`、`txtName`或`btnSave`这样的名称。
- en: The use of cryptic names and names that don't seem to match the intention of
    the code can make reading code rather difficult. What does **ihridx** mean? It
    means **Human Resources Index** and is an *integer*. Really! Avoid using names
    such as `mystring`, `myint`, and `mymethod`. Such names really don't serve a purpose.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用晦涩的名称和与代码意图不符的名称会使阅读代码变得相当困难。**ihridx**是什么意思？它的意思是**Human Resources Index**，是一个*整数*。真的！避免使用`mystring`、`myint`和`mymethod`这样的名称。这样的名称真的没有任何意义。
- en: Don't use underscores between words in a name either, such as `Bad_Programmer`.
    This can cause visual stress for developers and can make the code hard to read.
    Simply remove the underscore.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在名称中也不要使用下划线，比如`Bad_Programmer`。这会给开发人员造成视觉压力，并且使代码难以阅读。只需删除下划线。
- en: Don't use the same code convention for variables at the class level and method
    level. This can make it difficult to establish the scope of a variable. A good
    convention for variable names is to use camel case for variable names such as
    `alienSpawn`, and Pascal case for method, class, struct, and interface names such
    as `EnemySpawnGenerator`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在类级别和方法级别使用相同的代码约定。这会使变量的范围难以确定。变量名称的一个好的约定是对变量名称使用驼峰命名法，比如`alienSpawn`，对方法、类、结构和接口名称使用帕斯卡命名法，比如`EnemySpawnGenerator`。
- en: Following the good variable name convention, you should distinguish between
    local variables (those contained within a constructor or method), and member variables
    (those placed at the top of the class outside of constructors and methods) by
    prefixing the member variables with an underscore. I have used this as a coding
    convention in the workplace, and it does work really well and programmers do seem
    to like this convention.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循良好的变量命名约定，你应该通过在成员变量前加下划线来区分局部变量（在构造函数或方法中包含的变量）和成员变量（在构造函数和方法之外的类顶部放置的变量）。我在工作中使用过这种编码约定，它确实非常有效，程序员似乎也喜欢这种约定。
- en: Classes that do multiple jobs
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 做多项工作的类
- en: A good class should only do one job. Having a class that connects to a database,
    gets data, manipulates that data, loads a report, assigns the data to the report,
    displays the report, saves the report, prints the reports, and exports the report
    is doing too much. It needs to be refactored into smaller, better-organized classes.
    All-encompassing classes like this are a pain to read. I personally find them
    daunting. If you come across classes like this, organize the functionality into
    regions. Then move the code in those regions into new classes that perform one
    job.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的类应该只做一件事。一个类连接到数据库，获取数据，操作数据，加载报告，将数据分配给报告，显示报告，保存报告，打印报告和导出报告，这样做的工作太多了。它需要重构为更小、更有组织的类。这样的全面类很难阅读。我个人觉得它们令人望而生畏。如果你遇到这样的类，将功能组织成区域。然后将这些区域中的代码移动到执行一个工作的新类中。
- en: 'Let''s have a look at an example of a class that is doing multiple things:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个做多件事情的类的例子：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see in the preceding code, the class does two main things: it performs
    database operations and it performs file operations. Now the code is neatly organized
    within correctly named regions used to logically separate code within a class.
    But the **Single Responsibility Principle** (**SRP**) is broken. We would need
    to begin by refactoring this code to separate out the database operations into
    a class of their own, called something like `DatabaseManager`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的代码中所看到的，这个类做了两件主要的事情：它执行数据库操作和文件操作。现在代码被整齐地组织在正确命名的区域内，用于在类内逻辑上分离代码。但是**单一职责原则**（**SRP**）被打破了。我们需要从重构这段代码开始，将数据库操作分离出来，放到一个名为`DatabaseManager`的自己的类中。
- en: Then, we would remove the database operations from the `DbAndFileManager` class,
    leaving only the file operations, and then rename the `DbAndFileManager` class
    to `FileManager`. We would also need to consider the namespace of each file, and
    whether it should be modified so that the `DatabaseManager` would be placed in
    the `Data` namespace and the `FileManager` would be placed in the `FileSystem`
    namespace, or their equivalents in your program.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将数据库操作从`DbAndFileManager`类中移除，只留下文件操作，然后将`DbAndFileManager`类重命名为`FileManager`。我们还需要考虑每个文件的命名空间，以及是否应该修改它们，使得`DatabaseManager`放在`Data`命名空间中，`FileManager`放在`FileSystem`命名空间中，或者在你的程序中的等价位置。
- en: 'The following code is the result of extracting the database code from the `DbAndFileManager`
    class into its own class and in the correct namespace:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是将`DbAndFileManager`类中的数据库代码提取到自己的类中，并放在正确的命名空间中的结果：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The refactoring of the filesystem code results in the `FileManager` class in
    the `FileSystem` namespace, as shown in the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统代码的重构结果是`FileSystem`命名空间中的`FileManager`类，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've seen how to identify classes that do too much, and how we can refactor
    them to do only a single thing. Now let's repeat the process as we look at methods
    that do many things.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何识别做太多事情的类，以及如何将它们重构为只做一件事。现在让我们重复这个过程，看看做很多事情的方法。
- en: Methods that do many things
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 做很多事情的方法
- en: I have found myself getting lost in methods with many, many levels of indentation
    doing many things in those various indentations. The permutations were mind-boggling.
    I wanted to refactor the code to make maintenance easier, but my senior prohibited
    it. I could clearly see how the method could have been smaller by farming out
    the code to different methods.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现自己在许多层级的缩进中迷失，这些缩进中做了很多事情。排列组合令人费解。我想重构代码以使维护更容易，但我的前辈禁止了。我清楚地看到，通过将代码分配给不同的方法，该方法可以变得更小。
- en: 'Time for an example. In this example, the method accepts a string. That string
    is then encrypted and decrypted. It is also long so that you can see why methods
    should be kept small:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子。在这个例子中，该方法接受一个字符串。然后对该字符串进行加密和解密。它也很长，这样你就可以看到为什么方法应该保持简短：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see in the preceding method, it has 10 lines of code and is hard
    to read. Plus, it is doing more than one thing. This code can be broken down into
    two methods that each perform a single task. One method would encrypt a string,
    and the other method would decrypt the string. This leads us nicely into why methods
    should have no more than 10 lines of code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在前面的方法中所看到的，它有10行代码，很难阅读。此外，它做了不止一件事。这段代码可以分解为两个分别执行单个任务的方法。一个方法会对字符串进行加密，另一个方法会解密字符串。这很好地说明了为什么方法不应该超过10行代码。
- en: Methods with more than 10 lines of code
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超过10行代码的方法
- en: Large methods are not nice to read and understand. They can also lead to very
    hard-to-find bugs. Another problem with large methods is they can lose sight of
    their original intent. It's even worse when you come across large methods that
    have sections separated by comments and code wrapped in regions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 大方法不易阅读和理解。它们也可能导致非常难以找到的错误。大方法的另一个问题是它们可能会失去原始意图。当你遇到由注释分隔和代码包裹在区域中的大方法时，情况会变得更糟。
- en: If you have to scroll to read a method, then it is too long and can lead to
    programmer stress and misinterpretation. This in turn can lead to modifications
    that will break the code or the intent, or both. Methods should be as small as
    you can make them. But common sense does need to be exercised, as you can take
    the matter of small methods to the *n^(th)* degree to the point that it becomes
    excessive. The key to getting the right balance is to ensure the intent of the
    method is very clear and succinctly implemented.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须滚动阅读一个方法，那么它就太长了，可能会导致程序员的压力和误解。这反过来可能会导致修改破坏代码或意图，或者两者都会。方法应该尽可能小。但是需要行使常识，因为你可以将小方法的问题推到*第n*度，直到它变得过分。获得正确平衡的关键是确保方法的意图非常清晰和简洁地实现。
- en: The previous code is a good candidate for why you should keep methods small.
    Small methods are easy to read and understand. Normally, if your code drifts beyond
    10 lines it may be doing more than it is intended to. Make sure your methods name
    their intentions, as in `OpenDatabaseConnection()` and `CloseDatabaseConnection()`,
    and that they stick to their intentions and do not deviate away from them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是为什么你应该保持方法简短的一个很好的例子。小方法易于阅读和理解。通常，如果你的代码超过10行，它可能会做得比预期的更多。确保你的方法命名它们的意图，比如`OpenDatabaseConnection()`和`CloseDatabaseConnection()`，并且它们要坚持它们的意图，不要偏离它们。
- en: We are now going to take a look at method parameters.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要看一下方法参数。
- en: Methods with more than two parameters
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有两个以上参数的方法
- en: Methods with many parameters tend to get a bit unwieldy. Apart from being hard
    to read, it is very easy to pass a value to the wrong parameter and break type
    safety.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 具有许多参数的方法往往变得有些难以控制。除了难以阅读之外，很容易将一个值传递给错误的参数并破坏类型安全。
- en: Testing methods get increasingly more complex as the number of parameters increases,
    the main reason being that you have more permutations to apply to your test cases.
    It is possible that you will miss a use case that will cause issues in production.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 随着参数数量的增加，测试方法变得越来越复杂，主要原因是你有更多的排列组合要应用到你的测试用例上。可能会错过一个在生产中会导致问题的用例。
- en: Using exceptions to control program flow
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用异常来控制程序流程
- en: Exceptions used to control program flow may hide the intention of the code.
    They can also lead to unexpected and unintended results. The very fact that your
    code has been programmed to expect one or more exceptions shows your design to
    be wrong. A typical scenario that is covered in more detail in [Chapter 5](6a303d89-97fb-4bc0-bfb2-38b04233610c.xhtml),
    *Exception Handling*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 用异常来控制程序流程可能会隐藏代码的意图。它们也可能导致意外和意想不到的结果。你的代码已经被编程成期望一个或多个异常，这表明你的设计是错误的。在[第5章](6a303d89-97fb-4bc0-bfb2-38b04233610c.xhtml)中更详细地介绍了一个典型情况，*异常处理*。
- en: A typical scenario is when a business uses **Business Rule Exceptions** (**BREs**).
    A method will perform an action anticipating that an exception will be thrown.
    The program flow will be determined by whether the exception is thrown or not.
    A much better way is to use available language constructs to perform validation
    checks that return a Boolean value.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 典型情况是当企业使用**业务规则异常**（**BREs**）时。一个方法将执行一个动作，预期会抛出一个异常。程序流程将根据异常是否被抛出来确定。一个更好的方法是使用可用的语言结构来执行返回布尔值的验证检查。
- en: 'The following code shows the use of a BRE to control program flow:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了使用BRE来控制程序流程：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The method accepts `BusinessRuleException`. Depending upon the message in the
    exception, `BreFlowControlExample()` either calls the `DoOutOfAcceptableRangeWork()`
    method or the `DoInAcceptableRangeWork()` method.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受`BusinessRuleException`。根据异常中的消息，`BreFlowControlExample()`要么调用`DoOutOfAcceptableRangeWork()`方法，要么调用`DoInAcceptableRangeWork()`方法。
- en: 'A much better way to control the flow is through Boolean logic. Let''s look
    at the following `BetterFlowControlExample()` method:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过布尔逻辑来控制流程是一个更好的方法。让我们看一下以下`BetterFlowControlExample()`方法：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the `BetterFlowControlExample()` method, a Boolean value is passed into the
    method. The Boolean value is used to determine which path to execute. If the condition
    is in the acceptable range, then `DoInAcceptableRangeWork()` is called. Otherwise,
    the `DoOutOfAcceptableRangeWork()` method is called.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BetterFlowControlExample()`方法中，一个布尔值被传递到方法中。这个布尔值用于确定要执行哪条路径。如果条件在可接受范围内，那么将调用`DoInAcceptableRangeWork()`。否则，将调用`DoOutOfAcceptableRangeWork()`方法。
- en: Next, we will consider code that is difficult to read.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将考虑难以阅读的代码。
- en: Code that is difficult to read
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 难以阅读的代码
- en: Code such as lasagna and spaghetti code is really hard to read or follow. Badly
    named methods can also be a pain as they can obfuscate the intention of the method.
    Methods are further obfuscated if they are large and if linked methods are separated
    by a number of unrelated methods.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 像千层饼和意大利面代码这样的代码真的很难阅读或跟踪。糟糕命名的方法也可能是一个痛点，因为它们可能会掩盖方法的意图。如果方法很大，并且链接的方法被一些不相关的方法分开，那么方法会进一步被混淆。
- en: Lasagna code, also known more commonly as indirection, refers to layers of abstraction
    where something is referred to by name rather than by action. Layering is used
    extensively in **Object-Oriented Programming** (**OOP**) and to good effect. However,
    the more indirection is used, the more complex code can become. This can make
    it very hard for new programmers on a project to get up to speed with understanding
    the code. So there must be a balance struck between indirection and ease of understanding.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 千层饼代码，也更常见地称为间接引用，指的是抽象层次，其中某物是按名称而不是按动作来引用的。分层在**面向对象编程**（**OOP**）中被广泛使用，并且效果很好。然而，使用的间接引用越多，代码就会变得越复杂。这可能会让项目中的新程序员很难理解代码。因此，必须在间接引用和易理解性之间取得平衡。
- en: Spaghetti code refers to a tangled mess of tightly coupled code with low cohesion.
    Such code is very hard to maintain, refactor, extend, and redesign. Though on
    the plus side, it can be very easy to read and follow since it is more procedural
    in its programming. I remember working as a junior programmer on a VB6 GIS program
    that was sold to companies and used for marketing purposes. My technical director
    and his senior programmers had previously tried to redesign the software and failed.
    So they passed the gauntlet to me so that I would redesign the program. But not
    being skilled in software analysis and design at the time, I also failed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利面代码指的是紧密耦合、内聚性低的一团乱麻。这样的代码很难维护、重构、扩展和重新设计。但好的一面是，它在编程上更加程序化，因此阅读和跟踪起来会更容易。我记得曾经在一个VB6
    GIS程序上作为初级程序员工作，这个程序被公司购买并用于营销目的。我的技术总监和他的高级程序员之前曾试图重新设计软件，但失败了。所以他们把这个任务交给了我，让我重新设计这个程序。但当时我并不擅长软件分析和设计，所以我也失败了。
- en: The code was just too complex to follow and group into related items, and it
    was way too big. With hindsight, I would have been better off making a list of
    everything the program did, grouping the list by features, and then coming up
    with a list of requirements without even looking at the code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 代码太复杂，难以理解和分组到相关项目中，而且太大了。事后看来，我最好是列出程序所做的一切，按功能对列表进行分组，然后在甚至不看代码的情况下列出一系列要求。
- en: So my lesson learned when redesigning software is to avoid looking at the code
    at all costs. Write down everything the program does, and what the new functionality
    is that it should include. Turn the list into a set of software requirements with
    associated tasks, tests, and acceptance criteria, and then program to the specifications.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我在重新设计软件时学到的教训是，无论如何都要避免看代码。写下程序的所有功能，以及它应该包括的新功能。将列表转化为一组软件需求，附带任务、测试和验收标准，然后按照规格进行编程。
- en: Code that is tightly coupled
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 紧密耦合的代码
- en: Code that is tightly coupled is hard to test and hard to extend or modify. It
    is also hard to reuse code that is dependent on other code within a system.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 紧密耦合的代码很难测试，也很难扩展或修改。依赖于系统内其他代码的代码也很难重用。
- en: An example of tight coupling is when you reference a concrete class type in
    the parameter rather than referencing an interface. When referencing a concrete
    class, any changes to the concrete class directly affect the class that references
    it. So if you have a database connection class for a client that connects to SQL
    Server, and then takes on another customer that requires an Oracle database, then
    the concrete class would have to be modified for that specific customer and their
    Oracle database. That would lead to two versions of the code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 紧密耦合的一个例子是在参数中引用具体类类型而不是引用接口。当引用具体类时，对具体类的任何更改直接影响引用它的类。因此，如果您为连接到SQL Server的客户端创建了一个数据库连接类，然后接受需要Oracle数据库的另一个客户端，那么具体类将必须针对该特定客户端及其Oracle数据库进行修改。这将导致代码的两个版本。
- en: The more customers there are, the more versions of the code required. This soon
    becomes untenable and a right nightmare to maintain. Imagine that your database
    connection class has 100,000 different clients using 1 of 30 variations of the
    class, and they all have the same bug that has been identified and affects them
    all. That is 30 classes that have to have the same fix put in place, tested, packaged,
    and deployed. That's a lot of maintenance overhead, and very costly financially.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 客户越多，所需的代码版本就越多。这很快变得难以维护，而且在财务上非常昂贵。想象一下，您的数据库连接类有100,000个不同的客户使用类的30个变体中的1个，并且它们都存在已经确定并影响它们所有的相同错误。这是30个类必须具有相同的修复措施，经过测试，打包和部署。这是很多维护开销，而且在财务上非常昂贵。
- en: This particular scenario can be overcome by referencing an interface type and
    then using a database factory to build the required connection object. Then the
    connection string can be set in a configuration file by the customer and passed
    into the factory. The factory would then produce a concrete connection class that
    implements a connection interface for the specific type of database specified
    in the connection string.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用接口类型并使用数据库工厂构建所需的连接对象，可以克服这种特定情况。然后，客户可以在配置文件中设置连接字符串，并将其传递给工厂。工厂将为指定连接字符串中指定的特定数据库类型生成实现连接接口的具体连接类。
- en: 'Here is a bad example of tightly coupled code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是紧密耦合代码的糟糕示例：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see from the example, our database class is tied to using SQL Server
    and would require a hardcoded change to accept any other type of database. We
    will be covering refactoring of code in later chapters with actual code examples.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从示例中可以看出，我们的数据库类与使用SQL Server绑定，并且需要硬编码更改才能接受任何其他类型的数据库。我们将在后面的章节中涵盖代码重构，包括实际的代码示例。
- en: Low cohesion
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 低内聚
- en: Low cohesion consists of unrelated code that performs a variety of different
    tasks all grouped together. An example would be a utility class that contains
    a number of different utility methods for handling dates, text, numbers, doing
    file input and output, data validation, and encryption and decryption.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 低内聚由执行各种不同任务的不相关代码组成。例如，一个实用程序类包含许多不同的实用程序方法，用于处理日期，文本，数字，进行文件输入和输出，数据验证以及加密和解密。
- en: Objects left hanging around
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象挂在那里
- en: When objects are left hanging around in memory, they can lead to memory leaks.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象挂在内存中时，它们可能导致内存泄漏。
- en: Static variables can lead to memory leaks in several ways. If you're not using `DependencyObject`
    or `INotifyPropertyChanged`, then you are effectively subscribing to events. The
    **Common Language Runtime** (**CLR**) creates a strong reference by using the
    `ValueChanged` event via the `PropertyDescriptors AddValueChanged` event, which
    results in the storage of `PropertyDescriptor` that references the object it is
    bound to.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 静态变量可能以几种方式导致内存泄漏。如果您没有使用`DependencyObject`或`INotifyPropertyChanged`，那么您实际上是在订阅事件。**公共语言运行时**（**CLR**）通过`PropertyDescriptors
    AddValueChanged`事件使用`ValueChanged`事件创建强引用，这导致存储引用绑定到的对象的`PropertyDescriptor`。
- en: Unless you unsubscribe your bindings, you will end up with a memory leak. You
    will also end up with memory leaks using static variables that reference objects
    that don't get released. Any object that is referenced by a static variable is
    marked as not to be collected by the garbage collector. This is because static
    variables that reference objects are **Garbage Collection** (**GC**) roots, and
    anything that is a GC root is marked by the garbage collector as *do not collect*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除非取消订阅绑定，否则会导致内存泄漏。使用静态变量引用不会被释放的对象也会导致内存泄漏。静态变量引用的任何对象都被垃圾收集器标记为不可收集。这是因为引用对象的静态变量是**垃圾收集**（**GC**）根，任何是GC根的东西都被垃圾收集器标记为*不要收集*。
- en: When you use anonymous methods that capture class members, the instance of the
    class is referenced. This causes a reference to the class instance to remain alive
    while the anonymous methods stay alive.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用捕获类成员的匿名方法时，会引用类实例。这会导致类实例的引用在匿名方法保持活动的同时保持活动。
- en: When using **unmanaged code** (**COM**), if you do not release any managed and
    unmanaged objects and explicitly deallocate any memory, then you will end up with
    memory leaks.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用**非托管代码**（**COM**）时，如果不释放任何托管和非托管对象并显式释放任何内存，那么会导致内存泄漏。
- en: Code that caches indefinitely without using weak references, deleting unused
    cache, or limiting the cache size will eventually run out of memory.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用弱引用、删除未使用的缓存或限制缓存大小的情况下，无限期缓存的代码最终会耗尽内存。
- en: You would also end up with a memory leak if you were to create object references
    in a thread that never terminates.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在永远不终止的线程中创建对象引用，也会导致内存泄漏。
- en: Event subscriptions that are not anonymous reference classes. While these events
    remain subscribed to, the objects will remain in memory. So unless you unsubscribe
    from events when they are not needed, it is likely you will end up with a memory
    leak.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 不是匿名引用类的事件订阅。当这些事件保持订阅状态时，对象将继续存在于内存中。因此，除非在不需要时取消订阅事件，否则可能会导致内存泄漏。
- en: Use of the Finalize() method
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Finalize()方法
- en: While finalizers can help free up resources from objects that have not been
    correctly disposed of and help to prevent memory leaks, they do have a number
    of drawbacks.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然终结器可以帮助释放未正确处理的对象的资源，并有助于防止内存泄漏，但它们也有许多缺点。
- en: You do not know when finalizers will be called. They will be promoted by the
    garbage collector along with all dependants on the graph to the next generation,
    and will not be garbage-collected until the garbage collector decides to do so.
    This can mean that objects stay in memory for a long time. Out-of-memory exceptions
    could occur using finalizers as you can be creating objects faster then they are
    getting garbage-collected.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您不知道何时会调用终结器。它们将与图上所有依赖项一起被垃圾收集器提升到下一代，并且直到垃圾收集器决定这样做之前，它们不会被垃圾收集。这意味着对象可能会长时间停留在内存中。使用终结器可能会导致内存不足异常，因为您可能会比垃圾收集速度更快地创建对象。
- en: Over-engineering
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过度设计
- en: Over-engineering can be an utter nightmare. The biggest reason for this is that
    as a mere human, wading through a massive system, trying to understand it, how
    you are to use it, and what goes where is a time-consuming process. All the more
    so when there is no documentation, you are new to the system, and even people
    who have been using it much longer than you are unable to answer your questions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 过度设计可能是一场噩梦。最大的原因是，作为一个普通人，浏览一个庞大的系统，试图理解它，如何使用它，以及各个部分的功能是一个耗时的过程。当没有文档时，您对系统还很陌生，甚至使用它比您长时间的人也无法回答您的问题时，情况就更加如此。
- en: This can be a major cause of stress when you are expected to work on it with
    set deadlines.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当您被要求在设定的截止日期内进行工作时，这可能是一个主要的压力原因。
- en: Learn to Keep It Simple, Stupid
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 学会保持简单，愚蠢
- en: A good example of this is at one of the places I've worked. I had to write a
    test for a web app that accepted JSON from a service, allowed a child to do a
    test, and then passed the resulting scoring to another service. I did not use
    OOP, SOLID, or DRY, as I should have according to company policy. But I did get
    the work done by using KISS and procedural programming with events in a very small
    time frame. I was penalized for it and forced to rewrite it using their homegrown
    test player.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是我曾经工作过的一个地方。我必须为一个接受来自服务的JSON的Web应用编写一个测试，允许一个子类进行测试，然后将结果的评分传递给另一个服务。根据公司政策，我没有按照OOP、SOLID或DRY的要求进行操作。但是我通过在非常短的时间内使用KISS和过程式编程与事件完成了工作。我因此受到了惩罚，并被迫使用他们自己开发的测试播放器进行重写。
- en: So I set about learning their test player. There was no documentation, it did
    not follow their DRY principles, and very few people if any really understood
    it. Instead of a few days, like my penalized system, my new version that had to
    use their system took weeks to build because it did not do what I needed it to
    do, and I was not allowed to modify it to do what I needed it to do. So I was
    slowed down while I waited for someone to do what was required.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我开始学习他们的测试播放器。没有文档，也没有遵循DRY原则，很少有人真正理解它。与我的受罚系统相比，我的新版本需要使用他们的系统，因此花了几周的时间来构建，因为它没有做我需要它做的事情，而且我也不被允许修改它来做我需要它做的事情。因此，我在等待有人做所需的工作时被拖慢了速度。
- en: My first solution satisfied the business requirements and was an independent
    piece of code that cared about nothing else. The second solution satisfied the
    development team's technical requirements. The project lasted longer than the
    deadline. Any project that overshoots its deadline costs the business more money
    than planned.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我的第一个解决方案满足了业务需求，并且是一个独立的代码片段，不关心其他任何事情。第二个解决方案满足了开发团队的技术要求。项目的持续时间超过了截止日期。任何超过截止日期的项目都会比计划的成本更高。
- en: The other point I would like to make with my penalized system was that it was
    far simpler and easier to understand than the newer system that was rewritten
    to use the generic test player.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要用我的受罚系统表达的另一点是，它比被重写为使用通用测试播放器的新系统要简单得多，更容易理解。
- en: You don't always have to follow OOP, SOILD, and DRY. Sometimes it pays not to.
    After all, you can write the most beautiful OOP system. But under the hood, your
    code is converted to procedural code that is closer to what the computer understands!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您并不总是需要遵循OOP、SOILD和DRY。有时候不遵循反而更好。毕竟，您可以编写最美丽的OOP系统。但在底层，您的代码被转换为更接近计算机理解的过程式代码！
- en: Lack of regions in large classes
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大类中缺乏区域
- en: Large classes with lots of regions are very hard to read and follow, especially
    when related methods are not grouped together. Regions are very good for grouping
    similar to members within a large class. But they are no good if you don't use
    them!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 大量区域的大类很难阅读和跟踪，特别是当相关方法没有分组在一起时。区域对于在大类中对类似成员进行分组非常有用。但是如果您不使用它们，它们就没有用处！
- en: Lost-intention code
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 失去意图的代码
- en: 'If you are viewing a class and it is doing several things, then how do you
    know what its original intention was? If you are looking for a date method, for
    example, and you find it in a file class in the input/output namespace of your
    code, is the date method in the right location? No. Will it be hard for other
    developers who don''t know your code to find that method? Of course it will. Take
    a look at this code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在查看一个类，并且它正在做几件事情，那么您如何知道它的原始意图是什么？例如，如果您正在寻找一个日期方法，并且在代码的输入/输出命名空间的文件类中找到它，那么日期方法是否在正确的位置？不是。其他不了解您的代码的开发人员会很难找到该方法吗？当然会。看看这段代码：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What is the purpose of the class? The name does not give any indication, and
    what does `MyMethod` do? The class also appears to be doing date manipulation
    and getting product data. The `AddDates` method should be in a class solely for
    managing dates. And the `GetData` method should be in the product's view model.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 类的目的是什么？名称没有给出任何指示，`MyMethod` 做什么？该类似乎还在进行日期操作和获取产品数据。`AddDates` 方法应该在专门管理日期的类中。`GetData`
    方法应该在产品的视图模型中。
- en: Directly exposing information
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接暴露信息
- en: 'Classes that directly expose information are bad. Apart from producing tight
    coupling that can lead to bugs, if you want to change the information type, you
    have to change the type everywhere it is used. Also, what if you want to perform
    data validation before the assignment? Here''s an example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 直接暴露信息的类是不好的。除了产生可能导致错误的紧密耦合之外，如果要更改信息类型，就必须在使用的每个地方更改类型。另外，如果要在赋值之前执行数据验证怎么办？举个例子：
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, if you wanted to change `UnitsInStock` from type `long`
    to type `int`, you would have to change the code *everywhere* it is referenced.
    You would have to do the same with `ProductCode`. If new product codes had to
    adhere to a strict format, you would not be able to validate product codes if
    the string could be directly assigned by the calling class.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，如果要将 `UnitsInStock` 从类型 `long` 更改为类型 `int`，则必须更改 *每个* 引用它的代码。对 `ProductCode`
    也是一样。如果新的产品代码必须遵循严格的格式，如果字符串可以直接由调用类分配，您将无法验证产品代码。
- en: Good code
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 良好的代码
- en: Now that you know what not to do, it's time to look briefly at some good coding
    practices to be able to write pleasing, performant code.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您知道不应该做什么，现在是时候简要了解一些良好的编码实践，以便编写令人愉悦、高性能的代码。
- en: Proper indentation
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 适当的缩进
- en: 'When you use proper indentation, it makes reading the code much easier. You
    can tell by the indentation where code blocks start and end, and what code belongs
    to those code blocks:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用适当的缩进时，阅读代码会变得更加容易。您可以通过缩进看出代码块的开始和结束位置，以及哪些代码属于这些代码块：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding simple example, the code looks nice and is readable. You can
    clearly see where each code block starts and finishes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述简单示例中，代码看起来很好，易于阅读。您可以清楚地看到每个代码块的开始和结束位置。
- en: Meaningful comments
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有意义的注释
- en: Meaningful comments are comments that express the programmer's intention. Such
    comments are useful when the code is correct but may not be easily understood
    by anyone new to the code, or even to the same programmer in a few week's time.
    Such comments can be really helpful.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有意义的注释是表达程序员意图的注释。当代码正确但可能不容易被新手理解，甚至在几周后也是如此时，这样的注释是有用的。这样的注释可以真正有帮助。
- en: API documentation comments
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API 文档注释
- en: 'A good API is an API that has good documentation that is easy to follow. API
    comments are XML comments that can be used to generate HTML documentation. HTML
    documentation is important for developers wanting to use your API. The better
    the documentation, the more developers are likely to want to use your API. Here''s
    an example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的 API 是具有易于遵循的良好文档的 API。API 注释是 XML 注释，可用于生成 HTML 文档。HTML 文档对于想要使用您的 API
    的开发人员很重要。文档越好，开发人员越有可能想要使用您的 API。举个例子：
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This excerpt from the Kusto Query Language project is a good example of an API
    documentation comment.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Kusto 查询语言项目的这段摘录是 API 文档注释的一个很好的例子。
- en: Proper organization using namespaces
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用命名空间进行适当的组织
- en: Code that is properly organized and placed in appropriate namespaces can save
    developers a good amount of time when looking for a particular piece of code.
    For instance, if you are looking for classes and methods to do with dates and
    times, it would be a good idea to have a namespace called `DateTime`, a class
    called `Time` for time-related methods, and a class called `Date` for date-related
    methods.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 适当组织并放置在适当的命名空间中的代码可以在寻找特定代码片段时为开发人员节省大量时间。例如，如果您正在寻找与日期和时间相关的类和方法，最好有一个名为 `DateTime`
    的命名空间，一个名为 `Time` 的类用于与时间相关的方法，以及一个名为 `Date` 的类用于与日期相关的方法。
- en: 'The following is an example of the proper organization of namespaces:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是命名空间的适当组织的示例：
- en: '| **Name** | **Description** |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** |'
- en: '| `CompanyName.IO.FileSystem` | The namespace contains classes that define
    file and directory operations. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `CompanyName.IO.FileSystem` | 该命名空间包含定义文件和目录操作的类。|'
- en: '| `CompanyName.Converters` | The namespace contains classes for performing
    various conversion operations. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `CompanyName.Converters` | 该命名空间包含执行各种转换操作的类。|'
- en: '| `CompanyName.IO.Streams` | The namespace contains types for managing stream
    input and output. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `CompanyName.IO.Streams` | 该命名空间包含用于管理流输入和输出的类型。|'
- en: Good naming conventions
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 良好的命名约定
- en: It is good to follow the Microsoft C# naming conventions. Use Pascal casing
    for namespaces, classes, interfaces, enums, and methods. Use camel case for variable
    names and argument names, and make sure to prefix member variables with an underscore.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循 Microsoft C# 命名约定是很好的。对于命名空间、类、接口、枚举和方法，请使用帕斯卡命名法。对于变量名和参数名，请使用驼峰命名法，并确保使用下划线前缀来命名成员变量。
- en: 'Have a look at this example code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个示例代码：
- en: '[PRE16]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It shows suitable examples of naming conventions for namespaces, classes, member
    variables, classes, parameters, and local variables.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 它展示了命名空间、类、成员变量、类、参数和局部变量的命名约定的合适示例。
- en: Classes that only do one job
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只做一件事的类
- en: A good class is a class that does only one job. When you read the class, its
    intention is clear. Only the code that should be in that class is in that class
    and nothing else.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的类是一个只做一件事的类。当您阅读类时，其意图是清晰的。只有应该在该类中的代码才在该类中，没有其他东西。
- en: Methods that do one thing
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只做一件事的方法
- en: Methods should only do one thing. You should not have a method that does more
    than one thing, such as decrypting a string and performing string replacement.
    A method's intent should be clear. Methods that do only one thing are more inclined
    to be small, readable, and intentional.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 方法应该只做一件事。你不应该有一个做多件事的方法，比如解密字符串和执行字符串替换。方法的意图应该是清晰的。只做一件事的方法更容易小、易读和有意义。
- en: Methods with less than 10 lines, and preferably no more than 4
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法不超过10行，最好不超过4行
- en: Ideally, you should have methods that are no longer than 4 lines of code. However,
    this is not always possible, so you should aim to have methods that are no more
    than 10 lines in length so that they are easy to read and maintain.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你应该有不超过4行代码的方法。然而，这并不总是可能的，所以你应该努力使方法的长度不超过10行，以便它们易于阅读和维护。
- en: Methods with no more than two parameters
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法不超过两个参数
- en: 'It is best to have methods with no parameters, but having one or two is okay.
    If you start having more than two parameters, you need to think about the responsibility
    of your class and methods: are they taking on too much? If you do need more than
    two parameters, then you are better placed to pass an object.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最好是有没有参数的方法，但有一个或两个也可以。如果开始有超过两个参数，你需要考虑你的类和方法的责任：它们是否承担了太多？如果你确实需要超过两个参数，那么最好传递一个对象。
- en: Any method with more than two parameters can become difficult to read and follow.
    Having no more than two parameters makes the code readable, and a single parameter
    that is an object is way more readable than a method with several parameters.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 任何超过两个参数的方法都可能变得难以阅读和理解。最多只有两个参数使得代码更易读，而一个对象作为单个参数比具有多个参数的方法更易读。
- en: Proper use of exceptions
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常的正确使用
- en: Never use exceptions to control program flow. Handle common conditions that
    might trigger exceptions in such a way that an exception will not be raised or
    thrown. A good class is designed in such a way that you can avoid exceptions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要使用异常来控制程序流程。以一种不会引发异常的方式处理可能触发异常的常见条件。一个好的类设计应该能够避免异常。
- en: Recover from exceptions and/or release resources by using `try`/`catch`/`finally`
    exceptions. When catching exceptions, use specific exceptions that may be thrown
    in your code, so that you have more detailed information to log or assist in handling
    the exception.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`try`/`catch`/`finally`异常来恢复异常和/或释放资源。在捕获异常时，使用可能在你的代码中抛出的特定异常，这样你就可以获得更详细的信息来记录或帮助处理异常。
- en: 'Sometimes, using the predefined .NET exception types is not always possible.
    In such cases, it will be necessary to produce your own custom exceptions. Suffix
    your custom exception classes with the word `Exception`, and make sure to include
    the following three constructors:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，使用预定义的.NET异常类型并不总是可能的。在这种情况下，将需要生成自定义异常。用单词`Exception`作为自定义异常类的后缀，并确保包括以下三个构造函数：
- en: '`Exception()`: Uses default values'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exception()`: 使用默认值'
- en: '`Exception(string)`: Accepts a string message'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exception(string)`: 接受一个字符串消息'
- en: '`Exception(string, exception)`: Accepts a string message and an inner exception'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exception(string, exception)`: 接受一个字符串消息和一个内部异常'
- en: If you have to throw exceptions, don't return error codes but return exceptions
    with meaningful information.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必须抛出异常，不要返回错误代码，而是返回带有有意义信息的异常。
- en: Code that is readable
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可读的代码
- en: The more readable the code is, the more developers will enjoy working with it.
    Such code is easier to learn and work with. As developers come and go on a project,
    newbies will be able to read, extend, and maintain the code with little effort.
    Readable code is also less inclined to be buggy and unsafe.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 代码越易读，开发者就越喜欢使用它。这样的代码更容易学习和使用。随着开发者在项目中的进出，新手将能够轻松阅读、扩展和维护代码。易读的代码也不太容易出错和不安全。
- en: Code that is loosely coupled
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 松散耦合的代码
- en: Loosely coupled code is easier to test and refactor. You can also swap and change
    loosely coupled code more easily if you need to. Code reuse is another benefit
    of loosely coupled code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 松散耦合的代码更容易测试和重构。如果需要，你也可以更容易地交换和更改松散耦合的代码。代码重用是松散耦合代码的另一个好处。
- en: 'Let''s use our bad example of a database being passed a SQL Server connection.
    We could make that same class loosely coupled by referencing an interface instead
    of a concrete type. Let''s have a look at a good example of the refactored bad
    example from earlier:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个糟糕的例子，一个数据库被传递了一个SQL Server连接。我们可以通过引用一个接口而不是具体类型，使得相同的类松散耦合。让我们看一下之前重构的糟糕例子的好例子：
- en: '[PRE17]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see in this rather basic example, as long as the passed-in class
    implements the `IDatabaseConnection` interface, we can pass in any class for any
    kind of database connection. So if we find a bug in the SQL Server connection
    class, only SQL Server clients are affected. That means the clients with different
    databases will continue to work, and we only have to fix the code for SQL Server
    customers in the one class. This reduces the maintenance overhead and so reduces
    the overall cost of maintenance.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这个相当基本的例子中所看到的，只要传入的类实现了`IDatabaseConnection`接口，我们就可以为任何类型的数据库连接传入任何类。因此，如果我们在SQL
    Server连接类中发现了一个bug，只有SQL Server客户端会受到影响。这意味着具有不同数据库的客户端将继续工作，我们只需要在一个类中修复SQL Server客户端的代码。这减少了维护开销，从而降低了总体维护成本。
- en: High cohesion
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高内聚
- en: Common functionality that is correctly grouped together is known to be highly
    cohesive. Such code is easy to find. For example, if you look at the `Microsoft
    System.Diagnostics` namespace, you will find that it only contains code that pertains
    to diagnostics. It would not make sense to include collections and filesystem
    code in the `Diagnostics` namespace.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 正确分组的常见功能被认为是高度内聚的。这样的代码很容易找到。例如，如果你查看`Microsoft System.Diagnostics`命名空间，你会发现它只包含与诊断相关的代码。在`Diagnostics`命名空间中包含集合和文件系统代码是没有意义的。
- en: Objects are cleanly disposed of
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象被清理干净
- en: When using disposable classes, you should always call the `Dispose()` method
    to cleanly dispose of any resources that are in use. This helps to negate the
    possibility of memory leaks.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: There are times when you may need to set an object to `null` for it to go out
    of scope. An example would be a static variable that holds a reference to an object
    that you no longer require.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'The `using` statement is also a good clean way to use disposable objects, as
    when the object is no longer in scope it is automatically disposed of, so you
    don''t need to explicitly call the `Dispose()` method. Let''s have a look at the
    code that follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code defines a disposable object in the `using` statement and does what
    it needs to between the opening and closing curly braces. The object is automatically
    disposed of before the braces are exited. And so there is no need to manually
    call the `Dispose()` method, because it is called automatically.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding the Finalize() method
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using unmanaged resources, it is best to implement the `IDisposable` interface
    and avoid using the `Finalize()` method. There is no guarantee of when finalizers
    will run. They may not always run in the order you expect or when you expect them
    to run. Instead, it is better and more reliable to dispose of unmanaged resources
    in the `Dispose()` method.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: The right level of abstraction
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have the right level of abstraction when you expose to the higher level
    only that which needs exposure, and you do not get lost in the implementation.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: If you find that you are getting lost in the implementation details, then you
    have over-abstracted. If you find that multiple people have to work in the same
    class at the same time, then you have under-abstracted. In both cases, refactoring
    would be needed to get the abstraction to the right level.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Using regions in large classes
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regions are very useful for grouping items within a large class as they can
    be collapsed. It can be quite daunting reading through a large class and having
    to jump back and forth between methods, so grouping methods that call each other
    in the class is a good way to group them. The methods can then be collapsed and
    expanded as needed when working on a piece of code.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from what we have looked at so far, good coding practices make
    for code that is far more readable and easier to maintain. We will now take a
    look at the need for coding standards and principles along with some software
    methodologies such as SOLID and DRY.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The need for coding standards, principles, and methodologies
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most software today is written by multiple teams of programmers. As you know,
    we all have our own unique ways of coding, and we all have some form of programming
    ideology. You can easily find programming debates regarding various software development
    paradigms. But the consensus is that it does make our lives easier as programmers
    if we do all adhere to a given set of coding standards, principles, and methodologies.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Let's review what we mean by these in a little more detail.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Coding standards
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Coding standards set out several dos and don'ts that must be adhered to. Such
    standards can be enforced through tools such as FxCop and manually via peer code
    reviews. All companies have their own coding standards that must be adhered to.
    But what you will find in the real world is that when the business expects a deadline
    to be met, those coding standards can go out of the window as the deadline can
    become more important than the actual code quality. This is usually rectified
    by adding any required refactoring to the bug list as technical debt to be addressed
    after the release.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft has its own coding standards, and the majority of the time these
    are the adopted standards that are modified to suit each business'' needs. Here
    are some examples of coding standards found online:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.c-sharpcorner.com/UploadFile/ankurmalik123/C-Sharp-coding-standards/](https://www.c-sharpcorner.com/UploadFile/ankurmalik123/C-Sharp-coding-standards/)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.dofactory.com/reference/csharp-coding-standards](https://www.dofactory.com/reference/csharp-coding-standards)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.dofactory.com/reference/csharp-coding-standards](https://www.dofactory.com/reference/csharp-coding-standards)'
- en: '[https://blog.submain.com/coding-standards-c-developers-need/](https://blog.submain.com/coding-standards-c-developers-need/)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://blog.submain.com/coding-standards-c-developers-need/](https://blog.submain.com/coding-standards-c-developers-need/)'
- en: When people across teams or within the same team adhere to coding standards,
    your code base becomes unified. A unified code base is much easier to read, extend,
    and maintain. It is also likely to be less error-prone. And if errors do exist,
    they are more likely to be found more easily, since the code follows a standard
    set of guidelines that all developers adhere to.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当跨团队或同一团队的人遵守编码标准时，您的代码库将变得统一。统一的代码库更容易阅读、扩展和维护。它也更不容易出错。如果存在错误，也更容易找到，因为代码遵循一套所有开发人员都遵守的标准准则。
- en: Coding principles
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码原则
- en: Coding principles are a set of guidelines for writing high-quality code, testing
    and debugging that code, and performing maintenance on the code. Principles can
    be different between programmers and programming teams.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 编码原则是一组编写高质量代码、测试和调试代码以及对代码进行维护的准则。原则可能因程序员和编程团队而异。
- en: Even if you are a lone programmer, you will do yourself an honorable service
    by defining your own coding principles and sticking to them. If you work in a
    team, then it is very beneficial to all to agree on a set of coding standards
    to make working on shared code easier.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您是一个孤独的程序员，也可以通过定义自己的编码原则并坚持它们来为自己提供光荣的服务。如果您在一个团队中工作，那么达成一套编码标准对于所有人都是非常有益的，可以使共享代码的工作更加容易。
- en: Throughout this book, you will see examples of coding principles such as SOLID,
    YAGNI, KISS, and DRY, all of which will be explained in detail. But for now, **SOLID**
    stands for **Single Responsibility Principle, Open-Closed Principle, Liskov Substitution,
    Interface Segregation Principle,** and **Dependency Inversion Principle**. **YAGNI**
    stands for **You Ain't Gonna Need It**. **KISS** stands for **Keep It Simple,
    Stupid**, and **DRY** stands for **Don't Repeat Yourself**.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，您将看到诸如SOLID、YAGNI、KISS和DRY等编码原则的示例，所有这些都将被详细解释。但现在，**SOLID**代表**单一职责原则、开闭原则、里氏替换原则、接口隔离原则**和**依赖反转原则**。**YAGNI**代表**你不会需要它**。**KISS**代表**保持简单，愚蠢**，**DRY**代表**不要重复自己**。
- en: Coding methodologies
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码方法论
- en: Coding methodologies break down the process of developing software into a number
    of predefined phases. Each phase will have a number of steps associated with it.
    Different developers and development teams will have their own coding methodologies
    that they follow. The main aim of coding methodologies is to streamline the process
    from the initial concept, through the coding phase, to the deployment and maintenance
    phases.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 编码方法论将软件开发过程分解为许多预定义阶段。每个阶段都将与之相关的一些步骤。不同的开发人员和开发团队将遵循自己的编码方法论。编码方法论的主要目的是从最初的概念、编码阶段到部署和维护阶段的流程。
- en: In this book, you will become accustomed to **Test-Driven Development** (**TDD**)
    and **Behavioral-Driven Development** (**BDD**) using SpecFlow, and **Aspect-Oriented
    Programming** (**AOP**) using PostSharp.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，您将习惯于使用SpecFlow进行**测试驱动开发**（**TDD**）和**行为驱动开发**（**BDD**），以及使用PostSharp进行**面向方面的编程**（**AOP**）。
- en: Coding conventions
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码约定
- en: It is best to implement the Microsoft C# coding conventions. You can review
    them at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最好实施微软的C#编码约定。您可以在[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions)上查看它们。
- en: By adopting Microsoft's coding conventions, you are guaranteed to write code
    in a formally accepted and agreed-upon format. These C# coding conventions help
    people to focus on reading your code and spend less time focusing on the layout.
    Basically, Microsoft's coding standards promote best practices.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用微软的编码约定，您可以确保以正式接受和商定的格式编写代码。这些C#编码约定帮助人们专注于阅读您的代码，而不是专注于布局。基本上，微软的编码标准促进了最佳实践。
- en: Modularity
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块化
- en: Breaking large programs up into smaller modules makes a lot of sense. Small
    modules are easy to test, are more readily reused, and can be worked on independently
    from other modules. Small modules are also easier to extend and maintain.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 将大型程序分解为较小的模块是非常有意义的。小模块易于测试，更容易重用，并且可以独立于其他模块进行操作。小模块也更容易扩展和维护。
- en: A modular program can be divided into different assemblies and different namespaces
    within those assemblies. Modular programs are also much easier to work on in team
    environments as different modules can be worked on by different teams.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化程序可以分为不同的程序集和程序集内的不同命名空间。模块化程序在团队环境中也更容易操作，因为不同的模块可以由不同的团队进行操作。
- en: In the same project, code is modularized by adding folders that reflect namespaces.
    A namespace must only contain code that is related to its name. So, for instance,
    if you have a namespace called `FileSystem`, then types related to files and directories
    should be placed in that folder. Likewise, if you have a namespace called `Data`,
    then only types related to data and data sources should be located in that namespace.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个项目中，通过添加反映命名空间的文件夹来将代码模块化。命名空间必须只包含与其名称相关的代码。因此，例如，如果您有一个名为`FileSystem`的命名空间，则与文件和目录相关的类型应放置在该文件夹中。同样，如果您有一个名为`Data`的命名空间，则只有与数据和数据源相关的类型应放置在该命名空间中。
- en: Another beautiful aspect of correct modularization is that if you keep modules
    small and simple, they are easy to read. Most of a coder's life apart from coding
    is spent reading and understanding code. So the smaller and more correctly modularized
    the code is, then the more easier it is to read and understand the code. This
    leads to a greater understanding of the code and improves developer take-up and
    use of the code.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 正确模块化的另一个美好之处是，如果你保持模块小而简单，它们就更容易阅读。除了编码之外，大部分程序员的生活都花在阅读和理解代码上。因此，代码越小、正确模块化，就越容易阅读和理解。这会导致对代码的更深入理解，并提高开发人员对代码的接受和使用。
- en: KISS
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KISS
- en: You may be the super genius of the computer programming world. You may be able
    to produce code that is so sexy that other programmers can only stare at it in
    awe and end up drooling on their keyboard. But do those other programmers know
    what the code is by just looking at it? If you found that code in 10 weeks' time
    when you head deep into a mountain of different code with deadlines to meet, would
    you be able to explain with absolute clarity what your code does and the rationale
    behind your choice of coding method? And have you considered that you may have
    to work on that code further down the road?
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能是计算机编程世界的超级天才。你可能能够编写出让其他程序员只能惊叹地盯着它并流口水的代码。但其他程序员只看代码就知道它是什么吗？如果你在10周后发现了这段代码，当时你深陷于不同代码的海洋中，需要满足截止日期，你能清楚地解释你的代码做了什么以及你选择编码方法的理由吗？你有没有考虑过你可能需要在将来进一步处理这段代码？
- en: Have you ever programmed some code, gone away, and then looked at it more than
    a few days later and thought to yourself, *I didn't write this rubbish, did I?
    What was I thinking!?* I know I've been guilty of it and so have some of my ex-colleagues.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经编写过一些代码，然后离开，几天后再看它，然后对自己说，“我没写这种垃圾，是吗？我当时在想什么！？”我知道我曾经有过这种经历，我的一些前同事也有。
- en: When programming code, it is essential to keep the code simple and in a human-readable
    format that even newbie junior programmers can understand. Often juniors are exposed
    to code to read, understand, and then maintain. The more complex the code, the
    longer it takes for juniors to get up to speed. Even seniors can struggle with
    complex systems to the point that they leave to find work elsewhere that's less
    taxing on the brain and their well-being.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，保持代码简单且易于阅读，即使新手初级程序员也能理解。通常，初级程序员需要阅读、理解和维护代码。代码越复杂，初级程序员需要花费的时间就越长。甚至高级程序员也可能在复杂系统中遇到困难，以至于他们离开寻找其他工作，这样对大脑和身心的负担就会减轻。
- en: For example, if you are working on a simple website, ask yourself a few questions.
    Does it really need to use microservices? Is the brownfield project you are working
    on really complicated? Is it possible to simplify it to make it easier to maintain?
    When developing a new system, what are the minimum number of moving parts you
    need to write a robust, maintainable, and scalable solution that performs well?
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你正在开发一个简单的网站，问问自己几个问题。它真的需要使用微服务吗？你正在处理的旧项目真的很复杂吗？有可能简化它以便更容易维护吗？在开发新系统时，你需要写一个健壮、可维护和可扩展的解决方案，需要的最少的移动部件是什么？
- en: YAGNI
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: YAGNI
- en: YAGNI is a discipline in the agile world of programming that stipulates that
    a programmer should not add any code until it is absolutely needed. An honest
    programmer will write failing tests based on a design, then write just enough
    production code for the tests to work, and finally, refactor the code to remove
    any duplication. Using the YAGNI software development methodology, you keep your
    classes, methods, and overall lines of code to an absolute minimum.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: YAGNI是编程敏捷世界中的一种纪律，规定程序员在绝对需要之前不应添加任何代码。一个诚实的程序员会根据设计编写失败的测试，然后只编写足够的生产代码使测试工作，最后重构代码以消除任何重复。使用YAGNI软件开发方法，你将你的类、方法和总代码行数保持在绝对最低限度。
- en: The primary goal of YAGNI is to prevent the over-engineering of software systems
    by computer programmers. Do not add complexity if it is not needed. You must remember
    to only write the code that you need. Don't write code that you don't need, and
    don't write code for the sake of experimentation and learning. Keep experimental
    and learning code in sandboxed projects specifically for those purposes.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: YAGNI的主要目标是防止计算机程序员过度设计软件系统。如果不需要，就不要增加复杂性。你必须记住只编写你需要的代码。不要编写你不需要的代码，也不要为了实验和学习而编写代码。将实验和学习代码保留在专门用于这些目的的沙盒项目中。
- en: DRY
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DRY
- en: I said *Don't Repeat Yourself!* If you find that you are writing the same code
    in multiple areas, then this is a definite candidate for refactoring. You should
    look at the code to see if it can be genericized and placed in a helper class
    for use throughout the system or in a library for use by other projects.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我说*不要重复自己！* 如果你发现自己在多个地方写了相同的代码，那么这绝对是重构的候选。你应该查看代码，看看它是否可以变成通用的，并放在一个辅助类中供整个系统使用，或者放在一个库中供其他项目使用。
- en: If you have the same piece of code in multiple locations, and you find the code
    has a fault and needs to be modified, you must then modify the code in other areas.
    In situations like this, it is very easy to overlook code that requires modification.
    The result is code that gets released with the problem fixed in some areas, but
    still existing in others.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在多个地方有相同的代码，并且发现代码有错误需要修改，那么你必须在其他地方修改代码。在这种情况下，很容易忽视需要修改的代码。结果就是发布的代码在一些地方修复了问题，但在其他地方仍然存在。
- en: That is why it is a good idea to remove duplicate code as soon as you encounter
    it, as it may cause more problems further down the road if you don't.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在遇到重复代码时，尽快删除它是个好主意，因为如果不这样做，它可能会在将来造成更多问题。
- en: SOLID
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SOLID
- en: 'SOLID is a set of five design principles that intend to make software easier
    to understand and maintain. Software code should be easy to read and extend without
    having to modify portions of the existing code. The five SOLID design principles
    are as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID是一组旨在使软件更易于理解和维护的五个设计原则。软件代码应该易于阅读和扩展，而无需修改现有代码的部分。五个SOLID设计原则如下：
- en: '**Single Responsibility Principle**: Classes and methods should only perform
    a single responsibility. All the elements that form a single responsibility should
    be grouped together and encapsulated.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一责任原则**：类和方法应该只执行单一职责。组成单一责任的所有元素应该被分组在一起并封装起来。'
- en: '**Open/Closed Principle**: Classes and methods should be open for extension
    and closed for modification. When a change to the software is required, you should
    be able to extend the software without modifying any of the code.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开闭原则**：类和方法应该对扩展开放，对修改关闭。当需要对软件进行更改时，您应该能够扩展软件而不修改任何代码。'
- en: '**Liskov Substitution**: Your function has a pointer to a base class. It must
    be able to use any class derived from the base class without knowing it.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里氏替换原则**：您的函数有一个指向基类的指针。它必须能够使用任何从基类派生的类而不知道它。'
- en: '**Interface Segregation Principle**: When you have large interfaces, the clients
    that use them may not need all the methods. So, using the **Interface Segregation
    Principle** (**ISP**), you extract out methods to different interfaces. This means
    that instead of having one big interface, you have many small interfaces. Classes
    can then implement interfaces with only the methods they need.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离原则**：当您有大型接口时，使用它们的客户端可能不需要所有的方法。因此，使用**接口隔离原则**（**ISP**），您将方法提取到不同的接口中。这意味着您不再有一个大接口，而是有许多小接口。类可以实现只有它们需要的方法的接口。'
- en: '**Dependency Inversion Principle**: When you have a high-level module, it should
    not be dependent upon any low-level modules. You should be able to switch between
    low-level modules freely without affecting the high-level module that uses them.
    Both high-level and low-level modules should depend upon abstractions.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖反转原则**：当您有一个高级模块时，它不应该依赖于任何低级模块。您应该能够在不影响使用它们的高级模块的情况下自由切换低级模块。高级和低级模块都应该依赖于抽象。'
- en: An abstraction should not depend upon details, but details should depend upon
    abstractions.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象不应该依赖于细节，但细节应该依赖于抽象。
- en: When you declare variables, you should always use static types such as an interface
    or abstract class. Concrete classes that implement the interface or inherit from
    the abstract class can then be assigned to the variable.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当声明变量时，您应该始终使用静态类型，如接口或抽象类。然后可以将实现接口或继承自抽象类的具体类分配给变量。
- en: Occam's Razor
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 奥卡姆剃刀
- en: 'Occam''s Razor states the following: *Entities should not be multiplied without
    necessity*. To paraphrase, this essentially means that *the simplest solution
    is most likely the correct one*. So, in software development, the breaking of
    the principle of Occam''s Razor is accomplished by making unnecessary assumptions
    and employing the least simple solution to a software problem.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 奥卡姆剃刀陈述如下：*实体不应该被无必要地增加*。换句话说，这基本上意味着*最简单的解决方案很可能是正确的*。因此，在软件开发中，违反奥卡姆剃刀原则是通过进行不必要的假设并采用最不简单的解决方案来实现的。
- en: Software projects are usually founded upon a collection of facts and assumptions.
    Facts are easy to deal with but assumptions are something else. When coming up
    with a software project solution to a problem, you normally discuss the problem
    and potential solutions as a team. When choosing a solution, you should always
    choose the project with the least assumptions as this will be the most accurate
    choice to implement. If there are a few fair assumptions, the more assumptions
    you are having to make, the more likely it is that your design solution is flawed.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 软件项目通常建立在一系列事实和假设之上。事实很容易处理，但假设是另一回事。在解决软件项目问题时，通常作为团队讨论问题和潜在解决方案。在选择解决方案时，您应该始终选择假设最少的项目，因为这将是最准确的实施选择。如果有一些公平的假设，您需要做的假设越多，您的设计解决方案就越有可能存在缺陷。
- en: A project with less moving parts has less that can go wrong with it. So, by
    keeping projects small with as few entities as possible by not making assumptions
    unless they are necessary, and only dealing with facts, you adhere to the principle
    of Occam's Razor.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 移动部件较少的项目出现问题的可能性较小。因此，通过保持项目小，尽可能少地做出假设，除非有必要，并且只处理事实，您遵守了奥卡姆剃刀原则。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have had an introduction to good code and bad code and,
    hopefully, you now understand why good code matters. You have also been provided
    with the link to the Microsoft C# coding conventions so that you can follow Microsoft
    best practices for coding (if you are not already doing so).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经对好代码和坏代码有了介绍，希望您现在明白了为什么好代码很重要。您还提供了微软C#编码约定的链接，以便您可以遵循微软的最佳编码实践（如果您还没有这样做的话）。
- en: You have also briefly been introduced to various software methodologies including
    DRY, KISS, SOLID, YAGNI, and Occam's Razor.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您还简要介绍了各种软件方法，包括DRY、KISS、SOLID、YAGNI和奥卡姆剃刀。
- en: Using modularity, you have seen the benefits of modularizing code using namespaces
    and assemblies. Such benefits include independent teams being able to work on
    independent modules, and code reusability and maintainability.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块化，您已经看到了使用命名空间和程序集模块化代码的好处。这些好处包括独立团队能够独立工作在独立模块上，以及代码的可重用性和可维护性。
- en: In the next chapter, we will be looking at peer code reviews. They can be unpleasant
    at times, but peer code reviews help to keep programmers in check by making sure
    they are adhering to the company coding procedure.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下同行代码审查。有时可能会令人不快，但同行代码审查有助于通过确保他们遵守公司编码程序来使程序员受到约束。
- en: Questions
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are some of the outcomes of bad code?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 坏代码的一些结果是什么？
- en: What are some of the outcomes of good code?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好代码的一些结果是什么？
- en: What are some of the benefits of writing modular code?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写模块化代码的一些好处是什么？
- en: What is DRY code?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DRY代码是什么？
- en: Why should you KISS when writing code?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写代码时为什么要KISS？
- en: What does the acronym SOLID stand for?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SOLID的首字母缩写代表什么？
- en: Explain YAGNI.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释YAGNI。
- en: What's Occam's Razor?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 奥卡姆剃刀是什么？
- en: Further reading
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Adaptive Code: Agile coding with design patterns and SOLID principles, Second
    Edition* by Gary McLean Hall.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自适应代码：使用设计模式和SOLID原则进行敏捷编码，第二版*，作者是Gary McLean Hall。'
- en: '*Hands-On Design Patterns with C# and .NET Core* by Jeffrey Chilberto and Gaurav
    Aroraa.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用C#和.NET Core的设计模式实践*，作者是Jeffrey Chilberto和Gaurav Aroraa。'
- en: '*Building Maintainable Software, C# Edition* by Rob can der Leek, Pascal can
    Eck, Gijs Wijnholds, Sylvan Rigal, and Joost Visser.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可维护软件构建，C#版*，作者是Rob can der Leek，Pascal can Eck，Gijs Wijnholds，Sylvan Rigal和Joost
    Visser。'
- en: Good information on software anti-patterns, including a long list of anti-patterns,
    can be found at [https://en.wikibooks.org/wiki/Introduction_to_Software_Engineering/Architecture/Anti-Patterns](https://en.wikibooks.org/wiki/Introduction_to_Software_Engineering/Architecture/Anti-Patterns).
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于软件反模式的良好信息，包括一个反模式的长列表，可以在[https://en.wikibooks.org/wiki/Introduction_to_Software_Engineering/Architecture/Anti-Patterns](https://en.wikibooks.org/wiki/Introduction_to_Software_Engineering/Architecture/Anti-Patterns)找到。
- en: Good information on design patterns, with a list of design patterns that links
    to diagrams and implementation source code, can be found at [https://en.wikipedia.org/wiki/Software_design_pattern](https://en.wikipedia.org/wiki/Software_design_pattern).
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于设计模式的良好信息，包括一个链接到图表和实现源代码的设计模式列表，可以在[https://en.wikipedia.org/wiki/Software_design_pattern](https://en.wikipedia.org/wiki/Software_design_pattern)找到。

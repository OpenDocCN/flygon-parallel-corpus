- en: Classes, Objects, and Data Structures
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at organizing, formatting, and commenting on classes.
    We will also look at writing clean C# objects and data structures that respect
    the Law of Demeter. In addition, we will look at immutable objects and data structures
    and the interfaces and classes that define immutable collections in the `System.Collections.Immutable`
    namespace.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following broad topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Organizing classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commenting for document generation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cohesion and coupling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Law of Demeter
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable objects and data structures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you progress through this chapter, you will learn the following skills:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: How to effectively organize your classes using namespaces.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your classes will become smaller and more meaningful as you learn to program
    them with only a single responsibility.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it comes to writing your own APIs, you will be able to provide good developer
    documentation by providing comments that aid document generation tools.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any programs you write will be easy to modify and extend due to their high cohesion
    and low coupling.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, you will be able to apply the Law of Demeter and write and use immutable
    data structures.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's start by looking at how we can effectively organize our classes by
    using namespaces.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can access the code for this chapter on GitHub, at [https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH03](https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH03).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Organizing classes
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will notice that the hallmark of a clean project is that it will have well-organized
    classes. And folders will be used to group classes that belong together. Further,
    the classes in the folders will be enclosed within namespaces that match the assembly
    name and folder structure.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Each interface, class, struct, and enum should have its own source file in
    the correct namespace. Source files should be logically grouped together in the
    appropriate folders and the namespaces for the source files should match the assembly
    name and folder structure. The following screenshot demonstrates a clean folder
    and file structure:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1dc5cf04-4924-414d-88a9-62c6305c9757.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: It is a bad idea to have more than one interface, class, struct, or enum in
    an actual source file. The reason for this is that it can make locating items
    difficult, despite the fact that we have IntelliSense to assist us.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'When thinking about your namespaces, it is a good idea to follow the Pascal
    casing sequence of company name, product name, technology name, and then plural
    names for components separated by spaces. See the following for an example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The reason for starting with the company name is that it helps to avoid namespace
    classes. So, if Microsoft and FakeCompany both have a namespace called `System`,
    which `System` you desire to use can be differentiated by the company name.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, any items of code that are able to be reused in multiple projects are
    best placed in separate assemblies that can be accessed by multiple projects:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When using tests in your code, such as when doing **Test-Driven Development**
    (**TDD**), it is always best to keep your test classes in separate assemblies.
    Test assemblies should always be given the name of the assembly they are testing
    with the namespace `Tests` appended to the end of the assembly name:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You should never put tests for different assemblies in the same test assembly
    as each other. Always keep them separate.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the namespace and type should not use the same name as this can
    produce compiler conflicts. When pluralizing namespaces, you can forego pluralizing
    for company names, product names, and acronyms.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, here are the rules to keep in mind when organizing classes:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Follow the Pascal casing sequence of company name, product name, technology
    name, and plural names for components separated by spaces.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Place reusable items of code in separate assemblies.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't use the same name for the namespace and type.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't pluralize company and product names and acronyms.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将公司和产品名称以及缩写形式变为复数。
- en: We'll move on to the responsibility of classes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续讨论类的责任。
- en: A class should have only one responsibility
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个类应该只有一个责任
- en: Responsibility is the work that has been assigned to the class. In the SOLID
    set of principles, the S stands for **Single Responsibility Principle** (**SRP**). When
    applied to a class, SRP states that the class must only work on a single aspect
    of the feature being implemented. The responsibility of that single aspect should
    be fully encapsulated within the class. Therefore, you should never apply more
    than one responsibility to a class.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 责任是分配给类的工作。在SOLID原则集中，S代表**单一责任原则**（**SRP**）。当应用于类时，SRP规定类必须只处理正在实现的功能的一个方面。该单个方面的责任应完全封装在类内。因此，您不应该将超过一个责任应用于一个类。
- en: 'Let''s look at an example to understand why:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子来理解为什么：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see in the preceding code, for the `MultipleResponsibilities` class,
    we have our cryptography functionalities implemented with the `DecryptString`
    and the `EncryptString` methods. We also have file access implemented with the
    `ReadTextFromFile` and `SaveTextToFile` methods. This class breaks the SRP principle.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所看到的，对于`MultipleResponsibilities`类，我们已经实现了我们的加密功能，包括`DecryptString`和`EncryptString`方法。我们还实现了文件访问，包括`ReadTextFromFile`和`SaveTextToFile`方法。这个类违反了SRP原则。
- en: 'So we need to break this class up into two classes, one for cryptography and
    the other for file access:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要将这个类分成两个类，一个用于加密和另一个用于文件访问：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we can now see from the preceding code, by moving the `EncryptString` and
    `DecryptString` methods to their own `Cryptography` class in the core security
    namespace, we have made it easy to reuse the code to encrypt and decrypt strings
    across different products and technology groups. The `Cryptography` class also
    complies with SRP.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们现在从前面的代码中所看到的，通过将`EncryptString`和`DecryptString`方法移动到核心安全命名空间中的自己的`Cryptography`类中，我们已经使得在不同产品和技术组中重用代码来加密和解密字符串变得容易。`Cryptography`类也符合SRP。
- en: 'In the following code, we can see that the `SecurityAlgorithm` parameter of
    the `Cryptography` class is an enum and has been placed in its own source file.
    This helps to keep code clean, minimal, and well organized:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们可以看到`Cryptography`类的`SecurityAlgorithm`参数是一个枚举，并已放置在自己的源文件中。这有助于保持代码整洁、最小化和良好组织：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, in the following `TextFile` class, we again abide by SRP and have a nice
    reusable class that is in the appropriate core filesystem namespace. The `TextFile`
    class is reusable across different products and technology groups:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在下面的`TextFile`类中，我们再次遵守SRP，并且有一个很好的可重用的类，位于适当的核心文件系统命名空间中。`TextFile`类可以在不同产品和技术组中重复使用：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We've looked at the organization and the responsibility of classes. Now let's
    take a look at commenting on classes for the benefit of other developers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过了类的组织和责任。现在让我们来看看为了其他开发人员的利益而对类进行注释。
- en: Commenting for documentation generation
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于文档生成的注释
- en: Documenting your source code is always a good idea, whether it is an internal
    project or external software that will be used by other developers. Internal projects
    suffer because of developer turnover and often poor, or little to no documentation
    available to help new developers get up to speed. Many third-party APIs fail to
    get off the ground or uptake is slower than expected, often with adopters abandoning
    the APIs through frustration because of the poor state of the developer documentation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 始终为您的源代码编写文档是一个好主意，无论是内部项目还是将由其他开发人员使用的外部软件。内部项目因为开发人员的流失而受到影响，通常缺乏或几乎没有可用于帮助新开发人员快速上手的文档。许多第三方API由于开发人员文档的糟糕状态而难以起步或接受速度低于预期，通常由于采用者因开发人员文档的糟糕状态而感到沮丧而放弃API。
- en: 'It is always a good idea to include copyright notices at the top of each source
    code file and to comment on your namespaces, interfaces, classes, enums, structs,
    methods, and properties. Your copyright comments should be first in the source
    file, above the `using` statements and take the form of a multiline comment that
    starts with `/*` and ends with `*/`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个源代码文件的顶部包括版权声明并对您的命名空间、接口、类、枚举、结构、方法和属性进行注释始终是一个好主意。您的版权注释应该在源文件中首先出现，在`using`语句之上，并采用以`/*`开头和以`*/`结尾的多行注释形式：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code sample provides an example of a documented namespace and
    class with documented methods. You will see that the documentation comments for
    the namespace and contained members start with the documentation comment `///`
    and are directly above the item being commented on. When you type the three forward
    slashes, Visual Studio automatically generates the XML tags based on the line
    below.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码示例提供了一个带有文档化的命名空间和类以及文档化方法的示例。您将看到命名空间和包含的成员的文档注释以`///`开头，并直接位于被评论的项目上方。当您键入三个正斜杠时，Visual
    Studio会根据下面的行自动生成XML标签。
- en: For example, in the preceding code, the namespace only has a summary and so
    does the class, but both methods contain a summary, a couple of parameter comments,
    and a return comment.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面的代码中，命名空间只有一个摘要，类也是如此，但两个方法都包含一个摘要，一些参数注释和一个返回注释。
- en: The following table contains the different XML tags that you can use in your
    documentation comments.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下表包含了您可以在文档注释中使用的不同XML标签。
- en: '| **Tag** | **Section** | **Purpose** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '**标签** | **部分** | **目的** |'
- en: '| `<c>` | `<c>` | Formats text as code |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '`<c>` | `<c>` | 将文本格式化为代码 |'
- en: '| `<code>` | `<code>` | Provides source code as output |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '`<code>` | `<code>` | 作为输出提供源代码 |'
- en: '| `<example>` | `<example>` | Provides an example |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '`<example>` | `<example>` | 提供示例 |'
- en: '| `<exception>` | `<exception>` | Describes the exceptions that can be thrown
    by the method |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '`<exception>` | `<exception>` | 描述方法可能抛出的异常 |'
- en: '| `<include>` | `<include>` | Includes XML from an external file |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '`<include>` | `<include>` | 包含来自外部文件的XML |'
- en: '| `<list>` | `<list>` | Adds a list or table |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '`<list>` | `<list>` | 添加列表或表格 |'
- en: '| `<para>` | `<para>` | Adds structure to text |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `<para>` | `<para>` | 为文本添加结构 |'
- en: '| `<param>` | `<param>` | Describes the parameter of a constructor or method
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `<param>` | `<param>` | 描述构造函数或方法的参数 |'
- en: '| `<paramref>` | `<paramref>` | Tags a word to identify it is a parameter |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `<paramref>` | `<paramref>` | 标记一个词以识别它是一个参数 |'
- en: '| `<permission>` | `<permission>` | Describes the security accessibility of
    the member |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `<permission>` | `<permission>` | 描述成员的安全可访问性 |'
- en: '| `<remarks>` | `<remarks>` | Provides additional information |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `<remarks>` | `<remarks>` | 提供额外信息 |'
- en: '| `<returns>` | `<returns>` | Describes the return type |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `<returns>` | `<returns>` | 描述返回类型 |'
- en: '| `<see>` | `<see>` | Adds a hyperlink |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `<see>` | `<see>` | 添加超链接 |'
- en: '| `<seealso>` | `<seealso>` | Adds a *see also* entry |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `<seealso>` | `<seealso>` | 添加一个*参见*条目 |'
- en: '| `<summary>` | `<summary>` | Summarizes the type or member |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `<summary>` | `<summary>` | 总结类型或成员 |'
- en: '| `<value>` | `<value>` | Describes the value |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `<value>` | `<value>` | 描述值 |'
- en: '| `<typeparam>` |  | Describes the type parameter |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `<typeparam>` |  | 描述类型参数 |'
- en: '| `<typeparamref>` |  | Tags a word to identify it as a type parameter |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `<typeparamref>` |  | 标记一个词以识别它是一个类型参数 |'
- en: From the preceding table, it is clear that you have plenty of scope for documenting
    your source code. So it is a good idea to make the best use of the available tags
    to document your code. The better the documentation, the quicker and easier it
    will be for other developers to get up to speed with using the code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从上表可以清楚地看出，您有很多空间来记录您的源代码。因此，充分利用可用的标签来记录您的代码是一个好主意。文档越好，其他开发人员就能更快更容易地掌握使用代码。
- en: It is now time to look at cohesion and coupling.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看内聚性和耦合性了。
- en: Cohesion and coupling
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内聚性和耦合性
- en: In a well-designed C# assembly, code will be correctly grouped together. This
    is known as **high cohesion**. **Low cohesion** is when you have code grouped
    together that does not belong together.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计良好的C#程序集中，代码将被正确地分组在一起。这就是**高内聚性**。**低内聚性**是指将不相关的代码分组在一起。
- en: You want related classes to be as independent as possible. The more dependent
    one class is on another class, the higher the coupling. This is known as **tight
    coupling**. The more independent classes are of one another, the lower the cohesion.
    This is known as low cohesion.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望相关的类尽可能独立。一个类对另一个类的依赖性越高，耦合性就越高。这就是**紧密耦合**。类之间相互独立程度越高，内聚性就越低。这就是低内聚。
- en: So, in a well-defined class, you want high cohesion and low coupling. We'll
    now look at examples of tight coupling followed by low coupling.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在一个定义良好的类中，您希望有高内聚性和低耦合性。我们现在将看一些紧密耦合的例子，然后是低耦合。
- en: An example of tight coupling
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 紧密耦合的例子
- en: 'In the following code example, the `TightCouplingA` class breaks encapsulation
    and makes the `_name` variable directly accessible. The `_name` variable should
    be private and modified only by the properties of methods within its enclosing
    class. The `Name` property provides `get` and `set` methods to validate the `_name`
    variable, but this is pretty pointless as those checks can be bypassed and the
    properties not called:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中，`TightCouplingA`类打破了封装性，并直接访问了`_name`变量。`_name`变量应该是私有的，并且只能由其封闭类中的属性或方法修改。`Name`属性提供了`get`和`set`方法来验证`_name`变量，但这是毫无意义的，因为这些检查可以被绕过，属性也不会被调用：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On the other hand, in the following code, the `TightCouplingB` class creates
    an instance of `TightCouplingA`. It then introduces tight coupling between the
    two classes by directly accessing the `_name` member variable and setting it to
    `null`, and then directly accessing to print its value to the debug output window:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在下面的代码中，`TightCouplingB`类创建了`TightCouplingA`的一个实例。然后，它通过直接访问`_name`成员变量并将其设置为`null`，然后直接访问并将其值打印到调试输出窗口，直接在这两个类之间引入了紧密耦合：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now let's look at the same simple example using a low coupling.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下使用低耦合的相同简单示例。
- en: An example of low coupling
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 低耦合的例子
- en: In this example, we have two classes, `LooseCouplingA` and `LooseCouplingB`.
    `LooseCouplingA` declares a private instance variable named `_name`, and this
    variable is set via a public property.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有两个类，`LooseCouplingA`和`LooseCouplingB`。`LooseCouplingA`声明了一个名为`_name`的私有实例变量，并通过一个公共属性设置这个变量。
- en: '`LooseCouplingB` creates an instance of `LooseCouplingA` and gets and sets
    the value of `Name`. Because the `_name` data member cannot be set directly, the
    checks on setting and getting the value of that data member are performed.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`LooseCouplingB`创建了`LooseCouplingA`的一个实例，并获取和设置`Name`的值。因为无法直接设置`_name`数据成员，所以对该数据成员的设置和获取值的检查是通过属性进行的。'
- en: 'And so we have an example of loose coupling. Let''s have a look at the two
    classes called `LooseCouplingA` and `LooseCouplingB` that show this in action:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个松散耦合的例子。让我们看一下名为`LooseCouplingA`和`LooseCouplingB`的两个类，展示了这一点：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `LooseCouplingA` class, we declare the `_name` field as private and
    so prevent the data from being directly modified. The `_name` data is made indirectly
    accessible by the `Name` property:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LooseCouplingA`类中，我们将`_name`字段声明为私有，因此阻止直接修改数据。`_name`数据通过`Name`属性间接访问：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `LooseCouplingB` class is unable to directly access the `_name` variable
    of the `LooseCouplingB` class, and so modifies the data member via a property.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`LooseCouplingB`类无法直接访问`LooseCouplingB`类的`_name`变量，因此通过属性修改数据成员。'
- en: Well, we've looked at coupling and now know how to avoid tightly coupled code
    and implement loosely coupled code. So now, it is time for us to look at some
    examples of low cohesion and high cohesion.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们已经看过耦合性，现在知道如何避免紧密耦合的代码并实现松散耦合的代码。所以现在，是时候让我们看一些低内聚性和高内聚性的例子了。
- en: An example of low cohesion
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 低内聚性的例子
- en: 'When a class has more than one responsibility, it is said to be a low cohesive
    class. Have a look at the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类具有多个职责时，就说它是一个低内聚的类。看一下下面的代码：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we can see, the preceding class has at least three responsibilities:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，前面的类至少有三个职责：
- en: Connecting to and disconnecting from a data source
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting data and transforming it ready for report insertion
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a report and printing it out
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will see clearly how this breaks the SRP. Next, we will break this class
    down into three classes that adhere to the SRP.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: An example of high cohesion
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we are going to break down the `LowCohesion` class into three
    classes that obey the SRP. These will be called `Connection`, `DataProcessor`,
    and `ReportGenerator`. Let's see how much cleaner the code is after we implement
    the three classes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following class, you can see that the only methods in that class are
    related to connecting to a data source:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The class itself is named `Connection`, so this is an example of a high cohesive
    class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, the `DataProcessor` class contains two methods that
    process data by extracting data from the data source and transforming that data
    for insertion into the report:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So this is another example of a highly cohesive class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, the `ReportGenerator` class only has methods associated
    with generating and outputting the report:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Again, this is another example of a highly cohesive class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Looking at each of the three classes, we can see that they contain only methods
    that pertain to their single responsibility. And so each of the three preceding
    classes is highly cohesive.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: It is now time to look at how we design our code for change by using interfaces
    in place of classes so that code can be injected into constructors and methods
    using dependency injection and inversion of control.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Design for change
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When designing for change, you should change the *what* to the *how*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The *what* is the requirement of the business. As any seasoned person involved
    in a role within software development will tell you that requirements frequently
    change. As such, the software has to be adaptable to meet those changes. The business
    is not interested in *how* the requirements are implemented by the software and
    infrastructure teams, only that the requirements are met precisely on time and
    on budget.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the software and infrastructure teams are more focused on
    *how* those business requirements are to be met. Regardless of the technology
    and processes that are adopted for the project to implement the requirements,
    the software and target environment must be adaptable to changing requirements.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: But that is not all. You see, software versions often change with bug fixes
    and new features. As new features are implemented and refactoring takes place,
    the software code becomes deprecated and eventually obsolete. On top of that,
    software vendors have a road map of their software that forms part of their application
    life cycle management. Eventually, software versions get to the point where they
    are retired and no longer supported by the vendor. This can force a major migration
    from the current version, which will no longer be supported, to the new supported
    version, and this can bring with it breaking changes that must be addressed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Interface-oriented programming
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Interface-Oriented Programming** (**IOP**) helps us to program polymorphic
    code. Polymorphism in OOP is defined as different classes having their own implementations
    of the same interface. And so, by using interfaces, we can morph our software
    to meet the needs of the business.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a database connection example. An application may be required
    to connect to different data sources. But how can the database code remain the
    same no matter what database is employed? Well, the answer lies in the use of
    interfaces.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: You have different database connection classes that implement the same database
    connection interface, but they each have their own versions of the implemented
    methods. This is known as polymorphism. The database then accepts a database connection
    parameter that is of the database connection interface type. You can then pass
    into the database any database connection type that implements the database connection
    interface. Let's code this example so that it makes things a little more clear.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你有不同的数据库连接类，它们实现了相同的数据库连接接口，但它们各自有自己版本的实现方法。这就是多态。然后数据库接受一个数据库连接参数，该参数是数据库连接接口类型。然后你可以将任何实现数据库连接接口的数据库连接类型传递给数据库。让我们编写这个示例，以便更清楚地说明这些事情。
- en: 'Start by creating a simple .NET Framework console application. Then update
    the `Program` class as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个简单的.NET Framework控制台应用程序。然后按照以下方式更新`Program`类：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this code, the `Main()` method creates a new instance of the `Program` class
    and then calls the `InterfaceOrientedProgrammingExample()` method. In that method,
    we instantiate two different database connections, one for MongoDB and one for
    SQL Server. We then instantiate the database with a MongoDB connection, open the
    database connection, and then close it. Then we instantiate a new database using
    the same variable and pass in a SQL Server connection, then open the connection
    and close the connection. As you can see, we only have one `Database` class with
    a single constructor, yet the `Database` class will work with any database connection
    that implements the required interface. So, let''s add the `IConnection` interface:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`Main()`方法创建了`Program`类的一个新实例，然后调用了`InterfaceOrientedProgrammingExample()`方法。在该方法中，我们实例化了两个不同的数据库连接，一个是MongoDB，一个是SQL
    Server。然后我们使用MongoDB连接实例化数据库，打开数据库连接，然后关闭它。然后我们使用相同的变量实例化一个新的数据库，并传入一个SQL Server连接，然后打开连接并关闭连接。正如你所看到的，我们只有一个`Database`类和一个构造函数，但`Database`类可以与实现所需接口的任何数据库连接一起工作。因此，让我们添加`IConnection`接口：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The interface has only two methods called `Open()` and `Close()`. Add the MongoDB
    class that will implement this interface:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口只有两个名为`Open()`和`Close()`的方法。添加实现该接口的MongoDB类：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can see that the class implements the `IConnection` interface. Each method
    prints out a message to the console. Now add that `SQLServerConnection` class:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到该类实现了`IConnection`接口。每个方法都会在控制台打印一条消息。现在添加`SQLServerConnection`类：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The same goes for the `Database` class. It implements the `IConnection` interface,
    and for each method invocation, a message is printed to the console. And now for
    the `Database` class, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Database`类也是一样。它实现了`IConnection`接口，对于每个方法调用，都会在控制台打印一条消息。现在来看`Database`类，如下所示：'
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `Database` class accepts an `IConnection` parameter. This sets the `_connection`
    member variable. The `OpenConnection()` method opens the database connection,
    and the `CloseConnection()` method closes the database connection. Well, it''s
    time to run the program. You should see the following output in the console window:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Database`类接受一个`IConnection`参数。这设置了`_connection`成员变量。`OpenConnection()`方法打开数据库连接，`CloseConnection()`方法关闭数据库连接。现在是运行程序的时候了。你应该在控制台窗口中看到以下输出：'
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So now, you can see the advantage of programming to interfaces. You can see
    how they enable us to extend the program without having to modify the existing
    code. That means that if we need to support more databases, then all we have to
    do is write more connection objects that implement the `IConnection` interface.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到编程接口的优势。你可以看到它们如何使我们能够扩展程序，而无需修改现有的代码。这意味着如果我们需要支持更多的数据库，那么我们只需要编写更多实现`IConnection`接口的连接对象。
- en: Now that you know how interfaces work, we can look at how to apply them to dependency
    injection and inversion of control. Dependency injection helps us to write clean
    code that is loosely coupled and easy to test, and inversion of control enables
    the interchanging of software implementations as required, as long as those implementations
    implement the same interface.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了接口的工作原理，我们可以看看如何将它们应用到依赖注入和控制反转中。依赖注入帮助我们编写干净的、松耦合且易于测试的代码，而控制反转使得根据需要可以互换软件实现，只要这些实现实现了相同的接口。
- en: Dependency injection and inversion of control
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入和控制反转
- en: In C#, we have the ability to address changing software needs using **Dependency
    Injection** (**DI**) and **Inversion of Control** (**IoC**). These two terms do
    have different meanings but are often used interchangeably to mean the same thing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，我们有能力使用**依赖注入**（**DI**）和**控制反转**（**IoC**）来应对不断变化的软件需求。这两个术语确实有不同的含义，但通常可以互换使用来表示相同的事物。
- en: With IoC, you program a framework that accomplishes tasks by calling modules.
    An IoC container is used to keep a register of modules. These modules are loaded
    when requested by the user or configuration requests them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IoC，你可以编写一个通过调用模块来完成任务的框架。IoC容器用于保持模块的注册。这些模块在用户请求或配置请求它们时加载。
- en: DI removes internal dependencies from classes. Dependent objects are then injected
    by an external caller. An IoC container uses DI to inject dependent objects into
    an object or method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: DI将类的内部依赖项移除。依赖对象然后由外部调用者注入。IoC容器使用DI将依赖对象注入到对象或方法中。
- en: In this chapter, you will find some useful resources that will help you to understand
    IoC and DI. You will then be able to use these techniques in your programs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将找到一些有用的资源，这些资源将帮助你理解IoC和DI。然后你将能够在你的程序中使用这些技术。
- en: Let's see how we can implement our own simple DI and IoC without any third-party
    frameworks.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在没有任何第三方框架的情况下实现我们自己的简单DI和IoC。
- en: An example of DI
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入的示例
- en: In this example, we are going to roll our own simple DI. We will have an `ILogger`
    interface that will have a single method with a string parameter. We will then
    produce a class called `TextFileLogger` that implements the `ILogger` interface
    and outputs a string to a text file. Finally, we will have a `Worker` class that
    will demonstrate constructor injection and method injection. Let's look at the
    code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将自己编写一个简单的DI。我们将有一个`ILogger`接口，它将有一个带有字符串参数的单一方法。然后，我们将产生一个名为`TextFileLogger`的类，它实现了`ILogger`接口，并将一个字符串输出到文本文件。最后，我们将有一个`Worker`类，它将演示构造函数注入和方法注入。让我们看看代码。
- en: 'The following interface has a single method that will be used for implementing
    classes to output a message according to the implementation of the method:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下接口有一个方法，将用于实现类根据方法的实现输出消息：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `TexFileLogger` class implements the `ILogger` interface and outputs the
    message to a text file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`TexFileLogger`类实现了`ILogger`接口，并将消息输出到文本文件：'
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `Worker` class provides an example of constructor DI and method DI. Notice
    that the parameter is an interface. So, any class that implements that interface
    can be injected at runtime:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Worker`类提供了构造函数DI和方法DI的示例。请注意参数是一个接口。因此，任何实现该接口的类都可以在运行时注入：'
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `DependencyInject` method runs the example to show DI in action:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`DependencyInject`方法运行示例以展示DI的工作原理：'
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see with the code we've just looked at, we start by producing a new
    instance of the `TextFileLogger` class. This object is then injected into the
    constructor of the worker. We then call the `DoSomeWork` method and pass in the `TextFileLogger` instance.
    In this simple example, we have seen how to inject code into a class via its constructor
    and via methods.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在刚才看到的代码中所看到的，我们首先生成了`TextFileLogger`类的一个新实例。然后将这个对象注入到工作者的构造函数中。然后我们调用`DoSomeWork`方法并传入`TextFileLogger`实例。在这个简单的例子中，我们看到了如何通过构造函数和方法将代码注入到一个类中。
- en: What is good about this code is it removes the dependency between the worker
    and the `TextFileLogger` instance. This makes it easy for us to replace the `TextFileLogger` instance
    with any other type of logger that implements the `ILogger` interface. So we could
    have used, for example, an event viewer logger or even a database logger. Using
    DI is a good way to reduce coupling in your code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的好处在于它消除了工作者和`TextFileLogger`实例之间的依赖关系。这使得我们可以很容易地用实现`ILogger`接口的任何其他类型的记录器替换`TextFileLogger`实例。因此，我们可以使用，例如，事件查看器记录器或甚至数据库记录器。使用DI是减少代码耦合的好方法。
- en: Now that we've seen DI at work, we should also look at IoC. And we'll do that
    now.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了DI的工作，我们也应该看看IoC。我们现在就来看看。
- en: An example of IoC
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IoC的一个例子
- en: In this example, we are going to register dependencies with an IoC container.
    We will then use DI to inject the necessary dependencies.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用IoC容器注册依赖项。然后我们将使用DI来注入必要的依赖项。
- en: 'In the following code, we have an IoC container. The container registers the
    dependencies to be injected in a dictionary, and reads values from the configuration
    metadata:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们有一个IoC容器。容器将依赖项注册到字典中，并从配置元数据中读取值：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we create a container, and we use the container to configure metadata,
    register types, and create instances of dependencies:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个容器，并使用容器来配置元数据，注册类型，并创建依赖项的实例：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next up, we will look at how to limit an object's knowledge to knowing only
    about its close relatives using the Law of Demeter. This will help us to write
    a clean C# code that avoids the use of navigation trains.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何使用迪米特法则将对象的知识限制在只知道它的近亲。这将帮助我们编写一个干净的C#代码，避免使用导航列车。
- en: The Law of Demeter
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迪米特法则
- en: The Law of Demeter aims to remove navigation trains (dot counting), and it also
    aims to provide good encapsulation with loosely coupled code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 迪米特法则旨在消除导航列车（点计数），并且还旨在提供松散耦合的良好封装代码。
- en: 'A method that understands a navigation train breaks the Law of Demeter. For
    example, have a look at the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 理解导航列车的方法违反了迪米特法则。例如，看一下下面的代码：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Each unit of code should have a limited amount of knowledge. That knowledge
    should only be of relevant code that is closely related. With the Law of Demeter,
    you must tell and not ask. Using this law, you may only call methods of objects
    that are one or more of the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的每个单元应该具有有限的知识量。这些知识应该只涉及相关的代码。根据迪米特法则，你必须告诉而不是询问。使用这个法则，你只能调用一个或多个以下对象的方法：
- en: Passed as arguments
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为参数传递
- en: Created locally
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地创建
- en: Instance variables
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例变量
- en: Globals
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量
- en: Implementing the Law of Demeter can be difficult, but there are advantages to
    telling rather than asking. One such benefit is the decoupling of your code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 实施迪米特法则可能很困难，但告诉而不是询问有其优势。这样做的一个好处是解耦你的代码。
- en: It is good to see a bad example that breaks the Law of Demeter, along with one
    that obeys the Law of Demeter, so we will see this in the following sections.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 看到违反迪米特法则的坏例子以及遵守迪米特法则的例子是很好的，所以我们将在接下来的部分中看到这一点。
- en: A good and a bad example (chaining) of the Law of Demeter
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迪米特法则的好例子和坏例子（链接）
- en: In the good example, we have the report instance variable. On the report variable
    object instance, the method to open the connection is called. This does not break
    the law.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在好的例子中，我们有报告的实例变量。在报告变量对象实例上，调用了打开连接的方法。这不违反法律。
- en: 'The following code is a `Connection` class with a method that opens a connection:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个`Connection`类，其中有一个打开连接的方法：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `Database` class creates a new `Connection` object and opens a connection:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Database`类创建一个新的`Connection`对象并打开连接：'
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `Report` class, a `Database` object is instantiated and then a connection
    to the database is opened:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Report`类中，实例化了一个`Database`对象，然后打开了与数据库的连接：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: So far, we have seen good code that obeys the Law of Demeter. But the following
    is code that breaks this law.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了遵守迪米特法则的好代码。但以下是违反这一法则的代码。
- en: 'In the `Example` class, the Law of Demeter is broken because we introduce method
    chaining, as in `report.Database.Connection.Open()`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Example`类中，迪米特法则被打破，因为我们引入了方法链，如`report.Database.Connection.Open()`：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this bad example, the `Database` getter is called on the report instance
    variable. This is acceptable. But then a call is made to the `Connection` getter
    that returns a different object. This breaks the Law of Demeter, as does the final
    call to open the connection.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个糟糕的例子中，对报告实例变量调用了`Database` getter。这是可以接受的。但然后调用了返回不同对象的`Connection` getter。这违反了迪米特法则，最后调用打开连接也是如此。
- en: Immutable objects and data structures
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变对象和数据结构
- en: Immutable types are normally thought of as just value types. With value types,
    it makes sense that when they are set, you don't want them to change. But you
    can also have immutable object types and immutable data structure types. Immutable
    types are a type whose internal state does not change once they have been initialized.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变类型通常被认为只是值类型。对于值类型，当它们被设置时，不希望它们发生变化是有道理的。但是您也可以有不可变对象类型和不可变数据结构类型。不可变类型是一种在初始化后其内部状态不会改变的类型。
- en: The behavior of immutable types does not astonish or surprise fellow programmers
    and so conforms to the **principle of least astonishment** (**POLA**). The POLA
    conformity of immutable types adheres to any contracts made between clients, and
    because it is predictable, programmers will find it easy to reason about its behavior.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变类型的行为不会使其他程序员感到惊讶，因此符合**最小惊讶原则**（**POLA**）。不可变类型的POLA符合度遵守与客户之间达成的任何合同，并且因为它是可预测的，程序员会发现很容易推断其行为。
- en: Since immutable types are predictable and do not change, you are not going to
    be in for any nasty surprises. So you don't have to worry about any undesirable
    effects due to them being altered in some way. This makes immutable types ideal
    for sharing between threads as they are thread-safe and there is no need for defensive
    programming.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不可变类型是可预测且不会改变，您不会遇到任何令人不快的惊喜。因此，您不必担心由于以某种方式被更改而导致的任何不良影响。这使得不可变类型非常适合在线程之间共享，因为它们是线程安全的，无需进行防御性编程。
- en: When you create an immutable type and use object validation, you have a valid
    object for the lifetime of that object.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一个不可变类型并使用对象验证时，您将获得一个在该对象的生命周期内有效的对象。
- en: Let's have a look at an example of an immutable type in C#.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个C#中不可变类型的例子。
- en: An example of an immutable type
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变类型的例子
- en: 'We are now going to look at an immutable object. The `Person` object in the
    following code has three private member variables. The only time these can be
    set is during the creation time in the constructor. Once set, they are unable
    to be modified for the rest of the object''s lifetime. Each variable is only readable
    via read-only properties:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一个不可变对象。以下代码中的`Person`对象有三个私有成员变量。这些变量只能在构造函数中设置。一旦设置，它们在对象的其余生命周期内将无法修改。每个变量只能通过只读属性进行读取：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now we have seen how easy it is to write immutable objects and data structures,
    we will look at data and methods in objects.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到编写不可变对象和数据结构有多么容易，我们将看看对象中的数据和方法。
- en: Objects should hide data and expose methods
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象应该隐藏数据并公开方法
- en: The state of your object is stored in member variables. These member variables
    are data. Data should not be directly accessible. You should only provide access
    to data via exposed methods and properties.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的状态存储在成员变量中。这些成员变量是数据。数据不应直接可访问。您应该只通过公开的方法和属性提供对数据的访问。
- en: Why should you hide your data and expose your methods?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要隐藏数据并公开方法？
- en: Hiding data and exposing methods is known in the OOP world as encapsulation.
    Encapsulation hides the inner workings of a class from the outside world. This
    makes it easy to be able to change value types without breaking existing implementations
    that rely on the class. Data can be made read/writable, writable, or read-only
    providing more flexibility to you regarding data access and usage. You can also
    validate input and so prevent data from receiving invalid values. Encapsulating
    also makes testing your classes much easier, and you can make your classes more
    reusable and extendable.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏数据并公开方法在面向对象编程世界中被称为封装。封装将类的内部工作隐藏在外部世界之外。这使得更改值类型而不破坏依赖于该类的现有实现变得容易。数据可以被设置为可读/可写、可写或只读，这样可以更灵活地访问和使用数据。您还可以验证输入，从而防止数据接收无效值。封装还使得测试类变得更容易，并且可以使类更具可重用性和可扩展性。
- en: Let's look at an example.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。
- en: An example of encapsulation
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装的例子
- en: 'The following code example shows an encapsulated class. The `Car` object is
    mutable. It has properties that get and set the data values once they have been
    initialized by the constructor. The constructor and the set properties perform
    the validation of the parameter arguments. If the value is invalid, an invalid
    argument exception is thrown, otherwise the value is passed back and the data
    value is set:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例显示了一个封装的类。`Car`对象是可变的。它具有在构造函数初始化后获取和设置数据值的属性。构造函数和设置属性执行参数的验证。如果值无效，则抛出无效参数异常，否则将传回值并设置数据值：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The benefit of the preceding code is that if you need to change the validation
    for the code that gets or sets the data values, you can do so without breaking
    the implementation.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的好处是，如果您需要更改获取或设置数据值的代码的验证，您可以这样做而不会破坏实现。
- en: Data structures should expose data and have no methods
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构应该公开数据并且没有方法
- en: Structures differ from classes in that they use value equality in place of reference
    equality. Other than that, there is not much difference between a struct and a
    class.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 结构与类的不同之处在于它们使用值相等而不是引用相等。除此之外，结构和类之间没有太大的区别。
- en: There is a debate as to whether a data structure should make the variables public
    or hide them behind get and set properties. It is purely down to you which you
    choose, but personally I always think it best to hide data even in structs and
    only provide access via properties and methods. There is one caveat in terms of
    having clean data structures that are safe, and that is that once created, structs
    should not allow themselves to be mutated by methods and get properties. The reason
    for this is that changes to temporary data structures will be discarded.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at a simple data structure example.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: An example of data structure
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code is a simple data structure:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, the data structure is not that much different from a class in
    that it has a constructor and properties.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: With this, we come to the end of the chapter and will now review what we've
    learned.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about organizing our namespaces in folders and packages,
    and how good organization can help to prevent namespace classes. We then moved
    on to classes and responsibility and looked at why classes should only have one
    responsibility. We also looked at cohesion and coupling and why it is important
    to have high cohesion and low coupling.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Good documentation requires public members to be correctly commented on in documentation
    tools, and we saw how to do this using XML comments. The importance of why you
    should design for change was also discussed with basic examples of DI and IoC.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The Law of Demeter showed you how to not to talk to strangers, but only immediate
    friends, and how to avoid chaining. And finally, we looked at objects and data
    structures and what they should hide and what they should make public.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will briefly cover functional programming in C# and
    how to write clean methods that are small. We will also learn to avoid having
    more than two parameters in our methods, as methods with many parameters can become
    unwieldy. Plus we will learn to avoid duplication which can be a troublesome source
    of bugs when fixed in one location, but still exist elsewhere in your code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we organize our classes in C#?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many responsibilities should a class have?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you comment on your code for document generators?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does cohesion mean?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does coupling mean?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should cohesion be high or low?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should coupling be tight or loose?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What mechanisms are available that help you design for change?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is DI?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is IoC?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name one benefit of using immutable objects.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What should objects hide and show?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What should structures hide and show?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more detail in regard to understanding the different kinds of cohesion and
    coupling, check out [https://www.geeksforgeeks.org/software-engineering-coupling-and-cohesion/](https://www.geeksforgeeks.org/software-engineering-coupling-and-cohesion/).
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Many tutorials on IoC can be found at](https://www.tutorialsteacher.com/ioc/)
    [https://www.tutorialsteacher.com/ioc/](https://www.tutorialsteacher.com/ioc/)[. ](https://www.tutorialsteacher.com/ioc/)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

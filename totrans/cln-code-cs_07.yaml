- en: End-to-End System Testing
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端系统测试
- en: '**End-to-end** (**E2E**) system testing is the automated testing of a system
    in its entirety. As a programmer, the unit tests for your piece of code are just
    a small factor in the bigger picture of the whole system. So in this chapter,
    we will be looking at the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端（E2E）系统测试是对整个系统进行自动化测试。作为程序员，您的代码单元测试只是整个系统的一个小因素。因此，在本章中，我们将讨论以下主题：
- en: Performing E2E testing
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行端到端测试
- en: Coding and testing factories
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码和测试工厂
- en: Coding and testing dependency injection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码和测试依赖注入
- en: Testing modularization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试模块化
- en: 'By the end of this chapter, you will have gained the following skills:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将获得以下技能：
- en: Be able to define E2E testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够定义端到端测试
- en: Be able to perform E2E testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够执行端到端测试
- en: Be able to explain what factories are and how to use them
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够解释工厂是什么，以及如何使用它们
- en: Be able to understand what dependency injection is and how to use it
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够理解依赖注入是什么，以及如何使用它
- en: Be able to understand what modularization is and how to utilize it
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够理解模块化是什么，以及如何利用它
- en: E2E testing
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端测试
- en: So, you've finished your project and all the unit tests pass. However, your
    project is a part of a larger system. This larger system will need to be tested
    to make sure that your code, and the other code it interfaces with, both work
    together as expected. Code tested in isolation can break when integrated into
    larger systems, and existing systems can break with the addition of new code,
    so it is important to perform E2E testing, also known as **integration testing**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您已经完成了项目，所有单元测试都通过了。但是，您的项目是更大系统的一部分。需要测试更大的系统，以确保您的代码以及其接口的其他代码都按预期工作。在隔离测试的代码集成到更大的系统时，可能会出现故障，并且在添加新代码时可能会破坏现有系统，因此执行端到端测试（也称为集成测试）非常重要。
- en: 'Integration testing is responsible for testing the complete program flow from
    beginning to end. Integration testing usually starts at the *requirements gathering
    stage*. You start by gathering and documenting the various requirements of the
    system. You then design all the components and devise tests for each subsystem,
    and then the E2E tests for the whole system. Then, you write your code according
    to the requirements and implement your own unit tests. Once your code is complete
    and the tests all pass, then the code is integrated into the overall system within
    the test environment and the E2E tests are executed. Often, E2E tests are carried
    out manually, although where possible, they can be automated as well. The following
    diagram shows a system that comprises two subsystems with modules and a database.
    In E2E testing, all these modules will be tested either manually, using automation,
    or by both methods:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试负责测试从头到尾的完整程序流程。集成测试通常从“需求收集阶段”开始。您首先收集和记录系统的各种需求。然后设计所有组件并为每个子系统设计测试，然后为整个系统设计端到端测试。然后，根据要求编写代码并实施自己的单元测试。一旦代码完成并且所有测试都通过，代码就会在测试环境中集成到整个系统中，并执行端到端测试。通常，端到端测试是手动进行的，尽管在可能的情况下，它们也可以自动化。以下图表显示了一个包含两个子系统和数据库的系统。在端到端测试中，所有这些模块都将进行手动测试，使用自动化测试，或两种方法都使用：
- en: '![](img/226c6b2d-d997-46de-af9f-aeee7cfe2acb.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/226c6b2d-d997-46de-af9f-aeee7cfe2acb.png)'
- en: The input to and output from each system are the main focus of the tests. You
    have to ask yourself, *is the correct information passed in and passed out of
    each system?*
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系统的输入和输出是测试的主要焦点。您必须问自己，“每个系统是否传递了正确的信息？”
- en: 'Additionally, there are three things to consider when building your E2E tests:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在构建端到端测试时有三件事需要考虑：
- en: What *user functions* will there be, and what steps will each function perform?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会有哪些“用户功能”，每个功能将执行哪些步骤？
- en: What *conditions* will there be for each function and each of its steps?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个功能及其各个步骤将有什么“条件”？
- en: What are the *different scenarios* that we will have to build test cases for?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将为哪些“不同的场景”构建测试用例？
- en: Each subsystem will have one or more features that it will provide, and each
    feature will have a number of actions that will be executed in a particular order.
    Those actions will receive inputs and provide outputs. There will also be relationships
    between features and functions that you must identify, after which you will need
    to determine whether the function is *reusable* or *independent*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子系统将提供一个或多个功能，并且每个功能将按特定顺序执行多个操作。这些操作将接收输入并提供输出。您还必须确定功能和函数之间的关系，然后确定函数是“可重用”还是“独立”的。
- en: 'Consider the scenario of an online testing product. Teachers and students will
    log in to the system. If the teacher logs in, they will be taken to an admin console,
    and if a student logs in, they will be taken to the test menu to carry out one
    or more tests. In this scenario, we effectively have three subsystems:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在线测试产品的场景。老师和学生将登录系统。如果老师登录，他们将进入管理控制台，如果学生登录，他们将进入测试菜单进行一个或多个测试。在这种情况下，我们实际上有三个子系统：
- en: The login system
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录系统
- en: The admin system
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理系统
- en: The test system
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试系统
- en: There are two flows of execution in the aforementioned system. We have the admin
    flow and the test flow. Conditions and test cases will have to be established
    for each flow. We will use this very simple assessment system login scenario for
    our E2E example. In the real world, E2E will be more involved than in this chapter.
    The main aim of this chapter is to get you thinking about E2E testing and how
    you can best implement it, so we will keep things as simple as we can so that
    complexity does not get in the way of what we are trying to accomplish, which
    is to manually test three modules that must interact with each other.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'The aim of this section is to build three console applications that make up
    the complete system: the login module, the admin module, and the test module.
    Then once they are built, we will go through testing them manually. The diagram
    that follows displays the interaction between systems. We will start with the
    login module:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e8a30cd-7ce6-4185-a12d-fb8567a02fa6.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: The login module (subsystem)
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first part of our system requires both teachers and students to log in
    to the system using a username and password. The task list is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Enter the username.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the password.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press Cancel (this resets username and password).
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press OK.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the username is invalid, then display an error message on the login page.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the user is valid, then do the following:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user is a teacher, load the admin console.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user is a student, load the test console.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by creating a console application. Call it `CH07_Logon`. In the
    `Program.cs` class, replace the existing code with the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `DoLogin()` method will take the passed-in string and use it for the title.
    Since we will not have logged in yet, the title will be set to `"Welcome to the
    test platform"`. We need to add the `DoLogin()` method. The code for this method
    is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The previous code accepts a message. The message is used as the title in the
    console window. The user is then prompted to enter their username and password.
    The `ReadPassword()` method reads all inputs and replaces filtered letters with
    an *asterisk* to hide the user's input. The username and password are then validated
    by calling the `ValidateUser()` method.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we must do is add the `ReadPassword()` method as in the code
    that follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This method is really simple. It calls an overloaded method of the same name
    and passes in the password mask character. Let''s implement the overloaded `ReadPassword()`
    method:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The overloaded `ReadPassword()` method accepts a password mask. This method
    adds each character to the stack. Unless the key being pressed is the *Enter*key,
    the key being pressed is checked to see if the user is performing a *Delete* keypress. If
    the user is performing a *Delete* keypress, then the last character entered is
    removed from the stack. If the character entered is not in the filtered list,
    then it is pushed onto the stack. The password mask is then written to the screen.
    As soon as the *Enter* key is pressed, a blank line is written to the console
    window, and the contents of the stack are reversed, returning it as a string.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'The final method we need to write for this subsystem is the `ValidateUser()`
    method:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `ValidateUser()` method checks the username and password. If they validate
    as an admin, then the admin page is loaded. If they validate as a student, then
    the student page is loaded. Otherwise, the console is cleared, the user is informed
    the credentials are wrong, and they are prompted to reenter their credentials.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Upon a successful login operation being performed, the relevant subsystem is
    loaded and the login subsystem then terminates. Now that we have written our login
    module, we will write our admin module.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The admin module (subsystem)
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The admin subsystem is where all the system administration is carried out.
    This includes the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Importing students
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting students
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding students
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting students
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing students' profiles
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning tests to students
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the administrator password
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backing up data
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restoring data
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Erasing all data
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing reports
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting reports
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving reports
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing reports
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging out
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this exercise, we will not be implementing any of these features. I will
    leave you to do that as a fun exercise. All we are interested in is that the admin
    module loads on a successful login. If the admin module is loaded without logging
    in, then an error message is displayed. Then when the user presses a key, they
    are taken to the login module. Successful login is accomplished when a user successfully
    logs in as an administrator, and the admin executable is called with the *admin
    argument*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a console application in Visual Studio and call it `CH07_Admin`. Update
    the `Main()` method as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Main()` method checks that the argument count is greater than `0` and
    that the first argument in the array is admin. If it is, then the main screen
    is displayed by calling the `DisplayMainScreen()` method. Otherwise, the `DisplayMainScreenError()`
    method is called that warns the user that they must log in to access the system.
    It''s time to write the `DisplayMainScreen()` method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, the `DisplayMainScreen()` method is really simple. It displays
    a title with a message to press any key to exit, then waits for a keypress. Upon
    keypress, the program shells out to the login module and exits. Now, for the `DisplayMainScreenError()`
    method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: From this method, you can see that the module was started without logging in.
    This is not permitted. So when the user presses any key, the user is redirected
    to the login module, where they can log in to use the admin module. Our final
    module is the test module. Let's get to work and write it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The test module (subsystem)
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The test system consists of a menu. This menu displays a list of tests the
    student must perform, and also provides the option to exit the test system. The
    functions of this system include the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Display a menu of tests to be completed.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the menu, select an item to start a test.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On test completion, save results and return to the menu.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a test has been completed, remove it from the menu.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user exits the test module, they are returned to the login module.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with the previous module, I will let you have a play and add the aforementioned
    functionality. The main thing we are interested in here is to make sure the test
    module can only be run when the user has logged in. When the module is exited,
    the login module is loaded.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'The test module is more or less a rehash of the admin module, so we will rush
    through this section to get to where we need to be. Update the `Main()` method
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now add the `DisplayMainScreen()` method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And finally, write the `DisplayMainScreenError()` method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we have written all three modules, we will test them in the next section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Testing our three-module system using E2E
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to perform a manual E2E test of our three-module
    system. We will test the login module to ensure that it only allows valid logins
    access to either the admin module or the test module. When a valid admin logs
    into the system, they should see the admin module, and the login module should
    be unloaded. When a valid student logs into the system, then they should see the
    test module, and the login module should be unloaded.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: If we then try and load the admin module without first logging in, we should
    be warned that we must log in. Pressing any key should unload the admin module
    and load the login module. Trying to use the test module without logging in should
    behave in the same way as the admin module. We should be warned that we can't
    use the test module unless we log in, and pressing any key should load the login
    module and unload the test module.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now go through the manual testing process:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that all the projects are built, then run the login module. You should
    see the screen that follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bf130dba-087c-448d-a344-89766b0b5d6c.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf130dba-087c-448d-a344-89766b0b5d6c.png)'
- en: 'Enter an incorrect username and/or password, then press *Enter*, and you will
    see the following screen:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入错误的用户名和/或密码，然后按*Enter*，您将看到以下屏幕：
- en: '![](img/d7bf0b1f-2f9f-47df-a707-07267376dbb6.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7bf0b1f-2f9f-47df-a707-07267376dbb6.png)'
- en: 'Now, enter `admin` as the username and `letmein` as the password, and then
    press *Enter*. You should see the admin module screen for a successful login:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入`admin`作为用户名，`letmein`作为密码，然后按*Enter*。您应该会看到成功登录的管理员模块屏幕：
- en: '![](img/b6f29856-e562-4997-a448-7302aca8bab3.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6f29856-e562-4997-a448-7302aca8bab3.png)'
- en: 'Press any key to exit, and you should see the login module again:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按任意键退出，您应该再次看到登录模块：
- en: '![](img/c9cff545-17b8-4ba7-922a-14ce7fb1556e.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9cff545-17b8-4ba7-922a-14ce7fb1556e.png)'
- en: 'Enter `student` as your username and `letmein` as your password. Press *Enter*
    and you should be shown the student module:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`student`作为用户名，`letmein`作为密码。按*Enter*，您应该会看到学生模块：
- en: '![](img/537c6f76-cbdb-43e1-b825-baa350993755.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/537c6f76-cbdb-43e1-b825-baa350993755.png)'
- en: 'Now load the admin module without logging in, and you should see the following:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在加载管理员模块而不登录，您应该会看到以下内容：
- en: '![](img/ee22f7c7-a511-4283-973e-984b4a12af8b.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee22f7c7-a511-4283-973e-984b4a12af8b.png)'
- en: 'Pressing any key will take you back to the login module. Now load the test
    module without logging in, and you should see the following:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按任意键将返回登录模块。现在加载测试模块而不登录，您应该会看到以下内容：
- en: '![](img/a98b384d-c361-4a1f-8126-c6b10e50f900.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a98b384d-c361-4a1f-8126-c6b10e50f900.png)'
- en: We have now successfully manually carried out E2E testing of our system that
    consists of three modules. This is by far the best way to run through a system
    when E2E testing. Your unit tests will be very useful in making this stage fairly
    straightforward. By the time you get to this stage, your bugs should have been
    caught and dealt with. But as always, there is always the possibility of problems
    being encountered, which is why it is good to manually run through the system
    as a whole manually. That way, you can visually see through your interactions
    that the system behaves as expected.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地手动进行了系统的端到端测试，该系统由三个模块组成。这绝对是进行端到端测试时的最佳方式。您的单元测试将非常有用，使得这个阶段相当简单。到达这个阶段时，您的错误应该已经被捕获和处理。但是，像往常一样，总会有可能遇到问题，这就是为什么手动运行整个系统是一个好主意。这样，您可以通过视觉看到您的交互，系统是否按预期行为。
- en: Larger systems employ factories and dependency injection. In the following sections
    of this chapter, we will look at them both, starting with factories.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 更大的系统使用工厂和依赖注入。在本章的后续部分，我们将分别查看它们，从工厂开始。
- en: Factories
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂
- en: Factories are implemented using the **factory method pattern**. The intent of
    this pattern is to allow the creation of objects without specifying their classes.
    This is accomplished by invoking a factory method. The main goal of a factory
    method is to create an instance of a class.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂是使用**工厂方法模式**实现的。此模式的目的是允许创建对象而不指定它们的类。这是通过调用工厂方法来实现的。工厂方法的主要目标是创建类的实例。
- en: 'You use the factory method pattern for the following scenarios:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下情况下使用工厂方法模式：
- en: When the class is unable to anticipate the type of object that must be instantiated
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当类无法预测必须实例化的对象类型
- en: When the subclass must specify the type of object to instantiate
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当子类必须指定要实例化的对象类型
- en: When the class controls the instantiation of its objects
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当类控制其对象的实例化
- en: 'Consider the following diagram:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图表：
- en: '![](img/0657bd23-9126-4d8e-8644-5c6b8442814a.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0657bd23-9126-4d8e-8644-5c6b8442814a.png)'
- en: 'As you can see from the preceding diagram, you have the following items:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，您有以下项目：
- en: '`Factory`, which provides the interface for the `FactoryMethod()` that returns
    a type'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Factory`，提供了返回类型的`FactoryMethod()`的接口'
- en: '`ConcreteFactory`, which overrides or implements the `FactoryMethod()` to return
    a concrete type'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteFactory`，覆盖或实现`FactoryMethod()`以返回具体类型'
- en: '`ConcreteObject`, which inherits or implements the base class or interface'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteObject`，继承或实现基类或接口'
- en: Now is a good time for a demonstration. Imagine that you have three different
    customers. Each customer requires using a different relational database as the
    backend data source. The databases used by your customers will be Oracle Database,
    SQL Server, and MySQL.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是进行演示的好时机。想象一下，您有三个不同的客户。每个客户都需要使用不同的关系数据库作为后端数据源。您的客户使用的数据库将是Oracle Database、SQL
    Server和MySQL。
- en: As a part of your E2E testing, you will need to test against each of these data
    sources. But how can you write the program once and have it work against any of
    those databases? This is where the `Factory` method pattern comes in.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 作为端到端测试的一部分，您将需要针对每个数据源进行测试。但是如何编写程序一次，使其适用于这些数据库中的任何一个？这就是“工厂”方法模式发挥作用的地方。
- en: Either during the installation process or via the initial configuration of your
    application, you can have the user specify the database that they wish to use
    as the data source. This information can be stored in a configuration file as
    an encrypted database connection string. When your application starts up, it will
    read the database connection string and decrypt it. The database connection string
    will then be passed into the factory method. Lastly, an appropriate database connection
    object will be selected, instantiated, and returned for use by your application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程中或通过应用程序的初始配置，用户可以指定他们希望用作数据源的数据库。这些信息可以存储在配置文件中，作为加密的数据库连接字符串。当应用程序启动时，它将读取数据库连接字符串并对其进行解密。然后将数据库连接字符串传递到工厂方法中。最后，将选择、实例化并返回适当的数据库连接对象供应用程序使用。
- en: 'Now that you have some background, let''s create a .NET Framework Console Application
    in Visual Studio and call it `CH07_Factories`. Replace the code in the `App.cong`
    file with the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了一些背景知识，让我们在Visual Studio中创建一个.NET Framework控制台应用程序，并将其命名为“CH07_Factories”。将“App.cong”文件中的代码替换为以下内容：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the preceding code has added the `connectionStrings` element
    to the configuration file. Within that element, we clear any existing connection
    strings and then add the three database connection strings we will be using for
    the application. To simplify the contents of this section, we have unencrypted
    connection strings, but in the production environment, make sure that your connection
    strings are encrypted!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，前面的代码已经在配置文件中添加了`connectionStrings`元素。在该元素中，我们清除了任何现有的连接字符串，然后添加了我们将在应用程序中使用的三个数据库连接字符串。为了简化本节的内容，我们使用了未加密的连接字符串，但在生产环境中，请确保您的连接字符串是加密的！
- en: 'In this project, we will not be using the `Main()` method in the `Program`
    class. We will start the `Factory` class, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们不会使用`Program`类中的`Main()`方法。我们将启动`Factory`类，如下所示：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code is our abstract factory with a single abstract `FactoryMethod()`
    that returns a type of `IDatabaseConnection`. Since it does not exist, we''ll
    add that next:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是我们的抽象工厂，其中有一个抽象的`FactoryMethod()`，返回一个`IDatabaseConnection`类型。由于它还不存在，我们接下来会添加它：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this interface, we have a read-only connection string, a method called `OpenConnection()`
    to open a database connection, and a method called `CloseConnection()` to close
    an open database connection. So far, we have our abstract `Factory` and our `IDatababaseConnection`
    interface. Next, we will create our concrete database connection classes. Let''s
    start with the SQL Server database connection class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个接口中，我们有一个只读的连接字符串，一个名为`OpenConnection()`的方法来打开数据库连接，以及一个名为`CloseConnection()`的方法来关闭已打开的数据库连接。到目前为止，我们有了我们的抽象`Factory`和我们的`IDatababaseConnection`接口。接下来，我们将创建我们的具体数据库连接类。让我们从SQL
    Server数据库连接类开始：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the `SqlServerDbConnection` class fully implements the `IDatabaseConnection`
    interface. The constructor takes `connectionString` as a single parameter. The
    read-only `ConnectionString` property is then assigned to `connectionString`.
    The `OpenConnection()` method only prints to the console.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`SqlServerDbConnection`类完全实现了`IDatabaseConnection`接口。构造函数以`connectionString`作为单个参数。只读的`ConnectionString`属性然后被赋值为`connectionString`。`OpenConnection()`方法只是在控制台上打印。
- en: 'In a real implementation, however, the connection string would be used to connect
    to the valid data source specified in the string. Once a database connection is
    open, it must be *closed*. The closing of the database connection would be carried
    out by the `CloseConnection()` method. Next, we repeat the preceding process for
    the Oracle database connection and the MySQL database connection:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实际实现中，连接字符串将被用于连接到字符串中指定的有效数据源。一旦数据库连接打开，就必须*关闭*。关闭数据库连接将由`CloseConnection()`方法执行。接下来，我们重复前面的过程，为Oracle数据库连接和MySQL数据库连接进行实现：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We now have the `OracleDbConnection` class in place. So, the last class we
    need to implement is the `MySqlDbConnection` class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经放置了`OracleDbConnection`类。所以，我们需要实现的最后一个类是`MySqlDbConnection`类：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With that, we have added our concrete classes. The only thing left to do is
    to create our `ConcreteFactory` class that inherits the abstract `Factory` class.
    You will need to reference the `System.Configuration.ConfigurationManager` NuGet
    packet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经添加了我们的具体类。唯一剩下的事情就是创建我们的`ConcreteFactory`类，它继承了抽象的`Factory`类。你需要引用`System.Configuration.ConfigurationManager`
    NuGet包：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see, the class uses the `System.Configuration` namespace. The `ConnectionStringSettings` values
    are stored in the `_connectionStringSettings` member variable. This is set in
    the constructor that takes `connectionStringName`. The name is passed into the
    `GetDbConnectionSettings()` method. The quick among you will see an obvious mistake
    in the constructor.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个类使用了`System.Configuration`命名空间。`ConnectionStringSettings`的值存储在`_connectionStringSettings`成员变量中。这是在接受`connectionStringName`的构造函数中设置的。名称被传递到`GetDbConnectionSettings()`方法中。敏锐的读者会发现构造函数中的一个明显错误。
- en: The method is getting called but the member variable is not being set. However,
    we will pick up this oversight and fix it when we come to run the tests that we
    have yet to write. The `GetDbConnectionSettings()` methods uses `ConfigurationManager`
    to read the required connection string from the `ConnectionStrings[]` array.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 方法被调用了，但成员变量没有被设置。然而，当我们开始运行我们尚未编写的测试时，我们将注意到这个疏忽并加以修复。`GetDbConnectionSettings()`方法使用`ConfigurationManager`从`ConnectionStrings[]`数组中读取所需的连接字符串。
- en: 'Now, it is time to complete our `ConcreteClass` by adding `FactoryMethod()`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候通过添加`FactoryMethod()`来完成我们的`ConcreteClass`了：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Our `FactoryMethod()` returns a concrete class of type `IDatabaseConnection`.
    At the start of the class, the member variable is read and the values are stored
    locally for `providerName` and `connectionString`. A switch is then used to determine
    what type of database connection to build and pass back.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`FactoryMethod()`返回一个`IDatabaseConnection`类型的具体类。在类的开头，成员变量被读取并存储在`providerName`和`connectionString`中。然后使用switch来确定要构建和传回什么类型的数据库连接。
- en: We are now in a position to test our factory to see whether it works with the
    different types of databases used by our customers. This test can be done manually,
    but for the purpose of this exercise, we are going to write automation tests.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试我们的工厂，看它是否能够处理我们客户使用的不同类型的数据库。这个测试可以手动进行，但为了这个练习的目的，我们将编写自动化测试。
- en: 'Create a new NUnit test project. Add a reference to the `CH07_Factories` project.
    Then, add the `System.Configuration.ConfigurationManager` NuGet package. Rename
    the class to `UnitTests.cs`. Now, add the first test, as shown:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的NUnit测试项目。添加对`CH07_Factories`项目的引用。然后添加`System.Configuration.ConfigurationManager`
    NuGet包。将类重命名为`UnitTests.cs`。现在，添加第一个测试，如下所示：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This test is for a SQL Server database connection. It creates a new `ConcreteFactory()` instance
    and passes in the `connectionStringName` value of `"SqlServer"`. The factory then
    instantiates and returns the correct database connection object via `FactoryMethod()`.
    Finally, the connection object is asserted to test that it is indeed an instance
    of type `SqlServerDbConnection`. We need to write the previous test twice more
    for the other database connections, so let''s now add the Oracle database connection
    test:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试是针对 SQL Server 数据库连接的。它创建了一个新的 `ConcreteFactory()` 实例，并传入了 `"SqlServer"`
    的 `connectionStringName` 值。然后工厂通过 `FactoryMethod()` 实例化并返回正确的数据库连接对象。最后，连接对象被断言以测试它确实是
    `SqlServerDbConnection` 类型的实例。我们需要再为其他数据库连接编写前面的测试两次，所以现在让我们添加 Oracle 数据库连接测试：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The test passes in the `connectionStringName` value of `"Oracle"`. An assertion
    is made to test whether the connection object returned is of type `OracleDbConnection`.
    Last of all, we have our MySQL database connection test:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通过了 `"Oracle"` 的 `connectionStringName` 值。进行了断言来测试返回的连接对象是否是 `OracleDbConnection`
    类型。最后，我们有我们的 MySQL 数据库连接测试：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The test passes in the `connectionStringName` value of `"MySQL"`. An assertion
    is made to test whether the connection object returned is of type `MySqlDbConnection`.
    If we run our tests now, they will all fail because the `_connectionStringSettings`
    variable is not getting set, so let''s fix this. Modify your `ConcreteFactory`
    constructor as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通过了 `"MySQL"` 的 `connectionStringName` 值。进行了断言来测试返回的连接对象是否是 `MySqlDbConnection`
    类型。如果我们现在运行测试，它们都会失败，因为 `_connectionStringSettings` 变量没有被设置，所以让我们来修复这个问题。修改你的
    `ConcreteFactory` 构造函数如下：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you run all your tests now, they should work. If your connection string
    is not getting picked up by NUnit, then it will be looking in a different `App.config` file
    to what you are expecting. Add the following line before the line that reads the
    connection string:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行所有的测试，它们应该可以工作。如果 NUnit 没有获取到连接字符串，那么它会在一个不同的 `App.config` 文件中查找，而不是你期望的那个。在读取连接字符串的那一行之前添加以下行：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will inform you where NUnit is looking for your connection string settings.
    If the file does not exist, you can create it manually and duplicate the contents
    from your main `App.config` file. But the problem with this is that the file will
    more than likely get deleted upon the next build. So to make the change permanent,
    you can add a post-build event command line to your test project.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉你 NUnit 正在查找你的连接字符串设置。如果文件不存在，你可以手动创建它，并从你的主 `App.config` 文件中复制内容。但这样做的问题是，该文件很可能会在下次构建时被删除。因此，为了使更改永久生效，你可以向你的测试项目添加后期构建事件命令行。
- en: 'To do this, right-click on your test project and select Properties. Then on
    the Properties tab, select Build Events. In the post-build event command line,
    add the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，右键单击你的测试项目，选择属性。然后在属性选项卡上，选择“构建事件”。在后期构建事件命令行中，添加以下命令：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following screenshot shows the Build Events page of the Project Properties
    dialog with the Post-build event command line in place:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了项目属性对话框的“构建事件”页面，其中包含了后期构建事件命令行：
- en: '![](img/aaf54bb6-5e8e-4508-97e7-7e2535671d6c.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aaf54bb6-5e8e-4508-97e7-7e2535671d6c.png)'
- en: This will create the missing file in the test project output folder. The file
    on your system may be named `testhost.x86.dll.config`, since it is on my system.
    Now, your builds should be working.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在测试项目输出文件夹中创建缺失的文件。在你的系统上，该文件可能被命名为 `testhost.x86.dll.config`，因为在我的系统上是这样的。现在，你的构建应该可以工作了。
- en: 'If you change the return type of one of the cases in `FactoryMethod()`, you
    will see that your test fails, as shown in the following screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你改变 `FactoryMethod()` 中某个 case 的返回类型，你会发现你的测试失败，如下截图所示：
- en: '![](img/566d7135-2c34-4582-be80-52b4020ca9c7.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/566d7135-2c34-4582-be80-52b4020ca9c7.png)'
- en: Change the code back to the correct type so that your code now passes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码改回正确的类型，这样你的代码现在就可以通过了。
- en: We have seen how to manually E2E test a system, along with how to employ software
    factories, and how we can automatically test whether our factories function as
    expected. Now we will look at dependency injection and how this can be E2E tested.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何手动 E2E 测试系统，以及如何使用软件工厂，并且我们如何自动测试我们的工厂是否按预期工作。现在我们将看看依赖注入以及如何进行 E2E
    测试。
- en: Dependency injection
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: '**Dependency Injection** (**DI**) helps you to produce code that is loosely
    coupled by separating the code''s behavior from its dependencies, which leads
    to more readable code that is easy to test, extend, and maintain. Code is more
    readable because you follow the single responsibility principle. This also leads
    to much smaller code. Smaller code is easier to maintain and test, and because
    we rely upon abstractions instead of on implementations, we can extend the code
    more easily according to our needs.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**（**DI**）帮助你通过将代码的行为与其依赖项分离来生成松耦合的代码，这导致了更易于测试、扩展和维护的可读代码。代码更易于阅读，因为你遵循了单一职责原则。这也导致了更小的代码。更小的代码更容易维护和测试，因为我们依赖于抽象而不是实现，所以我们可以根据需要更轻松地扩展代码。'
- en: 'The following are the types of DI that you can implement:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你可以实现的 DI 类型：
- en: Constructor injection
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数注入
- en: Property/setter injection
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性/设置器注入
- en: Method injection
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法注入
- en: '*Poor man''s DI* is composed without a container. However, the recommended
    and best practice is to use a DI container. In simple terms, a DI container is
    a registration framework that instantiates dependencies and injects them when
    requested.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*穷人的 DI* 是不使用容器构建的。然而，推荐的最佳实践是使用 DI 容器。简单来说，DI 容器是一个注册框架，它在请求时实例化依赖项并注入它们。'
- en: We are now going to write our own dependency container, interface, services,
    and client for our DI example. Then we will write our tests for the dependency
    project. Bear in mind that even though tests should be written first, in most
    business situations I have encountered, they are written once the software has
    been written! So in this scenario, we will write our tests after the software
    we want has been coded. This can often happen when you employ multiple teams where
    some utilize TDD and some don't, or you use third-party code for which no tests
    exist.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为我们的DI示例编写自己的依赖容器、接口、服务和客户端。然后我们将为依赖项目编写测试。请记住，即使测试应该首先编写，在我遇到的大多数业务情况下，它们是在软件编写后编写的！因此，在这种情况下，我们将在编写所需软件后编写测试。当您雇用多个团队时，其中一些团队使用TDD，而另一些团队不使用TDD，或者您使用第三方代码而没有测试时，这种情况经常发生。
- en: We mentioned earlier that E2E is best done manually and that automation is hard,
    but you can automate tests of the system, as well as performing manual testing.
    This is particularly useful if you target multiple data sources.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，E2E最好手动完成，自动化很困难，但您可以自动化系统的测试，以及进行手动测试。如果您的目标是多个数据源，这将特别有用。
- en: The first thing you need to have in place is a dependency container. The dependency
    container keeps a register of types and instances. You register types before you
    use them. When it is time to use an instance of an object, you resolve it into
    a variable and inject (pass it) into the constructor, method, or property.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要准备好一个依赖容器。依赖容器保留类型和实例的注册。在使用之前，您需要注册类型。当需要使用对象的实例时，您将其解析为变量并注入（传递）到构造函数、方法或属性中。
- en: 'Create a new class library and call it `CH07_DependencyInjection`. Add a new
    class called `DependencyContainer`, and add the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类库，命名为`CH07_DependencyInjection`。添加一个名为`DependencyContainer`的新类，并添加以下代码：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this code, we have two dictionaries that house the types and the instances.
    We also have two methods. One is used to register our types, and the second is
    used to register our instances. Now that we have the code to register and store
    our types and instances, we need a way to resolve them at runtime. Add the following
    code to the `DependencyContainer` class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们有两个字典，其中包含类型和实例。我们还有两种方法。一种用于注册我们的类型，另一种用于注册我们的实例。现在我们已经有了注册和存储类型和实例的代码，我们需要一种在运行时解析它们的方法。将以下代码添加到`DependencyContainer`类中：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This method is passed in a type. It calls the method to resolve the type and
    returns an instance of that type. So, let''s add that method now:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法传入一个类型。它调用解析类型的方法并返回该类型的实例。因此，现在让我们添加该方法：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `Resolve()` method checks to see whether the `Instances` dictionary contains
    an instance whose key matches the contract. If it does, then that instance is
    returned. Otherwise, a new instance is created and returned.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Resolve()`方法检查`Instances`字典是否包含与合同匹配的实例。如果是，则返回该实例。否则，创建并返回一个新实例。'
- en: 'Now, we need an interface that our services to be injected will implement.
    We''ll call it `IService`. It will have a single method that will return a string,
    and the method will be called `WhoAreYou()`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个接口，我们要注入的服务将实现该接口。我们将其命名为`IService`。它将有一个返回字符串的单个方法，该方法将被命名为`WhoAreYou()`：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Our services to be injected will implement the aforementioned interface. Our
    first class will be named `ServiceOne`, and the method will return the string
    `"CH07_DependencyInjection.ServiceOne()"`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要注入的服务将实现上述接口。我们的第一个类将被命名为`ServiceOne`，并且该方法将返回字符串`"CH07_DependencyInjection.ServiceOne()"`：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The second service is the same except it is called `ServiceTwo`, and the method
    returns the string `"CH07_DependencyInjection.ServiceTwo()"`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个服务与第一个服务相同，只是它被称为`ServiceTwo`，并且该方法返回字符串`"CH07_DependencyInjection.ServiceTwo()"`：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The dependency container, interface, and service classes are now in place.
    Finally, we are going to add the client that will be used as the demonstration
    object that will consume our services via DI. Our class will demonstrate constructor
    injection, property injection, and method injection. Add the following code to
    the top of the class:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖容器、接口和服务类现在已经就位。最后，我们将添加客户端，该客户端将用作演示对象，通过DI来使用我们的服务。我们的类将演示构造函数注入、属性注入和方法注入。将以下代码添加到类的顶部：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `_service` member variable will be used to store our injected service.
    We have a default constructor so that we can test our property and method injection.
    Add the constructor that accepts and sets the `IService` member:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`_service`成员变量将用于存储我们注入的服务。我们有一个默认构造函数，以便我们可以测试我们的属性和方法注入。添加接受并设置`IService`成员的构造函数：'
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we will add our property to test property injection and constructor injection:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加用于测试属性注入和构造函数注入的属性：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then we''ll add a method that calls `WhoAreYou()` on the injected object. The
    `Service` property allows the `_service` member variable to be set and retrieved.
    Finally, we will add our `GetServiceName()` method:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将添加一个调用`WhoAreYou()`的方法注入对象。`Service`属性允许设置和检索`_service`成员变量。最后，我们将添加`GetServiceName()`方法：
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `GetServiceName()` method is called on the injected instance of the `IService`
    class. This method returns the fully qualified name of the service passed in.
    Now we will write the unit tests to test the functionality. Add a test project
    and reference the dependency project. Call the test project `CH07_DependencyInjection.Tests`
    and rename `UnitTest1` to `UnitTests`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetServiceName()`方法在`IService`类的注入实例上调用。此方法返回传入的服务的完全限定名称。现在我们将编写单元测试来测试功能。添加一个测试项目并引用依赖项目。将测试项目命名为`CH07_DependencyInjection.Tests`，并将`UnitTest1`重命名为`UnitTests`。'
- en: 'We will write tests to check that our registration and resolving of instances
    works, and that the correct classes are injected by constructor injection, setter
    injection, and method injection. Our tests will test the injection of `ServiceOne`
    and `ServiceTwo`. Let''s start by writing our `Setup()` method as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写测试来检查我们实例的注册和解析是否有效，并且正确的类是否通过构造函数注入、setter注入和方法注入。我们的测试将测试`ServiceOne`和`ServiceTwo`的注入。让我们从编写以下`Setup()`方法开始：
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In our `Setup()` method, we register both our implementations of the `IService`
    class, these being `ServiceOne()` and `ServiceTwo()`. Now we will write our two
    test methods to test the dependency container:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Setup()`方法中，我们注册了`IService`类的两个实现，即`ServiceOne()`和`ServiceTwo()`。现在我们将编写两个测试方法来测试依赖容器：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Both these methods call the `Resolve()` method. The method checks for an instance
    of a type. If an instance exists, it returns it. Otherwise, one is instantiated
    and returned. It''s time to write the constructor injection tests for `serviceOne`
    and `serviceTwo`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都调用`Resolve()`方法。该方法检查类型的实例。如果实例存在，则返回它。否则，将实例化并返回。现在是时候为`serviceOne`和`serviceTwo`编写构造函数注入测试了：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In both of these constructor test methods, we resolve the relevant service
    from the container registry. Then we pass the service into the constructor. Finally,
    using the get `Service` property, we assert that the service passed in via the
    constructor is an instance of the expected service. Let''s write the test to show
    that the property setter injection works as expected:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个构造函数测试方法中，我们从容器注册表中解析相关服务。然后将服务传递到构造函数中。最后，使用`Service`属性，我们断言通过构造函数传入的服务是预期服务的实例。让我们编写测试以显示属性setter注入按预期工作：
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To test that the setter injection resolves the class we are after, create a
    client using the default constructor, then assign the resolved instance to the
    `Service` property. Next, we assert whether the service is an instance of the
    expected type or not. Finally, for our tests, we just need to test our method
    injection:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试setter注入是否解析了我们想要的类，使用默认构造函数创建一个客户端，然后将解析后的实例分配给`Service`属性。接下来，我们断言服务是否是预期类型的实例。最后，对于我们的测试，我们只需要测试我们的方法注入：
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we again resolve our instance. Create a new client using the default constructor
    and assert passing in the resolved instance and that calling the `GetServiceName()`
    method returns the correct identity of the passed-in instance.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次解析我们的实例。使用默认构造函数创建一个新的客户端，并断言传入的解析实例和调用`GetServiceName()`方法返回传入实例的正确标识。
- en: Modularization
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化
- en: 'A system consists of one or more modules. When a system con two or more modules,
    you need to test the interaction between them to make sure they work together
    as expected. Let''s consider the system for an API shown in the following diagram:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 系统由一个或多个模块组成。当一个系统包含两个或多个模块时，您需要测试它们之间的交互，以确保它们按预期一起工作。让我们考虑一下以下图表中API的系统：
- en: '![](img/7f98ec51-7941-48ce-9cb1-1fe5936d445d.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f98ec51-7941-48ce-9cb1-1fe5936d445d.png)'
- en: As you can see from the previous diagram, we have a client that accesses a data
    store in the cloud via an API. The client sends a request to the HTTP server.
    The request is authenticated. Once it has been authenticated, the request is then
    authorized to access the API. The data sent by the client is deserialized and
    then passed on to the business layer. The business layer then performs either
    a read, insert, update, or delete operation on the data store. The data is then
    passed back to the client from the database via the business layer, followed by
    the serialization layer, and then back to the client.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表中可以看出，我们有一个客户端通过API访问云中的数据存储。客户端向HTTP服务器发送请求。请求经过身份验证。一旦经过身份验证，请求就被授权访问API。客户端发送的数据被反序列化，然后传递到业务层。业务层然后在数据存储上执行读取、插入、更新或删除操作。数据然后通过业务层从数据库传回客户端，然后通过序列化层传回客户端。
- en: 'As you can see, we have a number of modules that interact with each other.
    We have the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们有许多相互交互的模块。我们有以下内容：
- en: Security (Authentication and Authorization) interacting with serialization (Serialization
    and Deserialization)
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全（身份验证和授权）与序列化（序列化和反序列化）进行交互
- en: Serialization interacting with the business layer that contains all the business
    logic
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与包含所有业务逻辑的业务层进行交互的序列化
- en: The Business Logic layer interacting with the data store
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务逻辑层与数据存储进行交互
- en: 'If we look at these three preceding points, we can see that a number of tests
    can be written to automate the E2E testing process. Many tests are essentially
    unit tests that become incorporated into our suite of integration tests. Let''s
    consider some now. We are able to test the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下前面的三点，我们可以看到可以编写许多测试来自动化E2E测试过程。许多测试本质上是单元测试，这些测试成为我们的集成测试套件的一部分。现在让我们考虑一些。我们能够测试以下内容：
- en: Correct login
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确的登录
- en: Incorrect login
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录错误
- en: Authorized access
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权访问
- en: Unauthorized access
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未经授权的访问
- en: Serialization of data
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据序列化
- en: Deserialization of data
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据反序列化
- en: Business logic
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务逻辑
- en: Database read
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库读取
- en: Database update
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库更新
- en: Database insert
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库插入
- en: Database delete
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库删除
- en: 'As you can see from these tests, they are unit tests over integration tests.
    So, what integration tests could we write? Well, we could write the following
    tests:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些测试中可以看出，它们是集成测试的单元测试。那么，我们可以编写哪些集成测试呢？嗯，我们可以编写以下测试：
- en: Send a read request.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送读取请求。
- en: Send an insert request.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送插入请求。
- en: Send an edit request.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送编辑请求。
- en: Send a delete request.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送删除请求。
- en: Those four tests could be written using the correct username and password and
    well-formed data requests, and they could also be written for invalid usernames
    or passwords and malformed data requests.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个测试可以使用正确的用户名和密码以及格式良好的数据请求进行编写，也可以针对无效的用户名或密码和格式不良的数据请求进行编写。
- en: So, you can perform integration testing by using unit tests to test the code
    in each module, then using tests that only test the interaction between two modules
    at a time. You can also write tests that perform a full E2E operation.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以通过使用单元测试来测试每个模块中的代码，然后使用仅测试两个模块之间交互的测试来执行集成测试。您还可以编写执行完整E2E操作的测试。
- en: But despite being able to test all this with code, the one thing you *must*
    do is run through the system manually to verify that everything works as expected.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以使用代码测试所有这些，但你*必须*手动运行系统，以验证一切是否按预期工作。
- en: With all these tests completed successfully, you can have the confidence to
    release your code to the production environment.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些测试都成功完成后，您可以放心地将代码发布到生产环境。
- en: Now that we have covered E2E testing (also known as **integration testing**),
    let's take some time to summarize what we have learned.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了E2E测试（也称为**集成测试**），让我们花点时间总结一下我们学到的东西。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at what E2E testing is. We saw that we can write
    automated tests, but we've also come to understand the importance of manually
    testing the complete application from an end user perspective.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了什么是E2E测试。我们看到我们可以编写自动化测试，但我们也意识到了从最终用户的角度手动测试完整应用程序的重要性。
- en: When we looked at factories, we saw an example of their use when it comes to
    database connectivity. We considered a scenario where our app will enable users
    to use a database of their choice. We load in a connection string, and then based
    on that connection string, the relevant database connection object is instantiated
    and returned for use. We saw how we could test our factories for each use case
    for each different database. Factories can be used in a number of different scenarios,
    and now you know what they are, how to use them, and most importantly, you know
    how to test them.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们研究工厂时，我们看到了它们在数据库连接方面的使用示例。我们考虑了一个场景，即我们的应用程序将允许用户使用他们选择的数据库。我们加载连接字符串，然后根据该连接字符串实例化并返回相关的数据库连接对象供使用。我们看到了如何可以针对每个不同数据库的每个用例测试我们的工厂。工厂可以在许多不同的场景中使用，现在您知道它们是什么，如何使用它们，最重要的是，您知道如何测试它们。
- en: DI enables a single class to work with multiple different implementations of
    an interface. We saw this in action when we wrote our own dependency container.
    The interface we created was implemented by two classes, added to the dependency
    register, and resolved when called upon by the dependency container. We implemented
    unit tests to test the different implementations for constructor injection, property
    injection, and method injection.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: DI使单个类能够与接口的多个不同实现一起工作。当我们编写自己的依赖容器时，我们看到了这一点。我们创建的接口由两个类实现，添加到依赖注册表中，并在依赖容器调用时解析。我们实施了单元测试，以测试构造函数注入、属性注入和方法注入的不同实现。
- en: Then, we looked at modules. A simple application may consist of a single module,
    but the more an application grows in complexity, the more modules will make up
    that application. As the number of modules grows, so does the opportunity for
    something to go wrong. Therefore, it is very important to test the interaction
    between modules. The modules themselves can be tested using unit tests. The interaction
    between modules can be tested with more involved tests that run through a complete
    scenario from start to finish.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看了模块。一个简单的应用程序可能只包含一个模块，但随着应用程序复杂性的增加，组成该应用程序的模块也会增加。模块数量的增加也增加了出错的机会。因此，测试模块之间的交互非常重要。模块本身可以使用单元测试进行测试。模块之间的交互可以使用更复杂的测试进行测试，从头到尾运行完整的场景。
- en: In the next chapter, we will be looking at best practices when working with
    threading and concurrency. But first, let's test your knowledge on the contents
    of this chapter.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨在处理线程和并发时的最佳实践。但首先，让我们测试一下你对本章内容的了解。
- en: Questions
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is E2E testing?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是E2E测试？
- en: What is another term for E2E testing?
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: E2E测试的另一个术语是什么？
- en: What methods should we employ during E2E testing?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在E2E测试期间我们应该采用什么方法？
- en: What are factories, and why do we use them?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工厂是什么，为什么我们要使用它们？
- en: What is DI?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DI是什么？
- en: Why should we use a dependency container?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们应该使用依赖容器？
- en: Further reading
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The book *Dependency Injection in .NET* by Manning will introduce you to .NET
    DI before guiding you through the various DI frameworks.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Manning的书《.NET中的依赖注入》将在向您介绍.NET DI之前，引导您了解各种DI框架。

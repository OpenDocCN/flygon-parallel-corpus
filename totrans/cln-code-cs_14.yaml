- en: Refactoring C# Code – Implementing Design Patterns
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 重构C#代码——实现设计模式
- en: Half the battle in programming clean code is in the correct implementation and
    usage of design patterns. Design patterns themselves can become code smells. A
    design pattern becomes a code smell when it is used to over-engineer something
    that is rather simple to implement.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写清晰代码的一半战斗在于正确实现和使用设计模式。设计模式本身也可能成为代码异味。当用于过度设计某些相当简单的东西时，设计模式就会成为代码异味。
- en: You have already seen the use of design patterns in writing clean code and refactoring
    code smells in the previous chapters of this book. Specifically, we have implemented
    the adapter pattern, the decorator pattern, and the proxy pattern. These patterns
    were implemented in the right way to accomplish the task at hand. They were kept
    simple and they most certainly did not complicate the code. So, when used for
    their proper purpose, design patterns are really useful in removing code smells,
    thus leaving your code nice, clean, and fresh.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前几章中，你已经看到了设计模式在编写清晰代码和重构代码中的应用。具体来说，我们已经实现了适配器模式、装饰器模式和代理模式。这些模式都是以正确的方式实现以完成手头的任务。它们保持简单，绝对不会使代码复杂。因此，当用于其适当的目的时，设计模式在消除代码异味方面确实非常有用，从而使你的代码变得清晰、干净和新鲜。
- en: In this chapter, we will address the **Gang of Four (GoF)** creational, structural,
    and behavioral design patterns. Design patterns are not set in stone and you don't
    have to be strict in their implementation. But having code samples can help you
    transition from just having head knowledge to having the practical skills needed
    to correctly implement and use design patterns.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将讨论**四人帮（GoF）**的创建、结构和行为设计模式。设计模式并非一成不变，你不必严格按照它们的实现方式。但是有代码示例可以帮助你从仅仅拥有理论知识过渡到具备正确实现和使用设计模式所需的实际技能。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Implementing creational design patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现创建型设计模式
- en: Implementing structural design patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现结构设计模式
- en: Overview of behavioral design patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为设计模式的概述
- en: 'By the end of this chapter, you will have the following skills:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将具备以下技能：
- en: The ability to understand, describe, and program different creational design
    patterns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解、描述和编程不同的创建型设计模式的能力
- en: The ability to understand, describe, and program different structural design
    patterns
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解、描述和编程不同的结构设计模式的能力
- en: An understanding of an overview of behavioral design patterns
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解行为设计模式的概述
- en: We will begin our overview of GoF design patterns by addressing creational design
    patterns.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过讨论创建型设计模式来开始我们对GoF设计模式的概述。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Visual Studio 2019
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019
- en: A Visual Studio 2019 .NET Framework console application as your working project
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Visual Studio 2019 .NET Framework控制台应用作为你的工作项目
- en: 'The complete source code for this chapter: [https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH14/CH14_DesignPatterns](https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH14/CH14_DesignPatterns)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的完整源代码：[https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH14/CH14_DesignPatterns](https://github.com/PacktPublishing/Clean-Code-in-C-/tree/master/CH14/CH14_DesignPatterns)
- en: Implementing creational design patterns
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现创建型设计模式
- en: 'From a programmer''s perspective, we use creational design patterns when we
    perform object creation. Patterns are selected based on the task at hand. There
    are five creational design patterns:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从程序员的角度来看，当我们执行对象创建时，我们使用创建型设计模式。模式是根据手头的任务选择的。有五种创建型设计模式：
- en: '**Singleton**: The singleton pattern ensures that only one instance of an object
    will exist at the application level.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例模式**：单例模式确保应用程序级别只存在一个对象实例。'
- en: '**Factory method**: A factory pattern is used to create objects without using
    the class to be used.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工厂方法**：工厂模式用于创建对象而不使用要使用的类。'
- en: '**Abstract factory**: Without the specification of their concrete classes,
    groups of related or dependent objects are instantiated by the abstract factory.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象工厂**：在不指定其具体类的情况下，抽象工厂实例化相关或依赖的对象组。'
- en: '**Prototype**: Specifies the type of prototype to create, and then creates
    copies of the prototype.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原型**：指定要创建的原型的类型，然后创建原型的副本。'
- en: '**Builder**: Separates object construction from its representation.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**建造者**：将对象的构建与其表示分离。'
- en: We will now begin implementing each of these patterns, starting with the singleton
    design pattern.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将开始实现这些模式，从单例设计模式开始。
- en: Implementing the singleton pattern
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现单例模式
- en: 'The singleton design pattern only allows one instance of a class with global
    access to it. Use the singleton pattern when all operations within a system must
    be coordinated by exactly one object:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 单例设计模式只允许一个类的一个实例，并且可以全局访问。当系统内的所有操作必须由一个对象协调时，使用单例模式：
- en: '![](img/94e2597c-471b-48e0-ae30-ec3f69fa8d9c.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94e2597c-471b-48e0-ae30-ec3f69fa8d9c.png)'
- en: The participant in this pattern is **s****ingleton**—a class that is responsible
    for managing its own instance and ensures that there is only one instance of itself
    running in the entire system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式中的参与者是**单例**——一个负责管理自己实例的类，并确保在整个系统中只有一个实例在运行。
- en: 'We are now going to implement the singleton design pattern:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现单例设计模式：
- en: 'Add a folder called `Singleton` to the `CreationalDesignPatterns` folder. Then,
    add a class called `Singleton`:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CreationalDesignPatterns`文件夹中添加一个名为`Singleton`的文件夹。然后，添加一个名为`Singleton`的类：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Singleton` class stores a static copy of an instance of itself. You cannot
    instantiate the class because the constructor is marked as protected. The `Instance()`
    method is static. It checks to see whether an instance of the `Singleton` class
    exists. If it does, then it is returned. If it does not exist, then the instance
    is created and returned. Now, we''ll add the code to call it:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Singleton`类存储了自身实例的静态副本。您无法实例化该类，因为构造函数被标记为受保护。`Instance()`方法是静态的。它检查`Singleton`类的实例是否存在。如果存在，则返回该实例。如果不存在，则创建并返回该实例。现在，我们将添加调用它的代码：'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We declare two instances of the `Singleton` class, and then compare them to
    see whether they are the same instance. You can see the output in the following
    screenshot:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明了`Singleton`类的两个实例，然后将它们进行比较，以查看它们是否是同一个实例。您可以在以下截图中看到输出：
- en: '![](img/691d45a9-3c14-4bd6-8f99-46e4e9f5c5e3.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/691d45a9-3c14-4bd6-8f99-46e4e9f5c5e3.png)'
- en: As you can see, we have a working class that implements the singleton design
    pattern. Next up, we'll tackle the factory method design pattern.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们有一个实现了单例设计模式的工作类。接下来，我们将着手实现工厂方法设计模式。
- en: Implementing the factory method pattern
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现工厂方法模式
- en: 'The factory method design pattern creates objects that let their subclasses
    implement their own object creation logic. Use this design pattern when you want
    to keep object instantiation in a single place and need to generate a specific
    group of related objects:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法设计模式创建对象，让它们的子类实现自己的对象创建逻辑。当您想要将对象实例化保持在一个地方并且需要生成特定组相关对象时，请使用此设计模式：
- en: '![](img/93b0c1b5-6908-4e09-b537-4d396424bf78.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93b0c1b5-6908-4e09-b537-4d396424bf78.png)'
- en: 'The participants in this project are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的参与者如下：
- en: '`Product`**:** The abstract product created by the factory method'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`产品`**：** 工厂方法创建的抽象产品'
- en: '`ConcreteProduct`: Inherits the abstract product'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteProduct`：继承抽象产品'
- en: '`Creator`: An abstract class with an abstract factory method'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`创建者`：一个带有抽象工厂方法的抽象类'
- en: '`Concrete Creator`**:** Inherits the abstract creator and overrides the factory
    method'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Concrete Creator`**：** 继承抽象创建者并重写工厂方法'
- en: 'We will now implement the factory method:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现工厂方法：
- en: 'Add a folder to the `CreationalDesignPatterns` folder called `FactoryMethod`.
    Then, add the `Product` class:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CreationalDesignPatterns`文件夹中添加一个名为`FactoryMethod`的文件夹。然后，添加`Product`类：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Product` class defines the objects that are created by the factory method.
    Add the `ConcreteProduct` class:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Product`类定义了由工厂方法创建的对象。添加`ConcreteProduct`类：'
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `ConcreteProduct` class inherits the `Product` class. Add the `Creator` class:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ConcreteProduct`类继承了`Product`类。添加`Creator`类：'
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Creator` class will be inherited by the `ConcreteFactory` class, which
    will implement `FactoryMethod()`. Add the `ConcreteCreator` class:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Creator`类将被`ConcreteFactory`类继承，后者将实现`FactoryMethod()`。添加`ConcreteCreator`类：'
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `ConcreteCreator` class inherits the `Creator` class and overrides the `FactoryMethod()`.
    A new `ConcreteProduct` class is returned by the method. The following code demonstrates
    the factory method in use:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ConcreteCreator`类继承了`Creator`类并重写了`FactoryMethod()`。该方法返回一个新的`ConcreteProduct`类。以下代码演示了工厂方法的使用：'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have created a new instance of the `ConcreteCreator` class. Then, we called
    the `FactoryMethod()` to create a new product. The name of the product created
    by the factory method is then output to the console window, as shown:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了`ConcreteCreator`类的一个新实例。然后，我们调用`FactoryMethod()`来创建一个新产品。由工厂方法创建的产品的名称随后输出到控制台窗口，如下所示：
- en: '![](img/daa493a5-07aa-4d8f-8e20-a97708956825.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/daa493a5-07aa-4d8f-8e20-a97708956825.png)'
- en: Now that we know how to implement the factory method design pattern, we will
    move on to implementing the abstract factory design pattern.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何实现工厂方法设计模式，我们将继续实现抽象工厂设计模式。
- en: Implementing the abstract factory pattern
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现抽象工厂模式
- en: 'Without the specification of their concrete classes, groups of related or dependent objects, referred
    to as families, are instantiated using the abstract factory design pattern:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有具体类的情况下，相关或依赖的对象组，称为家族，使用抽象工厂设计模式进行实例化：
- en: '![](img/d57e611f-4941-4627-abfb-f991728fed2f.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d57e611f-4941-4627-abfb-f991728fed2f.png)'
- en: 'The participants in this pattern are as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式的参与者如下：
- en: '`AbstractFactory`: The abstract factory, which is implemented by concrete factories'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractFactory`：由具体工厂实现的抽象工厂'
- en: '`ConcreteFactory`: Creates concrete products'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteFactory`：创建具体产品'
- en: '`AbstractProduct`: The abstract product that concrete products will inherit'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractProduct`：具体产品将继承的抽象产品'
- en: '`Product`: Inherits `AbstractProduct` and is created by the concrete factory'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Product`：继承`AbstractProduct`并由具体工厂创建'
- en: 'We will now start implementing the pattern:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将开始实现该模式：
- en: Add a folder to the project called `CreationalDesignPatterns`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中添加一个名为`CreationalDesignPatterns`的文件夹。
- en: Add a folder to the `CreationalDesignPatterns` folder called `AbstractFactory`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CreationalDesignPatterns`文件夹中添加一个名为`AbstractFactory`的文件夹。
- en: 'In the `AbstractFactory` folder, add the `AbstractFactory` class:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AbstractFactory`文件夹中，添加`AbstractFactory`类：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`AbstractFactory` contains two abstract methods for creating abstract products.
    Add the `AbstractProductA` class:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AbstractFactory`包含两个创建抽象产品的抽象方法。添加`AbstractProductA`类：'
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `AbstractProductA` class has a single abstract method, which performs an
    operation on `AbstractProductB`. Now, add the `AbstractProductB` class:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AbstractProductA`类有一个单一的抽象方法，该方法对`AbstractProductB`执行操作。现在，添加`AbstractProductB`类：'
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `AbstractProductB` class has a single abstract method, which performs an
    operation on `AbstractProductA`. Add the `ProductA` class:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AbstractProductB`类有一个单一的抽象方法，该方法对`AbstractProductA`执行操作。添加`ProductA`类：'
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`ProductA` inherits `AbstractProductA` and overrides the `Operation()` method,
    which interacts with `AbstractProductB`. The `Operation()` method in this example
    prints out a console message. Do the same for the `ProductB` class:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProductA`继承了`AbstractProductA`并重写了`Operation()`方法，该方法与`AbstractProductB`进行交互。在这个例子中，`Operation()`方法打印出控制台消息。对`ProductB`类也做同样的操作：'
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`ProductB` inherits `AbstractProductB` and overrides the `Operation()` method,
    which interacts with `AbstractProductA`. The `Operation()` method in this example
    prints out a console message. Add the `ConcreteFactory` class:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProductB`继承了`AbstractProductB`并重写了`Operation()`方法，该方法与`AbstractProductA`进行交互。在这个例子中，`Operation()`方法打印出控制台消息。添加`ConcreteFactory`类：'
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`ConcreteFactory` inherits the `AbstractFactory` class and overrides the two
    product creation methods. Each method returns a concrete class. Add the `Client` class:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ConcreteFactory`继承了`AbstractFactory`类，并重写了两个产品创建方法。每个方法返回一个具体类。添加`Client`类：'
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `Client` class declares two abstract products. Its constructor takes an `AbstractFactory` class.
    Inside the constructor, both declared abstract products are assigned their respective
    concrete products by the factory. The `Run()` method executes `Operation()` on
    both products. The following code executes our abstract factory example:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Client`类声明了两个抽象产品。它的构造函数接受一个`AbstractFactory`类。在构造函数内部，工厂为两个声明的抽象产品分配了它们各自的具体产品。`Run()`方法执行了两个产品上的`Operation()`。以下代码执行了我们的抽象工厂示例：'
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run the code and you will see the following output:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，你会看到以下输出：
- en: '![](img/bb3f9ac2-15db-4b09-92ce-fa278c42e5c6.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb3f9ac2-15db-4b09-92ce-fa278c42e5c6.png)'
- en: 'A good reference implementation of the abstract factory is the ADO.NET 2.0
    `DbProviderFactory` abstract class. An article called *Abstract Factory Design
    Pattern in ADO.NET 2.0* by Moses Soliman on C# Corner is a nice write-up on `DbProviderFactory`
    about the implementation of the abstract factory design pattern. Here is the link:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂的一个很好的参考实现是ADO.NET 2.0的`DbProviderFactory`抽象类。一篇名为*ADO.NET 2.0中的抽象工厂设计模式*的文章，作者是Moses
    Soliman，发布在C# Corner上，对`DbProviderFactory`的抽象工厂设计模式的实现进行了很好的描述。这是链接：
- en: '[https://www.c-sharpcorner.com/article/abstract-factory-design-pattern-in-ado-net-2-0/](https://www.c-sharpcorner.com/article/abstract-factory-design-pattern-in-ado-net-2-0/).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.c-sharpcorner.com/article/abstract-factory-design-pattern-in-ado-net-2-0/](https://www.c-sharpcorner.com/article/abstract-factory-design-pattern-in-ado-net-2-0/).'
- en: We have successfully implemented the abstract factory design pattern. Now, we
    will implement the prototype pattern.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功实现了抽象工厂设计模式。现在，我们将实现原型模式。
- en: Implementing the prototype pattern
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现原型模式
- en: 'The prototype design pattern is used to create an instance of a prototype,
    and then to create new objects by cloning the prototype. Use this pattern when
    the cost of creating objects directly is expensive. With this pattern, you can
    cache the object and return a clone when needed:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 原型设计模式用于创建原型的实例，然后通过克隆原型来创建新对象。当直接创建对象的成本昂贵时，使用此模式。通过此模式，可以缓存对象，并在需要时返回克隆：
- en: '![](img/6a9b4467-fc5b-4ff3-9143-0f951db7651a.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a9b4467-fc5b-4ff3-9143-0f951db7651a.png)'
- en: 'The participants in the prototype design pattern are as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 原型设计模式中的参与者如下：
- en: '`Prototype`: An abstract class that provides a method for cloning itself'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Prototype`：提供克隆自身的方法的抽象类'
- en: '`ConcretePrototype`: Inherits the prototype and overrides the `Clone()` method
    to return a memberwise clone of the prototype'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcretePrototype`：继承原型并重写`Clone()`方法以返回原型的成员克隆'
- en: '`Client`: Requests new clones of the prototype'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Client`：请求原型的新克隆'
- en: 'We will now implement the prototype design pattern:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现原型设计模式：
- en: 'Add a folder called `Prototype` to the `CreationalDesignPatterns` folder, and
    then add the `Prototype` class:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CreationalDesignPatterns`文件夹中添加一个名为`Prototype`的文件夹，然后添加`Prototype`类：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our `Prototype` class must be inherited. Its constructor requires an identifying
    string to be passed in that is stored at the class level. A `Clone()` method is
    provided, which the subclass will override. Now, add the `ConcretePrototype` class:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`Prototype`类必须被继承。它的构造函数需要传入一个标识字符串，该字符串存储在类级别。提供了一个`Clone()`方法，子类将对其进行重写。现在，添加`ConcretePrototype`类：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `ConcretePrototype` class inherits from the `Prototype` class. Its constructor
    takes an identifying string and passes that string into the constructor of the
    base class. It then overrides the clone method to provide a shallow copy of the
    current object by calling the `MemberwiseClone()` method and returning the clone
    that is cast to the type of `Prototype`. Now for the code that demonstrates the
    prototype design pattern in use:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ConcretePrototype`类继承自`Prototype`类。它的构造函数接受一个标识字符串，并将该字符串传递给基类的构造函数。然后，它重写了克隆方法，通过调用`MemberwiseClone()`方法提供当前对象的浅拷贝，并返回转换为`Prototype`类型的克隆。现在，我们来演示原型设计模式的代码：'
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our code creates a new instance of the `ConcretePrototype` class with an identifier
    of `"Clone 1"`. We then clone the prototype and cast it to the `ConcretePrototype`
    type. Then, we print the clone''s identifier to the console window, as shown:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码创建了一个带有标识符“Clone 1”的`ConcretePrototype`类的新实例。然后，我们克隆原型并将其转换为`ConcretePrototype`类型。然后，我们将克隆的标识符打印到控制台窗口，如下所示：
- en: '![](img/dfb6a75d-50e6-40db-b4e9-8d379bb5a8cc.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dfb6a75d-50e6-40db-b4e9-8d379bb5a8cc.png)'
- en: As we can see, the clone has the same identifier as the prototype that it was
    cloned from.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，克隆的标识符与其克隆自的原型相同。
- en: For a very detailed article of a real-world example, refer to an excellent article
    called *Prototype Design Pattern with Real-World Scenario*, by Akshay Patel, on
    C# Corner. Here is the link: [https://www.c-sharpcorner.com/UploadFile/db2972/prototype-design-pattern-with-real-world-scenario624/](https://www.c-sharpcorner.com/UploadFile/db2972/prototype-design-pattern-with-real-world-scenario624/).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个真实世界示例的非常详细的文章，请参考一篇名为*具有真实场景的原型设计模式*的优秀文章，作者是Akshay Patel，文章发布在C# Corner上。这是链接：[https://www.c-sharpcorner.com/UploadFile/db2972/prototype-design-pattern-with-real-world-scenario624/](https://www.c-sharpcorner.com/UploadFile/db2972/prototype-design-pattern-with-real-world-scenario624/)。
- en: We will now implement our final creational design pattern called the builder
    design pattern.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现我们的最终创建型设计模式，即建造者设计模式。
- en: Implementing the builder pattern
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现建造者模式
- en: 'The builder design pattern separates the object''s construction from its representation.
    As a result, you can use the same construction method to create different representations
    of the object. Use the builder design pattern when you have a complex object that
    needs to be built up and connected in stages:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者设计模式将对象的构建与其表示分离。因此，您可以使用相同的构建方法来创建对象的不同表示。当您有一个需要逐步构建和连接的复杂对象时，请使用建造者设计模式：
- en: '![](img/721f8a0f-4d08-4857-a7b3-68407de21f3e.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/721f8a0f-4d08-4857-a7b3-68407de21f3e.png)'
- en: 'The participants in the builder design pattern are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者设计模式的参与者如下：
- en: '`Director`: A class that receives a builder via its constructor, and then calls
    each of the build methods on the builder object'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Director`：一个类，通过其构造函数接收一个构建者，然后在构建者对象上调用每个构建方法'
- en: '**`Builder`**: An abstract class that provides abstract build methods and an
    abstract method for returning the built object'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Builder`**：一个抽象类，提供抽象构建方法和一个用于返回构建对象的抽象方法'
- en: '`ConcreteBuilder`: A concrete class that inherits the `Builder` class, overrides
    the builder methods to actually build the object, and overrides the result method
    to return the fully built object'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteBuilder`：一个具体类，继承`Builder`类，重写构建方法以实际构建对象，并重写结果方法以返回完全构建的对象'
- en: 'Let''s start implementing our final creational design pattern—the builder design
    pattern:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现我们的最终创建型设计模式——建造者设计模式：
- en: 'Start by adding a folder called `Builder` to the `CreationalDesignPatterns`
    folder. Then, add the `Product` class:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`CreationalDesignPatterns`文件夹中添加一个名为`Builder`的文件夹。然后，添加`Product`类：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In our example, the `Product` class keeps a list of parts. These parts are
    strings. The list is initialized in the constructor. Parts are added by the `Add()`
    method, and when our object is fully constructed, we can call the `PrintPartsList()`
    method to print the list of parts that make up the object to the console window.
    Now, add the `Builder` class:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的示例中，`Product`类保留了一个部件列表。这些部件是字符串。列表在构造函数中初始化。通过`Add()`方法添加部件，当对象完全构建时，我们可以调用`PrintPartsList()`方法将构成对象的部件列表打印到控制台窗口。现在，添加`Builder`类：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our `Builder` class will be inherited by concrete classes that will override
    its abstract methods to build the object and return it. We''ll now add the `ConcreteBuilder`
    class:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`Builder`类将被具体类继承，这些具体类将重写其抽象方法以构建对象并返回它。我们现在将添加`ConcreteBuilder`类：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Our `ConcreteBuilder` class inherits the `Builder` class. The class stores
    the instance of the object to be constructed. The build methods are overridden
    and parts are added to the product via the product''s `Add()` method. The product
    is returned to the client via the `GetProduct()` method call. Add the `Director`
    class:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`ConcreteBuilder`类继承了`Builder`类。该类存储要构建的对象的实例。构建方法被重写，并通过产品的`Add()`方法向产品添加部件。产品通过`GetProduct()`方法调用返回给客户端。添加`Director`类：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `Director` class is a concrete class that takes a `Builder` object via
    its `Build()` method and calls the build methods on the `Builder` object to build
    the object. All we need now is the code to demonstrate the builder design pattern
    in action:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Director`类是一个具体类，通过其`Build()`方法接收一个`Builder`对象，并调用`Builder`对象上的构建方法来构建对象。现在我们需要的是演示建造者设计模式的代码：'
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We create a director and builder. Then, the director builds the product. The
    product is then assigned, and its parts list is printed out to the console window,
    as shown:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个导演和一个构建者。然后，导演构建产品。然后分配产品，并将其部件列表打印到控制台窗口，如下所示：
- en: '![](img/97d6673e-dcdf-4ede-8c17-06af4f20b39c.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97d6673e-dcdf-4ede-8c17-06af4f20b39c.png)'
- en: Everything is working as it should be.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都按预期运行。
- en: 'In .NET Framework, the `System.Text.StringBuilder` class is an example of the
    builder design pattern in the real world. Using string concatenation with the
    plus (`+`) operator is slower than using the `StringBuilder` class when concatenating
    five or more lines. String concatenation with the `+` operator is faster than
    `StringBuilder` when you have less than five concatenation lines, but slower when
    you have more than five lines to concatenate. The reason for this is that each
    time you create a string with the `+` operator, you are recreating the string
    since strings are immutable on the heap. But `StringBuilder` allocates buffer
    space on the heap. Then, characters are written to the buffer space. For only
    a small number of lines, the `+` operator is faster because of the overhead of
    creating the buffer when using the string builder. But when there are more than
    five lines, there is a noticeable difference when using `StringBuilder`. In big
    data projects where there may be hundreds of thousands or even millions of string
    concatenations taking place, the string concatenation strategy that you decide
    to employ will either perform fast or sluggishly. Let''s create a simple demonstration.
    Create a new class called `StringConcatenation`, and then add the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Framework中，`System.Text.StringBuilder`类是现实世界中建造者设计模式的一个例子。使用加号（`+`）运算符进行字符串连接比使用`StringBuilder`类在连接五行或更多行时要慢。当连接少于五行时，使用`+`运算符的字符串连接速度比`StringBuilder`快，但当连接超过五行时，速度比`StringBuilder`慢。原因是每次使用`+`运算符创建字符串时，都会重新创建字符串，因为字符串在堆上是不可变的。但`StringBuilder`在堆上分配缓冲区空间，然后将字符写入缓冲区空间。对于少量行，由于使用字符串构建器时创建缓冲区的开销，`+`运算符更快。但当超过五行时，使用`StringBuilder`时会有明显的差异。在大数据项目中，可能会进行数十万甚至数百万次字符串连接，您决定采用的字符串连接策略将决定其性能快慢。让我们创建一个简单的演示。创建一个名为`StringConcatenation`的新类，然后添加以下代码：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `_startTime` variable holds the current start time of the method execution.
    The `_durationPlus` variable holds the duration of the method execution as the
    number of ticks when using the `+` operator to concatenate, and `_durationSb`
    holds the duration of the operation as the number of ticks for the `StringBuilder`
    concatenation. Add the `UsingThePlusOperator()` method to the class:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`_startTime` 变量保存方法执行的当前开始时间。`_durationPlus` 变量保存使用 `+` 运算符进行连接时的方法执行持续时间的滴答声数量，`_durationSb`
    保存使用 `StringBuilder` 连接的操作的持续时间作为滴答声数量。将 `UsingThePlusOperator()` 方法添加到类中：'
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `UsingThePlusOperator()` method demonstrates the time taken when concatenating
    10,000 strings using the `+` operator. The time taken to process the string concatenation
    is stored as the number of ticks fired. There are 10,000 ticks per millisecond.
    Now, add the `UsingTheStringBuilder()` method:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`UsingThePlusOperator()` 方法演示了使用 `+` 运算符连接 10,000 个字符串时所花费的时间。处理字符串连接所花费的时间以触发的滴答声数量存储。每毫秒有
    10,000 个滴答声。现在，添加 `UsingTheStringBuilder()` 方法：'
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This method is the same as the previous one, except we perform string concatenation
    using the `StringBuilder` class. We''ll now add the code to print out the time
    difference, called `PrintTimeDifference()`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法与前一个方法相同，只是我们使用 `StringBuilder` 类执行字符串连接。现在我们将添加代码来打印时间差异，称为 `PrintTimeDifference()`：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `PrintTimeDifference()` method calculates the time difference by subtracting
    the `StringBuilder` ticks from the `+` ticks. The difference in ticks is then
    printed to the console, followed by a line that translates the ticks into seconds.
    Here is the code to test our methods so that we can see the time difference in
    the two concatenation methods:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrintTimeDifference()` 方法通过从 `StringBuilder` 的滴答声中减去 `+` 的滴答声来计算时间差。然后将滴答声的差异打印到控制台，然后是将滴答声转换为秒的行。以下是用于测试我们的方法的代码，以便我们可以看到两种连接方法之间的时间差异：'
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When you run the code, you will see the times and time difference in the console
    window, as shown:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行代码时，您将在控制台窗口中看到时间和时间差异，如下所示：
- en: '![](img/8b2cac85-45bb-4abf-a951-4d54785decff.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b2cac85-45bb-4abf-a951-4d54785decff.png)'
- en: As you can see from the screenshot, `StringBuilder` is much faster. With small
    amounts of data, you don't really see a difference with the naked eye. But the
    difference is noticeable to the naked eye when the data lines being processed
    greatly increase in number.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从屏幕截图中可以看出，`StringBuilder` 要快得多。对于少量数据，肉眼几乎看不出差异。但是当处理的数据行数量大大增加时，肉眼可以看到差异。
- en: 'Another example that comes to mind for using the builder pattern is report
    construction. If you consider banded reports, the bands are essentially sections
    that need to be built up from various sources. So, you could have the main part,
    and then each subreport as a different part. The final report would be the amalgamation
    of these various parts. So, you could have code like the following to build a
    report:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我想到的使用生成器模式的例子是报告构建。如果您考虑分段报告，那么各个段基本上是需要从各种来源构建起来的部分。因此，您可以有主要部分，然后每个子报告作为不同的部分。最终报告将是这些各种部分的融合。因此，您可以像以下代码一样构建报告：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we are creating a new report. We start by adding the header. Then, we
    add last year's sales figures, combined for all regions, followed by last year's
    sales figures, broken down by region. We then add a footer to the report and complete
    the process by generating the report output.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个新的报告。我们首先添加标题。然后，我们添加去年所有地区的销售额，然后是去年按地区细分的销售额。然后我们为报告添加页脚，并通过生成报告输出完成整个过程。
- en: So, you've seen the default implementation of the builder pattern from the UML
    diagram. Then, you implemented string concatenation using the `StringBuilder`
    class, which helps you build strings in a performant manner. Finally, you learned
    how the builder pattern can be useful in building up the sections of a report
    and generating its output.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，您已经从 UML 图表中看到了生成器模式的默认实现。然后，您使用 `StringBuilder` 类实现了字符串连接，这有助于以高性能的方式构建字符串。最后，您了解了生成器模式如何在构建报告的各个部分并生成其输出时有用。
- en: Well, that concludes our implementations of the creational design patterns.
    We will now move on to implementing some structural design patterns.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这就结束了我们对创建设计模式的实现。现在我们将继续实现一些结构设计模式。
- en: Implementing structural design patterns
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施结构设计模式
- en: 'As programmers, we use structural patterns to improve the overall structure
    of our code. So, when code is encountered that lacks structure and is not at its
    cleanest, we can use the patterns mentioned in this section to restructure the
    code and make it clean. There are seven structural design patterns:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们使用结构模式来改进代码的整体结构。因此，当遇到缺乏结构且不够清晰的代码时，我们可以使用本节中提到的模式来重构代码并使其变得清晰。有七种结构设计模式：
- en: '**Adapter**:Use this pattern to enable classes with incompatible interfaces
    to work cleanly together.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适配器**：使用此模式使具有不兼容接口的类能够干净地一起工作。'
- en: '**Bridge**: Use this pattern to loosely couple code by decoupling an abstraction
    from its implementation.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桥接**：使用此模式通过将抽象与其实现解耦来松散地耦合代码。'
- en: '**Composite**: Use this pattern to aggregate objects and provide a uniform
    way of working with individual and object compositions.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**：使用此模式聚合对象并提供一种统一的方式来处理单个和对象组合。'
- en: '**Decorator**: Use this pattern to keep the interface the same while dynamically
    adding new functionality to the object.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰者**：使用此模式保持接口相同，同时动态添加新功能到对象。'
- en: '**Façade**: Use this pattern to simplify larger and more complex interfaces.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外观**：使用此模式简化更大更复杂的接口。'
- en: '**Flyweight**:Use this pattern to conserve memory and pass shared data between
    objects.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**享元**：使用此模式节省内存并在对象之间传递共享数据。'
- en: '**Proxy**:Use this pattern between a client and an API to intercept calls between
    the client and the API.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理**：在客户端和 API 之间使用此模式拦截客户端和 API 之间的调用。'
- en: We have already touched on the adapter, decorator, and proxy patterns in previous
    chapters, so they won't be covered again in this chapter. Now, we'll start implementing
    our structural design patterns, starting with the bridge pattern.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的章节中提到了适配器、装饰器和代理模式，所以本章不会再涉及它们。现在，我们将开始实现我们的结构设计模式，首先是桥接模式。
- en: Implementing the bridge pattern
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现桥接模式
- en: We use the bridge pattern to decouple abstractions from their implementations
    so that they are not bound at compile time. Both the abstraction and implementation
    can vary without impacting the client.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用桥接模式来解耦抽象和实现，使它们在编译时不受限制。抽象和实现都可以在不影响客户端的情况下变化。
- en: 'Use the bridge design pattern if you require runtime binding of the implementation
    or sharing of the implementation between multiple objects, if a number of classes
    exist as a result of interface coupling and various implementations, or if there
    is a need for orthogonal class hierarchies to be mapped:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在实现之间进行运行时绑定，或者在多个对象之间共享实现，如果一些类由于接口耦合和各种实现而存在，或者需要将正交类层次结构映射到一起，则使用桥接设计模式：
- en: '![](img/0574df48-c539-4718-9969-5c743b1edccb.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0574df48-c539-4718-9969-5c743b1edccb.png)'
- en: 'The participants of the bridge design pattern are as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接设计模式的参与者如下：
- en: '`Abstraction`: An abstract class that contains abstract operations'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Abstraction`：包含抽象操作的抽象类'
- en: '`RefinedAbstraction`: Inherits the `Abstraction` class and overrides the `Operation()`
    method'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RefinedAbstraction`：继承`Abstraction`类并重写`Operation()`方法'
- en: '`Implementor`: An abstract class with an abstract `Operation()` method'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Implementor`：一个带有抽象`Operation()`方法的抽象类'
- en: '`ConcreteImplementor`: Inherits the `Implementor` class and overrides the `Operation()`
    method'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteImplementor`：继承`Implementor`类并重写`Operation()`方法'
- en: 'We will now implement the bridge design pattern:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将实现桥接设计模式：
- en: 'Start by adding the `StructuralDesignPatterns` folder to the project, and then
    in that folder, add the `Bridge` folder. Then, add the `Implementor` class:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先将`StructuralDesignPatterns`文件夹添加到项目中，然后在该文件夹中添加`Bridge`文件夹。然后，添加`Implementor`类：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `Implementor` class has just a single abstract method, called `Operation()`.
    Add the `Abstraction` class:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Implementor`类只有一个名为`Operation()`的抽象方法。添加`Abstraction`类：'
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `Abstraction` class has a protected field that holds the `Implementor`
    object, which is set via the `Implementor` property. A virtual method called `Operation()`
    calls the `Operation()` method on the implementor. Add the `RefinedAbstraction`
    class:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Abstraction`类有一个受保护的字段，保存着`Implementor`对象，该对象是通过`Implementor`属性设置的。一个名为`Operation()`的虚方法调用了实现者的`Operation()`方法。添加`RefinedAbstraction`类：'
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `RefinedAbstraction` class inherits the `Abstraction` class and overrides
    the `Operation()` method to call the `Operation()` method on the implementor.
    Now, add the `ConcreteImplementor` class:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RefinedAbstraction`类继承了`Abstraction`类，并重写了`Operation()`方法以调用实现者的`Operation()`方法。现在，添加`ConcreteImplementor`类：'
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `ConcreteImplementor` class inherits the `Implementor` class and overrides
    the `Operation()` method to print out a message to the console. The code to run
    the bridge design pattern example is as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ConcreteImplementor`类继承了`Implementor`类，并重写了`Operation()`方法以在控制台打印消息。运行桥接设计模式示例的代码如下：'
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We create a new `RefinedAbstraction` instance and then set its implementor
    to a new instance of `ConcreteImplementor`. Then, we call the `Operation()` method.
    The output from our example bridge implementation is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的`RefinedAbstraction`实例，然后将其实现者设置为`ConcreteImplementor`的新实例。然后，我们调用`Operation()`方法。我们示例桥接实现的输出如下：
- en: '![](img/efd18efa-a5c2-4060-8e20-6848a4a241b0.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/efd18efa-a5c2-4060-8e20-6848a4a241b0.png)'
- en: As you can see, we successfully executed the concrete operation in the concrete
    implementor class. The next pattern we will look at is the composite design pattern.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们成功地在具体实现者类中执行了具体操作。我们接下来要看的模式是组合设计模式。
- en: Implementing the composite pattern
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现组合模式
- en: With the composite design pattern, objects are composed of tree structures to
    represent part-whole hierarchies. This pattern enables you to treat individual
    objects and compositions of objects in a uniform manner.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组合设计模式，对象由树结构组成，以表示部分-整体的层次结构。这种模式使您能够以统一的方式处理单个对象和对象的组合。
- en: 'Use this pattern when you need to ignore the differences between individual
    objects and object compositions, when you need tree structures to represent hierarchies,
    and when a hierarchical structure requires generic functionality across its structure:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要忽略单个对象和对象组合之间的差异，需要树结构来表示层次结构，以及需要在整个结构中具有通用功能时，请使用此模式：
- en: '![](img/049f16d8-1fd9-4029-98a0-6619358ea800.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/049f16d8-1fd9-4029-98a0-6619358ea800.png)'
- en: 'The participants in the composite design pattern are as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 组合设计模式的参与者如下：
- en: '`Component`: Composed objects interface'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Component`：组合对象接口'
- en: '`Leaf`: A leaf in the composition that has no children'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Leaf`：组合中没有子节点的叶子'
- en: '`Composite`: Stores child components and performs operations'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Composite`：存储子组件并执行操作'
- en: '`Client`: Manipulates compositions and leaves via the component interface'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Client`：通过组件接口操纵组合和叶子'
- en: 'It''s time to implement the composite pattern:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现组合模式了：
- en: 'Add a new folder called `Composite` to the `StructuralDesignPatterns` class.
    Then, add the `IComponent` interface:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StructuralDesignPatterns`类中添加一个名为`Composite`的新文件夹。然后，添加`IComponent`接口：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `IComponent` interface has a single method, which will be implemented by
    both leaves and composites. Add the `Leaf` class:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IComponent`接口有一个方法，将由叶子和组合实现。添加`Leaf`类：'
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `Leaf` class implements the `IComponent` interface. Its constructor takes
    a name and stores it, and the `PrintName()` method prints the name of the leaf
    to the console window. Add the `Composite` class:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Leaf`类实现了`IComponent`接口。它的构造函数接受一个名称并存储它，`PrintName()`方法将叶子的名称打印到控制台窗口。添加`Composite`类：'
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `Composite` class implements the `IComponent` interface in the same way
    that the leaf does. Additionally, `Composite` stores a list of components that
    are added via the `Add()` method. Its `PrintName()` method prints out its own
    name, followed by the names of each of the components in the list. Now, we''ll
    add the code to test our composite design pattern implementation:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Composite`类以与叶子相同的方式实现`IComponent`接口。此外，`Composite`通过`Add()`方法存储添加的组件列表。它的`PrintName()`方法打印出自己的名称，然后是列表中每个组件的名称。现在，我们将添加代码来测试我们的组合设计模式实现：'
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As you can see, we create our composites and then our leaves. We then add the
    leaves to the appropriate composites. Then, we add our composites to the root
    composite. Finally, we call the root composite''s `PrintName()` method, which
    will print the root''s name, along with the names of all the components and leaves
    in the hierarchy. You can see the output, as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，我们创建了我们的组合，然后创建了我们的叶子。然后，我们将叶子添加到适当的组合中。然后，我们将我们的组合添加到根组合中。最后，我们调用根组合的`PrintName()`方法，它将打印根的名称，以及层次结构中所有组件和叶子的名称。您可以看到输出如下：
- en: '![](img/574321bd-979c-4a81-b744-ebd47516e20a.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/574321bd-979c-4a81-b744-ebd47516e20a.png)'
- en: Our composite implementation is working as expected. The next pattern we will
    implement is the façade design pattern.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组合实现符合预期。我们将实现的下一个模式是外观设计模式。
- en: Implementing the façade pattern
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现外观模式
- en: The façade pattern is designed to make using API subsystems easier to use. Use
    this pattern to hide a large and complex system behind a much simpler interface
    for your clients to use. The main reason that programmers will implement this
    pattern is that the system they are having to use or work on is too complex and
    very hard to understand.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式旨在使使用API子系统更容易。使用此模式将大型复杂系统隐藏在更简单的接口后，以供客户端使用。程序员实现此模式的主要原因是，他们必须使用或处理的系统过于复杂且非常难以理解。
- en: 'Other reasons why this pattern is employed include if too many classes are
    dependent on one another, or simply because programmers don''t have access to
    the source code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 采用此模式的其他原因包括如果太多类相互依赖，或者仅仅是因为程序员无法访问源代码：
- en: '![](img/0060eca7-5fe5-47b2-830c-c9c350bf01b9.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0060eca7-5fe5-47b2-830c-c9c350bf01b9.png)'
- en: 'The participants in the façade pattern are as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式中的参与者如下：
- en: '`Facade`: The simple interface, which acts as a *go-between* between the client
    and a more complex system of subsystems'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Facade`：简单的接口，充当客户端和子系统更复杂系统之间的*中间人*'
- en: '`Subsystem Classes`: The subsystem classes, which are directly removed from
    client access and are directly accessed by the façade'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`子系统类`：子系统类直接从客户端访问中移除，并且由外观直接访问'
- en: 'We are now going to implement the façade design pattern:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将实现外观设计模式：
- en: 'Add a folder called `Facade` to the `StructuralDesignPatterns` folder. Then,
    add the `SubsystemOne` and `SubsystemTwo` classes:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StructuralDesignPatterns`文件夹中添加一个名为`Facade`的文件夹。然后，添加`SubsystemOne`和`SubsystemTwo`类：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'These classes have a single method that prints the class name and method name
    to the console window. Now, let''s add the `Facade` class:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些类有一个单一的方法，将类名和方法名打印到控制台窗口。现在，让我们添加`Facade`类：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `Facade` class creates member variables for each system that it has knowledge
    of. It then provides a series of methods that will access various portions of
    each of the subsystems when requested to do so. We will add the code to test our
    implementation:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Facade`类为其了解的每个系统创建成员变量。然后，它提供一系列方法，当请求时将访问各个子系统的各个部分。我们将添加代码来测试我们的实现：'
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'All we have to do is create a `Facade` variable, and then we can call the methods
    that execute method calls in the subsystems. You should see the following output:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需创建一个`Facade`变量，然后我们可以调用执行子系统中的方法调用的方法。您应该看到以下输出：
- en: '![](img/b3286287-919d-4e74-876f-339c5ff907a8.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3286287-919d-4e74-876f-339c5ff907a8.png)'
- en: Time to look at our final structural pattern called the flyweight pattern.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看我们最后的结构模式，即享元模式。
- en: Implementing the flyweight pattern
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现享元模式
- en: 'The flyweight design pattern is used to efficiently process a large number
    of fine-grained objects by reducing the overall object count. Use this pattern
    to increase performance and reduce the memory footprint by reducing the number
    of objects that you create:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 享元设计模式用于通过减少总体对象数量来高效处理大量细粒度对象。使用此模式可以通过减少创建的对象数量来提高性能并减少内存占用：
- en: '![](img/41f36825-87f9-43d4-a806-4ce797c3c5e4.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41f36825-87f9-43d4-a806-4ce797c3c5e4.png)'
- en: 'The participants in the flyweight design pattern are as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 享元设计模式中的参与者如下：
- en: '`Flyweight`: Provides an interface for flyweights so that they can receive
    an extrinsic state and act on it'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flyweight`：为享元提供接口，以便它们可以接收外在状态并对其进行操作'
- en: '`ConcreteFlyweight`: A sharable object that adds storage for the intrinsic
    state'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteFlyweight`：可共享的对象，为内在状态添加存储'
- en: '`UnsharedConcreteFlyweight`: Used when flyweights don''t need to be shared'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnsharedConcreteFlyweight`：当享元不需要共享时使用'
- en: '`FlyweightFactory`: Correctly manages flyweight objects and shares them properly'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FlyweightFactory`：正确管理享元对象并适当共享它们'
- en: '`Client`: Maintains flyweight references and computes or stores the extrinsic
    state of flyweights'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Client`：维护享元引用并计算或存储享元的外在状态'
- en: '**Extrinsic state** means that it is not part of the essential nature of the
    object and that it originates externally to the object. **Intrinsic state** means
    that the state belongs to the object and is essential to the object.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**外在状态**意味着它不是对象的基本特性的一部分，它是外部产生的。**内在状态**意味着状态属于对象并且对对象是必不可少的。'
- en: 'Let''s implement the flyweight design pattern:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现享元设计模式：
- en: 'Start by adding the `Flyweight` folder to the `StructuralDesignPatters` folder.
    Now, add the `Flyweight` class:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在`StructuralDesignPatters`文件夹中添加`Flyweight`文件夹。现在，添加`Flyweight`类：
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This class is abstract and contains an abstract method called `Operation()`,
    which is passed in the extrinsic state of the flyweight:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `ConcreteFlyweight` class inherits the `Flyweight` class and overrides
    the `Operation()` method. The method outputs the method name and its extrinsic
    state. Now, add the `FlyweightFactory` class:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In our particular flyweight example, we store our flyweight objects in a *hashtable*.
    Three flyweight objects are created in our constructor. Our `GetFlyweight()` method
    returns the flyweight for the specified key from the hashtable. Now, add the client:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'An extrinsic state can be anything you require it to be. In our example, we
    are using a string. We declare a new flyweight factory, add three flyweights,
    and execute the operation on each of them. Let''s add the code to test our implementation
    of the flyweight design pattern:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The code creates a new `Client` instance, and then calls the `ProcessFlyweights()`
    method. You should see the following:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d3ff3dd7-d9c1-4bfb-a08c-110456c3d3b9.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: Well, that's it for the structural patterns. Now it is time for us to look at
    implementing behavioral design patterns.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Overview of behavioral design patterns
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a programmer, your behavior on the team is governed by your methods of communication
    and interaction with other team members. The objects we program are no different.
    As programmers, we determine how objects will behave and communicate with other
    objects through the use of behavioral patterns. These behavioral patterns are
    as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '**Chain of responsibility**: A sequential pipeline of objects that process
    an incoming request.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command**: Encapsulates all the information that will be used to call a method
    at some point in time within an object.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interpreter**: Provides interpretation of a given grammar.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterator**: Use this pattern to access an aggregate object''s elements sequentially
    without exposing its underlying representation.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mediator**: Use this pattern to have objects communicate with each other
    via an intermediary.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memento**: Use this pattern to capture and save the object''s state.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observer**: Use this pattern to observe and be notified of changes in the
    object state of the object being observed.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State**: Use this pattern to alter the behavior of an object when its state
    changes.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategy**: Use this pattern to define a catalog of encapsulated algorithms
    that are interchangeable.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Template method**: Use this pattern to define an algorithm and the steps
    that can be overridden in subclasses.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visitor**: Use this pattern to add new operations to existing objects without
    modifying them.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Due to the constraints of this book, we don''t have enough pages left to cover
    the behavioral design patterns. With that in mind, I will direct you to the following
    books, which you can use to further your knowledge of design patterns. The first
    book is called *Design Patterns in C#: A Hands-on Guide with Real-World Examples*,
    by Vaskaring Sarcar, and published by Apress. The second book is called *Design
    Patterns in .NET: Reusable Approaches in C# and F# for Object-Oriented Software
    Design*, by Dmitri Nesteruk, also published by Apress. Published by Packt, the
    third book is called *Hands-On Design Patterns with C# and .NET Core*, by Gaurav
    Aroraa and Jeffrey Chilberto.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Between these books, you will not only come to understand all the patterns,
    but you will also gain exposure to real-world examples, which will help you transition
    from simply having head knowledge to having the practical skills to use design
    patterns in a reusable way in your own projects.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: That's it for our look at design pattern implementations. Before we summarize
    what we've learned, I'll leave you with some final thoughts on clean code and
    refactoring.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Final thoughts
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two types of software development—**brownfield development** and **greenfield
    development**. The majority of the code we work on throughout our careers will
    be brownfield development, which is the maintenance and extension of existing
    software, while greenfield development is the development, maintenance, and extension
    of new software. With greenfield software development, you are afforded the opportunity
    to write clean code from the start, and I encourage you to do just that.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发有两种类型——**brownfield开发**和**greenfield开发**。我们职业生涯中大部分时间都在进行brownfield开发，即维护和扩展现有软件，而greenfield开发则是新软件的开发、维护和扩展。在greenfield软件开发中，你有机会从一开始就编写清晰的代码，我鼓励你这样做。
- en: Make sure that projects are properly planned before you work on them. Then,
    employ the tools available to you to develop clean code with confidence. When
    it comes to brownfield development, you are best off spending time getting to
    know the system inside out before you maintain or extend it. Unfortunately, you
    may not always be in a situation where time affords you such luxury. So, there
    may be times when you will set about writing the code you need, not realizing
    that code already exists to do the task you are implementing. Keeping the code
    that you do write clean and well-structured will make for easier refactoring later
    on in the project.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在开始工作之前对项目进行适当规划。然后，利用可用的工具自信地开发清晰的代码。在进行brownfield开发时，最好花时间彻底了解系统，然后再进行维护或扩展。不幸的是，你可能并不总能有这样的时间。因此，有时你会开始编写你需要的代码，却没有意识到已经存在可以执行你正在实现的任务的代码。保持你编写的代码清晰和结构良好，将使项目后期的重构更加容易。
- en: Regardless of whether the project you are working on is a brownfield or greenfield
    project, it is down to you to ensure that you follow the company procedures. They
    are there for good reasons, those reasons being harmony between the development
    team and a clean code base. When you encounter unclean code within the code base,
    you should look to refactor it immediately.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你正在进行的项目是brownfield还是greenfield项目，你都要确保遵循公司的程序。这些程序存在是有充分理由的，即开发团队之间的和谐以及清晰的代码库。当你在代码库中遇到不清晰的代码时，应立即考虑进行重构。
- en: If the code is too complex to change immediately, and if too many changes across
    layers are necessary, then the change must be logged as technical debt on the
    project to be addressed at a later date after proper planning.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码太复杂而无法立即更改，且需要跨层进行太多更改，那么这些更改必须被记录为项目中的技术债务，待适当规划后再进行处理。
- en: 'At the end of the day, whether you call yourself a software architect, software
    engineer, software developer, or anything else, for that matter, your bread and
    butter is your *programming skills*. Bad programming can be detrimental to your
    current position, and can even negatively impact your ability to find new positions.
    So, employ every resource you have to ensure that your current code leaves a lasting
    good impression of your level of ability. I once heard someone say the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在一天结束时，无论你自称自己是软件架构师、软件工程师、软件开发人员，或者其他任何称谓，你的**编程技能**才是你的生计。糟糕的编程可能对你目前的职位有害，甚至可能对你找到新职位产生负面影响。因此，尽一切资源确保你当前的代码给人留下持久的良好印象，展现你的能力水平。我曾听人说过以下话：
- en: '*"You are only as good as your last programming assignment!"*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*"你的最后一个编程任务决定了你的水平！"*'
- en: It is important when architecting systems not to be *too clever* and build overly
    complex systems. Keep the depth of inheritance of your programs to no greater
    than 1, and do your best to reduce loops through utilizing functional programming
    techniques such as LINQ.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在架构系统时，不要过于聪明，不要构建过于复杂的系统。将程序的继承深度控制在1以内，并尽力通过利用LINQ等函数式编程技术来减少循环。
- en: You saw in [Chapter 13](0118b704-174c-4b2e-8f06-9238c871b559.xhtml), *Refactoring
    C# Code – Identifying Code Smells*, how LINQ is more performant than a `foreach`
    loop. Try to also reduce the complexity of your software by limiting the number
    of pathways through your computer program from the beginning to the end. Reduce
    boilerplate code by removing the boilerplate code to aspects that can be weaved
    into the code at compile time. This reduces the number of lines in your methods
    to only those lines that are the required business logic. Keep classes small and
    focused on only one responsibility. Also, keep methods to 10 lines of code or
    fewer. Classes and methods must only perform a single responsibility.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第13章](0118b704-174c-4b2e-8f06-9238c871b559.xhtml)中看到了，*重构C#代码——识别代码异味*，LINQ比`foreach`循环更高效。尽量减少软件的复杂性，限制计算机程序从开始到结束的路径数量。通过在编译时移除可以编织到代码中的样板代码，减少样板代码的数量。这样可以将方法中的行数减少到仅包含必要业务逻辑的行数。保持类小而专注于单一职责。同时，保持方法的代码行数不超过10行。类和方法必须只执行单一职责。
- en: Learn to keep the code you write simple so that it is easy to read and reason
    about. Understand the code you write. If you can easily understand your code,
    then you're fine. Now, ask yourself this: *after working on another project and
    coming back to this one, would you still understand the code with little or no
    effort?* When code is hard to understand, then it must be refactored and simplified.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 学会保持你编写的代码简单，以便易于阅读和理解。理解你所编写的代码。如果你能轻松理解自己的代码，那就没问题。现在，问问自己：*在另一个项目上工作后回到这个项目，你是否仍能轻松理解代码？*当代码难以理解时，就必须进行重构和简化。
- en: Failure to do this can result in a bloated system that dies a slow and agonizing
    death. Use documentation comments to document publicly accessible code. For hidden
    code, only use succinct and meaningful comments when the code does not adequately
    make sense by itself. Use patterns for common code that would often be repeated
    so that you **Don't Repeat Yourself** (**DRY**). Indentation within Visual Studio
    2019 is automatic, but the default indentation is not the same across different
    document types. Therefore, it is a good idea to make sure all documentation types
    have the same levels of indentation. Use the standard naming recommendations as
    suggested by Microsoft.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 不这样做可能会导致一个臃肿的系统，最终慢慢而痛苦地死去。使用文档注释来记录公开可访问的代码。对于隐藏的代码，只有在代码本身无法充分解释时才使用简洁而有意义的注释。对于经常重复的常见代码，使用模式以避免重复（DRY）。Visual
    Studio 2019中的缩进是自动的，但默认的缩进在不同的文档类型中并不相同。因此，确保所有文档类型具有相同级别的缩进是一个好主意。使用微软建议的标准命名规范。
- en: Give yourself programming challenges to solve without copying and pasting other
    people's source code. Use benchmarking (profiling) to rewrite the same code with
    the aim of reducing processing time. Test your code often to ensure it is behaving
    and doing what it is supposed to. Finally, practice, practice, and then practice
    some more.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 给自己一些编程挑战，不要复制粘贴他人的源代码。使用基准测试（性能分析）来重写相同的代码，以减少处理时间。经常测试你的代码，确保它表现正常并完成了它应该完成的任务。最后，练习，练习，然后再练习。
- en: We all change our programming styles over time. Some programmers' code will
    deteriorate over time if they are within a team of programmers that adopts a lot
    of poor practices. Other programmers' code will improve over time if they are
    within a team of programmers that adopts a lot of best practices. Don't forget,
    just because code compiles and does what it is meant to, it does not necessarily
    mean that it is the cleanest or most performant code.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都会随着时间改变自己的编程风格。如果在一个采用了许多不良实践的团队中，一些程序员的代码会随着时间的推移而恶化。而另一些程序员的代码会随着时间的推移而改善，如果他们在一个采用了许多最佳实践的团队中。不要忘记，仅仅因为代码能编译并且能够完成其预期功能，并不一定意味着它是最清晰或者最高效的代码。
- en: Your aim as a computer programmer is to write clean and efficient code that
    is easy to read, reason, maintain, and expand. Practice implementing TDD and BDD,
    along with the software paradigms of KISS, SOLID, YAGNI, and DRY.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名计算机程序员，你的目标是编写清晰高效的代码，易于阅读、理解、维护和扩展。练习实施TDD和BDD，以及KISS、SOLID、YAGNI和DRY的软件范式。
- en: Consider checking out some old code from GitHub to use as a training opportunity
    in migration of old .NET versions to new .NET versions, and refactoring the code
    to make it clean and performant, as well as adding documentation comments to produce
    API documentation for the development team. This is good practice for honing your
    personal computer programming skills. By doing this, you can often come across
    some rather clever code that you can personally learn from. Other times, it can
    be a case of wondering what the programmer was thinking at the time! But either
    way, improving your clean coding skills at every opportunity you have will only
    work toward making you a stronger and better programmer.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑从GitHub上检出一些旧的代码，作为将旧的.NET版本迁移到新的.NET版本的培训机会，并重构代码以使其清晰高效，并添加文档注释以为开发团队生成API文档。这对磨练个人计算机编程技能是一个很好的实践。通过这样做，你经常会遇到一些相当聪明的代码，可以从中学习。有时，你可能会想知道程序员当时在想什么！但无论如何，利用每一个机会来提高你的清晰编码技能只会使你变得更强大、更优秀的程序员。
- en: 'Another saying that I believe to be true in the field of programming is as
    follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信编程领域的另一句话是：
- en: '"To become a true expert computer programmer, you have to push yourself beyond
    what you are currently capable of doing."'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: “要成为真正的专业计算机程序员，你必须超越目前的能力。”
- en: So, no matter how expert you or your peers consider you to be, always remember
    that you can do even better. Therefore, keep pushing forward and upping your game.
    Then, when you retire, you can look back on your career with a righteous pride
    in your wonderful accomplishments as a computer programmer!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论你或你的同行认为你有多么专业，永远记住你可以做得更好。因此，不断前进，提高自己的水平。然后，当你退休时，你可以以一名计算机程序员的辉煌成就为荣，回顾你的职业生涯！
- en: Let's now summarise what we have learned in this chapter.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们总结一下我们在本章学到的内容。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered several creational, structural, and behavioral design
    patterns. You used the knowledge that you gained in this chapter to look at legacy
    code and understand its goal. Then, you used the patterns that you learned to
    implement in this chapter to refactor existing code and make it easier to read,
    reason, maintain, and extend. By using the patterns in this book, and the many
    others that are available to you, you can refactor existing code and write clean
    code from the start.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了几种创建型、结构型和行为型设计模式。你利用本章学到的知识来查看遗留代码并理解其目标。然后，你使用本章学到的模式来重构现有代码，使其更易于阅读、理解、维护和扩展。通过使用本书中的模式以及其他可用的模式，你可以重构现有代码并从一开始编写清晰的代码。
- en: You also used the creational design patterns to solve real-world problems and
    to improve the efficiency of your code. Use structural design patterns to improve
    the overall structure of code and improve relations between objects. Also, use
    behavioral design patterns to improve communication between objects whilst maintaining
    the decoupling of those objects.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你还使用了创建型设计模式来解决现实世界的问题，并提高了代码的效率。使用结构型设计模式来改善代码的整体结构和对象之间的关系。此外，使用行为设计模式来改善对象之间的通信，同时保持这些对象的解耦。
- en: Well, this is the end of the chapter, and I thank you for taking the time to
    read this book and work through the code examples. Remember, software should be
    a joy to work with. As such, we don't need unclean code causing problems for our
    business, its development and support teams, and for the customers of the software.
    So, think about the code you are writing, and always strive to be a better programmer
    than you are today—no matter how many years you have been in the industry. There
    is an old saying: *no matter how good you are, you can always do better*!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这是本章的结束，我感谢你抽出时间阅读这本书并通过代码示例进行学习。记住，软件应该是一种愉悦的工作。因此，我们不需要不洁净的代码给我们的业务、开发和支持团队以及软件的客户带来问题。因此，请考虑你正在编写的代码，并始终努力成为比今天更好的程序员——无论你在这个行业已经工作了多少年。有一句古话：*无论你有多优秀，你总是可以做得更好*！
- en: Let's test your knowledge on the contents of this chapter, and then I will leave
    you with some further reading. Happy clean coding in C#!
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下你对本章内容的了解，然后我会给你一些进一步阅读的建议。祝你在C#中编写干净的代码！
- en: Questions
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are GoF patterns and why would we use them?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GoF模式是什么，为什么我们要使用它们？
- en: Explain what creational design patterns are used for and list them.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释创建设计模式的用途并列举它们。
- en: Explain what structural design patterns are used for and them.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释结构设计模式的用途并列举它们。
- en: Explain what behavioral design patterns are used for and list them.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释行为设计模式的用途并列举它们。
- en: Is it possible to overuse design patterns and call code smells?
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可能过度使用设计模式并称之为代码异味？
- en: Describe the singleton design pattern and when you'd use it.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述单例设计模式以及何时使用它。
- en: Why would we use factory methods?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们要使用工厂方法？
- en: What design pattern would you use to hide the complexity of a system that is
    large and difficult to use?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用什么设计模式来隐藏一个庞大且难以使用的系统的复杂性？
- en: How can you minimize memory usage and share common data between objects?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何最小化内存使用并在对象之间共享公共数据？
- en: What pattern is used to decouple an abstraction from its implementation?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于将抽象与其实现解耦的模式是什么？
- en: How can you construct multiple representations of the same complex object?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何构建同一复杂对象的多个表示？
- en: If you have an item that requires various stages of manipulation to get it into
    the required state, what pattern would you use and why?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你有一个需要经过多个阶段的操作才能将其转换为所需状态的项目，你会使用什么模式，为什么？
- en: Further reading
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Refactoring: Improving the Design of Existing Code*, by Martin Fowler'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重构：改善现有代码的设计*，作者：Martin Fowler'
- en: '*Refactoring at Scale*, by Maude Lemaire'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*规模化的重构*，作者：Maude Lemaire'
- en: '*Software Development, Design, and Coding: With Patterns, Debugging, Unit Testing,
    and Refactoring*, by John F. Dooley'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*软件开发、设计和编码：使用模式、调试、单元测试和重构*，作者：John F. Dooley'
- en: '*Refactoring for Software Design Smells*, by Girish Suryanarayana, Ganesh Samarthyam,
    and Tushar Sharma'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*软件设计异味的重构*，作者：Girish Suryanarayana, Ganesh Samarthyam和Tushar Sharma'
- en: '*Refactoring Databases: Evolutionary Database Design*,by Scott W. Ambler and
    Pramod J. Sadalage'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重构数据库：演进式数据库设计*，作者：Scott W. Ambler和Pramod J. Sadalage'
- en: '*Refactoring to Patterns*,by Joshua Kerievsky'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重构到模式*，作者：Joshua Kerievsky'
- en: '*C#7 and .NET Core 2.0 High Performance*, by Ovais Mehboob Ahmed Khan'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C#7和.NET Core 2.0高性能*，作者：Ovais Mehboob Ahmed Khan'
- en: '*Improving Your C# Skills*,by Ovais Mehboob Ahmed Khan, John Callaway, Clayton
    Hunt, and Rod Stephens'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提高你的C#技能*，作者：Ovais Mehboob Ahmed Khan, John Callaway, Clayton Hunt和Rod Stephens'
- en: '*Patterns of Enterprise Application Architecture*, by Martin Fowler'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*企业应用架构模式*，作者：Martin Fowler'
- en: '*Working Effectively with Legacy Code*,by Michael C. Feathers'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与遗留代码的有效工作*，作者：Michael C. Feathers'
- en: '[https://www.dofactory.com/products/dofactory-net](https://www.dofactory.com/products/dofactory-net):
    C# Design Pattern Framework for RAD by dofactory'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.dofactory.com/products/dofactory-net](https://www.dofactory.com/products/dofactory-net)：dofactory提供的用于RAD的C#设计模式框架'
- en: '*Hands-On Design Patterns with C# and .NET Core*, by Gaurav Aroraa and Jeffrey
    Chilberto'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用C#和.NET Core的设计模式实践*，作者：Gaurav Aroraa和Jeffrey Chilberto'
- en: '*Design Patterns Using C# and .NET Core*, by Dimitris Loukas'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用C#和.NET Core的设计模式*，作者：Dimitris Loukas'
- en: '*Design Patterns in C#: A Hands-on Guide with Real-World Examples*, by Vaskaring
    Sarcar'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C#中的设计模式：实际示例指南*，作者：Vaskaring Sarcar'

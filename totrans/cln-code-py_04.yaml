- en: The SOLID Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will continue to explore concepts of clean design applied
    to Python. In particular, we will review the so-called **SOLID** principles, and
    how to implement them in a Pythonic way. These principles entail a series of good
    practices to achieve better-quality software. In case some of us aren''t aware
    of what SOLID stands for, here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: Single responsibility principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: Open/closed principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: Liskov''s substitution principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: Interface segregation principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: Dependency inversion principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The goals of this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To become acquainted with SOLID principles for software design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To design software components that follow the single responsibility principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To achieve more maintainable code through the open/closed principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To implement proper class hierarchies in object-oriented design, by complying
    with Liskov's substitution principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To design with interface segregation and dependency inversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **single responsibility principle** (**SRP**) states that a software component
    (in general, a class) must have only one responsibility. The fact that the class
    has a sole responsibility means that it is in charge of doing just one concrete
    thing, and as a consequence of that, we can conclude that it must have only one
    reason to change.
  prefs: []
  type: TYPE_NORMAL
- en: Only if one thing on the domain problem changes will the class have to be updated.
    If we have to make modifications to a class, for different reasons, it means the
    abstraction is incorrect, and that the class has too many responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: As introduced in [Chapter 2](c6a1dd9e-e567-4254-b5cf-1033b8b89c3d.xhtml), *Pythonic
    Code*, this design principle helps us build more cohesive abstractions; objects
    that do one thing, and just one thing, well, following the Unix philosophy. What
    we want to avoid in all cases is having objects with multiple responsibilities
    (often called **god-objects**, because they know too much, or more than they should).
    These objects group different (mostly unrelated) behaviors, thus making them harder
    to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the smaller the class, the better.
  prefs: []
  type: TYPE_NORMAL
- en: The SRP is closely related to the idea of cohesion in software design, which
    we already explored in [Chapter 3](0aec97c9-5777-4cd5-8c76-134440c49402.xhtml),
    *General Traits of Good Code*, when we discussed separation of concerns in software.
    What we strive to achieve here is that classes are designed in such a way that
    most of their properties and their attributes are used by its methods, most of
    the time. When this happens, we know they are related concepts, and therefore
    it makes sense to group them under the same abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: In a way, this idea is somehow similar to the concept of normalization on relational
    database design. When we detect that there are partitions on the attributes or
    methods of the interface of an object, they might as well be moved somewhere else—it
    is a sign that they are two or more different abstractions mixed into one.
  prefs: []
  type: TYPE_NORMAL
- en: There is another way of looking at this principle. If, when looking at a class,
    we find methods that are mutually exclusive and do not relate to each other, they
    are the different responsibilities that have to be broken down into smaller classes.
  prefs: []
  type: TYPE_NORMAL
- en: A class with too many responsibilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we are going to create the case for an application that is
    in charge of reading information about events from a source (this could be log
    files, a database, or many more sources), and identifying the actions corresponding
    to each particular log.
  prefs: []
  type: TYPE_NORMAL
- en: 'A design that fails to conform to the SRP would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a2877df2-39ec-4056-b127-b0162883a1a4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Without considering the implementation, the code for the class might look in
    the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with this class is that it defines an interface with a set of methods
    that correspond to actions that are orthogonal: each one can be done independently
    of the rest.'
  prefs: []
  type: TYPE_NORMAL
- en: This design flaw makes the class rigid, inflexible, and error-prone because
    it is hard to maintain. In this example, each method represents a responsibility
    of the class. Each responsibility entails a reason why the class might need to
    be modified. In this case, each method represents one of the various reasons why
    the class will have to be modified.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the loader method, which retrieves the information from a particular
    source. Regardless of how this is done (we can abstract the implementation details
    here), it is clear that it will have its own sequence of steps, for instance connecting
    to the data source, loading the data, parsing it into the expected format, and
    so on. If any of this changes (for example, we want to change the data structure
    used for holding the data), the `SystemMonitor` class will need to change. Ask
    yourself whether this makes sense. Does a system monitor object have to change
    because we changed the representation of the data? No.
  prefs: []
  type: TYPE_NORMAL
- en: The same reasoning applies to the other two methods. If we change how we fingerprint
    events, or how we deliver them to another data source, we will end up making changes
    to the same class.
  prefs: []
  type: TYPE_NORMAL
- en: It should be clear by now that this class is rather fragile, and not very maintainable.
    There are lots of different reasons that will impact on changes in this class.
    Instead, we want external factors to impact our code as little as possible. The
    solution, again, is to create smaller and more cohesive abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: Distributing responsibilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make the solution more maintainable, we separate every method into a different
    class. This way, each class will have a single responsibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cdac0d5f-a04e-4839-990d-03d6753720b0.png)'
  prefs: []
  type: TYPE_IMG
- en: The same behavior is achieved by using an object that will interact with instances
    of these new classes, using those objects as collaborators, but the idea remains
    that each class encapsulates a specific set of methods that are independent of
    the rest. The idea now is that changes on any of these classes do not impact the
    rest, and all of them have a clear and specific meaning. If we need to change
    something on how we load events from the data sources, the alert system is not
    even aware of these changes, so we do not have to modify anything on the system
    monitor (as long as the contract is still preserved), and the data target is also
    unmodified.
  prefs: []
  type: TYPE_NORMAL
- en: Changes are now local, the impact is minimal, and each class is easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: The new classes define interfaces that are not only more maintainable but also
    reusable. Imagine that now, in another part of the application, we also need to
    read the activity from the logs, but for different purposes. With this design,
    we can simply use objects of type `ActivityReader` (which would actually be an
    interface, but for the purposes of this section, that detail is not relevant and
    will be explained later for the next principles). This would make sense, whereas
    it would not have made sense in the previous design, because attempts to reuse
    the only class we had defined would have also carried extra methods (such as `identify_events()`,
    or `stream_events()`) that were not needed at all.
  prefs: []
  type: TYPE_NORMAL
- en: One important clarification is that the principle does not mean at all that
    each class must have a single method. Any of the new classes might have extra
    methods, as long as they correspond to the same logic that that class is in charge
    of handling.
  prefs: []
  type: TYPE_NORMAL
- en: The open/closed principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **open/closed principle** (**OCP**) states that a module should be both
    open and closed (but with respect to different aspects).
  prefs: []
  type: TYPE_NORMAL
- en: When designing a class, for instance, we should carefully encapsulate the logic
    so that it has good maintenance, meaning that we will want it to be **open to
    extension but closed for modification.**
  prefs: []
  type: TYPE_NORMAL
- en: What this means in simple terms is that, of course, we want our code to be extensible,
    to adapt to new requirements, or changes in the domain problem. This means that,
    when something new appears on the domain problem, we only want to add new things
    to our model, not change anything existing that is closed to modification.
  prefs: []
  type: TYPE_NORMAL
- en: If, for some reason, when something new has to be added, we found ourselves
    modifying the code, then that logic is probably poorly designed. Ideally, when
    requirements change, we want to just have to extend the module with the new required
    behavior in order to comply with the new requirements, but without having to modify
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: This principle applies to several software abstractions. It could be a class
    or even a module. In the following two subsections, we will see examples of each
    one, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Example of maintainability perils for not following the open/closed principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin with an example of a system that is designed in such a way that
    does not follow the open/closed principle, in order to see the maintainability
    problems this carries, and the inflexibility of such a design.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that we have a part of the system that is in charge of identifying
    events as they occur in another system, which is being monitored. At each point,
    we want this component to identify the type of event, correctly, according to
    the values of the data that was previously gathered (for simplicity, we will assume
    it is packaged into a dictionary, and was previously retrieved through another
    means such as logs, queries, and many more). We have a class that, based on this
    data, will retrieve the event, which is another type with its own hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'A first attempt to solve this problem might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the expected behavior of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can clearly notice the hierarchy of event types, and some business logic
    to construct them. For instance, when there was no previous flag for a session,
    but there is now, we identify that record as a login event. Conversely, when the
    opposite happens, it means that it was a logout event. If it was not possible
    to identify an event, an event of type unknown is returned. This is to preserve
    polymorphism by following the null object pattern (instead of returning `None`,
    it retrieves an object of the corresponding type with some default logic). The
    null object pattern is described in [Chapter 9](dee5b4ed-34cd-4077-a5b4-83d4853e6e56.xhtml), *Common
    Design Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: This design has some problems. The first issue is that the logic for determining
    the types of events is centralized inside a monolithic method. As the number of
    events we want to support grows, this method will as well, and it could end up
    being a very long method, which is bad because, as we have already discussed,
    it will not be doing just one thing and one thing well.
  prefs: []
  type: TYPE_NORMAL
- en: On the same line, we can see that this method is not closed for modification.
    Every time we want to add a new type of event to the system, we will have to change
    something in this method (not to mention, that the chain of `elif` statements
    will be a nightmare to read!).
  prefs: []
  type: TYPE_NORMAL
- en: We want to be able to add new types of event without having to change this method
    (closed for modification). We also want to be able to support new types of event
    (open for extension) so that when a new event is added, we only have to add code,
    not change the code that already exists.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the events system for extensibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem with the previous example was that the `SystemMonitor` class was
    interacting directly with the concrete classes it was going to retrieve.
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve a design that honors the open/closed principle, we have
    to design toward abstractions*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible alternative would be to think of this class as it collaborates with
    the events, and then we delegate the logic for each particular type of event to
    its corresponding class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cc55531b-bccd-4441-86a5-c3de785e5243.png)'
  prefs: []
  type: TYPE_IMG
- en: Then we have to add a new (polymorphic) method to each type of event with the
    single responsibility of determining if it corresponds to the data being passed
    or not, and we also have to change the logic to go through all events, finding
    the right one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the interaction is now oriented toward an abstraction (in this case,
    it would be the generic base class `Event`, which might even be an abstract base
    class or an interface, but for the purposes of this example it is enough to have
    a concrete base class). The method no longer works with specific types of event,
    but just with generic events that follow a common interface—they are all polymorphic
    with respect to the `meets_condition` method.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how events are discovered through the `__subclasses__()` method. Supporting
    new types of event is now just about creating a new class for that event that
    has to inherit from `Event` and implement its own `meets_condition()` method,
    according to its specific business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the events system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's prove that this design is actually as extensible as we wanted it
    to be. Imagine that a new requirement arises, and we have to also support events
    that correspond to transactions that the user executed on the monitored system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class diagram for the design has to include such a new event type, as in
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/870dd0e2-4e1f-416e-b4b6-415b4e0c1df1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Only by adding the code to this new class does the logic keep working as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify that the previous cases work as before and that the new event
    is also correctly identified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `SystemMonitor.identify_event()` method did not change at all
    when we added the new event type. We, therefore, say that this method is closed with
    respect to new types of event.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, the `Event` class allowed us to add a new type of event when we
    were required to do so. We then say that events are open for an extension with
    respect to new types.
  prefs: []
  type: TYPE_NORMAL
- en: This is the true essence of this principle—when something new appears on the
    domain problem, we only want to add new code, not modify existing code.
  prefs: []
  type: TYPE_NORMAL
- en: Final thoughts about the OCP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you might have noticed, this principle is closely related to effective use
    of polymorphism. We want to design toward abstractions that respect a polymorphic
    contract that the client can use, to a structure that is generic enough that extending
    the model is possible, as long as the polymorphic relationship is preserved.
  prefs: []
  type: TYPE_NORMAL
- en: 'This principle tackles an important problem in software engineering: maintainability
    .The perils of not following the OCP are ripple effects and problems in the software
    where a single change triggers changes all over the code base, or risks breaking
    other parts of the code.'
  prefs: []
  type: TYPE_NORMAL
- en: One important final note is that, in order to achieve this design in which we
    do not change the code to extend behavior, we need to be able to create proper
    closure against the abstractions we want to protect (in this example, new types
    of event). This is not always possible in all programs, as some abstractions might
    collide (for example, we might have a proper abstraction that provides closure
    against a requirement, but does not work for other types of requirements). In
    these cases, we need to be selective and apply a strategy that provides the best
    closure for the types of requirement that require to be the most extensible.
  prefs: []
  type: TYPE_NORMAL
- en: Liskov's substitution principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Liskov''s substitution principle** (**LSP**) states that there is a series
    of properties that an object type must hold to preserve reliability on its design.'
  prefs: []
  type: TYPE_NORMAL
- en: The main idea behind LSP is that, for any class, a client should be able to
    use any of its subtypes indistinguishably, without even noticing, and therefore
    without compromising the expected behavior at runtime. This means that clients
    are completely isolated and unaware of changes in the class hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'More formally, this is the original definition (LISKOV 01) of Liskov''s substitution
    principle: if *S* is a subtype of *T*, then objects of type *T* may be replaced
    by objects of type *S*, without breaking the program.'
  prefs: []
  type: TYPE_NORMAL
- en: This can be understood with the help of a generic diagram such as the following
    one. Imagine that there is some client class that requires (includes) objects
    of another type. Generally speaking, we will want this client to interact with
    objects of some type, namely, it will work through an interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this type might as well be just a generic interface definition, an abstract
    class or an interface, not a class with the behavior itself. There may be several
    subclasses extending this type (described in the diagram with the name **Subtype**,
    up to **N**). The idea behind this principle is that, if the hierarchy is correctly
    implemented, the client class has to be able to work with instances of any of
    the subclasses without even noticing. These objects should be interchangeable,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2f7cb18f-e8c5-489c-aa5b-274ce34faf97.png)'
  prefs: []
  type: TYPE_IMG
- en: This is related to other design principles we have already visited, like designing
    to interfaces. A good class must define a clear and concise interface, and as
    long as subclasses honor that interface, the program will remain correct.
  prefs: []
  type: TYPE_NORMAL
- en: As a consequence of this, the principle also relates to the ideas behind designing
    by contract. There is a contract between a given type and a client. By following
    the rules of LSP, the design will make sure that subclasses respect the contracts
    as they are defined by parent classes.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting LSP issues with tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some scenarios so notoriously wrong with respect to the LSP that they
    can be easily identified by the tools we have learned to configure in [Chapter
    1](bba62a64-dfe9-478f-9b33-6c3240d75f59.xhtml), *Introduction, Code Formatting,
    and Tools* (mainly Mypy and Pylint).
  prefs: []
  type: TYPE_NORMAL
- en: Detecting incorrect datatypes in method signatures with Mypy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By using type annotations (as recommended previously in [Chapter 1](bba62a64-dfe9-478f-9b33-6c3240d75f59.xhtml),
    *Introduction, Code Formatting, and Tools*), throughout our code, and configuring
    Mypy, we can quickly detect some basic errors early, and check basic compliance
    with LSP for free.
  prefs: []
  type: TYPE_NORMAL
- en: 'If one of the subclasses of the `Event` class were to override a method in
    an incompatible fashion, Mypy would notice this by inspecting the annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run Mypy on this file, we will get an error message saying the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The violation to LSP is clear—since the derived class is using a type for the
    `event_data` parameter which is different from the one defined on the base class,
    we cannot expect them to work equally. Remember that, according to this principle,
    any caller of this hierarchy has to be able to work with `Event` or `LoginEvent`
    transparently, without noticing any difference. Interchanging objects of these
    two types should not make the application fail. Failure to do so would break the
    polymorphism on the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: The same error would have occurred if the return type was changed for something
    other than a Boolean value. The rationale is that clients of this code are expecting
    a Boolean value to work with. If one of the derived classes changes this return
    type, it would be breaking the contract, and again, we cannot expect the program
    to continue working normally.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick note about types that are not the same but share a common interface:
    even though this is just a simple example to demonstrate the error, it is still
    true that both dictionaries and lists have something in common; they are both
    iterables. This means that in some cases, it might be valid to have a method that
    expects a dictionary and another one expecting to receive a list, as long as both
    treat the parameters through the iterable interface. In this case, the problem
    would not lie in the logic itself (LSP might still apply), but in the definition
    of the types of the signature, which should read neither `list` nor `dict`, but
    a union of both. Regardless of the case, something has to be modified, whether
    it is the code of the method, the entire design, or just the type annotations,
    but in no case should we silence the warning and ignore the error given by Mypy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Do not ignore errors such as this by using `# type: ignore` or something similar.
    Refactor or change the code to solve the real problem. The tools are reporting
    an actual design flaw for a valid reason.'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting incompatible signatures with Pylint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another strong violation of LSP is when, instead of varying the types of the
    parameters on the hierarchy, the signatures of the methods differ completely.
    This might seem like quite a blunder, but detecting it would not always be so
    easy to remember; Python is interpreted, so there is no compiler to detect these
    type of error early on, and therefore they will not be caught until runtime. Luckily,
    we have static code analyzers such as Mypy and Pylint to catch errors such as
    this one early on.
  prefs: []
  type: TYPE_NORMAL
- en: While Mypy will also catch these type of error, it is not bad to also run Pylint
    to gain more insight.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the presence of a class that breaks the compatibility defined by the hierarchy
    (for example, by changing the signature of the method, adding an extra parameter,
    and so on) shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Pylint will detect it, printing an informative error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Once again, like in the previous case, do not suppress these errors. Pay attention
    to the warnings and errors the tools give and adapt the code accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: More subtle cases of LSP violations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In other cases, however, the way LSP is broken is not so clear or obvious that
    a tool can automatically identify it for us, and we have to rely upon careful
    code inspection when doing a code review.
  prefs: []
  type: TYPE_NORMAL
- en: Cases where contracts are modified are particularly harder to detect automatically.
    Given that the entire idea of LSP is that subclasses can be used by clients just
    like their parent class, it must also be true that contracts are correctly preserved
    on the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Remember from [Chapter 3,](0aec97c9-5777-4cd5-8c76-134440c49402.xhtml) *General
    Traits of Good Code*, that, when designing by contract, the contract between the
    client and supplier sets some rules—the client must provide the preconditions
    to the method, which the supplier might validate, and it returns some result to
    the client that it will check in the form of postconditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parent class defines a contract with its clients. Subclasses of this one
    must respect such a contract. This means that, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: A subclass can never make preconditions stricter than they are defined on the
    parent class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A subclass can never make postconditions weaker than they are defined on the
    parent class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider the example of the events hierarchy defined in the previous section,
    but now with a change to illustrate the relationship between LSP and DbC.
  prefs: []
  type: TYPE_NORMAL
- en: This time, we are going to assume a precondition for the method that checks
    the criteria based on the data, that the provided parameter must be a dictionary
    that contains both keys `"before"` and `"after"`, and that their values are also
    nested dictionaries. This allows us to encapsulate even further, because now the
    client does not need to catch the `KeyError` exception, but instead just calls
    the precondition method (assuming that is acceptable to fail if the system is
    operating under the wrong assumptions). As a side note, it is good that we can
    remove this from the client, as now, `SystemMonitor` does not require to know
    which types of exceptions the methods of the collaborator class might raise (remember
    that exception weaken encapsulation, as they require the caller to know something
    extra about the object they are calling).
  prefs: []
  type: TYPE_NORMAL
- en: 'Such a design might be represented with the following changes in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And now the code that tries to detect the correct event type just checks the
    precondition once, and proceeds to find the right type of event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The contract only states that the top-level keys `"before"` and `"after"` are
    mandatory and that their values should also be dictionaries. Any attempt in the
    subclasses to demand a more restrictive parameter will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class for the transaction event was originally correctly designed. Look
    at how the code does not impose a restriction on the internal key named `"transaction"`;
    it only uses its value if it is there, but this is not mandatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: However, the original two methods are not correct, because they demand the presence
    of a key named `"session"`, which is not part of the original contract. This breaks
    the contract, and now the client cannot use these classes in the same way it uses
    the rest of them because it will raise `KeyError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After fixing this (changing the square brackets for the `.get()` method), the
    order on the LSP has been reestablished, and polymorphism prevails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It is unreasonable to expect automated tools (regardless of how good and helpful
    they are), will detect cases such as this one. We have to be careful when designing
    classes that we do not accidentally change the input or output of the methods
    in a way that would be incompatible with what the clients are originally expecting.
  prefs: []
  type: TYPE_NORMAL
- en: Remarks on the LSP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The LSP is fundamental to a good object-oriented software design because it
    emphasizes one of its core traits—polymorphism. It is about creating correct hierarchies
    so that classes derived from a base one are polymorphic along the parent one,
    with respect to the methods on their interface.
  prefs: []
  type: TYPE_NORMAL
- en: It is also interesting to notice how this principle relates to the previous
    one—if we attempt to extend a class with a new one that is incompatible, it will
    fail, the contract with the client will be broken, and as a result such an extension
    will not be possible (or, to make it possible, we would have to break the other
    end of the principle and modify code in the client that should be closed for modification,
    which is completely undesirable and unacceptable).
  prefs: []
  type: TYPE_NORMAL
- en: Carefully thinking about new classes in the way that LSP suggests helps us to
    extend the hierarchy correctly. We could then say that LSP contributes to the
    OCP.
  prefs: []
  type: TYPE_NORMAL
- en: Interface segregation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **interface segregation principle** (**ISP**) provides some guidelines
    over an idea that we have revisited quite repeatedly already: that interfaces
    should be small.'
  prefs: []
  type: TYPE_NORMAL
- en: In object-oriented terms, an **interface** is represented by the set of methods
    an object exposes. This is to say that all the messages that an object is able
    to receive or interpret constitute its interface, and this is what other clients
    can request. The interface separates the definition of the exposed behavior for
    a class from its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, interfaces are implicitly defined by a class according to its methods.
    This is because Python follows the so-called **duck typing** principle.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, the idea behind duck typing was that any object is really represented
    by the methods it has, and by what it is capable of doing. This means that, regardless
    of the type of the class, its name, its docstring, class attributes, or instance
    attributes, what ultimately defines the essence of the object are the methods
    it has. The methods defined on a class (what it knows how to do) are what determines
    what that object will actually be. It was called duck typing because of the idea
    that "If it walks like a duck, and quacks like a duck, it must be a duck."
  prefs: []
  type: TYPE_NORMAL
- en: For a long time, duck typing was the sole way interfaces were defined in Python.
    Later on, Python 3 (PEP-3119) introduced the concept of abstract base classes
    as a way to define interfaces in a different way. The basic idea of abstract base
    classes is that they define a basic behavior or interface that some derived classes
    are responsible for implementing. This is useful in situations where we want to
    make sure that certain critical methods are actually overridden, and it also works
    as a mechanism for overriding or extending the functionality of methods such as
    `isinstance()`.
  prefs: []
  type: TYPE_NORMAL
- en: This module also contains a way of registering some types as part of a hierarchy,
    in what is called a **virtual subclass**. The idea is that this extends the concept
    of duck typing a little bit further by adding a new criterion—walks like a duck,
    quacks like a duck, or... it says it is a duck.
  prefs: []
  type: TYPE_NORMAL
- en: These notions of how Python interprets interfaces are important for understanding
    this principle and the next one.
  prefs: []
  type: TYPE_NORMAL
- en: In abstract terms, this means that the ISP states that, when we define an interface
    that provides multiple methods, it is better to instead break it down into multiple
    ones, each one containing fewer methods (preferably just one), with a very specific
    and accurate scope. By separating interfaces into the smallest possible units,
    to favor code reusability, each class that wants to implement one of these interfaces
    will most likely be highly cohesive given that it has a quite definite behavior
    and set of responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: An interface that provides too much
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we want to be able to parse an event from several data sources, in different
    formats (XML and JSON, for instance). Following good practice, we decide to target
    an interface as our dependency instead of a concrete class, and something like
    the following is devised:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/751713a3-59f5-476d-8481-80da4896f722.png)'
  prefs: []
  type: TYPE_IMG
- en: In order to create this as an interface in Python, we would use an abstract
    base class and define the methods (`from_xml()` and `from_json()`) as abstract,
    to force derived classes to implement them. Events that derive from this abstract
    base class and implement these methods would be able to work with their corresponding
    types.
  prefs: []
  type: TYPE_NORMAL
- en: But what if a particular class does not need the XML method, and can only be
    constructed from a JSON? It would still carry the `from_xml()` method from the
    interface, and since it does not need it, it will have to pass. This is not very
    flexible as it creates coupling and forces clients of the interface to work with
    methods that they do not need.
  prefs: []
  type: TYPE_NORMAL
- en: The smaller the interface, the better
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It would be better to separate this into two different interfaces, one for
    each method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/979e5d6b-abc5-48da-9353-5bce32fea19f.png)'
  prefs: []
  type: TYPE_IMG
- en: With this design, objects that derive from `XMLEventParser` and implement the
    `from_xml()` method will know how to be constructed from an XML, and the same
    for a JSON file, but most importantly, we maintain the orthogonality of two independent
    functions, and preserve the flexibility of the system without losing any functionality
    that can still be achieved by composing new smaller objects.
  prefs: []
  type: TYPE_NORMAL
- en: There is some resemblance to the SRP, but the main difference is that here we
    are talking about interfaces, so it is an abstract definition of behavior. There
    is no reason to change because there is nothing there until the interface is actually
    implemented. However, failure to comply with this principle will create an interface
    that will be coupled with orthogonal functionality, and this derived class will
    also fail to comply with the SRP (it will have more than one reason to change).
  prefs: []
  type: TYPE_NORMAL
- en: How small should an interface be?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The point made in the previous section is valid, but it also needs a warning—avoid
    a dangerous path if it's misunderstood or taken to the extreme.
  prefs: []
  type: TYPE_NORMAL
- en: A base class (abstract or not) defines an interface for all the other classes
    to extend it. The fact that this should be as small as possible has to be understood
    in terms of cohesion—it should do one thing. That doesn't mean it must necessarily
    have one method. In the previous example, it was by coincidence that both methods
    were doing totally disjoint things, hence it made sense to separate them into
    different classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'But it could be the case that more than one method rightfully belongs to the
    same class. Imagine that you want to provide a mixin class that abstracts certain
    logic in a context manager so that all classes derived from that mixin gain that
    context manager logic for free. As we already know, a context manager entails
    two methods: `__enter__` and `__exit__`. They must go together, or the outcome
    will not be a valid context manager at all!'
  prefs: []
  type: TYPE_NORMAL
- en: Failure to place both methods in the same class will result in a broken component
    that is not only useless, but also misleadingly dangerous. Hopefully, this exaggerated
    example works as a counter-balance to the one in the previous section, and together
    the reader can get a more accurate picture about designing interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency inversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a really powerful idea that will come up again later when we explore
    some design patterns in [Chapter 9](dee5b4ed-34cd-4077-a5b4-83d4853e6e56.xhtml), *Common
    Design Patterns*,and [Chapter 10](87530c54-bf97-48c2-a557-de448cd690d4.xhtml), *Clean
    Architecture*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **dependency inversion principle** (**DIP**) proposes an interesting design
    principle by which we protect our code by making it independent of things that
    are fragile, volatile, or out of our control. The idea of inverting dependencies
    is that our code should not adapt to details or concrete implementations, but
    rather the other way around: we want to force whatever implementation or detail
    to adapt to our code via a sort of API.'
  prefs: []
  type: TYPE_NORMAL
- en: Abstractions have to be organized in such a way that they do not depend on details,
    but rather the other way around—the details (concrete implementations) should
    depend on abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that two objects in our design need to collaborate, `A` and `B`. `A`
    works with an instance of `B`, but as it turns out, our module doesn''t control
    `B` directly (it might be an external library, or a module maintained by another
    team, and so on). If our code heavily depends on `B`, when this changes the code
    will break. To prevent this, we have to invert the dependency: make `B` have to
    adapt to `A`. This is done by presenting an interface and forcing our code not
    to depend on the concrete implementation of `B`, but rather on the interface we
    have defined. It is then `B`''s responsibility to comply with that interface.'
  prefs: []
  type: TYPE_NORMAL
- en: In line with the concepts explored in previous sections, abstractions also come
    in the form of interfaces (or abstract base classes in Python).
  prefs: []
  type: TYPE_NORMAL
- en: In general, we could expect concrete implementations to change much more frequently
    than abstract components. It is for this reason that we place abstractions (interfaces)
    as flexibility points where we expect our system to change, be modified, or extended
    without the abstraction itself having to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: A case of rigid dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last part of our event''s monitoring system is to deliver the identified
    events to a data collector to be further analyzed. A naive implementation of such
    an idea would consist of having an event streamer class that interacts with a
    data destination, for example, `Syslog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/27118de7-913e-4957-94b4-f3b2394f2006.png)'
  prefs: []
  type: TYPE_IMG
- en: However, this design is not very good, because we have a high-level class (`EventStreamer`)
    depending on a low-level one (`Syslog` is an implementation detail). If something
    changes in the way we want to send data to `Syslog`, `EventStreamer` will have
    to be modified. If we want to change the data destination for a different one
    or add new ones at runtime, we are also in trouble because we will find ourselves
    constantly modifying the `stream()` method to adapt it to these requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Inverting the dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The solution to these problems is to make `EventStreamer` work with an interface,
    rather than a concrete class. This way, implementing this interface is up to the
    low-level classes that contain the implementation details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/530270e6-552a-4c55-b49f-777b4ec37080.png)'
  prefs: []
  type: TYPE_IMG
- en: Now there is an interface that represents a generic data target where data is
    going to be sent to. Notice how the dependencies have now been inverted since `EventStreamer`
    does not depend on a concrete implementation of a particular data target, it does
    not have to change in line with changes on this one, and it is up to every particular
    data target; to implement the interface correctly and adapt to changes if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the original `EventStreamer` of the first implementation only
    worked with objects of type `Syslog`, which was not very flexible. Then we realized
    that it could work with any object that could respond to a `.send()` message,
    and identified this method as the interface that it needed to comply with. Now,
    in this version, `Syslog` is actually extending the abstract base class named
    `DataTargetClient`, which defines the `send()` method. From now on, it is up to
    every new type of data target (email, for instance) to extend this abstract base
    class and implement the `send()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even modify this property at runtime for any other object that implements
    a `send()` method, and it will still work. This is the reason why it is often
    called **dependency injection**: because the dependency can be provided dynamically.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The avid reader might be wondering why this is actually necessary. Python is
    flexible enough (sometimes too flexible), and will allow us to provide an object
    like `EventStreamer` with any particular data target object, without this one
    having to comply with any interface because it is dynamically typed. The question
    is this: why do we need to define the abstract base class (interface) at all when
    we can simply pass an object with a `send()` method to it?'
  prefs: []
  type: TYPE_NORMAL
- en: In all fairness, this is true; there is actually no need to do that, and the
    program will work just the same. After all, polymorphism does not mean (or require)
    inheritance to work. However, defining the abstract base class is a good practice
    that comes with some advantages, the first one being duck typing. Together with
    as duck typing, we can mention the fact that the models become more readable—remember
    that inheritance follows the rule of **is a**, so by declaring the abstract base
    class and extending from it, we are saying that, for instance, `Syslog` is `DataTargetClient`,
    which is something users of your code can read and understand (again, this is
    duck typing).
  prefs: []
  type: TYPE_NORMAL
- en: All in all, it is not mandatory to define the abstract base class, but it is
    desirable in order to achieve a cleaner design. This is one of the things this
    book is for—to help programmers avoid easy-to-make mistakes, just because Python
    is too flexible and we can get away with it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The SOLID principles are key guidelines for good object-oriented software design.
  prefs: []
  type: TYPE_NORMAL
- en: Building software is an incredibly hard task—the logic of the code is complex,
    its behavior at runtime is hard (if even possible, sometimes) to predict, requirements
    change constantly as well as the environment, and there are multiple things that
    can go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, there are multiple ways of constructing software with different
    techniques, paradigms, and a lot of different designs, which can work together
    to solve a particular problem in a specific manner. However, not all of these
    approaches will prove to be correct as time passes, and requirements change or
    evolve. However, by this time, it will already be too late to do something about
    an incorrect design, as it is rigid, inflexible, and therefore hard to change
    a refactor into the proper solution.
  prefs: []
  type: TYPE_NORMAL
- en: This means that, if we get the design wrong, it will costs us a lot in the future.
    How can we then achieve a good design that will eventually pay off? The answer
    is that we do not know for sure. We are dealing with the future, and the future
    is uncertain—there is no way to determine if our design will be correct and if
    our software will be flexible and adaptable in years to come. It is precisely
    for that reason that we have to stick to principles.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the SOLID principles come into play. They are not a magic rule
    (after all, there are no silver bullets in software engineering), but they provide
    good guidelines to follow that have been proven to work in past projects and will
    make our software much more likely to succeed.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have explored the SOLID principles with the goal of understanding
    clean design. In the following chapters, we will continue to explore details of
    the language, and see in some cases how these tools and features can be used with
    these principles.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a list of information you may refer to:'
  prefs: []
  type: TYPE_NORMAL
- en: '*SRP 01*: The Single Responsibility Principle ([https://8thlight.com/blog/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html](https://8thlight.com/blog/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PEP-3119*: Introducing Abstract Base Classes ([https://www.python.org/dev/peps/pep-3119/](https://www.python.org/dev/peps/pep-3119/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*LISKOV 01*: A paper written by Barbara Liskov named *Data Abstraction and
    Hierarchy*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

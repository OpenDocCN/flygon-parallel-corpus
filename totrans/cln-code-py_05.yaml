- en: Using Decorators to Improve Our Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore decorators and see how they are useful in many
    situations where we want to improve our design. We will start by first exploring
    what decorators are, how they work, and how they are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, we will then revisit concepts that we learned in previous
    chapters regarding general good practices for software design, and see how decorators
    can help us comply with each principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goals of this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To understand how decorators work in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn how to implement decorators that apply to functions and classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To effectively implement decorators, avoiding common implementation mistakes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To analyze how to avoid code duplication (the DRY principle) with decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To study how decorators contribute to separation of concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To analyze examples of good decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To review common situations, idioms, or patterns for when decorators are the
    right choice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are decorators in Python?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decorators were introduced in Python a long time ago, in (PEP-318), as a mechanism
    to simplify the way functions and methods are defined when they have to be modified
    after their original definition.
  prefs: []
  type: TYPE_NORMAL
- en: One of the original motivations for this was because functions such as `classmethod`
    and `staticmethod` were used to transform the original definition of the method,
    but they required an extra line, modifying the original definition of the function.
  prefs: []
  type: TYPE_NORMAL
- en: More generally speaking, every time we had to apply a transformation to a function,
    we had to call it with the `modifier` function, and then reassign it to the same
    name the function was originally defined with.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we have a function called `original`, and then we have a function
    that changes the behavior of `original` on top of it, called `modifier`, we have
    to write something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we change the function and reassign it to the same name. This is
    confusing, error-prone (imagine that someone forgets to reassign the function,
    or does reassign that but not in the line immediately after the function definition,
    but much farther away), and cumbersome. For this reason, some syntax support was
    added to the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example could be rewritten like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This means that decorators are just syntax sugar for calling whatever is after
    the decorator as a first parameter of the decorator itself, and the result would
    be whatever the decorator returns.
  prefs: []
  type: TYPE_NORMAL
- en: In line with the Python terminology, and our example, `modifier` is what we
    call the decorator, and `original` is the decorated function, often also called
    a **wrapped** object.
  prefs: []
  type: TYPE_NORMAL
- en: While the functionality was originally thought for methods and functions, the
    actual syntax allows any kind of object to be decorated, so we are going to explore
    decorators applied to functions, methods, generators, and classes.
  prefs: []
  type: TYPE_NORMAL
- en: One final note is that, while the name of a decorator is correct (after all,
    the decorator is in fact, making changes, extending, or working on top of the
    `wrapped` function), it is not to be confused with the decorator design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Decorate functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are probably the simplest representation of a Python object that can
    be decorated. We can use decorators on functions to apply all sorts of logic to
    them—we can validate parameters, check preconditions, change the behavior entirely,
    modify its signature, cache results (create a memorized version of the original
    function), and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we will create a basic decorator that implements a `retry` mechanism,
    controlling a particular domain-level exception and retrying a certain number
    of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The use of `@wraps` can be ignored for now, as it will be covered in the section
    named *Effective decorators - avoiding common mistakes*. The use of `_` in the
    for loop, means that the number is assigned to a variable we are not interested
    in at the moment, because it's not used inside the for loop (it's a common idiom
    in Python to name `_` values that are ignored).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `retry` decorator doesn''t take any parameters, so it can be easily applied
    to any function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As explained at the beginning, the definition of `@retry` on top of `run_operation`
    is just syntactic sugar that Python provides to actually execute `run_operation
    = retry(run_operation)`.
  prefs: []
  type: TYPE_NORMAL
- en: In this limited example, we can see how decorators can be used to create a generic
    `retry` operation that, under certain conditions (in this case, represented as
    exceptions that could be related to timeouts, for example), will allow calling
    the decorated code multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Decorate classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes can also be decorated (PEP-3129) with the same as can be applied to
    syntax functions. The only difference is that when writing the code for this decorator,
    we have to take into consideration that we are receiving a class, not a function.
  prefs: []
  type: TYPE_NORMAL
- en: Some practitioners might argue that decorating a class is something rather convoluted
    and that such a scenario might jeopardize readability because we would be declaring
    some attributes and methods in the class, but behind the scenes, the decorator
    might be applying changes that would render a completely different class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This assessment is true, but only if this technique is heavily abused. Objectively,
    this is no different from decorating functions; after all, classes are just another
    type of object in the Python ecosystem, as functions are. We will review the pros
    and cons of this issue with decorators in the section titled *Decorators and separation
    of concerns*, but for now, we''ll explore the benefits of decorators that apply
    particularly to classes:'
  prefs: []
  type: TYPE_NORMAL
- en: All the benefits of reusing code and the DRY principle. A valid case of a class
    decorator would be to enforce that multiple classes conform to a certain interface
    or criteria (by making this checks only once in the decorator that is going to
    be applied to those many classes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could create smaller or simpler classes that will be enhanced later on by
    decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The transformation logic we need to apply to a certain class will be much easier
    to maintain if we use a decorator, as opposed to more complicated (and often rightfully
    discouraged) approaches such as metaclasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Among all possible applications of decorators, we will explore a simple example
    to give an idea of the sorts of things they can be useful for. Keep in mind that
    this is not the only application type for class decorators, but also that the
    code we show you could have many other multiple solutions as well, all with their
    pros and cons, but we chose decorators with the purpose of illustrating their
    usefulness.
  prefs: []
  type: TYPE_NORMAL
- en: Recalling our event systems for the monitoring platform, we now need to transform
    the data for each event and send it to an external system. However, each type
    of event might have its own particularities when selecting how to send its data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, the `event` for a login might contain sensitive information
    such as credentials that we want to hide. Other fields such as `timestamp` might
    also require some transformations since we want to show them in a particular format.
    A first attempt at complying with these requirements would be as simple as having
    a class that maps to each particular `event` and knows how to serialize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we declare a class that is going to map directly with the login event,
    containing the logic for it—hide the `password` field, and format the `timestamp`
    as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this works and might look like a good option to start with, as time passes
    and we want to extend our system, we will find some issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Too many classes**: As the number of events grows, the number of serialization
    classes will grow in the same order of magnitude, because they are mapped one
    to one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The solution is not flexible enough**: If we need to reuse parts of the components
    (for example, we need to hide the `password` in another type of `event` that also
    has it), we will have to extract this into a function, but also call it repeatedly
    from multiple classes, meaning that we are not reusing that much code after all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boilerplate**: The `serialize()` method will have to be present in all `event`
    classes, calling the same code. Although we can extract this into another class
    (creating a mixin), it does not seem like a good use of inheritance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternative solution is to be able to dynamically construct an object that,
    given a set of filters (transformation functions) and an `event` instance, is
    able to serialize it by applying the filters to its fields. We then only need
    to define the functions to transform each type of field, and the serializer is
    created by composing many of these functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have this object, we can decorate the class in order to add the `serialize()`
    method, which will just call these `Serialization` objects with itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the decorator makes it easier for the user to know how each field
    is going to be treated without having to look into the code of another class.
    Just by reading the arguments passed to the class decorator, we know that the
    `username` and IP address will be left unmodified, the `password` will be hidden,
    and the `timestamp` will be formatted.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the code of the class does not need the `serialize()` method defined, nor
    does it need to extend from a mixin that implements it, since the decorator will
    add it. In fact, this is probably the only part that justifies the creation of
    the class decorator, because otherwise, the `Serialization` object could have
    been a class attribute of `LoginEvent`, but the fact that it is altering the class
    by adding a new method to it makes it impossible.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we could have another class decorator that, just by defining the attributes
    of the class, implements the logic of the `init` method, but this is beyond the
    scope of this example. This is what libraries such as `attrs` (ATTRS 01) do, and
    a similar functionality is proposed in (PEP-557) for the Standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using this class decorator from (PEP-557), in Python 3.7+, the previous
    example could be rewritten in a more compact way, without the boilerplate code
    of the `init`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Other types of decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know what the `@` syntax for decorators actually means, we can conclude
    that it isn't just functions, methods, or classes that can be decorated; actually,
    anything that can be defined, such as generators, coroutines, and even objects
    that have already been decorated, can be decorated, meaning that decorators can
    be stacked.
  prefs: []
  type: TYPE_NORMAL
- en: The previous example showed how decorators can be chained. We first defined
    the class, and then applied `@dataclass` to it, which converted it into a data
    class, acting as a container for those attributes. After that, the `@Serialization`
    will apply the logic to that class, resulting in a new class with the new `serialize()`
    method added to it.
  prefs: []
  type: TYPE_NORMAL
- en: Another good use of decorators is for generators that are supposed to be used
    as coroutines. We will explore the details of generators and coroutines in [Chapter
    7](32503c77-5ff2-4d35-af0e-8d9300cfa357.xhtml), *Using Generators,* but the main
    idea is that, before sending any data to a newly created generator, the latter
    has to be advanced up to their next `yield` statement by calling `next()` on it.
    This is a manual process that every user will have to remember and hence is error-prone.
    We could easily create a decorator that takes a generator as a parameter, calls
    `next()` to it, and then returns the generator.
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments to decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we already regard decorators as a powerful tool in Python. However,
    they could be even more powerful if we could just pass parameters to them so that
    their logic is abstracted even more.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways of implementing decorators that can take arguments, but
    we will go over the most common ones. The first one is to create decorators as
    nested functions with a new level of indirection, making everything in the decorator
    fall one level deeper. The second approach is to use a class for the decorator.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the second approach favors readability more, because it is easier
    to think in terms of an object than three or more nested functions working with
    closures. However, for completeness, we will explore both, and the reader can
    decide what is best for the problem at hand.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators with nested functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Roughly speaking, the general idea of a decorator is to create a function that
    returns a function (often called a higher-order function). The internal function
    defined in the body of the decorator is going to be the one actually being called.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we wish to pass parameters to it, we then need another level of indirection.
    The first one will take the parameters, and inside that function, we will define
    a new function, which will be the decorator, which in turn will define yet another
    new function, namely the one to be returned as a result of the decoration process.
    This means that we will have at least three levels of nested functions.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if this didn't seem clear so far. After reviewing the examples that
    are about to come, everything will become clear.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first examples we saw of decorators implemented the `retry` functionality
    over some functions. This is a good idea, except it has a problem; our implementation
    did not allow us to specify the numbers of retries, and instead, this was a fixed
    number inside the decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we want to be able to indicate how many retries each instance is going
    to have, and perhaps we could even add a default value to this parameter. In order
    to do this, we need another level of nested functions—first for the parameters,
    and then for the decorator itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because we are now going to have something in the form of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And that has to return a decorator because the `@` syntax will apply the result
    of that computation to the object to be decorated. Semantically, it would translate
    to something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides the number of desired retries, we can also indicate the types of exception
    we wish to control. The new version of the code supporting the new requirements
    might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples of how this decorator can be applied to functions, showing
    the different options it accepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Decorator objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous example requires three levels of nested functions. The first it
    is going to be a function that receives the parameters of the decorator we want
    to use. Inside this function, the rest of the functions are closures that use
    these parameters along with the logic of the decorator.
  prefs: []
  type: TYPE_NORMAL
- en: A cleaner implementation of this would be to use a class to define the decorator.
    In this case, we can pass the parameters in the `__init__` method, and then implement
    the logic of the decorator on the magic method named `__call__`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the decorator will look like it does in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And this decorator can be applied pretty much like the previous one, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note how the Python syntax takes effect here. First, we create
    the object, so before the `@` operation is applied, the object is created with
    its parameters passed to it. This will create a new object and initialize it with
    these parameters, as defined in the `init` method. After this, the `@` operation
    is invoked, so this object will wrap the function named `run_with_custom_reries_limit`,
    meaning that it will be passed to the `call` magic method.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this `call` magic method, we defined the logic of the decorator as we
    normally do—we wrap the original function, returning a new one with the logic
    we want instead.
  prefs: []
  type: TYPE_NORMAL
- en: Good uses for decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a look at some common patterns that make good
    use of decorators. These are common situations for when decorators are a good
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'From all the countless applications decorators can be used for, we will enumerate
    a few, the most common or relevant:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transforming parameters**: Changing the signature of a function to expose
    a nicer API, while encapsulating details on how the parameters are treated and
    transformed underneath'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tracing code**: Logging the execution of a function with its parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validate parameters**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement retry operations**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplify classes by moving some (repetitive) logic into decorators**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss the first two applications in detail in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have mentioned before that decorators can be used to validate parameters
    (and even enforce some preconditions or postconditions under the idea of DbC),
    so from this you probably have got the idea that it is somehow common to use decorators
    when dealing with or manipulating parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, there are some cases on which we find ourselves repeatedly creating
    similar objects, or applying similar transformations that we would wish to abstract
    away. Most of the time, we can achieve this by simply using a decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When talking about **tracing** in this section, we will refer to something
    more general that has to do with dealing with the execution of a function that
    we wish to monitor. This could refer to scenarios in which we want to:'
  prefs: []
  type: TYPE_NORMAL
- en: Actually trace the execution of a function (for example, by logging the lines
    it executes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor some metrics over a function (such as CPU usage or memory footprint)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measure the running time of a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log when a function was called, and the parameters that were passed to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will explore a simple example of a decorator that logs
    the execution of a function, including its name and the time it took to run.
  prefs: []
  type: TYPE_NORMAL
- en: Effective decorators – avoiding common mistakes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While decorators are a great feature of Python, they are not exempt from issues
    if used incorrectly. In this section, we will see some common issues to avoid
    in order to create effective decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Preserving data about the original wrapped object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common problems when applying a decorator to a function is that
    some of the properties or attributes of the original function are not maintained,
    leading to undesired, and hard-to-track, side-effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this we show a decorator that is in charge of logging when the
    function is about to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s imagine we have a function with this decorator applied to it. We
    might initially think that nothing of that function is modified with respect to
    its original definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: But maybe there are changes.
  prefs: []
  type: TYPE_NORMAL
- en: The decorator is not supposed to alter anything from the original function,
    but, as it turns out since it contains a flaw it's actually modifying its name
    and `docstring`, among other properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to get `help` for this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s check how it''s called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can see that, since the decorator is actually changing the original function
    for a new one (called `wrapped`), what we actually see are the properties of this
    function instead of those from the original function.
  prefs: []
  type: TYPE_NORMAL
- en: If we apply a decorator like this one to multiple functions, all with different
    names, they will all end up being called `wrapped`, which is a major concern (for
    example, if we want to log or trace the function, this will make debugging even
    harder).
  prefs: []
  type: TYPE_NORMAL
- en: Another problem is that, in case we placed docstrings with tests on these functions,
    they will be overridden by those of the decorator. As a result, the docstrings
    with the test we want will not run when we call our code with the `doctest` module
    (as we have seen in [Chapter 1](bba62a64-dfe9-478f-9b33-6c3240d75f59.xhtml), *Introduction,
    Code Formatting, and Tools*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The fix is simple, though. We just have to apply the `wraps` decorator in the
    internal function (`wrapped`), telling it that it is actually wrapping `function`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we check the properties, we will obtain what we expected in the first
    place. Check `help` for the function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And verify that its qualified name is correct, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Most importantly, we recovered the unit tests we might have had on the docstrings!
    By using the `wraps` decorator, we can also access the original, unmodified function
    under the `__wrapped__` attribute. Although it should not be used in production,
    it might come in handy in some unit tests when we want to check the unmodified
    version of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, for simple decorators, the way we would use `functools.wraps` would
    typically follow the general formula or structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Always use `functools.wraps` applied over the wrapped function, when creating
    a decorator, as shown in the preceding formula.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with side-effects in decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn that it is advisable to avoid side-effects in
    the body of the decorator. There are cases where this might be acceptable, but
    the bottom line is that, if in case of doubt, decide against it, for the reasons
    that are explained ahead. Everything that the decorator needs to do aside from
    the function that it's decorating should be placed in the innermost function definition,
    or there will be problems when it comes to importing.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, sometimes these side-effects are required (or even desired) to
    run at import time, and the obverse applies.
  prefs: []
  type: TYPE_NORMAL
- en: We will see examples of both, and where each one applies. If in doubt, err on
    the side of caution, and delay all side-effects until the very latest, right after
    the `wrapped` function is going to be called.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see when it's not a good idea to place extra logic outside the
    `wrapped` function.
  prefs: []
  type: TYPE_NORMAL
- en: Incorrect handling of side-effects in a decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s imagine the case of a decorator that was created with the goal of logging
    when a function started running and then logging its running time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will apply the decorator to a regular function, thinking that it will
    work just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This decorator has a subtle, yet critical bug in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s import the function, call it several times, and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Just by importing the function, we will notice that something's amiss. The logging
    line should not be there, because the function was not invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what happens if we run the function, and see how long it takes to run?
    Actually, we would expect that calling the same function multiple times will give
    similar results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Every time we run the same function, it takes longer! At this point, you have
    probably already noticed the (now obvious) error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember the syntax for decorators. `@traced_function_wrong` actually means
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: And this will run when the module is imported. Therefore, the time that is set
    in the function will be the one at the time the module was imported. Successive
    calls will compute the time difference from the running time until that original
    starting time. It will also log at the wrong moment, and not when the function
    is actually called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, the fix is also very simple—we just have to move the code inside the
    `wrapped` function in order to delay its execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With this new version, the previous problems are resolved.
  prefs: []
  type: TYPE_NORMAL
- en: If the actions of the decorator had been different, the results could have been
    much more disastrous. For instance, if it requires that you log events and send
    them to an external service, it will certainly fail unless the configuration has
    been run right before this has been imported, which we cannot guarantee. Even
    if we could, it would be bad practice. The same applies if the decorator has any
    other sort of side-effect, such as reading from a file, parsing a configuration,
    and many more.
  prefs: []
  type: TYPE_NORMAL
- en: Requiring decorators with side-effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, side-effects on decorators are necessary, and we should not delay
    their execution until the very last possible time, because that's part of the
    mechanism which is required for them to work.
  prefs: []
  type: TYPE_NORMAL
- en: One common scenario for when we don't want to delay the side-effect of decorators is
    when we need to register objects to a public registry that will be available in
    the module.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, going back to our previous `event` system example, we now want
    to only make some events available in the module, but not all of them. In the
    hierarchy of events, we might want to have some intermediate classes that are
    not actual events we want to process on the system, but some of their derivative
    classes instead.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of flagging each class based on whether it's going to be processed or
    not, we could explicitly register each class through a decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we have a class for all events that relate to the activities
    of a user. However, this is just an intermediate table for the types of event
    we actually want, namely `UserLoginEvent` and `UserLogoutEvent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When we look at the preceding code, it seems that `EVENTS_REGISTRY` is empty,
    but after importing something from this module, it will get populated with all
    of the classes that are under the `register_event` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This might seem like it's hard to read, or even misleading, because `EVENTS_REGISTRY`
    will have its final value at runtime, right after the module was imported, and
    we cannot easily predict its value by just looking at the code.
  prefs: []
  type: TYPE_NORMAL
- en: While that is true, in some cases this pattern is justified. In fact, many web
    frameworks or well-known libraries use this to work and expose objects or make
    them available.
  prefs: []
  type: TYPE_NORMAL
- en: It is also true that in this case, the decorator is not changing the `wrapped`
    object, nor altering the way it works in any way. However, the important note
    here is that, if we were to do some modifications and define an internal function
    that modifies the `wrapped` object, we would still probably want the code that
    registers the resulting object outside it.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of the word *outside*. It does not necessarily mean before, it's
    just not part of the same closure; but it's in the outer scope, so it's not delayed
    until runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Creating decorators that will always work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several different scenarios to which decorators might apply. It can
    also be the case that we need to use the same decorator for objects that fall
    into these different multiple scenarios, for instance, if we want to reuse our
    decorator and apply it to a function, a class, a method, or a static method.
  prefs: []
  type: TYPE_NORMAL
- en: If we create the decorator, just thinking about supporting only the first type
    of object we want to decorate, we might notice that the same decorator does not
    work equally well on a different type of object. The typical example is where
    we create a decorator to be used on a function, and then we want to apply it to
    a method of a class, only to realize that it does not work. A similar scenario
    might occur if we designed our decorator for a method, and then we want it to
    also apply for static methods or class methods.
  prefs: []
  type: TYPE_NORMAL
- en: When designing decorators, we typically think about reusing code, so we will
    want to use that decorator for functions and methods as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining our decorators with the signature `*args`, and `**kwargs`, will make
    them work in all cases, because it''s the most generic kind of signature that
    we can have. However, sometimes we might want not to use this, and instead define
    the decorator wrapping function according to the signature of the original function,
    mainly because of two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It will be more readable since it resembles the original function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It actually needs to do something with the arguments, so receiving `*args` and
    `**kwargs` wouldn't be convenient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider the case on which we have many functions in our code base that require
    a particular object to be created from a parameter. For instance, we pass a string,
    and initialize a driver object with it, repeatedly. Then we think we can remove
    the duplication by using a decorator that will take care of converting this parameter
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next example, we pretend that `DBDriver` is an object that knows how
    to connect and run operations on a database, but it needs a connection string.
    The methods we have in our code, are designed to receive a string with the information
    of the database and require to create an instance of `DBDriver` always. The idea
    of the decorator is that it's going to take place of this conversion automatically—the
    function will continue to receive a string, but the decorator will create a `DBDriver`
    and pass it to the function, so internally we can assume that we receive the object
    we need directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of using this in a function is shown in the next listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s easy to verify that if we pass a string to the function, we get the result
    done by an instance of `DBDriver`, so the decorator works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'But now, we want to reuse this same decorator in a class method, where we find
    the same problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We try to use this decorator, only to realize that it doesn''t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: What is the problem?
  prefs: []
  type: TYPE_NORMAL
- en: The method in the class is defined with an extra argument—`self`.
  prefs: []
  type: TYPE_NORMAL
- en: Methods are just a particular kind of function that receives `self` (the object
    they're defined upon) as the first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in this case, the decorator (designed to work with only one parameter,
    named `dbstring`), will interpret that `self` is said parameter, and call the
    method passing the string in the place of self, and nothing in the place for the
    second parameter, namely the string we are passing.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this issue, we need to create a decorator that will work equally for
    methods and functions, and we do so by defining this as a decorator object, that
    also implements the protocol descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: Descriptors are fully explained in [Chapter 7](32503c77-5ff2-4d35-af0e-8d9300cfa357.xhtml), *Using
    Generators*, so, for now, we can just take this as a recipe that will make the
    decorator work.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to implement the decorator as a class object and make this object
    a description, by implementing the `__get__` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Details on descriptors will be explained in [Chapter 6](1091614c-9831-4645-aaa6-140ae13f08d8.xhtml), *Getting
    More Out of Our Objects with Descriptors*, but for the purposes of this example,
    we can now say that what it does is actually rebinding the callable it's decorating
    to a method, meaning that it will bind the function to the object, and then recreate
    the decorator with this new callable.
  prefs: []
  type: TYPE_NORMAL
- en: For functions, it still works, because it won't call the `__get__` method at
    all.
  prefs: []
  type: TYPE_NORMAL
- en: The DRY principle with decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how decorators allow us to abstract away certain logic into a separate
    component. The main advantage of this is that we can then apply the decorator
    multiple times into different objects in order to reuse code. This follows the
    **Don't Repeat Yourself** (**DRY**) principle since we define certain knowledge
    once and only once.
  prefs: []
  type: TYPE_NORMAL
- en: The `retry` mechanism implemented in the previous sections is a good example
    of a decorator that can be applied multiple times to reuse code. Instead of making
    each particular function include its `retry` logic, we create a decorator and
    apply it several times. This makes sense once we have made sure that the decorator
    can work with methods and functions equally.
  prefs: []
  type: TYPE_NORMAL
- en: The class decorator that defined how events are to be represented also complies
    with the DRY principle in the sense that it defines one specific place for the
    logic for serializing an event, without needing to duplicate code scattered among
    different classes. Since we expect to reuse this decorator and apply it to many
    classes, its development (and complexity) pay off.
  prefs: []
  type: TYPE_NORMAL
- en: This last remark is important to bear in mind when trying to use decorators
    in order to reuse code—we have to be absolutely sure that we will actually be
    saving code.
  prefs: []
  type: TYPE_NORMAL
- en: Any decorator (especially if it is not carefully designed) adds another level
    of indirection to the code, and hence more complexity. Readers of the code might
    want to follow the path of the decorator to fully understand the logic of the
    function (although these considerations are addressed in the following section),
    so keep in mind that this complexity has to pay off. If there is not going to
    be too much reuse, then do not go for a decorator and opt for a simpler option
    (maybe just a separate function or another small class is enough).
  prefs: []
  type: TYPE_NORMAL
- en: But how do we know what too much reuse is? Is there a rule to determine when
    to refactor existing code into a decorator? There is nothing specific to decorators
    in Python, but we could apply a general rule of thumb in software engineering
    (GLASS 01) that states that a component should be tried out at least three times
    before considering creating a generic abstraction in the sort of a reusable component.
    From the same reference (GLASS 01); (we encourage all readers to read *Facts and
    Fallacies of Software Engineering* because it is a great reference) also comes
    the idea that creating reusable components is three times harder than creating
    simple ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom line is that reusing code through decorators is acceptable, but
    only when you take into account the following considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: Do not create the decorator in the first place from scratch. Wait until the
    pattern emerges and the abstraction for the decorator becomes clear, and then
    refactor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider that the decorator has to be applied several times (at least three
    times) before implementing it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the code in the decorators to a minimum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorators and separation of concerns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last point on the previous list is so important that it deserves a section
    of its own. We have already explored the idea of reusing code and noticed that
    a key element of reusing code is having components that are cohesive. This means
    that they should have the minimum level of responsibility—do one thing, one thing
    only, and do it well. The smaller our components, the more reusable, and the more
    they can be applied in a different context without carrying extra behavior that
    will cause coupling and dependencies, which will make the software rigid.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show you what this means, let''s reprise one of the decorators that we used
    in a previous example. We created a decorator that traced the execution of certain
    functions with code similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, this decorator, while it works, has a problem—it is doing more than one
    thing. It logs that a particular function was just invoked, and also logs how
    much time it took to run. Every time we use this decorator, we are carrying these
    two responsibilities, even if we only wanted one of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should be broken down into smaller decorators, each one with a more specific
    and limited responsibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the same functionality that we had previously can be achieved by
    simply combining both of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the order in which the decorators are applied is also important.
  prefs: []
  type: TYPE_NORMAL
- en: Do not place more than one responsibility in a decorator. The SRP applies to
    decorators as well.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing good decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a closing note for this chapter, let's review some examples of good decorators
    and how they are used both in Python itself, as well as in popular libraries.
    The idea is to get guidelines on how good decorators are created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before jumping into examples, let''s first identify traits that good decorators
    should have:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation, or separation of concerns**: A good decorator should effectively
    separate different responsibilities between what it does and what it is decorating.
    It cannot be a leaky abstraction, meaning that a client of the decorator should
    only invoke it in black box mode, without knowing how it is actually implementing
    its logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orthogonality**: What the decorator does should be independent, and as decoupled
    as possible from the object it is decorating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability**: It is desirable that the decorator can be applied to multiple
    types, and not that it just appears on one instance of one function, because that
    means that it could just have been a function instead. It has to be generic enough.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A nice example of decorators can be found in the Celery project, where a `task`
    is defined by applying the decorator of the `task` from the application to a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: One of the reasons why this is a good decorator is because it is very good at
    something—encapsulation. The user of the library only needs to define the function
    body and the decorator will convert that into a task automatically. The `"@app.task"`
    decorator surely wraps a lot of logic and code, but none of that is relevant to
    the body of `"mytask()"`. It is complete encapsulation and separation of concerns—nobody
    will have to take a look at what that decorator does, so it is a correct abstraction
    that does not leak any details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common use of decorators is in web frameworks (Pyramid, Flask, and
    Sanic, just to name a few), on which the handlers for views are registered to
    the URLs through decorators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: These sorts of decorator have the same considerations as before; they also provide
    total encapsulation because a user of the web framework rarely (if ever) needs
    to know what the `"@route"` decorator is doing. In this case, we know that the
    decorator is doing something more, such as registering these functions to a mapper
    to the URL, and also that it is changing the signature of the original function
    to provide us with a nicer interface that receives a request object with all the
    information already set.
  prefs: []
  type: TYPE_NORMAL
- en: The previous two examples are enough to make us notice something else about
    this use of decorators. They conform to an API. These libraries of frameworks
    are exposing their functionality to users through decorators, and it turns out
    that decorators are an excellent way of defining a clean programming interface.
  prefs: []
  type: TYPE_NORMAL
- en: This is probably the best way we should think about to decorators. Much like
    in the example of the class decorator that tells us how the attributes of the
    event are going to be handled, a good decorator should provide a clean interface
    so that users of the code know what to expect from the decorator, without needing
    to know how it works, or any of its details for that matter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decorators are powerful tools in Python that can be applied to many things such
    as classes, methods, functions, generators, and many more. We have demonstrated
    how to create decorators in different ways, and for different purposes, and drew
    some conclusions along the way.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a decorator for functions, try to make its signature match the
    original function being decorated. Instead of using the generic `*args`, and `**kwargs`,
    making the signature match the original one will make it easier to read, and maintain,
    and it will resemble the original function more closely, so it will be more familiar
    to readers of that code.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators are a very useful tool for reusing code and following the DRY principle.
    However, their usefulness comes at a cost, and if they are not used wisely, the
    complexity can do more harm than good. For that reason, we emphasize that decorators
    should be used when they are actually going to be applied multiple times (three
    or more times). In the same way as the DRY principle, we find the ideas of separation
    of concerns, with the goal of keeping the decorators as small as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Another good use of decorators is to create cleaner interfaces, for instance,
    simplifying the definition of a class by extracting part of its logic into a decorator.
    In this sense, decorators also help readability by providing the users with information
    about what that particular component will be doing, without needing to know how
    (encapsulation).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at another advanced feature of Python—descriptors.
    In particular, we will see how with the help of descriptors we can create even
    better decorators, and solve some of the issues we encountered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a list of information you can refer to:'
  prefs: []
  type: TYPE_NORMAL
- en: '*PEP-318*: Decorators for Functions and Methods ([https://www.python.org/dev/peps/pep-0318/](https://www.python.org/dev/peps/pep-0318/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PEP-3129*:Class Decorators ([https://www.python.org/dev/peps/pep-3129/](https://www.python.org/dev/peps/pep-3129/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*WRAPT 01*: [https://pypi.org/project/wrapt/](https://pypi.org/project/wrapt/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*WRAPT 02*: [https://wrapt.readthedocs.io/en/latest/decorators.html#universal-decorators](https://wrapt.readthedocs.io/en/latest/decorators.html#universal-decorators)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Functools module*: The `wraps` function in the `functools` module of Python''s
    standard library ([https://docs.python.org/3/library/functools.html#functools.wrap](https://docs.python.org/3/library/functools.html#functools.wraps))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ATTRS 01:* The `attrs` library ([https://pypi.org/project/attrs/](https://pypi.org/project/attrs/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PEP-557*: Data Classes ([https://www.python.org/dev/peps/pep-0557/](https://www.python.org/dev/peps/pep-0557/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*GLASS 01*: The book written by Robert L. Glass named *Facts and Fallacies
    of Software Engineering*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

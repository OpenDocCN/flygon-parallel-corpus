- en: '*Chapter 13*:'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '*第13章*：'
- en: Trees and Graphs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树和图
- en: 'This chapter covers one of the trickiest topics asked in interviews: trees
    and graphs. While there are tons of problems related to these two topics, only
    a handful of them are actually encountered in interviews. Therefore, it is very
    important to prioritize the most popular problems with trees and graphs.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了面试中经常被问到的最棘手的主题之一：树和图。虽然与这两个主题相关的问题有很多，但实际上只有少数问题会在面试中遇到。因此，非常重要的是要优先考虑与树和图相关的最受欢迎的问题。
- en: In this chapter, we'll start with a brief overview of trees and graphs. Later,
    we'll tackle the most popular and challenging problems encountered in interviews
    at IT giants such as Amazon, Microsoft, Adobe, and other companies. By the end
    of this chapter, you'll know how to answer interview questions and solve coding
    challenges regarding trees and graphs in an efficient and comprehensive way.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先简要概述树和图。随后，我们将解决在像亚马逊，微软，Adobe和其他公司的IT巨头的面试中遇到的最受欢迎和具有挑战性的问题。通过本章结束时，你将知道如何以高效和全面的方式回答面试问题并解决关于树和图的编码挑战。
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Trees in a nutshell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树的概述
- en: Graphs in a nutshell
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图的概述
- en: Coding challenges
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码挑战
- en: So, let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始吧！
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code present in this chapter can be found on GitHub at [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter13](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter13).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码都可以在GitHub上找到：[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter13](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter13)。
- en: Trees in a nutshell
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树的概述
- en: 'A tree is a non-linear data structure that organizes data hierarchically in
    nodes and cannot contain cycles. A tree has a specific terminology that may vary
    slightly, but commonly, the following notions are adopted:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 树是一种非线性数据结构，以节点的层次结构组织数据，不能包含循环。树有一个特定的术语，可能会有些许不同，但通常采用以下概念：
- en: '**Root** is the topmost node.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根节点**是最顶层的节点。'
- en: '**Edge** is the link or connection between two nodes.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边缘**是两个节点之间的链接或连接。'
- en: '**Parent** is a node that has an edge to a child node.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父节点**是具有到子节点的边缘的节点。'
- en: '**Child** is a node that has a parent node.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子节点**是具有父节点的节点。'
- en: '**Leaf** is a node that does not have a child node.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**叶子**是没有子节点的节点。'
- en: '**Height** is the length of the longest path to a leaf.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高度**是到叶子的最长路径的长度。'
- en: '**Depth** is the length of the path to its root.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度**是到其根的路径的长度。'
- en: 'The following diagram exemplifies these terms when used on a tree:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下图举例说明了这些术语在树上的使用：
- en: '![Figure 13.1 – Tree terminology'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.1 – 树术语'
- en: '](img/Figure_13.1_B15403.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.1_B15403.jpg)'
- en: Figure 13.1 – Tree terminology
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – 树术语
- en: Typically, any tree can have a root. The nodes of the tree can respect a certain
    order (or not), can store any type of data, and may have links to their parents.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，任何树都可以有一个根。树的节点可以遵循一定的顺序（或不遵循），可以存储任何类型的数据，并且可以链接到它们的父节点。
- en: Tree coding challenges are rife with ambiguous details and/or incorrect assumptions.
    It is very important to clarify every single detail with the interviewer in order
    to eliminate ambiguity. One of the most important aspects refers to the type of
    tree. Let's take a look at the most common types of trees.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 树编码挑战充斥着模糊的细节和/或不正确的假设。非常重要的是要在面试中澄清每一个细节，以消除歧义。其中最重要的一个方面涉及到树的类型。让我们来看看最常见的树类型。
- en: General tree
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般树
- en: 'Roughly speaking, we can categorize trees into binary trees and the rest of
    the allowed trees. A binary tree is a tree in which each node has up to two children.
    In the following diagram, the left-hand side image is of a non-binary tree, while
    the right-hand side image is of a binary tree:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 粗略地说，我们可以将树分类为二叉树和其他允许的树。二叉树是一种每个节点最多有两个子节点的树。在下面的图表中，左侧的图像是非二叉树，而右侧的图像是二叉树：
- en: '![Figure 13.2 – Non-binary tree versus binary tree'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.2 – 非二叉树与二叉树'
- en: '](img/Figure_13.2_B15403.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.2_B15403.jpg)'
- en: Figure 13.2 – Non-binary tree versus binary tree
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 非二叉树与二叉树
- en: 'In terms of code, a binary tree can be shaped as follows (this implementation
    is used later in the *Coding challenges* section, so keep this in mind):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，二叉树可以被塑造如下（这个实现稍后会在*编码挑战*部分中使用，所以请记住这一点）：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, each `Node` keeps references to two other `Node` elements, as
    well as a generic data (element). The left and right nodes represent the children
    of the current node. Most tree coding challenges that are encountered in interviews
    use binary trees, so they deserve special attention. Binary trees can be categorized
    as follows.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，每个`Node`都保留对其他两个`Node`元素的引用，以及一个通用数据（元素）。左节点和右节点代表当前节点的子节点。在面试中遇到的大多数树编码挑战都使用二叉树，因此它们值得特别关注。二叉树可以被分类如下。
- en: Knowing binary tree traversal
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解二叉树遍历
- en: 'Before attending a technical interview, you must know how to traverse a binary
    tree. Often, traversing a binary tree will not be a problem in itself, but you
    have to be comfortable with the **Breadth-first Search** (**BFS**) and the **Depth-first
    Search** (**DFS**) algorithms, along with their three variations: **Pre-Order**,
    **In-Order**, and **Post-Order**. The following diagram represents the result
    of each traversal type:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在参加技术面试之前，你必须知道如何遍历二叉树。通常情况下，遍历二叉树本身不会成为问题，但你必须熟悉**广度优先搜索**（**BFS**）和**深度优先搜索**（**DFS**）算法，以及它们的三种变体：**前序**，**中序**和**后序**。下图表示了每种遍历类型的结果：
- en: '![Figure 13.3 – Binary tree traversal'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.3 – 二叉树遍历'
- en: '](img/Figure_13.3_B15403.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.3_B15403.jpg)'
- en: Figure 13.3 – Binary tree traversal
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 二叉树遍历
- en: Let's have a brief overview of the BFS and DFS algorithms.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要概述一下BFS和DFS算法。
- en: Breadth-first Search (BFS) for trees
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 树的广度优先搜索（BFS）
- en: 'BFS for trees is also referred as Level-Order traversal. The main idea is to
    maintain a queue of nodes that will ensure the order of traversal. Initially,
    the queue contains only the root node. The steps of the algorithm are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 树的BFS也被称为层次遍历。其主要思想是维护一个节点队列，以确保遍历顺序。最初，队列只包含根节点。算法步骤如下：
- en: Pop the first node from the queue as the current node.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从队列中弹出第一个节点作为当前节点。
- en: Visit the current node.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问当前节点。
- en: If the current node has a left node, then enqueue that left node.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前节点有左节点，则将该左节点入队。
- en: If the current node has a right node, then enqueue that right node.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前节点有右节点，则将该右节点入队。
- en: Repeat from *step 1* until the queue is empty.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复从*步骤1*开始，直到队列为空。
- en: 'In terms of code, we have the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，我们有以下内容：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, let's focus on DFS.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们专注于DFS。
- en: Depth-first Search (DFS) for trees
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 深度优先搜索（DFS）用于树
- en: 'DFS for trees has three variations: **Pre-Order**, **In-Order**, and **Post-Order**.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 树的DFS有三种变体：**先序遍历**、**中序遍历**和**后序遍历**。
- en: 'Pre-Order traversal visits the current node before its child nodes, as follows
    **(root | left sub-tree | right sub-tree)**:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 先序遍历在访问其子节点之前访问当前节点，如下所示**(根节点 | 左子树 | 右子树)**：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In-Order traversal visits the left branch, then the current node, and finally,
    the right branch, as follows **(left sub-tree | root | right sub-tree)**:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 中序遍历先访问左分支，然后访问当前节点，最后访问右分支，如下所示**(左子树 | 根节点 | 右子树)**：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Post-Order visits the current node after its child nodes, as follows **(left
    sub-tree | right sub-tree | root)**:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 后序遍历在访问其子节点之后访问当前节点，如下所示**(左子树 | 右子树 | 根节点)**：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The complete application is called *BinaryTreeTraversal*. Besides the preceding
    examples, the complete code also contains BFS and DFS implementations that return
    a `List` and an `Iterator`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*BinaryTreeTraversal*。除了前面的示例之外，完整的代码还包含了返回`List`和`Iterator`的BFS和DFS实现。
- en: Binary Search Tree
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: 'A **Binary Search Tree** (**BST**) is a binary tree that follows an ordering
    rule. Typically, in a BST, the left descendants (all the elements on the left-hand
    side of the root) are smaller than or equal to the root element and, the right
    descendants (all the elements on the right-hand side of the root) are bigger than
    the root element. However, this order doesn''t apply to just the root element.
    It applies to each node, *n*, so, in a BST, the *left descendants of n* ≤ *n*
    < *right* *descendants of n*. In the following diagram, the image on the left
    is of a binary tree, while the image on the right is of a BST:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**二叉搜索树**（BST）是一种遵循排序规则的二叉树。通常，在BST中，左子节点（根的左侧所有元素）小于或等于根元素，右子节点（根的右侧所有元素）大于根元素。然而，这个顺序不仅适用于根元素。它适用于每个节点*n*，因此在BST中，*n*的*左子节点*
    ≤ *n* < *n*的*右子节点*。在下图中，左侧的图像是二叉树，右侧的图像是BST：'
- en: '![Figure 13.4 – Binary tree versus binary search tree'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.4 – 二叉树与二叉搜索树'
- en: '](img/Figure_13.4_B15403.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.4_B15403.jpg)'
- en: Figure 13.4 – Binary tree versus BST
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 二叉树与二叉搜索树
- en: Commonly, a BST doesn't accept duplicates, but when it does, they can be on
    one side (for example, only on the left-hand side) or on both sides. The duplicates
    can also be stored in a separated hash map, or directly in the structure of the
    tree via a counter. Pay attention and clarify these details with the interviewer.
    Handling duplicates in a BST is a problem encounter in interviews at Amazon, Flipkart,
    and Microsoft, which is why it will be tackled in the *Coding challenges* section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，BST不接受重复项，但当它接受时，它们可以在一侧（例如，仅在左侧）或两侧都存在。重复项也可以存储在单独的哈希映射中，或者直接通过计数器存储在树的结构中。请注意并与面试官澄清这些细节。在亚马逊、Flipkart和微软的面试中，处理BST中的重复项是一个常见问题，因此它将在*编码挑战*部分中进行讨论。
- en: 'In the code bundled with this book, you can find an application called *BinarySearchTreeTraversal*
    that exposes the following set of methods: `insert(T element)`, `contains(T element)`,
    `delete(T element)`, `min()`, `max()`, `root()`, `size()`, and `height()`. Moreover,
    it contains an implementation of BFS and DFS for printing nodes and for returning
    nodes as a `List` or an `Iterator`. Take your time and dissect the code.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书附带的代码中，您可以找到一个名为*BinarySearchTreeTraversal*的应用程序，其中包含以下一组方法：`insert(T element)`、`contains(T
    element)`、`delete(T element)`、`min()`、`max()`、`root()`、`size()`和`height()`。此外，它包含了用于打印节点和将节点返回为`List`或`Iterator`的BFS和DFS的实现。请花时间仔细研究代码。
- en: Balanced and unbalanced binary trees
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平衡和不平衡的二叉树
- en: 'When a binary tree guarantees O(log n) times for insert and find operations,
    we can say that we have a *balanced* binary tree, but one that''s not necessarily
    as balanced as it could be. When the difference between the heights of the left
    sub-tree and the right sub-tree for any node in the tree is no more than 1, then
    the tree is *height-balanced*. In the following diagram, the left-hand side tree
    is an unbalanced binary tree, the middle tree is a balanced binary tree but not
    height-balanced, and the right-hand side tree is a height-balanced tree:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当二叉树保证插入和查找操作的O(log n)时间时，我们可以说我们有一个*平衡*的二叉树，但这并不一定是尽可能平衡的。当树中任何节点的左子树和右子树的高度差不超过1时，树就是*高度平衡*的。在下图中，左侧的树是不平衡的二叉树，中间的树是平衡的二叉树，但不是高度平衡的，右侧的树是高度平衡的树：
- en: '![Figure 13.5 – Unbalanced binary tree versus balanced binary tree versus height
    balanced binary tree'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.5 – 不平衡二叉树与平衡二叉树与高度平衡二叉树'
- en: '](img/Figure_13.5_B15403.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.5_B15403.jpg)'
- en: Figure 13.5 – Unbalanced binary tree versus balanced binary tree versus height-balanced
    binary tree
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 – 不平衡二叉树与平衡二叉树与高度平衡二叉树
- en: 'There are two types of balanced trees: Red-Black trees and AVL trees.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 平衡树有两种类型：红黑树和AVL树。
- en: Red-Black tree
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 红黑树
- en: 'A Red-Black tree is a self-balancing BST where each node is under the incident
    of the following rules:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 红黑树是一种自平衡的二叉搜索树，其中每个节点都受以下规则的影响：
- en: Every node is either red or black
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个节点要么是红色，要么是黑色
- en: The root node is always black
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根节点始终是黑色
- en: Every leaf (NULL) is black
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个叶子（NULL）都是黑色
- en: Both children of a red node are black
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色节点的两个子节点都是黑色
- en: Every path from a node to a NULL node has the same number of black nodes
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从节点到NULL节点的每条路径具有相同数量的黑色节点
- en: 'The following diagram represents a Red-Black tree:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示了红黑树：
- en: '![Figure 13.6 – Red-Black tree example'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.6 - 红黑树示例'
- en: '](img/Figure_13.6_B15403.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.6_B15403.jpg)'
- en: Figure 13.6 – Red-Black tree example
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 - 红黑树示例
- en: A Red-Black tree never gets terribly unbalanced. If all the nodes are black,
    then the tree becomes a *perfectly balanced tree*. The Red-Black tree becomes
    its maximum height when the nodes in its longest path are alternate black and
    red nodes. The height of a Black-Red tree is always less than or equal to 2log2(n+1),
    so its height is always in the order of O(log n).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 红黑树永远不会变得非常不平衡。如果所有节点都是黑色，那么树就变成了*完全平衡树*。当其最长路径上的节点交替为黑色和红色节点时，红黑树的高度最大。黑红树的高度始终小于或等于2log2(n+1)，因此其高度始终在O(log
    n)的数量级内。
- en: Because of their complexity and time to implement, the problems that involve
    Red-Black trees are not a common topic in interviews. However, when they occur,
    the problem may ask you to implement the insert, delete, or find operations. In
    the code bundled with this book, you can find a Red-Black tree implementation
    that shows these operations at work. Take your time studying the code and getting
    familiar with the Red-Black tree concept. The application is called *RedBlackTreeImpl*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其复杂性和实施时间，涉及红黑树的问题在面试中并不常见。然而，当它们出现时，问题可能会要求您实现插入、删除或查找操作。在本书附带的代码中，您可以找到一个展示这些操作的红黑树实现。花些时间研究代码，熟悉红黑树的概念。该应用程序名为*RedBlackTreeImpl*。
- en: More implementations that you may want to check out can be found at [github.com/williamfiset/data-structures/blob/master/com/williamfiset/datastructures/balancedtree/RedBlackTree.java](http://github.com/williamfiset/data-structures/blob/master/com/williamfiset/datastructures/balancedtree/RedBlackTree.java)
    and [algs4.cs.princeton.edu/33balanced/RedBlackBST.java.html](http://algs4.cs.princeton.edu/33balanced/RedBlackBST.java.html).
    For a graphical visualization, please consider [www.cs.usfca.edu/~galles/visualization/RedBlack.html](http://www.cs.usfca.edu/~galles/visualization/RedBlack.html).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想要查看的更多实现可以在[github.com/williamfiset/data-structures/blob/master/com/williamfiset/datastructures/balancedtree/RedBlackTree.java](http://github.com/williamfiset/data-structures/blob/master/com/williamfiset/datastructures/balancedtree/RedBlackTree.java)和[algs4.cs.princeton.edu/33balanced/RedBlackBST.java.html](http://algs4.cs.princeton.edu/33balanced/RedBlackBST.java.html)找到。有关图形可视化，请考虑[www.cs.usfca.edu/~galles/visualization/RedBlack.html](http://www.cs.usfca.edu/~galles/visualization/RedBlack.html)。
- en: If you need to deep dive into this topic, I strongly recommend that you read
    a book dedicated to data structures since this is a quite vast topic.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要深入研究这个主题，我强烈建议您阅读一本专门讲述数据结构的书，因为这是一个非常广泛的主题。
- en: AVL tree
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AVL树
- en: 'An **AVL** tree (named after their inventors, **A**delson-**V**elsky and **L**andis)
    is a self - balancing BST that respects the following rules:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**AVL**树（以其发明者**A**delson-**V**elsky和**L**andis命名）是一种自平衡的BST，遵守以下规则：'
- en: The height of a sub-tree can differ at most by 1.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子树的高度最多相差1。
- en: 'The balance factor (*BN*) of a node (*n*) is -1, 0, or 1 and is defined as
    the height (*h*) difference: *BN=h*(*right_subtree*(*n*)) *- h*(*left_subtree*(*n*))or
    *BN=h*(*left_subtree*(*n*)) *- h*(*right_subtree(n*)).'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点(*n*)的平衡因子(*BN*)为-1、0或1，并定义为高度(*h*)差：*BN=h*(*right_subtree*(*n*)) *- h*(*left_subtree*(*n*))或*BN=h*(*left_subtree*(*n*))
    *- h*(*right_subtree(n*)。
- en: 'The following diagram represents an AVL tree:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示了AVL树：
- en: '![Figure 13.7 – AVL tree sample'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.7 - AVL树示例'
- en: '](img/Figure_13.7_B15403.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.7_B15403.jpg)'
- en: Figure 13.7 – AVL tree example
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 - AVL树示例
- en: An AVL tree allows all operations (insert, delete, find min, find max, and so
    on) to perform in O(log n), where *n* is the number of nodes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: AVL树允许所有操作（插入、删除、查找最小值、查找最大值等）在O(log n)的时间内执行，其中*n*是节点数。
- en: Because of their complexity and time to implement, the problems that involve
    AVL trees are not a common topic in interviews. However, when they occur, the
    problem may ask you to implement the insert, delete, or find operations. In the
    code bundled with this book, you can find an AVL tree implementation that shows
    these operations at work. Take your time studying the code and getting familiar
    with the AVL trees concept. The application is called *AVLTreeImpl*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其复杂性和实施时间，涉及AVL树的问题在面试中并不常见。然而，当它们出现时，问题可能会要求您实现插入、删除或查找操作。在本书附带的代码中，您可以找到一个展示这些操作的AVL树实现。花些时间研究代码，熟悉AVL树的概念。该应用程序名为*AVLTreeImpl*。
- en: More implementations that you may want to check out can be found at [github.com/williamfiset/data-structures/blob/master/com/williamfiset/datastructures/balancedtree/AVLTreeRecursiveOptimized.java](http://github.com/williamfiset/data-structures/blob/master/com/williamfiset/datastructures/balancedtree/AVLTreeRecursiveOptimized.java)
    and [algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/AVLTreeST.java.html](http://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/AVLTreeST.java.html).
    For a graphical visualization, please consider [www.cs.usfca.edu/~galles/visualization/AVLtree.html](http://www.cs.usfca.edu/~galles/visualization/AVLtree.html).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想要查看的更多实现可以在[github.com/williamfiset/data-structures/blob/master/com/williamfiset/datastructures/balancedtree/AVLTreeRecursiveOptimized.java](http://github.com/williamfiset/data-structures/blob/master/com/williamfiset/datastructures/balancedtree/AVLTreeRecursiveOptimized.java)和[algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/AVLTreeST.java.html](http://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/AVLTreeST.java.html)找到。有关图形可视化，请考虑[www.cs.usfca.edu/~galles/visualization/AVLtree.html](http://www.cs.usfca.edu/~galles/visualization/AVLtree.html)。
- en: If you need to deep dive into this topic, I strongly recommend that you read
    a book dedicated to data structures since this is a quite vast topic.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要深入研究这个主题，我强烈建议您阅读一本专门讲述数据结构的书，因为这是一个非常广泛的主题。
- en: Complete binary tree
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完全二叉树
- en: 'A complete binary tree is a binary tree in which every level, except possibly
    the last, is fully filled. Moreover, all the nodes are as far left as possible.
    In the following diagram, the left-hand side shows a non-complete binary tree,
    while the right-hand side shows a complete binary tree:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 完全二叉树是指每一层（最后一层可能除外）都是完全填充的二叉树。此外，所有节点尽可能靠左。在下图中，左侧显示了一个非完全二叉树，而右侧显示了一个完全二叉树：
- en: '![Figure 13.8 – A non-complete binary tree versus a complete binary tree'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.8 – 非完全二叉树与完全二叉树'
- en: '](img/Figure_13.8_B15403.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.8_B15403.jpg)'
- en: Figure 13.8 – A non-complete binary tree versus a complete binary tree
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8 – 非完全二叉树与完全二叉树
- en: A complete binary tree must be filled from left to right, so the left-hand side
    tree shown in the preceding diagram is not complete. A complete binary tree with
    *n* nodes always has O(log n) height.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 完全二叉树必须从左到右填充，因此上图中左侧显示的树不是完全二叉树。具有*n*个节点的完全二叉树始终具有O(log n)的高度。
- en: Full binary tree
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 满二叉树
- en: 'A full binary tree is a binary tree in which every node has two children or
    none. In other words, a node cannot have only one child. In the following diagram,
    the left-hand side shows a non-full binary tree, while the right-hand side shows
    a full binary tree:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 满二叉树是指每个节点都有两个子节点或没有子节点的二叉树。换句话说，一个节点不能只有一个子节点。在下图中，左侧显示了一个非满二叉树，而右侧显示了一个满二叉树：
- en: '![Figure 13.9 – A non-full binary tree versus a full binary tree'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.9 – 非满二叉树与满二叉树'
- en: '](img/Figure_13.9_B15403.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.9_B15403.jpg)'
- en: Figure 13.9 – A non-full binary tree versus a full binary tree
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 – 非满二叉树与满二叉树
- en: The left-hand side tree in the preceding diagram is not full because node 68
    has one child.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，左侧的树不是满树，因为节点68只有一个子节点。
- en: Perfect binary tree
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完美二叉树
- en: 'A perfect binary tree is complete and full at the same time. The following
    diagram shows one such tree:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 完美二叉树既是完全的又是满的。下图显示了这样一棵树：
- en: '![Figure 13.10 – Perfect binary tree'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.10 – 完美二叉树'
- en: '](img/Figure_13.10_B15403.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.10_B15403.jpg)'
- en: Figure 13.10 – Perfect binary tree
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10 – 完美二叉树
- en: So, in a perfect binary tree, all the leaf nodes are at the same level. This
    means that the last level contains the maximum number of nodes. These kinds of
    tree are pretty rare in interviews.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在完美二叉树中，所有叶节点都在同一级别。这意味着最后一级包含最大数量的节点。这种树在面试中相当罕见。
- en: Important note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, let's discuss binary heaps in more detail.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地讨论二叉堆。
- en: Binary Heaps
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二叉堆
- en: In a nutshell, a Binary Heap is a complete binary tree that has a *heap property*.
    When the elements are in ascending order (the heap property says that the element
    of each node is greater than or equal to the element of its parent), we have a
    Min Binary Heap (the minimum element is the root element), while when they are
    in descending order (the heap property says that the element of each node is less
    than or equal to the element of its parent), we have a Max Binary Heap (the maximum
    element is the root element).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，二叉堆是一棵具有*堆属性*的完全二叉树。当元素按升序排列时（堆属性表示每个节点的元素大于或等于其父节点的元素），我们有一个最小二叉堆（最小元素是根元素），而当它们按降序排列时（堆属性表示每个节点的元素小于或等于其父节点的元素），我们有一个最大二叉堆（最大元素是根元素）。
- en: 'The following diagram shows a complete binary tree (left-hand side), a Min
    Binary Heap (in the middle), and a Max Binary Heap (right-hand side):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个完全二叉树（左侧），一个最小二叉堆（中间），和一个最大二叉堆（右侧）：
- en: '![Figure 13.11 – Complete binary tree and min and max heaps'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.11 – 完全二叉树和最小和最大堆'
- en: '](img/Figure_13.11_B15403.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.11_B15403.jpg)'
- en: Figure 13.11 – Complete binary tree and min and max heaps
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11 – 完全二叉树和最小和最大堆
- en: A Binary Heap is not sorted. It is partially ordered. There is no relationship
    between the nodes on any given level.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉堆不是排序的。它是部分有序的。在任何给定级别上，节点之间没有关系。
- en: 'A Binary Heap is typically represented as an array (let''s denote it as *heap*)
    whose root is at *heap*[0]. More importantly, for *heap*[*i*], we have that the
    following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉堆通常表示为一个数组（我们将其表示为*heap*），其根节点位于*heap*[0]。更重要的是，对于*heap*[*i*]，我们有以下情况：
- en: '*heap*[(*i* - 1) / 2]: Returns the parent node'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*heap*[(*i* - 1) / 2]：返回父节点'
- en: '*heap*[(2 * *i*) + 1]: Returns the left child node'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*heap*[(2 * *i*) + 1]：返回左子节点'
- en: '*heap*[(2 * *i*) + 2]: Returns the right child node'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*heap*[(2 * *i*) + 2]：返回右子节点'
- en: 'A Max Binary Heap, when implemented via an array, looks as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过数组实现最大二叉堆时，它看起来如下：
- en: '[PRE6]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The common operations that are used with a heap are `add()`, `poll()`, and `peek()`.
    After adding or polling an element, we must fix the heap so that it respects the
    heap property. This step is commonly referenced as *heapifying* the heap.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与堆一起使用的常见操作是`add()`、`poll()`和`peek()`。添加或轮询元素后，我们必须修复堆，以使其符合堆属性。这一步通常被称为*堆化*堆。
- en: 'Adding an element to a heap is an O(log n) time operation. The new element
    is added at the end of the heap tree. If the new element is smaller than its parent,
    then we don''t need to do anything. Otherwise, we have to traverse the heap upward
    to fix the violated heap property. This operation is known as *heapify-up*. The
    algorithm behind *heapify-up* has two steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 向堆中添加元素是一个O(log n)的时间操作。新元素添加到堆树的末尾。如果新元素小于其父元素，则我们不需要做任何操作。否则，我们必须向上遍历堆以修复违反的堆属性。这个操作被称为*堆化上*。*堆化上*背后的算法有两个步骤：
- en: Start from the end of the heap as the current node.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从堆的末尾开始作为当前节点。
- en: While the current node has a parent and the parent is less than the current
    node, swap these nodes.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前节点有父节点且父节点小于当前节点时，交换这些节点。
- en: 'Polling an element from a heap is also an O(log n) time operation. After we''ve
    polled the root element of the heap, we have to fix the heap so that it respects
    the heap property. This operation is known as *heapify-down*. The algorithm behind
    *heapify-down* has three steps:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从堆中轮询元素也是一个O(log n)的时间操作。在我们轮询了堆的根元素之后，我们必须修复堆，使其遵守堆属性。这个操作被称为*heapify-down*。*heapify-down*背后的算法有三个步骤：
- en: Start from the root of the heap as the current node.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从堆的根开始作为当前节点。
- en: Determine the largest node between the children of the current node.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定当前节点的子节点中最大的节点。
- en: If the current node is less than its largest children, then swap these two nodes
    and repeat from *step 2*; otherwise, there is nothing else to do, so stop.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前节点小于其最大的子节点，则交换这两个节点，并从*步骤2*重复；否则，没有其他事情可做，所以停止。
- en: Finally, peeking is an O(1) operation that returns the root element of the heap.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，peeking是一个O(1)的操作，返回堆的根元素。
- en: 'In the code bundled with this book, you can find an application called *MaxHeap*
    that exposes the following set of methods: `add(T element)`, `peek()`, and `poll()`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书附带的代码中，您可以找到一个名为*MaxHeap*的应用程序，它公开了以下一组方法：`add(T element)`、`peek()`和`poll()`。
- en: Important note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A special case of a tree is known as a Trie. Also known as a *digital tree*
    or a *prefix tree,* a Trie is an ordered tree structure used commonly for storing
    strings. Its name comes from the fact that Trie is a re*Trie*val data structure.
    Its performance is better than a binary tree. Trie is detailed in my book, *Java
    Coding Problems* ([https://www.packtpub.com/programming/java-coding-problems](https://www.packtpub.com/programming/java-coding-problems)),
    next to other data structures such as tuples, disjoint-set, binary indexed trees
    (Fenwick trees), and Bloom filters.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 树的一个特殊情况被称为Trie。Trie也被称为*数字树*或*前缀树*，是一种用于存储字符串的有序树结构。它的名称来自于Trie是一种检索数据结构。它的性能比二叉树好。Trie在我的书《Java编程问题》中有详细介绍（[https://www.packtpub.com/programming/java-coding-problems](https://www.packtpub.com/programming/java-coding-problems)），以及其他数据结构，如元组、不相交集、二进制索引树（Fenwick树）和Bloom过滤器。
- en: Next, let's have a brief overview of graphs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们简要概述一下图。
- en: Graphs in a nutshell
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图简介
- en: A graph is a data structure that's used to represent a collection of nodes that
    can be connected with edges. For example, a graph can be used to represent a network
    of members on a social media platform, so it is a great data structure for representing
    real-life connections. A tree (as detailed in the previous section) is a particular
    type of graph. In other words, a tree is a graph without cycles. In graph terms,
    a graph without cycles is called an *acyclic graph*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图是用于表示可以通过边连接的节点集合的数据结构。例如，图可以用于表示社交媒体平台上成员的网络，因此它是表示现实生活连接的良好数据结构。树（如前一节中详细介绍的）是图的一种特殊类型。换句话说，树是没有循环的图。在图的术语中，没有循环的图被称为*无环图*。
- en: 'The specific terminology for graphs involves two main terms:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图的特定术语涉及两个主要术语：
- en: '**Vertex** represents the information (for example, a member, a dog, or a value)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点**表示信息（例如成员、狗或值）'
- en: '**Edge** is the connection or the relationship between two vertices'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边**是两个顶点之间的连接或关系'
- en: The connection can be unidirectional (as in the case of binary trees) or bidirectional.
    When the connection is bidirectional (such as a two-way street), the graph is
    known as an *undirected graph* and it has *undirected edges*. When the connection
    is unidirectional (such as a one-way street), then the graph is known as a *directed
    graph* and it has *directed edges*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 连接可以是单向的（如二叉树的情况）或双向的。当连接是双向的（比如双向街道）时，图被称为*无向图*，它有*无向边*。当连接是单向的（比如单向街道）时，图被称为*有向图*，它有*有向边*。
- en: 'The edges of a graph can carry information known as the weight (for example,
    the length of a road). In this case, the graphs are called *weighted graphs*.
    When a graph has a single edge that points to the same vertex, it is called a
    *self-loop graph*. The following diagram provides representations for each of
    these graph types:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图的边可以携带称为权重的信息（例如，道路的长度）。在这种情况下，图被称为*加权图*。当图有一个指向相同顶点的单个边时，它被称为*自环图*。下图提供了每种图类型的表示：
- en: '![Figure 13.12 – Graph types'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.12 - 图类型'
- en: '](img/Figure_13.12_B15403.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.12_B15403.jpg)'
- en: Figure 13.12 – Graph types
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12 - 图类型
- en: Unlike binary trees, representing graphs via node links is not practical. In
    computers, a graph is commonly represented via the adjacency matrix or adjacency
    list. Let's tackle the former; that is, the adjacency matrix.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与二叉树不同，通过节点链接表示图形是不实际的。在计算机中，图通常通过邻接矩阵或邻接表表示。让我们来解决前者；也就是邻接矩阵。
- en: Adjacency matrix
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邻接矩阵
- en: 'An adjacency matrix is represented by a boolean two-dimensional array (or an
    integer two-dimensional array that contains only 0s and 1s) of size *n* x *n*,
    where *n* is the number of vertices. If we denote this two-dimensional array as
    a *matrix,* then *matrix*[*i*][*j*] is true (or 1) if there is an edge from vertex
    *i* to vertex *j*; otherwise, it is false (or 0). The following diagram shows
    an example of an adjacency matrix for an undirected graph:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接矩阵由一个大小为*n* x *n*的布尔二维数组（或只包含0和1的整数二维数组）表示，其中*n*是顶点的数量。如果我们将这个二维数组表示为一个*矩阵*，那么*matrix*[*i*][*j*]为true（或1），如果从顶点*i*到顶点*j*有一条边；否则为false（或0）。下图显示了一个无向图的邻接矩阵的示例：
- en: '![Figure 13.13 – An adjacency matrix for an undirected graph'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.13 - 无向图的邻接矩阵'
- en: '](img/Figure_13.13_B15403.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.13_B15403.jpg)'
- en: Figure 13.13 – An adjacency matrix for an undirected graph
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.13 - 无向图的邻接矩阵
- en: In order to save space, a bit-matrix can be used as well.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，也可以使用位矩阵。
- en: In the case of weighted graphs, the adjacency matrix can store the weight of
    the edge, while 0 can be used to indicate the absence of the edge.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在加权图的情况下，邻接矩阵可以存储边的权重，而0可以用于表示边的不存在。
- en: 'Implementing a graph based on the adjacency matrix can be done as follows (all
    we need is the list of vertices since the edges are passed to each method that
    has to traverse the graph as the adjacency matrix):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 根据邻接矩阵实现图可以如下进行（我们只需要顶点列表，因为边被传递给每个必须遍历图的方法，作为邻接矩阵的一部分）：
- en: '[PRE7]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Another approach we can use to represent a graph in a computer is the adjacency
    list.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用另一种方法来在计算机中表示图，那就是邻接表。
- en: Adjacency list
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邻接表
- en: 'An adjacency list is an array of lists whose size is equal to the number of
    vertices in the graph. Every vertex is stored in this array and it stores a list
    of adjacent vertices. In other words, the list at index *i* of the array contains
    the adjacent vertices of the vertex stored in the array at index *i*. The following
    diagram shows an example of an adjacency list for an undirected graph:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接表是一个列表数组，其大小等于图中顶点的数量。每个顶点都存储在这个数组中，并且它存储了一个相邻顶点的列表。换句话说，数组中索引*i*处的列表包含了存储在数组索引*i*处的顶点的相邻顶点。下图显示了一个无向图的邻接表示例：
- en: '![Figure 13.14 – An adjacency list for an undirected graph'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.14 - 无向图的邻接表'
- en: '](img/Figure_13.14_B15403.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.14_B15403.jpg)'
- en: Figure 13.14 – An adjacency list for an undirected graph
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14 - 无向图的邻接表
- en: 'Implementing a graph based on the adjacency list can be done as follows (here,
    we are using a `Map` to implement the adjacency list):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 根据邻接表实现图可以如下进行（这里，我们使用`Map`来实现邻接表）：
- en: '[PRE8]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, let's briefly cover the traversal of a graph.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们简要介绍一下图的遍历。
- en: Graph traversal
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图的遍历
- en: The two most common ways to traverse a graph are via **Depth-first Search**
    (**DFS**) and **Breadth-first Search** (**BFS**). Let's have a rundown of each.
    **BFS** is mainly used for graphs.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历图的两种最常见方法是**深度优先搜索**（**DFS**）和**广度优先搜索**（**BFS**）。让我们简要介绍一下每种方法。**BFS**主要用于图。
- en: 'In the case of graphs, we must consider that a graph may have cycles. A plain
    BFS implementation (as you saw in the case of binary trees) doesn''t take cycles
    into account, so we risk an infinite loop while traversing the BFS queue. Eliminating
    this risk can be done via an additional collection that holds the visited nodes.
    The steps for this algorithm are as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在图的情况下，我们必须考虑到图可能有循环。普通的BFS实现（就像你在二叉树的情况下看到的那样）不考虑循环，所以在遍历BFS队列时存在无限循环的风险。通过额外的集合来消除这种风险，这个集合保存了已访问的节点。该算法的步骤如下：
- en: Mark the start node (current node) as visited (add it to the collection of visited
    nodes) and add it to the BFS queue.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将起始节点（当前节点）标记为已访问（将其添加到已访问节点的集合中）并将其添加到BFS队列中。
- en: Pop the current node from the queue.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从队列中弹出当前节点。
- en: Visit the current node.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问当前节点。
- en: Get the adjacent nodes of the current node.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取当前节点的相邻节点。
- en: 'Loop the adjacent nodes. For each non-null and unvisited node, do the following:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环相邻节点。对于每个非空且未访问的节点，执行以下操作：
- en: a. Mark it as visited (add it to the collection of visited nodes).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: a. 将其标记为已访问（将其添加到已访问节点的集合中）。
- en: b. Add it to the queue.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: b. 将其添加到队列中。
- en: Repeat from *step 2* until the queue is empty.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复从*步骤2*直到队列为空。
- en: Depth-first Search (DFS) for graphs
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图的深度优先搜索（DFS）
- en: In the case of graphs, we can implement the DFS algorithm via recursion or iterative
    implementation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '在图的情况下，我们可以通过递归或迭代实现DFS算法。 '
- en: DFS for graphs via recursion
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过递归实现图的DFS
- en: 'The steps for implementing the DFS algorithm for graphs via recursion are as
    follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过递归实现图的DFS算法的步骤如下：
- en: Start from the current node (the given node) and mark the current node as visited
    (add it to the collection of visited nodes).
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从当前节点（给定节点）开始，并将当前节点标记为已访问（将其添加到已访问节点的集合中）。
- en: Visit the current node.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问当前节点。
- en: Traverse the unvisited adjacent vertices via recursion.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过递归遍历未访问的相邻顶点。
- en: DFS for graphs – iterative implementation
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 图的深度优先搜索 - 迭代实现
- en: 'The iterative implementation of the DFS algorithm relies on a `Stack`. The
    steps are as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: DFS算法的迭代实现依赖于`Stack`。步骤如下：
- en: Start from the current node (the given node) and push the current node into
    `Stack`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从当前节点（给定节点）开始，并将当前节点推入`Stack`。
- en: 'While `Stack` is not empty, do the following:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`Stack`不为空时，执行以下操作：
- en: a. Pop the current node from `Stack.`
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: a. 从`Stack`中弹出当前节点。
- en: b. Visit the current node.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: b. 访问当前节点。
- en: c. Mark the current node as visited (add it to the collection of visited nodes).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: c. 将当前节点标记为已访问（将其添加到已访问节点的集合中）。
- en: d. Push the unvisited adjacent vertices into `Stack`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: d. 将未访问的相邻顶点推入`Stack`。
- en: In the code bundled with this book, you can find a graph implementation based
    on the adjacency matrix called *GraphAdjacencyMatrixTraversal.* You can also find
    one based on the adjacency list called *GraphAdjacencyListTraversal.* Both applications
    contain BFS and DFS implementations.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书附带的代码中，你可以找到基于邻接矩阵的图实现，名为*GraphAdjacencyMatrixTraversal*。你还可以找到一个基于邻接表的实现，名为*GraphAdjacencyListTraversal*。这两个应用程序都包含了BFS和DFS的实现。
- en: Coding challenges
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程挑战
- en: Now that we have had a brief overview of trees and graphs, it is time to challenge
    ourselves with the 25 most popular coding problems encountered in interviews about
    these topics.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要了解了树和图，是时候挑战自己，解决关于这些主题的面试中遇到的25个最受欢迎的编程问题了。
- en: As usual, we have a mix of problems that are usually encountered by the top
    companies of the world, including IT giants such as Amazon, Adobe and Google.
    So, let's get started!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们有一系列通常由世界顶级公司遇到的问题，包括亚马逊、Adobe和谷歌等IT巨头。所以，让我们开始吧！
- en: Coding challenge 1 – Paths between two nodes
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战1 - 两个节点之间的路径
- en: '`true` if there is a path (route) between two given nodes.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个给定节点之间存在路径（路由），则返回`true`。
- en: '**Solution**: Let''s consider the directed graph shown in the following diagram:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们考虑下图所示的有向图：'
- en: '![Figure 13.15 – Paths from D to E and vice versa'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.15 - 从D到E和从E到D的路径'
- en: '](img/Figure_13.15_B15403.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.15_B15403.jpg)'
- en: Figure 13.15 – Paths from D to E and vice versa
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.15 - 从D到E和从E到D的路径
- en: 'If we consider nodes *D* and *E*, then we can see that from *D* to *E*, there
    are three paths, while from *E* to *D*, there are none. So, if we start from *D*
    and traverse the graph (via BFS or DFS) then, at some point, we have to pass through
    node *E*, otherwise there will be no path between *D* and *E*. So, the solution
    to this problem consists of starting from one of the given nodes and traversing
    the graph until we reach the second given node or until there are no more valid
    moves. For example, we can do this via BFS as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑节点*D*和*E*，我们可以看到从*D*到*E*有三条路径，而从*E*到*D*没有路径。因此，如果我们从*D*开始遍历图（通过BFS或DFS），那么在某个时候，我们必须经过节点*E*，否则*D*和*E*之间将没有路径。因此，解决这个问题的解决方案包括从给定节点中的一个开始，并遍历图直到到达第二个给定节点，或者直到没有更多有效的移动。例如，我们可以通过BFS来做到这一点：
- en: '[PRE9]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The complete application is called *DirectedGraphPath.*
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*DirectedGraphPath*。
- en: Coding challenge 2 – Sorted array to minimal BST
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战2 - 排序数组到最小BST
- en: '**Amazon**, **Google**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**'
- en: '**Problem**: Consider you''ve been given a sorted (ascending order) array of
    integers. Write a snippet of code that creates the minimal BST from this array.
    We define the minimal BST as the BST with the minimum height.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你得到了一个有序（升序）的整数数组。编写一小段代码，从这个数组创建最小的BST。我们将最小的BST定义为高度最小的BST。'
- en: '**Solution**: Consider the given array as {-2, 3, 4, 6, 7, 8, 12, 23, 90}.
    The minimal BST that can be created from this array looks as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：将给定的数组视为{-2, 3, 4, 6, 7, 8, 12, 23, 90}。可以从该数组创建的最小BST如下所示：'
- en: '![Figure 13.16 – Sorted array to minimal BST'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.16 - 排序数组到最小BST'
- en: '](img/Figure_13.16_B15403.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.16_B15403.jpg)'
- en: Figure 13.16 – Sorted array to minimal BST
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.16 - 排序数组到最小BST
- en: In order to obtain a BST of minimal height, we must strive to distribute an
    equal number of nodes in the left and right sub-trees. With this statement in
    mind, note that we can choose the middle of the sorted array as the root. The
    elements of the array on the left-hand side of the middle are smaller than the
    middle, so they can form the left sub-tree. The elements of the array on the right-hand
    side of the middle are greater than the middle, so they can form the right sub-tree.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最小高度的BST，我们必须努力在左右子树中分配相等数量的节点。考虑到这一点，注意到我们可以选择排序数组的中间值作为根。中间值左侧的数组元素小于中间值，因此它们可以形成左子树。中间值右侧的数组元素大于中间值，因此它们可以形成右子树。
- en: 'So, we can choose 7 as the root of the tree. Next, -2, 3, 4, and 6 should form
    the left sub-tree, while 8, 12, 23, and 90 should form the right sub-tree. However,
    we know that we cannot simply add these elements to the left or right sub-trees
    since we have to respect the BST property: in a BST, for each node, *n*, the *left
    descendants of n ≤ n < right descendants of n*.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以选择7作为树的根。接下来，-2、3、4和6应该形成左子树，而8、12、23和90应该形成右子树。然而，我们知道我们不能简单地将这些元素添加到左子树或右子树，因为我们必须遵守BST属性：在BST中，对于每个节点*n*，*n*的左子节点≤*n*<*n*的右子节点。
- en: However, we can simply follow the same technique. If we consider -2, 3, 4, and
    6 as an array, then its middle is 3, and if we consider 8, 12, 24, and 90 as an
    array, then its middle is 12\. So, 3 is the root of the left sub-sub-tree containing
    -2, and the right sub-sub-tree is the one that contains 4 and 6\. Similarly, 12
    is the root of the left sub-sub-tree containing 8, and the right sub-sub-tree
    is the one that contains 24 and 90\.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以简单地遵循相同的技术。如果我们将-2、3、4和6视为一个数组，那么它的中间值是3，如果我们将8、12、24和90视为一个数组，那么它的中间值是12。因此，3是包含-2的左子子树的根，右子子树是包含4和6的子树。同样，12是包含8的左子子树的根，右子子树是包含24和90的子树。
- en: 'Well, I think we have enough experience to intuit that the same technique can
    be applied until we''ve processed all the sub-arrays. Moreover, it is quite intuitive
    that this solution can be implemented via recursion (if you don''t consider recursion
    one of your top skills, review [*Chapter 8*](B15403_08_Final_JM_ePub.xhtml#_idTextAnchor161)*,
    Recursion and Dynamic Programming*). So, we can resume our algorithm in four steps:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我认为我们有足够的经验来直觉地应用相同的技术，直到我们处理完所有的子数组。此外，很直观地，这个解决方案可以通过递归来实现（如果你不认为递归是你的顶级技能之一，请查看[*第8章*](B15403_08_Final_JM_ePub.xhtml#_idTextAnchor161)*，递归和动态规划*）。因此，我们可以将我们的算法总结为四个步骤：
- en: Insert the middle element of the array into the tree.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数组的中间元素插入树中。
- en: Insert the elements of the left sub-array into the left sub-tree.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将左子数组的元素插入左子树。
- en: Insert the elements of the right sub-array into the right sub-tree.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将右子数组的元素插入右子树。
- en: Trigger the recursive call.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发递归调用。
- en: 'The following implementation puts these steps into code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实现将这些步骤转化为代码：
- en: '[PRE10]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The complete application is called *SortedArrayToMinBinarySearchTree.*
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*SortedArrayToMinBinarySearchTree*。
- en: Coding challenge 3 – List per level
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战3 - 每层列表
- en: '**Problem**: Consider you''ve been given a binary tree. Write a snippet of
    code that creates a list of elements for each level of the tree (for example,
    if the tree has a depth of *d*, then you''ll have *d* lists).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你得到了一个二叉树。编写一小段代码，为树的每一层创建一个元素列表（例如，如果树的深度为*d*，那么你将有*d*个列表）。'
- en: '**Solution**: Let''s consider the binary tree shown in the following diagram:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们考虑下面图中显示的二叉树：'
- en: '![Figure 13.17 – List per level'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.17 - 每层列表'
- en: '](img/Figure_13.17_B15403.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.17_B15403.jpg)'
- en: Figure 13.17 – List per level
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.17 - 每层列表
- en: So, we have a binary tree of depth 3\. On depth 0, we have the root, 40\. On
    depth 1, we have 47 and 45\. On depth 2, we have 11, 13, 44, and 88\. Finally,
    on depth 3, we have 3 and 1\.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个深度为3的二叉树。在深度0上，我们有根40。在深度1上，我们有47和45。在深度2上，我们有11、13、44和88。最后，在深度3上，我们有3和1。
- en: 'It is quite intuitive to think like this: if we traverse the binary tree level
    by level, then we can create a list of elements for each level. In other words,
    we can adapt the BFS algorithm (also known as Level-Order traversal) in such a
    way that we capture the elements at each traversed level. More precisely, we start
    by traversing the root (and create a list containing this element), continue by
    traversing level 1 (and create a list containing the elements from this level),
    and so on.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这样想是很直观的：如果我们逐级遍历二叉树，那么我们可以为每个级别创建一个元素列表。换句话说，我们可以调整BFS算法（也称为层次遍历），以便捕获每个遍历级别的元素。更确切地说，我们从遍历根节点开始（并创建一个包含此元素的列表），继续遍历第1级（并创建一个包含此级别的元素的列表），依此类推。
- en: 'When we reach level *i*, we will have already fully visited all the nodes on
    the previous level, *i*-1\. This means that to get the elements on level *i*,
    we must traverse all the children of the nodes of the previous level, *i*-1\.
    The following solution runs in O(n) time:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达第*i*级时，我们将已经完全访问了前一级，*i*-1上的所有节点。这意味着要获得第*i*级的元素，我们必须遍历前一级，*i*-1上的所有节点的子节点。以下解决方案需要O(n)时间运行：
- en: '[PRE11]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The complete application is called *ListPerBinaryTreeLevel.*
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*ListPerBinaryTreeLevel.*
- en: Coding challenge 4 – sub-tree
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战4 – 子树
- en: '**Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**Adobe**，**微软**，**Flipkart**'
- en: '`true` if *q* is a sub-tree of *p*.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*q*是*p*的子树，则返回`true`。
- en: '**Solution**: Consider the following diagram:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：考虑以下图表：'
- en: '![Figure 13.18 – Binary tree’s sub-tree of another binary tree'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.18 – 二叉树的另一个二叉树的子树'
- en: '](img/Figure_13.18_B15403.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.18_B15403.jpg)'
- en: Figure 13.18 – Binary tree's sub-tree of another binary tree
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.18 – 一个二叉树的子树
- en: As we can see, the binary tree in the middle, *q*, is a sub-tree of the *p1*
    binary tree (left-hand side) but is not a sub-tree of the *p2* binary tree (right-hand
    side).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，中间的二叉树*q*是*p1*二叉树（左侧）的子树，但不是*p2*二叉树（右侧）的子树。
- en: 'Moreover, this diagram reveals two cases:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该图表揭示了两种情况：
- en: If the root of *p* matches the root of *q* (*p.root.element == q.root.element*),
    then the problem reduces to check whether the right sub-tree of *q* is the same
    as the right sub-tree of *p,* or whether the left sub-tree of *q* is the same
    as the left sub-tree of *p*.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*p*的根与*q*的根匹配（*p.root.element == q.root.element*），那么问题就变成了检查*q*的右子树是否与*p*的右子树相同，或者*q*的左子树是否与*p*的左子树相同。
- en: If the root of *p* doesn't match the root of *q* (*p.root.element != q.root.element*),
    then the problem reduces to check whether the left sub-tree of *p* is the same
    as *q,* or whether the right sub-tree of *p* is the same as *q*.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*p*的根节点与*q*的根节点不匹配（*p.root.element != q.root.element*），那么问题就变成了检查*p*的左子树是否与*q*相同，或者*p*的右子树是否与*q*相同。
- en: 'In order to implement the first bullet, we need two methods. To better understand
    why we need two methods, check out the following diagram:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现第一个方法，我们需要两种方法。为了更好地理解为什么我们需要两种方法，请查看以下图表：
- en: '![Figure 13.19 – Roots and leaves match but the intermediate nodes don’t'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.19 – 根和叶匹配，但中间节点不匹配'
- en: '](img/Figure_13.19_B15403.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.19_B15403.jpg)'
- en: Figure 13.19 – Roots and leaves match but the intermediate nodes don't
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.19 – 根和叶匹配，但中间节点不匹配
- en: If the roots of *p* and *q* match but some of the nodes from the left/right
    sub-trees don't match, then we have to go back to where we started with *p* and
    *q* to check whether *q* is a sub-tree of *p*. The first method should check whether
    the trees are the same once their roots are the same. The second method should
    handle the case where we find that the trees are not the same but start at a certain
    node. Pay attention to this aspect, since many candidates don't take it into account.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*p*和*q*的根匹配，但左/右子树的一些节点不匹配，那么我们必须回到*p*和*q*的起点，检查*q*是否是*p*的子树。第一个方法应该检查根相同的情况下树是否相同。第二个方法应该处理我们发现树不相同但从某个节点开始的情况。注意这一点，因为许多候选人没有考虑到这一点。
- en: 'So, in terms of code, we have the following (for *n* nodes, this runs in O(n)
    time):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在代码方面，我们有以下内容（对于*n*个节点，这需要O(n)时间运行）：
- en: '[PRE12]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The application is called *BinaryTreeSubtree**.*
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序称为*BinaryTreeSubtree**.*
- en: Coding challenge 5 – Landing reservation system
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战5 – 着陆预订系统
- en: '**Amazon**, **Adobe**, **Microsoft**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**Adobe**，**微软**'
- en: '**Problem**: Consider an airport with a single runway. This airport receives
    landing requests from different airplanes. A landing request contains the landing
    time (for example, 9:56) and the time in minutes needed to complete the procedure
    (for example, 5 minutes). We denote it as 9:56 (5). Write a snippet of code that
    uses a BST to design this reservation system. Since there is a single runway,
    the code should reject any landing request that overlaps an existing one. The
    order of requests dictates the order of reservations.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个只有一条跑道的机场。这个机场接收来自不同飞机的着陆请求。着陆请求包含着陆时间（例如，9:56）和完成程序所需的分钟数（例如，5分钟）。我们将其表示为9:56（5）。编写一段代码，使用BST设计这个预订系统。由于只有一条跑道，代码应拒绝任何与现有请求重叠的着陆请求。请求的顺序决定了预订的顺序。'
- en: '**Solution**: Let''s consider a time screenshot of our landing timeline (the
    order for the landing requests was 10:10 (3), 10:14 (3), 9:55 (2), 10:18 (1),
    9:58 (5), 9:47 (2), 9:41 (2), 10:22 (1), 9:50 (6), and 10:04 (4). This can be
    seen in the following diagram:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们考虑一下我们着陆时间线的时间截图（着陆请求的顺序是10:10（3），10:14（3），9:55（2），10:18（1），9:58（5），9:47（2），9:41（2），10:22（1），9:50（6）和10:04（4）。这可以在以下图表中看到：'
- en: '![Figure 13.20 – Timeline screenshot'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.20 – 时间线截图'
- en: '](img/Figure_13.20_B15403.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.20_B15403.jpg)'
- en: Figure 13.20 – Timeline screenshot
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.20 – 时间线截图
- en: 'So, we have already done several reservations, as follows: at 9:41, an airplane
    will land and it will need 2 minutes to complete the procedure; at 9:47 and 9:55,
    there are two other airplanes that need 2 minutes to complete landing; at 9:58,
    we have an airplane that needs 5 minutes to complete landing; and so on. Moreover,
    we also have two new landing requests denoted in the diagram as *R1* and *R2*.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经做了几次预订，如下：在9:41，一架飞机将着陆，需要2分钟完成程序；在9:47和9:55，还有两架飞机需要2分钟完成着陆；在9:58，我们有一架飞机需要5分钟完成着陆；等等。此外，我们还有两个新的着陆请求，图中标记为*R1*和*R2*。
- en: Notice that we cannot approve the *R1* landing request. The landing time is
    9:50 and it needs 6 minutes to complete, so it ends at 9:56\. However, at 9:56,
    we already have the airplane from 9:55 on the runway. Since we have a single runway,
    we reject this landing request. We consider such cases as overlappings.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们无法批准*R1*着陆请求。着陆时间是9:50，需要6分钟完成，所以在9:56结束。然而，在9:56时，我们已经有了来自9:55的飞机。由于我们只有一个跑道，我们拒绝了这个着陆请求。我们认为这种情况是重叠的。
- en: On the other hand, we approve the *R2* landing request. The request time is
    10:04 and it needs 4 minutes to complete, so it ends at 10:08\. At 10:08, there
    is no other airplane on the runway since the next landing is at 10:10.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们批准*R2*着陆请求。请求时间是10:04，需要4分钟完成，所以在10:08结束。在10:08时，跑道上没有其他飞机，因为下一次着陆是在10:10。
- en: Notice that we have to use a BST to solve this problem, but using an array (sorted
    or unsorted) or a linked list (sorted or unsorted) is also a valid approach. Using
    an unsorted array (or linked list) will need O(1) time for inserting a landing
    request and O(n) time for checking the potential overlapping. If we were to use
    a sorted array (or linked list) and the Binary Search algorithm, then we could
    check the potential overlapping in O(log n). However, to insert a landing request,
    we will need O(n) because we have to shift all the elements to the right from
    the position of insertion.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须使用BST来解决这个问题，但使用数组（排序或未排序）或链表（排序或未排序）也是一种有效的方法。使用未排序的数组（或链表）将需要O(1)时间来插入着陆请求，并且需要O(n)时间来检查潜在的重叠。如果我们使用排序的数组（或链表）和二分搜索算法，那么我们可以在O(log
    n)时间内检查潜在的重叠。但是，要插入着陆请求，我们将需要O(n)，因为我们必须将插入位置右侧的所有元素移动。
- en: 'How about using a BST? First, let''s represent the preceding timeline screenshot
    as a BST. Check out the following diagram (the order of the landing requests was
    10:10 (3), 10:14 (3), 9:55 (2), 10:18 (1), 9:58 (5), 9:47 (2), 9:41 (2), 10:22
    (1), *9:50 (6)*, and 10:04 (4)):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用BST如何？首先，让我们将前面的时间线截图表示为BST。请查看以下图表（着陆请求的顺序是10:10（3），10:14（3），9:55（2），10:18（1），9:58（5），9:47（2），9:41（2），10:22（1），*9:50（6）*和10:04（4））：
- en: '![Figure 13.21 – Timeline screenshot as a BST'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.21-时间线截图作为BST'
- en: '](img/Figure_13.21_B15403.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.21_B15403.jpg)'
- en: Figure 13.21 – Timeline screenshot as a BST
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.21-时间线截图作为BST
- en: This time, for each landing request, we only have to scan half of the tree.
    This is the consequence of using a BST (all the nodes on the left are smaller
    than all the nodes on the right, so a landing request time can only be in the
    left or the right sub-tree). For example, the landing request at 10:04 is less
    than the root (10:10), so it goes in the left sub-tree. If, at any given landing
    request, we encounter an overlapping, then we just return without inserting the
    corresponding node into the tree. We can find the potential overlappings in O(h),
    where *h* is the height of the BST, and we can insert it in O(1) time.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，对于每个着陆请求，我们只需要扫描树的一半。这是使用BST的结果（左侧的所有节点都小于右侧的所有节点，因此着陆请求时间只能在左侧或右侧子树中）。例如，10:04的着陆请求小于根（10:10），因此它进入左子树。如果在任何给定的着陆请求中，我们遇到重叠，那么我们只需返回而不将相应的节点插入树中。我们可以在O(h)时间内找到潜在的重叠，其中*h*是BST的高度，并且我们可以在O(1)时间内插入它。
- en: 'An overlapping is given by the following simple computation (we''re using the
    Java 8 Date-Time API, but you can reduce it to simple integers as well – if you
    are not familiar with the Java 8 Date-Time API, then I strongly recommend that
    you buy my book, *Java Coding Problems*, published by Packt ([https://www.packtpub.com/programming/java-coding-problems](https://www.packtpub.com/programming/java-coding-problems)).
    This book has an astonishing chapter about this topic that is a *must-read* for
    any candidate:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 重叠由以下简单的计算给出（我们使用Java 8日期时间API，但您也可以将其简化为简单的整数-如果您不熟悉Java 8日期时间API，那么我强烈建议您购买我的书*Java编码问题*，由Packt出版（[https://www.packtpub.com/programming/java-coding-problems](https://www.packtpub.com/programming/java-coding-problems)）。这本书有一章关于这个主题的惊人章节，对于任何候选人来说都是*必读*：
- en: '[PRE13]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So, in *t1*, we compute the time between the (*landing time* + *time needed
    to complete*) of the current node and the *landing time* of the current request.
    In *t2*, we compute the time between the *landing time* of the current node and
    the (*current request landing time* + *time needed to complete*). If *t1* is less
    than or equal to *t2*, then we have found an overlapping, so we reject the current
    landing request. Let''s see the complete code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在*t1*中，我们计算当前节点的（*着陆时间*+*完成所需时间*）与当前请求的*着陆时间*之间的时间。在*t2*中，我们计算当前节点的*着陆时间*与（*当前请求的着陆时间*+*完成所需时间*）之间的时间。如果*t1*小于或等于*t2*，那么我们已经找到了一个重叠，因此我们拒绝当前的着陆请求。让我们看看完整的代码：
- en: '[PRE14]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that we can easily print the timeline by using the In-Order traversal
    of a BST. The complete application is called *BinaryTreeLandingReservation.*
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以通过使用BST的中序遍历轻松打印时间线。完整的应用程序称为*BinaryTreeLandingReservation*。
- en: Coding challenge 6 – Balanced binary tree
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战6-平衡二叉树
- en: '**Amazon**, **Microsoft**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**微软**'
- en: '`true` if the binary tree is balanced.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果二叉树是平衡的，则为`true`。
- en: '**Solution**: So, in order to have a balanced binary tree, for each node, the
    two sub-trees cannot differ in height by more than one. Conforming to this statement,
    the image on the right represents a balanced binary tree, while the image on the
    left represents an unbalanced binary tree:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：因此，为了拥有平衡的二叉树，对于每个节点，两个子树的高度不能相差超过一。遵循这个声明，右侧的图像代表一个平衡的二叉树，而左侧的图像代表一个不平衡的二叉树：'
- en: '![Figure 13.22 – Unbalanced and balanced binary trees'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.22 – 不平衡和平衡二叉树'
- en: '](img/Figure_13.22_B15403.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.22_B15403.jpg)'
- en: Figure 13.22 – Unbalanced and balanced binary trees
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.22 – 不平衡和平衡二叉树
- en: The binary tree on the left is unbalanced since the difference between the heights
    of the left sub-trees corresponding to nodes 40 (the root) and 30 and the right
    sub-trees is greater than one (for example, the *left-height*(40) = 4 while the
    *right-height*(40) = 2).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的二叉树不平衡，因为根节点40和30的左子树的高度和右子树的高度之差大于一（例如，*left-height*(40) = 4，而*right-height*(40)
    = 2）。
- en: The right-hand side binary tree is balanced since, for each node, the difference
    between the height of the left sub-tree and the right sub-tree is not greater
    than one.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的二叉树是平衡的，因为对于每个节点，左子树和右子树的高度差不大于一。
- en: 'Based on this example, we can intuit that a simple solution consists of a recursive
    algorithm. We can traverse each node and compute the height of the left and right
    sub-trees. If the difference between these heights is greater than one, then we
    return `false`. In terms of code, this is quite straightforward:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个例子，我们可以直观地得出一个简单的解决方案，即递归算法。我们可以遍历每个节点并计算左右子树的高度。如果这些高度之间的差大于一，那么我们返回`false`。在代码方面，这非常简单：
- en: '[PRE15]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This approach performs in O(n log n) time because, on each node, we apply the
    recursion through its entire sub-tree. So, the problem is the number of `height()`
    calls. At this moment, the `height()` method only computes the heights. But it
    can be improved to check whether the tree is balanced as well. All we need to
    do is signal an unbalanced sub-tree via an error code. On the other hand, for
    a balanced tree, we return the corresponding height. In place of an error code,
    we can use `Integer.MIN_VALUE`, as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的执行时间为O(n log n)，因为在每个节点上，我们通过整个子树应用递归。因此，问题在于`height()`调用的次数。目前，`height()`方法只计算高度。但它可以改进为检查树是否平衡。我们只需要通过错误代码来表示不平衡的子树。另一方面，对于平衡树，我们返回相应的高度。我们可以使用`Integer.MIN_VALUE`代替错误代码，如下所示：
- en: '[PRE16]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code runs in O(n) time and O(h) space, where *h* is the height of the tree.
    The application is called *BinaryTreeBalanced.*
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行时间为O(n)，空间为O(h)，其中*h*是树的高度。该应用程序称为*BinaryTreeBalanced*。
- en: Coding challenge 7 – Binary tree is a BST
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战7 – 二叉树是BST
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '`true` if this tree is a **Binary Search Tree** (**BST**).'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`true`如果这棵树是**二叉搜索树**（**BST**）。'
- en: '**Solution**: Right from the start, we notice that the problem is explicitly
    mentioning that the given binary tree may contain duplicates. Why is this important?
    Because if the binary tree doesn''t allow duplicates, then we can rely on a simple
    In-Order traversal and an array. If we add each traversed element to an array,
    then the resulting array will be sorted only if the binary tree is a BST. Let''s
    clarify this aspect via the following diagram:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：从一开始，我们注意到问题明确提到给定的二叉树可能包含重复项。为什么这很重要？因为如果二叉树不允许重复项，那么我们可以依赖简单的中序遍历和数组。如果我们将每个遍历的元素添加到数组中，那么结果数组只有在二叉树是BST时才会排序。让我们通过以下图表澄清这一方面：'
- en: '![Figure 13.23 – Valid and invalid BSTs'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.23 – 有效和无效的BSTs'
- en: '](img/Figure_13.23_B15403.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.23_B15403.jpg)'
- en: Figure 13.23 – Valid and invalid BSTs
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.23 – 有效和无效的BSTs
- en: We know that the BST property says that for each node, *n*, of a BST, the *left
    descendants of n ≤ n < right descendants of n*. This means that the first two
    binary trees shown in the previous diagram are valid BST, while the last one is
    not a valid BST. Now, adding the elements of the middle and the last binary tree
    to the array will result in an array of [40, 40]. This means we cannot validate
    or invalidate a BST based on this array since we cannot distinguish between the
    trees. So, in conclusion, you should rely on this simple algorithm if the given
    binary tree doesn't accept duplicates.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道BST属性表示BST的每个节点*n*的*左子代n ≤ n < 右子代n*。这意味着前面图表中显示的前两个二叉树是有效的BST，而最后一个不是有效的BST。现在，将中间和最后一个二叉树的元素添加到数组中将得到一个数组[40,
    40]。这意味着我们无法根据此数组验证或使BST无效，因为我们无法区分树。因此，总之，如果给定的二叉树不接受重复项，您应该依赖这个简单的算法。
- en: 'Now, it''s time to take this a step further. Let''s examine the *left descendants
    of n ≤ n < right descendants of n* statement shown in the following binary tree:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候更进一步了。让我们检查下面二叉树中所示的*n ≤ n < n的左子代*语句：
- en: '![Figure 13.24 – Invalid BST](img/Figure_13.24_B15403.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图13.24 – 无效的BST](img/Figure_13.24_B15403.jpg)'
- en: Figure 13.24 – Invalid BST
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.24 – 无效的BST
- en: Check this out! For each node, *n*, we can write that *n.left ≤ n < n.right*,
    but it is clear that 55 is in the wrong place. So, let's reinforce that all the
    left nodes of the current node should be less than or equal to the current node,
    which must be less than all the right nodes.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个！对于每个节点*n*，我们可以写成*n.left ≤ n < n.right*，但很明显55放错了地方。所以，让我们强调当前节点的所有左节点应小于或等于当前节点，当前节点必须小于所有右节点。
- en: 'In other words, it is not enough to validate the left and right nodes of the
    current node. We must validate each node against a range of nodes. More precisely,
    all the nodes of a left or a right sub-tree should be validated against a range
    bounded by the minimum accepted element, respectively the maximum accepted element
    (*min, max*). Let''s consider the following tree:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.25 – Validating a BST'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.25_B15403.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.25 – Validating a BST
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'We start from the root (40) and we consider (*min*=null, *max*=null), so 40
    meets the condition since there is no minimum or maximum limit. Next, we go to
    the left sub-tree (let''s denote this sub-tree as 40-left-sub-tree). All the nodes
    from the 40-left-sub-tree should range between (null, 40). Next, we go to the
    left again, and we meet the 35-left-sub-tree, which should range between (null,
    35). Basically, we continue to go left until there are no nodes left. At this
    point, we start going to the right, so the 35-right-sub-tree should range between
    (35, 40), the 40-right-sub-tree should range between (40, null), and so on. So,
    when we go to the left, the maximum value gets updated. When we go to the right,
    the minimum gets updated. If anything goes wrong, then we stop and return `false`.
    Let''s see the code based on this algorithm:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The complete application is called *BinaryTreeIsBST.*
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 8 – Successor node
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Google**, **Microsoft**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a **Binary Search Tree** (**BST**)
    and a node from this tree. Write a snippet of code that prints the successor node
    of the given node in the context of In-Order traversal.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: So, let''s recall the In-Order traversal of a binary tree. This
    **Depth-first Search** (**DFS**) flavor traverses the left sub-tree, then the
    current node, and then the right sub-tree. Now, let''s assume that we arbitrarily
    choose a node from a BST (let''s denote it as *n*) and we want to find its successor
    (let''s denote it as *s*) in the context of In-Order traversal.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following diagram as the given BST. We can use it as support
    for distinguishing between the possible cases:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.26 – BST sample with start and successor nodes'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.26_B15403.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.26 – BST sample with start and successor nodes
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding diagram, we denoted two main cases as (a) and (b).
    In case (a), the node, *n*, has the right sub-tree. In case (b), the node, *n*,
    doesn't contain the right sub-tree.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Case (a), exemplified in the left-hand side BST, reveals that if the node, *n*,
    has the right sub-tree, then the successor node, *s*, is the leftmost node of
    this right sub-tree. For example, for *n*=50, the successor node is 54.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'Case (b) has two sub-cases: a simple case and a tricky case. The simple case
    is exemplified by the middle BST shown in the preceding diagram. When the node,
    *n*, doesn''t contain the right sub-tree and *n* is the left child of its parent,
    then the successor node is this parent. For example, for *n*=40, the successor
    node is 50\. This is the simple sub-case of (b).'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The tricky sub-case of (b) is exemplified by the right-hand side BST shown in
    the preceding diagram. When the node, *n*, doesn't contain the right sub-tree
    and *n* is the right child of its parent, then we have to traverse upward until
    *n* becomes the left child of its parent. Once we've done that, we return this
    parent. For example, if *n*=59, then the successor node is 60.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we must consider that if *n* is the last node in the traversal, then
    we return the root's parent, which can be null.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'If we glue these cases to form some pseudocode, then we get the following:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we can translate this pseudocode into code, as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The complete application is called *BinarySearchTreeSuccessor**.* This application
    also contains the same problem, but is resolved via Pre-Order and Post-Order traversal.
    Before checking the solutions for the Pre-Order and Post-Order contexts, you should
    challenge yourself by identifying the possible cases and sketching the pseudocode
    and its implementation.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*BinarySearchTreeSuccessor*。这个应用程序也包含了同样的问题，但是通过先序遍历和后序遍历来解决。在检查先序遍历和后序遍历上下文的解决方案之前，你应该挑战自己，识别可能的情况，并勾画伪代码及其实现。
- en: Coding challenge 9 – Topological sort
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战9 – 拓扑排序
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider you''ve been given a **Directed Acyclic Graph** (**DAG**);
    that is, a directed graph without cycles. Write a snippet of code that returns
    the linear ordering of vertices such that for every directed edge, *XY*, vertex
    *X* comes before *Y* in the ordering. In other words, for every edge, the source
    node comes before the destination. This is also known as topological sort, and
    it only works for DAGs.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你已经得到了一个**有向无环图**（**DAG**）；即，一个没有循环的有向图。编写一小段代码，返回顶点的线性排序，使得对于每条有向边*XY*，顶点*X*在排序中出现在*Y*之前。换句话说，对于每条边，源节点在目标节点之前。这也被称为拓扑排序，它只适用于DAGs。 '
- en: '**Solution**: Let''s dive into this problem via the following DAG:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：让我们通过以下有向无环图（DAG）来深入研究这个问题：
- en: '![Figure 13.27 – Directed acyclic graph (DAG)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.27 – 有向无环图（DAG）'
- en: '](img/Figure_13.27_B15403.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.27_B15403.jpg)'
- en: Figure 13.27 – Directed acyclic graph (DAG)
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.27 – 有向无环图（DAG）
- en: Let's start the topological sort from vertex D. Before vertex D, there is no
    other vertex (no edge), so we can add D to the result, (D). From D, we can go
    to B or A. Let's go to vertex A. We cannot add A to the result because we didn't
    process vertex B of edge BA, so let's go to vertex B. Before B, we have only D,
    which was added to the result, so we can add B to the result, (D, B). From B,
    we can go to A, E, C, and F. We cannot go to C since we didn't process AC, and
    we cannot go to F since we didn't process CF. However, we can go to A since DA
    and BA have been processed, and we can go to E since before E, there's only B,
    which is in the result. Notice that the topological sort may provide different
    results. Let's go to E. Due to this, E is added to the result (D, B, E). Next,
    we can add A to the result, which allows us to add C, which allows us to add F.
    So, the result is now (D, B, E, A, C, F). From F, we can go to G. Since EG has
    been processed, we can add G to the result. Finally, from G, we go to H and we
    obtain the topological sort result as (D, B, E, A, C, F, G, H).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从顶点D开始进行拓扑排序。在顶点D之前，没有其他顶点（没有边），所以我们可以将D添加到结果中，(D)。从D，我们可以到达B或A。让我们去顶点A。我们不能将A添加到结果中，因为我们没有处理边BA的顶点B，所以让我们去顶点B。在B之前，我们只有D，已经添加到结果中，所以我们可以将B添加到结果中，(D,
    B)。从B，我们可以到达A、E、C和F。我们不能到达C，因为我们没有处理AC，我们也不能到达F，因为我们没有处理CF。然而，我们可以到达A，因为DA和BA已经被处理，我们也可以到达E，因为在E之前只有B，它在结果中。注意，拓扑排序可能会提供不同的结果。让我们去E。因此，E被添加到结果中（D,
    B, E）。接下来，我们可以将A添加到结果中，这使我们可以添加C，这使我们可以添加F。因此，结果现在是（D, B, E, A, C, F）。从F，我们可以到达G。由于EG已经被处理，我们可以将G添加到结果中。最后，从G，我们到达H，得到的拓扑排序结果为（D,
    B, E, A, C, F, G, H）。
- en: This traversal is just an arbitrary traversal that we cannot put it into code.
    However, we know that a graph can be traversed via the BFS and DFS algorithms.
    If we try to think in the context of DFS, then we start from node D and we traverse
    B, A, C, F, G, H, and E. While we perform the DFS traversal, we cannot simply
    add the vertices to the result since we break the problem requirement (for every
    directed edge, *XY*, vertex *X* comes before *Y* in the ordering). However, we
    can use a `Stack` and push a vertex into this stack after traversing all its neighbors.
    This means that H is the first vertex that's pushed into the stack, followed by
    G, F, C, A, E, B, and D. Now, popping from the stack until it is empty will give
    us the topological sort as D, B, E, A, C, F, G, and H.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这种遍历只是一种任意的遍历，我们无法将其编写成代码。然而，我们知道图可以通过BFS和DFS算法进行遍历。如果我们尝试在DFS的上下文中思考，那么我们从节点D开始，遍历B、A、C、F、G、H和E。在执行DFS遍历时，我们不能简单地将顶点添加到结果中，因为我们违反了问题的要求（对于每条有向边*XY*，顶点*X*在排序中出现在*Y*之前）。然而，我们可以使用一个`Stack`，在遍历完所有邻居节点后将一个顶点推入这个栈中。这意味着H是第一个被推入栈中的顶点，然后是G、F、C、A、E、B和D。现在，从栈中弹出直到为空将给我们拓扑排序的结果，即D、B、E、A、C、F、G和H。
- en: 'So, topological sort is just a DFS flavor based on a `Stack` that can be implemented
    as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，拓扑排序只是基于`Stack`的DFS变种，可以实现如下：
- en: '[PRE20]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The complete application is called *GraphTopologicalSort.*
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*GraphTopologicalSort*。
- en: Coding challenge 10 – Common ancestor
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战10 – 共同祖先
- en: '**Amazon**, **Google**, **Microsoft**, **Flipkart**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**微软**，**Flipkart**'
- en: '**Problem**: Consider you''ve been given a binary tree. Write a snippet of
    code that finds the first common ancestor of two given nodes. You cannot store
    additional nodes in a data structure.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你已经得到了一棵二叉树。编写一小段代码，找到两个给定节点的第一个共同祖先。你不能在数据结构中存储额外的节点。'
- en: '**Solution**: The best way to analyze this kind of problem is by taking some
    paper and a pen and drawing a binary tree with some samples. Notice that the problem
    doesn''t say that this is a BST. Practically, it can be any valid binary tree.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：分析这种问题的最佳方法是拿一些纸和笔，画一个二叉树并标注一些样本。注意，问题没有说这是一个二叉搜索树。实际上，它可以是任何有效的二叉树。
- en: 'In the following diagram, we have three possible scenarios:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们有三种可能的情况：
- en: '![Figure 13.28 – Finding the first common ancestor'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.28 – 寻找第一个共同祖先'
- en: '](img/Figure_13.28_B15403.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.28_B15403.jpg)'
- en: Figure 13.28 – Finding the first common ancestor
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.28 – 寻找第一个共同祖先
- en: 'Here, we can see that the given nodes can be in different sub-trees (left-
    and right-hand trees) or in the same sub-tree (middle tree). So, we can traverse
    the tree starting from the root using a method of the `commonAncestor(Node root,
    Node n1, Node n2)` type and return it as follows (*n1* and *n2* are the two given
    nodes):'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到给定的节点可以位于不同的子树（左子树和右子树）或者位于同一个子树（中间子树）。因此，我们可以从根节点开始遍历树，使用`commonAncestor(Node
    root, Node n1, Node n2)`类型的方法，并返回如下（*n1*和*n2*是给定的两个节点）：
- en: Returns *n1* if the root's sub-tree includes *n1* (and doesn't include *n2*)
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果根的子树包括*n1*（但不包括*n2*），则返回*n1*
- en: Returns *n2* if the root's sub-tree includes *n2* (and doesn't include *n1*)
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果根的子树包括*n2*（但不包括*n1*），则返回*n2*
- en: Returns `null` if neither *n1* nor *n2* are in the root's sub-tree
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果根的子树中既没有*n1*也没有*n2*，则返回`null`
- en: Else, it returns the common ancestor of *n1* and *n2*.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，返回*n1*和*n2*的公共祖先。
- en: 'When `commonAncestor(n.left, n1, n2)` and `commonAncestor(n.right, n1, n2)`
    return non-null values, this means that *n1* and *n2* are in different sub-trees
    and *n* is the common ancestor. Let''s see this in terms of code:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当`commonAncestor(n.left, n1, n2)`和`commonAncestor(n.right, n1, n2)`返回非空值时，这意味着*n1*和*n2*在不同的子树中，而*n*是它们的公共祖先。让我们看看代码：
- en: '[PRE21]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The complete application is called *BinaryTreeCommonAncestor.*
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*BinaryTreeCommonAncestor*。
- en: Coding challenge 11 – Chess knight
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程挑战11 - 国际象棋骑士
- en: '**Amazon**, **Microsoft**, **Flipkart**'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**微软**，**Flipkart**'
- en: '**Problem**: Consider you''ve been given a chess board and a knight. Initially,
    the knight is placed in a cell (start cell). Write a snippet of code that computes
    the minimum number of moves needed to move the knight from the start cell to a
    given target cell.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你已经得到了一个国际象棋棋盘和一个骑士。最初，骑士放在一个单元格（起始单元格）中。编写一小段代码，计算将骑士从起始单元格移动到给定目标单元格所需的最小移动次数。'
- en: '**Solution**: Let''s consider an example. The chess board is 8x8 in size and
    the knight starts from cell (1, 8). The target cell is (8, 1). As the following
    image reveals, the knight needs to make a minimum of 6 moves to go from cell (1,
    8) to cell (8, 1):'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们考虑一个例子。国际象棋棋盘的大小为8x8，骑士从单元格（1, 8）开始。目标单元格是（8, 1）。正如下图所示，骑士需要至少移动6次才能从单元格（1,
    8）到单元格（8, 1）：'
- en: '![Figure 13.29 – Moving the knight from cell (1, 8) to cell (8, 1)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.29 - 将骑士从单元格（1, 8）移动到单元格（8, 1）'
- en: '](img/Figure_13.29_B15403.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.29_B15403.jpg)'
- en: Figure 13.29 – Moving the knight from cell (1, 8) to cell (8, 1)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.29 - 将骑士从单元格（1, 8）移动到单元格（8, 1）
- en: 'As this image reveals, a knight can move from an (*r, c*) cell to eight other
    valid cells, as follows: (*r*+2*, c*+1), (*r*+1*, c*+2), (*r*-1*,c*+2), (*r*-2*,
    c*+1), (*r*-2*, c*-1), (*r*-1*, c*-2), (*r*+1*, c*-2), and (*r*+2*, c*-1). So,
    there are eight possible movements. If we think of these possible movements as
    directions (edges) and the cells as vertices, then we can visualize this problem
    in the context of a graph. The edges are the possible moves, while the vertices
    are the possible cells for the knight. Each move holds the distance from the current
    cell to the start cell. For each move, the distance is increased by 1\. So, in
    the context of a graph, the problem reduces to finding the shortest path in a
    graph. Hence, we can use BFS to solve this problem.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这张图片所显示的，一个骑士可以从一个（*r，c*）单元格移动到另外八个有效的单元格，如下：（*r*+2，*c*+1），（*r*+1，*c*+2），（*r*-1，*c*+2），（*r*-2，*c*+1），（*r*-2，*c*-1），（*r*-1，*c*-2），（*r*+1，*c*-2），和（*r*+2，*c*-1）。因此，有八种可能的移动。如果我们将这些可能的移动看作方向（边）和单元格看作顶点，那么我们可以在图的上下文中可视化这个问题。边是可能的移动，而顶点是骑士的可能单元格。每个移动都保存从当前单元格到起始单元格的距离。对于每次移动，距离增加1。因此，在图的上下文中，这个问题可以简化为在图中找到最短路径。因此，我们可以使用BFS来解决这个问题。
- en: 'The steps for this algorithm are as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的步骤如下：
- en: Create an empty queue.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空队列。
- en: Enqueue the starting cell so that it has a distance of 0 from itself.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将起始单元格入队，使其与自身的距离为0。
- en: 'As long as the queue is not empty, do the following:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只要队列不为空，执行以下操作：
- en: a. Pop the next unvisited cell from the queue.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: a. 从队列中弹出下一个未访问的单元格。
- en: b. If the popped cell is the target cell, then return its distance.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: b. 如果弹出的单元格是目标单元格，则返回它的距离。
- en: c. If the popped cell is not the target cell, then mark this cell as visited
    and enqueue each of the eight possible movements into the queue by increasing
    the distance by 1.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: c. 如果弹出的单元格不是目标单元格，则将此单元格标记为已访问，并通过增加距离1来将八个可能的移动入队列。
- en: 'Since we rely on the BFS algorithm, we know that all the cells whose shortest
    path is 1 are visited first. Next, the visited cells are the adjacent cells whose
    shortest paths are 1+1=2 and so on; hence any cell whose shortest path is equal
    to the *shortest path of its parent* + 1\. This means that when we traverse the
    target cell for the first time, it gives us the final result. This is the shortest
    path. Let''s see the code:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们依赖BFS算法，我们知道所有最短路径为1的单元格首先被访问。接下来，被访问的单元格是最短路径为1+1=2的相邻单元格，依此类推；因此，任何最短路径等于*其父节点的最短路径*
    + 1的单元格。这意味着当我们第一次遍历目标单元格时，它给出了我们的最终结果。这就是最短路径。让我们看看代码：
- en: '[PRE22]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The application is called *ChessKnight.*
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序称为*ChessKnight*。
- en: Coding challenge 12 – Printing binary tree corners
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程挑战12 - 打印二叉树的角
- en: '**Amazon**, **Google**'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**'
- en: '**Problem**: Consider you''ve been given a binary tree. Write a snippet of
    code that prints the corners of this tree at each level.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你已经得到了一棵二叉树。编写一小段代码，打印出每个级别的树的角。'
- en: '**Solution**: Let''s consider the following tree:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们考虑以下树：'
- en: '![Figure 13.30 – Printing binary tree corners'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.30 - 打印二叉树的角'
- en: '](img/Figure_13.30_B15403.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.30_B15403.jpg)'
- en: Figure 13.30 – Printing binary tree corners
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.30 - 打印二叉树的角
- en: 'So, the main idea is to print the leftmost and rightmost nodes at each level.
    This means that a Level-Order traversal (BFS) can be useful since we can traverse
    each level. All we have to do is identify the first and the last node on each
    level. To do this, we need to adjust the classical Level-Order traversal by adding
    a condition that''s meant to determine whether the current node represents a corner.
    The code speaks for itself:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，主要思想是打印每个级别的最左边和最右边的节点。这意味着层序遍历（BFS）可能很有用，因为我们可以遍历每个级别。我们所要做的就是识别每个级别上的第一个和最后一个节点。为了做到这一点，我们需要通过添加一个条件来调整经典的层序遍历，该条件旨在确定当前节点是否代表一个角落。代码本身说明了这一点：
- en: '[PRE23]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The application is called *BinaryTreePrintCorners.*
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序称为*BinaryTreePrintCorners.*
- en: Coding challenge 13 – Max path sum
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程挑战13 - 最大路径和
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider you''ve been given a non-empty binary tree. Write a snippet
    of code that computes the maximum path sum. A path is considered any sequence
    of nodes starting from any node and ending in any node in the tree, along with
    the parent-child connections. The path must contain at least one node and may
    or may not go through the root of the tree.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑到你已经得到了一个非空的二叉树。编写一小段代码来计算最大路径和。路径被认为是从任何节点开始并在树中的任何节点结束的任何节点序列，以及父子连接。路径必须包含至少一个节点，可能经过树的根，也可能不经过树的根。'
- en: '**Solution**: The following diagram shows three examples of a max path sum:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：下图显示了最大路径和的三个例子：'
- en: '![Figure 13.31 – Three examples of a max path sum'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.31 - 最大路径和的三个例子'
- en: '](img/Figure_13.31_B15403.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.31_B15403.jpg)'
- en: Figure 13.31 – Three examples of a max path sum
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.31 - 最大路径和的三个例子
- en: 'Finding a solution to this problem requires us to identify the number of ways
    in which the current node can be a part of the maximum path. By inspecting the
    preceding examples, we can isolate four cases, as shown in the following diagram
    (take your time and look at more examples until you reach the same conclusion):'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题需要我们确定当前节点可以成为最大路径的一部分的方式数量。通过检查前面的例子，我们可以得出四种情况，如下图所示（花点时间看更多例子，直到得出相同的结论）：
- en: '![Figure 13.32 – Number of ways the current node can be a part of the maximum
    path'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.32 - 当前节点可以成为最大路径的一部分的方式数量'
- en: '](img/Figure_13.32_B15403.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.32_B15403.jpg)'
- en: Figure 13.32 – Number of ways the current node can be a part of the maximum
    path
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.32 - 当前节点可以成为最大路径的一部分的方式数量
- en: 'So, a node that is part of the max path is put into one of the following four
    cases:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为最大路径的一部分的节点被放入以下四种情况之一：
- en: The node is the only node in the max path
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节点是最大路径中唯一的节点
- en: The node is part of the max path next to its left child
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节点是最大路径的一部分，紧邻其左子节点
- en: The node is part of the max path next to its right child
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节点是最大路径的一部分，紧邻其右子节点
- en: The node is part of the max path next to its left and right children
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节点是最大路径的一部分，紧邻其左右子节点
- en: 'These four steps lead us to a clear conclusion: we must iterate over all the
    nodes of the tree. A good choice is the DFS algorithm, but, more precisely, the
    Post-Order tree traversal, which imposes the traversal order as **left sub-tree**
    | **right sub-tree** | **root**. While we traverse the tree, we pass the maximum
    of the rest of the tree to the parent. The following diagram reveals this algorithm:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个步骤使我们得出一个明确的结论：我们必须遍历树的所有节点。一个很好的选择是DFS算法，但更确切地说是后序遍历树遍历，它将遍历顺序规定为**左子树**
    | **右子树** | **根**。当我们遍历树时，我们将树的其余部分的最大值传递给父节点。下图显示了这个算法：
- en: '![Figure 13.33 – Post-order traversal and passing the maximum in the tree to
    the parent'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.33 - 后序遍历并将树中的最大值传递给父节点'
- en: '](img/Figure_13.33_B15403.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.33_B15403.jpg)'
- en: Figure 13.33 – Post-order traversal and passing the maximum in the tree to the
    parent
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.33 - 后序遍历并将树中的最大值传递给父节点
- en: 'So, if we apply this algorithm step by step to the preceding diagram, we get
    the following (remember that this is a Post-Order traversal):'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们按照这个算法逐步应用到前面的图中，我们得到以下结果（记住这是后序遍历）：
- en: 41 does not have children, so 41 is added to max(0, 0), 41+max(0, 0)=41.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 41没有子节点，所以41被添加到max(0, 0)，41+max(0, 0)=41。
- en: 3 only has the left child, -5, so 3 is added to max(-5, 0), 3+max(-5, 0)=3.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3只有左子节点-5，所以3被添加到max(-5, 0)，3+max(-5, 0)=3。
- en: -2 is added to the max(41, 3) sub-trees, so -2+max(41, 3)=39.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -2被添加到max(41, 3)子树，所以-2+max(41, 3)=39。
- en: -7 does not have children, so -7 is added to max(0, 0), -7+max(0, 0)=-7.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -7没有子节点，所以-7被添加到max(0, 0)，-7+max(0, 0)=-7。
- en: 70 does not have children, so 70 is added to max(0, 0), 70+max(0, 0)=70.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 70没有子节点，所以70被添加到max(0, 0)，70+max(0, 0)=70。
- en: -1 is added to the max(-7, 70) sub-trees, so -1+70=69.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -1被添加到max(-7, 70)子树，所以-1+70=69。
- en: 50 is added to the maximum of the left (39) and the right (69) sub-trees, so
    39+69+50=158 (this is the max path sum).
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 50被添加到左（39）和右（69）子树的最大值，所以39+69+50=158（这是最大路径和）。
- en: 'The following code reveals the implementation of this algorithm:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了这个算法的实现：
- en: '[PRE24]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The application is called *BinaryTreeMaxPathSum.*
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序称为*BinaryTreeMaxPathSum.*
- en: Coding challenge 14 – Diagonal traversal
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程挑战14 - 对角线遍历
- en: '**Amazon**, **Adobe**, **Microsoft**'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**Adobe**，**微软**'
- en: '**Problem**: Consider you''ve been given a non-empty binary tree. Write a snippet
    of code that prints all the nodes for each negative diagonal (\). A negative diagonal
    has a negative slope.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑到你已经得到了一个非空的二叉树。编写一小段代码，打印每个负对角线（\）上的所有节点。负对角线具有负斜率。'
- en: '**Solution**: If you are not familiar with the notion of a binary tree negative
    diagonal, then ensure you clarify this aspect with the interviewer. They will
    probably provide you with an example, similar to the one shown in the following
    diagram:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：如果你对二叉树的负对角线概念不熟悉，请确保与面试官澄清这一方面。他们可能会为你提供一个例子，类似于下图所示的例子：'
- en: '![Figure 13.34 – Negative diagonals of a binary tree'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.34 - 二叉树的负对角线'
- en: '](img/Figure_13.34_B15403.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.34_B15403.jpg)'
- en: Figure 13.34 – Negative diagonals of a binary tree
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.34-二叉树的负对角线
- en: In the preceding diagram, we have three diagonals. The first diagonal contains
    nodes 50, 12, and 70\. The second diagonal contains nodes 45, 3, 14, and 65\.
    Finally, the third diagonal contains nodes 41 and 11.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们有三条对角线。第一条对角线包含节点50、12和70。第二条对角线包含节点45、3、14和65。最后，第三条对角线包含节点41和11。
- en: Recursion-based solution
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于递归的解决方案
- en: One solution to this problem is to use recursion and *hashing* (if you are not
    familiar with the concept of hashing, then please read [*Chapter 6*](B15403_06_Final_JM_ePub.xhtml#_idTextAnchor080)*,
    Object-Oriented Programming*, the *Hash table* problem). In Java, we can use hashing
    via the built-in `HashMap` implementation, so there is no need to write a hashing
    implementation from scratch. But how is this `HashMap` useful? What should we
    store in an entry (key-value pair) of this map?
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个解决方案是使用递归和*哈希*（如果您不熟悉哈希的概念，请阅读[*第6章*](B15403_06_Final_JM_ePub.xhtml#_idTextAnchor080)*，面向对象编程*，*哈希表*问题）。在Java中，我们可以通过内置的`HashMap`实现使用哈希，因此无需从头开始编写哈希实现。但是这个`HashMap`有什么用呢？我们应该在这个地图的条目（键值对）中存储什么？
- en: 'We can associate each diagonal in the binary tree with a key in the map. Since
    each diagonal (key) contains multiple nodes, it is very convenient to represent
    the value as a `List`. While we traverse the binary tree, we need to add the current
    node to the proper `List`, so under the proper diagonal. For example, here, we
    can perform a Pre-Order traversal. Every time we go to the left sub-tree, we increase
    the diagonal by 1, and every time we go to the right sub-tree, we maintain the
    current diagonal. This way, we obtain something similar to the following:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将二叉树中的每条对角线与地图中的一个键关联起来。由于每条对角线（键）包含多个节点，因此将值表示为`List`非常方便。当我们遍历二叉树时，我们需要将当前节点添加到适当的`List`中，因此在适当的对角线下。例如，在这里，我们可以执行前序遍历。每次我们进入左子树时，我们将对角线增加1，每次我们进入右子树时，我们保持当前对角线。这样，我们得到类似以下的东西：
- en: '![Figure 13.35 – Pre-Order traversal and increasing the diagonal by 1 for the
    left child'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.35-前序遍历并将对角线增加1以处理左子节点'
- en: '](img/Figure_13.35_B15403.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.35_B15403.jpg)'
- en: Figure 13.35 – Pre-Order traversal and increasing the diagonal by 1 for the
    left child
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.35-前序遍历并将对角线增加1以处理左子节点
- en: 'The time complexity of the following solution is O(n log n) with an auxiliary
    space of O(n), where *n* is the number of nodes in the tree:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 以下解决方案的时间复杂度为O(n log n)，辅助空间为O(n)，其中*n*是树中的节点数：
- en: '[PRE25]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, let's look at another solution for this problem.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个问题的另一个解决方案。
- en: Iterative-based solution
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于迭代的解决方案
- en: 'Solving this problem can be done iteratively as well. This time, we can employ
    Level-Order traversal and enqueue the nodes of a diagonal using a `Queue`. The
    main pseudocode for this solution can be written as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题也可以通过迭代完成。这次，我们可以使用层次遍历，并使用`Queue`将对角线的节点入队。这个解决方案的主要伪代码可以写成如下形式：
- en: '[PRE26]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When this pseudocode is put into code, we get the following:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个伪代码转换成代码后，我们得到以下结果：
- en: '[PRE27]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code runs in O(n) time with an auxiliary space of O(n), where
    *n* is the number of nodes in the tree. The complete application is called *BinaryTreePrintDiagonal.*
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的运行时间为O(n)，辅助空间为O(n)，其中*n*是树中的节点数。完整的应用程序称为*BinaryTreePrintDiagonal*。
- en: Coding challenge 15 – Handling duplicates in BSTs
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战15-处理BST中的重复项
- en: '**Amazon**, **Microsoft**, **Flipkart**'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**微软**，**Flipkart**'
- en: '**Problem**: Consider you''ve been given a BST that allows duplicates. Write
    an implementation that supports the insert and delete operations while handling
    duplicates.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你有一个允许重复的BST。编写一个支持插入和删除操作的实现，同时处理重复项。'
- en: '**Solution**: We know that the property of a BST claims that for each node,
    *n*, we know that the *left descendants of n ≤ n < right descendants of n*. Commonly,
    problems that involve BSTs don''t allow duplicates, so duplicates cannot be inserted.
    However, if duplicates are allowed, then our convention will be to insert the
    duplicate into the left sub-tree.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：我们知道BST的属性声称对于每个节点*n*，我们知道*n*的左子节点≤*n*<*n*的右子节点。通常，涉及BST的问题不允许重复项，因此不能插入重复项。但是，如果允许重复项，那么我们的约定将是将重复项插入左子树。'
- en: 'However, the interviewer probably expects to see an implementation that allows
    us to associate a count with each node, as shown in the following diagram:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，面试官可能希望看到一个允许我们将计数与每个节点关联的实现，如下图所示：
- en: '![Figure 13.36 – Handling duplicates in a BST'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.36-处理BST中的重复项'
- en: '](img/Figure_13.36_B15403.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.36_B15403.jpg)'
- en: Figure 13.36 – Handling duplicates in a BST
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.36-处理BST中的重复项
- en: 'To provide this implementation, we need to modify the structure of a classical
    BST so that it supports a counter:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供这个实现，我们需要修改经典BST的结构，以便支持计数：
- en: '[PRE28]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Every time we create a new node (a node that doesn't exist in the tree), the
    counter will be equal to 1.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建一个新节点（树中不存在的节点）时，计数器将等于1。
- en: 'When we insert a node, we need to distinguish between a new node and a duplicate
    node. If we insert a duplicate node, then all we need to do is increase the counter
    of that node by one, without creating a new node. The relevant part of the insert
    operation is listed here:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们插入一个节点时，我们需要区分新节点和重复节点。如果我们插入一个重复节点，那么我们只需要将该节点的计数增加一，而不创建新节点。插入操作的相关部分如下：
- en: '[PRE29]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Deleting a node follows similar logic. If we delete a duplicate node, then
    we just decrease its counter by one. If the counter is already equal to 1, then
    we just delete the node. The relevant code is as follows:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 删除节点遵循类似的逻辑。如果我们删除一个重复节点，那么我们只需将其计数减一。如果计数已经等于1，那么我们只需删除节点。相关代码如下：
- en: '[PRE30]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The complete application is called *BinarySearchTreeDuplicates.* Another solution
    to this problem consists of using a hash table to keep count of the nodes. This
    way, you don't modify the tree structure. Challenge yourself and complete this
    implementation.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 16 – Isomorphism of binary trees
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Microsoft**'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given two binary trees. Write a snippet
    of code that decides whether these two binary trees are isomorphic to each other.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: If you are not familiar with the term *isomorphic*, then you
    have to clarify this with the interviewer. This term is very well-defined in mathematics,
    but the interviewer probably won''t give a mathematical explanation/demonstration,
    and, as you know, mathematicians have their own language that hardly passes for
    fluent and easy-to-understand English. Moreover, in mathematics, the notion of
    isomorphism refers to any two structures, not only binary trees. So, the interviewer
    will probably give you an explanation, as follows (let''s denote the trees as
    *T1* and *T2*):'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '**Definition 1**: *T1 and T2 are isomorphic if T1 can be changed to T2 via
    swapping the children several times. T1 and T2 don''t have to be the same physical
    shape at all.*'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '**Definition 2**: *T1 and T2 are isomorphic if you can translate T1 into T2
    and T2 into T1 without losing information.*'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '**Definition 3**: *Think of two strings, AAB and XXY. If A is transformed into
    X and B is transformed into Y, then AAB becomes XXY, so these two strings are
    isomorphic. So, two binary trees are isomorphic if T2 is a structure-wise mirror
    of T1.*'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter what definition you get from the interviewer, I am pretty sure that
    all of them will attempt to give you an example. The following diagram shows a
    bunch of examples of isomorphic binary trees:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.37 – Isomorphic binary tree examples'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.37_B15403.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.37 – Isomorphic binary tree examples
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the preceding definitions and examples, we can shape the following
    algorithm for determining whether two binary trees are isomorphic:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: If *T1* and *T2* are `null`, then they are isomorphic, so return `true.`
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *T1* or *T2* is `null`, then they are not isomorphic, so return `false.`
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *T1.data* is not equal to *T2.data,* then they are not isomorphic, so return
    `false.`
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Traverse the left sub-tree of *T1* and the left sub-tree of *T2*.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Traverse the right sub-tree of *T1* and the right sub-tree of *T2*:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. If the structures of *T1* and *T2* are identical, then return `true.`
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: b. If the structures of *T1* and *T2* are not identical, then we check whether
    one tree (or sub-tree) is mirroring another tree (sub-tree),
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Traverse the left sub-tree of *T1* and the right sub-tree of *T2.*
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Traverse the right sub-tree of *T1* and the left sub-tree of *T2*:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. If the structures are mirrored, then return `true`; otherwise, return `false.`
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting this algorithm into code results in the following:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The complete application is called *TwoBinaryTreesAreIsomorphic.*
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 17 – Binary tree right view
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a binary tree. Write a snippet of
    code that prints the right view of this tree. Printing the *right view* means
    printing all the nodes that you can see if you look at the binary tree from its
    right-hand side.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: If you''re unsure what the right view of a binary tree is, then
    clarify this with the interviewer. For example, the following diagram highlights
    the nodes that represent the right view of a binary tree:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.38 – Right view of a binary tree'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.38_B15403.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.38 – Right view of a binary tree
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you are placed in the right-hand side of this tree, you''ll only see
    nodes 40, 45, 44, 9, and 2\. If we think about Level-Order traversal (BFS), we
    obtain the following output:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '**40**, 47, **45**, 11, 3, **44**, 7, 5, **9**, **2**'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The highlighted nodes are the ones that represent the right view. However, each
    of these nodes represents the rightmost node at each level in the tree. This means
    that we can adjust the BFS algorithm and print the last node of each level.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an O(n) complexity time algorithm with an auxiliary O(n) space (represented
    by the queue), where *n* is the number of nodes in the tree:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we can implement a recursive solution as well.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: This is an O(n) complexity time algorithm with an auxiliary O(n) space (represented
    by a map), where *n* is the number of nodes in the tree. You can find the recursive
    approach in the code bundled with this book in the *BinaryTreeRightView* application.
    Challenge yourself and implement the binary tree's left view.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 18 – kth largest element
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Google**, **Flipkart**'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a BST. Write a snippet of code that
    prints the *k*th largest element without changing the BST.'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider the following BST:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.39 – kth largest element in a BST'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.39_B15403.jpg)'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.39 – kth largest element in a BST
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: For *k*=1, we can see that 56 is the first largest element. For *k*=2, we can
    see that 55 is the second largest element, and so on.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: 'The brute-force solution is quite simple and will run in O(n) time, where *n*
    is the number of nodes in the tree. All we have to do is extract an array and
    place it in the In-Order traversal **(left sub-tree | right sub-tree | root)**
    of the tree: 45, 47, 50, 52, 54, 55, 56\. Once we''ve done that, we can find the
    *k*th element as *array*[*n-k*]. For example, for *k*=3, the third element is
    *array*[7-3] = *array*[4]=54\. You can challenge yourself if you wish and provide
    this implementation.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: 'However, another approach that runs in O(k+h) complexity time, where *h* is
    the height of the BST, can be written based on the Reverse-In-Order traversal
    **(right sub-tree | left sub-tree | root)**, which gives us the elements in descending
    order: 56, 55, 54, 52, 50, 47, 45.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: 'The code speaks for itself (the `c` variable counts the visited nodes):'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The complete application is called *BinarySearchTreeKthLargestElement.*
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 19 – Mirror binary tree
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a binary tree. Write a snippet of
    code that constructs the mirror of this tree.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: A mirrored tree looks as follows (the tree on the right is the
    mirrored version of the left-hand side tree):'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.40 – Given tree and the mirrored tree'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.40_B15403.jpg)'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.40 – Given tree and the mirrored tree
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: So, a mirrored tree is like a horizontal flip of the given tree. To create the
    mirror of a tree, we have to decide whether we will return the mirror tree as
    a new tree or mirror the given tree in place.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Mirroring the given tree in a new tree
  id: totrans-520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Returning the mirror as a new tree can be done via a recursive algorithm that
    follows these steps:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.41 - Recursive Algorithm](img/Figure_13.41_B15403_Recursive_Algorithm.jpg)'
  id: totrans-522
  prefs: []
  type: TYPE_IMG
- en: Figure 13.41 - Recursive Algorithm
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of code, we have the following:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, let's try to mirror the given tree in place.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: Mirroring the given tree in place
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Mirroring the given tree in place can be done via recursion as well. This time,
    the algorithm follows these steps:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: Mirror the left sub-tree of the given tree.
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mirror the right sub-tree of the given tree.
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Swap the left and right sub-trees (swap their pointers).
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In terms of code, we have the following:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The complete application is called *MirrorBinaryTree.*
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 20 – Spiral-level order traversal of a binary tree
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Microsoft**'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a binary tree. Write a snippet of
    code that prints the spiral-level traversal of this binary tree. More precisely,
    all the nodes present at level 1 should be printed from left to right, followed
    by all the nodes present at level 2 printed from right to left, followed by all
    the nodes present at level 3 printed from left to right, and so on. So, odd levels
    should be printed from left to right and even levels should be printed from right
    to left.'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你有一个二叉树。编写一小段代码，打印这个二叉树的螺旋级遍历。更确切地说，应该从左到右打印所有在第1级的节点，然后从右到左打印所有在第2级的节点，然后从左到右打印所有在第3级的节点，依此类推。因此，奇数级应从左到右打印，偶数级应从右到左打印。'
- en: '**Solution**: The spiral-level traversal can be formulated in two ways, as
    follows:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：螺旋级遍历可以用两种方式来表达，如下所示：'
- en: Odd levels should be printed from left to right and even levels from right to
    left.
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奇数级应从左到右打印，偶数级应从右到左打印。
- en: Odd levels should be printed from right to left and even levels from left to
    right.
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奇数级应从右到左打印，偶数级应从左到右打印。
- en: 'The following diagram represents these statements:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示这些陈述：
- en: '![Figure 13.42 – Spiral order traversal'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.42 - 螺旋顺序遍历'
- en: '](img/Figure_13.41_B15403.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.41_B15403.jpg)'
- en: Figure 13.42 – Spiral order traversal
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.42 - 螺旋顺序遍历
- en: So, on the left-hand side, we obtain 50, 12, 45, 12, 3, 65, 70, 24, and 41\.
    On the other hand, on the right-hand side, we obtain 50, 45, 12, 70, 65, 3, 12,
    41, and 24.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在左侧，我们得到50、12、45、12、3、65、70、24和41。另一方面，在右侧，我们得到50、45、12、70、65、3、12、41和24。
- en: Recursive approach
  id: totrans-546
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归方法
- en: Let's try to implement the spiral order traversal from the left-hand side of
    the preceding diagram. Notice that the odd levels should be printed from left
    to right, while the even levels should be printed in reverse order. Basically,
    we need to adjust the well-known Level-Order traversal by flipping the direction
    of the even levels. This means that we can use a boolean variable to alternate
    the printing order. So, if the boolean variable is `true` (or 1), then we print
    the current level from left to right; otherwise, we print it from right to left.
    At each iteration (level), we flip the boolean value.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试从前面图表的左侧实现螺旋顺序遍历。请注意，奇数级应从左到右打印，而偶数级应以相反的顺序打印。基本上，我们需要通过翻转偶数级的方向来调整众所周知的层次遍历。这意味着我们可以使用一个布尔变量来交替打印顺序。因此，如果布尔变量为“true”（或1），那么我们从左到右打印当前级别；否则，我们从右到左打印。在每次迭代（级别）中，我们翻转布尔值。
- en: 'Applying this via recursion can be done as follows:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 通过递归应用可以这样做：
- en: '[PRE36]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This code runs in O(n2) time, which is quite inefficient. Can we do this more
    efficiently? Yes – we can do it in O(n) time with extra space, O(n), via an iterative
    approach.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行时间为O(n2)，效率相当低。我们能更有效地做到吗？是的 - 我们可以用额外空间O(n)的迭代方法在O(n)的时间内完成。
- en: Iterative approach
  id: totrans-551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代方法
- en: Let's try to implement the spiral order traversal from the right-hand side of
    the given diagram. We'll do this via an iterative approach this time. Mainly,
    we can use two stacks (`Stack`) or a double ended queue (`Deque`). Let's learn
    how we can do this via two stacks.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试从给定图表的右侧实现螺旋顺序遍历。这次我们将通过迭代方法来实现。主要是，我们可以使用两个栈（`Stack`）或双端队列（`Deque`）。让我们学习如何通过两个栈来实现这一点。
- en: 'The main idea of using two stacks is quite straightforward: we use one stack
    to print the left-to-right nodes and the other stack to print the right-to-left
    nodes. At each iteration (or level), we have the corresponding nodes in one of
    the stacks. While we print the nodes from a stack, we push the nodes of the next
    level into the other stack.'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个栈的主要思想非常简单：我们使用一个栈来打印从左到右的节点，另一个栈来打印从右到左的节点。在每次迭代（或级别）中，一个栈中有相应级别的节点。在我们打印一个栈中的节点时，我们将下一级别的节点推入另一个栈中。
- en: 'The following code puts these statements into code form:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将这些陈述转化为代码形式：
- en: '[PRE37]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The complete application is called *BinaryTreeSpiralTraversal.* In this application,
    you can also find the implementation based on a `Deque`.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*BinaryTreeSpiralTraversal*。在这个应用程序中，您还可以找到基于`Deque`的实现。
- en: Coding challenge 21 – Nodes at a distance k from leafs
  id: totrans-557
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战21 - 距离叶节点k的节点
- en: '**Amazon**, **Google**, **Microsoft**, **Flipkart**'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**微软**，**Flipkart**'
- en: '**Problem**: Consider you''ve been given a binary tree of integers and an integer,
    *k*. Write a snippet of code that prints all the nodes that are at a distance
    *k* from a leaf node.'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你有一个整数二叉树和一个整数*k*。编写一小段代码，打印所有距离叶节点*k*的节点。'
- en: '**Solution**: We can intuit that a distance of *k* from a leaf means *k* levels
    above the leaf. But to clarify any doubts, let''s follow the classical approach
    and try to visualize an example. The following diagram represents a binary tree;
    the highlighted nodes (40, 47, and 11) represent the nodes that are at a distance
    of *k*=2 from a leaf node:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：我们可以直觉地认为距离叶子*k*的距离意味着叶子上方*k*级。但为了澄清任何疑问，让我们遵循经典方法，尝试可视化一个例子。以下图表表示二叉树；突出显示的节点（40、47和11）表示距离叶节点*k*=2的节点：'
- en: '![Figure 13.43 – Nodes at a distance of  k=2 from any leaf node'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.43 - 距离叶节点k=2的节点'
- en: '](img/Figure_13.42_B15403.jpg)'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.42_B15403.jpg)'
- en: Figure 13.43 – Nodes at a distance of k=2 from a leaf node
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.43 - 距离叶节点k=2的节点
- en: 'From the preceding diagram, we can make the following observations:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表中，我们可以得出以下观察结果：
- en: Node 40 is at a distance of 2 from leaf 44\.
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点40距离叶子44有2个距离。
- en: Node 47 is at a distance of 2 from leaf 9 and leaf 5\.
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点47距离叶子9和叶子5有2个距离。
- en: Node 11 is at a distance of 2 from leaf 2.
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点11距离叶子2有2个距离。
- en: 'If we look at each level, then we can see the following:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们观察每个级别，那么我们可以看到以下内容：
- en: The nodes at distance 1 from a leaf node are 3, 11, 7, and 45.
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 距离叶节点1个距离的节点是3、11、7和45。
- en: The nodes at distance 2 from a leaf node are 11, 47, and 40.
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 距离叶节点2个距离的节点是11、47和40。
- en: The nodes at distance 3 from a leaf node are 40 and 47.
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 距离叶节点3个距离的节点是40和47。
- en: The node at distance 4 from a leaf node is 40 .
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the root node is the greatest distance away from a leaf, and *k* doesn't
    make sense to be greater than the number of levels; that is, 1\. If we start from
    the root and we go down the tree until we find a leaf, then the resulting path
    should contain a node that it is at a distance of *k* from that leaf.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: For example, a possible path is 40 (the root), 47, 11, 7, and 2 (the leaf).
    If *k*=2, then node 11 is at a distance of 2 from the leaf. Another possible path
    is 40 (the root), 47, 11, and 5 (the leaf). If *k*=2, then node 47 is at a distance
    of 2 from the leaf. Yet another path is 40 (the root), 47, 3, and 9 (the leaf).
    If *k*=2, then node 47 is at a distance of 2 from the leaf. We already found this
    node; therefore, we now have to pay attention and remove the duplicates.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: The paths that have been listed so far indicate that there's a Pre-Order traversal
    of the tree **(root | left sub-tree | right sub-tree)**. During the traversal,
    we must keep track of the current path. In other words, the constructed path is
    made up of the ancestors of the current node in the Pre-Order traversal. When
    we find a leaf node, we have to print the ancestor that is at a distance *k* from
    this leaf.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: 'To eliminate duplicates, we can use a `Set` (let''s denote it as `nodesAtDist`),
    as shown in the following code:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding code runs in O(n) time complexity and auxiliary space O(n), where
    *n* is the number of nodes in the tree. The complete application is called *BinaryTreeDistanceFromLeaf.*
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 22 – Pair for a given sum
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '`true` if there is a pair of nodes that have this sum.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider the BST shown in the following diagram and *sum*=74:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.44 – The pair for sum=74 contains nodes 6 and 68'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.43_B15403.jpg)'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.44 – The pair for sum=74 contains nodes 6 and 68
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: So, for *sum*=74, we can find the pair (6, 68). If *sum*=89, then the pair is
    (43, 46). If *sum*=99, then the pair is (50, 49). The nodes that form the pair
    can be from the same sub-tree or different sub-trees and can include the root
    and leaf nodes as well.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: One solution to this problem relies on *hashing* and recursion. Mainly, we traverse
    the tree using In-Order traversal (`HashSet`). Moreover, before inserting the
    current node into the set, we check whether (*the given sum - the current node's
    element*) is present in the set. If it is, then we have found a pair, so we stop
    the process and return `true`. Otherwise, we insert the current node into the
    set and continue this process until we find a pair, or the traversal is done.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this is listed here:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The runtime of this code is O(n) with an auxiliary space of O(n). The complete
    application is called *BinarySearchTreeSum.*
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: Another solution that you may like to consider and challenge yourself with starts
    from the fact that a BST, when traversed using In-Order traversal, outputs the
    nodes in sorted order. This means that if we scan the BST and store the outputs
    in an array, then the problem is exactly the same as finding the pair for the
    given sum in an array. But this solution requires two traversals of all the nodes
    and an auxiliary space of O(n).
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach starts from the BST property: *left descendants of n ≤ n <
    right descendants of n*. In other words, the minimum node in the tree is the leftmost
    node (in our case, 6) and the maximum node in the tree is the rightmost node (in
    our case, 71). Now, consider two traversals of the tree:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: A Forward In-Order traversal (the leftmost node is the first visited node)
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Reverse In-Order traversal (the rightmost node is the first visited node)
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s evaluate the (*minimum + maximum*) expression:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: If (*minimum + maximum*) < *sum*, then go to the next *minimum* (next node returned
    by the Forward In-Order traversal).
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If (*minimum + maximum*) > *sum*, then go to the next *maximum* (next node returned
    by the Reverse In-Order traversal).
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果(*最小值 + 最大值*) > *总和*，那么转到下一个*最大值*（反向中序遍历返回的下一个节点）。
- en: If (*minimum + maximum*) = *sum*, then return `true.`
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果(*最小值 + 最大值*) = *总和*，那么返回`true`。
- en: The main problem here is that we need to manage these two traversals. An approach
    can rely on two stacks. In one stack, we store the outputs of the Forward In-Order
    traversal, while in another stack, we store the outputs of the Reverse In-Order
    traversal. When we reach the *minimum* (leftmost) and the *maximum* (rightmost)
    nodes, we must pop the tops of the stacks and perform an equality check against
    the given *sum*.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 主要问题在于我们需要管理这两个遍历。一种方法可以依赖于两个堆栈。在一个堆栈中，我们存储前向中序遍历的输出，而在另一个堆栈中，我们存储反向中序遍历的输出。当我们到达*最小*（最左边）和*最大*（最右边）节点时，我们必须弹出堆栈的顶部并对给定的*总和*执行相等性检查。
- en: 'This equality check passes through one of the preceding checks (given by the
    preceding three bullets) and is interpreted as follows:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相等性检查通过了前面三个检查（由前面的三个项目符号给出），并且解释如下：
- en: If (*minimum + maximum*) < *sum*, then we go to the right sub-tree of the popped
    node via the Forward In-Order traversal. This is how we can find the next greatest
    element.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果(*最小值 + 最大值*) < *总和*，那么我们通过前向中序遍历转到弹出节点的右子树。这是我们如何找到下一个最大的元素。
- en: If (*minimum + maximum*) > *sum*, then we go to the left sub-tree of the popped
    node via the Reverse In-Order traversal. This is how we can find the next smallest
    element.
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果(*最小值 + 最大值*) > *总和*，那么我们通过反向中序遍历转到弹出节点的左子树。这是我们如何找到下一个最小的元素。
- en: If (*minimum + maximum*) = *sum*, then we have found a pair that validates the
    given *sum*.
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果(*最小值 + 最大值*) = *总和*，那么我们找到了一个验证给定*总和*的一对。
- en: 'The algorithm is applied as long as the Forward In-Order and Reverse In-Order
    traversals do not meet. Let''s see the code for this:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 只要前向中序遍历和反向中序遍历不相遇，算法就会应用。让我们看看这段代码：
- en: '[PRE40]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The runtime of this code is O(n) with an auxiliary space of O(n). The complete
    application is called *BinarySearchTreeSum.*
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间是O(n)，辅助空间是O(n)。完整的应用程序称为*BinarySearchTreeSum*。
- en: Coding challenge 23 – Vertical sums in a binary tree
  id: totrans-607
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战23 - 二叉树中的垂直求和
- en: '**Amazon**, **Google**, **Flipkart**'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Flipkart**'
- en: '**Problem**: Consider you''ve been given a binary tree. Write a snippet of
    code that computes the vertical sums for this binary tree.'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你已经得到了一个二叉树。编写一小段代码，计算这个二叉树的垂直求和。'
- en: '**Solution**: In order to have a clear picture of this problem, it is very
    important that you sketch a meaningful diagram. It will be quite useful to use
    a notebook with squares (a math notebook). This is useful because you must draw
    the edges between the nodes at 45 degrees; otherwise, it is possible that you
    won''t see the vertical axes of the nodes correctly. Commonly, when we draw a
    binary tree, we don''t care about the angle between the nodes, but in this case,
    this is a vital aspect for understanding the problem and finding a solution to
    it.'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：为了清晰地理解这个问题，非常重要的是你画一个有意义的图表。最好使用一个有方格的笔记本（数学笔记本）。这很有用，因为你必须以45度角画出节点之间的边缘；否则，可能看不到节点的垂直轴线。通常，当我们画一个二叉树时，我们不关心节点之间的角度，但在这种情况下，这是理解问题并找到解决方案的一个重要方面。'
- en: 'The following diagram is a sketch of the binary tree. It shows some helpful
    landmarks that will lead us to the solution:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表是二叉树的草图。它显示了一些有用的地标，将引导我们找到解决方案：
- en: '![Figure 13.45 – Vertical sums in a binary tree'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.45 - 二叉树中的垂直求和'
- en: '](img/Figure_13.44_B15403.jpg)'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.44_B15403.jpg)'
- en: Figure 13.45 – Vertical sums in a binary tree
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.45 - 二叉树中的垂直求和
- en: If we scan the tree from the left-hand side to the right-hand side, we can identify
    seven vertical axes whose sums are 5, 7, 16, 35, 54, 44, and 6\. At the top of
    the diagram, we've added the horizontal distance of each node from the root node.
    If we consider the root node as having the distance 0, then we can easily uniquely
    identify each vertical axis from the left or the right of the root by decreasing,
    respectively increasing 1 as, -3, -2, -1, 0 (the root), 1, 2, 3.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从左边扫描树到右边，我们可以识别出七个垂直轴，它们的总和分别为5、7、16、35、54、44和6。在图表的顶部，我们添加了每个节点距离根节点的水平距离。如果我们将根节点视为距离0，那么我们可以通过减少或增加1来轻松地从根的左侧或右侧唯一地识别每个垂直轴，分别为-3、-2、-1、0（根）、1、2、3。
- en: Each axis is uniquely identified by its distance from the root, and each axis
    holds the nodes that we have to sum up. If we think about the unique distance
    of an axis as a key and the sum of the nodes on this axis as a value, then we
    can intuit that this problem can be solved via *hashing* (if you are not familiar
    with the concept of hashing, then please take a look at [*Chapter 6*](B15403_06_Final_JM_ePub.xhtml#_idTextAnchor080)*,
    Object-Oriented Programming*, the *Hash table* problem). In Java, we can use hashing
    via the built-in `HashMap` implementation, so there is no need to write a hashing
    implementation from scratch.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 每个轴都是通过它距离根的距离唯一标识的，并且每个轴都包含我们必须求和的节点。如果我们将轴的唯一距离视为一个键，将该轴上节点的总和视为一个值，那么我们可以直观地认为这个问题可以通过*哈希*（如果你不熟悉哈希的概念，请参阅[*第6章*](B15403_06_Final_JM_ePub.xhtml#_idTextAnchor080)*，面向对象编程*，*哈希表*问题）。在Java中，我们可以通过内置的`HashMap`实现使用哈希，因此无需从头开始编写哈希实现。
- en: But how can we fill up this map? It is quite obvious that we have to traverse
    the tree while we are filling up the map. We can start from the root and add the
    key to the map as 0 (0 corresponds to the axis that contains the root) and the
    value as the root (21). Next, we can use recursion to go to the left-axis of the
    root by decreasing the distance from the root by 1\. We can also use recursion
    to go through the right-axis of the root by increasing the distance from the root
    by 1\. At every node, we update the value in the map that corresponds to the key
    that identifies the current axis. So, if we recursively follow path **root**|**left
    sub-tree**|**right sub-tree**, then we use the Pre-Order traversal of a binary
    tree.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何填充这个映射呢？很明显，我们必须在遍历树的同时填充映射。我们可以从根开始，将键添加到映射为0（0对应包含根的轴），值为根（21）。接下来，我们可以使用递归通过减小距离从根到左轴。我们也可以使用递归通过增加距离从根到右轴。在每个节点，我们更新映射中对应于标识当前轴的键的值。因此，如果我们递归地遵循路径**root**|**left
    sub-tree**|**right sub-tree**，那么我们使用二叉树的前序遍历。
- en: 'In the end, our map should contain the following key-value pairs: (-3, 5),
    (-2, 7), (-1, 16), (0, 35), (1, 54), (2, 44), and (3, 6).'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的映射应该包含以下键值对：(-3, 5)，(-2, 7)，(-1, 16)，(0, 35)，(1, 54)，(2, 44)和(3, 6)。
- en: 'Putting this algorithm into code results in the following (`map` contains the
    vertical sums):'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 将此算法编码为以下结果（`map`包含垂直和）：
- en: '[PRE41]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The preceding code runs in O(n log n) time with an auxiliary space of O(n),
    where *n* is the total number of nodes of the tree. Adding to a map has an O(log
    n) complexity time and since we make an addition for each node of the tree, this
    means we get O(n log n). For an interview, the solution presented here should
    be enough. However, you can challenge yourself and decrease the complexity of
    time to O(n) by using an additional doubly linked list. Mainly, you need to store
    each vertical sum in a node of a linked list. First, add the vertical sum corresponding
    to the axis that contains the root to the linked list. Then, *node.next* and *node.prev*
    of the linked list should store the vertical sums of the axis from the left and
    the right of the root axis. Finally, rely on recursion to update the linked list
    while traversing the tree.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在O(n log n)时间内运行，辅助空间为O(n)，其中*n*是树的总节点数。将映射添加到具有O(log n)复杂度的时间，因为我们对树的每个节点进行一次添加，这意味着我们得到O(n
    log n)。对于面试来说，这里提出的解决方案应该足够了。但是，你可以挑战自己，通过使用额外的双向链表将时间复杂度降低到O(n)。主要是，你需要将每个垂直和存储在链表的一个节点中。首先，将与包含根的轴对应的垂直和添加到链表中。然后，链表的*node.next*和*node.prev*应该存储根轴左侧和右侧轴的垂直和。最后，依靠递归在遍历树时更新链表。
- en: The complete application is called *BinaryTreeVerticalSum.*
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为* BinaryTreeVerticalSum。*
- en: Coding challenge 23 – Converting a max heap into a min heap
  id: totrans-623
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战23 - 将最大堆转换为最小堆
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider you''ve been given an array representing a Min Binary
    Heap. Write a snippet of code that converts the given Min Binary Heap into a Max
    Binary Heap in linear time and without extra space.'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑到你已经得到了一个表示最小二叉堆的数组。编写一小段代码，将给定的最小二叉堆在线性时间内转换为最大二叉堆，而且不需要额外的空间。'
- en: '**Solution**: The solution to this problem is inspired by the *Heap Sort* algorithm
    (this algorithm is presented in [*Chapter 14*](B15403_14_Final_JM_ePub.xhtml#_idTextAnchor340)*,
    Sorting and Searching*).'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：这个问题的解决方案受到了*Heap Sort*算法的启发（该算法在[*第14章*](B15403_14_Final_JM_ePub.xhtml#_idTextAnchor340)*，排序和搜索*中介绍）。'
- en: 'Initially, this problem may sound complicated, but after a few minutes of reflection,
    you may come to the conclusion that the problem can be reduced to building a Max
    Binary Heap from an unsorted array. So, the fact that the given array is, or isn''t,
    a Min Binary Heap is not important. We can build the required Max Binary Heap
    from any array (sorted or unsorted) by following two steps:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，这个问题可能听起来很复杂，但经过几分钟的思考，你可能会得出结论，问题可以简化为从未排序的数组构建最大二叉堆。因此，给定的数组是或不是最小二叉堆并不重要。我们可以通过以下两个步骤从任何数组（排序或未排序）构建所需的最大二叉堆：
- en: Start from the rightmost, bottommost node (last internal node) of the given
    array.
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从给定数组的最右下方节点（最后一个内部节点）开始。
- en: '*Heapify* all the nodes via the bottom-up technique.'
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过自底向上的技术*Heapify*所有节点。
- en: 'The code speaks for itself:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 代码说明自己：
- en: '[PRE42]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The runtime of this code is O(n) with no extra space needed. The complete application
    is called *MaxHeapToMinHeap.* It also contains the conversion of a Min Binary
    Heap into a Max Binary Heap.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间是O(n)，不需要额外的空间。完整的应用程序称为*MaxHeapToMinHeap。*它还包含将最小二叉堆转换为最大二叉堆。
- en: Coding challenge 24 – Finding out whether a binary tree is symmetric
  id: totrans-633
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战24 - 查找二叉树是否对称
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '`true` if this binary tree is symmetric (a mirror image of itself or not; the
    left sub-tree and right sub-tree are mirror images of each other).'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个二叉树是对称的（镜像的或不是；左子树和右子树是彼此的镜像），则返回`true`。
- en: '**Solution**: First, let''s take a look at a diagram containing symmetric and
    asymmetric binary trees. The binary trees labeled (a), (b), and (d) are asymmetric,
    while the binary trees labeled (c), (e), and (f) are symmetric. Notice that a
    binary tree is symmetric if both the structure and the data are symmetric:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：首先，让我们看一下包含对称和不对称二叉树的图表。标有(a)、(b)和(d)的二叉树是不对称的，而标有(c)、(e)和(f)的二叉树是对称的。请注意，如果二叉树的结构和数据都是对称的，那么二叉树是对称的：'
- en: '![Figure 13.46 – Symmetric and asymmetric binary tree examples'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.46 - 对称和不对称的二叉树示例'
- en: '](img/Figure_13.45_B15403.jpg)'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.45_B15403.jpg)'
- en: Figure 13.46 – Symmetric and asymmetric binary tree examples
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.46 - 对称和不对称的二叉树示例
- en: 'We can think of this problem as mirroring *root.left* and checking whether
    it is identical to *root.right*. If they are identical, then the binary tree is
    symmetric. However, we can also express the symmetry of two binary trees via three
    conditions, as follows (the easiest way to understand these conditions is to take
    each of them and pass them to the samples shown in the preceding diagram):'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个问题看作是镜像*root.left*并检查它是否与*root.right*相同。如果它们相同，那么二叉树是对称的。然而，我们也可以通过三个条件来表达两个二叉树的对称性，如下所示（理解这些条件最简单的方法是将它们分别应用到前面图表中显示的示例中）：
- en: The root node's elements are the same.
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根节点的元素相同。
- en: The left sub-tree of the left tree and the right sub-tree of the right tree
    must be mirror images.
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左树的左子树和右树的右子树必须是镜像。
- en: The right sub-tree of the left tree and the left sub-tree of the right tree
    must be mirror images.
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左树的右子树和右树的左子树必须是镜像。
- en: 'I think that we have enough experience to recognize that these conditions can
    be implemented via recursion, as follows:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们有足够的经验来认识到这些条件可以通过递归来实现，如下所示：
- en: '[PRE43]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The time complexity of this code is O(n) with O(h) extra space, where *h* is
    the height of the tree. How about an iterative implementation? We can provide
    an iterative implementation via a queue. The following code is the best explanation
    for this approach:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的时间复杂度是O(n)，额外空间是O(h)，其中*h*是树的高度。那么迭代实现呢？我们可以通过队列提供迭代实现。以下代码是对这种方法的最好解释：
- en: '[PRE44]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The time complexity of this code is O(n) with O(h) extra space, where *h* is
    the height of the tree. The complete application is called *IsSymmetricBinaryTree.*
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的时间复杂度是O(n)，额外空间是O(h)，其中*h*是树的高度。完整的应用程序称为*IsSymmetricBinaryTree*。
- en: Coding challenge 25 – Connecting *n* ropes at the minimum cost
  id: totrans-649
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战25 - 以最小成本连接*n*根绳子
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊，谷歌，Adobe，微软，Flipkart
- en: '**Problem**: Consider you''ve been given an array containing the lengths of
    *n* ropes, and we need to connect all these ropes to a single rope. Consider that
    connecting two ropes has a cost equal to the sum of their lengths. Write a snippet
    of code that connects all the ropes to a single rope at the minimum cost.'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你有一个包含*n*根绳子长度的数组，我们需要将所有这些绳子连接成一根绳子。考虑到连接两根绳子的成本等于它们长度的总和。编写一小段代码，以最小成本将所有绳子连接成一根绳子。'
- en: '**Solution**: Let''s consider that we have four ropes whose lengths are 1,
    3, 4, and 6\. Let''s connect the shortest two ropes first. This means we need
    to connect ropes 1 and 3, which has a cost of 1+3=4\. Continuing with the same
    logic, the next two ropes are 4 (the one we just obtained) and 4 in length. The
    cost is 4+4=8, so the total cost is 4+8=12\. We have two ropes left that are 8
    and 6 in length. The cost of connecting them is 8+6=14\. Hence, the total and
    final cost is 12+14=26.'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：假设我们有四根长度分别为1、3、4和6的绳子。让我们首先连接最短的两根绳子。这意味着我们需要连接长度为1和3的绳子，成本为1+3=4。按照相同的逻辑，接下来的两根绳子是长度为4（我们刚刚得到的）和4。成本是4+4=8，所以总成本是4+8=12。我们还剩下两根长度分别为8和6的绳子。连接它们的成本是8+6=14。因此，总成本和最终成本是12+14=26。'
- en: Now, let's try another strategy. Let's connect the longest two ropes first.
    This means we need to connect ropes 4 and 6, which has a cost of 4+6=10\. Continuing
    with the same logic, the next two ropes are 10 (the one we just obtained) and
    3 in length. The cost is 10+3=13, so the total cost is 10+13=23\. We have two
    ropes left that are 13 and 1 in length. The cost of connecting them is 13+1=14\.
    Therefore, the total and final cost is 23+14=37.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试另一种策略。让我们首先连接最长的两根绳子。这意味着我们需要连接长度为4和6的绳子，成本为4+6=10。按照相同的逻辑，接下来的两根绳子是10（我们刚刚得到的）和长度为3。成本是10+3=13，所以总成本是10+13=23。我们还剩下两根绳子，长度分别为13和1。连接它们的成本是13+1=14。因此，总成本和最终成本是23+14=37。
- en: Since 37>26, it is obvious that the first approach is better than the second
    one. But what's the catch? Well, in case you haven't noticed yet, the lengths
    of the ropes that are connected first occur in the rest of the connections. For
    example, when we connect ropes 1 and 3, we write 1+3=4\. So, 4 is the total cost
    so far. Next, we add 4+4=8, so the new total cost is the previous total cost +
    8, which is 4+8, but 4 was obtained from 1+3, so 1+3 occurs again. Finally, we
    connect 8+6=14\. The new total cost is the previous cost + 14, which is 12 + 14,
    but 12 was obtained from 4+8, and 4 was obtained from 1+3, so 1+3 occurs again.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 由于37>26，很明显第一种方法比第二种方法更好。但是，有什么陷阱吗？嗯，如果你还没有注意到，首先连接的绳子的长度在其余的连接中出现。例如，当我们连接绳子1和3时，我们写1+3=4。所以，4是到目前为止的总成本。接下来，我们加上4+4=8，所以新的总成本是之前的总成本+8，即4+8，但4是从1+3得到的，所以1+3再次出现。最后，我们连接8+6=14。新的总成本是之前的成本+14，即12+14，但12是从4+8得到的，4是从1+3得到的，所以1+3再次出现。
- en: 'Analyzing the preceding statement leads us to the conclusion that we can obtain
    the minimum cost of connecting all the ropes if the repeated added rope is the
    smallest, then the second smallest, and so on. In other words, we can think of
    the algorithm for this as follows:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 分析上述陈述会让我们得出结论，如果重复添加的绳子是最小的，那么我们可以获得连接所有绳子的最小成本，然后是第二小的，依此类推。换句话说，我们可以将此算法视为如下所示：
- en: Sort the ropes by their lengths in descending order.
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按长度降序对绳子进行排序。
- en: Connect the first two ropes and update the partial minimum cost.
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接前两根绳子并更新部分最小成本。
- en: Replace the first two ropes with the resulting one.
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用结果替换前两根绳子。
- en: Repeat from *step 1* until there is a single rope left (the result of connecting
    all the ropes).
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*步骤1*开始重复，直到只剩下一根绳子（连接所有绳子的结果）。
- en: After implementing this algorithm, we should obtain the final minimum cost.
    If we try to implement this algorithm via a sorting algorithm such as Quick Sort
    or Merge Sort, then the result will perform in O(n2 log n) time. As you know from
    [*Chapter 7*](B15403_07_Final_JM_ePub.xhtml#_idTextAnchor135)*, Big O Analysis
    of Algorithms*, these sorting algorithms perform in O(n log n) time, but we have
    to sort the array each time two ropes are connected.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we do this better? Yes, we can! At any moment, we only need the two ropes
    with the smallest lengths; we don''t care about the rest of the array. In other
    words, we need a data structure that gives us efficient access to the minimum
    element. Hence, the answer is a Min Binary Heap. Adding and removing from a Min
    Binary Heap is an O(log n) complexity time operation. The algorithm for this can
    be expressed as follows:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: Create the Min Binary Heap from the array of rope lengths (O(log n)).
  id: totrans-662
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Poll the root of the Min Binary Heap, which will give us the smallest rope (O(log
    n)).
  id: totrans-663
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Poll the root again, which will give us the second smallest rope (O(log n)).
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect two ropes (sum up their lengths) and put the result back into the Min
    Binary Heap.
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat from *step 2* until there is a single rope left (the result of connecting
    all the ropes).
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, the algorithm that performs in O(n log n) complexity time is as follows:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The complete application is called *HeapConnectRopes.*
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: Advanced topics
  id: totrans-670
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Right from the start, you should know that the following topics are rarely
    encountered in technical interviews. First, let me enumerate these topics as a
    non-exhaustive list:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: AVL trees (a brief description and an implementation are available in the code
    bundled with this book)
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red-Black trees (a brief description and an implementation are available in
    the code bundled with this book)
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dijkstra's algorithm
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rabin-Karp substring search
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Bellman-Ford algorithm
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Floyd-Warshall algorithm
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interval trees
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum spanning trees
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: B-trees
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bipartite graph
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph coloring
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: P, NP, and NP-complete
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combinatory and probability
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A*
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have mastered all the problems covered in this book, then I strongly
    recommend that you continue learning by looking into the aforementioned topics.
    If you don't do this, then please consider all the problems as having a higher
    priority than these topics.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: Most of the topics outlined here may or may not be asked in interviews. They
    represent complex algorithms that you either know or you don't – the interviewer
    cannot get a true insight into your logic and thinking capabilities just because
    you are able to reproduce a famous algorithm. The interviewer wants to see that
    you are capable of exploiting your knowledge. These algorithms don't reveal your
    capability to solve a problem that you haven't seen before. It is obvious that
    you cannot intuit such complex algorithms, so your footprint is almost insignificant.
    Don't worry if you don't know these algorithms! They don't make you look smarter
    or stupider! Furthermore, since they are complex, they require a lot of time to
    implement, and, in an interview, time is limited.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: However, it doesn't hurt to study more! That's a rule, so if you have the time,
    then take a look at these advanced topics as well.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-690
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This was one of the tough chapters of this book and a *must-read* for any technical
    interview. Trees and graphs are such wide, wonderful, and challenging topics that
    entire books have been dedicated to them. However, when you have to prepare for
    an interview, you don''t have the time to study tons of books and deep dive into
    every topic. This is exactly where the magic of this chapter comes into the picture:
    this chapter (just like the entire book) is totally focused on the fact that you
    must achieve your goal: ace a technical interview.'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: In other words, this chapter contained the most popular tree and graph problems
    that may be encountered in technical interviews, along with meaningful figures,
    comprehensive explanations, and clear and clean code.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，本章包含了在技术面试中可能遇到的最流行的树和图问题，以及有意义的图表、全面的解释和清晰干净的代码。
- en: In the next chapter, we'll tackle problems related to sorting and searching.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将解决与排序和搜索相关的问题。

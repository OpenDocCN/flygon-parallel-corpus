- en: The Exploit Formulation Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is all about creating exploit modules and helping to understand
    how inbuilt Metasploit utilities can improve the creation process. In this chapter,
    we will cover various exemplar vulnerabilities, and we will try to develop approaches
    and methods to exploit these vulnerabilities. In addition to that, our primary
    focus will be on building exploit modules for Metasploit. We will also cover a
    wide variety of tools that will aid writing exploits in Metasploit. An essential
    aspect of exploit writing is the computer architecture. If we do not include the
    basics of the architecture, we will not be able to understand how exploits work
    at the lower levels. Therefore, let's first start a discussion about the system
    architecture and the essentials required to write exploits.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, we will know more about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The stages of exploit development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parameters to be considered while writing exploits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How various registers work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to fuzz software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write exploits in the Metasploit framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypassing protection mechanisms using Metasploit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The absolute basics of exploitation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the most critical components required for exploitation.
    We will discuss a wide variety of registers supported in different architectures.
    We will also discuss the **Extended Instruction Pointer** (**EIP**) and **Extended
    Stack Pointer** (**ESP**), and their importance in writing exploits. We will also
    look at **No Operation** (**NOP**) and **Jump** (**JMP**) instructions and their
    significance in writing exploits for various software.
  prefs: []
  type: TYPE_NORMAL
- en: The basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's cover the basics that are necessary when learning about exploit writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following terms are based on the hardware, software, and security perspectives
    in exploit development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Register**: This is an area on the processor used to store information. Also,
    the processor leverages registers to handle process execution, memory manipulation,
    API calls, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**x86**: This is a family of system architectures that are found mostly on
    Intel-based systems and are generally 32-bit systems, while x64 are 64-bit systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assembly language**: This is a low-level programming language with simple
    operations. However, reading an assembly code and maintaining it is a tough nut
    to crack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buffer**: A buffer is a fixed memory holder in a program, and it stores data
    onto the stack or heap, depending upon the type of memory they hold.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debugger**: Debuggers allow step-by-step analysis of executables, including
    stopping, restarting, breaking, and manipulating process memory, registers, stacks,
    and so on. The widely-used debuggers are the Immunity Debugger, GDB, and OllyDbg.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shellcode**: This is the machine language used to execute on the target system.
    Historically, it was used to run a shell process, granting the attacker access
    to the system. So, shellcode is a set of instructions a processor understands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stack**: This acts as a placeholder for data and uses the **Last-In-First-Out**
    (**LIFO**) method for storage, which means the last inserted data is the first
    to be removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Heap**: Heap is a memory region primarily used for dynamic allocation. Unlike
    the stack, we can allocate and free and block at any given time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buffer overflow**: This means that there is more data supplied in the buffer
    than its capacity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Format string bugs**: These are bugs related to the print statements in context
    with a file or console, which, when given a variable set of data, may disclose
    valuable information regarding the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System calls**: These are calls to a system-level method invoked by a program
    under execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The architecture defines how the various components of a system are organized.
    Let's understand the necessary components first, and then we will dive deep into
    the advanced stages.
  prefs: []
  type: TYPE_NORMAL
- en: System organization basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start writing programs and performing other tasks, such as debugging,
    let''s understand how the components are organized in the system with the help
    of the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc9235d5-26d0-472c-a611-2d94613b1920.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see clearly that every primary component in the system is connected using
    the **System bus**. Therefore, every communication that takes place between the
    **CPU**, **Memory**, and **I/O devices** is via the **System bus**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CPU is the central processing unit in the system, and it is indeed the
    most vital component in the system. So, let''s see how things are organized in
    the CPU by understanding the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2d85356-7201-4345-a86f-af4dd66ef920.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding diagram shows the basic structure of a **CPU** with components
    such as **Control Unit** (**CU**), **Execution Unit** (**EU**) **Registers**,
    and **Flags**. Let''s get to know what these components are, as explained in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Components** | **Working** |'
  prefs: []
  type: TYPE_TB
- en: '| Control unit | The control unit is responsible for receiving and decoding
    the instruction and stores data in the memory |'
  prefs: []
  type: TYPE_TB
- en: '| Execution unit | The execution unit is a place where the actual execution
    takes place |'
  prefs: []
  type: TYPE_TB
- en: '| Registers | Registers are placeholder memory variables that aid the execution
    |'
  prefs: []
  type: TYPE_TB
- en: '| Flags | These are used to indicate events when the execution is taking place
    |'
  prefs: []
  type: TYPE_TB
- en: Registers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Registers are high-speed computer memory components. They are also listed on
    the top of the speed chart of the memory hierarchy. We measure a register by the
    number of bits they can hold; for example, an 8-bit register and a 32-bit register
    hold 8 bits and 32 bits of memory, respectively. **General Purpose**, **Segment**,
    **EFLAGS**, and **index registers** are the different types of relevant registers
    we have in the system. They are responsible for performing almost every function
    in the system, as they hold all the values to be processed. Let''s look at their
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Registers** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| EAX | This is an accumulator and used to store data and operands. It is 32
    bits in size. |'
  prefs: []
  type: TYPE_TB
- en: '| EBX | This is the base register and a pointer to the data. It is 32 bits
    in size. |'
  prefs: []
  type: TYPE_TB
- en: '| ECX | This is a counter, and it is used for looping purposes. It is 32 bits
    in size. |'
  prefs: []
  type: TYPE_TB
- en: '| EDX | This is a data register and stores the I/O pointer. It is 32 bits in
    size. |'
  prefs: []
  type: TYPE_TB
- en: '| ESI/EDI | These are index registers that serve as data pointers for memory
    operations. They are also 32 bits in size. |'
  prefs: []
  type: TYPE_TB
- en: '| ESP | This register points to the top of the stack, and its value is changed
    when an item is either pushed or popped from the stack. It is 32 bits in size.
    |'
  prefs: []
  type: TYPE_TB
- en: '| EBP | This is the stack data pointer register and is 32 bits in size. |'
  prefs: []
  type: TYPE_TB
- en: '| EIP | This is the instruction pointer, which is 32 bits in size, and is the
    most crucial pointer in this chapter. It also holds the address of the next instruction
    to be executed. |'
  prefs: []
  type: TYPE_TB
- en: '| SS, DSES, CS, FS, and GS | These are the segment registers. They are 16 bits
    in size. |'
  prefs: []
  type: TYPE_TB
- en: You can read more about the basics of the architecture and the uses of various
    system calls and instructions for exploitation at: [http://resources.infosecinstitute.com/debugging-fundamentals-for-exploit-development/#x86](http://resources.infosecinstitute.com/debugging-fundamentals-for-exploit-development/#x86).
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting stack-based buffer overflows with Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The buffer overflow vulnerability is an anomaly, where, while writing data
    to the buffer, it overruns the buffer size and overwrites the memory addresses.
    An elementary example of a buffer overflow is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d93ff26-46d3-446d-b98f-0f845634725c.png)'
  prefs: []
  type: TYPE_IMG
- en: The left side of the preceding diagram shows what an application looks like.
    However, the right side denotes the application's behavior when a buffer overflow
    condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we take advantage of buffer overflow vulnerability? The answer is
    straightforward. If we know the exact amount of data that will overwrite everything
    just before the start of the EIP (Instruction Pointer), we can put anything in
    the EIP and control the address of the next instruction to be processed.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the first thing is to figure out an exact number of bytes that are
    good enough to fill everything before the start of the EIP. We will see in the
    upcoming sections how we can find the exact number of bytes using Metasploit utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Crashing the vulnerable application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use a custom-made vulnerable application that uses unsafe functions.
    Let''s try running the application from the command shell, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0567bb0-648f-46f5-aeac-807ee2a49771.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that this is a small example application, which listens on TCP port
    `200`. We will connect to this application via Telnet on port `200` and supply
    random data to it, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0087caa-4393-4a14-9ba4-16fb025e7d5f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After we provide the data, we will see that the connection to the target is
    lost. This is because the application server has crashed. Let''s see what it looks
    like on the target''s system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a50dc75e-760d-4511-a698-519e918086c4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On investigating the error report by clicking click here, we can see the following
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbaf1619-08ff-4ff7-8788-417dc810fcd9.png)'
  prefs: []
  type: TYPE_IMG
- en: The cause of the crash was that the application failed to process the address
    of the next instruction, located at 41414141\. Does this ring any bells? The value
    41 is the hexadecimal representation of character A. What happened is that our
    input, extending through the boundary of the buffer, went on to overwrite the
    EIP register. Therefore, since the address of the next instruction was overwritten,
    the program tried finding the address of the next instruction at 41414141, which
    was not a valid address. Hence, it crashed.
  prefs: []
  type: TYPE_NORMAL
- en: Download the example application we used in the example from: [http://redstack.net/blog/category/How%20To.html](http://redstack.net/blog/category/How%20To.html).
  prefs: []
  type: TYPE_NORMAL
- en: Building the exploit base
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To exploit the app and gain access to the target system, we need to know about
    the things listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Component** | **Use** |'
  prefs: []
  type: TYPE_TB
- en: '| Offset | We crashed the application in the previous section. However, to
    exploit the application, we will need the exact size of the input that is good
    enough to fill the space + the EBP register, so that whatever we provide after
    our input goes directly into the EIP register. We refer to the amount of data
    that is good enough to land us right before the EIP register as the offset. |'
  prefs: []
  type: TYPE_TB
- en: '| Jump address/Ret | This is the actual address to overwrite in the EIP register.
    To clarify, this is the address of a JMP ESP instruction from a DLL file that
    helps to jump to the payload. |'
  prefs: []
  type: TYPE_TB
- en: '| Bad characters | Bad characters are those that can lead to the termination
    of a payload. Suppose a shellcode containing null bytes (0x00) is sent over the
    network. It will terminate the buffer prematurely, causing unexpected results.
    Bad characters should be avoided. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s understand the exploitation part of this application with the help of
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/598f5a96-1a5f-4d6b-8cc5-33002b0f9466.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Looking at the preceding diagram, we have to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Overwrite the buffer and EBP register with the user input just before the start
    of the EIP register. The value that's good enough will be the offset value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overwrite the ESP with the JMP ESP address from the relevant DLL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Supply some padding before the payload to remove irregularities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, supply the shellcode to be executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the upcoming section, we will look at all these steps in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the offset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the preceding section, the first step in exploitation is to find
    out the offset. Metasploit aids this process by using two different tools, called
    `pattern_create` and `pattern_offset`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the pattern_create tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We saw in the previous section that we were able to crash the application by
    supplying a random amount of `A` characters. However, we''ve learned that to build
    a working exploit, we need to figure out the exact number of these characters.
    Metasploit''s inbuilt tool, `pattern_create`, does this for us in no time. It
    generates patterns that can be supplied instead of `A` characters and, based on
    the value which overwrote the EIP register, we can quickly figure out the exact
    number of bytes using its counterpart tool, `pattern_offset`. Let''s see how we
    can do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8e0706f-008d-491f-ae8b-1b3502f68cc4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that running the `pattern_create.rb` script from the `/tools/exploit/`
    directory for a pattern of 1,000 bytes will generate the preceding output. This
    output can be fed to the vulnerable application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fdc96fa9-7533-49ea-84d4-52c26de6ad52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Looking at the target''s endpoint, we can see the offset value, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0cb70ce2-876e-416b-a126-8b4b4a78be52.png)'
  prefs: []
  type: TYPE_IMG
- en: We have 72413372 as the address that overwrote the EIP register.
  prefs: []
  type: TYPE_NORMAL
- en: Using the pattern_offset tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, we overwrote the EIP address with 72413372\. Let''s
    figure out the exact number of bytes required to overwrite the EIP with the `pattern_offset`
    tool. This tool takes two arguments; the first one is the address and the second
    one is the length, which was `1000`, as generated using `pattern_create`. Let''s
    find out the offset, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b37cb6a-cc58-4840-a757-2b77a1283c02.png)'
  prefs: []
  type: TYPE_IMG
- en: The exact match is found to be at 520\. Therefore, any 4 bytes after 520 characters
    becomes the contents of the EIP register.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the JMP ESP address
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s review the diagram we used to understand the exploitation again, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/240fc9e7-88f7-4b82-8d0c-145b0168ce87.png)'
  prefs: []
  type: TYPE_IMG
- en: We completed the first step in the preceding diagram. Our next task is to find
    the JMP ESP address. We require the address of a JMP ESP instruction because our
    payload will be loaded to the ESP register and we cannot merely point to the payload
    after overwriting the buffer. Hence, we will require the address of a JMP ESP
    instruction from an external DLL, which will ask the program to make a jump to
    the content of the ESP that is at the start of our payload.
  prefs: []
  type: TYPE_NORMAL
- en: To find the jump address, we will require a debugger so that we can see which
    DLL files are loaded with the vulnerable application. The best choice, in my opinion,
    is the Immunity Debugger. The Immunity Debugger comes with a ton of plugins that
    aid exploit writing.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Immunity Debugger to find executable modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Immunity Debugger is an application that helps us find out the behavior
    of an application at runtime. It also helps us to identify flaws, the value of
    registers, reverse engineer the application, and so on. Analyzing the application
    in the Immunity Debugger will not only help us understand the values contained
    in the various registers better, but will also tell us about a variety of information
    about the target application, such as the instruction where the crash took place
    and the executable modules linked to an executable file.
  prefs: []
  type: TYPE_NORMAL
- en: 'An executable can be loaded into the Immunity Debugger directly by selecting
    Open from the File menu. We can also attach a running app by attaching its process
    to the Immunity Debugger by choosing the Attach option from the File menu. When
    we navigate to File | Attach, it will present us with the list of running processes
    on the target system. We just need to select the appropriate process. However,
    a significant point here is that when a process attaches to the Immunity Debugger,
    by default, it lands in a paused state. Therefore, make sure you press the Play
    button to change the state of the process from the paused to the running state.
    Let''s visualize how we can attach a process to the Immunity Debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83c1ae4f-49e1-43b4-8cf6-55da312fbf12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After pressing the Attach button, let''s see which DLL files are loaded with
    the vulnerable application by navigating to View and selecting the Executable
    modules option. We will be presented with the following list of DLL files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2455a72c-d8d8-4834-a8fe-6c0df10f7e60.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have the list of DLL files, we need to find the JMP ESP address
    from one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Using msfpescan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we found the DLL modules associated with the vulnerable
    application. Either we can use the Immunity Debugger to find the address of the
    JMP ESP instructions, which is a lengthy and time-consuming process, or we can
    use `msfpescan` to search the addresses for the JMP ESP instructions from a DLL
    file, which is a much faster process and eliminates manual searching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `msfpescan` gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/639fd66e-cae6-4834-b35e-6907671bc9cd.png)'
  prefs: []
  type: TYPE_IMG
- en: Utilities such as `msfbinscan `and `msfrop` may not be present in the default
    Metasploit installation that is shipped with Kali Linux. Switch to Ubuntu and
    install Metasploit manually to obtain these utilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can perform a variety of tasks such as finding the POP-POP-RET instruction
    addresses for SEH-based buffer overflows, displaying the code at a particular
    address, and much more with `msfpescan`. We just need to find the address of the
    JMP ESP instruction. We can achieve this by using the `-j` switch, followed by
    the register name, which is ESP. Let''s begin the search on the `ws2_32.dll` file
    to find the JMP ESP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b26e3564-30b2-4b31-8912-04fc3352baa8.png)'
  prefs: []
  type: TYPE_IMG
- en: The result of the command returned `0x71ab9372`. This is the address of the
    JMP ESP instruction in the `ws2_32.dll` file. We just need to overwrite the EIP
    register with this address to make a jump of execution to the shellcode that resides
    in the ESP register.
  prefs: []
  type: TYPE_NORMAL
- en: Stuffing the space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s revise the exploitation diagram and understand where exactly we lie
    in the exploitation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34cc8528-2fa8-4f2f-a270-0d14fecf206d.png)'
  prefs: []
  type: TYPE_IMG
- en: We have completed the second step. However, a significant point here is that
    sometimes the first few bytes of the shellcode may get stripped off due to irregularities,
    and the shellcode may not get executed. In such situations, we shall pad the shellcode
    with prefixed NOPs so that the execution of the shellcode can take place flawlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we send `ABCDEF` to the ESP, but when we analyze it using the Immunity
    Debugger, we get the contents as `DEF` only. In this case, we have three missing
    characters. Therefore, we shall pad the payload with three NOP bytes or other
    random data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see if we need to pad the shellcode for this vulnerable application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0b9fe00-925e-4eb7-8284-38bee07a7a7b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, we created data based on the values we have for
    the buffer size. We know that the offset is `520`. Therefore, we supplied `520`
    followed by the JMP ESP address in little-endian format, which is accompanied
    by random text; that is, `ABCDEF`. Once we send this data, we analyze the ESP
    register in the Immunity Debugger, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/788e7c69-e7f1-4db2-ba1c-6f2611b9a263.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the letter `A` from the random text `ABCDEF` is missing. Hence,
    we just need a single byte padding to achieve alignment. It is an excellent practice
    to pad the space before shellcode with a few extra NOPs to avoid issues with shellcode
    decoding and irregularities.
  prefs: []
  type: TYPE_NORMAL
- en: Relevance of NOPs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NOPs or NOP-sled are No Operation instructions that merely slide the program
    execution to the next memory address. We use NOPs to reach the desired place in
    the memory addresses. We supply NOPs commonly before the start of the shellcode
    to ensure its successful execution in the memory while performing no operations
    and just sliding through the memory addresses. The `\x90` instruction represents
    a NOP instruction in the hexadecimal format.
  prefs: []
  type: TYPE_NORMAL
- en: Determining bad characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it may happen that after setting up everything correctly for exploitation,
    we may never get to exploit the system. Alternatively, it might happen that our
    exploit executed successfully, but the payload fails to run. This can happen in
    cases where the data supplied in the exploit is either truncated or improperly
    parsed by the target system, causing unexpected behavior. This will make the entire
    exploit unusable, and we will struggle to get the shell or Meterpreter onto the
    system. In this case, we need to determine the bad characters that are preventing
    the execution. We can avoid such situations by finding matching similar exploit
    modules and use the bad characters from them in our exploit module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to define these bad characters in the `Payload` section of the exploit.
    Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding section is taken from the `freeftpd_user.rb` file under `/exploit/windows/ftp`.
    The options listed suggests that the space of the payload should be less than
    `800` bytes and the payload should avoid using `0x00`, `0x20`, `0x0a`, and `0x0d`,
    which are null byte, space, line feed, and carriage return, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: More information on finding bad characters can be found at: [http://resources.infosecinstitute.com/stack-based-buffer-overflow-in-win-32-platform-part-6-dealing-with-bad-characters-jmp-instruction/](http://resources.infosecinstitute.com/stack-based-buffer-overflow-in-win-32-platform-part-6-dealing-with-bad-characters-jmp-instruction/).
  prefs: []
  type: TYPE_NORMAL
- en: Determining space limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Space` variable in the `Payload field` defines the total size reserved
    for the shellcode. We need to assign enough space for the `Payload` to fit in.
    If the `Payload` is large and the space allocated is less than the shellcode of
    the payload, it will not execute. Also, while writing custom exploits, the shellcode
    should be as small as possible. We may have a situation where the available space
    is only for 200 bytes, but the available shellcode needs at least 800 bytes of
    space. In this situation, we can fit a small first stage shellcode within the
    buffer, which will execute and download the second, larger stage to complete the
    exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: For smaller shellcode for various payloads, visit: [http://shell-storm.org/shellcode/](http://shell-storm.org/shellcode/).
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Metasploit exploit module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s review our exploitation process diagram and check if we are good to
    finalize the module or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b076501b-a46d-4a63-91ea-1e5a96a8bf9a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that we have all the essentials for developing the Metasploit module.
    This is because the payload generation is automated in Metasploit and can be changed
    on the fly as well. So, let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Before starting with the code, let''s have a look at the libraries we used
    in this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Include statement** | **Path** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `Msf::Exploit::Remote::Tcp` | `/lib/msf/core/exploit/tcp.rb` | The TCP library
    file provides basic TCP functions, such as connect, disconnect, write data, and
    so on |'
  prefs: []
  type: TYPE_TB
- en: 'In the same way as we built modules in [Chapter 12](32de9df6-2753-4075-8f9c-cbf119522ded.xhtml),
    *Reinventing Metasploit*, the exploit modules begin by including the necessary
    library paths and then including the required files from those paths. We define
    the type of module to be `Msf::Exploit::Remote`, meaning a remote exploit. Next,
    we have the `initialize` constructor method, in which we define the name, description,
    author information, and so on. However, we can see plenty of new declarations
    in the `initialize` method. Let''s see what they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Declaration** | **Value** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `Platform` | `win` | Defines the type of platform the exploit is going to
    target. The value win denotes that the exploit will be usable on Windows-based
    operating systems. |'
  prefs: []
  type: TYPE_TB
- en: '| `disclosure date` | `Mar 04 2018` | The date of disclosure of the vulnerability.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Targets` | `Ret` | The `Ret` field for a particular OS defines the JMP ESP
    address we found in the previous section. |'
  prefs: []
  type: TYPE_TB
- en: '| `0x71AB9372` |'
  prefs: []
  type: TYPE_TB
- en: '| `Targets` | `Offset` | The `Offset` field for a particular OS defines the
    number of bytes required to fill the buffer just before overwriting the EIP. We
    found this value in the previous section. |'
  prefs: []
  type: TYPE_TB
- en: '| `520` |'
  prefs: []
  type: TYPE_TB
- en: '| `Payload` | `space` | The `space` variable in the payload declaration defines
    the amount of maximum space the payload can use. This is relatively important
    since sometimes we have insufficient space to load our shellcode. |'
  prefs: []
  type: TYPE_TB
- en: '| `1000` |'
  prefs: []
  type: TYPE_TB
- en: '| `Payload` | `BadChars` | The `BadChars` variable in the payload declaration
    defines the bad characters to avoid in the payload generation process. The practice
    of declaring bad characters will ensure stability and removal of bytes that may
    cause the application to crash or no execution of the payload to take place. |'
  prefs: []
  type: TYPE_TB
- en: '| `\x00\xff` |'
  prefs: []
  type: TYPE_TB
- en: 'We also define the default port for the exploit module as `200` in the `register_options`
    section. Let''s have a look at the remaining code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand some of the important functions used in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Library** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `make_nops` | `/lib/msf/core/exploit.rb` | This method is used to create
    `n` number of NOPs by passing `n` as the count |'
  prefs: []
  type: TYPE_TB
- en: '| `Connect` | `/lib/msf/core/exploit/tcp.rb` | This method is called to make
    a connection to the target |'
  prefs: []
  type: TYPE_TB
- en: '| `disconnect` | `/lib/msf/core/exploit/tcp.rb` | This method is called to
    disconnect an existing connection to the target |'
  prefs: []
  type: TYPE_TB
- en: '| `handler` | `/lib/msf/core/exploit.rb` | This passes the connection to the
    associated payload handler to check if the exploit succeeded and a connection
    is established |'
  prefs: []
  type: TYPE_TB
- en: We saw in the previous section that the `run` method is used as the default
    method for auxiliary modules. However, for the exploits, the `exploit` method
    is considered the default main method.
  prefs: []
  type: TYPE_NORMAL
- en: We begin by connecting to the target using `connect`. Using the `make_nops`
    function, we created 520 NOPs by passing the `Offset` field of the `target` declaration
    that we defined in the `initialize` section. We stored these 520 NOPs in the `buf`
    variable. In the next instruction, we appended the JMP ESP address to `buf` by
    fetching its value from the `Ret` field of the `target` declaration. Using `pack('V')`,
    we get the little endian format for the address. Along with the `Ret` address,
    we append a few NOPs to serve as padding before the shellcode. One of the advantages
    of using Metasploit is being able to switch the payload on the fly. Therefore,
    simply appending the payload using `payload.encoded` will add the currently selected
    payload to the `buf` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we directly send the value of `buf` to the connected target using `sock.put`.
    We run the handler method to check if the target was exploited successfully and
    if a connection was established to it or not. Finally, we just disconnect from
    the target using `disconnect`. Let''s see if we can exploit the service or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af70490a-44be-467f-8139-b0928c768820.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We set the required options and payload as `windows/meterpreter/bind_tcp`,
    which denotes a direct connection to the target. We can see that, initially, our
    exploit completed, but no session was created. At this point, we change bad characters
    from `\x00\xff` to `\x00\x0a\x0d\x20` by editing the exploit code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4dc4b10e-30bb-4d09-ae86-622b70595b79.png)'
  prefs: []
  type: TYPE_IMG
- en: We can modify a module directly from Metasploit using the `edit` command. By
    default, the file will load in the VI editor. However, if you are no better than
    me, you will stick to the nano editor and make the changes. Once we change the
    module, it has to be reloaded to Metasploit. For the module we are currently working
    with, we can reload it using the `reload` command, as shown in the previous image.
    Rerunning the module, we got Meterpreter access to the target with ease. Now that
    we've completed the first exploit module successfully, we will jump into a slightly
    more advanced exploit module in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting SEH-based buffer overflows with Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exception handlers are code modules that catch exceptions and errors generated
    during the execution of the program. This allows the program to continue execution
    instead of crashing. Windows operating systems have default exception handlers,
    and we see them generally when an application crashes and throws a pop-up that
    says *XYZ program has encountered an error and needed to close*. When the program
    generates an exception, the equivalent address of the catch code is loaded and
    called from the stack. However, if we somehow manage to overwrite the address
    in the stack for the catch code of the handler, we will be able to control the
    application. Let''s see how things are arranged in a stack when an application
    is implemented with exception handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a93d591e-bf18-4ce8-95b5-59c5e4f1d09d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding diagram, we can see that we have the address of the catch
    block in the stack. We can also see, on the right side, that when we feed enough
    input to the program, it overwrites the address of the catch block in the stack
    as well. Therefore, we can easily find out the offset value for overwriting the
    address of the catch block using the `pattern_create` and `pattern_offset` tools
    in Metasploit. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f377ffa0-29fa-4d39-842e-a897144ddb6b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We create a pattern of `4000` characters and send it to the target using the
    `TELNET` command. Let''s see the application''s stack in the Immunity Debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40c9658d-6cf6-40f4-a9f2-4990837bfb63.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see in the application''s stack pane that the address of the SE handler
    was overwritten with `45346E45`. Let''s use `pattern_offset` to find the exact
    offset, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/764f935e-f9f6-473d-9893-984703abe76d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the correct match is at `3522`. However, a significant point
    to note here is that according to the design of an SEH frame, we have the following
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e4a5343-310c-4ade-b579-4d81a3afb6ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An SEH record contains the first `4` bytes as the address of the next SEH handler
    and the next `4` bytes as the address of the catch block. An application may have
    multiple exception handlers. Therefore, a particular SEH record stores the first
    4 bytes as the address of the next SEH record. Let''s see how we can take advantage
    of SEH records:'
  prefs: []
  type: TYPE_NORMAL
- en: We will cause an exception in the application so that a call is made to the
    exception handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will overwrite the address of the catch handler field with the address of
    a POP/POP/RETN instruction. This is because we need to switch the execution to
    the address of the next SEH frame (4 bytes before the address of the catch handler).
    We will use POP/POP/RET because the memory address where the call to the catch
    block is saved is stored in the stack and the address of the pointer to the next
    handler is at ESP+8 (the ESP is referred as the top of the stack). Therefore,
    two POP operations will redirect the execution to the start of 4 byte which are
    the address of the next SEH record.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While supplying the input in the very first step, we will overwrite the address
    of the next SEH frame with the JMP instruction to our payload. Therefore, when
    the second step completes, the execution will make a jump of a specified number
    of bytes to the shellcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Successfully jumping to the shellcode will execute the payload and we will gain
    access to the target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s understand these steps with the help of the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/339c6f70-ba02-46a6-ad7a-344b7c570e10.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, when an exception occurs, it calls the address of
    the handler (already overwritten with the address of the POP/POP/RET instruction).
    This causes the execution of POP/POP/RET and redirects the execution to the address
    of the next SEH record (already overwritten with a short jump). Therefore, when
    the JMP executes, it points to the shellcode, and the application treats it as
    another SEH record.
  prefs: []
  type: TYPE_NORMAL
- en: Building the exploit base
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have familiarized ourselves with the basics, let''s see what essentials
    we need to develop a working exploit for SEH-based vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Component** | **Use** |'
  prefs: []
  type: TYPE_TB
- en: '| Offset | In this module, the offset will refer to the exact size of input
    that is good enough to overwrite the address of the catch block. |'
  prefs: []
  type: TYPE_TB
- en: '| POP/POP/RET address | This is the address of a POP-POP-RET sequence from
    the DLL. |'
  prefs: []
  type: TYPE_TB
- en: '| Short jump instruction | To move to the start of shellcode, we will need
    to make a short jump of a specified number of bytes. Hence, a short jump instruction
    will be required. |'
  prefs: []
  type: TYPE_TB
- en: We already know that we require a payload, a set of bad characters to prevent,
    space considerations, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the offset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Easy File Sharing Web Server 7.2 application is a web server that has a
    vulnerability in the request handling sections, where a malicious HEAD request
    can cause an overflow in the buffer and overwrite the address in the SEH chain.
  prefs: []
  type: TYPE_NORMAL
- en: Using the pattern_create tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will find the offset using the `pattern_create` and `pattern_offset` tools,
    as we did previously while attaching the vulnerable application to the debugger.
    Let''s see how we can achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b5a05e9-2bed-4b4d-b1e7-5bf685cabcdd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We created a pattern of `10000` characters. Now, let''s feed the pattern to
    the application on port `80` and analyze its behavior in the Immunity Debugger.
    We will see that the application halts. Let''s see the SEH chains by navigating
    to View from the menu bar and selecting SEH chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5e5dc8f-caef-43ed-bb4c-e23a77d16928.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the SEH chain option, we will be able to see the overridden catch
    block address and the address of the next SEH record fields overridden with the
    data we supplied:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/271c5654-7c49-4d54-842d-b9c23a143982.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the pattern_offset tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s find the offset to the address of the next SEH frame and the offset
    to the address of the catch block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea02cb23-da13-4881-85a4-461d33998a83.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the 4 bytes containing the memory address to the next SEH record
    starts from `4061` bytes and the offset to the catch block begins right after
    those 4 bytes; that is, from `4065`.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the POP/POP/RET address
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed previously, we will require the address to the POP/POP/RET instruction
    to load the address in the next SEH frame record and jump to the payload. We know
    that we need to load the address from an external DLL file. However, most of the
    latest operating systems compile their DLL files with SafeSEH protection. Therefore,
    we will require the address of the POP/POP/RET instruction from a DLL module,
    which is not implemented with the SafeSEH mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: The example application crashes on the following `HEAD` request; that is, `HEAD`
    followed by the junk pattern created by the `pattern_create` tool, which is followed
    by `HTTP/1.0rnrn`.
  prefs: []
  type: TYPE_NORMAL
- en: The Mona script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Mona script is a Python-driven plugin for the Immunity Debugger and provides
    a variety of options for exploitation. The script can be downloaded from: [https://github.com/corelan/mona/blob/master/mona.py](https://github.com/corelan/mona/blob/master/mona.py).
    It is easy to install the script by placing it into the `\Program Files\Immunity
    Inc\Immunity Debugger\PyCommands` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s analyze the DLL files by using Mona and running the `!mona modules`
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5de60269-f16b-4189-9753-d8c23383de07.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see from the preceding screenshot that we have very few DLL files, which
    are not implemented with the SafeSEH mechanism. Let's use these files to find
    the relevant address of the POP/POP/RET instruction.
  prefs: []
  type: TYPE_NORMAL
- en: More information on the Mona script can be found at: [https://www.corelan.be/index.php/2011/07/14/mona-py-the-manual/](https://www.corelan.be/index.php/2011/07/14/mona-py-the-manual/).
  prefs: []
  type: TYPE_NORMAL
- en: Using msfpescan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can easily find the POP/POP/RET instruction sequence with `msfpescan` using
    the `-s` switch. Let''s use it on the `ImageLoad.dll` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ad5e795-2155-47f0-b223-6c82bd0e9d4d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s use a safe address, eliminating any address that can cause issues with
    the HTTP protocol, such as the consecutive repetition of zeros, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71da2ab5-e7dc-4092-9ce3-df3e361b7481.png)'
  prefs: []
  type: TYPE_IMG
- en: We will use `0x10019798` as the POP/POP/RET address. We now have two critical
    components for writing the exploit, which are the offset and the address to be
    loaded into the catch block, which is the address of our POP/POP/RET instruction.
    We only need the instruction for the short jump, which is to be loaded into the
    address of the next SEH record that will help us to jump to the shellcode. Metasploit
    libraries will provide us with the short jump instruction using inbuilt functions.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Metasploit SEH exploit module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have all the important data for exploiting the target application,
    let''s go ahead and create an exploit module in Metasploit, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Having worked with the header part of various modules, we start by including
    the required sections of the library files. Next, we define the class and the
    module type as we did in the previous modules. We begin the `initialize` section
    by defining the name, description, author information, license information, payload
    options, disclosure date, and default target. We use the address of the POP/POP/RET
    instruction in the `Ret` return address variable and `Offset` as `4061` under
    the `Targets` field. We have used `4061` instead of `4065` because Metasploit
    will automatically generate the short jump instruction to the shellcode; therefore,
    we will start 4 bytes before `4065` bytes so that the short jump can be placed
    into the carrier for the address of the next SEH record.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving further, let''s have a look at the essential functions we are
    going to use in the module. We''ve already seen the usage of `make_nops`, `connect`,
    `disconnect`, and `handler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Library** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `generate_seh_record()` | `/lib/msf/core/exploit/seh.rb` | The library mixin
    provides ways to generate SEH records. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s continue with the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `exploit` function starts by connecting to the target. Next, it generates
    a malicious `HEAD` request by appending `4061` NOPs to the `HEAD` request. Next,
    the `generate_seh_record()` function generates an `8` byte `SEH` record, where
    the first 4 bytes form the instruction to jump to the payload. Generally, these
    4 bytes contain instructions such as `\xeb\x0A\x90\x90`, where `\xeb` denotes
    a jump instruction, `\x0A` denotes the `12` bytes to jump, and the `\x90\x90 NOP`
    instruction completes the 4 bytes as padding.
  prefs: []
  type: TYPE_NORMAL
- en: Using the NASM shell for writing assembly instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metasploit provides an excellent utility for writing short assembly code using
    the NASM shell. We wrote a small assembly code in the previous section, `\xeb\x0a`,
    which denoted a short jump of 12 bytes. However, after eliminating the use of
    searching the internet or toggling through assembly op-codes, we can use the NASM
    shell to write assembly code with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we had a simple assembly call, which was `JMP SHORT
    12`. However, we did not know what op-codes match this instruction. Therefore,
    let''s use the NASM shell and find out, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f8fe2cf-7991-429b-aaeb-734accd15ea4.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see in the preceding screenshot that we launched `nasm_shell.rb` from
    the `/usr/share/Metasploit-framework/tools/exploit` directory and simply typed
    in the command that generated the same op-code, `EB0A`, which we discussed earlier.
    Hence, we can utilize the NASM shell in all our upcoming exploit examples and
    practical exercises to reduce effort and save a great deal of time.
  prefs: []
  type: TYPE_NORMAL
- en: Coming back to the topic, Metasploit allowed us to skip the task of providing
    the jump instruction and the number of bytes to the payload using the `generate_seh_record()`
    function. Next, we simply provided some padding before the payload to overcome
    any irregularities and follow with the payload. We simply completed the request
    using `HTTP/1.0\r\n\r\n` in the header. Finally, we sent the data stored in the
    variable weapon to the target and called the handler method to check if the attempt
    was successful, and we were given access to the target.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try running the module and analyze the behavior, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76cda35c-2294-4901-9ef5-29553e382704.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s set all the required options for the module and run the `exploit` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6617dc64-4149-4132-8cee-8ddf1250432f.png)'
  prefs: []
  type: TYPE_IMG
- en: Bang! We successfully exploited the target, which is a Windows 7 system. We
    saw how easy it is to create SEH modules in Metasploit. In the next section, we
    will take a deeper dive into advanced modules that bypass security mechanisms
    such as DEP.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [https://github.com/rapid7/metasploit-framework/wiki/How-to-use-the-Seh-mixin-to-exploit-an-exception-handler](https://github.com/rapid7/metasploit-framework/wiki/How-to-use-the-Seh-mixin-to-exploit-an-exception-handler) for
    more information on the SEH mixin.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing DEP in Metasploit modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Data Execution Prevention** (**DEP**) is a protection mechanism that marks
    specific areas of memory as non-executable, causing no execution of shellcode
    when it comes to exploitation. Therefore, even if we can overwrite the EIP register
    and point the ESP to the start of the shellcode, we will not be able to execute
    our payloads. This is because DEP prevents the execution of data in the writable
    areas of the memory, such as stack and heap. In this case, we will need to use
    existing instructions that are in the executable regions to achieve the desired
    functionality. We can do this by putting all the executable instructions in such
    an order that jumping to the shellcode becomes viable.'
  prefs: []
  type: TYPE_NORMAL
- en: The technique for bypassing DEP is called **Return Oriented Programming** (**ROP**).
    ROP differs from an ordinary stack overflow, where overwriting the EIP and calling
    the jump to the shellcode is only required. When DEP is enabled, we cannot do
    that since the data in the stack is non-executable. Here, instead of jumping to
    the shellcode, we will call the first ROP gadget, and these gadgets should be
    set up in such a way that they form a chained structure, where one gadget returns
    to the next one without ever executing any code from the stack.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will see how we can find ROP gadgets, which are
    instructions that can perform operations over registers followed by a return (`RET`)
    instruction. The best way to find ROP gadgets is to look for them in loaded modules
    (DLLs). The combination of such gadgets formed together that takes one address
    after the other from the stack and returns to the next one are called ROP chains.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have an example application that is vulnerable to stack overflow. The offset
    value for overwriting EIP is 2006\. Let''s see what happens when we exploit this
    application using Metasploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8257a82-1559-485b-81b8-51473cb4d7e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that we got a Meterpreter shell with ease. Let''s turn on DEP in
    Windows by navigating to the advanced system properties from the system properties,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fd448d5-a14e-40ed-8c4d-4bdb79ffa9e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We turned on DEP by selecting Turn on DEP for all programs and services except
    those I select. Let''s restart our system and retry exploiting the same vulnerability,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d19ebd28-fd05-4b24-af6a-2ef5a65a4d5d.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that our exploit failed because the shellcode was not executed.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example application from: [http://www.thegreycorner.com/2010/12/introducing-vulnserver.html](http://www.thegreycorner.com/2010/12/introducing-vulnserver.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the upcoming sections, we will see how we can bypass limitations posed by
    DEP using Metasploit and gain access to the protected systems. Let''s keep DEP
    enabled, attach the same vulnerable application to the debugger, and check its
    executable modules, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df7cc20b-64f2-411f-8dac-997886a437c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the Mona script, as we did previously, we can find information about all
    the modules using the `!mona modules` command. However, to build ROP chains, we
    need to find all the executable ROP gadgets within these DLL files.
  prefs: []
  type: TYPE_NORMAL
- en: Using msfrop to find ROP gadgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Metasploit provides a very convenient tool to find ROP gadgets: `msfrop`. It
    not only enables us to list all the ROP gadgets but also allows us to search through
    those gadgets to find the appropriate gadgets for our required actions. Let''s
    say we need to see all the gadgets that can help us to perform a pop operation
    over the `ECX` register. We can do this using `msfrop`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b26f0e56-3daf-4848-a42b-0e3289dfe707.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As soon as we provide the `-s` switch for searching and `-v` for verbose output,
    we start getting a list of all the gadgets where the POP ECX instruction is used.
    Let''s see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cae599b6-1754-4486-915b-d67b673fecec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that we have various gadgets that can perform the POP ECX task with
    ease. However, to build a successful Metasploit module that can exploit the target
    application in the presence of DEP, we need to develop a chain of these ROP gadgets
    without executing anything from the stack. Let''s understand the ROP bypass for
    DEP through the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ae8c704-8223-47e1-a1a1-8414361dc207.png)'
  prefs: []
  type: TYPE_IMG
- en: On the left side, we have the layout for a standard application. In the middle,
    we have an application that is attacked using a buffer overflow vulnerability,
    causing the overwrite of the EIP register. On the right, we have the mechanism
    for the DEP bypass, where instead of overwriting EIP with the JMP ESP address,
    we overwrite it with the address of the ROP gadget, followed by another ROP gadget,
    and so on until the execution of the shellcode is achieved.
  prefs: []
  type: TYPE_NORMAL
- en: How will the execution of instructions bypass hardware-enabled DEP protection?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is simple. The trick is to chain these ROP gadgets to call a `VirtualProtect()`
    function, which is a memory protection function used to make the stack executable
    so that the shellcode can execute. Let''s look at the steps we need to perform
    to get the exploit to work under DEP protection:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the offset to the EIP register
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overwrite the register with the first ROP gadget
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue overwriting with the rest of the gadgets until the shellcode becomes
    executable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the shellcode
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Mona to create ROP chains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the Mona script from the Immunity Debugger, we can find ROP gadgets.
    However, it also provides functionality to create an entire ROP chain by itself,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/488269bb-b3c7-4609-b3de-0c7cbb5f008a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the `!mona rop -m *.dll -cp nonull` command in the Immunity Debugger''s
    console, we can find all the relevant information about the ROP gadgets. We can
    see that we have the following files generated by the Mona script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb4f21a9-c0ad-43e5-99dd-cdeb145d080b.png)'
  prefs: []
  type: TYPE_IMG
- en: Interestingly, we have a file called `rop_chains.txt`, which contains the entire
    chain that can be used directly in the exploit module. This file contains the
    ROP chains created in Python, C, and Ruby for use in Metasploit already. All we
    need to do is copy the ROP chain into our exploit, and we are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a ROP chain for triggering the `VirtualProtect()` function, we need
    the following setup of registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a949b3aa-4cb1-4243-99c3-5745db324264.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see the ROP chain created by the Mona script, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80399eaa-788b-46d3-9749-d46e0614de54.png)'
  prefs: []
  type: TYPE_IMG
- en: We have a complete `create_rop_chain` function in the `rop_chains.txt` file
    for Metasploit. We merely need to copy this function to our exploit.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Metasploit exploit module for DEP bypass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will write the DEP bypass exploit for the same vulnerable
    application in which we exploited the stack overflow vulnerability, and the exploit
    failed when DEP was enabled. The application runs on TCP port `9999`. So, let''s
    quickly build a module and try bypassing DEP on the same application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We have written numerous modules, and are quite familiar with the required
    libraries and the initialization section. Additionally, we do not need a return
    address since we are using ROP chains that automatically build mechanisms to jump
    to the shellcode. Let''s focus on the exploit section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we copied the entire `create_rop_chain` function from the `rop_chains.txt`
    file generated by the Mona script to our exploit.
  prefs: []
  type: TYPE_NORMAL
- en: We begin the exploit method by connecting to the target. Then, we call the `create_rop_chain`
    function and store the entire chain in a variable called `rop_chain`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a random text of `2006` characters using the `rand_text_alpha_upper`
    function and store it into a variable called `junk`. The vulnerability in the
    application lies in the execution of the `TRUN` command. Therefore, we create
    a new variable called `buf` and store the `TRUN` command, followed by the `junk`
    variable that holds `2006` random characters, followed by our `rop_chain`. We
    also add some padding and, finally, the shellcode to the `buf` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we just put the `buf` variable onto the communication channel `sock.put`
    method. Finally, we just call the handler to check for successful exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run this module and check if we can exploit the system or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/671993e2-7b00-4d79-b1ab-68672df8b82b.png)'
  prefs: []
  type: TYPE_IMG
- en: Bingo! We made it through the DEP protection with ease. We can now perform post-exploitation
    on the compromised target.
  prefs: []
  type: TYPE_NORMAL
- en: Other protection mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we developed exploits based on stack-based vulnerabilities
    and in our journey of exploitation, we bypassed SEH and DEP protection mechanisms.
    There are many more protection techniques, such as **Address Space Layout Randomization**
    (**ASLR**), **stack cookies**, **SafeSEH**, **SEHOP**, and many others. We will
    see bypass techniques for these techniques in the upcoming sections of the book.
    However, these techniques will require an excellent understanding of assembly,
    opcodes, and debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to an excellent tutorial on bypassing protection mechanisms at: [https://www.corelan.be/index.php/2009/09/21/exploit-writing-tutorial-part-6-bypassing-stack-cookies-safeseh-hw-dep-and-aslr/](https://www.corelan.be/index.php/2009/09/21/exploit-writing-tutorial-part-6-bypassing-stack-cookies-safeseh-hw-dep-and-aslr/).
  prefs: []
  type: TYPE_NORMAL
- en: For more information on debugging, refer to: [http://resources.infosecinstitute.com/debugging-fundamentals-for-exploit-development/](http://resources.infosecinstitute.com/debugging-fundamentals-for-exploit-development/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by covering the essentials of assembly in the context
    of exploit writing in Metasploit, the general concepts, and their importance in
    exploitation. We covered details of stack-based overflows, SEH-based stack overflows,
    and bypasses for protection mechanisms such as DEP in depth. We included various
    handy tools in Metasploit that aid the process of exploitation. We also looked
    at the importance of bad characters and space limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can perform tasks such as writing exploits for software in Metasploit
    with the help of supporting tools, determining essential registers, methods to
    overwrite them, and defeating sophisticated protection mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feel free to perform the following set of exercises before proceeding with
    the next chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Try finding exploits on exploit-db.com which work only on Windows XP systems
    and make them usable on Windows 7/8/8.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take at least 3 POC exploits from [https://exploit-db.com/](https://exploit-db.com/)
    and convert them to a fully capable Metasploit exploit module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start making contributions to Metasploit's GitHub repository and fork the main
    instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will look at publicly available exploits that are currently
    not available in Metasploit. We will try porting them to the Metasploit framework.
  prefs: []
  type: TYPE_NORMAL

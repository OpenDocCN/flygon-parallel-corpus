- en: 1\. Hello C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces you to the basics of C#. You will start by learning
    about the basics of the .NET Command-Line Interface (CLI) and how to use Visual
    Studio Code (VS Code) as a basic Integrated Development Environment (IDE). You
    will then learn about the various C# data types and how to declare variables for
    these types, before moving on to a section about arithmetic and logical operators.
    By the end of the chapter, you will know how to handle exceptions and errors and
    be able to write simple programs in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# is a programming language created in the early 2000s by a team at Microsoft
    led by Anders Hejlsberg, who is also among the creators of some other popular
    languages, such as Delphi and Turbo Pascal, both widely used in the 1990s. Over
    the last 20 years, C# has grown and evolved, and today it is one of the most widely
    used programming languages globally, according to Stack Overflow's 2020 insights.
  prefs: []
  type: TYPE_NORMAL
- en: It has its reasons for holding such an honorable place in the tech community.
    C# allows you to write applications for a wide segment of markets and devices.
    From the banking industry, with its high-security standards, to e-commerce companies,
    which hold enormous volumes of transactions, it is a language trusted by companies
    that need both performance and reliability. Besides that, C# also makes it possible
    to write web, desktop, mobile, and even IoT applications, allowing you to develop
    for almost every kind of device.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# was initially limited to work only on Windows; however, there have been
    concerted efforts by the C# team over the past few years to make it cross-platform
    compatible. Today, it can be used with all major OS distributions, namely, Windows,
    Linux, and macOS. The goal is simple: to develop, build, and run C# anywhere,
    letting each developer and team choose their most productive or favorite environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Another remarkable characteristic of C# is that it is a strongly typed programming
    language. You will dive into this more deeply in the upcoming sections, and you
    will see that strong typing enables better data security while programming.
  prefs: []
  type: TYPE_NORMAL
- en: Besides that, C# has become open source over the last few years, with Microsoft
    as its principal maintainer. This is highly advantageous, as it allows the language
    to receive continuous improvements from around the globe, with a solid backing
    company that both promotes and invests in it. C# is also a multi-paradigm language,
    meaning that you can use it to write software in many programming styles, in a
    beautiful, concise, and proper manner.
  prefs: []
  type: TYPE_NORMAL
- en: Running and Developing C# with the .NET CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One term you'll hear a lot in the C# world is .NET. It is the foundation of
    C#, a framework that the language is built on top of. It has both a Software Development
    Kit (SDK) that allows the language to be developed and a runtime that allows the
    language to run.
  prefs: []
  type: TYPE_NORMAL
- en: That said, to start developing with C#, you only need to install the .NET SDK.
    This installation will provide both a compiler and the runtime on the development
    environment. In this section, you will cover the basic steps of preparing your
    environment for developing and running C# locally.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the *Preface* of this book for step-by-step instructions on
    how to download the .NET 6.0 SDK and install it on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: Once the installation of the .NET 6.0 SDK is completed, you will have something
    called the .NET CLI. This Command-Line Interface (CLI) allows you to create new
    projects, compile them, and run them with very simple commands that you can run
    directly from your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the installation, run the following command on your favorite terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This output shows that you have the 6.0.100 version of the SDK installed on
    your computer. That means you are ready to start developing your applications.
    If you type `dotnet -–help`, you will notice that several commands will appear
    for you as options to run within the CLI. In this section, you will cover the
    most basic ones that you need to create and run applications: `new`, `build`,
    and `run`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dotnet new` command allows you to create a bootstrap project to start
    developing. The CLI has several built-in templates, which are nothing more than
    basic bootstraps for various types of applications: web apps, desktop apps, and
    so on. You must specify two things in the `dotnet new` command:'
  prefs: []
  type: TYPE_NORMAL
- en: The template name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The project name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The name is passed as an argument, which means you should specify it with a
    `-n` or `–name` flag. The command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, to create a new console application named `MyConsoleApp` you
    can simply type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will generate a new folder with a file named `MyConsoleApp.csproj`, which
    is the C# project file that contains all the metadata needed by the compiler to
    build your project, and some files needed for the application to be built and
    run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `dotnet build` command allows you to build an application and make
    it ready to run. This command should be placed only in two locations:'
  prefs: []
  type: TYPE_NORMAL
- en: A project folder, containing a `.csproj` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A folder containing a `.sln` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solution (`.sln`) files are files that contain the metadata of one or more project
    files. They are used to organize multiple project files into single builds.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the third important command is dotnet `run`. This command allows you
    to properly run an application. It can be called without any arguments from the
    folder that contains the `.csproj` file of your .NET app, or without passing the
    project folder with the `-–project` flag on the CLI. The `run` command also automatically
    builds the application prior to the run.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Programs with the CLI and VS Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While working through this book, you will use Visual Studio Code (VS Code) as
    your code editor. It works on all platforms, and you can download the version
    for your OS at https://code.visualstudio.com/. Although VS Code is not a complete
    Integrated Development Environment (IDE), it has a lot of extensions that make
    it a powerful tool to develop and do proper C# coding, regardless of the OS being
    used.
  prefs: []
  type: TYPE_NORMAL
- en: To properly develop C# code, you will primarily need to install the Microsoft
    C# extension. It equips VS Code with the ability to do code completion and identify
    errors and is available at [https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp](https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding, it is recommended that you install VS Code and the Microsoft
    C# extension. You can find a step-by-step breakdown of the installation process
    in the *Preface* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Anatomy of a C# Program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to run, every C# program needs something called an entry point. In
    C#, the standard entry point for a program is the `Main` method. Regardless of
    your program type, whether it is a web application, desktop application, or even
    a simple console one, the `Main` method will be the **entry point** for your C#
    program. This means that each time an application runs, the runtime searches for
    this method within your code and executes the code blocks inside it.
  prefs: []
  type: TYPE_NORMAL
- en: This structure is created for you by the CLI, with the `new` command. A `Program.cs`
    file contains a class named `Program`, with a method named `Main`, which, in turn,
    contains a single instruction that will be executed after the program is built
    and running. You will learn more about methods and classes later, but for now,
    just know that a class is something that usually contains a set of data and that
    can perform actions on this data through these **methods**.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to note regarding basic C# concepts is `//`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.01: Creating a Console App that Says "Hello World"'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will see the CLI commands you learned about in the previous
    section, as you build your first ever C# program. It will be a simple console
    app that will print `Hello World` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the VS Code integrated terminal and type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This command will create a new console application in the `Exercise1_01` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the command line, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: "Hello World" output on the console'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_01_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.1: "Hello World" output on the console'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/HErU6](https://packt.link/HErU6).
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you created the most basic program possible with C#, a console
    application that prints some text to the prompt. You also learned how to use .NET
    CLI, which is the mechanism built within the .NET SDK to create and manage .NET projects.
  prefs: []
  type: TYPE_NORMAL
- en: Now proceed to the next section to grasp how top-level statements are written.
  prefs: []
  type: TYPE_NORMAL
- en: Top-Level Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You must have noticed in *Exercise 1.01* that, by default, when you create
    a console application, you have a `Program.cs` file that contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A class named `Program`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The static void `Main` keywords.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will learn about classes and methods in detail later, but for now, for
    the sake of simplicity, you do not need these resources to create and execute
    programs with C#. The latest version (.NET 6) introduced a feature that makes
    writing simple programs much easier and less verbose. For instance, consider the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can simply replace this snippet with two lines of code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By using such top-level statements, you can write concise programs. You can
    simply put the statements to be executed at the top of the program. This is also
    useful for speeding up the learning curve with C#, as you need not worry about
    advanced concepts upfront. The only thing to look out for here is that the project
    can have only one file with top-level statements.
  prefs: []
  type: TYPE_NORMAL
- en: That is why in this chapter, you will find that all exercises will use this
    format, to make things as clear as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will now take your first steps in creating your own programs. This section
    will delve into the concept of variables—what they are and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: A variable is a name given to a computer memory location that holds some data
    that may vary. For a variable to exist, it first must be **declared** with a type
    and a name. It can also have a value assigned to it. The declaration of a variable
    can be achieved in a few different ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some basic considerations regarding naming conventions for variables
    in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: The names must be unique, starting with a letter, and should contain only letters,
    digits, and the underscore character (`_`). The names can also begin with an underscore
    character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The names are case-sensitive; thus, `myVariable` and `MyVariable` are different
    names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reserved keywords, such as `int` or `string`, cannot be used as names (this
    is a compiler restriction) unless you put an `@` symbol in front of the name,
    such as `@int` or `@string`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Variables can be declared in two ways: explicitly and implicitly. Both styles
    of the declaration have their pros and cons, which you will explore in the next
    section.'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Variables Explicitly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A variable can be declared explicitly by writing both its type and value. Suppose
    you want to create two variables, `a` and `b`, both containing integers. Doing
    so explicitly would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Before a variable is used, it must have a value assigned. Otherwise, the C#
    compiler will give an error while building your program. The following example
    illustrates that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to declare multiple variables in the same line, like in
    the following snippet, where you are declaring three variables; two hold the value
    `100` and one holds the value `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Declaring Variables Implicitly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that C# is a strongly typed programming language; this means that a
    variable will always have a type associated with it. It does not matter whether
    the type is declared implicitly or explicitly. With the `var` keyword, the C#
    compiler will infer the variable type based on the value that has been assigned
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that you want to create a variable that holds some text using this
    method. This can be done with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For storing text in a variable, you should start and end the text with double
    quotes (`"`). In the preceding example, by looking at the value that was assigned
    to `name`, C# knows that the type this variable holds is a string, even though
    the type is not mentioned in the statement.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit versus Implicit Declaration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Explicit declarations enhance readability with the type declared, and this is
    one of the main advantages of this technique. On the other hand, they tend to
    let the code become more verbose, especially when working with some data types
    (that you will see further ahead), such as `Collections`.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, deciding on the style of declaration depends on the personal preferences
    of the programmer, and may be influenced by the company's guidelines in some cases.
    In this journey of learning, it is recommended that you pick one that makes your
    learning path smoother, as there are few substantial differences from a purely
    technical standpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next exercise, you will do this yourself by assigning variables to inputs
    that come from a user''s interaction with a console application, where the user
    will be asked to input their name. To complete this exercise, you will make use
    of the following built-in methods that C# provides, which you will be using frequently
    in your C# journey:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Console.ReadLine()`: This allows you to retrieve a value that the user prompted
    on the console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Console.WriteLine()`: This writes the value passed as an argument as an output
    to the console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 1.02: Assigning Variables to User Inputs'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will create an interactive console application. The app
    should ask you for your name, and once provided, it should display a greeting
    with your name in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete this exercise, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Command Prompt and type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a new console application in the `Exercise1_02` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Program.cs` file. Paste the following inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file. On the command line, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, type your name into the console and hit `Enter` on your keyboard. For
    example, if you type in `Mateus`, the following will be the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/1fbVH](https://packt.link/1fbVH).
  prefs: []
  type: TYPE_NORMAL
- en: You are more familiar with what variables are, how to declare them, and how
    to assign values to them. Now it is time to start talking about what data these
    variables can store and, more specifically, what types of data there are.
  prefs: []
  type: TYPE_NORMAL
- en: Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will talk about the main data types within C# and their functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C# uses the `string` keyword to identify data that stores text as a sequence
    of characters. You can declare a string in several ways, as shown in the following
    snippet. However, when assigning some value to a string variable, you must place
    the content between a pair of double quotes, as you can see in the last two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'One simple but effective technique (that you used in the preceding *Exercise
    1.02*) is one called string interpolation. With this technique, it is very simple
    to mix plain text values with variable values, so that the text is combined among
    these two. You can combine two or more strings by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Before the initial quotes, insert a `$` symbol.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, inside the strings, place curly brackets and the name of the variable
    that you want to put into the string. In this case, this is done by putting `{name}`
    inside the initial string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Another important fact to remember about strings is that they are immutable.
    This means that a string object cannot be changed after its creation. This happens
    because strings in C# are an array of characters. Arrays are data structures that
    gather objects of the same type and have a fixed length. You will cover arrays
    in detail in an upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will explore string immutability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.03: Checking String Immutability'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will use two strings to demonstrate that string references
    are always immutable. Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the VS Code integrated terminal and type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `Program.cs` file and create a method with the `void` return type,
    which replaces part of a string like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, the `Replace` function is used to replace the first
    string (`World`, in this case) with the second one (`Mars`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a method that does the same thing but returns the result instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now insert the following after the previous methods. Here, you create two string
    variables and observe their behavior after trying to modify them with the methods
    created previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, call `dotnet run --project Exercise1_03` from the command line. You
    should see the following output on the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/ZoNiw](https://packt.link/ZoNiw).
  prefs: []
  type: TYPE_NORMAL
- en: With this exercise, you saw the concept of string immutability in action. When
    you passed a string that was a reference type (`Hello World!`) as a method argument,
    it was not modified. That is what happens when you use the `FormatString` method,
    which returns `void`. Due to string immutability, a new string is created but
    not allocated to any variable, and the original string stays the same. With the
    second method, it returns a new string, and this string is then printed to the
    console.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though strings are reference values, when you use the `.Equals()` method,
    the equality operator (`==`), and other operators (such as `!=`), you are actually
    comparing the values of the strings, as can be seen in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can compare these values and call `Console.WriteLine()` to output the
    result, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You get this output because, even though strings are reference types, both the
    `==` and `.Equals` comparisons run against string values. Also, remember that
    strings are immutable. This means that when you assign `second` to `first` and
    set `first` as `null`, a new value is created for `first` and, therefore, the
    reference for `second` does not change.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C# has its numeric types subdivided into two main categories—integral and floating-point
    type numbers. The integral number types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sbyte`: Holds values from -128 to 127'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short`: Holds values from -32,768 to 32,767'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: Holds values from -2,147,483,648 to 2,147,483,647'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`: Holds values from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deciding which type of integral type to use depends on the size of the values
    you want to store.
  prefs: []
  type: TYPE_NORMAL
- en: All these types are called signed values. This means that they can store both
    negative and positive numbers. There is also another range of types called unsigned
    types. Unsigned types are `byte`, `ushort`, `uint`, and `ulong`. The main difference
    between them is that signed types can store negative numbers and unsigned types
    can store only numbers greater than or equal to zero. You will use signed types
    most of the time, so do not worry about remembering this all at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other category, namely, floating-point types, refers to the types used
    to store numbers with one or more decimal points. There are three floating-point
    types in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '`float`: This occupies four bytes and can store numbers from ± 1.5 x 10−45
    to ± 3.4 x 1038 with a precision range of six to nine digits. To declare a float
    number using `var`, you can simply append `f` to the end of the number, like so:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`double`: This occupies eight bytes and can store numbers from ± 5.0 × 10−324
    to ± 1.7 × 1030 with a precision range of 15 to 17 digits. To declare a double
    number using var, you can append d to the end of the number, like so:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`decimal`: This occupies 16 bytes and can store numbers from ± 1.0 x 10-28
    to ± 7.9228 x 1028 with a precision range from 28 to 29 digits. To declare a decimal
    number using var, you must simply append m to the end of the number, like so:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Choosing the floating-point type depends mainly on the degree of precision required.
    For instance, `decimal` is mostly used for financial applications that need a
    very high degree of precision and cannot rely on rounding for accurate calculations.
    With GPS coordinates, `double` variables might be appropriate if you want to deal
    with sub-meter precisions that usually have 10 digits.
  prefs: []
  type: TYPE_NORMAL
- en: Another relevant point to consider when choosing numeric types is performance.
    The larger the memory space allocated to a variable, the less performant the operations
    with these variables are. Therefore, if high precision is not a requirement, `float`
    variables will be better performers than `doubles`, which, in turn, will be better
    performers than decimals.
  prefs: []
  type: TYPE_NORMAL
- en: Here you grasped what variables are and their main types. Now you will perform
    some basic calculations with them, such as addition, subtraction, and multiplication.
    This can be done using the arithmetic operators available in C#, such as `+`,
    `-`, `/`, and `*`. So, move on to the next exercise where you will create a basic
    calculator using these operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.04: Using the Basic Arithmetic Operators'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will create a simple calculator that receives two inputs
    and shows the results between them, based on which arithmetic operation is selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the VS Code integrated terminal and type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to the project folder, open the `Program.cs` file, and inside the
    `Main` method, declare two variables that read the user input, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet uses the `.ReadLine` method to read the input. This method,
    however, gives a `string`, and you need to evaluate a number. Therefore, the `Parse`
    method has been used here. All the numeric types have a method called Parse, which
    receives a string and converts it into a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to write the output of these basic operators to the console.
    Add the following code to the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program using the `dotnet run` command, and you should see the following
    output, if you input `10` and `20`, for instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/ldWVv](https://packt.link/ldWVv).
  prefs: []
  type: TYPE_NORMAL
- en: Thus, you have built a simple calculator app in C# using the arithmetic operators.
    You also learned about the concept of parsing, which is used to convert strings
    to numbers. In the next section, you will briefly cover the topic of classes,
    one of the core concepts of programming in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes are an integral part of coding in C# and will be covered comprehensively
    in *Chapter 2*, *Building Quality Object-Oriented Code*. This section touches
    upon the basics of classes so that you can begin using them in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: The reserved `class` keyword within C# is used when you want to define the type
    of an object. An object, which can also be called an instance, is nothing more
    than a block of memory that has been allocated to store information. Given this
    definition, what a class does is act as a blueprint for an object by having some
    properties to describe this object and specifying the actions that this object
    can perform through methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider that you have a class named `Person`, with two properties,
    `Name` and `Age`, and a method that checks whether `Person` is a child. Methods
    are where logic can be placed to perform some action. They can return a value
    of a certain type or have the special `void` keyword, which indicates that they
    do not return anything but just execute some action. You can also have methods
    calling other methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'One question remains, though. Since classes act as blueprints (or definitions
    if you prefer), how do you actually allocate memory to store the information defined
    by a class? This is done through a process called instantiation. When you instantiate
    an object, you allocate some space in memory for it in a reserved area called
    the heap. When you assign a variable to an object, you are setting the variable
    to have the address of this memory space, so that each time you manipulate this
    variable, it points to and manipulates the data allocated at this memory space.
    The following is a simple example of instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note that `Person` has properties that have two magic keywords—`get` and `set`.
    Getters define that a property value can be retrieved, and setters define that
    a property value can be set.
  prefs: []
  type: TYPE_NORMAL
- en: Another important concept here is the concept of a constructor. A constructor
    is a method with no return type, usually present at the top level of the class
    for better readability. It specifies what is needed for an object to be created.
    By default, a class will always have a parameter-less constructor. If another
    constructor with parameters is defined, the class will be constrained to only
    this one. In that case, if you still want to have a parameter-less constructor,
    you must specify one. This is quite useful, as classes can have multiple constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, you can assign values to an object property that has a setter in
    the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of creation, via its constructor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'At the time of creation, with direct variable assignment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'After the object is created, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a lot more to classes that you will see further on. For now, the main
    ideas are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes are blueprints of objects and can have both properties and methods that
    describe these objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects need to be instantiated so that you can perform operations with them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes have one parameter-less constructor by default, but can have many customized
    ones as required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object variables are references that contain the memory address of a special
    memory space allocated to the object inside a dedicated memory section named the
    heap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A date can be represented in C# using the `DateTime` value type. It is a struct
    with two static properties called `MinValue`, which is January 1, 0001 00:00:00,
    and `MaxValue`, which is December 31, 9999 11:59:59 P.M. As the names suggest,
    both these values represent the minimum and maximum dates according to the Gregorian
    calendar date format. The default value for `DateTime` objects is `MinValue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to construct a `DateTime` variable in various ways. Some of
    the most common ways are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assigning the current time as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This sets the variable to the current date and time on the calling computer,
    expressed as the local time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This sets the variable to the current date and time on this computer, expressed
    as the Coordinated Universal Time (UTC).
  prefs: []
  type: TYPE_NORMAL
- en: You can also use constructors for passing days, months, years, hours, minutes,
    and even seconds and milliseconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also a special property available for `DateTime` objects called `Ticks`.
    It is a measure of the number of 100 nanoseconds elapsed since `DateTime.MinValue`.
    Every time you have an object of this type, you can call the `Ticks` property
    to get such a value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another special type for dates is the `TimeSpan` struct. A `TimeSpan` object
    represents a time interval as days, hours, minutes, and seconds. It is useful
    when fetching intervals between dates. You will now see what this looks like in practice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 1.05: Using Date Arithmetic'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will use the `TimeSpan` method/struct to calculate the
    difference between your local time and the UTC time. To complete this exercise,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the VS Code integrated terminal and type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Open the `Program.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Paste the following inside the `Main` method and save the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, you first checked whether the current local date and
    UTC dates were equal. Then you checked for the interval between them, if any,
    using the `TimeSpan` method. Next, it printed the difference between the local
    and UTC time and printed the date two days ahead of the current one (`31/12/ 2020`,
    in this case).
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the file. On the command line, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/WIScZ](https://packt.link/WIScZ).
  prefs: []
  type: TYPE_NORMAL
- en: Note that depending on your time zone, you will likely see different output.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting Dates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is also possible to format `DateTime` values to localized strings. That
    means formatting a `DateTime` instance according to a special concept within the
    C# language called a culture, which is a representation of your local time. For
    instance, dates are represented differently in different countries. Now take a
    look at the following examples, where dates are outputted in both the format used
    in France and the format used in the United States:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to explicitly define the format you want the date to be
    output in, as in the following example, where you pass the `yyyyMMddTHH:mm:ss`
    value to say that you want the date to be output as year, then month, then day,
    then hour, then minutes preceded by a colon, and finally, seconds, also preceded
    by a colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output gets displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Logical Operators and Boolean Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You are already familiar with these. Recall that in the preceding exercise,
    you did the following comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This output assigns the value `true` to `now` if the dates are equal. But as
    you know, they might not necessarily be the same. Therefore, if the dates are
    different, a `false` value will be assigned. These two values are the result of
    such Boolean expressions and are called Boolean values. That is why the `now`
    variable has the type of `bool`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Boolean expressions are the base for every logical comparison in every program.
    Based on these comparisons, a computer can execute a certain behavior in a program.
    Here are some other examples of Boolean expressions and variable assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assigning the result of a comparison that checks whether `a` is greater than
    `b`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Assigning the result of a comparison that checks whether `b` is greater than
    or equal to `a`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking whether two strings are equal and assigning the result of this comparison
    to a variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, the result of the previous comparison would be `false` and this value
    will be assigned to the `areTheseAnimalsSame` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have learned what Booleans are and how they work, it is time to
    look at some logical operators you can use to compare Boolean variables and expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `&&` (AND) operator: This operator will perform an equality comparison.
    It will return `true` if both are equal and `false` if they are not. Consider
    the following example, where you check whether two strings have the length `0`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `||` (OR) operator: This operator will check whether either of the values
    being compared is `true`. For example, here you are checking whether at least
    one of the strings has zero length:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `!` (NOT) operator: This operator takes a Boolean expression or value and
    negates it; that is, it returns the opposite value. For example, consider the
    following example, where you negate the result of a comparison that checks whether
    one of the strings has zero length:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Using if-else Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up till now, you have learned about types, variables, and operators. Now it
    is time to go into the mechanisms that help you to use these concepts in real-world
    problems—that is, decision-making statements.
  prefs: []
  type: TYPE_NORMAL
- en: In C#, `if-else` statements are some of the most popular choices for implementing
    branching in code, which means telling the code to follow one path if a condition
    is satisfied, else follow another path. They are logical statements that evaluate
    a Boolean expression and continue the program's execution based on this evaluation result.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can use `if-else` statements to check whether the password
    entered satisfies certain criteria (such as having at least six characters and
    one digit). In the next exercise, you will do exactly that, in a simple console
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.06: Branching with if-else'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will use `if-else` statements to write a simple credentials
    check program. The application should ask the user to enter their username; unless
    this value is at least six characters in length, the user cannot proceed. Once
    this condition is met, the user should be asked for a password. The password should
    also have a minimum of six characters containing at least one digit. Only after
    both these criteria are met should the program display a success message, such
    as `User successfully registered`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the VS Code integrated terminal, create a new console project called
    `Exercise1_06`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Main` method, add the following code to ask the user for a username,
    and assign the value to a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the program needs to check whether the username has more than six characters
    and if not, write an error message to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, within an `else` clause, you will continue the verification and ask the
    user to type a password. Once the user has entered a password, three points need
    to be checked. The first condition to check is whether the password has at least
    six characters and then whether there is at least one number. Then, if either
    of these conditions fails, the console should display an error message; else,
    it should display a success message. Add the following code for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding snippet, you can see that if the user enters fewer than six
    characters, an error message is displayed as `The password must have at least
    6 characters.`. If the password doesn't contain a single digit but satisfies the
    preceding condition, another error message is displayed as `The password must
    contain at least one number.`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the logical condition used for this, which is `!password.Any(c => char.IsDi©(c))`.
    You will learn more about the `=>` notation in *Chapter 2*, *Building Quality
    Object-Oriented Code*, but for now, you just need to know that this line checks
    every character in the password and uses the `IsDigit` function to check whether
    the character is a digit. This is done for every character, and if no digit is
    found, the error message is displayed. If all the conditions are met, a success
    message is displayed as `User successfully registered.`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the program using `dotnet run`. You should see an output like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/3Q7oK](https://packt.link/3Q7oK).
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you worked with if-else branching statements to implement
    a simple user registration program.
  prefs: []
  type: TYPE_NORMAL
- en: The Ternary Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another simple-to-use, yet effective, decision-making operator is the ternary
    operator. It allows you to set the value of a variable based on a Boolean comparison.
    For example, consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here, you are using the `?` symbol to check whether the Boolean condition placed
    before it is valid. The compiler runs the `IsChild` function for the `person`
    object. If the method returns `true`, the first value (before the `:` symbol)
    will be assigned to the `gift` variable. If the method returns `false`, the second
    value (after the `:` symbol) will be assigned to the `gift` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The ternary operator is simple and makes assignments based on simple Boolean
    verifications even more concise. You will be using this quite often in your C#
    journey.
  prefs: []
  type: TYPE_NORMAL
- en: Reference and Value Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two types of variables in C#, namely, reference types and value types.
    Variables of value types, such as structs, contain the values themselves, as the
    name suggests. These values are stored in a memory space called the stack. When
    a variable of such a type is declared, specific memory space is allocated to store
    this value, as illustrated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: Memory allocation for a value type variable'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_01_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.2: Memory allocation for a value type variable'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the value of the variable, which is `5`, is stored in memory at the location
    `0x100` in the RAM. The built-in value types for C# are `bool`, `byte`, `char`,
    `decimal`, `double`, `enum`, `float`, `int`, `long`, `sbyte`, `short`, `struct`,
    `uint`, `ulong`, and `ushort`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scenario for reference type variables is different, though. The three main
    reference types you need to know about in this chapter are `string`, array, and
    `class`. When a new reference type variable is assigned, what is stored in memory
    is not the value itself, but instead a memory address where the value gets allocated.
    For example, consider the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3: Memory allocation for a reference type variable'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_01_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.3: Memory allocation for a reference type variable'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, instead of the value of the string variable (`Hello`), the address where
    it is allocated (`0x100`) is stored in memory. For brevity, you will not dive
    deep into this topic, but it is important to know the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: When value type variables are passed as parameters or assigned as the value
    of another variable, the .NET runtime copies the value of the variable to the
    other object. This means that the original variable is not affected by any changes
    made in the newer and subsequent variables, as the values were literally copied
    from one place to another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When reference type variables are passed as parameters or assigned as the value
    of another variable, .NET passes the heap memory address instead of the value.
    This means that every subsequent change made in this variable inside a method
    will be reflected outside.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, consider the following code, which deals with integers. Here,
    you declare an `int` variable named `a` and assign the value `100` to it. Later,
    you create another `int` variable named `b` and assign the value of `a` to it.
    Finally, you modify `b`, to be incremented by `100`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The values of `a` and `b` will be displayed in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the value from `a` was copied into `b`. From this point, any
    other modification you do on `b` will reflect changes only in `b` and `a` will
    continue to have its original value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what if you pass reference types as method arguments? Consider the following
    program. Here, you have a class named `Car` with two properties—`Name` and `GearType`.
    Inside the program is a method called `UpgradeGearType` that receives an object
    of the `Car` type and changes its `GearType` to `Automatic`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'After you create a `Car` `UpgradeGearType()` method, the output will be as
    the follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Thus, you see that if you pass an `car` in this case) as an argument to a method
    (`UpgradeGearType` in this example), every change made inside this **object**
    is reflected after and outside the method call. This is because reference types
    refer to a specific location in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.07: Grasping Value and Reference Equality'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will see how equality comparison is different for value
    types and reference types. Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In VS Code, open the integrated terminal and type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `Program.cs` file. In the same file, create a struct named `GoldenRetriever`
    with a `Name` property, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Still in the same file, create one more class named `BorderCollie` with a similar
    `Name` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'One final class must be created, a class named `Bernese`, also having the `Name`
    property, but with an extra override of the native `Equals` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `this` keyword is used to refer to the current `borderCollie` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in the `Program.cs` file, you will create some objects for these types.
    Note that since you are using **top-level statements**, these declarations should
    be above the class and the struct declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, right after the previous declarations, compare these values using the
    `Equals` method and assign the result to some variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, print the comparison results to the console with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program from the command line using `dotnet run` and you will see the
    following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/xcWN9](https://packt.link/xcWN9).
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, structs are value types. Therefore, when two objects of
    the same struct are compared with `Equals`, .NET internally checks all the struct
    properties. If those properties have equal values, then `true` is returned. With
    `Golden Retrievers`, for instance, if you had a `FamilyName` property and this
    property was different between the two objects, the result of the equality comparison
    would be `false`.
  prefs: []
  type: TYPE_NORMAL
- en: For classes and all other reference types, the equality comparison is quite
    different. By default, object reference is checked on equality comparison. If
    the references are different (and they will be, unless the two variables are assigned
    to the same object), the equality comparison will return `false`. This explains
    the result you see for `Border Collies` in the example that the references were
    different for the two instances.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a method that can be implemented in reference types called
    Equals. Given two objects, the `Equals` method can be used for comparison following
    the logic placed inside the method. That is exactly what happened with the Bernese
    dogs example.
  prefs: []
  type: TYPE_NORMAL
- en: Default Value Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you have dealt with value and reference types, you will briefly explore
    the default value types. In C#, every type has a default value, as specified in
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4: Default value types table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_01_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.4: Default value types table'
  prefs: []
  type: TYPE_NORMAL
- en: 'These default values can be assigned to a variable using the `default` keyword.
    To use this word in a variable declaration, you must explicitly declare the variable
    type before its name. For example, consider the following snippet, where you are
    assigning the `default` value to two `int` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `a` and `b` will be assigned the value `0` in this case. Note that it
    is not possible to use `var` in this case. This is because, for implicitly declared
    variables, the compiler needs a value assigned to the variable in order to infer
    its type. So, the following snippet will lead to an error because no type was
    set, either through an explicit declaration or by variable assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Enhancing Decision Making with the switch Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `switch` statement is often used as an alternative to the if-else construct
    if a single expression is to be tested against three or more conditions, that
    is, when you want to select one of many code sections to be executed, such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The matching expression should return a value that is of one of the following
    types: `char`, `string`, `bool`, `numbers`, `enum`, and `object`. This value will
    then be evaluated within one of the matching case clauses or within the default
    clause if it does not match any prior clause.'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to say that only one `switch` section in a `switch` statement
    will be executed. C# doesn't allow execution to continue from one `switch` section
    to the next. However, a `switch` statement does not know how to stop by itself.
    You can either use the `break` keyword if you only wish to execute something without
    returning or return something if that is the case.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the `default` keyword on a `switch` statement is where the execution goes
    if none of the other options are matched. In the next exercise, you will use a
    `switch` statement to create a restaurant menu app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.08: Using switch to Order Food'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will create a console app that lets the user select from
    a menu of food items available at a restaurant. The app should display an acknowledgment
    receipt for the order. You will use the `switch` statement to implement the logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new console project called `Exercise1_08`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create an `System.Text.StringBuilder`. This is a class that helps build
    strings in many ways. Here, you are building strings line by line so that they
    can be properly displayed on the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Display the menu on the console and ask the user to choose one of the options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Read the key that the user presses and assign it to a variable with the `Console.ReadKey()`
    method. This method works similarly to `ReadLine()`, which you have used before,
    with the difference that it reads the key that is immediately pressed after calling
    the method. Add the following code for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it is time to use the `switch` statement. Use `option.KeyChar.ToString()`
    as the matching expression of the `switch` clause here. Keys `1`, `2`, `3`, and
    `4` should result in orders accepted for `burgers`, `cheeseburgers`, `double cheeseburgers`,
    and `Coke`, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Any other input, however, should be considered invalid and a message gets displayed,
    letting you know you have selected an invalid option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, run the program with `dotnet run --project Exercise1_08` and interact
    with the console to see the possible outputs. For example, if you type `1`, you
    should see an output like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/x1Mvn](https://packt.link/x1Mvn).
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you should get the output for the other options as well. You have
    learned about branching statements in C#. There is another type of statement that
    you will use often while programming using C#, called iteration statements. The
    next section covers this topic in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration Statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Iteration statements, also called loops, are types of statements that are useful
    in the real world, as you often need to continuously repeat some logical execution
    in your applications `while` or `until` some condition is met, such as operating
    with a number that must be incremented until a certain value. C# offers numerous
    ways of implementing such iterations, and in this section, you will examine each
    of these in detail.
  prefs: []
  type: TYPE_NORMAL
- en: while
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first iteration statement you will consider is the `while` statement. This
    statement allows a C# program to execute a set of instructions while a certain
    Boolean expression is evaluated to be `true`. It has one of the most basic structures.
    Consider the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet shows how you can use the `while` statement. Note that
    the `while` keyword is followed by a pair of brackets enclosing a logical condition;
    in this case, the condition is that the value of `i` must be less than `10`. The
    code written inside the curly braces will be executed until this condition is
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the preceding code will print the value of `i`, starting with `0`, up
    to `10`. This is fairly simplistic code; in the next exercise, you will use the
    `while` statement for something a little more complex, such as checking whether
    a number entered by you is a prime number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.09: Checking Whether a Number is Prime with a while Loop'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will use a `while` loop to check whether a number you
    enter is prime. To do so, the `while` loop will check whether the counter is less
    than or equal to the integer result of the division of the number by `2`. When
    this condition is satisfied, you check whether the remainder of the division of
    the number by the counter is `0`. If not, you increment the counter and continue
    until the loop condition is not met. If it is met, it means the number is not
    `false` and the loop can stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the VS Code integrated terminal, create a new console project called
    `Exercise1_09`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `Program.cs` file, create the following method, which will perform
    the logic you introduced at the beginning of the exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, input a number, so you can check whether it is prime:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, check whether the number is prime and print the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, on the VS Code integrated terminal, call `dotnet run --project Exercise1_09`
    and interact with the program. For example, try entering `29` as an input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the result for `29` is `true` since it is a prime number.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/5oNg5](https://packt.link/5oNg5).
  prefs: []
  type: TYPE_NORMAL
- en: The preceding exercise aimed to show you the simple structure of a `while` loop
    with some more complex logic. It checks a number (named `input`) and prints whether
    it is a prime number. Here, you have seen the `break` keyword used again to stop
    program execution. Now proceed to learn about jump statements.
  prefs: []
  type: TYPE_NORMAL
- en: Jump Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are some other important keywords used within loops that are worth mentioning
    as well. These keywords are called jump statements and are used to transfer program
    executions to another part. For instance, you could rewrite the `IsPrime` method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Here, you have inverted the logical check. Instead of checking whether the remainder
    is zero and then breaking the program execution, you have checked that the remainder
    is not zero and, if so, have used the `continue` statement to pass the execution
    to the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now look at how you can rewrite this using another special keyword, `goto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The `goto` keyword can be used to jump from one part of the code to another
    one defined by what is called a label. In this case, the label was named `isNotAPrime`.
    Finally, take a look at one last way of writing this logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Now, instead of using `break` or `continue` to stop the program execution, you
    simply use `return` to break the loop execution since the result that you were
    looking for was already found.
  prefs: []
  type: TYPE_NORMAL
- en: do-while
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `do-while` loop is like the previous one, but with one subtle difference:
    it executes the logic at least once, while a simple `while` statement may never
    be executed if the condition is not met at the first execution. It has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you write the value of `t`, starting from `0`, and keep incrementing
    it while it is smaller than `5`. Before jumping into the next type of loop, learn
    about a new concept called arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An array is a data structure used to store many objects of the same type. For
    instance, the following example is a variable declared as an array of integer
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The first important thing to note about arrays is that they have a fixed capacity.
    This means that an array will have the length defined at the time of its creation
    and this length cannot change. The length can be determined in various ways. In
    the preceding example, the length is inferred by counting the number of objects
    in the array. However, another way of creating an array is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you are creating an array that has the capacity of `5` integers, but
    you do not specify any value for the array elements. When an array of any data
    type is created without adding elements to it, the default values for that value
    type are set for each position of the array. For example, consider the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5: Value type array with no index assigned'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_01_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.5: Value type array with no index assigned'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding figure shows that when you create an integer array of five elements,
    without assigning a value to any element, the array is automatically filled with
    the default value at every position. In this case, the default value is `0`. Now
    consider the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6: Reference type array with fixed size and only one index assigned'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_01_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.6: Reference type array with fixed size and only one index assigned'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, you have created an array of five objects and assigned
    the `"Hello"` string value to the element at index `1`. The other positions of
    the array are automatically assigned the default value for objects, which is `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is worth noting that all arrays have indexes, which refers to the
    positions of the individual array elements. The first position will always have
    an index `0`. Thus, the positions in an array of size `n` can be specified from
    index `0` to `n-1`. Therefore, if you call `numbers[2]`, this means that you are
    trying to access the element in position `2` inside the numbers array.
  prefs: []
  type: TYPE_NORMAL
- en: for Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `for` loop executes a set of instructions while a Boolean expression matches
    a specified condition. Just like `while` loops, jump statements can be used to
    stop a loop execution. It has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The initializer statement is executed before the loop starts. It is used to
    declare and assign a local variable that will be used only inside the scope of
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'But in more complex scenarios, it can be used to combine other statement expressions
    as well. The condition specifies a Boolean condition that indicates when the loop
    should either continue or exit. The iterator is usually used to increment or decrement
    the variable created in the initializer section. Take the following example, where
    a `for` loop is used to print the elements of an integer array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: In this example, an initializer variable, `j`, has been created that is assigned
    `0` initially. The `for` loop will keep executing while `j` is smaller than the
    array length minus `1` (remember that indexes always start at `0`). After each
    iteration, the value of `j` is incremented by `1`. In this way, the `for` loop
    goes through the entire array and performs the given action, that is, printing
    the value of the current array element.
  prefs: []
  type: TYPE_NORMAL
- en: C# also allows the usage of **nested loops**, that is, a **loop within a loop**,
    as you will see in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.10: Ordering an Array Using Bubble Sort'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will execute one of the simplest sorting algorithms. Bubble
    sort consists of going through every pair of elements inside an array and swapping
    them if they are unordered. In the end, the expectation is to have an array ordered
    in ascending order. You will use nested `for` loops to implement this algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, the array to be sorted should be passed as a parameter to this
    method. For each element of this array, if the current element is greater than
    the next, their positions should be swapped. This swap occurs by storing the value
    of the next element in a temporary variable, assigning the value of the current
    element to the next element, and finally, setting the value of the current element
    with the temporary value stored. Once the first element is compared to all others,
    a comparison starts for the second element and so on, till finally, the array
    is sorted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new console project using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Program.cs` file, create the method to implement the sorting algorithm.
    Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create an **array** with some numbers, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `BubbleSort` method, passing the array as an argument, and assign
    the result to a variable, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you need to print the message that the array was sorted. To do so,
    iterate over it, printing the array elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the `dotnet run --project Exercise1_10` command. You should
    see the following output on your screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/cJs8y](https://packt.link/cJs8y).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you used the two concepts learned in the last two sections:
    arrays and for loops. You manipulated arrays, accessing their values through indexes,
    and used for loops to move through these indexes.'
  prefs: []
  type: TYPE_NORMAL
- en: There is another way to go through every element of an array or `foreach` statements.
    You will explore this in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: foreach Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `foreach` statement executes a set of instructions for each element of a
    collection. Just like a `for` loop, the `break`, `continue`, `goto`, and `return`
    keywords can also be used with `foreach` statements. Consider the following example,
    in which you iterate over every element of an array and write it to the console
    as the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet prints the numbers from `1` to `5` to the console. You
    can use `foreach` statements with much more than arrays; they can also be used
    with lists, collections, and spans, which are other data structures that will
    be covered in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: File Handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you have been creating programs that interact mostly with CPU and memory.
    This section will focus on I/O operations, that is, input and output operations,
    on the physical disk. A great example of this type of operation is file handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'C# has several classes that help you perform I/O operations. Some of these
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`File`: This class provides methods for the manipulation of files, that is,
    reading, writing, creating, deleting, copying, and moving files on the disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Directory`: Like the `File` class, this class includes methods to create,
    move, and enumerate directories and subdirectories on the disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Path`: This provides utilities to deal with absolute and relative paths of
    files and directories on the disk. A relative path is always related to some path
    inside the current directory where the application is being executed, and an absolute
    path refers to an absolute location inside the hard drive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DriveInfo`: This provides information about a disk drive, such as `Name`,
    `DriveType`, `VolumeLabel`, and `DriveFormat`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You already know that files are mostly some sets of data located somewhere
    in a hard drive that can be opened for reading or writing by some program. When
    you open a file in a C# application, your program reads the file as a sequence
    of bytes through a communication channel. This communication channel is called
    a stream. Streams can be of two types:'
  prefs: []
  type: TYPE_NORMAL
- en: The input streams are used for reading operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output streams are used for writing operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Stream` class is an abstract class in C# that enables common operations
    regarding this byte flow. For file handling on a hard disk, you will use the `FileStream`
    class, designed specifically for this purpose. The following are two important
    properties of this class: `FileAccess` and `FileMode`.'
  prefs: []
  type: TYPE_NORMAL
- en: FileAccess
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is an `enum` that provides you with options to choose a level of access
    when opening a specified file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Read`: This opens a file in read-only mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadWrite`: This opens a file in read and write mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Write`: This opens a file in write-only mode. This is rarely used, as you
    usually do some reading along with the writing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FileMode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is an `enum` that specifies the operations that can be performed on a
    file. It should be used along with the access mode as some modes only work with
    some levels of access. Take a look at the options, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Append`: Use this when you want to add content at the end of the file. If
    the file does not exist, a new one will be created. For this operation, the file
    must have write permission; otherwise, any attempt to read fails and throws a
    `NotSupportedException` exception. Exceptions are an important concept that will
    be covered later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Create`: Use this to create a new file or overwrite an existing one. For this
    option, too, write permission is required. In Windows, if the file exists but
    is hidden, an `UnauthorizedAccessException` exception is thrown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateNew`: This is like `Create` but is used to create new files and also
    requires write permission. However, if the file already exists, an `IOException`
    exception is thrown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Open`: As the name suggests, this mode is used to open a file. The file must
    have read or read and write permissions. If the file does not exist, a `FileNotFoundException`
    exception is thrown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OpenOrCreate`: This is like `Open`, except it creates a new file if it does
    not already exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 1.11: Reading Content from Text Files'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will read text from a Comma-Separated Values (CSV) file.
    CSV files simply contain data represented by strings and separated either by colons
    or semicolons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Command Prompt and type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'At the `Exercise1_11` project folder location in your computer, create a file
    named `products.csv` and paste the following content inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `Program.cs` file and replace its contents with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Call `dotnet run` in Command Prompt and you will get an output that is the same
    as the contents of the CSV file you have created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/5flid](https://packt.link/5flid).
  prefs: []
  type: TYPE_NORMAL
- en: This exercise has some pretty interesting outcomes, which you are going to learn
    step by step. First, you opened a file using the `FileStream` class. This allows
    you to start streaming bytes from a file with two special properties, namely,
    `FileMode` and `FileAccess`. It will return a `StreamReader` class. This class
    enables you to read these bytes as text characters.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that your `Main` method changed from `void` to `async` Task. Additionally,
    the `await` keyword has been used, which is used for asynchronous operations.
    You will learn more about these topics in upcoming chapters. For now, you only
    need to know that an async operation is something that does not block the program
    execution. This means that you can output lines as they are being read; that is,
    you do not have to wait for all of them to be read.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, learn about the special keyword that handles files, databases,
    and network connections.
  prefs: []
  type: TYPE_NORMAL
- en: Disposable Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another special thing about the preceding exercise was the `using` keyword.
    It is a keyword used to clean up unmanaged resources from memory. These resources
    are special objects that handle some operational system resources, such as files,
    databases, and network connections. They are called **special** because they do
    what is called I/O operations; that is, they interact with the real resources
    of the machine, such as network and hard drives, not just with memory spaces.
  prefs: []
  type: TYPE_NORMAL
- en: The memory used by objects in C# is handled by something called the garbage
    collector. By default, C# handles the memory space in the stack and the heap. The
    only types of objects that do not perform this cleanup are called unmanaged objects.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning these objects from memory means that the resources will be free to
    be used by another process in the computer. That means a file can be handled by
    another one, a database connection is free to be used again by a connection pool,
    and so on. Those types of resources are called disposable resources. Every time
    you deal with a disposable resource, you can use the `using` keyword when creating
    an object. Then, the compiler knows that when the `using` statement closes, it
    can automatically free these resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.12: Writing to a Text File'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will write some text into a CSV file, again using the
    `FileStream` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the VS Code integrated terminal and type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: At a preferred location on your computer, copy the `products.csv` file from
    the previous exercise and paste it into this exercise's folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, create a method named `ReadFile` that will receive a `FileStream`
    file and iterate over the file lines to output the result to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in your program, open the `products.csv` file with `StreamWriter` and
    add some more information to it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, read the contents of the file after modification:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Call `dotnet run --project Exercise1_12` in the VS Code integrated terminal
    and you will be able to see the contents of the CSV file you just created, in
    addition to the line you just appended:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Note that for each run, the program will append a new line, so you will see
    more lines being added.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/dUk2z](https://packt.link/dUk2z).
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes your program will fail to execute at some point and may not provide
    an output. Such an instance is called an exception error. The next section details
    all about such an error.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exceptions indicate that a program has failed to execute at some point for
    some reason and can be raised by either the code itself or the .NET runtime. Usually,
    an exception is a severe failure and can even terminate your program''s execution.
    Fortunately, C# provides a special way of handling exceptions, which is `try/catch` blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `try` clause, you call the code that might throw an exception, and
    inside the `catch` clause, you can treat the exception that was raised. For instance,
    consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: This method takes two integers and returns the result of a division between
    them. However, what will happen if `b` is `0`? In such a case, the runtime will
    throw `System.DivideByZeroException`, indicating that it is not possible to execute
    the division. How could you handle this exception in a real-world program? You
    will explore this in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.13: Handling Invalid User Inputs with try/catch'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will create a console app that takes two inputs from you,
    divides the first number by the second one, and outputs the result. If you enter
    an invalid character, the app should throw an exception, and all of this should
    be handled inside the program logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the VS Code integrated terminal, create a new console app called `Exercise1_13`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the following method inside the `Program.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a Boolean variable to indicate whether the division was properly
    executed. Assign `false` to it as its initial value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a `while` loop that will check whether the division happened successfully.
    If it did, the program should terminate. If not, the program should prompt you
    to input valid data and perform the division again. Add the following code to
    do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, execute the program using the `dotnet run` command and interact with
    the console. Try to insert strings instead of numbers and see what output you
    get. Look at the following output as an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/EVsrJ](https://packt.link/EVsrJ).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you handled two types of exceptions that are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `int.Parse(string str)` method throws `System.FormatException` if it is
    not possible to convert the `string` variable into an integer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `double Divide(int a, int b)` method throws `System.DivideByZeroException`
    if b is 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you have seen how exceptions are handled, it is important to note
    a rule of thumb that will help you in your C# journey, which is that *you should
    only catch what you can or what you need to handle*. There are only a few situations
    where exception handling is really needed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When you want to **mask** an exception, that is, catch it and pretend that nothing
    happened. This is known as exception suppression. That should take place when
    the exception that is thrown does not impact the flow of your program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to control your program's execution flow to perform some alternate
    actions, as you did in the preceding exercise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to catch a type of exception to throw it as another type. For
    instance, when communicating with your web API, you might see an exception of
    type `HttpException` that indicates that the destination is unreachable. You could
    make use of a custom exception here, such as `IntegrationException`, to indicate
    more clearly that it happened in a part of your application that performs some
    integrations with external APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `throw` keyword can also be used to intentionally stop the program execution
    flow in certain cases. For example, consider that you are creating a `Person`
    object and that the `Name` property should not be `null` at the time of creation.
    You can enforce on this class a `System.ArgumentException` or `System.ArgumentNullException`,
    as in the following snippet, which uses `ArgumentNullException` to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Here, if the value of the `name` argument is `null` or if you only enter space
    characters, `ArgumentNullException` is thrown, and the program does not execute
    successfully. The null/white space condition is checked with the help of the `IsNullOrWhiteSpace`
    function, which can be used for string variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to practice all that you learned in the previous sections through
    an activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1.01: Creating a Guessing Game'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this activity, you need to create a guessing game using the concepts you
    have learned about and practiced so far in this chapter. In this game, first,
    a random number from one to 10 must be generated, not to be output to the console.
    The console should then prompt the user to input a number and then guess which
    random number has been generated, and the user should get a maximum of five chances.
  prefs: []
  type: TYPE_NORMAL
- en: Upon every incorrect input, a warning message should be displayed, letting the
    user know how many chances they have left, and if all five chances are exhausted
    with incorrect guesses, the program terminates. However, once the user guesses
    correctly, a success message should be displayed, before the program terminates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a variable called `numberToBeGuessed` that is assigned to a random number
    within C#. You can use the following snippet to do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: This generates a random number for you, between `0` and `10`. You could replace
    `10` with a higher number if you wanted to make the game a little more difficult,
    or with a smaller number to make it easier, but for this activity, you will use
    `10` as the maximum value.
  prefs: []
  type: TYPE_NORMAL
- en: Create a variable called `remainingChances` that will store the remaining number
    of chances that the user has.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `numberFound` variable and assign a `false` value to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, create a `while` loop that will execute while there are still some chances
    remaining. Within this loop, add code to output the number of chances remaining,
    until the correct guess is made. Then, create a variable called `number` that
    will receive the `number` variable is the correct guess, and assign the value
    `true` to the `numberFound` variable if so. If not, the number of remaining chances
    should be reduced by `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, add code to inform users whether they have guessed the number correctly.
    You can output something such as `Congrats! You've guessed the number with {remainingChanges}
    chances left!` if they guessed correctly. If they ran out of chances, output `You're
    out of chances. The number was {numberToBeGuessed}.`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter gave you an overview of the fundamentals of C# and what it looks
    like to write programs with it. You explored everything from the variable declaration,
    data types, and basic arithmetic and logical operators to file and exception handling.
    You also explored how C# allocates memory while dealing with value and reference
    types.
  prefs: []
  type: TYPE_NORMAL
- en: In the exercises and activities in this chapter, you were able to solve some
    real-world problems and think of solutions that can be implemented with this language
    and its resources. You learned how to prompt for user inputs in console apps,
    how to handle files within a system, and finally, how to deal with unexpected
    inputs through exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover the essentials of Object-oriented programming, diving
    deeper into the concept of classes and objects. You will also learn about the
    importance of writing clean, concise code that is easy to maintain, and the principles you
    can follow for writing such code.
  prefs: []
  type: TYPE_NORMAL

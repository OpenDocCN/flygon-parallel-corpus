- en: 3\. Delegates, Events, and Lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how delegates are defined and invoked, and you
    will explore their wide usage across the .NET ecosystem. With this knowledge,
    you will move on to the inbuilt `Action` and `Func` delegates to discover how
    their usage reduces unnecessary boilerplate code. You will then see how multicast
    delegates can be harnessed to send messages to multiple parties, and how events
    can be incorporated into event-driven code. Along the way, you will discover some
    common pitfalls to avoid and best practices to follow that prevent a great application
    from turning into an unreliable one.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will demystify the lambda syntax style and show how it can be used
    effectively. By the end of the chapter, you will be able to use the lambda syntax
    comfortably to create code that is succinct, as well as easy to grasp and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned some of the key aspects of Object Oriented
    Programming (OOP). In this chapter, you will build on this by looking at the common
    patterns used specifically in C# that enable classes to interact.
  prefs: []
  type: TYPE_NORMAL
- en: Have you found yourself working with a code that has to listen to certain signals
    and act on them, but you cannot be sure until runtime what those actions should
    be? Maybe you have a block of code that you need to reuse or pass to other methods
    for them to call when they are ready. Or, you may want to filter a list of objects,
    but need to base how you would do that on a combination of user preferences. Much
    of this can be achieved using interfaces, but it is often more efficient to create
    chunks of code that you can then pass to other classes in a type-safe way. Such
    blocks are referred to as delegates and form the backbone of many .NET libraries,
    allowing methods or pieces of code to be passed as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The natural extension to a delegate is the event, which makes it possible to
    offer a form of optional behavior in software. For example, you may have a component
    that broadcasts live news and stock prices, but unless you provide a way to opt
    into these services, you may limit the usability of such a component.
  prefs: []
  type: TYPE_NORMAL
- en: User Interface (UI) apps often provide notifications of various user actions,
    for example, keypresses, swiping a screen, or clicking a mouse button; such notifications
    follow a standard pattern in C#, which will be discussed fully in this chapter.
    In such scenarios, the UI element detecting such actions is referred to as a publisher,
    whereas the code that acts upon those messages is called a subscriber. When brought
    together, they form an event-driven design referred to as the publisher-subscriber,
    or pub-sub, pattern. You will see how this can be used in all types of C#. Remember
    that its usage is not just the exclusive domain of UI applications.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will learn about lambda statements and lambda expressions, collectively
    known as lambdas. These have an unusual syntax, which can initially take a while
    to become comfortable with. Rather than having lots of methods and functions scattered
    within a class, lambdas allow for smaller blocks of code that are often self-contained
    and located within close proximity to where they are used in the code, thereby
    offering an easier way to follow and maintain code. You will learn about lambdas
    in detail in the latter half of this chapter. First, you will learn about delegates.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The .NET delegate is similar to function pointers found in other languages,
    such as C++; in other words, it is like a pointer to a method to be invoked at
    runtime. In essence, it is a placeholder for a block of code, which can be something
    as simple as a single statement or a full-blown multiline code block, complete
    with complex branches of execution, that you ask other code to execute at some
    point in time. The term delegate hints at some form of **representative**, which
    is precisely what this placeholder concept relates to.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates allow for minimum coupling between objects, and much less code. There
    is no need to create classes that are derived from specific classes or interfaces.
    By using a delegate, you are defining what a compatible method should look like,
    whether it is in a class or struct, static, or instance-based. The arguments and
    return type define this calling compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, delegates can be used in a callback fashion, which allows multiple
    methods to be wired up to a single publication source. They often require much
    less code and provide more features than found using an interface-based design.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how effective delegates can be. Suppose you have
    a class that searches for users by surname. It would probably look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You then need to extend this to include a search of the user''s login name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, you decide to add yet another search, this time by location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You start the searches with code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Can you see the pattern that is occurring every time? You are repeating the
    same code that iterates through the list of users, applying a Boolean condition
    (also known as a predicate) to find the first matching user.
  prefs: []
  type: TYPE_NORMAL
- en: The only thing that is different is that the predicate decides whether a match
    has been found. This is one of the common cases where delegates are used at a
    basic level. The `predicate` can be replaced with a delegate, acting as a placeholder,
    which is evaluated when required.
  prefs: []
  type: TYPE_NORMAL
- en: Converting this code to a delegate style, you define a delegate named `FindUser`
    (this step can be skipped as .NET contains a delegate definition that you can
    reuse; you will come to this later).
  prefs: []
  type: TYPE_NORMAL
- en: 'All you need is a single helper method, `Find`, which is passed a `FindUser`
    delegate instance. Find knows how to loop through the users, invoking the delegate
    passing in the user, which returns true or false for a match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code is kept together and is much more concise now. There
    is no need to cut and paste code that loops through the users, as that is all
    done in one place. For each type of search, you simply define a delegate once
    and pass it to `Find`. To add a new type of search, all you need to do is define
    it in a single statement line, rather than copying at least eight lines of code
    that repeat the looping function.
  prefs: []
  type: TYPE_NORMAL
- en: The lambda syntax is a fundamental style used to define method bodies, but its
    strange syntax can prove to be an obstacle at first. At first glance, lambda expressions
    can look odd with their `=>` style, but they do offer a cleaner way to specify
    a target method. The act of defining a lambda is similar to defining a method;
    you essentially omit the method name and use `=>` to prefix a block of code.
  prefs: []
  type: TYPE_NORMAL
- en: You will now look at another example, using interfaces this time. Consider that
    you are working on a graphics engine and need to calculate the position of an
    image onscreen each time the user rotates or zooms in. Note that this example
    skips any complex math calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that you need to transform a `Point` class using the `ITransform`
    interface with a single method named `Move`, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user rotates an object, you need to use `RotateTransform`, and for
    a zoom operation, you will use `ZoomTransform`, as follows. Both are based on
    the `ITransform` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So, given these two classes, a point can be transformed by creating a new `Transform`
    instance, which is passed to a method named `Calculate`, as shown in the following
    code. `Calculate` calls the corresponding `Move` method, and does some extra unspecified
    work on point, before returning point to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is a standard class and interface-based design, but you can see that you
    have made a lot of effort to create new classes with just a single numeric value
    from a `Move` method. It is a worthwhile idea to have the calculations broken
    down into an easy-to-follow implementation. After all, it could have led to a
    future maintenance problem if implemented in a single method with multiple if-then
    branches.
  prefs: []
  type: TYPE_NORMAL
- en: By re-implementing a delegate-based design, you still have maintainable code,
    but much less of it to look after. You can have a `TransformPoint` delegate and
    a new `Calculate` function that can be passed a `TransformPoint` delegate.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can invoke a delegate by appending brackets around its name and passing
    in any arguments. This is similar to how you would call a standard class-level
    function or method. You will cover this invocation in more detail later; for now,
    consider the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You still need the actual target `Rotate` and `Zoom` methods, but you do not
    have the overhead of creating unnecessary classes to do this. You can add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, calling the method delegates is as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice how using delegates in this way helps eliminate a lot of unnecessary
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/AcwZA](https://packt.link/AcwZA).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to invoking a single placeholder method, a delegate also contains
    extra plumbing that allows it to be used in a **multicast** manner, that is, a
    way to chain multiple target methods together, each being invoked one after the
    other. This is often referred to as an invocation list or delegate chain and is
    initiated by code that acts as a publication source.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example of how this multicast concept applies can be seen in UIs.
    Imagine you have an application that shows the map of a country. As the user moves
    their mouse over the map, you may want to perform various actions, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the mouse pointer to a different shape while over a building.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing a tooltip that calculates the real-world longitude and latitude coordinates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing a message in a status bar that calculates the population of the area
    where the mouse is hovering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To achieve this, you would need some way to detect when the user moves the mouse
    over the screen. This is often referred to as the publisher. In this example,
    its sole purpose is to detect mouse movements and publish them to anyone who is
    listening.
  prefs: []
  type: TYPE_NORMAL
- en: To perform the three required UI actions, you would create a class that has
    a list of objects to notify when the mouse position changes, allowing each object
    to perform whatever activity it needs, in isolation from the others. Each of these
    objects is referred to as a subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: 'When your publisher detects that the mouse has moved, you follow this pseudo
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This assumes that `subscriptionList` is a list of objects, perhaps based on
    an interface with the `OnMouseMoved` method. It is up to you to add code that
    enables interested parties to subscribe to and unsubscribe from the `OnMouseMoved`
    notifications. It would be an unfortunate design if code that has previously subscribed
    has no way to unsubscribe and gets called repeatedly when there is no longer any
    need for it to be called.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, there is a fair amount of coupling between the publisher
    and subscribers, and you are back to using interfaces for a type-safe implementation.
    What if you then needed to listen for keypresses, both key down and key up? It
    would soon get quite frustrating having to repeatedly copy such similar code.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the delegate type contains all this as inbuilt behavior. You can
    use single or multiple target methods interchangeably; all you need to do is invoke
    a delegate and the delegate will handle the rest for you.
  prefs: []
  type: TYPE_NORMAL
- en: You will take an in-depth look at multicast delegates shortly, but first, you
    will explore the single-target method scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Custom Delegate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Delegates are defined in a way that is similar to that of a standard method.
    The compiler does not care about the code in the body of a target method, only
    that it can be invoked safely at some point in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `delegate` keyword is used to define a delegate, using the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following list describes each component of this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scope: An access modifier, such as `public`, `private`, or `protected`, to
    define the scope of the delegate. If you do not include a modifier, the compiler
    will default to marking it as private, but it is always better to be explicit
    in showing the intent of your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `delegate` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Return type: If there is no return type, `void` is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Delegate name: This can be anything that you like, but the name must be unique
    within the namespace. Many naming conventions (including Microsoft''s) suggest
    adding `Handler` or `EventHandler` to your delegate''s name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arguments, if required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Delegates can be nested within a class or namespace; they can also be defined
    within the global namespace, although this practice is discouraged. When defining
    classes in C#, it is common practice to define them within a parent namespace,
    typically based on a hierarchical convention that starts with the company name,
    followed by the product name, and finally the feature. This helps to provide a
    more unique identity to a type.
  prefs: []
  type: TYPE_NORMAL
- en: By defining a delegate without a namespace, there is a high chance that it will
    clash with another delegate with the same name if it is also defined in a library
    without the protection of a namespace. This can cause the compiler to become confused
    as to which delegate you are referring to.
  prefs: []
  type: TYPE_NORMAL
- en: In earlier versions of .NET, it was common practice to define custom delegates.
    Such code has since been replaced with various inbuilt .NET delegates, which you
    will look at shortly. For now, you will briefly cover the basics of defining a
    custom delegate. It is worthwhile know about this if you maintain any legacy C#
    code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will create a custom delegate, one that is passed
    a `DateTime` parameter and returns a Boolean to indicate validity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.01: Defining and Invoking Custom Delegates'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Say you have an application that allows users to order products. While filling
    in the order details, the customer can specify an order date and a delivery date,
    both of which must be validated before accepting the order. You need a flexible
    way to validate these dates. For some customers, you may allow weekend delivery
    dates, while for others, it must be at least seven days away. You may also allow
    an order to be back-dated for certain customers.
  prefs: []
  type: TYPE_NORMAL
- en: You know that delegates offer a way to vary an implementation at runtime, so
    that is the best way to proceed. You do not want multiple interfaces, or worse,
    a complex jumble of `if-then` statements, to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the customer''s profile, you can create a class named `Order`,
    which can be passed different date validation rules. These rules can be validated
    by a `Validate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder called `Chapter03`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change to the `Chapter03` folder and create a new console app, called `Exercise01`,
    using the CLI `dotnet` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `Chapter03\Exercise01.csproj` and replace the contents with these settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Open `Exercise01\Program.cs` and clear the contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preference for using namespaces to prevent a clash with objects from other
    libraries was mentioned earlier, so to keep things isolated, use `Chapter03.Exercise01`
    as the namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To implement your date validation rules, you will define a delegate that takes
    a single `DateTime` argument and returns a Boolean value. You will name it `DateValidationHandler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you will create a class named `Order`, which contains details of the
    order and can be passed to two date validation delegates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice how you have declared two read-only, class-level instances of `DateValidationHandler`,
    one to validate the order date and a second to validate the delivery date. This
    design assumes that the date validation rules are not going to be altered for
    this `Order` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the constructor, you pass the two delegates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this design, a different class is typically responsible for deciding which
    delegates to use, based on the selected customer's profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to add the two date properties that are to be validated. These dates
    may be set using a UI that listens to keypresses and applies user edits directly
    to this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add an `IsValid` method that passes `OrderDate` to the `orderDateValidator`
    delegate and `DeliveryDate` to the `deliveryDateValidator` delegate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If both are valid, then this call will return `true`. The key here is that
    `Order` doesn''t need to know about the precise implementation of an individual
    customer''s date validation rules, so you can easily reuse `Order` elsewhere in
    a program. To invoke a delegate, you simply wrap any arguments in brackets, in
    this case passing the correct date property to each delegate instance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a console app to test this, add a `static` class called `Program`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You want to create two functions that validate whether the date passed to them
    is valid. These functions will form the basis of your delegate target methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice how both have the exact signature that the `DateValidationHandler` delegate
    is expecting. Neither is aware of the nature of the date that they are validating,
    as that is not their concern. They are both marked `static` as they do not interact
    with any variables or properties anywhere in this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the `Main` entry point. Here, you create two `DateValidationHandler`
    delegate instances, passing `IsPastDate` to one and `IsWeekendDate` to the second.
    These are the target methods that will get called when each of the delegates is
    invoked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can create an `Order` instance, passing in the delegates and setting
    the order and delivery dates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There are various ways to create delegates. Here, you have assigned them to
    variables first to make the code clearer (you will cover different styles later).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s just a case of displaying the dates in the console and calling `IsValid`,
    which, in turn, will invoke each of your delegate methods once. Notice that a
    custom date format is used to make the dates more readable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the console app produces output like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This order is **not** valid as the delivery date is a Thursday, not a weekend
    as you require:'
  prefs: []
  type: TYPE_NORMAL
- en: You have learned how to define a custom delegate and have created two instances
    that make use of small helper functions to validate dates. This gives you an idea
    of how flexible delegates can be.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/cmL0s](https://packt.link/cmL0s).
  prefs: []
  type: TYPE_NORMAL
- en: The Inbuilt Action and Func Delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you define a delegate, you are describing its signature, that is, the
    return type and a list of input parameters. With that said, consider these two
    delegates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'They both have the same signature but vary by name alone, which is why you
    can declare an instance of each and have them **both** point at the **same** target
    method when invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the console app produces the same results in both calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/r6B8n](https://packt.link/r6B8n).
  prefs: []
  type: TYPE_NORMAL
- en: It would be great if you could dispense with defining both `DoStuff` and `DoMoreStuff`
    delegates and use a more generalized delegate with precisely the same signature.
    After all, it does not matter in the preceding snippet if you create a `DoStuff`
    or `DoMoreStuff` delegate, since both make a call to the same target method.
  prefs: []
  type: TYPE_NORMAL
- en: .NET does, in fact, provide various inbuilt delegates that you can make use
    of directly, saving you the effort of defining such delegates yourself. These
    are the `Action` and `Func` delegates.
  prefs: []
  type: TYPE_NORMAL
- en: There are many possible combinations of `Action` and `Func` delegates, each
    allowing an increasing number of parameters. You can specify anywhere from zero
    to 16 different parameter types. With so many combinations available, it is extremely
    unlikely that you will ever need to define your own delegate type.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that `Action` and `Func` delegates were added in a later
    version of .NET and, as such, the use of custom delegates tends to be found in
    older legacy code. There is no need to create new delegates yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, `MyMethod` is invoked using the three-argument `Func`
    variation; you will cover the odd-looking `<string, int, string>` syntax shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the same return value as the two earlier invocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Before you continue exploring `Action` and `Func` delegates, it is useful to
    explore the `Action<string, int, string>` syntax a bit further. This syntax allows
    type parameters to be used to define classes and methods. These are known as generics
    and act as placeholders for a particular type. In *Chapter 4*, *Data Structures
    and LINQ*, you will cover generics in much greater detail, but it is worth summarizing
    their usage here with the `Action` and `Func` delegates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The non-generic version of the `Action` delegate is predefined in .NET as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you know from your earlier look at delegates, this is a delegate that does
    not take any arguments and does not have a return type; it is the simplest type
    of delegate available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrast that with one of the generic `Action` delegates predefined in .NET:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see this includes a `<T>` and `T` parameter section, which means it
    accepts a `Action` that is constrained to a string, which takes a single string
    argument and returns no value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'How about an `int` constrained version? This also has no return type and takes
    a single `int` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Can you see the pattern here? In essence, the type that you specify can be used
    to declare a type at compile time. What if you wanted two arguments, or three,
    or four…or 16? Simple. There are `Action` and `Func` generic types that can take
    up to **16** different argument types. You are very unlikely to be writing code
    that needs more than 16 parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'This two-argument `Action` takes `int` and `string` as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can spin that around. Here is another two-argument `Action`, but this takes
    a `string` parameter and then an `int` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: These cover most argument combinations, so you can see that it is very rare
    to create your own delegate types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same rules apply to delegates that return a value; this is where the `Func`
    types are used. The generic `Func` type starts with a single value type parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, `funcE` is a delegate that returns a Boolean value
    and takes no arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Can you guess which is the return type from this rather long `Func` declaration?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives a delegate that returns a `string` . In other words, the last argument
    type in a `Func` defines the return type. Notice that `funcF` takes four arguments:
    `bool`, `int`, `int`, and `DateTime`.'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, generics are a great way to define types. They save a lot of duplicate
    code by allowing type parameters to act as placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning Delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You covered creating custom delegates and briefly how to assign and invoke a
    delegate in *Exercise 3.01*. You then looked at using the preferred `Action` and
    `Func` equivalents, but what other options do you have for assigning the method
    (or methods) that form a delegate? Are there other ways to invoke a delegate?
  prefs: []
  type: TYPE_NORMAL
- en: Delegates can be assigned to a variable in much the same way that you might
    assign a class instance. You can also pass new instances or static instances around
    without having to use variables to do so. Once assigned, you can invoke the delegate
    or pass the reference to other classes so they can invoke it, and this is often
    done within the Framework API.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will now look at a `Func` delegate, which takes a single `DateTime` argument
    and returns a `bool` value to indicate validity. You will use a `static` class
    containing two helper methods, which form the actual target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/mwmxh](https://packt.link/mwmxh).
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `DateValidators` class is marked as `static`. You may have heard
    the phrase **statics are inefficient**. In other words, creating an application
    with many static classes is a weak practice. Static classes are instantiated the
    first time they are accessed by running code and remain in memory until the application
    is closed. This makes it difficult to control their lifetime. Defining small utility
    classes as static is less of an issue, provided they do indeed remain stateless.
    Stateless means they do not set any local variables. Static classes that set local
    states are very difficult to unit test; you can never be sure that the variable
    set is from one test or another test.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding snippet, `IsFuture` returns `true` if the `Date` property of
    the `DateTime` argument is later than the current date. You are using the static
    `DateTime.Today` property to retrieve the current system date. `IsWeekend` is
    defined using an expression-bodied syntax and will return `true` if the `DateTime`
    argument's day of the week falls on a Saturday or Sunday.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can assign delegates the same way that you would assign regular variables
    (remember you do `futureValidator` and `weekendValidator`. Each constructor is
    passed the actual target method, the `IsFuture` or `IsWeekend` instance, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that it is not valid to use the `var` keyword to assign a delegate without
    wrapping in the `Func` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Taking this knowledge of delegates, proceed to how you can invoke a delegate.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking a Delegate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several ways to invoke a delegate. For example, consider the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To invoke `futureValidator`, you must pass in a `DateTime` value, and it will
    return a `bool` value using any of these styles:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoke with the null-coalescing operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This is the preferred and safest approach; you should always check for a null
    before calling `Invoke`. If there is a chance that a delegate does not point to
    an object in memory, then you must perform a null reference check before accessing
    methods and properties. A failure to do so will result in `NullReferenceException`
    being thrown. This is the runtime's way of warning you that the object is not
    pointing at anything.
  prefs: []
  type: TYPE_NORMAL
- en: By using the null-coalescing operator, the compiler will add the null check
    for you. In the code, you explicitly declared `futureValidator`, so here it cannot
    be null. But what if you had been passed `futureValidator` from another method?
    How can you be sure that the caller had correctly assigned a reference?
  prefs: []
  type: TYPE_NORMAL
- en: Delegates have additional rules that make it possible for them to throw `NullReferenceException`
    when invoked. In the preceding example, `futureValidator` has a single target,
    but as you will see later, the `NullReferenceException`.
  prefs: []
  type: TYPE_NORMAL
- en: Direct Invoke
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the same as the previous method, but without the safety of the null
    check. This is not recommended for the same reason; that is, the delegate can
    throw a `NullReferenceException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Without the `Invoke` prefix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This looks more succinct as you simply call the delegate without the `Invoke`
    prefix. Again, this is not recommended due to a possible null reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Try assigning and safely invoking a delegate through an exercise by bringing
    them together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.02: Assigning and Invoking Delegates'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you are going to write a console app showing how a `Func`
    delegate can be used to extract numeric values. You will create a `Car` class
    that has `Distance` and `JourneyTime` properties. You will prompt the user to
    enter the distance traveled yesterday and today, passing this information to a
    `Comparison` class that is told how to extract values and calculate their differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change to the `Chapter03` folder and create a new console app, called `Exercise02`,
    using the CLI `dotnet` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `Chapter03\Exercise02.csproj` and replace the entire file with these settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Open `Exercise02\Program.cs` and clear the contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start by adding a record called `Car`. Include the `System.Globalization` namespace
    for string parsing. Use the `Chapter03.Exercise02` namespace to keep code separate
    from the other exercises.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add two properties, `Distance` and `JourneyTime`. They will have `init`-only
    properties, so you will use the `init` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a class named `Comparison` that is passed a `Func` delegate to
    work with. The `Comparison` class will use the delegate to extract either the
    `Distance` or `JourneyTime` properties and calculate the difference for two `Car`
    instances. By using the flexibility of delegates, `Comparison` will not know whether
    it is extracting `Distance` or `JourneyTime`, just that it is using a double to
    calculate the differences. This shows that you can reuse this class should you
    need to calculate other `Car` properties in the future:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Add three properties that form the results of the calculation, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the calculation, pass two `Car` instances, one for the car journey
    yesterday, `yesterdayCar`, and one for today, `todayCar`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate a value for `Yesterday`, invoke the `valueSelector` `Func` delegate,
    passing in the `yesterdayCar` instance. Again, remember that the `Comparison`
    class is unaware whether it is extracting `Distance` or `JourneyTime`; it just
    needs to know that when the `delegate` is invoked with a `Car` argument, it will
    get a double number back:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Do the same to extract the value for `Today` by using the same `Func` delegate,
    but passing in the `todayCar` instance instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it is just a case of calculating the difference between the two extracted
    numbers; you don''t need to use the `Func` delegate to do that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'So, you have a class that knows how to invoke a `Func` delegate to extract
    a certain `Car` property when it is told how to. Now, you need a class to wrap
    up the `Comparison` instances. For this, add a class called `JourneyComparer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'For the car journey, you need to calculate the difference between the `Yesterday`
    and `Today` `Distance` properties. To do so, create a `Comparison` class that
    is told how to extract a value from a `Car` instance. You may as well use the
    same name for this `Comparison` class as you will extract a car''s `Distance`.
    Remember that the `Comparison` constructor needs a `Func` delegate that is passed
    a `Car` instance and returns a double value. You will add `GetCarDistance()` shortly;
    this will eventually be invoked by passing `Car` instances for yesterday''s and
    today''s journeys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeat the process as described in the preceding steps for a `JourneyTime`
    `Comparison`; this one should be told to use `GetCarJourneyTime()` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add another `Comparison` property called `AverageSpeed` as follows.
    You will see shortly that `GetCarAverageSpeed()` is yet another function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the `GetCarDistance` and `GetCarJourneyTime` local functions, they
    are passed a `Car` instance and return either `Distance` or `JourneyTime` accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`GetCarAverageSpeed`, as the name suggests, returns the average speed. Here,
    you have shown that the `Func` delegate just needs a compatible function; it doesn''t
    matter what it returns as long as it is `double`. The `Comparison` class does
    not need to know that it is returning a calculated value such as this when it
    invokes the `Func` delegate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The three `Comparison` properties should be defined like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the main `Compare` method. This will be passed two `Car` instances,
    one for `yesterday` and one for `today`, and it simply calls `Compare` on the
    three `Comparison` items passing in the two `Car` instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'You need a console app to enter the miles traveled per day, so add a class
    called `Program` with a static `Main` entry point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'You can randomly assign journey times to save some input, so add a new `Random`
    instance and the start of a `do-while` loop, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Read for yesterday''s distance, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the distance to create yesterday''s `Car` with a random `JourneyTime`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Do the same for today''s distance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have two `Car` instances populated with values for yesterday and
    today, you can create the `JourneyComparer` instance and call `Compare`. This
    will then call `Compare` on your three `Comparison` instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, write the results to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Write out yesterday''s results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Write out today''s results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, write the summary values using the `Difference` properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Finish off the `do-while` loop, exiting if the user enters an empty string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the console and entering distances of `1000` and `900` produces the
    following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The program will run in a loop until you enter a blank value. You will notice
    a different output as the `JourneyTime` is set using a random value returned by
    an instance of `Random` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/EJTtS](https://packt.link/EJTtS).
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have seen how a `Func<Car, double>` delegate is used to
    create general-purpose code that can be easily reused without the need to create
    extra interfaces or classes.
  prefs: []
  type: TYPE_NORMAL
- en: Now it is time to look at the second important aspect of deletes and their ability
    to chain multiple target methods together.
  prefs: []
  type: TYPE_NORMAL
- en: Multicast Delegates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you have invoked delegates that have a single method assigned, typically
    in the form of a function call. Delegates offer the ability to combine a list
    of methods that are executed with a single invocation call, using the `+=` operator,
    any number of additional target methods can be added to the target list. Every
    time the delegate is invoked, each one of the target methods gets invoked too.
    But what if you decide you want to remove a target method? That is where the `-=`
    operator is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, you have an `Action<string>` delegate named
    `logger`. It starts with a single target method, `LogToConsole`. If you were to
    invoke this delegate, passing in a string, then the `LogToConsole` method will
    be called once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to watch the call stack, you would observe these calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a new target method, you use the `+=` operator. The following statement
    adds `LogToFile` to the `logger` delegate''s invocation list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, every time you invoke `logger`, both `LogToConsole` and `LogToFile` will
    be called. Now invoke `logger` a second time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The call stack looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, suppose you use `+=` to add a third target method called `LogToDataBase`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Now invoke it once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The call stack looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'However, consider that you may no longer want to include `LogToFile` in the
    target method list. In such a case, simply use the `-=` operator to remove it,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'You can again invoke the delegate as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, the call stack looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen, this code resulted in just `LogToConsole` and `LogToDataBase`.
  prefs: []
  type: TYPE_NORMAL
- en: By using delegates in this way, you can decide which target methods get called
    based on certain criteria at runtime. This allows you to pass this configured
    delegate into other methods, to be invoked as and when needed.
  prefs: []
  type: TYPE_NORMAL
- en: You have seen that `Console.WriteLine` can be used to write messages to the
    console window. To create a method that logs to a file (as `LogToFile` does in
    the preceding example), you need to use the `File` class from the `System.IO`
    namespace. `File` has many static methods that can be used to read and write files.
    You will not go into full details about `File` here, but it is worth mentioning
    the `File.AppendAllText` method, which can be used to create or replace a text
    file containing a string value, `File.Exists`, which is used to check for the
    existence of a file, and `File.Delete`, to delete a file.
  prefs: []
  type: TYPE_NORMAL
- en: Now it is time to practice what you have learned through an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.03: Invoking a Multicast Delegate'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will use a multicast delegate to create a cash machine
    that logs details when a user enters their PIN and asks to see their balance.
    For this, you will create a `CashMachine` class that invokes a configured **logging**
    delegate, which you can use as a controller class to decide whether messages are
    sent to the file or to the console.
  prefs: []
  type: TYPE_NORMAL
- en: You will use an `Action<string>` delegate as you do not need any values to return.
    Using `+=`, you can control which target methods get called when your delegate
    is invoked by `CashMachine`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change to the `Chapter03` folder and create a new console app, called `Exercise03`,
    using the CLI `dotnet` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `Chapter03\Exercise03.csproj` and replace the entire file with these settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Open `Exercise03\Program.cs` and clear the contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class called `CashMachine`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `Chapter03.Exercise03` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The `CashMachine` constructor is passed the `Action<string>` delegate, which
    you can assign to a `readonly` class variable called `_logger`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `Log` helper function that checks whether the `_logger` delegate is null
    before invoking:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `VerifyPin` and `ShowBalance` methods are called, a message should
    be logged with some details. Create these methods as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add a console app that configures a `logger` delegate that you can pass
    into a `CashMachine` object. Note that this is a common form of usage: a class
    that is responsible for deciding how messages are logged by other classes. Use
    a constant, `OutputFile`, for the filename to be used for file logging, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Each time the program runs, it should start with a `File.Delete` to delete
    the output file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a delegate instance, `logger`, that starts with a single target method,
    `LogToConsole`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `+=` operator, add `LogToFile` as a second target method to also
    be called whenever the delegate is invoked by `CashMachine`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'You will implement the two target logging methods shortly; for now, create
    a `cashMachine` instance and get ready to call its methods, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Prompt for a `pin` and pass it to the `VerifyPin` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: In case you enter a blank value, then it is checked and a warning is displayed.
    This will then close the program using a `return` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait for the `Enter` key to be pressed before calling the `ShowBalance` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the logging methods. They must be compatible with your `Action<string>`
    delegate. One writes a message to the console and the other appends it to the
    text file. Add these two static methods as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the console app, you see that `VerifyPin` and `ShowBalance` calls are
    written to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'For each `logger` delegate invocation, the `LogToFile` method will also be
    called, so when opening `activity.txt`, you should see the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/h9vic](https://packt.link/h9vic).
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that delegates are immutable, so each time you use
    the `+=` or `-=` operators, you create a **new** delegate instance. This means
    that if you alter a delegate after you have passed it to a target class, you will
    not see any changes to the methods called from inside that target class.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this in action in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'All objects in C# have a `GetHashCode()` function that returns a unique ID.
    Running the code produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the `+=` call. This shows that the object reference is changing
    each time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now look at another example using an `Action<string>` delegate. Here, you will
    use the `+=` operator to add target methods and then use `-=` to remove the target methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: You start with one target method, `LogToConsole`, and then add the same target
    method a second time. Invoking the logger delegate using `logger("Console x 2")`
    results in `LogToConsole` being called twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'You then use `-=` to remove `LogToConsole` **twice** such that had two targets
    and now you do not have any at all. Running the code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'However, rather than `logger("logger is now null")` running correctly, you
    end up with an unhandled exception being thrown like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: By removing the last target method, the `-=` operator returned a null reference,
    which you then assigned to the logger. As you can see, it is important to always
    check that a delegate is not null before trying to invoke it.
  prefs: []
  type: TYPE_NORMAL
- en: Multicasting with a Func Delegate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, you have used `Action<string>` delegates within `Action` delegates.
  prefs: []
  type: TYPE_NORMAL
- en: You have seen that `Func` delegates are used when a return value is required
    from an invoked delegate. It is also perfectly legal for the C# complier to use
    `Func` delegates in multicast delegates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example where you have a `Func<string, string>` delegate.
    This delegate supports functions that are passed a string and return a formatted
    string is returned. This could be used when you need to format an email address
    by removing the `@` sign and dot symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'You start by assigning the `RemoveDots` string function to `emailFormatter`
    and invoke it using the `Address` constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you add a second target, `RemoveAtSign`, and invoke `emailFormatter` a
    second time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The first invocation returns the `admin@googlecom` string. The `RemoveAtSign`
    added to the target list, returns a value with only the `@` symbol removed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/fshse](https://packt.link/fshse).
  prefs: []
  type: TYPE_NORMAL
- en: Both `Func1` and `Func2` are invoked, but only the value from `Func2` is returned
    to both `ResultA` and `ResultB` variables, even though the correct arguments are
    passed in. When a `Func<>` delegate is used with multicast in this manner, all
    of the target `Func` instances are called, but the return value will be that of
    the last `Func<>` in the chain. `Func<>` is better suited in a single method scenario,
    although the compiler will still allow you to use it as a multicast delegate without
    any compilation error or warning.
  prefs: []
  type: TYPE_NORMAL
- en: What Happens When Things Go Wrong?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a delegate is invoked, all methods in the invocation list are called. In
    the case of single-name delegates, this will be one target method. What happens
    in the case of multicast delegates if one of those targets throws an exception?
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code. When the `logger` delegate is invoked, by passing
    in `try log this`, you may expect the methods to be called in the order that they
    were added: `LogToConsole`, `LogToError`, and finally `LogToDebug`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: If any target method throws an exception, such as the one you see in `LogToError`,
    then the remaining targets are **not** called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the code results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: You will see this output because the `LogToDebug` method wasn't called at all.
    Consider a UI with multiple targets listening to a mouse button click. The first
    method fires when a button is pressed and disables the button to prevent double-clicks,
    the second method changes the button's image to indicate success, and the third
    method enables the button.
  prefs: []
  type: TYPE_NORMAL
- en: If the second method fails, then the third method will not get called, and the
    button could remain in a disabled state with an incorrect image assigned, thereby
    confusing the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that all target methods are run regardless, you can enumerate through
    the invocation list and invoke each method manually. Take a look at the .NET `MulticastDelegate`
    type. You will find that there is a function, `GetInvocationList`, that returns
    an array of the delegate objects. This array contains the target methods that
    have been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: You can then loop through those target methods and execute each one inside a
    `try`/`catch` block. Now practice what you learned through this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.04: Ensuring All Target Methods Are Invoked in a Multicast Delegate'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this chapter, you have been using `Action<string>` delegates to perform
    various logging operations. In this exercise, you have a list of target methods
    for a logging delegate and you want to ensure that "all" target methods are invoked
    even if earlier ones fail. You may have a scenario where logging to a database
    or filesystem fails occasionally, maybe due to network issues. In such a situation,
    you will want other logging operations to at least have a chance to perform their
    logging activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change to the `Chapter03` folder and create a new console app, called `Exercise04`,
    using the CLI `dotnet` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `Chapter03\Exercise04.csproj` and replace the entire file with these settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Open `Exercise04\Program.cs` and clear the contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now add a static `Program` class for your console app, including `System` and,
    additionally, `System.IO` as you want to create a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Use a `const` to name the logging file. This file is created when the program executes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you must define the app''s `Main` entry point. Here you delete the output
    file if it already exists. It is best to start with an empty file here, as otherwise,
    the log file will keep growing every time you run the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'You will start with `logger` having just one target method, `LogToConsole`,
    which you will add shortly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'You use the `InvokeAll` method to invoke the delegate, passing in `"First call"`
    as an argument. This will not fail as `logger` has a single valid method and you
    will add `InvokeAll` shortly, too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The aim of this exercise is to have a multicast delegate, so add some additional
    target methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Try a second call using `InvokeAll` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the target methods that were added to the delegate. Add the following
    code for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now implement the `InvokeAll` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: It is passed an `Action<string>` delegate that matches the `logger` delegate
    type, along with an `arg` string to use when invoking each target method. Before
    that though, it is important to check that `logger` is not already null and there
    is nothing you can do with a null delegate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the delegate''s `GetInvocationList()` method to get a list of all the target
    methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, loop through each item in the list as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'After wrapping each loop element in a `try`/`catch`, cast `del` into an `Action<string>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '`GetInvocationList` returns each item as the base delegate type regardless
    of their actual type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If it is the correct type and **not** null, then it is safe to try invoking:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: You have added some extra details to show what is about to be invoked by using
    the delegate's `Method.Name` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finish with a `catch` block that logs the error message if an error was caught:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code, creates a file called `Exercise04.txt` with the following results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: You will see that it catches the error thrown by `LogToDatabase` and still allows
    `LogToFile` to be called.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/Dp5H4](https://packt.link/Dp5H4).
  prefs: []
  type: TYPE_NORMAL
- en: It is now important to expand upon the multicast concept using events.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous sections, you have created delegates and invoked them directly
    in the same method or passed them to another method for it to invoke when needed.
    By using delegates in this way, you have a simple way for code to be notified
    when something of interest happens. So far, this has not been a major problem,
    but you may have noticed that there appears to be no way to prevent an object
    that has access to a delegate from invoking it directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following scenario: you have created an application that allows
    other programs to register for notifications when a new email arrives by adding
    their target method to a delegate that you have provided. What if a program, either
    by mistake or for malicious reasons, decides to invoke your delegate itself? This
    could quite easily overwhelm all the target methods in your invocation list. Such
    listener programs should never be allowed to invoke a delegate in this way—after
    all, they are meant to be passive listeners.'
  prefs: []
  type: TYPE_NORMAL
- en: You could add extra methods that allow listeners to add or remove their target
    methods from the invocation list and shield the delegate from direct access, but
    what if you have hundreds of such delegates available in an application? That
    is a great deal of code to write.
  prefs: []
  type: TYPE_NORMAL
- en: The `event` keyword instructs the C# complier to add extra code to ensure that
    a delegate can **only** be invoked by the class or struct that it is declared
    in. External code can add or remove target methods but is prevented from invoking
    the delegate. Attempting to do so results in a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is commonly known as the pub-sub pattern. The object raising an
    event is called the event sender or **publisher**; the object(s) receiving the
    event are called event handlers or **subscribers**.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an Event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `event` keyword is used to define an event and its associated delegates.
    Its definition looks similar to the way delegates are defined, but unlike delegates,
    you cannot use the global namespace to define events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Events have four elements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scope: An access modifier, such as `public`, `private`, or `protected`, to
    define the scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `event` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Delegate type: The associated delegate, `EventHandler` in this example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Event name: This can be anything you like, `MouseDoubleClicked`, for example.
    However, the name must be unique within the namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events are typically associated with the inbuilt .NET delegates, `EventHandler`,
    or its generic `EventHandler<>` version. It is rare to create custom delegates
    for events, but you may find this in older legacy code created prior to the `Action`
    and generic `Action<T>` delegates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EventHandler` delegate was available in early versions of .NET. It has
    the following signature, taking a sender `object` and an `EventArgs` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The more recent generic-based `EventHandler<T>` delegate looks similar; it
    also takes a sender `object` and a parameter defined by the type `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: The `sender` parameter is defined as `object`, allowing any type of object to
    be sent to subscribers for them to identify the sender of the event. This can
    be useful in a situation where you have a centralized method that needs to work
    on various types of objects rather than specific instances.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in a UI app, you may have one subscriber that listens for an OK
    button being clicked, and a second subscriber that listens for a **Cancel** button
    being clicked–each of these could be handled by two separate methods. In the case
    of multiple checkboxes used to toggle options on or off, you could use a single
    target method that simply needs to be told that a checkbox is the sender, and
    to toggle the setting accordingly. This allows you to reuse the same checkbox
    handler rather than creating a method for every checkbox on a screen.
  prefs: []
  type: TYPE_NORMAL
- en: It is not mandatory to include details of the sender when invoking an `EventHandler`
    delegate. Often, you may not want to divulge the inner workings of your code to
    the outside; in this case, it is common practice to pass a null reference to the
    delegate.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument in both delegates can be used to provide extra contextual
    information about the event (for example, was it the left or right mouse button
    that was pressed?). Traditionally, this extra information was wrapped up using
    a class derived from `EventArgs`, but that convention has been relaxed in newer
    .NET versions.
  prefs: []
  type: TYPE_NORMAL
- en: There are two standard .NET delegates you should for your event definition?
  prefs: []
  type: TYPE_NORMAL
- en: '`EventHandler`: This can be used when there is no extra information to describe
    the event. For example, a checkbox click event may not need any extra information,
    it was simply clicked. In this case, it is perfectly valid to pass null or `EventArgs.Empty`
    as the second parameter. This delegate can often be found in legacy apps that
    use a class derived from `EventArgs` to describe the event further. Was it a double-click
    of the mouse that triggered this event? In this case, a `Clicks` property may
    have been added to an `EventArgs` derived class to provide such extra details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventHandler<T>`: Since the inclusion of generics in C#, this has become the
    more frequently used delegate for events, simply because using generics requires
    fewer classes to be created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interestingly, no matter what scope you give to your event (`public`, for example),
    the C# compiler will internally create a private member with that name. This is
    the key concept with events: only the class that defines the event may **invoke
    it**. Consumers are free to add or remove their interest, but they **cannot**
    invoke it themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: When an event is defined, the publisher class in which it is defined can simply
    invoke it as and when needed, in the same way that you invoke delegates. In the
    earlier examples, a point was made of always checking that the delegate is not
    null before invoking. The same approach should be taken with events, as you have
    little control over how or when a subscriber may add or remove their target methods.
  prefs: []
  type: TYPE_NORMAL
- en: When a publisher class is initially created, all events have an initial value
    of null. This will change to not null when any subscriber adds a target method.
    Conversely, as soon as a subscriber removes a target method, the event will revert
    to null if there are no methods left in the invocation list and all this is handled
    by the runtime. This is the standard behavior you saw earlier with delegates.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can prevent an event from ever becoming null by adding an empty delegate
    to the end of the event definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Rather than having the default null value, you are adding your own default delegate
    instance—one that does nothing. Hence the blank between the `{}` symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a common pattern often followed when using events within a publisher
    class, particularly in classes that may be subclassed further. You will now see
    this with the help of a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a class, `MouseClickedEventArgs`, that contains additional information
    about the event, in this case, the number of mouse clicks that were detected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Observe the `MouseClickPublisher` class, This has a `MouseClicked` event defined
    using the generic `EventHandler<>` delegate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the `delegate { };` block to prevent `MouseClicked` from being null
    initially:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an `OnMouseClicked` virtual method that gives any further subclassed `MouseClickPublisher`
    classes a chance to suppress or change the event notification, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Now you need a method that tracks the mouse clicks. In this example, you will
    not actually show how mouse clicks are detected, but you will call `OnMouseClicked`,
    passing in `2` to indicate a double-click.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice how you have not invoked the `MouseClicked` event directly; you always
    go via the `OnMouseClicked` intermediary method. This provides a way for other
    implementations of `MouseClickPublisher` to override the event notification if
    they need to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add a new type of publisher that is based on `MouseClickPublisher`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: This `MouseSingleClickPublisher` overrides the `OnMouseClicked` method and only
    calls the base `OnMouseClicked` if a single click was detected. By implementing
    this type of pattern, you allow different types of publishers to control whether
    events are fired to subscribers in a customized manner.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/J1EiB](https://packt.link/J1EiB).
  prefs: []
  type: TYPE_NORMAL
- en: You can now practice what you learned through the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.05: Publishing and Subscribing to Events'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will create an alarm clock as an example of a publisher.
    The alarm clock will simulate a `Ticked` event. You will also add a `WakeUp` event
    that is published when the current time matches an alarm time. In .NET, `DateTime`
    is used to represent a point in time, so you will use that for the current time
    and alarm time properties. You will use `DateTime.Subtract` to get the difference
    between the current time and the alarm time and publish the `WakeUp` event when
    it is due.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change to the `Chapter03` folder and create a new console app, called `Exercise05`,
    using the CLI `dotnet` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `Chapter03\Exercise05.csproj` and replace the entire file with these settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Open `Exercise05\Program.cs` and clear the contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class called `AlarmClock`. Here you need to use a `DateTime` class,
    so include the `System` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: You will offer two events for subscribers to listen to—`WakeUp`, based on the
    non-generic `EventHandler` delegate (since you will not pass any extra information
    in this event), and `Ticked`, which uses the generic `EventHandler` delegate with
    a `DateTime` parameter type.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will use this to pass along the current time to display in the console.
    Notice that both have the initial `delegate {};` safety mechanism:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Include an `OnWakeUp` override as an example, but do not do the same with `Ticked`;
    this is to show the different invocation approaches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add two `DateTime` properties, the alarm and clock times, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Start` method is used to start the clock. You simulate a clock ticking once
    every minute for `24 hours` using a simple loop as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'For each simulated minute, increment the clock using `DateTime.AddMinute` and
    publish the `Ticked` event, passing in `this` (the `AlarmClock` sender instance)
    and the clock time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '`ClockTime.Subtract` is used to calculate the difference between the click
    and alarm times.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You pass the `timeRemaining` value to the local function, `IsTimeToWakeUp`,
    calling the `OnWakeUp` method and break out of the loop if it is time to wake
    up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `IsTimeToWakeUp`, a relational pattern, to see whether there is less
    than one minute remaining. Add the following code for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add a console app that subscribes to the alarm clock and its two events
    by starting from the static void `Main` entry point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `AlarmClock` instance and use the `+=` operator to subscribe to
    the `Ticked` event and the `WakeUp` events. You will define `ClockTicked` and
    `ClockWakeUp` shortly. For now, just add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the clock''s current time, use `DateTime.AddMinutes` to add `120` minutes
    to the alarm time, and then start the clock, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Finish off `Main` by prompting for the `Enter` key to be pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can add the event subscriber local methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '`ClockWakeUp` is passed sender and `EventArgs` arguments. You don''t use either
    of these, but they are required for the `EventHandler` delegate. When this subscriber''s
    method is called, you write `"Wake up"` to the console.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ClockTicked` is passed the `DateTime` argument as required by the `EventHandler<DateTime>`
    delegate. Here, you pass the current time, so you write that to the console using
    `:t` to show the time in a short format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the app produces this output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: In this example you see that the alarm clock simulates a tick every minute and
    publishes a `Ticked` event.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/GPkYQ](https://packt.link/GPkYQ).
  prefs: []
  type: TYPE_NORMAL
- en: Now it is time to grasp the difference between events and delegates.
  prefs: []
  type: TYPE_NORMAL
- en: Events or Delegates?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the face of it, events and delegates look remarkably similar:'
  prefs: []
  type: TYPE_NORMAL
- en: Events are an extended form of delegates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both offer **late-bound** semantics, so rather than calling methods that are
    known precisely at compile-time, you can defer a list of target methods when known
    at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both are `Invoke()` or, more simply, the `()` suffix shortcut, ideally with
    a null check before doing so.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The key considerations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionality: Events offer an optional approach; callers can decide to opt into
    events or not. If your component can complete its task without needing any subscriber
    methods, then it is preferable to use an event-based approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Return types: Do you need to handle return types? Delegates associated with
    events are always void.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lifetime: Event subscribers typically have a shorter lifetime than their publishers,
    leaving the publisher to continue detecting new messages even if there are no
    active subscribers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static Events Can Cause Memory Leaks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you wrap up your look at events, it pays to be **careful** when using
    events, particularly those that are statically defined.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you add a subscriber's target method to a publisher's event, the publisher
    class will store a reference to your target method. When you have finished using
    a subscriber instance and it remains attached to a `static` publisher, it is possible
    that the memory used by your subscriber will not be cleared up.
  prefs: []
  type: TYPE_NORMAL
- en: These are often referred to as orphaned, phantom, or ghost events. To prevent
    this, always try to pair up each `+=` call with a corresponding `-=` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Extensions (Rx) ([https://github.com/dotnet/reactive](https://github.com/dotnet/reactive))
    is a great library for leveraging and taming event-based and asynchronous programming
    using LINQ-style operators. Rx provides a way to time-shift, for example, buffering
    a very chatty event into manageable streams with just a few lines of code. What's
    more, Rx streams are very easy to unit test, allowing you to effectively take
    control of time.
  prefs: []
  type: TYPE_NORMAL
- en: Now read about the interesting topic of lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout the previous sections, you have mainly used class-level methods
    as targets for your delegates and events, such as the `ClockTicked` and `ClockWakeUp`
    methods, that were also used in *Exercise 3.05*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: The `ClockWakeUp` and `ClockTicked` methods are easy to follow and step through.
    However, by converting them into lambda expression syntax, you can have a more
    succinct syntax and closer proximity to where they are in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now convert the `Ticked` and `WakeUp` events to use two different lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: You have used the same `+=` operator, but instead of method names, you see `(sender,
    e) =>` and identical blocks of code, as seen in `ClockTicked` and `ClockWakeUp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When defining a lambda expression, you can pass any parameters within parentheses,
    `()`, followed by `=>` (this is often read as **goes to**), and then by your expression/statement
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: The code block can be as complex as you need and can return a value if it is
    a `Func`-based delegate.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler can normally infer each of the parameter types, so you do not even
    need to specify their types. Moreover, you can omit the parentheses if there is
    only one argument and the compiler can infer its type.
  prefs: []
  type: TYPE_NORMAL
- en: Wherever a delegate (remember that `Action`, `Action<T>`, and `Func<T>` are
    inbuilt examples of a delegate) needs to be used as an argument, rather than creating
    a class or local method or function, you should consider using a lambda expression.
    The main reason is that this often results in less code, and that code is placed
    closer to the location where it is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider another example on Lambda. Given a list of movies, you can use
    the `List<string>` class to store these string-based names, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `List.Sort` method to sort the names alphabetically (the final
    output will be shown at the end of this example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need more control over how this sort works, the `List` class has another
    `Sort` method that accepts a delegate of this form: `delegate int Comparison<T>(T
    x, T y)`. This delegate is passed two arguments of the same type (`x` and `y`)
    and returns an `int` value. The `int` value can be used to define the sort order
    of items in the list without you having to worry about the internal workings of
    the `Sort` method.'
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative, you can sort the names to exclude `"The"` from the beginning
    of movie titles. This is often used as an alternative way to list names. You can
    achieve this by passing a lambda expression, using the `( )` syntax to wrap two
    strings, `x, y`, that will be passed by `Sort()` when it invokes your lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `x` or `y` starts with your noise word, `"The"`, then you use the `string.Substring`
    function to skip the first four characters. `String.Compare` is then used to return
    a numeric value that compares the resulting string values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then write out the sorted results to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the example code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the second set of names is sorted with `"The"` is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [http://packt.link/B3NmQ](http://packt.link/B3NmQ).
  prefs: []
  type: TYPE_NORMAL
- en: To see these lambda statements put into practice, try your hand at the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.06: Using a Statement Lambda to Reverse Words in a Sentence'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you are going to create a utility class that splits the words
    in a sentence and returns that sentence with the words in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change to the `Chapter03` folder and create a new console app, called `Exercise06`,
    using the CLI `dotnet` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `Chapter03\Exercise06.csproj` and replace the entire file with these settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Open `Exercise02\Program.cs` and clear the contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class named `WordUtilities` with a string function called `ReverseWords`.
    You need to include the `System.Linq` namespace to help with the string operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a `Func<string, string>` delegate called `swapWords` that takes a string
    input and returns a string value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'You will accept a string input argument named `phrase`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the lambda statement body. Use the `string.Split` function to split
    the `phrase` string into an array of strings using a space as the splitting character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '`String.Reverse` reverses the order of strings in the array, before finally
    joining the reversed words string array in a single string using `string.Join`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have defined the required `Func`, so invoke it by passing the sentence
    parameter and returning that as the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for a console app that prompts for a sentence to be entered, which is passed
    to `WordUtilities.ReverseWords`, with the result being written to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the console app produces results output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/z12sR](https://packt.link/z12sR).
  prefs: []
  type: TYPE_NORMAL
- en: You will conclude this look at lambdas with some of the less obvious issues
    that you might not expect to see when running and debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Captures and Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lambda expressions can **capture** any of the variables or parameters within
    the method where they are defined. The word capture is used to describe the way
    that a lambda expression captures or reaches up into the parent method to access
    any variables or parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To grasp this better, consider the following example. Here you will create
    a `Func<int, string>` called `joiner` that joins words together using the `Enumerable.Repeat`
    method. The `word` variable (known as an `Outer Variables`) is captured inside
    the body of the `joiner` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding example produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: You invoked the `joiner` delegate by passing `2` as an argument. At that moment
    in time, the outer `word` variable has a value of `"hello"`, which is repeated
    twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'This confirms that captured variables, from the parent method, were evaluated
    `Func` was invoked. Now change the value of `word` from `hello` to `goodbye` and
    invoke `joiner` once again, passing `3` as the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this example produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: It is worth remembering that it does not matter where in the code you defined
    `joiner`. You could have changed the value of `word` to any number of strings
    before or after declaring `joiner`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking captures one step further, if you define a variable with the same name
    inside a lambda, it will be scoped `word`, which will have no effect on the outer
    variable with the same name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example results in the following output. Notice how the outer
    variable, `word`, remains unchanged from `goodbye`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you will look at the concept of closures that is a subtle part of the
    C# language and often leads to unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, you have a variable, `actions`, that contains a `List`
    of `Action` delegates. You use a basic `for` loop to add five separate `Action`
    instances to the list. The lambda expression for each `Action` simply writes that
    value of `i` from the `for` loop to the console. Finally, the code simply runs
    through each `Action` in the `actions` list and invokes each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the example produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason why `MyAction: i` did not start from `0` is that the value of `i`,
    when accessed from inside a `Action` delegate, is only evaluated once the `Action`
    is invoked. By the time each delegate is invoked, the outer loop has already repeated
    five times over.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/vfOPx](https://packt.link/vfOPx).
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to the capture concept you observed, where the outer variables,
    `i` in this case, are only evaluated when invoked. You used `i` in the `for` loop
    to add each `Action` to the list, but by the time you invoked each action, `i`
    had its final value of `5`.
  prefs: []
  type: TYPE_NORMAL
- en: This can often lead to unexpected behavior, especially if you assume that an
    `i` is being used inside each action's loop variable. To ensure that the incrementing
    value of `i` is used inside each lambda expression, you need to introduce a `for`
    loop, one that takes a copy of the iterator variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, you have added the `closurei` variable. It looks
    very subtle, but you now have a more locally scoped variable, which you access
    from inside the lambda expression, rather than the iterator, `i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the example produces the following output. You can see that the incrementing
    value is used when each `Action` is invoked, rather than the value of `5` that
    you saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: You have covered the key aspects of delegates and events in event-driven applications.
    You extended this by using the succinct coding style offered by lambdas, to be
    notified when events of interest occur.
  prefs: []
  type: TYPE_NORMAL
- en: You will now bring these ideas together into an activity in which you will use
    some of the inbuilt .NET classes with their own events. You will need to adapt
    these events to your own format and publish so they can be subscribed to by a
    console app.
  prefs: []
  type: TYPE_NORMAL
- en: Now it is time to practice all you have learned through the following activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 3.01: Creating a Web File Downloader'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You plan to investigate patterns in US storm events. To do this, you need to
    download storm event datasets from online sources for later analysis. The National
    Oceanic and Atmospheric Administration is one such source of data and can be accessed
    from [https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles](https://www1.ncdc.noaa.gov/pub/data/swdi/stormevents/csvfiles).
  prefs: []
  type: TYPE_NORMAL
- en: You are tasked with creating a .NET Core console app that allows a web address
    to be entered, the contents of which are downloaded to a local disk. To be as
    user-friendly as possible, the application needs to use events that signal when
    an invalid address is entered, the progress of a download, and when it completes.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, you should try to hide the internal implementation that you use to
    download files, preferring to adapt any events that you use to ones that your
    caller can subscribe to. This form of adaption is often used to make code more
    maintainable by hiding internal details from callers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, the `WebClient` class in C# can be used for download requests.
    As with many parts of .NET, this class returns objects that implement the `IDisposable`
    interface. This is a standard interface and it indicates that the object you are
    using should be wrapped in a `using` statement to ensure that any resources or
    memory are cleaned away for you when you have finished using the object. `using`
    takes this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `WebClient.DownloadFileAsync` method downloads files in the background.
    Ideally, you should use a mechanism that allows one part of your code to `System.Threading.ManualResetEventSlim`
    is a class that has `Set` and `Wait` methods that can help with this type of signaling.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this activity, you will need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a progress changed `EventArgs` class (an example name could be `DownloadProgressChangedEventArgs`)
    that can be used when publishing progress events. This should have `ProgressPercentage`
    and `BytesReceived` properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `WebClient` class from `System.Net` should be used to download a requested
    web file. You should create an adapter class (a suggested name is `WebClientAdapter`)
    that hides your internal usage of `WebClient` from your callers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your adapter class should provide three events—`DownloadCompleted`, `DownloadProgressChanged`,
    and `InvalidUrlRequested`—that a caller can subscribe to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The adapter class will need a `DownloadFile` method that calls the `WebClient`
    class's `DownloadFileAsync` method to start the download request. This requires
    converting a string-based web address into a Uniform Resource Identifier (URI)
    class. The `Uri.TryCreate()` method can create an absolute address from the string
    entered via the console. If the call to `Uri.TryCreate` fails, you should publish
    the `InvalidUrlRequested` event to indicate this failure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`WebClient` has two events—`DownloadFileCompleted` and `DownloadProgressChanged`.
    You should subscribe to these two events and republish them using your own similar
    events.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a console app that uses an instance of `WebClientAdapter` (as created
    in *Step 2*) and subscribe to the three events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By subscribing to the `DownloadCompleted` event, you should indicate success
    in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By subscribing to `DownloadProgressChanged`, you should report progress messages
    to the console showing the `ProgressPercentage` and `BytesReceived` values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By subscribing to the `InvalidUrlRequested` event, you should show a warning
    on the console using a different console background color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a `do` loop that allows the user to repeatedly enter a web address. This
    address and a temporary destination file path can be passed to `WebClientAdapter.DownloadFile()`
    until the user enters a blank address to quit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you run the console app with various download requests, you should see
    an output similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: By completing this activity, you have seen how to subscribe to events from an
    existing .NET event-based publisher class (`WebClient`), adapting them to your
    own specification before republishing them in your adapter class (`WebClientAdapter`),
    which were ultimately subscribed to by a console app.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you took an in-depth look at delegates. You created custom
    delegates and saw how they could be replaced with their modern counterparts, the
    inbuilt `Action` and `Func` delegates. By using null reference checks, you discovered
    the safe way to invoke delegates and how multiple methods can be chained together
    to form multicast delegates. You extended delegates further to use them with the
    `event` keyword to restrict invocation and followed the preferred pattern when
    defining and invoking events. Finally, you covered the succinct lambda expression
    style and saw how bugs can be avoided by recognising the use of captures and closures.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will look at LINQ and data structures, the fundamental
    parts of the C# language.
  prefs: []
  type: TYPE_NORMAL

- en: 4\. Data Structures and LINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the main collections and their primary
    usage in C#. You will then see how Language-Integrated Query (LINQ) can be used
    to query collections in memory using code that is efficient and succinct. By the
    end of this chapter, you will be well versed in using LINQ for operations such
    as sorting, filtering, and aggregating data.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the previous chapters, you have used variables that refer to a single
    value, such as the `string` and `double` system types, system `class` instances,
    and your own class instances. .NET has a variety of data structures that can be
    used to store multiple values. These structures are generally referred to as collections.
    This chapter builds on this concept by introducing collection types from the `System.Collections.Generic`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: You can create variables that can store multiple object references using collection
    types. Such collections include lists that resize to accommodate the number of
    elements and dictionaries that offer access to the elements using a unique key
    as an identifier. For example, you may need to store a list of international dialing
    codes using the codes as unique identifiers. In this case, you need to be certain
    that the same dialing code is not added to the collection twice.
  prefs: []
  type: TYPE_NORMAL
- en: These collections are instantiated like any other classes and are used extensively
    in most applications. Choosing the correct type of collection depends primarily
    on how you intend to add items and the way you would like to access such items
    once they are in a collection. The commonly used collection types include `List`,
    `Set`, and `HashSet`, which you will cover in detail shortly.
  prefs: []
  type: TYPE_NORMAL
- en: LINQ is a technology that offers an expressive and concise syntax for querying
    objects. Much of the complexities around filtering, sorting, and grouping objects
    can be removed using the SQL-like language, or if you prefer, a set of extension
    methods that can be chained together to produce collections that can be enumerated
    with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET provides various types of in-built data structures, such as the `Array`,
    `List`, and `Dictionary` types. At the heart of all data structures are the `IEnumerable`
    and `ICollection` interfaces. Classes that implement these interfaces offer a
    way to enumerate through the individual elements and to manipulate their items.
    There is rarely a need to create your own classes that derive directly from these
    interfaces, as all the required functionality is covered by the built-in collection
    types, but it is worth knowing the key properties as they are heavily used throughout
    .NET.
  prefs: []
  type: TYPE_NORMAL
- en: The generic version of each collection type requires a single type parameter,
    which defines the type of elements that can be added to a collection, using the
    standard `<T>` syntax of the generic types.
  prefs: []
  type: TYPE_NORMAL
- en: The `IEnumerable` interface has a single property, that is, `IEnumerator<T>
    GetEnumerator()`. This property returns a type that provides methods that allow
    the caller to iterate through the elements in the collection. You do not need
    to call the `GetEnumerator()` method directly, as the compiler will call it whenever
    you use a `foreach` statement, such as `foreach(var book in books)`. You will
    learn more about using this in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ICollection` interface has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int Count { get; }`: Returns the number of items in the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool IsReadOnly { get; }`: Indicates if the collection is read-only. Certain
    collections can be marked as read-only to prevent callers from adding, deleting,
    or moving elements in the collection. C# will not prevent you from amending the
    properties of individual items in a read-only collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void Add(T item)`: Adds an item of type `<T>` to the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void Clear()`: Removes all items from the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool Contains(T item)`: Returns `true` if the collection contains a certain value.
    Depending on the type of item in the collection, this can be value-equality, where
    an object is similarly based on its members, or reference-equality, where the
    object points to the same memory location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void CopyTo(T[] array, int arrayIndex)`: Copies each element from the collection
    into the target array, starting with the first element at a specified index position.
    This can be useful if you need to skip a specific number of elements from the
    beginning of the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool Remove(T item)`: Removes the specified item from the collection. If there
    are multiple occurrences of the instance, then only the first instance is removed.
    This returns `true` if an item was successfully removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IEnumerable` and `ICollection` are interfaces that all collections implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: ICollection and IEnumerable class diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_04_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.1: ICollection and IEnumerable class diagram'
  prefs: []
  type: TYPE_NORMAL
- en: There are further interfaces that some collections implement, depending on how
    elements are accessed within a collection.
  prefs: []
  type: TYPE_NORMAL
- en: The `IList` interface is used for collections that can be accessed by index
    position, starting from zero. So, for a list that contains two items, `Red` and
    `Blue`, the element at index zero is `Red` and the element at index one is `Blue`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: IList class diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_04_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.2: IList class diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IList` interface has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T this[int index] { get; set; }`: Gets or sets the element at the specified
    index position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int Add(T item)`: Adds the specified item and returns the index position of
    that item in the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void Clear()`: Removes all items from the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool Contains(T item)`: Returns `true` if the list contains the specified item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int IndexOf(T item)`: Returns the index position of the item, or `-1` if not found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void Insert(int index, T item)`: Inserts the item at the index position specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void Remove(T item)`: Removes the item if it exists within the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void RemoveAt(int index)`: Removes the item at the specified index position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have now seen the primary interfaces common to collections. So, now you
    will now take a look at the main collection types that are available and how they
    are used.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `List<T>` type is one of the most extensively used collections in C#. It
    is used where you have a collection of items and want to control the order of
    items using their index position. It implements the `IList` interface, which allows
    items to be inserted, accessed, or removed using an index position:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: List class diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_04_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.3: List class diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists have the following behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: Items can be inserted at any position within the collection. Any trailing items
    will have their index position incremented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Items can be removed, either by index or value. This will also cause trailing
    items to have their index position updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Items can be set using their index value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Items can be added to the end of the collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Items can be duplicated within the collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The position of items can be sorted using the various `Sort` methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One example of a list might be the tabs in a web browser application. Typically,
    a user may want to drag a browser tab amongst other tabs, open new tabs at the
    end, or close tabs anywhere in a list of tabs. The code to control these actions
    can be implemented using `List`.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, `List` maintains an array to store its objects. This can be efficient
    when adding items to the end, but it may be inefficient when inserting items,
    particularly near the beginning of the list, as the index position of items will
    need to be recalculated.
  prefs: []
  type: TYPE_NORMAL
- en: The following example shows how the generic `List` class is used. The code uses
    the `List<string>` type parameter, which allows `string` types to be added to
    the list. Attempts to add any other type will result in a compiler error. This
    will show the various commonly used methods of the `List` class.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder called `Chapter04` in your source code folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change to the `Chapter04` folder and create a new console app, called `Chapter04`,
    using the following .NET command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Delete the `Class1.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new folder called `Examples`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class file called `ListExamples.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `System.Collections.Generic` namespace to access the `List<T>` class
    and declare a new variable called `colors`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code declares the new `colors` variable, which can store multiple color
    names as `strings`. Here, the collection initialization syntax is used so that
    `red` and `green` are added as part of the initialization of the variable. The
    `Add` method is called, adding `orange` to the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, `AddRange` adds `yellow` and `pink` to the end of the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, there are five colors in the list, with `red` at index position
    `0` and `green` at position `1`. You can verify this using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `Insert`, `blue` can be inserted at the beginning of the list, that is,
    at index `0`, as shown in the following code. Note that this moves `red` from
    index `0` to `1` and all other colors will have their index incremented by one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output on running this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `foreach` you can iterate through the strings in the list, writing each
    string to the console, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the following code to reverse the array. Here, each `color` string
    is converted into an array of `char` type using `ToCharArray`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This does not affect any of the values in the `colors` List, as `characters`
    refers to a different object. Note that `foreach` iterates through each string,
    whereas `ForEach` defines an Action delegate to be invoked using each string (recall
    that in *Chapter 3*, *Delegates, Events, and Lambdas*, you saw how lambda statements
    can be used to create `Action` delegates).
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the code leads to this output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next snippet, the `List` constructor accepts a source collection. This
    creates a new list containing a copy of the `colors` strings in this case, which
    is sorted using the default `Sort` implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The string type uses value-type semantics, which means that the `backupColors`
    list is populated with a **copy** of each source string value. Updating a string
    in one list will **not** affect the other list. Conversely, classes are defined
    as reference-types so passing a list of class instances to the constructor will
    still create a new list, with independent element indexes, but each element will
    point to the same shared reference in memory rather than an independent copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, prior to removing all colors (using `colors.Clear`),
    each value is written to the console (the list will be repopulated shortly):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, `AddRange` is used again, to add the full list of colors back to the
    `colors` list, using the sorted `backupColors` items as a source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ConvertAll` method is passed a delegate that can be used to return a new
    list of any type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, a new `List<string>` is returned with each item being formatted using
    its value and the item''s index in the list. As expected, running the code produces
    this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next snippet, two `Contains()` methods are used to show string value-equality
    in action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the uppercase `RED` is `red` will be. Running the code produces this
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `Exists` method is passed a Predicate delegate, which returns `True`
    or `False` if the test condition is met. Predicate is an inbuilt delegate, which
    returns a boolean value. In this case, `True` will be returned if any item exists
    where the string value ends with the letters `ink` (`pink`, for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You know there is already a `red` color, but it will be interesting to see
    what happens if you insert `red` again, twice, at the very beginning of the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This shows that it is possible to insert the same item more than once into a
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next snippet shows you how to use the `FindAll` method. `FindAll` is similar
    to the `Exists` method, in that it is passed a `Predicate` condition. All items
    that match that rule will be returned. Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get an output as follows. As expected, there are three `red` items returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finishing the example, the `Remove` method is used to remove the first `red`
    from the list. There are still two `FindLastIndex` to get the index of the last
    `red` item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/dLbK6](https://packt.link/dLbK6).
  prefs: []
  type: TYPE_NORMAL
- en: With the knowledge of how the generic `List` class is used, it is time for you
    to work on an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.01: Maintaining Order within a List'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of the chapter, web browser tabs were described as an ideal
    example of lists. In this exercise, you will put this idea into action, and create
    a class that controls the navigation of the tabs within an app that mimics a web
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, you will create a `Tab` class and a `TabController` app that allows
    new tabs to be opened and existing tabs to be closed or moved. The following steps
    will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: In VSCode, select your `Chapter04` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new folder called `Exercises`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `Exercises` folder, add a folder called `Exercise01` and add a file
    called `Exercise01.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `Exercise01.cs` and define a `Tab` class with a string URL constructor
    parameter as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `ToString` method has been overridden to return the current URL to
    help when logging details to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `TabController` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `TabController` class contains a List of tabs. Notice how the class inherits
    from the `IEnumerable` interface. This interface is used so that the class provides
    a way to iterate through its items, using a `foreach` statement. You will provide
    methods to open, move, and close tabs, which will directly control the order of
    items in the `_tabs` list, in the next steps. Note that you could have exposed
    the `_tabs` list directly to callers, but it would be preferable to limit access
    to the tabs through your own methods. Hence, it is defined as a `readonly` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, define the `OpenNew` method, which adds a new tab to the end of the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Define another method, `Close`, which removes the tab from the list if it exists.
    Add the following code for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To move a tab to the start of the list, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, `MoveToStart` will try to remove the tab and then insert it at index `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, add the following code to move a tab to the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, calling `MoveToEnd` removes the tab first, and then adds it to the end,
    logging the new index position to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `IEnumerable` interface requires that you implement two methods,
    `IEnumerator<Tab> GetEnumerator()` and `IEnumerable.GetEnumerator()`. These allow
    the caller to iterate through a collection using either a generic of type `Tab`
    or using the second method to iterate via an object-based type. The second method
    is a throwback to earlier versions of C# but is needed for compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the actual results for both methods, you can use the `GetEnumerator` method
    of the `_tab` list, as that contains the tabs in list form. Add the following
    code to do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now create a console app that tests the controller''s behavior. Start
    by opening three new tabs and logging the tab details via `LogTabs` (this will
    be defined shortly):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, move `amazon` to the start and `packt` to the end, and log the tab details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Close the `msoft` tab and log details once more:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Finally, add an extension method that helps log the URL of each tab in `TabController`.
    Define this as an extension method for `IEnumerable<Tab>`, rather than `TabController`,
    as you simply need an iterator to iterate through the tabs using a `foreach` loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use `PadRight` to left-align each URL, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code produces the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes Visual Studio might report a non-nullable property error the first
    time you execute the program. This is a helpful reminder that you are attempting
    to use a string value that may have a null value at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The three tabs are opened. `amazon.com` and `packtpub.com` are then moved before
    `microsoft.com` is finally closed and removed from the tab list.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/iUcIs](https://packt.link/iUcIs).
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have seen how lists can be used to store multiple items
    of the same type while maintaining the order of items. The next section covers
    the `Queue` and `Stack` classes, which allow items to be added and removed in
    a predefined sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Queue class provides a first-in, first-out mechanism. Items are added to
    the end of the queue using the `Enqueue` method and are removed from the front
    of the queue using the `Dequeue` method. Items in the queue cannot be accessed
    via an index element.
  prefs: []
  type: TYPE_NORMAL
- en: Queues are typically used when you need a workflow that ensures items are processed
    in the order in which they are added to the queue. A typical example might be
    a busy online ticketing system selling a limited number of concert tickets to
    customers. To ensure fairness, customers are added to a queuing system as soon
    as they log on. The system would then dequeue each customer and process each order,
    in full, either until all tickets have been sold or the customer queue is empty.
  prefs: []
  type: TYPE_NORMAL
- en: The following example creates a queue containing five `CustomerOrder` records.
    When it is time to process the orders, each order is dequeued using the `TryDequeue`
    method, which will return `true` until all orders have been processed. The customer
    orders are processed in the order that they were added. If the number of tickets
    requested is more than or equal to the tickets remaining, then the customer is
    shown a success message. An apology message is shown if the number of tickets
    remaining is less than the requested amount.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: The Queue''s Enqueue() and Dequeue() workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_04_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.4: The Queue''s Enqueue() and Dequeue() workflow'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Examples` folder of your `Chapter04` source folder, add a new class
    called `QueueExamples.cs` and edit it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Add five orders to the queue using the `Enqueue` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, use a `while` loop that repeats until `TryDequeue` returns `false`, meaning
    all current orders have been processed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the example code produces the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The first time you run this program, Visual Studio might show a non-nullable
    type error. This error is a reminder that you are using a variable that could
    be a null value.
  prefs: []
  type: TYPE_NORMAL
- en: The output shows that `Dave` requested two tickets. As there are two or more
    tickets available, he was successful. Both `Siva` and `Julien` were also successful,
    but by the time `Kane` placed his order of two tickets, there was only one ticket
    available, so he was shown the apology message. Finally, `Ann` requested one ticket
    and was successful in her order.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/Zb524](https://packt.link/Zb524).
  prefs: []
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Stack` class provides the opposite mechanism to the `Queue` class; items
    are processed in last-in, first-out order. As with the `Queue` class, you cannot
    access elements via their index position. Items are added to the stack using the
    `Push` method and removed using the `Pop` method.
  prefs: []
  type: TYPE_NORMAL
- en: An application's `Undo` menu can be implemented using a stack. For example,
    in a word processor, as the user edits a document, an `Action` delegate is created,
    which can reverse the most recent change whenever the user presses `Ctrl` + `Z`.
    The most recent action is popped off the stack and the change is undone. This
    allows multiple steps to be undone.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: The Stack''s Push() and Pop() workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_04_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.5: The Stack''s Push() and Pop() workflow'
  prefs: []
  type: TYPE_NORMAL
- en: The following example shows this in practice.
  prefs: []
  type: TYPE_NORMAL
- en: You will start by creating an `UndoStack` class that supports multiple undo
    operations. The caller decides what action should run each time the `Undo` request
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical undoable operation would be storing a copy of text prior to the user
    adding a word. Another undoable operation would be storing a copy of the current
    font prior to a new font being applied. You can start by adding the following
    code, where you are creating the `UndoStack` class and defining a `readonly Stack
    of Action` delegates, named `_undoStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Chapter04\Examples` folder, add a new class called `StackExamples.cs`
    and edit it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user has done something, the same action can be undone. So push an
    `Action` to the front of `_undoStack`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Undo` method checks to see if there are any items to undo, then calls
    `Pop` to remove the most recent `Action` and invoke it, thus undoing the change
    that was just applied. The code for this can be added as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can create a `TextEditor` class that allows edits to be added to `UndoStack`.
    This constructor is passed `UndoStack` as there could be multiple editors that
    need to add various `Action` delegates to the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the `EditText` command, which takes a copy of the `previousText`
    value and creates an `Action` delegate that can revert the text to its previous
    value, if invoked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `newText` value should be appended to the `Text` property, using the
    `+=` operator. The details for this are logged to the console, using `PadRight`
    to improve the format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it is time to create a console app that tests `TextEditor` and `UndoStack`.
    Four edits are initially made, followed by two **undo operations**, and finally
    two more text edits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the console app produces the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio may show non-nullable property error the first time the code is
    executed. This is because Visual Studio notices that the `Text` property can be
    a null value at runtime so offers a suggestion to improve the code.
  prefs: []
  type: TYPE_NORMAL
- en: The left-hand output shows the text edits and undoes operations as they are
    applied and the resulting `Text` value on the right-hand side. The two `Undo`
    calls result in `near by` and `city` being removed from the `Text` value, before
    `land` and `far far away` are finally added to the `Text` value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/tLVyf](https://packt.link/tLVyf).
  prefs: []
  type: TYPE_NORMAL
- en: HashSets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `HashSet` class provides mathematical set operations with collections of
    objects in an efficient and highly performant manner. `HashSet` does not allow
    duplicate elements and items are not stored in any particular order. Using the
    `HashSet` class is ideal for high-performance operations, such as needing to quickly
    find where two collections of objects overlap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, `HashSet` is used with the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public void UnionWith(IEnumerable<T> other)`: Produces a set union. This modifies
    `HashSet` to include the items present in the current `HashSet` instance, the
    other collection, or both.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void IntersectWith(IEnumerable<T> other)`: Produces a set intersect.
    This modifies `HashSet` to include items present in the current `HashSet` instance
    and the other collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void ExceptWith(IEnumerable<T> other)`: Produces a set subtraction.
    This removes items from the `HashSet` that are present in the current `HashSet`
    instance and the other collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HashSet` is useful when you need to include or exclude certain elements from
    **collections**. As an example, consider that an agent manages various celebrities
    and has been asked to find three sets of stars:'
  prefs: []
  type: TYPE_NORMAL
- en: Those that can act **or** sing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those that can act **and** sing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those that can act **only** (no singers allowed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following snippet, a list of actors'' and singers'' names is created:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Chapter04\Examples` folder, add a new class called `HashSetExamples.cs`
    and edit it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a new `HashSet` instance that initially contains singers only and
    then use `UnionWith` to modify the set to contain a distinct set of those that
    can act **or** sing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'For those that can act `HashSet` instance of singers, and modify the `HashSet`
    instance using `IntersectWith` to contain a distinct list of those that are in
    both collections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, for those that can `ExceptWith` to remove those from the `HashSet`
    instance that can also sing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the console app produces the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: From the output, you can see that out of the given list of actors and singers,
    only `Will Smith` can act and sing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/ZdNbS](https://packt.link/ZdNbS).
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another commonly used collection type is the generic `Dictionary<TK, TV>`. This allows
    multiple items to be added, but a unique **key** is needed to identify an item instance.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries are commonly used to look up values using known keys. The key and
    value type parameters can be of any type. A value can exist in a `Dictionary`
    more than once, provided that its key is **unique**. Attempting to add a key that
    already exists will result in a runtime exception being thrown.
  prefs: []
  type: TYPE_NORMAL
- en: A common example of a `Dictionary` might be a registry of known countries that
    are keyed by their ISO country code. A customer service application may load customer
    details from a database and then use the ISO code to look up the customer's country
    from the country list, rather than having the extra overhead of creating a new
    country instance for each customer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information on standard ISO country codes at [https://www.iso.org/iso-3166-country-codes.html](https://www.iso.org/iso-3166-country-codes.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The main methods used in the `Dictionary` class are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public TValue this[TKey key] {get; set;}`: Gets or sets a value associated
    with the key. An exception is thrown if the key does not exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dictionary<TKey, TValue>.KeyCollection Keys { get; }`: Returns a `KeyCollection`
    dictionary instance that contains all keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dictionary<TKey, TValue>.ValueCollection Values { get; }`: Returns a `ValueCollection`
    dictionary instance that contains all values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public int Count { get; }`: Returns the number of elements in the `Dictionary`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void Add(TKey key, TValue value)`: Adds the key and associated value. If the
    key already exists, an exception is thrown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void Clear()`: Clears all keys and values from the `Dictionary`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool ContainsKey(TKey key)`: Returns `true` if the specified key exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool ContainsValue(TValue value)`: Returns `true` if the specified value exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool Remove(TKey key)`: Removes a value with the associated key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool TryAdd(TKey key, TValue value)`: Attempts to add the key and value. If
    the key already exists, an exception is "not" thrown. Returns `true` if the value
    was added.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool TryGetValue(TKey key, out TValue value)`: Gets the value associated with
    the key, if it is available. Returns `true` if it was found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows how a `Dictionary` can be used to add and navigate
    `Country` records:'
  prefs: []
  type: TYPE_NORMAL
- en: In your `Chapter04\Examples` folder, add a new class called `DictionaryExamples.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start by defining a `Country` record, which is passed a `Name` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `Dictionary` initialization syntax to create a `Dictionary` with five
    countries, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next code snippet, `Dictionary` implements the `IEnumerable` interface,
    which allows you to retrieve a key-value pair representing the key and value items
    in the `Dictionary`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the example code produces the following output. By iterating through
    each item in `countries`, you can see the five country codes and their names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an entry with the `AFG` key, so using the `set indexer` passing in
    `AFG` as a key allows a new `Country` record to be set that replaces the previous
    item with the `AGF` key. You can add the following code for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the code, adding a key for `AFG` allows you to get a value using
    that key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Key comparisons are case-sensitive with string keys, so `AGO` is present but
    `and` is not as the corresponding country (`Andorra`) is defined with the uppercase
    `AND` key. You can add the following code to check this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `Add` to add a new entry will throw an exception if the key already exists.
    This can be seen by adding the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Conversely, `TryAdd` does `AIA` key, so using `TryAdd` simply returns a `false`
    value rather than throwing an exception:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'As the following output shows, adding `Anguilla` once using the `AIA` key is
    valid but attempting to add it again using the `AIA` key results in an exception
    being caught:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`TryGetValue`, as the name suggests, allows you to try to get a value by key.
    You pass in a key that may be missing from the `Dictionary`. Requesting an object
    whose key is missing from the `Dictionary` will ensure that an exception is not
    thrown. This is useful if you are unsure whether a value has been added for the
    specified key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output upon running this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio might report the following warning: `Warning CS8600: Converting
    null literal or possible null value to non-nullable type`. This is a reminder
    from Visual Studio that a variable may have a null value at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: You have seen how the `Dictionary` class is used to ensure that only unique
    identities are associated with values. Even if you do not know which keys are
    in the `Dictionary` until runtime, you can use the `TryGetValue` and `TryAdd`
    methods to prevent runtime exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/vzHUb](https://packt.link/vzHUb).
  prefs: []
  type: TYPE_NORMAL
- en: In this example, a string key was used for the `Dictionary`. However, any type
    can be used as a key. You will often find that an integer value is used as a key
    when source data is retrieved from relational databases, as integers can often
    be more efficient in memory than strings. Now it is time to use this feature through
    an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.02: Using a Dictionary to Count the Words in a Sentence'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have been asked to create a console app that asks the user to enter a sentence.
    The console should then split the input into individual words (using a space character
    as a word delimiter) and count the number of times that each word occurs. If possible,
    simple forms of punctuation should be removed from the output, and you are to
    ignore capitalized words so that, for example, `Apple` and `apple` both appear
    as a single word.
  prefs: []
  type: TYPE_NORMAL
- en: This is an ideal use of a `Dictionary`. The `Dictionary` will use a string as
    the key (a unique entry for each word) with an `int` value to count the words.
    You will use `string.Split()` to split a sentence into words, and `char.IsPunctuation`
    to remove any trailing punctuation marks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: In your `Chapter04\Exercises` folder, create a new folder called `Exercise02`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `Exercise02` folder, add a new class called `Program.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start by defining a new class called `WordCounter`. This can be marked as `static`
    so that it can be used without needing to create an instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a `static` method called `Process`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This is passed a phrase and returns `IEnumerable<KeyValuePair>`, which allows
    the caller to enumerate through a `Dictionary` of results. After this definition,
    the `Dictionary` of `wordCounts` is keyed using a `string` (each word found) and
    an `int` (the number of times that a word occurs).
  prefs: []
  type: TYPE_NORMAL
- en: You are to ignore the case of words with capital letters, so convert the string
    into its lowercase equivalent before using the `string.Split` method to split
    the phrase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then you can use the `RemoveEmptyEntries` option to remove any empty string
    values. Add the following code for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Use a simple `foreach` loop to iterate through the individual words found in
    the phrase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The `char.IsPunctuation` method is used to remove punctuation marks from the
    end of the word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `TryGetValue` method to check if there is a `Dictionary` entry with
    the current word. If so, update the `count` by one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: If the word does not exist, add a new word key with a starting value of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all the words in the phrase have been processed, return the `wordCounts Dictionary`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, write the console app that allows the user to enter a phrase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The `do` loop will end once the user enters an empty string; you will add the
    code for this in an upcoming step.
  prefs: []
  type: TYPE_NORMAL
- en: Call the `WordCounter.Process` method to return a key-value pair that can be
    enumerated through.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each `key` and `value`, write the word and its count, padding each word
    to the right:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: A new line is started after every third word (using `i % 3 = 0`) for improved
    output formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finish off the `do-while` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the console using the opening text from *The Gettysburg Address* of
    1863 produces this output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can search online for The Gettysburg Address or visit [https://rmc.library.cornell.edu/gettysburg/good_cause/transcript.htm](https://rmc.library.cornell.edu/gettysburg/good_cause/transcript.htm).
  prefs: []
  type: TYPE_NORMAL
- en: From the results, you can see that each word is displayed only once and that
    certain words, such as `and` and `that`, appear more than once in the speech.
    The words are listed in the order they appear in the text, but this is not always
    the case with the `Dictionary` class. It should be assumed that the order will
    **not** remain fixed this way; dictionaries' values should be accessed using a
    key.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/Dnw4a](https://packt.link/Dnw4a).
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have learned about the main collections commonly used in .NET. It
    is now time to look at LINQ, which makes extensive use of collections based on
    the `IEnumerable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: LINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LINQ (pronounced **link**) is short for Language Integrated Query. LINQ is a
    general-purpose language that can be used to query objects in memory by using
    a syntax that is similar to Structured Query Language (SQL), that is, it is used
    to query databases. It is an enhancement of the C# language that makes it easier
    to interact with objects in memory using SQL-like Query Expressions or Query Operators
    (implemented through a series of extension methods).
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft''s original idea for LINQ was to bridge the gap between .NET code
    and data sources, such as relational databases and XML, using LINQ providers.
    LINQ providers form a set of building blocks that can be used to query various
    sources of data, using a similar set of Query Operators, without the caller needing
    to know the intricacies of how each data source works. The following is a list
    of providers and how they are used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'LINQ to Objects: Queries applied to objects in memory, such as those defined
    in a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LINQ to SQL: Queries applied to relational databases such as SQL Server, Sybase,
    or Oracle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LINQ to XML: Queries applied to XML documents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will cover LINQ to Objects. This is, by far, the most common use
    of LINQ providers and offers a flexible way to query collections in memory. In
    fact, when talking about LINQ, most people refer to LINQ to Objects, mainly due
    to its ubiquitous use throughout C# applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the heart of LINQ is the way that collections can be converted, filtered,
    and aggregated into new forms using a concise and easy-to-use syntax. LINQ can
    be used in two interchangeable styles:'
  prefs: []
  type: TYPE_NORMAL
- en: Query Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query Expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each style offers a different syntax to achieve the same result, and which one
    you use often comes down to personal preference. Each style can be interwoven
    in code easily.
  prefs: []
  type: TYPE_NORMAL
- en: Query Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are based on a series of core extension methods. The results from one
    method can be chained together into a programming style, which can often be easier
    to grasp than their expression-based counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: The extension methods typically take an `IEnumerable<T>` or `IQueryable<T>`
    input source, such as a list, and allow a `Func<T>` predicate to be applied to
    that source. The source is generic-based, so Query Operators work with all types.
    It is just as easy to work with `List<string>` as it is with `List<Customer>`,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, `.Where`, `.OrderBy`, and `.Select` are the extension
    methods being called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Here, you are taking the results from a `.Where` extension method to find all
    books with a unit price greater than `10`, which is then sorted using the `.OrderBy`
    extension method. Finally, the name of each book is extracted using the `.Select`
    method. These methods could have been declared as single lines of code, but chaining
    in this way provides a more intuitive syntax. This will be covered in more detail
    in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Query Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Query Expressions are an enhancement of the C# language and resemble SQL syntax.
    The C# compiler compiles Query Expressions into a sequence of Query Operator extension
    method calls. Note that not all Query Operators are available with an equivalent
    Query Expression implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Query Expressions have the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: They start with a `from` clause.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can contain at least one or more optional `where`, `orderby`, `join`, `let`,
    and additional `from` clauses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They end with either a `select` or a `group` clause.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following snippet is functionally equivalent to the Query Operator style
    defined in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: You will take a more in-depth look at both styles as you learn about the standard
    Query Operators shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Deferred Execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whether you choose to use Query Operators, Query Expressions, or a mixture of
    the two, it is important to remember that for many operators, the query that you
    define is not executed when it is defined, but only when it is enumerated over.
    This means that it is not until a `foreach` statement or a `ToList`, `ToArray`,
    `ToDictionary`, `ToLookup`, or `ToHashSet` method is called that the actual query
    is executed.
  prefs: []
  type: TYPE_NORMAL
- en: This allows queries to be constructed elsewhere in code with additional criteria
    included, and then used or even reused with a different collection of data. Recall
    that in *Chapter 3*, *Delegates, Lambdas, and Events*, you saw similar behavior
    with delegates. Delegates are not executed where they are defined, but only when
    they are invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following short Query Operator example, the output will be `abz` even
    though `z` is added **after** the query is defined but **before** it is enumerated
    through. This demonstrates that LINQ queries are evaluated on demand, rather than
    at the point where they are declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Standard Query Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LINQ is driven by a core set of extension methods, referred to as standard Query
    Operators. These are grouped into operations based on their functionality. There
    are many standard Query Operators available, so for this introduction, you will
    explore all the main operators that you are likely to use regularly.
  prefs: []
  type: TYPE_NORMAL
- en: Projection Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Projection operations allow you to convert an object into a new structure using
    only the properties that you need. You can create a new type, apply mathematical
    operations, or return the original object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Select`: Projects each item in the source into a new form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SelectMany`: Projects all items in the source, flattens the result, and optionally
    projects them to a new form. There is no Query Expression equivalent for `SelectMany`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider the following snippet, which iterates through a `List<string>` containing
    the values `Mon`, `Tues`, and `Wednes`, outputting each with the word day appended.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Chapter04\Examples` folder, add a new file called `LinqSelectExamples.cs`
    and edit it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the Query Operator syntax first, you can see that `query1` uses
    the `Select` extension method and defines a `Func<T>` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, the variable `d` is passed to the lambda statement, which appends
    the word `day` to each string in the `days` list: `"Mon"`, `"Tues"`, `"Wednes"`.
    This returns a new `IEnumerable<string>` instance, with the original values inside
    the source variable, `days`, remaining unchanged.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now enumerate through the new `IEnumerable` instance using `foreach`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `Select` method has another overload that allows the index position
    in the source and value to be accessed, rather than just the value itself. Here,
    `d` (the string value) and `i` (its index) are passed, using the `( d , i ) =>`
    syntax and joined into a new string. The output will be displayed as `0 : Monday`,
    `1 : Tuesday`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you continue looking at `Select` projections, it is worth noting that
    C# does not limit you to just creating new strings from existing strings. You
    can project into any type.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create anonymous types, which are types created by the compiler
    from the properties that you name and specify. For example, consider the following
    example, which results in a new type being created that represents the results
    of the `Select` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Here, `query3` results in a new type that has an Index and `UpperCaseName` property;
    the values are assigned using `Index = i` and `UpperCaseName = $"{d.ToUpper()}DAY"`.
  prefs: []
  type: TYPE_NORMAL
- en: These types are scoped to be available within your local method and can then
    be used in any local statements, such as in the previous `foreach` block. This
    saves you from having to create classes to temporarily store values from a `Select`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the code produces output in this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: As an alternative, consider how the equivalent Query Expression looks. In the
    following example, you start with the from `day in days` expression. This assigns
    the name `day` to the string values in the `days` list. You then use `select`
    to project that to a new string, appending `"day"` to each.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is functionally equivalent to the example in `query1`. The only difference
    is the code readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example snippet mixes a Query Operator and Query Expressions.
    The `select` Query Expression cannot be used to select a value and index, so the
    `Select` extension method is used to create an anonymous type with a `Name` and
    `Index` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the full example produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Again, it largely comes down to personal choice as to which you prefer using.
    As queries become longer, one form may require less code than the other.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/wKye0](https://packt.link/wKye0).
  prefs: []
  type: TYPE_NORMAL
- en: SelectMany
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have seen how `Select` can be used to project values from each item in a
    source collection. In the case of a source that has enumerable properties, the
    `SelectMany` extension method can extract the multiple items into a single list,
    which can then be optionally projected into a new form.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example creates two `City` records, each with multiple `Station`
    names, and uses `SelectMany` to extract all stations from both cities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Chapter04\Examples` folder, add a new file called `LinqSelectManyExamples.cs`
    and edit it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The `Func` parameter, which is passed to `SelectMany`, requires you to specify
    an enumerable property, in this case, the `City` class's `Stations` property,
    which contains a list of string names (see the highlighted code).
  prefs: []
  type: TYPE_NORMAL
- en: Notice how a shortcut is used here, by directly integrating the query into a
    `foreach` statement. You are not altering or reusing the query variable, so there is
    no benefit in defining it separately, as done earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '`SelectMany` extracts all the station names from all of the items in the `List<City>`
    variable. Starting with the `City` class at element `0`, which has the name `London`,
    it will extract the three station names `("Kings Cross KGX"`, `"Liverpool Street
    LVS"`, and `"Euston EUS"`). It will then move on to the second `City` element,
    named `Birmingham`, and extract the single station, named `"New Street NST"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the example produces the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'As an alternative, consider the following snippet. Here, you revert to using
    a query variable, `stations`, to make the code easier to follow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Rather than just returning each `Station` string, this example uses a nested
    `Select` method and a `Range` operator to extract the last three characters from
    the station name using `s[^3..]`, where `s` is a string for each station name
    and `^3` indicates that the `Range` operator should extract a string that starts
    at the last three characters in the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the example produces the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: You can see the last three characters of each station name are shown in the output.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/g8dXZ](https://packt.link/g8dXZ).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section you will read about the filtering operations that filter
    a result as per a condition.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Filtering operations allow you to filter a result to return only those items
    that match a condition. For example, consider the following snippet, which contains
    a list of orders:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Chapter04\Examples` folder, add a new file called `LinqWhereExample.cs`
    and edit it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Here, some order items are defined for various stationery products. Suppose
    you want to output all orders that have a quantity greater than five (this should
    output the `Ruler` and `USB Memory Stick` orders from the source).
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, you can add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose you extend the criteria to find all products where the product
    is `Pen` or `Pencil`. You can chain that result into a `Select` method, which
    will return each order''s total value; remember that `Select` can return anything
    from a source, even a simple extra calculation like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the Query Expression in the following snippet uses a `where` clause to
    find the orders with a price less than or equal to `3.99`. This projects them
    into an anonymous type that has `Name` and `Value` properties, which you enumerate
    through using a `foreach` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the full example produces this result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Now you have seen Query Operators in action, it is worth returning to deferred
    execution to see how this affects a query that is enumerated multiple times over.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this next example, you have a collection of journeys made by a vehicle,
    which are populated via a `TravelLog` record. The `TravelLog` class contains an
    `AverageSpeed` method that logs a console message each time it is executed, and,
    as the name suggests, returns the average speed of the vehicle during that journey:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your Chapter04\Examples folder, add a new file called `LinqMultipleEnumerationExample.cs`
    and edit it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define the console app''s `Main` method, which populates a `travelLogs`
    list with four `TravelLog` records. You will add the following code for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: You will now create a `fastestJourneys` query variable, which includes a `Where`
    clause. This `Where` clause will call each journey's `AverageSpeed` method when
    enumerated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, using a `foreach` loop, you enumerate through the items in `fastestJourneys`
    and write the name and distance to the console (note that you do `AverageSpeed`
    method inside the `foreach` loop):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code block will produce the following output, the `Name` and `Distance`
    for each journey:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that `AverageSpeed` was called `Where` condition. This is as expected
    so far, but now, you can reuse the same query to output the `Name` and, alternatively,
    the `Duration`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this block produces the same `AverageSpeed` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: This shows that whenever a query is enumerated, the full query is `AverageSpeed`,
    but what if a method needs to access a database to extract some data? That would
    result in multiple database calls and, possibly, a very slow application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use methods such as `ToList`, `ToArray`, `ToDictionary`, `ToLookup`,
    or `ToHashSet` to ensure that a query that could be enumerated many times is `Where`
    clause but includes an extra `ToList` call to immediately execute the query and
    ensure it is not re-evaluated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the block produces the following output. Notice how `AverageSpeed`
    is called `Fastest Duration Multiple loop iteration` messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Notice that from the collection of journeys made by a vehicle, the code returns
    the average speed of the vehicle during the journeys.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/CIZJE](https://packt.link/CIZJE).
  prefs: []
  type: TYPE_NORMAL
- en: Sorting Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are five operations to sort items in a source. Items are primarily sorted
    and that can be followed by an optional secondary sort, which sorts the items
    within their primary group. For example, you can use a primary sort to sort a
    list of people firstly by the `City` property and then use a secondary sort to
    further sort them by the `Surname` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OrderBy`: Sorts values into ascending order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrderByDescending`: Sorts values into descending order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ThenBy`: Sorts values that have been primarily sorted into a secondary ascending
    order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ThenByDescending`: Sorts values that have been primarily sorted into a secondary
    descending order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reverse`: Simply returns a collection where the order of elements in the source
    is reversed. There is no expression equivalent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OrderBy and OrderByDescending
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, you will use the `System.IO` namespace to query files in the
    host machine's `temp` folder, rather than creating small objects from lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'The static `Directory` class offers methods that can query the filesystem.
    `FileInfo` retrieves details about a specific file, such as its size or creation
    date. The `Path.GetTempPath` method returns the system''s `temp` folder. To illustrate
    the point, in the Windows operating system, this can typically be found at `C:\Users\username\AppData\Local\Temp`,
    where `username` is a specific Windows login name. This will be different for
    other users and other systems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Chapter04\Examples` folder, add a new file called `LinqOrderByExamples.cs`
    and edit it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `Directory.EnumerateFiles` method to find all filenames with the `.tmp`
    extension in the `temp` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Here, each filename is projected into a `FileInfo` instance and chained into
    a populated collection using `ToList`, which allows you to further query the resulting
    `fileInfos` details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `OrderBy` method is used to sort the earliest files by comparing
    the `CreationTime` property of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the largest files, re-query `fileInfos` and sort each file by its `Length`
    property using `OrderByDescending`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, use `where` and `orderby` descending expressions to find the largest
    files that are less than `1,000` bytes in length:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on the files in your `temp` folder, you should see an output like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: With this example, you have queried files in the host machine's `temp` folder,
    rather than creating small objects from lists.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/mWeVC](https://packt.link/mWeVC).
  prefs: []
  type: TYPE_NORMAL
- en: ThenBy and ThenByDescending
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following example sorts popular quotes, based on the number of words found
    in each.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Chapter04\Examples` folder, add a new file called `LinqThenByExamples.cs`
    and edit it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'You start by declaring a string array of quotes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next snippet, each of these string quotes is projected into a new anonymous
    type based on the number of words in the quote (found using `String.Split()`).
    The items are first sorted in descending order to show those with the most words
    and then sorted in alphabetical order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code lists the quotes in word count order as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Note how the quotes with six words are shown alphabetically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following (highlighted code) is the equivalent Query Expression with `orderby
    quote.Words descending` followed by the `quote.Words` ascending clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/YWJRz](https://packt.link/YWJRz).
  prefs: []
  type: TYPE_NORMAL
- en: Now you have sorted popular quotes based on the number of words found in each.
    It is time to apply the skills learnt in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.03: Filtering a List of Countries by Continent and Sorting by Area'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding examples, you have looked at code that can select, filter,
    and sort a collection source. You will now combine these into an exercise that
    filters a small list of countries for two continents (South America and Africa)
    and sorts the results by geographical size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: In your `Chapter04\Exercises` folder, create a new `Exercise03` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class called `Program.cs` in the `Exercise03` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start by adding a `Country` record that will be passed the `Name` of a country,
    the `Continent` to which it belongs, and its `Area` in square miles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a small subset of country data defined in an array, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: The array contains the name of a country, the continent it belongs to, and its
    geographical size in square miles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your search criteria must include `South America` or `Africa`. So define them
    in an array rather than hardcoding the `where` clause with two specific strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: This offers extra code flexibility should you need to alter it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build up a query by filtering and sorting by continent, sorting by area, and
    using the `.Select` extension method, which returns the `Index` and `item` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: You finally project each into a new anonymous type to be written to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the code block produces the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `Algeria` has the largest area in `Africa`, and `Brazil` has the
    largest area in `South America` (based on this small subset of data). Notice how
    you add `1` to each `Index` for readability (since starting at zero is less user-friendly).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/Djddw](https://packt.link/Djddw).
  prefs: []
  type: TYPE_NORMAL
- en: You have seen how LINQ extension methods can be used to access items in a data
    source. Now, you will learn about partitioning data, which can be used to extract
    subsets of items.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you have looked at filtering the items in a data source that match a
    defined condition. Partitioning is used when you need to divide a data source
    into two distinct sections and return either of those two sections for subsequent
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider that you have a list of vehicles sorted by value and want
    to process the five least expensive vehicles using some method. If the list is
    sorted in ascending order, then you could partition the data using the `Take(5)`
    method (defined in the following paragraphs), which will extract the first five
    items and discard the remaining.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are six partitioning operations that are used to split a source, with
    either of the two sections being returned. There are no partitioning Query Expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Skip`: Returns a collection that skips items up to a specified numeric position
    in the source sequence. Used when you need to skip the first N items in a source collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SkipLast`: Returns a collection that skips the last N items in the source sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SkipWhile`: Returns a collection that skips items in the source sequence that
    match a specified condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Take`: Returns a collection that contains the first N items in the sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TakeLast`: Returns a collection that contains the last N items in the sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TakeWhile`: Returns a collection that contains only those items that match
    the condition specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following example demonstrates various `Skip` and `Take` operations on an
    unsorted list of exam grades. Here, you use `Skip(1)` to ignore the highest grade
    in a sorted list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Chapter04\Examples` folder, add a new file called `LinqSkipTakeExamples.cs`
    and edit it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the relational `is` operator is used to exclude those less than `25`
    or greater than `75`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'By using `SkipLast`, you can show the bottom half of the results. Add the code
    for this as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `Take(2)` is used here to show the two highest grades:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the example produces this output, which is as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrated the various `Skip` and `Take` operations on an unsorted
    list of exam grades.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/TsDFk](https://packt.link/TsDFk).
  prefs: []
  type: TYPE_NORMAL
- en: Grouping Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`GroupBy` groups elements that share the same attribute. It is often used to
    group data or provide a count of items grouped by a common attribute. The result
    is an enumerable `IGrouping<K, V>` type collection, where `K` is the key type
    and `V` is the value type specified. `IGrouping` itself is enumerable as it contains
    all items that match the specified key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the next snippet, which groups a `List` of customer orders
    by name. In your `Chapter04\Examples` folder, add a new file called `LinqGroupByExamples.cs`
    and edit it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you have a list of `CustomerOrder` objects and want to group
    them by the `Name` property. For this, the `GroupBy` method is passed a `Func`
    delegate, which selects the `Name` property from each `CustomerOrder` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each item in the `GroupBy` result contains a `Key` (in this case, the customer''s
    `Name`). You can then sort the grouping item to show the `CustomerOrders` items
    sorted by `Quantity`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the data is first grouped by customer `Name` and then ordered by
    order `Quantity` within each customer grouping. The equivalent Query Expression
    is written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: You have now seen some of the commonly used LINQ operators. You will now bring
    them together in an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.04: Finding the Most Commonly Used Words in a Book'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 3*, *Delegates, Events, and Lambdas*, you used the `WebClient` class
    to download data from a website. In this exercise, you will use data downloaded
    from *Project Gutenberg*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Project Gutenberg is a library of 60,000 free eBooks. You can search online
    for Project Gutenberg or visit [https://www.gutenberg.org/](https://www.gutenberg.org/).
  prefs: []
  type: TYPE_NORMAL
- en: You will create a console app that allows the user to enter a URL. Then, you
    will download the book's text from the Project Gutenberg URL and use various LINQ
    statements to find the most frequent words in the book's text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you want to exclude some common stop-words; these are words such
    as `and`, `or`, and `the` that appear regularly in English, but add little to
    the meaning of a sentence. You will use the `Regex.Split` method to help split
    words more accurately than a simple space delimiter. Perform the following steps
    to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information on Regex can be found at [https://packt.link/v4hGN](https://packt.link/v4hGN).
  prefs: []
  type: TYPE_NORMAL
- en: In your `Chapter04\Exercises` folder, create a new `Exercise04` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class called `Program.cs` in the `Exercise04` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, define the `TextCounter` class. This will be passed the path to a file,
    which you will add shortly. This should contain common English stop-words:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Using `File.ReadAllLines`, add each word into the `_stopWords` `HashSet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: You have used a `HashSet`, as each stop-word is unique.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `Process` method is passed a string that contains the book's text
    and the maximum number of words to show.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Return the result as a `Tuple<string, int>` collection, which saves you from
    having to create a class or record to hold the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Now perform the query part. Use `Regex.Split` with the pattern `@"\s+"` to split
    all the words.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its simplest form, this pattern splits a string into a list of words, typically
    using a space or punctuation marks to identify word boundaries. For example, the
    string `Hello Goodbye` would be split into an array that contains two elements,
    `Hello` and `Goodbye`. The returned string items are filtered via `where` to ensure
    all stop-words are ignored using the `Contains` method. The words are then grouped
    by value, `GroupBy(t=>t)`, projected to a `Tuple` using the word as a `Key`, and
    the number of times it occurs using `grp.Count`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you sort by `Item2`, which for this `Tuple` is the word count, and
    then take only the required number of words:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Now start creating the main console app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Include a text file called `StopWords.txt` in the `Chapter04` source folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find `StopWords.txt` on GitHub at [https://packt.link/Vi8JH](https://packt.link/Vi8JH),
    or you can download any standard stop-word file, such as NLTK's [https://packt.link/ZF1Tf](https://packt.link/ZF1Tf).
    This file should be saved in the `Chapter04\Exercises` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `TextCounter` has been created, prompt the user for a URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Enter a valid address and create a new `WebClient` instance and download the
    data file into a temporary file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Perform extra processing to the text file before passing its contents to `TextCounter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'The Gutenberg text files contain extra details such as the author and title.
    These can be read by reading each line in the file. The actual text of the book
    doesn''t begin until finding a line that starts `*** START OF THE PROJECT GUTENBERG
    EBOOK`, so you need to read each line looking for this start message too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, append each line read into a `StringBuilder` instance, which is efficient
    for such string operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Now parse each line inside `tempFile`, looking for the `Author`, `Title`, or
    the `StartIndicator`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'If the book text is found, provide a summary of lines and characters read before
    calling the `counter.Process` method. Here, you want the top `50` words:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have the results, use a `foreach` loop to output the word count details,
    adding a blank line to the output after every third word:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the console app, using `https://www.gutenberg.org/files/64333/64333-0.txt`
    as an example URL produces the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio might show the following when the code is run for the first time:
    `warning SYSLIB0014: ''WebClient.WebClient()'' is obsolete: ''WebRequest, HttpWebRequest,
    ServicePoint, and WebClient are obsolete. Use HttpClient instead.`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a recommendation to use the newer `HttpClient` class instead of the
    `WebClient` class. Both are, however, functionally equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: The output shows a list of words found amongst the `4,063` lines of text downloaded.
    The counter shows that `one`, `new`, and `project` are the most popular words.
    Notice how `mr.`, `gutenberg-tm`, `it.`, and `_the` appear as words. This shows
    that the Regex expression used is not completely accurate when splitting words.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/Q7Pf8](https://packt.link/Q7Pf8).
  prefs: []
  type: TYPE_NORMAL
- en: An interesting enhancement to this exercise would be to sort the words by count,
    include a count of the stop words found, or find the average word length.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Aggregation operations are used to compute a single value from a collection
    of values in a data source. An example could be the maximum, minimum, and average
    rainfall from data collected over a month:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Average`: Calculates the average value in a collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Count`: Counts the items that match a predicate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Max`: Calculates the maximum value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Min`: Calculates the minimum value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sum`: Calculates the sum of values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example uses the `Process.GetProcess` method from the `System.Diagnostics`
    namespace to retrieve a list of processes currently running on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `Chapter04\Examples` folder, add a new file called `LinqAggregationExamples.cs`
    and edit it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'First, `Process.GetProcesses().ToList()` is called to retrieve a list of the
    active processes running on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the `Count` extension method obtains a count of the items returned. Count
    has an additional overload, which accepts a `Func` delegate used to filter each
    of the items to be counted. The `Process` class has a `PrivateMemorySize64` property,
    which returns the number of bytes of memory the process is currently consuming,
    so you can use that to count the `1,000,000` bytes of memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `Average` extension method returns the overall average of a specific
    value for all items in the `processes` list. In this case, you use it to calculate
    the average memory consumption, using the `PrivateMemorySize64` property again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PrivateMemorySize64` property is also used to calculate the maximum and
    minimum memory used for all processes, along with the total memory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have calculated the statistics, each value is written to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, the `Count` method returns the number of all processes
    and, using the `Predicate` overload, you `Count` those where the memory is less
    than 1,000,000 bytes (by examining the `process.PrivateMemorySize64` property).
    You can also see that `Average`, `Max`, `Min`, and `Sum` are used to calculate
    statistics for process memory usage on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The aggregate operators will throw `InvalidOperationException` with the error
    `Sequence contains no elements` if you attempt to calculate using a source collection
    that contains no elements. You should check the `Count` or `Any` methods prior
    to calling any aggregate operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `FormatBytes` formats the amounts of memory into their megabyte equivalents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the example produces results similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: From the output you will observe how the program retrieves a list of processes
    currently running on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/HI2eV](https://packt.link/HI2eV).
  prefs: []
  type: TYPE_NORMAL
- en: Quantifier Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quantifier operations return a `bool` that indicates whether `Predicate` condition.
    This is often used to verify any elements in a collection match some criteria,
    rather than relying on `Count`, which enumerates **all** items in the collection,
    even if you need just one result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quantifier operations are accessed using the following extension methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`All`: Returns `true` if **all** elements in the source sequence match a condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Any`: Returns `true` if **any** element in the source sequence matches a condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Contains`: Returns `true` if the source sequence contains the specified item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following card-dealing example selects three cards at random and returns
    a summary of those selected. The summary uses the `All` and `Any` extension methods
    to determine whether any of the cards were clubs or red and whether all cards
    were diamonds or an even number:'
  prefs: []
  type: TYPE_NORMAL
- en: In your `Chapter04\Examples` folder, add a new file called `LinqAllAnyExamples.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start by declaring an `enum` that represents each of the four suits in a pack
    of playing cards and a `record` class that defines a playing card:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'It is common practice to override the `ToString` method to provide a user-friendly
    way to describe an object''s state at runtime. Here, the card''s number and suit
    are returned as a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a class to represent a deck of cards (for ease, only create cards
    numbered one to 10). The deck''s constructor will populate the `_cards` collection
    with `10` cards for each of the suits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `Draw` method randomly selects a card from the `_cards` List, which
    it removes before returning to the caller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'The console app selects three cards using the deck''s `Draw` method. Add the
    code for this as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'To show a summary, use the `OrderByDescending` and `Select` operations to extract
    the user-friendly `ToString` description for each `PlayingCard`. This is then
    joined into a single delimited string as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `All` or `Any`, you can provide an overview of the cards and their score
    using the `Sum` of the card numbers. By using `Any`, you determine whether `PlayingCardSuit.Clubs`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, `Any` is used to see if `Hearts` or `Diamonds` suits, and therefore,
    are `Red`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next snippet, the `All` extension looks at every item in the collection
    and returns `true`, in this case, if `Diamonds`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'All is used again to see if all card numbers can be divided by two without
    a remainder, that is, whether they are even:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Conclude by using the `Sum` aggregation method to calculate the value of the
    cards in the hand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the console app produces output like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: The cards are randomly selected so you will have different hands each time you
    run the program. In this example, the score was `21`, which is often a winning
    hand in card games.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/xPuTc](https://packt.link/xPuTc).
  prefs: []
  type: TYPE_NORMAL
- en: Join Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Join operations are used to join two sources based on the association of objects
    in one data source with those that share a common attribute in a second data source.
    If you are familiar with database design, this can be thought of as a primary
    and foreign key relationship between tables.
  prefs: []
  type: TYPE_NORMAL
- en: A common example of a join is one where you have a one-way relationship, such
    as `Orders`, which has a property of type `Products`, but the `Products` class
    does not have a collection property that represents a backward relationship to
    a collection of `Orders`. By using a `Join` operator, you can create a backward
    relationship to show `Orders` for `Products`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two join extension methods are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Join`: Joins two sequences using a key selector to extract pairs of values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GroupJoin`: Joins two sequences using a key selector and groups the resulting items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example contains three `Manufacturer` records, each with a unique
    `ManufacturerId`. These numeric IDs are used to define various `Car` records,
    but to save memory, you will not have a direct memory reference from `Manufacturer`
    back to `Car`. You will use the `Join` method to create an association between
    the `Manufacturer` and `Car` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: In your `Chapter04\Examples` folder, add a new file called `LinqJoinExamples.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, declare the `Manufacturer` and `Car` records as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Main` entry point, create two lists, one for the manufacturers
    and the other to represent the `cars`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, there is no direct reference, but as you know, you can use `ManufacturerId`
    to link the two together using the `int` IDs. You can add the following code for
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, the `Join` operation has various parameters. You pass
    in the `cars` list and define which properties in the `manufacturer` and `car`
    classes should be used to create the join. In this case, `manufacturer.ManufacturerId
    = car.ManufacturerId` determines the correct join.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `manufacturer` and `car` arguments return a new anonymous type
    that contains the `manufacturer.Name` and `car.Name` properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the console app produces the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, each of the `Car` and `Manufacturer` instances has been joined
    correctly using `ManufacturerId`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The equivalent Query Expression would be as follows (note that in this case,
    it is a more concise format than the Query Operator syntax):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [http://packt.link/Wh8jK](http://packt.link/Wh8jK).
  prefs: []
  type: TYPE_NORMAL
- en: Before you finish exploring LINQ, there is one more area related to LINQ Query
    Expressions—the `let` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Using a let Clause in Query Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In earlier Query Expressions, you are often required to repeat similar-looking
    code in various clauses. Using a `let` clause, you can introduce new variables
    inside an Expression Query and reuse the variable''s value throughout the rest
    of the query. For example, consider the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Here, you are searching for a station with the `LVS` or `EUS` code or a name
    ending in `CROSS`. To do this, you must extract the last three characters using
    a range, `station[^3..]`, but you have duplicated that in two `where` clauses
    and the final projection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The station code and station names could both be converted into local variables
    using the `let` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Here, you have defined `code` and `name` using a `let` clause and reused them
    throughout the query. This code looks much neater and is also easier to follow
    and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/b2KiG](https://packt.link/b2KiG).
  prefs: []
  type: TYPE_NORMAL
- en: By now you have seen the main parts of LINQ. Now you will now bring these together
    into an activity that filters a set of flight records based on a user's criteria
    and provides various statistics on the subset of flights found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 4.01: Treasury Flight Data Analysis'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have been asked to create a console app that allows the user to download
    publicly available flight data files and apply statistical analysis to the files.
    This analysis should be used to calculate a count of the total records found,
    along with the average, minimum, and maximum fare paid within that subset.
  prefs: []
  type: TYPE_NORMAL
- en: The user should be able to enter a number of commands and each command should
    add a specific filter based on the flight's class, origin, or destination properties.
    Once the user has entered the required criteria, the `go` command must be entered,
    and the console should run a query and output the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data file you will use for this activity contains details of flights made
    by the UK''s HM Treasury department between January 1 to December 31, 2011 (there
    are 714 records.) You will need to use `WebClient.DownloadFile` to download the
    data from the following URL: [https://www.gov.uk/government/uploads/system/uploads/attachment_data/file/245855/HMT_-_2011_Air_Data.csv](https://www.gov.uk/government/uploads/system/uploads/attachment_data/file/245855/HMT_-_2011_Air_Data.csv)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The website might open differently for Internet Explorer or Google Chrome. This
    depends on how IE or Chrome are configured on your machine. Using `WebClient.DownloadFile`,
    you can download the data as suggested.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, the program should download data once and then reread it from the local
    filesystem each time it is started.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Preview of HM Treasury traffic data in Excel'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_04_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.6: Preview of HM Treasury traffic data in Excel'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once downloaded, the data should then be read into a suitable record structure
    before being added to a collection, which allows various queries to be applied.
    The output should show the following aggregate values for all rows that match
    the user''s criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: Record count
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Average fare
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum fare
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum fare
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The user should be able to enter the following console commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Class c`: Adds a class filter, where `c` is a flight class to search for,
    such as `economy` or `Business class`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Origin o`: Adds an `origin` filter, where o is the flight origin, such as
    `dublin`, `london`, or `basel`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Destination d`: Adds a destination filter, where `d` is the flight destination,
    such as `delhi`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clear`: Clears all filters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go`: Applies the current filters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a user enters multiple filters of the same type, then these should be treated
    as an `OR` filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `enum` can be used to identify the filter criteria type entered, as shown
    in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, a record can be used to store each filter type and comparison operand,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Each filter specified should be added to a `List<FilterCriteria>` instance.
    For example, if the user enters two origin filters, one for `dublin` and another
    for `london`, then the list should contain two objects, each representing an origin
    type filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user enters the `go` command, a query should be built that performs
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Extracts all `class` filter values into a list of strings (`List<string>`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracts all `origin` filter values into `List<string>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracts all `destination` filter values into `List<string>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses a `where` extension method to filter the fight records for each criteria
    type specified using the `List<string>`. It contains a method to perform a case-insensitive
    search.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder called `Activities` in the `Chapter04` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new folder called `Activity01` to that new folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class file called `Flight.cs`. This will be a `Record` class with
    fields that match those in the flight data. A `Record` class should be used as
    it offers a simple type purely to hold data rather than any form of behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class file called `FlightLoader.cs`. This class will be used for
    downloading or importing data. `FlightLoader` should include a list of the field
    index positions within the data file, to be used when reading each line of data
    and splitting the contents into a string array, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Now for the `FlightLoader` implementation, use a `static` class to define the
    index of known field positions in the data file. This will make it easier to handle
    any future changes in the layout of the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, a `Download` method should be passed a URL and destination file. Use `WebClient.DownloadFile`
    to download the data file and then defer to `Import` to process the downloaded
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An `Import` method is to be added. This is passed the name of the local file
    to import (downloaded using the `Import` method) and will return a list of `Flight` records.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a class file called `FilterCriteria.cs`. This should contain a `FilterCriteriaType`
    `enum` definition. You will offer filters based on the flight's class, origin,
    and destination properties, so `FilterCriteriaType` should represent each of these.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, for the main filtering class, add a new class file called `FlightQuery.cs`.
    The constructor will be passed a `FlightLoader` instance. Within it, create a
    list named `_flights` to contain the data imported via `FlightLoader`. Create
    a `List<FilterCriteria>` instance named `_filters` that represent each of the
    criteria items that are added, each time the user specifies a new filter condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Import` and `Download` methods of `FlightLoader` should be called by the
    console at startup, allowing previously downloaded data to be processed, via the
    `_loader` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Count` variable that returns the number of flight records that have
    been imported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user specifies a filter to add, the console will call `AddFilter`,
    passing an `enum` to define the criteria type and the string value being filtered
    for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RunQuery` is the main method that returns those flights that match the user''s
    criteria. You need to use the built-in `StringComparer.InvariantCultureIgnoreCase`
    comparer to ensure string comparison ignores any case differences. You define
    a query variable that calls `Select` on the flights; at the moment, this would
    result in a filtered result set.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each of the types of filter available is string-based, so you need to extract
    all the string items. If there are any items to filter, you add an extra `Where`
    call to the query for each type (`Class`, `Destination`, or `Origin`). Each `Where`
    clause uses a `Contains` predicate, which examines the associated property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add the two helper methods used by `RunQuery`. `GetFiltersByType` is passed
    each of the `FilterCriteriaType` enums that represent a known type of criteria
    type and finds any of these in the list of filters using the `.Where` method.
    For example, if the user added two `Destination` criteria such as India and Germany,
    this would result in the two strings `India` and `Germany` being returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FormatFilters` simply joins a list of `filterValues` strings into a user-friendly
    string with the word `OR` between each item, such as `London OR Dublin`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now create the main console app. Add a new class called `Program.cs`, which
    will allow the user to input requests and process their commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hardcode the download URL and destination filename.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the main `FlightQuery` class, passing in a `FlightLoader` instance. If
    the app has been run before, you can `Import` the local flight data, or use `Download`
    if not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show a summary of the records imported and the available commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user enters a command, there might also be an argument, such as `destination
    united kingdom`, where `destination` is the command and `united kingdom` is the
    argument. To determine this, use the `IndexOf` method to find the location of
    the first space character in the input, if any.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the `go` command, call `RunQuery` and use various aggregation operators
    on the results returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the remaining commands, clear or add filters as requested. If the `Clear`
    command is specified, call the query's `ClearFilters` method, which will clear
    the list of criteria items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a `class` filter command is specified, call `AddFilter` specifying the `FilterCriteriaType.Class
    enum` and the string `Argument`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The same pattern should be used for `Origin` and `Destination` commands. Call
    `AddFilter`, passing in the required `enum` value and the argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The console output should be similar to the following, here listing the commands
    available to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'The user should be able to add two class filters, for `economy` or `Business
    Class` (all string comparisons should be case-insensitive), as shown in the following
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the user should be able to add an origin filter as follows (this
    example is for `london`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the destination filter should look like this (this example is for `zurich`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'Entering `go` should show a summary of all filters specified, followed by the
    results for flights that match the filters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you saw how the `IEnumerable` and `ICollection` interfaces
    form the basis of .NET data structures, and how they can be used to store multiple
    items. You created different types of collections depending on how each collection
    is meant to be used. You learned that the `List` collection is most extensively
    used to store collections of items, particularly if the number of elements is
    not known at compile time. You saw that the `Stack` and `Queue` types allow the
    order of items to be handled in a controlled manner, and how the `HashSet` offers
    set-based processing, while the `Dictionary` stores unique values using a key
    identifier.
  prefs: []
  type: TYPE_NORMAL
- en: You then further explored data structures by using LINQ Query Expressions and
    Query Operators to apply queries to data, showing how queries can be altered at
    runtime depending on filtering requirements. You sorted and partitioned data and
    saw how similar operations can be achieved using both Query Operators and Query
    Expressions, each offering a preference and flexibility based on context.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will see how parallel and asynchronous code can be
    used to run complex or long-running operations together.
  prefs: []
  type: TYPE_NORMAL

- en: 9\. Creating API Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In modern software development, most logic is served through distinct web services.
    This is essential to be able to both call and make new web services as a developer.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will be creating your own RESTful web service using the
    ASP.NET Core Web API template. You will learn not only how to do it but also some
    of the best practices for designing and building a Web API. You will also learn
    how to protect an API using Azure Active Directory (AAD), centralize error handling,
    troubleshoot errors, generate documentation, and more.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to create professional Web APIs
    that are secured with AAD, hosted on the cloud, scalable, and able to serve thousands
    of users.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core is a part of the .NET Core framework that is targeted at creating
    web apps. Using it, you can create both frontend (such as Razor or Blazor) and
    backend (such as Web API or gRPC) applications. However, in this chapter, you
    will be focusing on creating RESTful Web APIs. Creating a new web service for
    the first time might sound like a daunting task, but don't worry too much; for
    most scenarios, there is a template to get you started. In this chapter, you will
    create a few Web APIs using ASP.NET Core 6.0.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core Web API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 8*, *Creating and Using Web API Clients*, you learned how to call
    RESTful APIs. In this chapter, you will be making one. Web API is a template for
    creating RESTful Web APIs in .NET. It contains routing, Dependency Injection (DI),
    an example controller, logging, and other useful components to get you started.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a New Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to create a new Web API, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it after a project you want to create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to that directory using the `cd` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the following at the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That is all it takes to get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see whether this is executing as expected, run the following and see your
    application come to life (*Figure 9.1*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 9.1: Terminal window showing the port the application is hosted on'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.1: Terminal window showing the port the application is hosted on'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 9.1*, you will see port 7021 for the `https` version of the application.
    There may be multiple ports, especially if you are hosting both `HTTP` and `HTTPs`
    versions of an application. However, the key thing to remember is that you can
    the port where an application runs (for example, through the command line).
  prefs: []
  type: TYPE_NORMAL
- en: A port is a channel through which you allow a certain application to be called
    by all other applications. It is a number that appears after a base URL and it
    allows a single application through. Those applications don't have to be outsiders;
    the same rules also apply to internal communication.
  prefs: []
  type: TYPE_NORMAL
- en: Localhost refers to an application hosted locally. Later in this chapter, you
    will configure the service to bind to whatever port you want.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are 65,535 ports available on a single machine. Ports zero through 1023
    are called well-known ports because usually, the same parts of the system listen
    on them. Typically, if a single application is hosted on one machine, the port
    will be 80 for `http` and 443 for `https`. If you are hosting multiple applications,
    the ports will vary drastically (usually starting from port 1024).
  prefs: []
  type: TYPE_NORMAL
- en: Web API Project Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every Web API is made of at least two classes—`Program` and one or more controllers
    (`WeatherForecastController` in this case):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Program: This is the **starting point** of an application. It serves as a low-level
    runner of an application and manages dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Controller: This is a `[Model]Controller`. In this example case, `WeatherForecastController`
    will be called using a `/weatherforecast` endpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.2: The newly created MyProject structure in VS Code with key parts
    highlighted'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.2: The newly created MyProject structure in VS Code with key parts
    highlighted'
  prefs: []
  type: TYPE_NORMAL
- en: An In-Depth Look at WeatherForecastController
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The controller from the default template is preceded by two attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[ApiController]`: This attribute adds common, convenient (yet opinionated)
    Web API functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[Route("[controller]")]`: This attribute is used to provide a routing pattern
    of a given controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, in cases where these attributes are absent or the request is complex,
    you would need to validate an incoming HTTP request yourself without routing out
    of the box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This controller has `/WeatherForecast` as the route. The route is usually made
    of the word that precedes the word `Controller` unless specified otherwise. When
    developing APIs professionally, or when you have a client- and server-side application,
    it is recommended to preappend `/api` to the route, making it `[Route("api/[controller]")]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you''ll learn about the controller class declaration. Common controller
    functions come from a derived `ControllerBase` class and a few components (usually
    a logger) and services. The only interesting bit here is that, instead of `Ilogger`,
    you use `ILogger<WeatherForecastController>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The reason behind using the generic part is solely for getting the context from
    the place where the log was called. Using a generic version of a logger, you use
    a fully qualified name of a class that is supplied as a generic argument. Calling
    `logger.Log` will prefix it with a context; in this case, it will be `Chapter09.Service.Controllers.WeatherForecastController[0]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, look at the following controller method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `[HttpGet]` attribute binds the `Get` method with the root controller endpoint''s
    (`/WeatherForecast`) HTTP GET method. There is a version of that attribute for
    every HTTP method, and they are `HttpGet`, `HttpPost`, `HttpPatch`, `HttpPut`,
    and `HttpDelete`. To check whether the service works, run the application using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `-urls=https://localhost:7021/` argument is not a requirement. This
    argument simply makes sure that the port picked by .NET is the same as is indicated
    in this example during execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the output, navigate to `https://localhost:7021/weatherforecast/` in
    the browser. This will return a single default `WeatherForecast` upon calling
    HTTP GET:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[{"date":"0001-01-01T00:00:00","temperatureC":0,"temperatureF":32,"summary":null}].`'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When `https://localhost:7021/weatherforecast/` displays an error message (`localhost
    refused to connect`), it means that the application is likely running, but on
    a different port. So, always remember to specify a port as described in the *Creating
    a New Project* section (*Step 5*).
  prefs: []
  type: TYPE_NORMAL
- en: Responding with Different Status Codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Find out what status codes can `public IEnumerable<WeatherForecast> Get()`
    respond with. Using the following steps, you can play around with it and inspect
    what happens in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to `https://localhost:7021/weatherforecast/` in the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on `More tools`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Developer tools` option. Alternatively, you can use the `F12` key
    to launch the developer tools.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on the `Network` tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the `Headers` tab. You will see that `https://localhost:7021/weatherforecast/`
    responds with `200` `Status Code`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.3: Dev tools Network tab—inspecting response headers of a successful
    response'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.3: Dev tools Network tab—inspecting response headers of a successful
    response'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new endpoint called `GetError` that throws an exception if a rare
    circumstance arises while a program is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, call `https://localhost:7021/weatherforecast/error`. It responds with
    a status code of `500`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.4: Dev tools Network tab—inspecting a response with an exception'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.4: Dev tools Network tab—inspecting a response with an exception'
  prefs: []
  type: TYPE_NORMAL
- en: 'What should you do if you want a different status code to be returned? For
    that, the `BaseController` class contains utility methods for returning any kind
    of status code you require. For example, if you wanted to explicitly return an
    OK response, instead of returning a value right away, you could return `Ok(value)`.
    However, if you try changing the code, you will get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This does not work because you do not return an HTTP status code from a controller;
    you either return some value or throw some error. To return any status code of
    your choice, you need to change the return type. For that reason, a controller
    should never have a return type of some value. It should always return the `IActionResult`
    type—a type that supports all status codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create one more method for getting the weather for any day of the week. If
    the day is not found (a value less than `1` or more than `7`), you will explicitly
    return `404 – not found`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you added one new `{day}` at the end of the endpoint. This is a placeholder
    value, which comes from a matching function argument (in this case, `day`). Rerunning
    the service and navigating to `https://localhost:7021/weatherforecast/weekday/8`
    will result in a `404 – not found` status code because it is more than the max
    allowed day value, which is `7`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5: The response to finding a weather forecast for a non-existent
    day of the week'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.5: The response to finding a weather forecast for a non-existent day
    of the week'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/SCudR](https://packt.link/SCudR).
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the theoretical portion of this topic. In the following section,
    you will put this into practice with an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.01: .NET Core Current Time Service'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have managed to run a Web API once, adding new controllers should
    be trivial. Often, whether a service is running or not, it is checked using the
    most basic logic; whether it is returning OK or getting the current `DateTime`
    value. In this exercise, you will create a simple current time service returning
    the current time in ISO standard. Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new controller called `TimeController` to get the local time and further
    add functions for testing purposes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The controller shown here isn't just for testing; it acts as business logic
    too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an endpoint for HTTP GET called `GetCurrentTime` that points to the `time/current`
    route. You will use it to get the current time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Return the current `DateTime` converted to a string in ISO format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to `https://localhost:7021/time/current` and you should see the following
    response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned in the *Web API Project Structure* section, you can use the endpoint
    to determine whether a service is running or not. If it is running, then you will
    get the `DateTime` value, which you saw in the preceding output. If it is not
    running, then you would get a response with a status code of `404 – not found`.
    If it is running but with problems, then you would get the `500` status code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/OzaTd](https://packt.link/OzaTd).
  prefs: []
  type: TYPE_NORMAL
- en: So far, all your focus was on a controller. It's time you shift your attention
    to another crucial part of a Web API—the `Program` class.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping a Web API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Program` class wires up the whole API together. In layman's terms, you
    register the implementations for all the abstractions used by controllers and
    add all the necessary middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In *Chapter 2*, *Building Quality Object-Oriented Code*, you explored the concept
    of DI. In *Chapter 7*, *Creating Modern Web Applications with ASP.NET*, you had
    a look at an example of DI for logging services. In this chapter, you will get
    hands-on experience in DI and the Inversion of Control (IoC) container—a component
    used to wire up and resolve all the dependencies in a central place. In .NET Core
    and later, the default container is `Microsoft.Extensions.DependencyInjection`.
    You will learn more about that a bit later.
  prefs: []
  type: TYPE_NORMAL
- en: Program.cs and Minimal API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest Web API in .NET 6 looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is a minimal API because it makes use of the top-level statements feature.
    Prior to .NET 6, you would have two methods within a `Startup` class (`Configure`
    and `ConfigureService`) and a `Program` class. Now you have a single file, `Program.cs`,
    and no classes or methods. You can still use the old way of starting an application.
    In fact, .NET 6 will generate similar classes under the hood. However, if you
    are making a new app in .NET 6, then using a minimal API should be preferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Break down the preceding code snippet. To start the application, you first
    need to build it. So, you will create a builder using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`builder.Services` specifies which services are to be injected. In this case,
    you registered the implementation of the controllers. So, here you have just one
    controller calling—that is, `WeatherForecastController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When you use `builder.Build()`, you can access the `app` object and further
    configure the application by adding middleware. For example, to add controller
    routing, call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, `builder.Environment.IsDevelopment()` checks whether the environment
    is developed. If it is developed, it calls `app.UseDeveloperExceptionPage();`,
    which adds detailed errors when something fails.
  prefs: []
  type: TYPE_NORMAL
- en: Logging is not mentioned anywhere; yet you still use it. A common pattern is
    to group all the related injections under the same extension method for `IServiceCollection`.
    An example of an extension method for all the controller-related functionality,
    including logging, is the `AddControllers` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'You already saw the logging messages sent through the console logger right
    after you ran the API. Under the hood, the `builder.Services.AddLogging` method
    is called. This method clears all the logging providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the application now, you will not see anything appear in the console
    (*Figure 9.6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6: Running an application with no logs displayed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.6: Running an application with no logs displayed'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you modify `AddLogging` to include `Console` and `Debug` logging
    in the following way, you will see the logs as in *Figure 9.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add an error logging functionality to the error endpoint of `WeatherForecastController`.
    This will throw an exception when a rare circumstance arises while a program is
    running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the API with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, call `https://localhost:7021/weatherforecast/error` and this will show
    the logged message (compare *Figure 9.6* and *Figure 9.7*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7: The error message, Whoops, displayed on the terminal'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.7: The error message, Whoops, displayed on the terminal'
  prefs: []
  type: TYPE_NORMAL
- en: The Inner Workings of the AddLogging Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How does the `AddLogging` method work? The decompiled code of the `AddLogging`
    method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It is best practice not to initialize loggers by yourself. `ILoggerFactory`
    provides that functionality as a single place from which you may create loggers.
    While `ILoggerFactory` is an interface, `LoggerFactory` is an implementation of
    that interface. `AddSingleton` is a method that specifies that a single instance
    of `LoggerFactory` will be created and used whenever `ILoggerFactory` is referenced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the question arises: why wasn''t `ILoggerFactory` used in a controller?
    `ILoggerFactory` is used under the hood when resolving an implementation of a
    controller. When exposing a controller dependency such as a `logger`, you no longer
    need to care about how it gets initialized. This is a great benefit because it
    makes the class holding a dependency both more simple and more flexible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do want to use `ILoggerFactory` instead of `Ilogger`, you could have
    a constructor accepting the factory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then use it to create a `logger`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This latter `logger` functions the same as the former.
  prefs: []
  type: TYPE_NORMAL
- en: This section dealt with the `AddSingleton` method for managing service dependencies
    in a central place. Proceed to the next section to solve dependency complexities
    with DI.
  prefs: []
  type: TYPE_NORMAL
- en: The Lifetime of an Injected Component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `AddSingleton` method is useful because complex applications have hundreds,
    if not thousands, of dependencies often shared across different components. It
    would be quite a challenge to manage the initialization of each. DI solves that
    problem by providing a central place for managing dependencies and their lifetimes.
    Before proceeding further, you'll need to learn more about DI lifetimes.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three injected object lifetimes in .NET:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Singleton: Object initialized once per application lifetime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scoped: Object initialized once per request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transient: Object initialized every time it is referenced'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To better illustrate DI and different service lifetimes, the next section will
    refactor the existing `WeatherForecastController` code.
  prefs: []
  type: TYPE_NORMAL
- en: DI Examples within a Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A service is a holder for logic at the highest level. By itself, a controller
    should not do any business logic and just delegate a request to some other object
    that is able to handle it. Apply this principle and refactor the `GetWeekday`
    method using DI.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create an interface for the service to which you will move all the logic.
    This is done to create an abstraction for which you will later provide an implementation.
    An abstraction is needed because you want to move out as much logic as possible
    from the controller into other components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you move a portion away from a controller, you would like to handle error
    scenarios as well. In this case, if a provided day is not between `1` and `7`,
    you will return a `404 – not found` error. However, at the service level, there
    is no concept of HTTP status codes. Therefore, instead of returning an HTTP message,
    you will be throwing an exception. For the exception to be handled properly, you
    will create a custom exception called `NoSuchWeekdayException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a class that implements the service. You will move your code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The only difference here as compared to the previous code is that, instead of
    returning `NotFound`, you have used `throw new NoSuchWeekdayException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, inject the service into a controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The cleaned-up controller method, in the *Responding with Different Status
    Codes* section, with minimum business logic, now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It might still seem like the same code; however, the key point here is that
    the controller no longer does any business logic. It simply maps results from
    the service back to an HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In the *Error Handling* section, you will return to this and further remove
    code from the controller, making it as light as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this code, you would get the following exception when calling any
    of the controller''s endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This exception shows that there is no way that `WeatherForecastController`
    can figure out the implementation for `IWeatherForecastService`. So, you need
    to specify which implementation fits the needed abstraction. For example, this
    is done inside the `Program` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `AddSingleton` method reads this as for the `IWeatherForecastService`, `WeatherForecastService`
    **implementation**. In the following paragraphs, you will learn how exactly it
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a service to be injected, you can explore what effect each
    injection has on service calls when calling the following controller method. For
    that point, you will slightly modify `WeatherForecastService` and `WeatherForecastController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within `WeatherForecastService`, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inject a `logger`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When the service is initialized, log a random `Guid` that changes the constructor
    to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Within `WeatherForecastController`, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inject the second instance of `WeatherForecastService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Call both instances when getting a weekday:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `GetWeekday` method is called twice because it will help illustrate DI lifetimes
    better. Now it is time to explore different DI lifetimes.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Register the service as a singleton in `Program.cs` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'After calling the application, you will see the following logs generated while
    running the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you call the application again, you will see the same GUID logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This proves that the service was initialized only once.
  prefs: []
  type: TYPE_NORMAL
- en: Scoped
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Register the service as scoped in `Program.cs` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After calling the application, you will see the following logs generated while
    running the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'On calling `WeatherForecastService` again, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is a different GUID that has been logged. This proves that the service
    was initialized once per request, but a new instance was initialized on a new
    request.
  prefs: []
  type: TYPE_NORMAL
- en: Transient
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Register the service as transient in `Program.cs` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After calling the application, you should see the following in the logs generated
    while running the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: That there are two different GUIDs logged proves that both services were initialized
    using different instances. It is possible to use DI and IoC outside of the Web
    API. DI through IoC is just another library with a few extras given by the Web
    API template.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use IoC outside of ASP.NET Core, install the following NuGet
    (or other IoC container): `Microsoft.Extensions.DependencyInjection`.'
  prefs: []
  type: TYPE_NORMAL
- en: TryAdd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, you have wired implementations to their abstractions using an `Add[Lifetime]`
    function. However, that is not the best practice in most cases. Usually, you'll
    want a single implementation to be wired for a single abstraction. However, if
    you repeatedly call `Add[Lifetime]`, for example, the `AddSingleton` function,
    you will create a collection of implementing instances (duplicates) underneath.
    This is rarely the intention and therefore you should protect yourself against
    that.
  prefs: []
  type: TYPE_NORMAL
- en: The cleanest way to wire dependencies is through the `TryAdd[Lifetime]` method.
    In the case of a duplicate dependency, it will simply not add a duplicate. To
    illustrate the difference between the two versions of DIs, compare the injected
    service counts using different methods. Here, you will inject two identical services
    as a singleton.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here you are using the `Add[Lifetime]` service as a singleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you are using the `TryAdd[Lifetime]` service as a singleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Observe that `Add[Lifetime]` added a duplicate in the output, while `TryAdd[Lifetime]`
    did not. Since you don't want duplicate dependencies, it's recommended that you
    use the `TryAdd[Lifetime]` version.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do an injection for a concrete class as well. Calling `builder.Services.AddSingleton<WeatherForecastService,
    WeatherForecastService>();` is a valid C# code; however, it does not make much
    sense. DI is used to inject an implementation into an abstraction. This will not
    work when bootstrapping the service because the following error will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The error occurs because there is still an abstraction-implementation binding
    to be provided. It would only work if a concrete implementation, rather than an
    abstraction, were exposed in the constructor of the controller. In practice, this
    scenario is rarely used.
  prefs: []
  type: TYPE_NORMAL
- en: You have learned that the cleanest way of wiring dependencies is through the
    `TryAdd[Lifetime]` method. You will now create a service that accepts primitive
    arguments (`int` and `string`) and see how it manages its non-primitive dependencies
    in an IoC container.
  prefs: []
  type: TYPE_NORMAL
- en: Manual Injection Using an IoC Container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are scenarios in which you will need to create an instance of a service
    before injecting it. An example use case could be a service with primitive arguments
    in a constructor, in other words, a weather forecast service for a specific city
    with a configured interval for forecast refreshes. So, here, you cannot inject
    a string or an integer, but you can create a service with an integer and a string
    and inject that instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify `WeatherForecastService` with the said features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Return to the `Program` class and try to inject a service for `New York` with
    a refresh interval of `5` (hours):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In order to inject the service, as always, you use a version of the `builder.Services.Add[Lifetime]`
    method. However, on top of that, you provided an argument—a delegate specifying
    how a service should be created. The service provider can be accessed by calling
    the `BuildServices` method on `IServiceCollection`. This delegate takes `IServiceProvider`
    as input and uses it to build a new service.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you did not use it and thus named the argument after the discard
    operator (`_`). The remaining contents of the function are just a simple return
    with the values from the previous paragraph (for brevity, you will not add any
    extra logic to use the new values). If you had a more complex service, for example,
    a service that requires another service, you could call the `.GetService<ServiceType>`
    method from `IServiceProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Build` and `Create` are two common method names. However, they should not
    be used interchangeably. Use `Build` when building a single dedicated object,
    while `Create` is used when the intention is to produce many objects of diverse
    types.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/fBFRQ](https://packt.link/fBFRQ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.02: Displaying Current Time in a Country API Time Zone'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you are tasked with creating a Web API that provides the date
    and time at different time zones of UTC. Through a URL, you will pass a number
    between `-12` and `+12` and return the time in that time zone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an interface called `ICurrentTimeProvider` with a method called `DateTime
    GetTime(string timezone)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class called `CurrentTimeUtcProvider` implementing `ICurrentTimeProvider`
    to implement the logic required for the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the method of converting the current `DateTime` to `Utc` and then
    offsetting that based on the time zone passed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `CurrentTimeProviderController` controller to make sure it accepts
    `ICurrentTimeProvider` in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `HttpGet` endpoint called `IActionResult Get(string timezoneId)`,
    which calls the current time provider and returns the current time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that `{timezoneId}` is not specified in the `HttpGet` attribute.
    This is because the pattern is used for REST parts on an endpoint; however, in
    this scenario, it is passed as an argument of a query string. If a string contains
    whitespaces or other special characters, it should be encoded before being passed.
    You can URL-encode a string using this tool: [https://meyerweb.com/eric/tools/dencoder/](https://meyerweb.com/eric/tools/dencoder/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Program` class, inject the service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here, you injected the service as a singleton because it is stateless.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the `https://localhost:7021/CurrentTime?timezone=[yourtimezone]` endpoint
    with a `timezoneid` value of your choice. For example, you can call the following
    endpoint: `https://localhost:7021/CurrentTime?timezoneid=Central%20Europe%20Standard%20Time`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will get the response showing the date and time at that time zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/iqGJL](https://packt.link/iqGJL).
  prefs: []
  type: TYPE_NORMAL
- en: OpenAPI and Swagger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OpenAPI is a **REST API** description format. It is a specification of an API
    with the endpoints it has, the authentication methods it supports, the arguments
    it accepts, and the example requests and responses it informs. The REST API works
    with both JSON and XML formats; however, JSON is chosen frequently. Swagger is
    a collection of tools and libraries implementing the OpenAPI standard. Swagger
    generates two things:'
  prefs: []
  type: TYPE_NORMAL
- en: A web page to make calls to your API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate client code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In .NET, there are two libraries for working with Swagger:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NSwag`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Swashbuckle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Swagger Swashbuckle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, you will use `Swashbuckle` to demonstrate one of many ways
    to test APIs and generate API documentation. So, install the `Swashbuckle.AspNetCore`
    package by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Just before the `builder.Build()` call, add the following line of code in `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This injects the Swagger services needed to generate the Swagger schema and
    the documentation test page.
  prefs: []
  type: TYPE_NORMAL
- en: 'After `builder.Build()` in `Program.cs`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The first line supports reaching the OpenAPI Swagger specification and the second
    one allows accessing the specification on a user-friendly web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'When you navigate to `https://localhost:7021/swagger/`, you will see the following
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8: A user-friendly Swagger endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.8: A user-friendly Swagger endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on any of the endpoints will allow you to send an HTTP request to them.
    This page can be configured to include common information about the project, such
    as the contact information, licenses it is under, description, terms of services,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of Swagger do not end here. If you had comments, you could include
    them on this page as well. You could also include all the possible response types
    that the endpoint produces. You can even include example requests and set them
    as defaults when calling an API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new endpoint to save a weather forecast and then another one to retrieve
    it. Document both the methods one by one. So, first, update the `IWeatherForecastService`
    interface to include the two new methods, `GetWeekday` and `GetWeatherForecast`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add implementations of those methods to `WeatherForecastService`. To
    save the weather forecast, you will need storage, and the simplest storage would
    be `IMemoryCache`. Here, you will need a new field for `IMemoryCache`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, update the constructor to inject `IMemoryCache`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create the `SaveWeatherForecast` method to save a weather forecast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `GetWeatherForecast` method to get a weather forecast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go back to `WeatherForecastController` and create an endpoint for each
    method so that you can test it using the HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Please note that when creating a new weather forecast, you return a `CreatedAtAction`
    result. This returns an HTTP status code of `201` with a URI used to get the created
    resource. It was specified that, in order to get the created forecast later, you
    can use `GetWeatherForecast`. The anonymous `new { date = weatherForecast.Date.ToShortDateString()}`
    object specifies the arguments needed to call that action. You passed `Date.ToShortDateString()`
    and not just a date because a full `DateTime` contains more than what you need.
    Here, you need only a date; therefore, you explicitly cut what you don't need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Document each method by describing what it does and what status codes it can
    return. You will then add this information above each endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You have now added XML docs to the two endpoints. Using `ProducesResponseType`,
    you specified what status codes the endpoints could return. If you refresh the
    Swagger page, you will see the `SaveWeatherForecast` endpoint in Swagger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9: SaveWeatherForecast endpoint in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.9: SaveWeatherForecast endpoint in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you refresh the Swagger page, you will see the `GetWeatherForecast` endpoint
    in Swagger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10: GetWeatherForecast endpoint in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.10: GetWeatherForecast endpoint in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the status code addition, but where did the comments go? By default,
    Swagger does not pick XML docs. You need to specify what it has to do by configuring
    your project file. To do so, add the following piece of code inside `<Project>`
    below the property group of a target framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 9.11: Swagger configuration to include XML docs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.11: Swagger configuration to include XML docs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, go to the `Program.cs` file and replace `service.AddSwaggerGen()` with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the last piece of code needed to include XML comments in the Swagger
    docs. Now, refresh the page and you should see the comments included:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12: WeatherForecast Swagger docs with XML docs included'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.12: WeatherForecast Swagger docs with XML docs included'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/iQK5X](https://packt.link/iQK5X).
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot more that you can do with Swagger; you can include an example
    request and response and give default values to parameters. You can even create
    your own API specification standards and decorate a project namespace to apply
    the same conventions to every controller and their endpoints, but that is beyond
    the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to mention is the ability to generate a client out of the Swagger
    docs. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In order to download the `swagger.json` OpenAPI documentation artifact, navigate
    to `https://localhost:7021/swagger/v1/swagger.json`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click anywhere on the page and select the `Save as` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, press the `Enter` key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will use this JSON to generate client code. So, register and log in
    to [https://app.swaggerhub.com/home](https://app.swaggerhub.com/home) (you can
    use your GitHub account).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the new window, click the `Create New` button (`1`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.13: SwaggerHub and the Import API window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.13: SwaggerHub and the Import API window'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Import and document API` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Swagger file you have just downloaded by clicking the `Browse` button (`2`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, hit the `UPLOAD FILE` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When you select the file, the `IMPORT` button (`3` in *Figure 9.13*) changes
    to the `UPLOAD FILE` button (`3` in *Figure 9.14*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14: SwaggerHub IMPORT button changed to UPLOAD FILE button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.14: SwaggerHub IMPORT button changed to UPLOAD FILE button'
  prefs: []
  type: TYPE_NORMAL
- en: On the next screen, leave the name of the service and the version with default values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, click the `IMPORT DEFINITION` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.15: SwaggerHub import Swagger service definition'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.15: SwaggerHub import Swagger service definition'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the `Swagger.json` API scheme is imported, you can use it to generate
    a strongly typed C# client code to call the API. So, click the `Export` option
    (`1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click the `Client SDK` option (`2`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the `csharp` option (`3`):![Figure 9.16: Exporting a new client in the
    C# client from SwaggerHub'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16835_09_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.16: Exporting a new client in the C# client from SwaggerHub'
  prefs: []
  type: TYPE_NORMAL
- en: A `csharp-client-generated.zip` file will be downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: Extract the `csharp-client-generated.zip` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate the extracted folder and open the `IO.Swagger.sln` file. You should
    see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.17: Files generated for the client using SwaggerHub'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.17: Files generated for the client using SwaggerHub'
  prefs: []
  type: TYPE_NORMAL
- en: The generated client code not only has a strongly typed HTTP client but also
    includes tests. It also has a `README.md` file on how to call the client and many
    more common development scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the question that arises is whether you should use Swagger when you already
    have Postman. While Postman is one of the most popular tools used for testing
    different kinds of Web APIs, Swagger is so much more than just a client to test
    whether the API works. Primarily, Swagger is a tool for documenting the API. From
    a conventional code, it allows you to generate all that you might need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Test page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the client code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the documentation page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Till now, you have learned that Swagger is a collection of tools and libraries
    implementing OpenAPI standards that are helpful for testing and documenting your
    APIs. You can now proceed to grasp error handling.
  prefs: []
  type: TYPE_NORMAL
- en: Error Handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have already learned that the code within a controller should be as minimalistic
    as possible due to it being the highest level in code (direct call). Specific
    error handling should not be included in the controller code because it adds complexity
    to already-complex code. Fortunately, there is a way to map exceptions to HTTP
    status codes and set up all of them in one place—that is, via the `Hellang.Middleware.ProblemDetails`
    package. To do so, first install the package by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Map `NoSuchWeekdayException` to HTTP status code `404`. In the `Program.cs`
    file, before `builder.Build()`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This not only converts an exception to the right status code but also uses `ProblemDetails`—a
    standard response model based on RFC 7807—to provide faults in an HTTP response.
    Also, this excludes exception details in the error message.
  prefs: []
  type: TYPE_NORMAL
- en: When developing a service locally, knowing what went wrong is invaluable. However,
    exposing the stack trace and other information needed to determine the error can
    expose exploits of your Web API. Thus, it's better to hide it when moving toward
    the release stage. By default, the `Hellang` library already excludes the exception
    details in upper environments, so it is better that you don't include that line.
    For demo purposes and a simplified response message, it was included here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you build a demo, you also need to turn off the default developer exceptions
    page because it overrides the exceptions in `ProblemDetails`. Simply remove the
    following block of code from the `Configure` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Since you already have a central place for handling `NoSuchWeekdayException`,
    you can simplify the controller method for getting `WeatherForecast` for a given date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'When calling the endpoint with an invalid day value (for example, `9`), you
    get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This centralized error handling approach allows the controllers to be rid of
    all the `try-catch` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/CntW6](https://packt.link/CntW6).
  prefs: []
  type: TYPE_NORMAL
- en: You can now map exceptions to HTTP status codes and set them all up in one place.
    This next section will take a look at another addition to an API, which is request validation.
  prefs: []
  type: TYPE_NORMAL
- en: Request Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another useful addition to an API is request validation. By default, ASP.NET
    Core has a request validator based on the required attributes. However, there
    might be complex scenarios where a combination of properties results in an invalid
    request or a custom error message for which validation is required.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET has a great NuGet package for that: `FluentValidation.AspNetCore`. Perform
    the following steps to learn how to carry out request validation. Before you continue,
    install the package by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This package allows registering custom validators per model. It makes use of
    existing ASP.NET Core middleware, so all you must do is inject a new validator.
    Create a validator for `WeatherForecast`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A validator should inherit the `AbstractValidator` class. This is not obligatory,
    but it is highly recommended because it implements the common methods for functionality
    and has a default implementation for generic validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Through a generic argument, you specified that this is a validator for `WeatherForecast`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the validation itself. This is done in a constructor of a validator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '`FluentValidation` is a .NET library and is all about fluent API, with self-explanatory
    methods. Here, you require a weather forecast date to be no more than one month
    in the future. The next validation is to have the temperature between `-100 C`
    and `100 C`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ping your API through Swagger, the following request gets displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The response will be displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: You don't have to use `FluentValidation`, especially if your API is simple and
    does not have complex rules. But in an enterprise setting, it is highly recommended
    that you do use it because the level of detail you can add to your validation
    is unlimited.
  prefs: []
  type: TYPE_NORMAL
- en: You learned about `FluentValidation` and the scenarios where it is useful. The
    next section will touch upon the two options for reading configuration in ASP.NET.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/uOGOe](https://packt.link/uOGOe).
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In ASP.NET Core Web API, you have two options for reading configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IConfiguration`: This is a global configuration container. Even though it
    allows access to all the configuration properties, injecting it directly into
    other components is inefficient. This is because it is weakly typed and has a
    risk of you trying to get a non-existing configuration property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IOptions`: This is strongly typed and convenient because the configuration
    is fragmented into just the pieces that a component needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can choose either of the two options. It is best practice to use `IOptions`
    in ASP.NET Core, as the configuration examples will be based on it. Whichever
    option you choose, you need to store the configuration in the `appsettings.json`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Move the hardcoded configuration from a constructor (weather forecast city
    and refresh interval) and move it into a configuration section in the `appsettings.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a model representing this configuration section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'You no longer have to inject the two primitive values into the component. Instead,
    you will inject `IOptions<WeatherForecastConfig>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Before the JSON section is useable, you need to bind to it. This can be done
    by finding the section through `IConfiguration` (via the `builder.Configuration`
    property):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `WeatherForecastConfig` has a matching section in the configuration
    file. Therefore, `nameof` was used. So, `nameof` should be preferred when using
    the alternative `string` type. That way, if the name of a type changes, the configuration
    will change consistently (or else the code won't compile).
  prefs: []
  type: TYPE_NORMAL
- en: Remember the `BuildWeatherForecastService` method you used previously? The beauty
    of it all is that the method can be removed altogether because the service can
    be created without the need for custom initialization. If you compile and run
    the code, you will get the same response.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/xoB0K](https://packt.link/xoB0K).
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core Web API is just a collection of libraries on top of the .NET Core
    framework. You can use `appsettings.json` in other types of applications as well.
    It is better to use individual libraries regardless of the project type you choose.
    In order to use the configuration through JSON, all you need to do is to install
    the following NuGet packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Microsoft.Extensions.Configuration`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.Extensions.Configuration.EnvironmentVariables`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.Extensions.Configuration.FileExtensions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.Extensions.Configuration.Json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.Extensions.Options`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, you learned how to use `IConfiguration` and `IOptions`. Your
    API is now ready, and it already includes many standard components of a typical
    Web API. The next section will detail how you can handle this complexity in code.
  prefs: []
  type: TYPE_NORMAL
- en: Development Environments and Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Applications often need to have two environments—production and development.
    You want the application development environment to have premade settings, more
    detailed error messages (if possible), more detailed logging, and lastly, debugging
    enabled. All of that is not needed for a production environment and you would
    want to keep it clean.
  prefs: []
  type: TYPE_NORMAL
- en: Other than the build configuration, you manage environments through different
    configuration files. The `appsettings.json` file is a base configuration file
    and is used across all environments. This configuration file should contain the
    configuration you would like for production.
  prefs: []
  type: TYPE_NORMAL
- en: The `Appsettings.development.json` file is a configuration file that will be
    applied when you build your application in debug mode. Here, `appsettings.json`
    will still be used with the development settings overriding the matching sections.
    A common example is described here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say `appsettings.json` has the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'And `appsettings.development.json` has the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the settings used will be the merged file with override matching sections,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, you will learn how to manage DI more cleanly.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Complexity needs to be handled and the complexity referred to here is the `Program`
    class. You'll need to break it out into smaller pieces and form a Bootstrapping
    directory specifying the components the service is made of.
  prefs: []
  type: TYPE_NORMAL
- en: When breaking down code within `Program.cs`, it is recommended to use a fluent
    API pattern. This is a pattern where you can chain multiple function calls from
    a single root object. In this case, you will create several extension methods
    for the `IServiceCollection` type and chain all the module injections one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reduce the complexity of the `Program` class, move the DI of different logical
    sections into different files. Each step that follows will do just that. So, split
    the controller and API baseline setup to a new file named `ControllersConfigurationSetup.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, move the code for logging to a new file named `LoggingSetup.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, move the request validation logic to a new file named `RequestValidatorsSetup.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Move the Swagger setup logic to a new file named `SwaggerSetup.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Move the injection of the `WeatherForecast`-related classes'' code to a new
    file named `WeatherServiceSetup.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, move the exception mapping of HTTP status codes to a new file named
    `ExceptionMappingSetup.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Now move all the new classes under `/Bootstrap` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18: Bootstrap folder with the fragmented services injection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.18: Bootstrap folder with the fragmented services injection'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.18* displays the `Bootstrap` folder. This project structure itself
    demonstrates what the API is made up of. So, DI becomes as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, you may want to pass the configuration or environment from a
    builder to other bootstrap methods or app methods multiple times. If you find
    yourself repeatedly calling `builder.X`, then consider storing each property in
    a local variable, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: With this, you will no longer repeatedly access the builder and will instead
    be able to use the needed builder properties directly. This is especially useful
    if you migrate from .NET Core to .NET 6\. `Environment` and `Configuration` used
    to be properties of a `Program` class, while `Services` would be injected into
    the `ConfigureServices` method. In .NET 6, `Services` is accessed through a `builder`
    object. However, with this approach, you can still use those properties or arguments
    as they were.
  prefs: []
  type: TYPE_NORMAL
- en: From now on, when referring to services, environments, or configurations, you
    will assume that you are accessing them from `builder.Services`, `builder.Environment`,
    and `builder.Configuration`, accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/iQK5X](https://packt.link/iQK5X).
  prefs: []
  type: TYPE_NORMAL
- en: Calling Another API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A working product is usually made of many APIs communicating with each other.
    To communicate effectively, one web service often needs to call another service.
    For example, a hospital may have a website (frontend) that calls a Web API (backend).
    This Web API orchestrates things by making calls to a booking Web API, a billing
    Web API, and a staff Web API. A staff Web API may make calls to an inventory API,
    holidays API, etc.
  prefs: []
  type: TYPE_NORMAL
- en: RapidAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As discussed in *Chapter 8*, *Creating and Using Web API Clients*, there are
    various ways of making HTTP calls to other services (though HTTP is not the only
    way to call another service). This time, you will try to get weather forecasts
    from an existing API and format it in your way. For doing so, you will use the
    RapidAPI Weather API, which can be found at [https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/](https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: RapidAPI is a platform that supports many APIs. The site [https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/](https://rapidapi.com/visual-crossing-corporation-visual-crossing-corporation-default/api/visual-crossing-weather/)
    is just one example. Many of the APIs present there are free; however, be aware
    that an API that is free today might become paid tomorrow. If that happens by
    the time you read this chapter, go through the examples, and explore the *Weather
    APIs* section at [https://rapidapi.com/category/Weather](https://rapidapi.com/category/Weather).
    You should be able to find similar alternatives there.
  prefs: []
  type: TYPE_NORMAL
- en: 'This API requires a GitHub account for use. Perform the following steps to
    use the RapidAPI Weather API:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the website [https://rapidapi.com/community/api/open-weather-map/](https://rapidapi.com/community/api/open-weather-map/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can navigate to [https://rapidapi.com/community/api/open-weather-map/](https://rapidapi.com/community/api/open-weather-map/)
    only if you are logged in. So, signup at [https://rapidapi.com/](https://rapidapi.com/)
    and create an account. This is required if you need an API key. Next login and
    select `Weather` category and choose `Open Weather` link.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you log in to the website, you will see the following window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19: Unsubscribed test page of the Visual Crossing Weather API on
    rapidapi.com'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.19: Unsubscribed test page of the Visual Crossing Weather API on rapidapi.com'
  prefs: []
  type: TYPE_NORMAL
- en: Click the `Subscribe to Test` button to get access (for free) to making calls
    to the Web API. A new window will open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the `Basic` option, which will allow you to make 500 calls a month to
    that API. For educational purposes, the basic plan should be enough:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.20: RapidAPI subscription fees with a free Basic plan highlighted'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.20: RapidAPI subscription fees with a free Basic plan highlighted'
  prefs: []
  type: TYPE_NORMAL
- en: You will be redirected to the test page with the `Test Endpoint` button available
    (instead of the `Subscribe to Test` button).
  prefs: []
  type: TYPE_NORMAL
- en: Now, configure the request. The first configuration asks you to enter the intervals
    for getting the weather forecast. You want an hourly forecast, so enter `1` hour
    beside `aggregateHours` (`1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next up is the `location` address (`2`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In *Figure 9.21*, you can observe that the city, state, and country are specified.
    These fields ask you to enter your address. However, typing your city name would
    also work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose the default `contentType` option as `csv` for this API (`3`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.21: GET weather forecast data request configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.21: GET weather forecast data request configuration'
  prefs: []
  type: TYPE_NORMAL
- en: This API is interesting because it allows you to return data in different formats—JSON,
    XML, and CSV. It is still a Web API and not so RESTful because the data response
    type is natively CSV. If you choose JSON, it will look unnatural and significantly
    more difficult to work with.
  prefs: []
  type: TYPE_NORMAL
- en: On the next screen, click `Code Snippets` (`1`) and then `(C#) HttpClient` (`2`)
    to see the example client code generated for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click `Test Endpoint` (`3`) to send a request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the `Results` tab (`4`) to view the response (in *Figure 9.22*, other
    endpoints are collapsed):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.22: rapidapi.com with test request page and example code'
  prefs: []
  type: TYPE_NORMAL
- en: in C# for making the request
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.22: rapidapi.com with test request page and example code in C# for
    making the request'
  prefs: []
  type: TYPE_NORMAL
- en: This window provides a nice API. It is also a great way to learn how to make
    calls to it by giving multiple examples of creating clients using a variety of
    languages and technologies.
  prefs: []
  type: TYPE_NORMAL
- en: As always, you will not initialize this client directly in a client but inject
    the client somehow. In *Chapter 8*, *Creating and Using Web API Clients*, it was
    mentioned that to have a static `HttpClient` over one constantly disposed is an
    efficient practice. However, for a Web API, there is an even better alternative—`HttpClientFactory`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you do all that, you need to prepare a few things. First, update the
    `appsettings.json` file with the inclusion of the base URL of an API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you will need to create another class for fetching the weather details
    from the said API. For that purpose, you will need an API key. You can find it
    in the example code snippet on the API website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.23: RapidAPI API key in the example code snippet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.23: RapidAPI API key in the example code snippet'
  prefs: []
  type: TYPE_NORMAL
- en: Save the API key as an environment variable because it is a secret and storing
    secrets in code is bad practice. So, name it as `x-rapidapi-key`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, the returned weather forecast might be quite different from yours.
    You can see the example response by clicking the `Test Endpoint` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.24: RapidAPI example response from GET current weather data endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.24: RapidAPI example response from GET current weather data endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the results received after clicking the `Test Endpoint` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the results in [https://toolslick.com/generation/code/class-from-csv](https://toolslick.com/generation/code/class-from-csv).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the class name as `WeatherForecast` and leave the rest of the settings
    as the defaults.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, press the `GENERATE` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.25: Response content pasted to'
  prefs: []
  type: TYPE_NORMAL
- en: https://toolslick.com/generation/code/class-from-csv
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.25: Response content pasted to [https://toolslick.com/generation/code/class-from-csv](https://toolslick.com/generation/code/class-from-csv)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will create two classes, `WeatherForecast` and `WeatherForecastClassMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.26: Generated data model and mapping classes (simplified for brevity)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.26: Generated data model and mapping classes (simplified for brevity)'
  prefs: []
  type: TYPE_NORMAL
- en: '`WeatherForecast` represents the object to which the data from this API will
    be loaded.'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `WeatherForecast.cs` under the `Dtos` folder (DTO will
    be described in detail in the *DTO and Mapping Using AutoMapper* section) and
    paste the class there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the bits that do not have a connection to an already-existing `WeatherForecast`
    model. The cleaned-up model will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: You should know that `WeatherForecastClassMap` is a special class. It is used
    by the `CsvHelper` library, which is used for parsing CSV files. You could parse
    CSV files yourself; however, `CsvHelper` makes it a lot easier to parse.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `CsvHelper`, install its NuGet package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '`WeatherForecastCsv` represents a mapping from a CSV to a C# object.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, create a file called `WeatherForecastClassMap.cs` under the `ClassMaps`
    folder and paste the class there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Keep only the mappings that match the `WeatherForecast` class that was edited
    in *Step 17*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/dV6wX](https://packt.link/dV6wX)
    and [https://packt.link/mGJMW](https://packt.link/mGJMW).
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, you learned how to get weather forecasts from an existing
    API and format them your way using the RapidAPI Weather API. Now it is time to
    proceed to the service client and use the models created, along with the settings,
    parse the API response, and return the current time weather.
  prefs: []
  type: TYPE_NORMAL
- en: Service Client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you have all the ingredients that are needed to create the provider class.
    You learned in *Chapter 8*, *Creating and Using Web API Clients*, that when communicating
    with another API, it''s best to create a separate component for it. So, here you
    will start from an interface abstraction, `IWeatherForecastProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create an implementation of that interface—that is, a class taking `HttpClient`
    for DI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement an interface, start with writing a method definition for getting
    the current weather:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a request to call HTTP GET with a relative URI for getting a forecast
    of the CSV type at a given location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, send a request and verify that it was a success:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'If the status code is not in the range of `200-300`, the `response.EnsureSuccessStatusCode();`
    throws an exception. Set up a CSV reader to prepare for deserializing weather
    forecasts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: You are adding a `using` statement to `StringReader` and `CsvReader` because
    both implement the `IDisposable` interface for disposing unmanaged resources.
    This happens when you use the `using` statement within a function after it returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, deserialize the forecasts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, you request the API to return forecasts starting from today and stopping
    a few days in the future with 1-hour intervals. The first returned forecast is
    the forecast of the current hour—that is, the forecast that you need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you will use `Newtonsoft.Json` for deserialization. Install the following
    package to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `AddControllersConfiguration` method by appending the following
    line on the services object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: This line replaces the default serializer with `Newtonsoft.Json`. Now, `Newtonsoft.Json`
    doesn't have to be used; however, it is a much more popular and complete library
    for serialization compared to the default one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/jmSwi](https://packt.link/jmSwi).
  prefs: []
  type: TYPE_NORMAL
- en: Till now, you have learned how to create a service client and make basic HTTP
    calls using it. It's effective for grasping the basics; however, the classes the
    API uses should be coupled with the classes of the APIs it consumes. In the next
    section, you will learn how to decouple the API from third-party API models using
    a DTO and mapping via `AutoMapper`.
  prefs: []
  type: TYPE_NORMAL
- en: DTO and Mapping Using AutoMapper
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The weather forecast model from RapidAPI is a Date Transfer Object (DTO)—a model
    used just for transferring data and convenient serialization. RapidAPI may change
    its data model and, if that happens, the DTO will change as well. If you are just
    presenting the data you had received and don't need to perform any logical operations
    on it, then any change may be alright.
  prefs: []
  type: TYPE_NORMAL
- en: However, you will usually apply business logic to a data model. You already
    know that references to a data model are scattered across multiple classes. With
    every change to a DTO, a class may have to change as well. For example, the DTO
    property that was called `weather` has now changed to `weathers`. Another example
    is of a property that was previously called `description` will now be called a
    `message`. So, renaming a DTO property like this will require you to make changes
    everywhere they are referenced. The bigger the project, the worse of an issue
    this becomes.
  prefs: []
  type: TYPE_NORMAL
- en: The advice of the SOLID principles is to avoid such changes (refer to *Chapter
    2*, *Building Quality Object-Oriented Code*). One of the ways to achieve this
    is by having two kinds of models—one for domain and the other for outside calls.
    This will require a mapping between foreign objects (coming from outside APIs)
    into your own.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping can be done either manually or by using some popular libraries. One
    of the most popular mapping libraries is AutoMapper. It allows you to map from
    one object to another using property names. You can also make your own mappings.
    Now, you will use this library to configure a mapping between a weather forecast
    DTO and a weather forecast model.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, first install NuGet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: This library allows you to inject `AutoMapper` into `ServiceCollection`. Here,
    `AutoMapper` uses the `Profile` class to define a mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new mapping should inherit the `Profile` class. So, inside the constructor
    of the new profile, use a `CreateMap` method to provide a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in order to map every property from the `CreateMap` method, call the
    `ForMember` method and specify how to do a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Here, the value of `TemperatureC` comes from `main.temp` inside the DTO.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the other property, you will concatenate all the weather descriptions into
    one string and call that a summary (`BuildDescription`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, use the lambda method, `ForMember`, when building a weather forecast summary
    mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `MapperSetup` class and inject `AutoMapper` from the `AddModelMappings`
    method to provide different mapping profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Append `.AddModelMappings()` to the `services` object calls. With this, you
    can call `mapper.Map<Model.WeatherForecast>(dtoForecast);`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/fEfdw](https://packt.link/fEfdw)
    and [https://packt.link/wDqK6](https://packt.link/wDqK6).
  prefs: []
  type: TYPE_NORMAL
- en: The `AutoMapper` mapping library allows you to map from one object to another
    by default mapping matching property names. The next section will detail how you
    can use DI to reuse `HttpClient`.
  prefs: []
  type: TYPE_NORMAL
- en: HttpClient DI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Continuing with DI, you now want to get into the habit of using the fragmented
    `ConfigureServices` approach. So, first, create a class called `HttpClientsSetup`
    and then create a method for adding the configured `HttpClients`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, for the injection itself, use the `AddHttpClient` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding section, it was mentioned that the keys should be hidden and
    stored in environment variables. To set a default start URI of every call, set
    `BaseAddress` (`WeatherForecastProviderUrl` used in *Step 10* of the *RapidAPI*
    section).
  prefs: []
  type: TYPE_NORMAL
- en: 'To append the API key on every request, get the API key that you stored in
    environment variables and assign it to default headers as `x-rapidapi-key`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish the injection-builder pattern, you need to return the `services`
    object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go back to `services` in `Program` and append the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'To integrate the client you have just set up, go to `WeatherForecastService`,
    and inject the `mapper` and `provider` components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `GetWeatherForecast` method to either get the cached forecast of
    this hour or fetch a new one from the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: This method, just like the preceding one, first tries to get a value from the
    cache. If the value exists, then the method returns a value. However, if the value
    does not exist, the method calls the API for the preconfigured city, maps the
    DTO forecast to the model forecast, and saves it in the cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you send an HTTP GET request to `https://localhost:7021/WeatherForecast/`,
    you should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Calling the same endpoint results in the same response. However, the response
    times are significantly faster due to the cache being used rather than repeating
    a call to the forecast API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/GMFmm](https://packt.link/GMFmm).
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the theoretical portion of this topic. In the following section,
    you will put this into practice with an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.03: Performing File Operations by Calling Azure Blob Storage'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common task with a Web API is to perform a variety of operations on files,
    such as download, upload, or delete. In this exercise, you will reuse a portion
    of `FilesClient` from *Activity 8.04* of *Chapter 8*, *Building Quality Object-Oriented
    Code*, to serve as a baseline client for calling Azure Blob storage and call its
    methods via REST endpoints to do the following operations on a file:'
  prefs: []
  type: TYPE_NORMAL
- en: Download a file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a shareable link with expiration time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upload a file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete a file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract an interface for `FilesClient` and call it `IFilesService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The new interface is simplified as you will work on a single container. However,
    as per the requirements, you have added a few new methods: `Delete`, `Upload`,
    `Download`, and `GetDownloadLink`. The `Download` method is for downloading a
    file in its raw form—that is, bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `Exercises/Exercise03/FilesService.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the following parts of [https://packt.link/XC9qG](https://packt.link/XC9qG%20)
    there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename `Client` to `Service`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also change the `Exercise04` reference (used in *Chapter 8*, *Building Quality
    Object-Oriented Code*) to `Exercise03` (a new one to be used for this chapter):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor initializes `blobServiceClient` to get `blobClient`, which
    allows you to do operations in the *Exercice03* directory in the Azure Blob Storage
    Account. If the folder doesn''t exist, `blobServiceClient` will create it for
    you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For the preceding step to work, you will need an Azure Storage Account. So,
    refer to *Activity 8.04* of *Chapter 8*, *Building Quality Object-Oriented Code*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `ValidateFileExists` method to validate whether a file exists in
    the storage, else throw an exception (a small helper method that did not exist before):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create the `Delete` method to delete a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Here, you will first get a client for the file and then check whether the file
    exists. If not, then you will throw a `FileNotFoundException` exception. If the
    file exists, then you will delete the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `UploadFile` method to upload a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Once again, you first get a client that allows you to perform operations on
    a file. Then, feed the content and headers to it to upload.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `Download` method to download a file in bytes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: This method creates a memory stream and downloads the file to it. Please note
    that this is not going to work on large files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to learn more on how to process large files, please refer
    to [https://docs.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-6.0#upload-large-files-with-streaming](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-6.0#upload-large-files-with-streaming).
  prefs: []
  type: TYPE_NORMAL
- en: There is a way to present raw downloaded bytes as an image or JSON, rather than
    as generic downloadable content. With an HTTP request or response, you can send
    a header specifying the way the content should be interpreted. This header is
    called Content-Type. Each application will process this differently. In the context
    of Swagger, `image/png` will be displayed as an image, while `application/json`
    will be shown as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `GetUri` method to get a URI of `blobClient`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Getting a URI requires the use of `BlobSasBuilder`, through which you can generate
    a shareable URL to a blob. Through the builder, specify the kind of resource you
    are trying to share (`"b"` stands for blob) and the expiry time. You need to set
    the permissions (to read) and pass the `sasBuilder` builder to the `blobClient`
    client to generate `sasUri`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, use a filename to create a file download link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `ExceptionMappingSetup` class and the `AddExceptionMappings` method,
    add the following mapping:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an extension method to inject a module of `FileUploadService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: An extension method is a simplified way of showing a new method to an existing interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Append it to `services` in `Program.cs` to use the `FileUploadService` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a controller for files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Controller creation is standard on MVC architecture, and this allows users to
    access `FileService` through HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, inject `IFilesService` to provide an interface through which file-related
    functionality could be accessed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create an endpoint to delete a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an endpoint to download a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an endpoint for getting a shareable file download link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an endpoint for uploading a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '`IFormFile` is a common way of passing small files to a controller. However,
    from `IFormFile`, you need file contents as a stream. You can get this using the
    `OpenReadStream` method. Swagger allows you to use the File Explorer window to
    choose the file you want to upload.'
  prefs: []
  type: TYPE_NORMAL
- en: Now you run the API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your Swagger documentation will have a new section with the controller methods.
    Here are the responses of each:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upload file request:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.27: Upload file request in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.27: Upload file request in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upload file response:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.28: Upload file response in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.28: Upload file response in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get download link request:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.29: Get download link request in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.29: Get download link request in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get download link response:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.30: Get download link response in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.30: Get download link response in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download file request:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.31: Download file request in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.31: Download file request in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download file response:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.32: Download file response in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.32: Download file response in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete file request:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.33: Delete file request in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.33: Delete file request in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete file response:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.34: Delete file response in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.34: Delete file response in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: This exercise illustrated the remaining aspects of what you can do with a Web
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/cTa4a](https://packt.link/cTa4a).
  prefs: []
  type: TYPE_NORMAL
- en: The volume of functionality you can serve through the web is immense. However,
    this comes with its own big problem. How do you ensure that your API is consumed
    only by the intended identities? In the next section, you will explore how to
    secure a Web API.
  prefs: []
  type: TYPE_NORMAL
- en: Securing a Web API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every now and then, you'll hear about a major security breach on the news. In
    this section, you will learn how to protect a public API using AAD.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Active Directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Azure Active Directory (AAD) is Microsoft's cloud identity and access management
    service that is used to sign in to well-known applications, such as Visual Studio,
    Office 365, and Azure, and to internal resources. AAD uses OpenID to provide user
    identity through a JavaScript Web Token.
  prefs: []
  type: TYPE_NORMAL
- en: JWT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A JavaScript Web Token (JWT) is a collection of personal data encoded and sent
    over as a mechanism of authentication. A single field encoded in a JWT is called
    a claim.
  prefs: []
  type: TYPE_NORMAL
- en: OpenID Connect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenID Connect (OIDC) is the protocol used for getting the ID token, which provides
    user identity or an access token. It's a layer on top of OAuth 2 to get an identity.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth serves as a means of getting an access token on behalf of some user. With
    OIDC, you get an identity; this has a role and access comes from that role. When
    a user wants to log in to a website, OpenID might require them to input their
    credentials. This might sound exactly the same as OAuth; however, don't mix the
    two. OpenID is all about acquiring and verifying the user's identity and granting
    access coming with a role. OAuth, on the other hand, gives access to a user to
    do a limited set of functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'A real-life analogy would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenID: You come to an airport and present your passport (which is issued by
    the government) confirming your role (passenger) and identity that way. You are
    **granted** a **passenger** role and allowed to board an airplane.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OAuth: You come to an airport and the staff asks you to take part in an emotional
    state tracking event. With your **consent**, the staff (**others**) at the airport
    can now track more of your personal data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a summary:'
  prefs: []
  type: TYPE_NORMAL
- en: OpenID provides authentication and **verifies who you are**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth is authorization that allows others to do **things on your behalf**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application Registration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step in securing a Web API using Azure is to create an application
    registration in AAD. Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to `Azure Active Directory` by typing `active dir` in the search bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.35: Azure Active Directory being searched in portal.azure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.35: Azure Active Directory being searched in portal.azure'
  prefs: []
  type: TYPE_NORMAL
- en: In the new window, click the `App registrations` option (`1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, click the `New registration` button (`2`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.36: Azure app registration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_36.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.36: Azure app registration'
  prefs: []
  type: TYPE_NORMAL
- en: In the new window, enter `Chapter09WebApi` as the name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Keep the other settings as the default and click the `Register` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.37: The new app registration named Chapter09WebApi'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_37.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.37: The new app registration named Chapter09WebApi'
  prefs: []
  type: TYPE_NORMAL
- en: To access an API, you need at least one scope or role. In this example, you
    will create a scope called `access_as_user`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scopes in general can be used to control which part of an API is accessible
    to you. For the scope to be available for all users, you will need to select `Admins
    and users`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this trivial example, given the token is valid, you will allow access to
    everything. So, select the `Access all as a user` option. The exact values of
    the other fields do not matter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.38: The access_as_user scope available for all users'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_38.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.38: The access_as_user scope available for all users'
  prefs: []
  type: TYPE_NORMAL
- en: The first step in securing a Web API using Azure was to create an application
    registration in AAD. The next topic will cover how you can implement security
    within a Web API in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Web API Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section will focus on the details of how, programmatically, you can get
    the token and work with it. So, first, install NuGet, which does JWT validation
    using the Microsoft identity platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Bootstrap folder, create the `SecuritySetup` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `Program.cs`, append this to `services`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'The injected services are needed by the authorization middleware. So, add the
    following on an `app` to add authorization middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: This will be triggered on all endpoints decorated with the `[Authorize]` attribute.
    Make sure the preceding two lines are placed before `app.MapControllers();` or
    else the middleware will not be wired with your controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within `appsettings.json`, add the following configuration to link to your
    `AzureAd` security configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, add the `Authorize` attribute above each controller for any kind of
    security you choose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: The `Authorize` attribute is essential for any type of security implementation.
    This attribute will perform the generic token validation, while `[RequiredScope("access_as_user")]`
    will check whether the `access_as_user` scope was included or not. What you now
    have is a secured API. If you try calling the `WeatherForecast` endpoints, you
    will get a `401 – Unauthorised` error.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/ruj9o](https://packt.link/ruj9o).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to generate a token through the token
    generator app and use it to securely access your API.
  prefs: []
  type: TYPE_NORMAL
- en: Token Generator App
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To call the API, you need to generate a token by creating a console application.
    Before you do that, however, you need to configure one more thing in your app
    registration. Your console application is considered a desktop app. So, when signing
    in, you need a redirect URI. This URI, returned with the code, is used to get
    the access token. To achieve this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the left pane in AAD, select the `Authentication` option (`1`) to view
    all configurations with outside applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, click the `Add a platform` button (`2`) to configure a new application
    (token generator):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.39: Authentication window with options to configure a new application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_39.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.39: Authentication window with options to configure a new application'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Configure platforms` section, select the `Mobile and desktop applications`
    button (`3`) to register a console application token generator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.40: Selecting the Mobile and desktop applications platform for authentication'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_40.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.40: Selecting the Mobile and desktop applications platform for authentication'
  prefs: []
  type: TYPE_NORMAL
- en: A new window will open on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Type your `Custom redirect URIs` that specify where you will return after the
    successful login to AAD when requesting the token. In this case, it doesn't matter
    so much. So, type any URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, click the `Configure` button (`4`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.41: Configuring the redirect URI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_41.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.41: Configuring the redirect URI'
  prefs: []
  type: TYPE_NORMAL
- en: 'That completes the configuration of AAD. Now that you have all the infrastructure
    for security, build a console application to generate an access token from AAD:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a new project called `Chapter09.TokenGenerator`. It will allow
    you to generate authorization tokens needed to call your API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, make it a console app on .NET Core to keep it simple and display a generated
    token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `Microsoft.Identity.Client` by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: This will allow you to request a token later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in `Program.cs`, create a method to initialize an AAD application client.
    This will be used to prompt browser login, as if you were to log in to the Azure portal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The values used in the preceding code will differ, depending upon the AAD subscription.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the application uses the `clientId` and `tenantId` configured
    in AAD.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another method to use the application that requires a user login on
    Azure to get an auth token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, define the scopes you need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Replace `api://{clientId}/{scope}` with your own application ID URI if you are
    not using a default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, attempt to get a cached token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'The cached token retrieval is required if the login was done earlier. If you
    haven''t signed in before to get a token, you will need to log in to Azure AD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Return the access token as the result of a logged-in user so that you can use
    it later to access your APIs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, call the two methods and print the result (using the minimal API):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when you run the token app, it will ask you to sign in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.42: Sign-in request from Azure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_42.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.42: Sign-in request from Azure'
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful sign-in redirects you to a configured redirect URI with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that the token will be returned in the console window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.43: Generated token from the app registration in the console app'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_43.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.43: Generated token from the app registration in the console app'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can inspect the token using the [https://jwt.io/](https://jwt.io/)
    website. The following screen is displayed, showing two parts: `Encoded` and `Decoded`.
    The `Decoded` part is divided into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HEADER`: This contains a type of token and the algorithm used to encrypt the token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PAYLOAD`: The claims encoded within the token contain information, such as
    who requested the token and what access has been granted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.44: Encoded and decoded JWT version on the jwt.io website'
  prefs: []
  type: TYPE_NORMAL
- en: using your app registration
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_44.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.44: Encoded and decoded JWT version on the jwt.io website using your
    app registration'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to secure an unsecured API. Security is not
    limited to just an authorization token. As a professional developer, you must
    be aware of the most common vulnerabilities in APIs. A list of the top 10 most
    common security issues is updated every four years based on the trends in the
    industry. This list is called the Open Web Application Security Project (OWASP)
    and can be reached at [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will apply the changes needed for Swagger to work with
    the authorization token.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Swagger Auth
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To pass an authorization header through Swagger, you will need to add some
    configuration. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to render an authorization button, add the following block of code
    inside the `SwaggerSetup` class, the `AddSwagger` method, and the `services.AddSwaggerGen(cfg
    =>` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to forward the value of a bearer token with an authorization header,
    add the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'When you navigate to [https://localhost:7021/index.html](https://localhost:7021/index.html),
    you will see that it now contains the `Authorize` button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.45: Swagger docs with Authorize button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_45.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.45: Swagger docs with Authorize button'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the `Authorize` button to allow you to input the bearer token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.46: Bearer token input after clicking the Authorize button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_46.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.46: Bearer token input after clicking the Authorize button'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, send a request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.47: Swagger-generated request with a status of 200 generated in
    response'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_47.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.47: Swagger-generated request with a status of 200 generated in response'
  prefs: []
  type: TYPE_NORMAL
- en: You will see that the authorization header is added, and the `ok` response (HTTP
    status code `200`) is returned.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you added some configuration to pass an authorization header
    through Swagger.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/hMc2t](https://packt.link/hMc2t).
  prefs: []
  type: TYPE_NORMAL
- en: If you make a mistake and your token validation fails, you will get either a
    `401 – unauthorized` or `403 – forbidden` status code returned (often without
    any details). Fixing this error might be a headache. However, it is not too difficult
    to get more information on what went wrong. The next section provides more details.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting Token Validation Errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To simulate this scenario, try invalidating the client-id in `appsettings.json`
    by changing any single symbol (for example, the last letter to `b`). Run the request
    and see how the response is displayed as `401`, with nothing else appearing in
    the logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the validations and incoming and outcoming requests can be tracked through
    a pipeline. All you must do is change the default minimum logged level from `info`
    to `Trace`. You can do this by replacing the `appsettings.development.json` file
    contents with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Do not mix `appsettings.development.json` with `appsettings.json`. The former
    is used for configuration as a whole and the latter overrides the configuration
    but only in certain environments—development (local) in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the same request again, you will now see a verbose log in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspecting it deeper reveals the error as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Audience validation failed; Audiences: ''api://2d8834d3-6a27-47c9-84f1-0c9db3eeb4bb''.
    Did not match validationParameters`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This error indicates a mismatched audience configured in the JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.48: Token validation error with the error highlighted'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_48.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.48: Token validation error with the error highlighted'
  prefs: []
  type: TYPE_NORMAL
- en: Now it is time for you to learn about the SOA architecture where components
    of a system are hosted as separate services.
  prefs: []
  type: TYPE_NORMAL
- en: Service-Oriented Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Software architecture has come a long way—evolving from monolithic to Service-Oriented
    Architecture (SOA). SOA is an architecture where major layers of applications
    are hosted as separate services. For example, there would be one or more Web APIs
    for data access, one or more Web APIs for business logic, and one or more client
    applications consuming it all. The flow would be like this: the client app calls
    the business Web API, which calls another business Web API or a data access Web
    API.'
  prefs: []
  type: TYPE_NORMAL
- en: However, modern software architecture goes one step further to bring a more
    evolved architecture, called microservice architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice Architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microservice architecture is SOA with a single-responsibility principle applied.
    This means that, instead of service-as-a-layer, you now have hosted self-contained
    modules that have a single responsibility. A self-contained service has both data
    access and business logic layers. Instead of many services per layer, in this
    approach, you have many services per module.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of those self-contained modules is to allow multiple teams to work
    on different parts of the same system simultaneously without ever stepping on
    each other's toes. On top of that, parts in a system can be scaled and hosted
    independently and there is no single point of failure. Also, each team is free
    to use whatever technology stack they are most familiar with, as all the communication
    happens through HTTP calls.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the theoretical portion of this topic. In the following section,
    you will put all that you have learned into practice with an activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9.01: Implementing the File Upload Service Using Microservice Architecture'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A microservice should be self-contained and do just one thing. In this activity,
    you will sum up the steps needed for extracting a piece of code into a microservice
    that manages how you work with files through the web (delete, upload, and download).
    This should serve as an overall effective checklist of what needs to be done when
    creating a new microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project. In this case, it will be a `.NET Core Web API` project
    on the .NET 6.0 framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `Chapter09.Activity.9.01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add the commonly used NuGet packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AutoMapper.Extensions.Microsoft.DependencyInjection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FluentValidation.AspNetCore`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hellang.Middleware.ProblemDetails`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.AspNetCore.Mvc.NewtonsoftJson`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.Identity.Web`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Swashbuckle.AspNetCore`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, include the Azure Blobs Client package as `Azure.Storage.Blobs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create one or more controllers for communication with the Web API. In this case,
    you will move `FileController` to the `Controllers` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to create one or more services for business logic, move `FilesService`
    to the `Services` folder and `FileServiceSetup` to the `Bootstrap` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then document API using XML docs and Swagger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `csproj` file to include XML docs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy `SwaggerSetup` to the `Bootstrap` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure `Controllers`. In this scenario, it will be a plain one-line `services.AddControllers()`
    under the `ControllersConfigurationSetup` class and the `AddControllersConfiguration`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the problem details error mappings. In this case, there are no exceptions
    that you will explicitly handle. So, you will keep it as a one-liner within the
    `ExceptionMappingSetup` class and the `AddExceptionMappings` and `services.AddProblemDetails()`
    methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Secure the API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create AAD app registration for the new service. Refer to the *Application Registration*
    subsection in the *Securing the Web API* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the configuration of the new service based on the Azure AD app registration
    client, `tenant`, and `app` IDs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject the needed services and configure the API pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `Program` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the `ConfigureServices` method contains extra services, you don't need
    to remove them. Leave the `Configure` method as is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the service through Swagger and upload a test file. Don't forget to generate
    a bearer token first using the token generator app from the updated values learned
    earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, try to get a test file that you just uploaded. You should see the
    status code `200`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Get download link request:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.49: Get download link request in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_49.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.49: Get download link request in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get download link response:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.50: Get download link response in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_50.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.50: Get download link response in Swagger'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  prefs: []
  type: TYPE_NORMAL
- en: All the services that have been created so far require considerations such as
    hosting, scaling, and availability. In the following section, you will learn about
    serverless and Azure Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding section, you learned that microservice architecture is a self-contained
    service with both data access and business logic layers. With this approach, you
    have many services per module. However, working with microservices, especially
    at the start, might seem like a hassle. It might raise doubts such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What does not big enough mean?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should you host on different servers or on the same machine?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is another cloud hosting model better?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These questions might be overwhelming. So, a simple way of calling your code
    through HTTP is by using Azure Functions. Azure Functions is a serverless solution
    that allows you to call your functions on the cloud. Serverless does not mean
    that there is no server; you just do not need to manage it by yourself. In this
    section, you will try to port `CurrentTimeController` from *Exercise 9.02* to
    an Azure Function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding with the steps, install Azure Functions Core Tools first
    using the instructions here: [https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=v3%2Cwindows%2Ccsharp%2Cportal%2Cbash%2Ckeda#install-the-azure-functions-core-tools](https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local?tabs=v3%2Cwindows%2Ccsharp%2Cportal%2Cbash%2Ckeda#install-the-azure-functions-core-tools).
    Azure Functions Core Tools also requires the Azure CLI to be installed (if you
    want to publish an Azure Functions application and not on a server). Follow the
    instructions here: [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows?tabs=azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows?tabs=azure-cli).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: In VS Code, click the `Extenstions` icon (`1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then search for `azure function` in the search text box (`2`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, install the `Azure Functions` extension (`3`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.51: Searching for the Azure Functions extension in VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_51.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.51: Searching for the Azure Functions extension in VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: A new Azure tab will appear on the left.
  prefs: []
  type: TYPE_NORMAL
- en: Click the new Azure tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the new page, click the `Add` button (`1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the `Create Function…` option (`2`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.52: The new Azure Functions extension in VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: with the Create Function… button
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_52.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.52: The new Azure Functions extension in VS Code with the Create Function…
    button'
  prefs: []
  type: TYPE_NORMAL
- en: In the Create Function window, select `HTTP trigger`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the name `GetCurrentTime.Get`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the project where it is held `Pact.AzFunction`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the last screen, select `anonymous`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, there is no need to go into too much detail about this configuration.
    The key point to be considered here is that the function will be reachable publicly,
    through HTTP requests. A new project created through these steps will include
    the new Azure Function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, navigate to the root of the new project folder to run the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, press `F5` or click the `Start debugging to update this list…` message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.53: Azure Extension window with the to-be-built project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_53.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.53: Azure Extension window with the to-be-built project'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that upon a successful build, the message changes to the function name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.54: Azure Extension window with post-build project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_54.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.54: Azure Extension window with post-build project'
  prefs: []
  type: TYPE_NORMAL
- en: 'The terminal output window, displayed at the bottom of VS Code, shows the following
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.55: The terminal output after a successful build'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16835_09_55.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.55: The terminal output after a successful build'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in VS Code Explorer, open `GetCurrentTime.cs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that in *Exercise 9.01*, you worked with the `GetCurrentTime` code. You will
    reuse the same code here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: The template names are generated based on your configuration from before. An
    Azure Function is bound to an HTTP endpoint through the `[Function("GetCurrentTime")]`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Before you proceed, you might have noticed that, even though the function for
    getting the current time consumed a variable for `timezoneid`, there is no such
    variable here (yet). Unlike the previous REST APIs you created to pass parameters
    to an Azure Function, here you pass it through either a request body or query
    variables. The only problem here is that you will have to parse it yourself, as
    there are no bindings through attributes just like with the controller methods.
    The argument you need is just a simple string that can be passed as a query argument.
    This line parses the URI from the request and gets a `timezoneId` variable from
    the query string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `timezoneId` variable to get the current time in a specific zone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up is the business logic. So, use the `timezoneId` variable to get the
    current time in a specified time zone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, serialize the results in `HTTP 200 Ok` as the `text/plain` content type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Run this code and navigate to `http://localhost:7071/api/GetCurrentTime?timezoneId=Central%20European%20Standard%20Time`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will get the current time of that time zone, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: You have now grasped the workings of Azure Functions—a serverless solution to
    call your functions on the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: It has been a long path through this book, but with the conclusion of this final
    activity, you have mastered all the concepts and skills required to create your
    own modern C# applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to build your own REST Web API using the ASP.NET
    Core Web API template. You learned how to tackle the ever-growing complexity of
    configuration using bootstrap classes. You were introduced to the OpenAPI standard
    and Swagger, a tool used for calling an API to see whether it has successfully
    rendered the documentation. You also delved into mapping exceptions to specific
    HTTP status codes, along with how to map DTOs to domain objects and vice versa.
    In the second half of the chapter, you practiced securing the Web API using AAD,
    learned the concept of microservices, and created one yourself—both through a
    new dedicated Web API and through an Azure Function.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to create and consume Web APIs is important because that's what
    most of the software development is all about. You either consume or create Web
    APIs at some point. Even if you don't have to create one yourself, grasping the
    ins and outs of it will help you as a professional developer.
  prefs: []
  type: TYPE_NORMAL
- en: This brings a close to *The C# Workshop*. Throughout this book, you have learned
    the basics of programming in C#, starting with simple programs that used arithmetic
    and logical operators, followed by the increasingly complex concepts of clean
    coding, delegates and lambdas, multithreading, client and server Web APIs, and
    Razor Pages applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concludes the print copy of this book, but it is not the end of your journey.
    Visit the GitHub repository at [https://packt.link/sezEm](https://packt.link/sezEm)
    for bonus chapters—*Chapter 10*, *Automated Testing*, and *Chapter 11*, *Production-Ready
    C#: From Development to Deployment*—covering such topics as different forms of
    testing before you take an in-depth look at unit testing using Nunit (the most
    popular third-party testing library for C#), getting acquainted with Git and using
    GitHub to keep a remote backup of your code, enabling Continuous Deployment (CD)
    and deployment from your code to the cloud, studying the cloud using Microsoft
    Azure, in addition to learning how to use GitHub Actions to perform CI and CD
    to push application changes live in production.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rayon](img/Jason_Hales.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Jason Hales**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rayon](img/Almantas_Karpavicius.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Almantas Karpavicius**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rayon](img/Mateus_Viegas.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Mateus Viegas**'
  prefs: []
  type: TYPE_NORMAL
- en: Hey!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are Jason Hales, Almantas Karpavicius, and Mateus Viegas the authors of this
    book. We really hope you enjoyed reading our book and found it useful for learning
    C#.
  prefs: []
  type: TYPE_NORMAL
- en: It would really help us (and other potential readers!) if you could leave a
    review on Amazon sharing your thoughts on *The C# Workshop*.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the link [https://packt.link/r/1800566492](https://packt.link/r/1800566492).
  prefs: []
  type: TYPE_NORMAL
- en: OR
  prefs: []
  type: TYPE_NORMAL
- en: Scan the QR code to leave your review.
  prefs: []
  type: TYPE_NORMAL
- en: '![Barcode](img/qrcode.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Your review will help us to understand what's worked well in this book and what
    could be improved upon for future editions, so it really is appreciated.
  prefs: []
  type: TYPE_NORMAL
- en: Best wishes,
  prefs: []
  type: TYPE_NORMAL
- en: Jason Hales, Almantas Karpavicius, and Mateus Viegas
  prefs: []
  type: TYPE_NORMAL
- en: '![Packt Logo](img/Packt_Logo-1.png)'
  prefs: []
  type: TYPE_IMG

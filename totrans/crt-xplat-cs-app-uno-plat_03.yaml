- en: '*Chapter 2*: Writing Your First Uno Platform App'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to create a new Uno Platform app and see
    how a typical Uno Platform app is structured. First, we will go over the default
    Uno Platform app template, including the different projects included, and get
    you running on Windows 10 with your first Uno Platform app. After that, we will
    dive deeper into running and debugging your app on different platforms by showing
    how to use emulators and debugging the WebAssembly (Wasm) version of the app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Uno Platform supports a plethora of platforms and more and more platforms
    are being added to the list of supported platforms, in this book, we will only
    develop for a subset of supported platforms. The following platforms are the most
    prominent and widely used platforms, and as such, we will target them: Windows
    10, Android, Web/Wasm, macOS, and iOS.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: While we mention the other platforms in this chapter for completeness, the other
    chapters will only include the platforms mentioned earlier. This means that we
    will not show you how to run or test your app on **Linux**, **Tizen**, or **Windows
    7/8**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Uno Platform app and understanding its structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running and debugging your app, including using **XAML Hot Reload** and **C#
    Edit and Continue**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform-specific code using C# compiler symbols and **XAML** prefixes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other project types besides the Uno Platform app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have written your first Uno Platform app
    and created customizations based on the running platform. In addition to that,
    you will be able to make use of the different Uno Platform project types.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter assumes that you already have your development environment set
    up, including installing the project templates, as was covered in [*Chapter 1*](B17132_01_Final_VK_ePub.xhtml#_idTextAnchor015),
    *Introducing Uno Platform*. You can find the source code for this chapter here:
    [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter02](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter02).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action: [https://bit.ly/37Dt0Hg](https://bit.ly/37Dt0Hg)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: If you are using the digital version of this book, we advise you to type the
    code yourself or access the code from the book's GitHub repository Doing so will
    help you avoid any potential errors related to the copying and pasting of code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first app
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different ways of creating your project, so we will start with the
    most common one, using Visual Studio.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Creating your project with the Uno Platform solution templates
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The process of creating an Uno Platform app project is the same as for other
    project types in Visual Studio. Depending on the extensions and project templates
    installed, you will be greeted by the list of options in *Figure 2.1* when filtering
    for **Uno Platform**. Note that for *Figure 2.1*, only the **Uno Platform Solution
    Templates** extension was installed:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – List of Uno Platform project templates in the new project dialog'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Author_Figure_2.01_B17132.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – List of Uno Platform project templates in the new project dialog
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to get started with Uno Platform is using the **Multi-Platform
    App (Uno Platform)** project template as this contains all the necessary projects
    to build and run Uno Platform apps for every platform.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start creating your app by selecting the **Multi-Platform App (Uno Platform)**
    project type and click **Next**. Be careful that you are not selecting the **Multi-Platform
    Library (Uno Platform)** option as that will create a different project type,
    which we cover in the *Going beyond the default cross-platform app structure section*.
    Now you need to choose the name of your project, the location, and the solution
    name as seen in *Figure 2.2*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过选择**多平台应用程序（Uno Platform）**项目类型并单击**下一步**来开始创建您的应用程序。 请注意，您不要选择**多平台库（Uno
    Platform）**选项，因为那将创建一个不同的项目类型，我们将在*超越默认跨平台应用程序结构*部分中介绍。 现在，您需要选择项目的名称、位置和解决方案名称，如*图2.2*中所示：
- en: '![](img/Author_Figure_2.02_B17132.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Author_Figure_2.02_B17132.jpg)'
- en: Figure 2.2 – Configuring Multi-Platform App (Uno Platform)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 - 配置多平台应用程序（Uno Platform）
- en: In our case, we will call our project `HelloWorld` and save it under `D:\Projects`
    meaning that the project will be stored in `D:\Projects\HelloWorld` with the `HelloWorld.sln`
    solution being the top-level element. Of course, you can create the project in
    any folder you want; `D:\Projects` is just an example here. Note though that you
    should create your project as close as possible to the root of your drive to avoid
    issues with paths that are too long. After clicking **Create**, Visual Studio
    will create your project and open the solution for you. You will see all the generated
    projects in **Solution Explorer**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将称我们的项目为`HelloWorld`，并将其保存在`D:\Projects`下，这意味着项目将存储在`D:\Projects\HelloWorld`中，而`HelloWorld.sln`解决方案将是顶级元素。
    当然，您可以在任何您想要的文件夹中创建项目； `D:\Projects`只是一个例子。 请注意，您应尽可能靠近驱动器根目录创建项目，以避免路径过长的问题。
    单击**创建**后，Visual Studio将为您创建项目并打开解决方案。 您将在**Solution Explorer**中看到所有生成的项目。
- en: If you are creating your project in Visual Studio for Mac, the generated solution
    will include project heads for **Windows Presentation Foundation** (**WPF**) and
    **Universal Windows Platform** (**UWP**) apps. A project or platform head is the
    corresponding project that will be compiled when you compile your app for a specific
    platform. So, in the case of Windows 10, the UWP head will be compiled. You will
    need to use a Windows PC to build these apps. If you don't want to build for these
    platforms, you can remove the projects from the solution. If you will build these
    on a Windows machine separately, unload them from the solution when working on
    a Mac.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Visual Studio for Mac中创建项目，生成的解决方案将包括**Windows Presentation Foundation**（**WPF**）和**Universal
    Windows Platform**（**UWP**）应用程序的项目头。 项目或平台头是在为特定平台编译应用程序时将被编译的相应项目。 因此，在Windows
    10的情况下，将编译UWP头。 您需要使用Windows PC来构建这些应用程序。 如果您不想为这些平台构建，可以从解决方案中删除这些项目。 如果您将在Windows机器上单独构建这些项目，请在Mac上工作时从解决方案中卸载它们。
- en: 'Since your app might not target every platform supported by Uno Platform, you
    might want to remove those heads for your app. To do that, remove those projects
    from the solution by right-clicking the project in the project view and clicking
    **Remove** as shown in *Figure 2.3*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的应用程序可能不针对Uno Platform支持的每个平台，您可能希望为您的应用程序删除那些头。 要做到这一点，请通过右键单击项目视图中的项目并单击**删除**来从解决方案中删除这些项目，如*图2.3*所示：
- en: '![Figure 2.3 – Removing the Skia.Tizen head from the solution'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3 - 从解决方案中删除Skia.Tizen头'
- en: '](img/Figure_2.03_B17132.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.03_B17132.jpg)'
- en: Figure 2.3 – Removing the Skia.Tizen head from the solution
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 - 从解决方案中删除Skia.Tizen头
- en: After removing the project from the solution, the project is still on disk.
    To remove it entirely, you will have to delete the project by opening the project
    folder and deleting the corresponding folders. Since we will only target Windows
    10, Android, Web, macOS, and iOS, you can remove the `Skia.GTK`, the `Skia.Tizen`,
    `Skia.Wpf`, and `Skia.WpfHost` projects from your solution.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从解决方案中删除项目后，项目仍然存在于磁盘上。 要完全删除它，您必须打开项目文件夹并删除相应的文件夹。 由于我们只针对Windows 10、Android、Web、macOS和iOS，您可以从解决方案中删除`Skia.GTK`、`Skia.Tizen`、`Skia.Wpf`和`Skia.WpfHost`项目。
- en: Creating your project with the .NET CLI
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用.NET CLI创建您的项目
- en: 'Of course, you don''t have to use Visual Studio to create your Uno Platform
    app. You can also use the `dotnet new` templates for Uno Platform. You can create
    a new project by opening a terminal and typing the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您不必使用Visual Studio来创建您的Uno Platform应用程序。 您还可以使用Uno Platform的`dotnet new`模板。
    您可以通过打开终端并输入以下内容来创建新项目：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will create a new project called **MyApp**. You can find an overview of
    all the dotnet new templates in Uno Platform's template documentation ([https://platform.uno/docs/articles/get-started-dotnet-new.html](https://platform.uno/docs/articles/get-started-dotnet-new.html)).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为**MyApp**的新项目。 您可以在Uno Platform的模板文档中找到所有dotnet new模板的概述（[https://platform.uno/docs/articles/get-started-dotnet-new.html](https://platform.uno/docs/articles/get-started-dotnet-new.html)）。
- en: 'Of course, not everyone wants to target every platform with their app nor is
    it appropriate for every app to run on every platform. You can opt out of creating
    the target projects for specific platforms (more on those in the next section)
    by including specific flags in your commands. For example, with the following
    command, you will create a new project that will not run on Linux and other Skia-based
    platforms as we exclude the Skia heads:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非每个人都希望将其应用程序针对每个平台，也不是每个应用程序都适合在每个平台上运行。 您可以通过在命令中包含特定标志来选择不为特定平台创建目标项目（下一节将详细介绍这些内容）。
    例如，使用以下命令，您将创建一个不在Linux和其他Skia平台上运行的新项目，因为我们排除了Skia头：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To get a list of all the available options for the `unoapp` template, you can
    run `dotnet new unoapp -h`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`unoapp`模板的所有可用选项列表，可以运行`dotnet new unoapp -h`。
- en: Project structure and the heads
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目结构和头
- en: 'When creating the project in Visual Studio on Windows, with the Uno Platform
    Solution templates, there are two different top-level elements in `Platforms`
    folder and the `HelloWorld.Shared` shared C# project. Note that in the solution
    view, those are the two top-level elements, however, the `Platforms` folder does
    not exist on disk. Instead, all projects including the shared project have their
    own folder as shown in *Figure 2.4*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上使用Uno平台解决方案模板在Visual Studio中创建项目时，`Platforms`文件夹和`HelloWorld.Shared`共享C#项目中有两个不同的顶级元素。请注意，在解决方案视图中，这些是两个顶级元素，但是`Platforms`文件夹在磁盘上不存在。相反，所有项目，包括共享项目，都有自己的文件夹，如*图2.4*所示：
- en: '![Figure 2.4 – HelloWorld project in File Explorer'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4 - 文件资源管理器中的HelloWorld项目'
- en: '](img/Figure_2.04_B17132.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.04_B17132.jpg)'
- en: Figure 2.4 – HelloWorld project in File Explorer
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 - 文件资源管理器中的HelloWorld项目
- en: 'In the root of the generated solution is a file called `.vsconfig`. This file
    contains a list of all the Visual Studio components required to work with the
    generated project. If you set your environment up as in [*Chapter 1*](B17132_01_Final_VK_ePub.xhtml#_idTextAnchor015),
    *Introducing Uno Platform*, then you''ll have everything you need. But, if you
    see the prompt in *Figure 2.5*, click on the **Install** link and add the missing
    workloads:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的解决方案的根目录中有一个名为`.vsconfig`的文件。该文件包含了与生成的项目一起使用所需的所有Visual Studio组件的列表。如果您按照[*第1章*](B17132_01_Final_VK_ePub.xhtml#_idTextAnchor015)中介绍Uno平台的方式设置了您的环境，那么您将拥有所需的一切。但是，如果您看到*图2.5*中的提示，请单击**安装**链接并添加缺少的工作负载：
- en: '![Figure 2.5 – Missing components warning in Visual Studio'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5 - 在Visual Studio中缺少组件的警告'
- en: '](img/Figure_2.05_B17132.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.05_B17132.jpg)'
- en: Figure 2.5 – Missing components warning in Visual Studio
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 - 在Visual Studio中缺少组件的警告
- en: 'Under the `Platforms` solution folder, you will find a `C#` project for every
    one of the supported platforms:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Platforms`解决方案文件夹下，您将找到每个受支持平台的`C#`项目：
- en: '`HelloWorld.Droid.csproj` for Android'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HelloWorld.Droid.csproj` 用于Android'
- en: '`HelloWorld.iOS.csproj` for iOS'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HelloWorld.iOS.csproj` 用于iOS'
- en: '`HelloWorld.macOS.csproj` for macOS'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HelloWorld.macOS.csproj` 用于macOS'
- en: '`HelloWorld.Skia.Gtk.csproj` for Linux with GTK'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HelloWorld.Skia.Gtk.csproj` 用于带有GTK的Linux'
- en: '`HelloWorld.Skia.Tizen.csproj` for Tizen'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HelloWorld.Skia.Tizen.csproj` 用于Tizen'
- en: '`HelloWorld.Skia.Wpf.csproj`: Base project for Windows 7 and Windows 8'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HelloWorld.Skia.Wpf.csproj`：用于Windows 7和Windows 8的基本项目'
- en: '`HelloWorld.Skia.Wpf.WpfHost.csproj`: Host for the `HelloWorld.Skia.Wpf` project
    on Windows 7 and Windows 8'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HelloWorld.Skia.Wpf.WpfHost.csproj`：用于Windows 7和Windows 8上的`HelloWorld.Skia.Wpf`项目的主机'
- en: '`HelloWorld.UWP.csproj` for Windows 10'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HelloWorld.UWP.csproj` 用于Windows 10'
- en: '`HelloWorld.Wasm.csproj` for WebAssembly (WASM)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HelloWorld.Wasm.csproj` 用于WebAssembly（WASM）'
- en: Those projects are also called `UIApplication` for iOS, creating and displaying
    an `NSApplication` on macOS, or starting the application on WASM.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些项目也被称为iOS的`UIApplication`，在macOS上创建和显示`NSApplication`，或在WASM上启动应用程序。
- en: Some specific settings and configurations, such as permissions required by your
    app, will differ based on the platform. Some platforms allow you to use APIs without
    any restrictions. In contrast, other platforms are more prohibitive and require
    your app to specify those APIs beforehand or ask the user for permission, which
    is something you have to configure in the head project. As those configurations
    need to be done in the individual heads, the experience will differ based on the
    different platforms. We will only cover parts of those differences when configuring
    the platform heads in [*Chapter 3*](B17132_03_Final_VK_ePub.xhtml#_idTextAnchor052),
    *Working with Forms and Data*, (Mac, WASM, and UWP) and [*Chapter 4*](B17132_04_Final_VK_ePub.xhtml#_idTextAnchor064),
    *Mobilizing Your App*, (Android and iOS) as part of developing apps for those
    platforms.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 基于平台的一些特定设置和配置，例如应用程序所需的权限，将根据平台而异。一些平台允许您无任何限制地使用API。相反，其他平台更加禁止，并要求您的应用程序事先指定这些API或要求用户授予权限，这是您必须在头项目中配置的内容。由于这些配置需要在各个头项目中完成，因此在不同平台上的体验将有所不同。在[*第3章*](B17132_03_Final_VK_ePub.xhtml#_idTextAnchor052)中配置平台头时，我们将仅涵盖部分这些差异，*使用表单和数据*（Mac、WASM和UWP），以及[*第4章*](B17132_04_Final_VK_ePub.xhtml#_idTextAnchor064)，*使您的应用程序移动*（Android和iOS）作为为这些平台开发应用程序的一部分。
- en: In contrast to the head projects, the **shared project** is where almost all
    of your app's code will be, including your pages and views, the core logic of
    the app, and any assets such as resources or images that will be used on every
    platform. The shared project is referenced by all of the platform heads, so any
    code placed in there will be used on all of the platforms. If you are not familiar
    with C# shared projects, shared projects are nothing more than a list of files
    that will be included when compiling a project that references the shared project.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与头项目相比，**共享项目**是几乎所有应用程序代码的所在地，包括页面和视图、应用程序的核心逻辑以及任何资源或图像等资产，这些资产将在每个平台上使用。共享项目被所有平台头引用，因此放在那里的任何代码都将在所有平台上使用。如果您不熟悉C#共享项目，共享项目只不过是一个在编译引用共享项目的项目时将被包含的文件列表。
- en: 'A newly created cross-platform app like our **Hello World** app already comes
    with a few files in the shared project:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 像我们的**Hello World**应用程序这样的新创建的跨平台应用程序已经在共享项目中带有一些文件：
- en: '`App.xaml.cs`: This is the app''s entry point; it will load the UI and navigate
    to `MainPage`. In here, you can also configure the logging of events by uncommenting
    the respective lines in the `InitializeLogging` function.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.xaml.cs`：这是应用程序的入口点；它将加载UI并导航到`MainPage`。在这里，您还可以通过取消注释`InitializeLogging`函数中的相应行来配置事件的日志记录。'
- en: '`App.xaml`: This contains the list of common XAML resources such as resource
    dictionaries and theme resources.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App.xaml`：这包含了常见的XAML资源列表，如资源字典和主题资源。'
- en: '`MainPage.xaml.cs`: This file contains the C# code of your `MainPage`.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainPage.xaml.cs`：这个文件包含了你的`MainPage`的C#代码。'
- en: '`MainPage.xaml`: This is where you can put the UI of your `MainPage`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainPage.xaml`：这是您可以放置`MainPage`的UI的地方。'
- en: '`Assets/SharedAssets.md`: This is a demo asset file that is included to show
    how assets work inside an Uno Platform app.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assets/SharedAssets.md`：这是一个演示资产文件，用于展示在Uno平台应用程序中如何使用资产。'
- en: '`Strings/en/Resources.resw`: This is also a demo asset file that you can use
    to get started with localization inside your Uno Platform app.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Strings/en/Resources.resw`：这也是一个演示资产文件，您可以使用它来开始在Uno平台应用程序中进行本地化。'
- en: Now that you are familiar with the project structure of your first Uno Platform
    app, let's dive into building and running your app.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了您的第一个Uno平台应用程序的项目结构，让我们深入了解如何构建和运行您的应用程序。
- en: Building and running your first Uno Platform app
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行您的第一个Uno平台应用程序
- en: Since you are familiar with the structure of an Uno Platform app, we can get
    to building and running your first Uno Platform app! In this section, we will
    go over the different ways of building and running your app.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您熟悉了Uno平台应用程序的结构，我们可以开始构建和运行您的第一个Uno平台应用程序了！在本节中，我们将介绍构建和运行应用程序的不同方法。
- en: Running and debugging your app with Visual Studio on Windows
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Windows上使用Visual Studio运行和调试您的应用程序
- en: Running your Uno Platform app from within Visual Studio is exactly the same
    as running a regular UWP, `Xamarin.Forms`, or WASM app. To build and run the app
    on a specific device or emulator, you can select the corresponding head from the
    startup project dropdown. Note that depending on the selected configuration, target
    platform, and architecture, not every project will be compiled to the expected
    output and might even not get compiled at all. For example, the UWP project always
    targets explicit architectures and as such, will compile to x86 when selecting
    the **Any CPU** architecture. That means not all combinations of target architecture
    and project will compile into what is specified but rather will fall back to a
    default architecture such as x86 in the case of UWP.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从Visual Studio中运行您的Uno平台应用程序与运行常规的UWP、`Xamarin.Forms`或WASM应用程序完全相同。要在特定设备或模拟器上构建和运行应用程序，可以从启动项目下拉菜单中选择相应的头。请注意，根据所选的配置、目标平台和架构，不是每个项目都会编译成预期的输出，甚至可能根本不会被编译。例如，UWP项目始终针对明确的架构进行编译，因此在选择**任意CPU**架构时将编译为x86。这意味着并非所有目标架构和项目的组合都会编译成指定的内容，而是会退回到默认架构，例如在UWP的情况下是x86。
- en: 'To run the UWP app, select the **HelloWorld.UWP** project as the startup project
    if it isn''t already selected, by choosing **HelloWorld.UWP** from the startup
    project dropdown as shown in *Figure 2.6*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行UWP应用程序，如果尚未选择**HelloWorld.UWP**项目作为启动项目，请从启动项目下拉菜单中选择**HelloWorld.UWP**，如*图2.6*所示：
- en: '![Figure 2.6 – Configuration, architecture, startup project, and target machine
    options in Visual Studio'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6 - Visual Studio中的配置、架构、启动项目和目标机器选项'
- en: '](img/Figure_2.06_B17132.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.06_B17132.jpg)'
- en: Figure 2.6 – Configuration, architecture, startup project, and target machine
    options in Visual Studio
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 - Visual Studio中的配置、架构、启动项目和目标机器选项
- en: 'After that, select the correct architecture for your machine and the run configuration,
    debug, or release you want to run. Since we are going to debug the app in the
    next section, choose **Debug** for now. After that, you can choose the target
    device to deploy to, that is, the local machine, a connected device, or an emulator.
    To do that, use the dropdown to the right of the project list shown in *Figure
    2.7*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，选择适合您的计算机架构和要运行的运行配置、调试或发布。由于我们将在下一节中调试应用程序，请暂时选择**调试**。之后，您可以选择要部署到的目标设备，即本地计算机、连接的设备或模拟器。要做到这一点，请使用*图2.7*中项目列表右侧的下拉菜单：
- en: '![Figure 2.7 – List of Android emulators in Visual Studio'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7 - Visual Studio中的Android模拟器列表'
- en: '](img/Figure_2.07_B17132.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.07_B17132.jpg)'
- en: Figure 2.7 – List of Android emulators in Visual Studio
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 - Visual Studio中的Android模拟器列表
- en: 'You can then start the project by clicking on the green arrow or hitting *F5*.
    The app will build, and you should be greeted by something like *Figure 2.8*:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过单击绿色箭头或按下*F5*来启动项目。应用程序将构建，然后您应该会看到类似*图2.8*的东西：
- en: '![Figure 2.8 – Screenshot of the HelloWorld app running on Windows 10'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.8 - 运行在Windows 10上的HelloWorld应用程序的屏幕截图'
- en: '](img/Author_Figure_2.08_B17132.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Author_Figure_2.08_B17132.jpg)'
- en: Figure 2.8 – Screenshot of the HelloWorld app running on Windows 10
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 - 运行在Windows 10上的HelloWorld应用程序的屏幕截图
- en: Congratulations, you have just run your first Uno Platform app! Of course, running
    your app on Windows is not the only part of developing your cross-platform app.
    Running and debugging your app on Android, iOS, and other platforms is vital when
    writing cross-platform apps to ensure your apps work on all platforms supported.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您刚刚运行了您的第一个Uno平台应用程序！当然，在Windows上运行应用程序并不是开发跨平台应用程序的唯一部分。在Android、iOS和其他平台上运行和调试您的应用程序对于编写跨平台应用程序来说是至关重要的，以确保您的应用程序在所有支持的平台上都能正常运行。
- en: For Android development, there are multiple different ways to try out and run
    your apps. One possibility is using an Android emulator, which comes with Visual
    Studio. For that, simply select the Android emulator from the target list dropdown
    as shown in *Figure 2.7*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android开发，有多种不同的方法可以尝试和运行您的应用程序。一种可能性是使用Visual Studio附带的Android模拟器。为此，只需从目标列表下拉菜单中选择Android模拟器，如*图2.7*所示。
- en: Note
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you haven't already added an Android emulator device image, you will only
    see **Android Emulator** as an option. To learn how to add and configure devices,
    the Visual Studio documentation ([https://docs.microsoft.com/en-us/xamarin/android/get-started/installation/android-emulator/device-manager](https://docs.microsoft.com/en-us/xamarin/android/get-started/installation/android-emulator/device-manager))
    covers creating new devices and configuring them for your needs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有添加Android模拟器设备映像，您将只看到**Android模拟器**作为选项。要了解如何添加和配置设备，Visual Studio文档([https://docs.microsoft.com/en-us/xamarin/android/get-started/installation/android-emulator/device-manager](https://docs.microsoft.com/en-us/xamarin/android/get-started/installation/android-emulator/device-manager))介绍了如何创建新设备并根据您的需求进行配置。
- en: If you have connected an Android phone to your computer, it will show up in
    the list of available target devices. An example of this can be seen with the
    Samsung device shown in *Figure 2.7*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已将Android手机连接到计算机，它将显示在可用目标设备列表中。可以在*图2.7*中看到Samsung设备的示例。
- en: Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For optimal development experience with Visual Studio, when editing C# or XAML
    files, ensure Visual Studio will use the UWP head for IntelliSense since, otherwise,
    IntelliSense might not work correctly. For this, when you have opened a C# or
    XAML file, select the UWP head from the dropdown below the tab name of the opened
    file.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得与Visual Studio的最佳开发体验，在编辑C#或XAML文件时，请确保Visual Studio将使用UWP头进行智能感知，否则智能感知可能无法正常工作。为此，在打开C#或XAML文件时，从下拉菜单中选择已打开文件的选项卡名称下方的UWP头。
- en: Pairing Visual Studio for Windows with a Mac
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将Windows的Visual Studio与Mac配对
- en: For testing and debugging the iOS head, you can either directly develop on a
    Mac, which we will cover in the next section, or you can pair your Visual Studio
    for Windows with a Mac to remotely debug the iOS head.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试和调试iOS头，您可以直接在Mac上开发，我们将在下一节中介绍，或者您可以将Windows的Visual Studio与Mac配对，以远程调试iOS头。
- en: 'The *Mobile development with .NET* workload in Visual Studio includes the software
    needed to connect to a Mac. However, there are three steps required to fully configure
    it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中的*使用.NET进行移动开发*工作负载包括连接到Mac所需的软件。但是，需要三个步骤才能完全配置它：
- en: Install **Xcode** and **Visual Studio for Mac** on the Mac and open these apps
    to ensure all dependencies are installed.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Mac上安装**Xcode**和**Visual Studio for Mac**，并打开这些应用程序以确保安装了所有依赖项。
- en: Enable **Remote login** on the Mac.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Mac上启用**远程登录**。
- en: Connect to the Mac from Visual Studio.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Visual Studio连接到Mac。
- en: 'Enabling remote login on the Mac requires the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上启用远程登录需要以下步骤：
- en: Open the **Sharing** pane in **System Preferences**.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**系统偏好设置**中打开**共享**窗格。
- en: Check **Remote Login** and specify the users to **Allow access for:**.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查**远程登录**并指定**允许访问的用户：**。
- en: Change any firewall settings as prompted.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据提示更改防火墙设置。
- en: 'To connect from Visual Studio, do the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Visual Studio连接，请执行以下操作：
- en: Go to **Tools** >**iOS**>**Pair to Mac.**
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转到**工具**>**iOS**>**配对到Mac**。
- en: If you're doing this for the first time, select **Add Mac…** and enter the Mac
    name or IP address, and then the username and password when prompted.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您是第一次这样做，请选择**添加Mac…**并输入Mac名称或IP地址，然后在提示时输入用户名和密码。
- en: If the Mac is already listed, select it and click **Connect**.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果Mac已列出，请选择它并单击**连接**。
- en: The tool will check everything needed is installed and available on the Mac,
    and then it will open the connection.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具将检查Mac上安装和可用的所有必需内容，然后打开连接。
- en: If there's a problem, it will tell you what to do to address it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现问题，它将告诉您如何解决。
- en: Note.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意。
- en: More detailed instructions on pairing Visual Studio to a Mac and advice on addressing
    any problems you may encounter are available at [https://docs.microsoft.com/xamarin/ios/get-started/installation/windows/connecting-to-mac/](https://docs.microsoft.com/xamarin/ios/get-started/installation/windows/connecting-to-mac/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有关将Visual Studio配对到Mac以及解决可能遇到的任何问题的更详细说明，请访问[https://docs.microsoft.com/xamarin/ios/get-started/installation/windows/connecting-to-mac/](https://docs.microsoft.com/xamarin/ios/get-started/installation/windows/connecting-to-mac/)。
- en: With Visual Studio now successfully paired to your Mac, you're able to debug
    the app from your Windows machine and see it running on the remoted iOS simulator.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Visual Studio已成功与您的Mac配对，您可以从Windows机器调试应用程序，并在远程iOS模拟器上运行它。
- en: Running and debugging your apps with Visual Studio for Mac
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Visual Studio for Mac运行和调试应用程序
- en: If you are primarily working on a Mac, using Visual Studio for Mac is the easiest
    way of developing your Uno Platform app.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您主要在Mac上工作，使用Visual Studio for Mac是开发Uno平台应用程序的最简单方法。
- en: Running your Uno Platform app using Visual Studio for Mac is the same as running
    other apps. You will need to select the correct head project in the startup project
    list (for example, `HelloWorld.macOS` or `HelloWorld.iOS`), select the correct
    target architecture to run the app for, and the device or emulator to run the
    app on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Visual Studio for Mac运行Uno平台应用程序与运行其他应用程序相同。您需要在启动项目列表中选择正确的头项目（例如，`HelloWorld.macOS`或`HelloWorld.iOS`），选择正确的目标架构来运行应用程序，并选择设备或模拟器来运行应用程序。
- en: Of course, in addition to running the app on your local machine, you can also
    run the Android or iOS app on an emulator. Any suitable devices that you can run
    the Android or iOS build of your app on will show up as targets in Visual Studio
    for Windows, including any emulators or simulators.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除了在本地机器上运行应用程序之外，您还可以在模拟器上运行Android或iOS应用程序。您可以在Windows的Visual Studio中将任何适用的设备作为目标，包括任何模拟器或仿真器。
- en: Since debugging the WASM build of your Uno Platform apps will happen outside
    of Visual Studio and Visual Studio for Mac, we will cover this in the next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Uno平台应用程序的WASM版本的调试将在Visual Studio和Visual Studio for Mac之外进行，我们将在下一节中介绍这一点。
- en: Debugging the WASM head of your app
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试应用程序的WASM头
- en: 'At the time of writing, debugging WASM from inside Visual Studio or Visual
    Studio for Mac is not well supported, however, there are alternative options.
    Because of this, the debugging experience for WASM will instead take place inside
    your browser when using Visual Studio for Windows or Visual Studio for Mac. For
    the best debugging experience, we recommend using the latest Canary build of Google
    Chrome. This is available from [https://www.google.com/chrome/canary/](https://www.google.com/chrome/canary/).
    Since debugging WASM is still experimental, and as such will likely change, we
    highly recommend visiting the official documentation ([https://platform.uno/docs/articles/debugging-wasm.html](https://platform.uno/docs/articles/debugging-wasm.html))
    to get the latest information. You can learn more about debugging the WASM head
    with Visual Studio here: [https://platform.uno/blog/debugging-uno-platform-webassembly-apps-in-visual-studio-2019/](https://platform.uno/blog/debugging-uno-platform-webassembly-apps-in-visual-studio-2019/).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，从Visual Studio或Visual Studio for Mac内部调试WASM的支持并不是很好，但是有替代选项。因此，当使用Visual
    Studio for Windows或Visual Studio for Mac时，WASM的调试体验将在浏览器中进行。为了获得最佳的调试体验，我们建议使用最新的Google
    Chrome Canary版本。这可以从[https://www.google.com/chrome/canary/](https://www.google.com/chrome/canary/)获取。由于WASM的调试仍处于实验阶段，因此可能会发生变化，我们强烈建议访问官方文档([https://platform.uno/docs/articles/debugging-wasm.html](https://platform.uno/docs/articles/debugging-wasm.html))获取最新信息。您可以在这里了解有关使用Visual
    Studio调试WASM头的更多信息：[https://platform.uno/blog/debugging-uno-platform-webassembly-apps-in-visual-studio-2019/](https://platform.uno/blog/debugging-uno-platform-webassembly-apps-in-visual-studio-2019/)。
- en: 'Alternatively, you can use Visual Studio Code to debug the WASM version of
    your app. For an optimal experience, you should create your Uno Platform app with
    the `dotnet new` CLI. You must include the `–vscodeWasm` flag, as shown here,
    since it will add build configurations that you can use in Visual Studio Code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用Visual Studio Code来调试应用程序的WASM版本。为了获得最佳体验，您应该使用`dotnet new`CLI创建Uno
    Platform应用程序。您必须包括`–vscodeWasm`标志，如下所示，因为它将添加您可以在Visual Studio Code中使用的构建配置：
- en: '[PRE2]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that with the preceding `dotnet new` command, we opted out of the other
    heads since, at the time of writing, only the WASM version can be debugged with
    Visual Studio Code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过前面的`dotnet new`命令，我们选择了不使用其他头部，因为在撰写本文时，只有WASM版本可以在Visual Studio Code中进行调试。
- en: If you already have created your app, please follow the steps shown in the documentation
    at [https://platform.uno/docs/articles/get-started-vscode.html#updating-an-existing-application-to-work-with-vs-code](https://platform.uno/docs/articles/get-started-vscode.html#updating-an-existing-application-to-work-with-vs-code).
    This also works when heads for other platforms are already present in your project.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经创建了应用程序，请按照文档中显示的步骤进行操作[https://platform.uno/docs/articles/get-started-vscode.html#updating-an-existing-application-to-work-with-vs-code](https://platform.uno/docs/articles/get-started-vscode.html#updating-an-existing-application-to-work-with-vs-code)。当您的项目中已经存在其他平台的头部时，这也适用。
- en: 'To start your app and debug it with Visual Studio, first restore NuGet packages
    using `dotnet restore`. After that, you will need to start the development server.
    To do this, open the **RUN AND DEBUG** panel shown in *Figure 2.9* by clicking
    on the triangle-bug icon on the left of Visual Studio Code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Visual Studio启动应用程序并进行调试，首先使用`dotnet restore`恢复NuGet包。之后，您需要启动开发服务器。要做到这一点，打开Visual
    Studio Code左侧的三角形图标，显示**运行和调试**面板，如*图2.9*所示：
- en: '![Figure 2.9 – RUN AND DEBUG view of Visual Studio Code'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9 - Visual Studio Code的运行和调试视图'
- en: '](img/Figure_2.09_B17132.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.09_B17132.jpg)'
- en: Figure 2.9 – RUN AND DEBUG view of Visual Studio Code
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 - Visual Studio Code的运行和调试视图
- en: 'Click on the arrow, which will run the **.NET Core Launch** configuration,
    which builds the app and starts a development server. The development server will
    host your app. Check the terminal output to see on which URL you can visit the
    WASM app on your local machine, as shown in *Figure 2.10*:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 单击箭头，将运行**.NET Core Launch**配置，该配置将构建应用程序并启动开发服务器。开发服务器将托管您的应用程序。检查终端输出，以查看您可以在本地计算机上访问WASM应用程序的URL，如*图2.10*所示：
- en: '![Figure 2.10 – Terminal output of the development server'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.10 - 开发服务器的终端输出'
- en: '](img/Figure_2.10_B17132.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.10_B17132.jpg)'
- en: Figure 2.10 – Terminal output of the development server
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 - 开发服务器的终端输出
- en: If you just want to start the app and continue without debugging capabilities,
    you are done here. However, if you want to take advantage of the debugging and
    breakpoint support, you will also have to select the **.NET Core Debug Uno Platform
    WebAssembly in Chrome** configuration. After selecting the launch configuration
    in the **Run and Debug** panel, start it, which will start the debugging server.
    The debugging server then opens a browser window with your Uno Platform WASM app
    opened.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想启动应用程序并在没有调试功能的情况下继续，那么您已经完成了。但是，如果您想利用调试和断点支持，您还需要选择**在Chrome中的.NET Core
    Debug Uno Platform WebAssembly**配置。在**运行和调试**面板中选择启动配置后，启动它，这将启动调试服务器。然后，调试服务器会打开一个浏览器窗口，其中包含您的Uno
    Platform WASM应用程序。
- en: Note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: By default, the debugging server will start using the latest stable release
    of Google Chrome. If you have no stable release of Google Chrome installed, the
    server will not start. If you wish to use the latest stable release of Edge instead,
    you can update the `.vscode/launch.json` file and change `pwa-chrome` to `pwa-msedge`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，调试服务器将使用最新的稳定版Google Chrome启动。如果您没有安装稳定版的Google Chrome，服务器将无法启动。如果您希望改用最新的稳定版Edge，可以更新`.vscode/launch.json`文件，并将`pwa-chrome`更改为`pwa-msedge`。
- en: After the debugging server has started and is ready for requests, it will open
    the website in Chrome or Edge depending on your configuration. Any breakpoints
    you place in Visual Studio Code will be respected by the browser and pause your
    WASM app, similar to how breakpoints would work with Visual Studio on non-WASM
    projects.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 调试服务器启动并准备好接收请求后，它将根据您的配置在Chrome或Edge中打开网站。您在Visual Studio Code中放置的任何断点都将被浏览器所尊重，并暂停您的WASM应用程序，类似于在非WASM项目上使用Visual
    Studio时断点的工作方式。
- en: 'After successfully completing these steps, you can open your app in a browser
    of your choice and it will look like *Figure 2.11*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 成功完成这些步骤后，您可以在所选的浏览器中打开应用程序，它将看起来像*图2.11*：
- en: '![Figure 2.11 – HelloWorld app running in the browser'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.11–在浏览器中运行的HelloWorld应用程序'
- en: '](img/Figure_2.11_B17132.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.11_B17132.jpg)'
- en: Figure 2.11 – HelloWorld app running in the browser
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11–在浏览器中运行的HelloWorld应用程序
- en: 'Now that we covered running and debugging your app, let''s quickly cover two
    very helpful features for developing with Uno Platform: XAML Hot Reload and C#
    Edit and Continue.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了运行和调试应用程序，让我们快速介绍一下使用Uno Platform进行开发的两个非常有用的功能：XAML Hot Reload和C#编辑和继续。
- en: XAML Hot Reload and C# Edit and Continue
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XAML Hot Reload和C#编辑和继续
- en: To make development easier and faster, especially UI development, Uno Platform
    supports XAML Hot Reload and C# Edit and Continue when developing with Visual
    Studio. XAML Hot Reload allows you to modify the XAML code of your views and pages,
    and the running app will update in real time, while C# Edit and Continue allows
    you to modify C# code without having to restart your app for changes to be picked
    up.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使开发更加简单和快速，特别是UI开发，Uno Platform在使用Visual Studio进行开发时支持XAML Hot Reload和C#编辑和继续。XAML
    Hot Reload允许您修改视图和页面的XAML代码，运行的应用程序将实时更新，而C#编辑和继续允许您修改C#代码，而无需重新启动应用程序以捕获更改。
- en: Since the UWP head of your app is being built using the UWP toolchain, you can
    use XAML Hot Reload and C# Edit and Continue. Since at the time of writing, UWP
    is the only platform supporting both, we will use UWP to showcase it. Other platforms
    do not support C# Edit and Continue, but do, however, support XAML Hot Reload.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的应用程序的UWP头部是使用UWP工具链构建的，因此您可以使用XAML Hot Reload和C#编辑和继续。由于在撰写本文时，UWP是唯一支持两者的平台，因此我们将使用UWP来展示它。其他平台不支持C#编辑和继续，但是支持XAML
    Hot Reload。
- en: XAML Hot Reload
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XAML Hot Reload
- en: 'To try out XAML Hot Reload, open your `MainPage.xaml` file inside the shared
    project. The page''s content will just be a `Grid` and a `TextBlock`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试XAML Hot Reload，请在共享项目中打开`MainPage.xaml`文件。页面的内容将只是一个`Grid`和一个`TextBlock`：
- en: '[PRE3]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now let's change our page by replacing the text with **Hello from hot reload!**,
    save the file (*Ctrl* + *S*), and voilà, our app now looks like as shown in *Figure
    2.12* without having restarted the app!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过用**Hello from hot reload!**替换文本来更改我们的页面，保存文件（*Ctrl* + *S*），我们的应用程序现在看起来像*图2.12*所示，而无需重新启动应用程序！
- en: '![Figure 2.12 – Our HelloWorld app with XAML Hot Reload changes'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.12–我们的HelloWorld应用程序使用XAML Hot Reload更改'
- en: '](img/Author_Figure_2.12_B17132.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Author_Figure_2.12_B17132.jpg)'
- en: Figure 2.12 – Our HelloWorld app with XAML Hot Reload changes
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12–我们的HelloWorld应用程序使用XAML Hot Reload更改
- en: XAML Hot Reload works on UWP, iOS, Android, and WebAssembly. However, not all
    types of changes are supported, for example, changing the event handler of controls
    is not supported by XAML Hot Reload and requires an app restart. In addition to
    that, updating `ResourceDictionary` files will also not update the app and will
    require an app restart.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: XAML Hot Reload可以在UWP、iOS、Android和WebAssembly上运行。但是，并非所有类型的更改都受支持，例如，更改控件的事件处理程序不受XAML
    Hot Reload支持，需要应用程序重新启动。除此之外，更新`ResourceDictionary`文件也不会更新应用程序，需要应用程序重新启动。
- en: C# Edit and Continue
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C#编辑和继续
- en: 'Sometimes, you also need to make changes to your "*code-behind*", and that''s
    where C# Edit and Continue will be your friend. Note that you will need to use
    the UWP head of your app since it is the only platform supporting C# Edit and
    Continue. Before we continue with trying out C# Edit and Continue, you will need
    to add a few things since our HelloWorld app doesn''t contain much C# code yet.
    For that, first, you will need to close the debugger and the app since the following
    code changes are not supported by C# Edit and Continue. Update your page to contain
    a button with a `Click` event handler by changing your `MainPage` content to this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您还需要对“*code-behind*”进行更改，这就是C#编辑和继续将成为您的朋友的地方。请注意，您需要使用应用程序的UWP头部，因为它是唯一支持C#编辑和继续的平台。在继续尝试C#编辑和继续之前，您需要添加一些内容，因为我们的HelloWorld应用程序尚不包含太多C#代码。首先，您需要关闭调试器和应用程序，因为C#编辑和继续不支持以下代码更改。通过将`MainPage`内容更改为以下内容，更新您的页面以包含具有`Click`事件处理程序的按钮：
- en: '[PRE4]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, in your `MainPage` class, add the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在您的`MainPage`类中，添加以下代码：
- en: '[PRE5]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When you run the app and click on the button, the text will change to **Hello
    from code behind!**. Now click the **Break all** button highlighted in *Figure
    2.13* or press *Ctrl* + *Alt* + *Break:*
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行应用程序并单击按钮时，文本将更改为**Hello from code behind!**。现在单击*图2.13*中突出显示的**全部中断**按钮，或按*Ctrl*
    + *Alt* + *Break*：
- en: '![Figure 2.13 – Break all button'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.13–全部中断按钮'
- en: '](img/Figure_2.13_B17132.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.13_B17132.jpg)'
- en: Figure 2.13 – Break all button
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13–全部中断按钮
- en: 'Your app is now paused and you can make changes to your C# code, which will
    be picked up when you resume your app by clicking on `Click` event handler to
    `Hello from C# Edit and Continue!`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序现在已暂停，您可以对C#代码进行更改，当您通过单击`Click`事件处理程序来恢复应用程序时，这些更改将被捕获为`Hello from C#
    Edit and Continue!`：
- en: '[PRE6]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then resume the app. If you now click on the button, the text will now change
    to **Hello from C# Edit and Continue!**.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后恢复应用程序。如果现在点击按钮，文本将更改为**Hello from C# Edit and Continue!**。
- en: There are some limitations on the changes you can make with Edit and Continue
    though; not all code changes are supported, for example, changing the type of
    an object. For a full list of unsupported changes, please visit the official documentation
    ([https://docs.microsoft.com/en-us/visualstudio/debugger/supported-code-changes-csharp](https://docs.microsoft.com/en-us/visualstudio/debugger/supported-code-changes-csharp)).
    Note that at the time of writing, C# Edit and Continue only works on Windows for
    the UWP and the Skia heads.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于编辑和继续，有一些限制；并非所有代码更改都受支持，例如，更改对象的类型。有关不受支持更改的完整列表，请访问官方文档（[https://docs.microsoft.com/en-us/visualstudio/debugger/supported-code-changes-csharp](https://docs.microsoft.com/en-us/visualstudio/debugger/supported-code-changes-csharp)）。请注意，在撰写本文时，C#编辑和继续仅在UWP和Skia头部的Windows上运行。
- en: Now that we have covered building and running your app, let's talk about conditional
    code, namely platform-specific C# and XAML.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了构建和运行应用程序，让我们谈谈条件代码，即特定于平台的C#和XAML。
- en: Platform-specific XAML and C#
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特定于平台的XAML和C#
- en: While Uno Platform allows you to run your app on any platform without having
    to worry about the underlying platform-specific API, there are still cases where
    you might want to write code that is specific to a platform, for example, accessing
    native platform APIs.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Uno平台允许您在任何平台上运行应用程序，而无需担心底层特定于平台的API，但仍然存在一些情况，您可能希望编写特定于平台的代码，例如访问本机平台API。
- en: Platform-specific C#
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定于平台的C#
- en: Writing platform-specific C# code is similar to writing architecture-specific
    or runtime-specific C# code. Uno Platform ships with a set of compiler symbols
    that will be defined when your code is being compiled for a specific platform.
    This is achieved using preprocessor directives. Preprocessor directives will only
    be respected by the compiler if the symbol was set for the compilation, otherwise,
    the compiler will completely ignore the preprocessor directive.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 编写特定于平台的C#代码类似于编写特定于架构或特定于运行时的C#代码。Uno平台附带了一组编译器符号，这些符号将在为特定平台编译代码时定义。这是通过使用预处理器指令实现的。预处理器指令只有在为编译设置了符号时，编译器才会尊重它们，否则编译器将完全忽略预处理器指令。
- en: 'At the time of writing, Uno Platform comes with the following preprocessor
    directives:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Uno平台附带了以下预处理器指令：
- en: '`NETFX_CORE` for UWP'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NETFX_CORE`用于UWP'
- en: '`__ANDROID__` for Android'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__ANDROID__`用于Android'
- en: '`__IOS__` for iOS'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__IOS__`用于iOS'
- en: '`HAS_UNO_WASM` (or `__WASM__`) for the web using WebAssembly'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HAS_UNO_WASM`（或`__WASM__`）用于使用WebAssembly的Web'
- en: '`__MACOS__` for macOS'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__MACOS__`用于macOS'
- en: '`HAS_UNO_SKIA` (or `__SKIA__`) for Skia-based heads'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HAS_UNO_SKIA`（或`__SKIA__`）用于基于Skia的头'
- en: Note that WASM and Skia have two different symbols available. Both are equally
    valid and have no difference except their name.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，WASM和Skia有两个不同的符号可用。两者都是有效的，除了它们的名称之外没有区别。
- en: 'You can use those exactly like you would any other symbols, such as `DEBUG`,
    and you can even combine them, for example, `if __ANDROID__ || __ MACOS__`. Let''s
    try it out in our example from earlier and have the `TextBlock` element indicate
    whether we are on desktop, the web, or mobile using C# symbols:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像使用`DEBUG`一样使用这些符号，甚至可以组合它们，例如`if __ANDROID__ || __ MACOS__`。让我们在之前的示例中尝试一下，并使用C#符号使`TextBlock`元素指示我们是在桌面、网络还是移动设备上：
- en: '[PRE7]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you run the UWP head of your app and click the button, the text will then
    change to `NETFX_CORE` symbol being set. Now, if you run the app on an Android
    or iOS emulator (or device) and click on the button, it will display `__ANDROID__`
    or the `__IOS__` symbols.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行应用程序的UWP头并单击按钮，然后文本将更改为设置的`NETFX_CORE`符号。现在，如果您在Android或iOS模拟器（或设备）上运行应用程序并单击按钮，它将显示`__ANDROID__`或`__IOS__`符号。
- en: Platform-specific XAML
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定于平台的XAML
- en: While platform-specific C# code is great, there are also cases where you need
    to render a control on a specific platform. This is where platform-specific XAML
    prefixes come in. XAML prefixes allow you to render controls only on specific
    platforms, similar to conditional namespaces for UWP.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然特定于平台的C#代码很棒，但也有一些情况需要在特定平台上呈现控件。这就是特定于平台的XAML前缀发挥作用的地方。XAML前缀允许您仅在特定平台上呈现控件，类似于UWP的条件命名空间。
- en: 'There are, at the time of writing, the following XAML prefixes that you can
    use:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，您可以使用以下XAML前缀：
- en: '![Figure 2.14 – Table of namespace prefixes, the supported platforms, and their
    namespace URIs'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.14 - 命名空间前缀表，支持的平台及其命名空间URI'
- en: '](img/Figure_2.14_B17132.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.14_B17132.jpg)'
- en: Figure 2.14 – Table of namespace prefixes, the supported platforms, and their
    namespace URIs
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 - 命名空间前缀表，支持的平台及其命名空间URI
- en: To include a specific XAML prefix in your XAML, you have to add `xmlns:[prefix-name]=[namespace
    URI]` at the top of the XAML file with all other namespace declarations. **Prefix-name**
    is the XAML prefix (column 1 in *Figure 2.14*) while **namespace URI** is the
    URI of the namespace (column 3 in *Figure 2.14*) the prefix should be used with.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要在XAML中包含特定的XAML前缀，您必须在XAML文件的顶部与所有其他命名空间声明一起添加`xmlns:[prefix-name]=[namespace
    URI]`。**前缀名称**是XAML前缀（*图2.14*中的第1列），而**命名空间URI**是应与之一起使用的命名空间的URI（*图2.14*中的第3列）。
- en: 'For prefixes that will be excluded from Windows, you need to add the prefixes
    to the `mc:Ignorable` list. Those prefixes are `android`, `ios`, `wasm`, `macos`,
    `skia`, `xamarin`, `netstdref`, `not_netstdref`, and `not_win`, so all prefixes
    that are not in `http: //schemas.microsoft.com/winfx/2006/xaml/presentation.`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将从Windows中排除的前缀，您需要将前缀添加到`mc:Ignorable`列表中。这些前缀是`android`、`ios`、`wasm`、`macos`、`skia`、`xamarin`、`netstdref`、`not_netstdref`和`not_win`，因此所有不在`http://schemas.microsoft.com/winfx/2006/xaml/presentation`中的前缀。
- en: 'Now let''s try out a few platform XAML prefixes by updating our HelloWorld
    project to have a `TextBlock` element that only renders on WASM. For that, we
    will first add the prefix to our `MainPage.xaml` file (note that we have omitted
    some definitions):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试一下通过更新我们的HelloWorld项目来使用一些平台XAML前缀，使`TextBlock`元素仅在WASM上呈现。为此，我们将首先将前缀添加到我们的`MainPage.xaml`文件中（请注意，我们省略了一些定义）：
- en: '[PRE8]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Since the Android, iOS, WASM, macOS, and Skia XAML prefixes will be excluded
    on Windows, we need to add them to the `mc:Ignorable` list. This is because they
    are not part of the standard XAML specification and would result in errors otherwise.
    After adding them, we can add controls that will render only if the app is running
    on a specific platform, for example, WASM or iOS. To try that out, we will add
    a `TextBlock` element to welcome users on each platform as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Android、iOS、WASM、macOS和Skia XAML前缀将在Windows上被排除，因此我们需要将它们添加到`mc:Ignorable`列表中。这是因为它们不是标准XAML规范的一部分，否则将导致错误。添加它们后，我们可以添加仅在应用程序在特定平台上运行时呈现的控件，例如WASM或iOS。要尝试这一点，我们将添加一个`TextBlock`元素来欢迎用户：
- en: '[PRE9]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, if you start the WASM head of your app and open the app in your browser
    (if it''s not open already), the app will show the `TextBlock` element, as shown
    on the left side of *Figure 2.15*. If you start the UWP head of your app now,
    the app will show **Welcome on Windows!** instead, as shown on the right side
    of *Figure 2.15*:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – HelloWorld app running using WASM (left) and using UWP (right)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.15_B17132.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.15 – HelloWorld app running using WASM (left) and using UWP (right)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using the XAML prefixes in cross-targeted libraries such as the
    `Cross Target Library (Uno Platform)` project template, which is covered in the
    next section, the XAML prefixes behave slightly differently. Because of the way
    cross-targeted libraries work, the `wasm` and `skia` prefixes will always evaluate
    to false. An example of a cross-targeted library is the `Cross-Runtime Library`
    project type, which we''ll cover in the next section. This is because both compile
    to .NET Standard 2.0 instead of the WASM or Skia heads. Instead of those prefixes,
    you can use the `netstdref` prefix with the namespace URI `http: //uno.ui/netstdref`,
    which will evaluate to true if running on WASM or Skia. In addition to that, there
    is also the `not_netstdref` prefix with the namespace URI `http: //uno.ui/not_netstdref`,
    which is the exact opposite of `netstdref`. Note that you will need to add both
    prefixes to the `mc:Ignorable` list. Now that you have learned about platform-specific
    code using C# compiler symbols and XAML prefixes, let''s look into the other project
    types.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Going beyond the default cross-platform app structure
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have created a cross-platform app that contains the heads for every
    platform. But there are also different project types that you can use to write
    your Uno Platform app, which we will cover in this section.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The `dotnet` CLI, do this now by opening a terminal and running `dotnet new
    -i Uno.ProjectTemplates.Dotnet`, since we will use these in the remaining part
    of the chapter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The multi-platform library project type
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important project types besides the **Multi-Platform App (Uno
    Platform)** project type is the **Cross-Platform Library (Uno Platform)** type.
    The **Cross-Platform Library (Uno Platform)** project type allows you to write
    code that can be consumed by Uno Platform apps. The easiest way of getting to
    know the project type is by creating a new cross-platform library. We will do
    this by creating a new project inside our existing HelloWorld solution.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: To be able to use all the project templates installed with the `dotnet new`
    CLI, you will need to allow Visual Studio to include the `dotnet new` templates
    in the project type list. You can do this by opening the options under **Tools
    > O****ptions** and opening the **Preview Features** section located under **Environment**
    by checking **Show all .NET Core templates in the New Project dialog**. After
    this, you will need to restart Visual Studio for the changes to take effect.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'After enabling that option, restart Visual Studio and open the new project
    dialog by right-clicking on the solution in the solution view and clicking **Add**
    > **New Project**. The dialog will look like *Figure 2.16*:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – The Add a new project dialog in Visual Studio'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Author_Figure_2.16_B17132.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.16 – The Add a new project dialog in Visual Studio
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Next, select the `HelloWorld.Helpers`. After entering the name, click **Create**.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'This will create a new cross-platform Uno Platform library in your solution.
    On disk, the library has its own folder named after itself and your solution view
    will look like *Figure 2.17*:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17 – HelloWorld solution view'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.17_B17132.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.17 – HelloWorld solution view
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add some code to our cross-platform library. We will rename the
    class `Class1` to `Greetings` and introduce a new public static function called
    `GetStandardGreeting` that will return the string `"Hello from a cross-platform
    library!"`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In addition to creating the library, you must also add a reference to it in
    each of the head projects you want to use the project in. The process of adding
    a reference to the library is the same for all heads, that's why we will only
    show you how to add the reference to the UWP head.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the reference to the UWP head, right-click the UWP project in Solution
    Explorer. Inside the context menu, you will find the **Add** category, which contains
    the **Reference…** option, which is also shown in *Figure 2.18*:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Add | Reference… option for the UWP head'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.18_B17132.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.18 – Add | Reference… option for the UWP head
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking on **Reference…**, a new dialog where you can select the reference
    to add will open. In our case, you will need to select the project, as shown in
    *Figure 2.19*:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19 – Reference Manager for the UWP head'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.19_B17132.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.19 – Reference Manager for the UWP head
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'After checking the `HelloWorld.Helpers` project, click **OK** to save the changes.
    Now we can use our library in the UWP version of the app. Let''s update our event
    handler from the platform''s conditional code section to use the Greetings helper
    class as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you run the UWP version of the app now and click on the button, the app will
    display `Helpers namespace` in the `HelloWorld namespace`. This is because we
    have not added a reference to the library from the macOS head yet. For any platform
    where you plan to use the library, you will need to add a reference in the platform's
    head. The procedure also applies to libraries being referenced as a NuGet package;
    you will need to add a reference to the NuGet package in every platform head that
    you want to use the library in. Unlike the Uno Platform app project, where most
    of the source code is inside a shared project, the **Cross-Platform Library**
    project type is a multi-targeted project.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Other project types
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the Cross-Platform Library project type, there are other Uno
    Platform project templates. We will cover them broadly in this section. To be
    able to create them from Visual Studio, enable displaying `dotnet` new templates
    in Visual Studio as shown in the last section.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: If you are already familiar with app development using XAML and the MVVM pattern,
    you might already know Prism ([https://prismlibrary.com/](https://prismlibrary.com/)),
    a framework *"for building XAML applications that are loosely coupled, maintainable,
    and testable."* Among the Uno Platform templates is also the **Cross-Platform
    App (Prism) (Uno Platform)** template, which will create a Prism Uno Platform
    app. Creating a Prism Uno Platform app is the same as creating a "normal" multi-platform
    Uno app.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the Uno Platform Prism app template, there is also an Uno Platform
    template for building apps for **WinUI 3**. However, you can create an Uno Platform
    app that uses a preview version of WinUI 3 for Windows 10\. To create an Uno Platform
    app using WinUI 3, in the new project dialog, choose the **Cross-Platform App
    (WinUI) (Uno Platform)** template.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Another project type that will be useful, especially when developing libraries
    that will be shipped using NuGet, is the **Cross-Runtime Library (Uno Platform)**
    project type, which will create a Cross-Runtime Library. In contrast to the Cross-Platform
    Library, where Skia and WASM versions are not built separately and cannot be distinguished,
    the Cross-Runtime Library will compile the project separately for WASM and Skia,
    allowing the writing of WASM- and Skia-specific code using XAML prefixes and compiler
    symbols.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: In addition to that, we also have the **Cross-Platform UI Tests Library**. The
    Cross- Platform UI Tests Library allows you to write UI tests that can be run
    on multiple platforms using a single code base. Since we will cover testing more
    thoroughly in [*Chapter 7*](B17132_07_Final_VK_ePub.xhtml#_idTextAnchor119), *Testing
    Your Apps*, we will cover that project type there.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们还有**跨平台UI测试库**。跨平台UI测试库允许您编写可以在多个平台上运行的UI测试，只需使用一个代码库。由于我们将在《第7章》中更全面地介绍测试，即《测试您的应用程序》，我们将在那里介绍该项目类型。
- en: Last but not least, we have the `Xamarin.Forms` apps to the web using WebAssembly
    and Uno Platform, which will be covered in [*Chapter 8*](B17132_08_Final_VK_ePub.xhtml#_idTextAnchor132),
    *Deploying Your Apps and Going Further*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，我们将在《第8章》中涵盖使用WebAssembly和Uno平台将`Xamarin.Forms`应用程序部署到Web上，即《部署您的应用程序并进一步》。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to create, build, and run your first Uno Platform
    app, and learned about the general solution structure and how platform heads work.
    We also covered building, running, and debugging your app on different platforms
    using Visual Studio and Visual Studio Code. In addition to that, you also learned
    about using XAML Hot Reload and C# Edit and Continue to make development easier.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何创建、构建和运行您的第一个Uno平台应用程序，并了解了一般解决方案结构以及平台头的工作原理。我们还介绍了如何使用Visual Studio和Visual
    Studio Code在不同平台上构建、运行和调试应用程序。除此之外，您还学会了如何使用XAML热重载和C#编辑和继续功能，以使开发更加轻松。
- en: In the next section, we will write apps for UnoBookRail, the company operating
    public transport in UnoBookCity. We will start off [*Chapter 3*](B17132_03_Final_VK_ePub.xhtml#_idTextAnchor052),
    *Working with Forms and Data*, by writing a task management app for UnoBookRail
    that allows entering, filtering, and editing data on the desktop and the web.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将为UnoBookRail编写应用程序，该公司运营UnoBookCity的公共交通。我们将从《第3章》开始，即《使用表单和数据》，为UnoBookRail编写一个任务管理应用程序，该应用程序允许在桌面和Web上输入、过滤和编辑数据。

- en: '*Chapter 5*: Making Your App Ready for the Real World'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：使您的应用程序准备好面向现实世界'
- en: In the last chapter, we covered writing your first mobile app using Uno Platform
    that was targeted toward employees of UnoBookRail. We will also write a mobile
    app in this chapter; however, we will focus on making it ready for customers.
    In this chapter, you will write an app that persists user preferences and larger
    sets of data on a device. In addition, you will also learn how to make your app
    more visually appealing to users with a custom app icon and how to write apps
    that can be used by people using assistive technology.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了使用Uno Platform编写面向UnoBookRail员工的第一个移动应用程序。在本章中，我们也将编写一个移动应用程序；但是，我们将专注于使其准备好供客户使用。在本章中，您将编写一个在设备上持久保存用户偏好和更大数据集的应用程序。此外，您还将学习如何通过自定义应用程序图标使您的应用程序对用户更具吸引力，以及如何编写可以供使用辅助技术的人使用的应用程序。
- en: 'To do that, we''ll cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将在本章中涵盖以下主题：
- en: Introducing the app
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍应用程序
- en: Persisting data locally using the `ApplicationData` API and SQLite
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ApplicationData` API和SQLite在本地持久化数据
- en: Making your app ready for customers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使您的应用程序准备好供客户使用
- en: Localizing your app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地化您的应用程序
- en: Using a custom app icon and splash screen
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义应用程序图标和启动画面
- en: Making your app accessible for all users
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使您的应用程序适用于所有用户
- en: By the end of this chapter, you'll have created a mobile app running on iOS
    and Android that is ready for customers and is also localized and accessible.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将创建一个在iOS和Android上运行的移动应用程序，该应用程序已准备好供客户使用，并且已进行本地化和可访问。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you already have your development environment set
    up, including installing the project templates, as was covered in [*Chapter 1*](B17132_01_Final_VK_ePub.xhtml#_idTextAnchor015),
    *Introducing Uno Platform*. The source code for this chapter is at [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter05](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter05).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已经设置好了开发环境，包括安装了项目模板，就像在[*第1章*](B17132_01_Final_VK_ePub.xhtml#_idTextAnchor015)中介绍的那样，*介绍Uno
    Platform*。本章的源代码位于[https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter05](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter05)。
- en: The code in this chapter makes use of the library from [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码使用了来自[https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary)的库。
- en: 'Check out the following video to see the code in action: [https://bit.ly/3AywuqQ](https://bit.ly/3AywuqQ)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[https://bit.ly/3AywuqQ](https://bit.ly/3AywuqQ)
- en: Introducing the app
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍应用程序
- en: 'In this chapter, we will build the UnoBookRail DigitalTicket app, an app targeting
    UnoBookRail''s customers that want to get from A to B using UnoBookRail. While
    the real version of this app would have a lot of features, in this chapter, we
    will only develop the following features:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建UnoBookRail DigitalTicket应用程序，这是一个面向想要使用UnoBookRail从A到B的UnoBookRail客户的应用程序。虽然这个应用程序的真实版本可能有很多功能，但在本章中，我们只会开发以下功能：
- en: Booking tickets for journeys between two stations of the UnoBookRail network
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预订UnoBookRail网络两个站点之间的行程车票
- en: Viewing all booked tickets as well as QR codes for the ticket
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看所有预订的车票以及车票的QR码
- en: Localization of the app and letting users choose the language being used for
    the app
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地化应用程序，并允许用户选择用于应用程序的语言
- en: As part of this, we will also ensure that our app is accessible and allow more
    people of different levels of ability to use our app. Let's start now by creating
    the app and adding the first bit of content.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 作为其中的一部分，我们还将确保我们的应用程序是可访问的，并允许不同能力水平的更多人使用我们的应用程序。现在让我们开始创建应用程序并添加第一部分内容。
- en: Creating the app
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建应用程序
- en: 'First of all, we need to set up the solution for our app:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的应用程序设置解决方案：
- en: Start by creating a new app using the **Multi-Platform App (Uno Platform)**template.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用**Multi-Platform App (Uno Platform)** 模板创建一个新的应用程序。
- en: Name the project `DigitalTicket`. Of course, you can use a different name; however,
    in this chapter, we will assume the app is named DigitalTicket and uses the respective
    namespace.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为`DigitalTicket`。当然，您也可以使用不同的名称；但是，在本章中，我们将假设该应用程序被命名为DigitalTicket，并使用相应的命名空间。
- en: Remove all platform heads except the **Android**, **iOS**, and **UWP** ones.
    Note that we also remove the WASM head even if there might be a benefit to providing
    this functionality on the web. While WASM works reasonably well on mobile devices,
    it is not ideal, and for simplicity, we will continue without the WASM version
    of the app.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除除**Android**、**iOS**和**UWP**之外的所有平台头。请注意，即使在网络上提供此功能可能会有好处，我们也会删除WASM头。虽然WASM在移动设备上运行得相当不错，但并不理想，为了简单起见，我们将继续不使用应用程序的WASM版本。
- en: Add the UnoBookRail shared library to the solution since we will need its functionality
    later. To do this, right-click on the solution file, select `UnoBookRail.Common.csproj`
    file, and click **Open**.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将UnoBookRail共享库添加到解决方案中，因为我们稍后将需要其功能。为此，请右键单击解决方案文件，选择`UnoBookRail.Common.csproj`文件，然后单击**打开**。
- en: Reference the shared library project in every head project. To do this, right-click
    on the head project, select **Add** | **Reference…** | **Projects**, check **UnoBookRail.Common**,
    and click **OK**. Since we need a reference to the library in every head, repeat
    this process for every head, that is, Android, iOS, and UWP.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个头项目中引用共享库项目。为此，请右键单击头项目，选择**添加** | **引用…** | **项目**，选中**UnoBookRail.Common**，然后单击**确定**。由于我们需要在每个头中引用该库，请为每个头重复此过程，即Android、iOS和UWP。
- en: 'Since our app will also follow the `Microsoft.Toolkit.MVVM` package, which
    you will also need to add a reference to:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序还将遵循`Microsoft.Toolkit.MVVM`包，您还需要添加对其的引用：
- en: Right-click the solution node in the solution view and select **Manage NuGet
    Packages for solution…**.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案视图中右键单击解决方案节点，然后选择**管理解决方案的NuGet包…**。
- en: Search for `Microsoft.Toolkit.MVVM` and select the **NuGet** package.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索`Microsoft.Toolkit.MVVM`并选择**NuGet**包。
- en: Select the Android, iOS, and UWP heads in the project list and click **Install**.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目列表中选择Android、iOS和UWP头部，然后点击**安装**。
- en: 'Similar to the previous chapter, we will also need to modify our app to leave
    space for camera notches to avoid the content of our app being occluded:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章类似，我们还需要修改我们的应用程序以留出相机刘海的空间，以避免应用程序的内容被遮挡：
- en: 'For this, add the following namespace to the `MainPage.xaml` file: `xmlns:toolkit="using:Uno.UI.Toolkit"`.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，在`MainPage.xaml`文件中添加以下命名空间：`xmlns:toolkit="using:Uno.UI.Toolkit"`。
- en: After this, add `toolkit:VisibleBoundsPadding.PaddingMask="All"` to the grid
    inside our `MainPage.xaml` file.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在我们的`MainPage.xaml`文件内的网格中添加`toolkit:VisibleBoundsPadding.PaddingMask="All"`。
- en: Creating the main navigation and booking process
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建主导航和预订流程
- en: 'Since our app will contain different features, we will split up the functionality
    of our app into different pages that we will navigate to. Inside `MainPage`, we
    will have our navigation and the code related to that:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序将包含不同的功能，我们将把应用程序的功能拆分成不同的页面，我们将导航到这些页面。在`MainPage`内，我们将有我们的导航和相关代码：
- en: First, start by creating a views folder by right-clicking `Views`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过右键单击`Views`创建一个views文件夹。
- en: Now, add the following three pages inside the `JourneyBookingPage.xaml`, `OwnedTicketsPage.xaml`,
    and `SettingsPage.xaml`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`JourneyBookingPage.xaml`、`OwnedTicketsPage.xaml`和`SettingsPage.xaml`内添加以下三个页面。
- en: 'Since we will need it later, create a `Utils` folder and add a `LocalizedResources`
    class to it with the following code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们以后会需要它，创建一个`Utils`文件夹，并添加一个`LocalizedResources`类，其中包含以下代码：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For now, this class will just return the string so we can reference the class
    and not have to update the code later. Later in this chapter, though, we will
    update the implementation to return the localized version for the keys provided.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个类只会返回字符串，这样我们就可以引用该类，而不必以后更新代码。不过，在本章的后面，我们将更新实现以返回提供的键的本地化版本。
- en: After that, create a `ViewModels` folder in your shared project and create a
    `NavigationViewModel` class.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在共享项目中创建一个`ViewModels`文件夹，并创建一个`NavigationViewModel`类。
- en: 'Add the following to your `NavigationViewModel` class:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到您的`NavigationViewModel`类：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code will expose the type of page `MainPage` should navigate to and provide
    a selection changed listener to update that whenever the selection of the app's
    navigation changes. To determine the correct page type, we will use the `Tag`
    property of the selected item.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将公开`MainPage`应该导航到的页面类型，并提供选择更改侦听器以在应用程序导航更改时更新。为了确定正确的页面类型，我们将使用所选项的`Tag`属性。
- en: 'Now, replace the content of `MainPage` with this:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，用以下内容替换`MainPage`的内容：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is the main navigation of our app. We use the `NavigationView` control
    for this, which allows us to easily have a side pane that can be opened using
    a hamburger button. Inside that, we provide the different navigation options and
    set the `Tag` property to be used by `NavigationViewModel`. Since we only allow
    the journey booking and the list of owned tickets in this chapter, we disable
    the other options for now.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们应用程序的主要导航。我们使用`NavigationView`控件来实现这一点，它允许我们轻松地拥有一个可以使用汉堡按钮打开的侧边窗格。在其中，我们提供不同的导航选项，并将`Tag`属性设置为`NavigationViewModel`使用。由于在本章中我们只允许预订行程和拥有的票证列表，我们暂时禁用了其他选项。
- en: 'Replace your `MainPage` class with the following:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下内容替换您的`MainPage`类：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this, `MainPage` will create the necessary view models once it is created
    and update the displayed content based on that. `MainPage` also listens to the
    `OnNavigatedTo` event to update the displayed item based on the arguments passed
    to it. Lastly, we also listen to the `NavigationViewModels` property changed event.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，`MainPage`在创建时将创建必要的视图模型，并根据此更新显示的内容。`MainPage`还监听`OnNavigatedTo`事件，以根据传递给它的参数更新显示的项目。最后，我们还监听`NavigationViewModels`属性更改事件。
- en: 'Note that we are overriding the `OnNavigatedTo` function to be able to allow
    navigating to `MainPage` and, within `MainPage`, to a specific page. While we
    don''t need this right now, we will use this later. Let''s continue by filling
    the journey booking page with some content:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们重写了`OnNavigatedTo`函数，以便允许导航到`MainPage`，以及在`MainPage`内导航到特定页面。虽然我们现在不需要这个，但以后我们会用到。让我们继续填充行程预订页面的内容：
- en: Create the `JourneyBookingOption` class inside the `ViewModels` folder.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewModels`文件夹内创建`JourneyBookingOption`类。
- en: 'Add the following code to the `JourneyBookingOption` class:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`JourneyBookingOption`类：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since this is a data object that will be used to display the options, it only
    contains properties. Since the title will be displayed inside the app and needs
    to be localized, we use the `LocalizedResources.GetString` function to determine
    the correct value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个用于显示选项的数据对象，它只包含属性。由于标题将显示在应用程序内并且需要本地化，我们使用`LocalizedResources.GetString`函数来确定正确的值。
- en: Now create the `JourneyBookingViewModel` class inside the `ViewModels` folder
    and add the code as seen on GitHub ([https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter05/DigitalTicket.Shared/ViewModels/JourneyBookingViewModel.cs](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter05/DigitalTicket.Shared/ViewModels/JourneyBookingViewModel.cs)).
    Note that a few lines are commented out, and that's because we will need those
    lines later; however, right now we haven't added the necessary code yet.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在`ViewModels`文件夹中创建`JourneyBookingViewModel`类，并添加GitHub上看到的代码（[https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter05/DigitalTicket.Shared/ViewModels/JourneyBookingViewModel.cs](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter05/DigitalTicket.Shared/ViewModels/JourneyBookingViewModel.cs)）。请注意，有几行被注释掉，那是因为我们稍后会需要这些行；但是，现在我们还没有添加必要的代码。
- en: Update `JourneyBookingPage.xaml.cs` and `JourneyBookingPage.xaml` so they are
    as seen on GitHub.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`JourneyBookingPage.xaml.cs`和`JourneyBookingPage.xaml`，使它们与GitHub上看到的一样。
- en: 'Copy the following entries into the `Strings.resw` file inside the `Strings/en`
    folder. Note that you don''t have to copy the `Comments` column word by word,
    as it is only there to provide guidance and context for the other two columns:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下条目复制到`Strings/en`文件夹中的`Strings.resw`文件中。请注意，您不必逐字复制`Comments`列，因为它只是为其他两列提供指导和上下文：
- en: '![Table 5.1](img/Table_01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![表5.1](img/Table_01.jpg)'
- en: 'As you might notice, some controls have the `x:Uid` property set, which is
    why the entries inside the `Strings.resw` file are needed. We will cover how these
    things work in the *Localizing your app* section; for now, we will only add the
    code and corresponding entries to our resources file. Now, if you start the app,
    you should be greeted by something as shown in *Figure 5.1*:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，一些控件设置了`x:Uid`属性，这就是为什么需要`Strings.resw`文件中的条目。我们将在*本地化您的应用程序*部分介绍这些工作原理；现在，我们只会添加代码和相应的条目到我们的资源文件中。现在，如果您启动应用程序，您应该会看到*图5.1*中显示的内容：
- en: '![Figure 5.1 – Journey booking page on Android'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 - Android上的旅程预订页面'
- en: '](img/Author_Figure_5.01_B17132.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Author_Figure_5.01_B17132.jpg)'
- en: Figure 5.1 – Journey booking page on Android
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 - Android上的旅程预订页面
- en: Now your users are able to configure their journey, select the ticket, and book
    it, albeit with less-than-ideal ticket names. We will fix this in the *Localizing
    your app* section. For simplicity, we will not deal with the actual payment and
    assume that payment information is associated with the user's account.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的用户可以配置他们的旅程，选择车票并预订，尽管车票名称不够理想。我们将在*本地化您的应用程序*部分中解决这个问题。为简单起见，我们将不处理实际付款，并假设付款信息与用户帐户关联。
- en: In this section, we added the initial code and navigation of our app. We also
    added the journey booking page, even though it currently doesn't actually book
    the tickets, which we will change later. In the next section, we will cover how
    to persist data locally on the user's device using two different methods, the
    `ApplicationData` API and SQLite.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们添加了应用程序的初始代码和导航。我们还添加了旅程预订页面，尽管目前实际上还没有预订车票，但我们稍后会更改。在下一节中，我们将介绍如何使用两种不同的方法在用户设备上本地持久化数据，即`ApplicationData`
    API和SQLite。
- en: Persisting data locally using the ApplicationData API and SQLite
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ApplicationData API和SQLite在本地持久化数据
- en: While in a lot of cases data can be fetched from the internet, as we have seen
    in [*Chapter 4*](B17132_04_Final_VK_ePub.xhtml#_idTextAnchor064), *Mobilizing
    Your App*, there is often a need to persist data on users' devices. This might
    be the case for data that needs to be available even when there is no internet
    connection or data that is device-specific such as settings. We will start by
    persisting small chunks of data using the `ApplicationData` API.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在许多情况下，数据可以从互联网上获取，就像我们在[*第4章*](B17132_04_Final_VK_ePub.xhtml#_idTextAnchor064)中看到的那样，*移动化您的应用程序*，通常需要在用户设备上持久化数据。这可能是需要在没有互联网连接时可用的数据，或者是设备特定的数据，例如设置。我们将首先使用`ApplicationData`
    API持久化小块数据。
- en: Storing data using the ApplicationData API
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ApplicationData API存储数据
- en: 'Since we will localize our app, we also want to give the users the possibility
    to choose the language of the app. To do this, first create a `Models` folder
    inside our shared project and add a `SettingsStore` class. Now, add the following
    code to the `SettingsStore` class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将本地化我们的应用程序，我们还希望用户能够选择应用程序的语言。为此，首先在我们的共享项目中创建一个`Models`文件夹，并添加一个`SettingsStore`类。现在，将以下代码添加到`SettingsStore`类中：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To access the app''s default local application storage, we use the `ApplicationData.Current.LocalSettings`
    object. The `ApplicationData` API also allows you to access different ways of
    storing data, for example, you can use it to access the app''s local folder using
    `ApplicationData.Current.LocalFolder`. In our case, though, we will use `ApplicationData.Current.LocalSettings`
    to persist data. The `LocalSettings` object is an `ApplicationDataContainer` object,
    which you can use just like a dictionary. Note, though, that the `LocalSettings`
    object only supports simple data types such as strings and numbers. Now that we
    have added a way to store which language to display the app in, we will need to
    let users change the language:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 访问应用程序的默认本地应用程序存储，我们使用`ApplicationData.Current.LocalSettings`对象。`ApplicationData`
    API还允许您访问存储数据的不同方式，例如，您可以使用它来访问应用程序的本地文件夹，使用`ApplicationData.Current.LocalFolder`。在我们的情况下，我们将使用`ApplicationData.Current.LocalSettings`来持久化数据。`LocalSettings`对象是一个`ApplicationDataContainer`对象，您可以像使用字典一样使用它。请注意，`LocalSettings`对象仅支持字符串和数字等简单数据类型。现在我们已经添加了一种存储要显示应用程序语言的方法，我们需要让用户更改语言：
- en: 'First, create a new class named `SettingsViewModel` inside our `ViewModels`
    folder. You can find the code for this class here: [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter05/DigitalTicket.Shared/ViewModels/SettingsViewModel.cs](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter05/DigitalTicket.Shared/ViewModels/SettingsViewModel.cs).'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we update our settings page to include the UI to change the app''s language.
    To do this, replace the `Grid` element inside `SettingsPage.xaml` with the following:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In addition to this, we will also need to update `SettingsPage.xaml.cs`. Note
    that we will set the `ItemsSource` of `ComboBox` in code-behind to ensure that
    `ItemsSource` will be set after the `ComboBox` has been created and is ready so
    that the `ComboBox` will update correctly. To do this, add the following code:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, to ensure that the selected language will be respected on the app''s
    start, add the following code inside the `OnLaunched` function of `App.xaml.cs`
    and add imports for `DigitalTicket.Models` and `DigitalTicket.ViewModels`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we have added the language option, let''s try it out. If you start
    the app now and navigate to the settings page using the navigation on the left,
    you should see something like on the left side of *Figure 5.2*. Now, if you select
    the `SettingsViewModel` reloads `MainPage` and all other pages after setting the
    `ApplicationLanguages.PrimaryLanguageOverride` property. We will talk more about
    this property in the *Localizing your app* section and also update the app so
    that all text currently visible also updates based on the language chosen:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Left: Settings page; Right: Navigation after switching language
    to German'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.02_B17132.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.2 – Left: Settings page; Right: Navigation after switching language
    to German'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Using SQLite to store data
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the `ApplicationData` API is good for storing small chunks of data, if
    you want to persist larger datasets of data, the `ApplicationData` API is not
    ideal since there are space limitations for the entries stored using the `ApplicationData.Current.LocalSettings`
    object. Namely, object keys can only be 255 characters in length and the entries
    can only be 8 kilobytes in size on UWP. Of course, this doesn't mean that you
    can't store larger or more complex datasets in your app. This is where `sqlite-net-pcl`
    library as this library works on every platform supported by our app. `sqlite-net-pcl`
    includes a platform-independent implementation of SQLite and allows us to easily
    serialize objects into SQLite databases.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding a reference to `sqlite-net-pcl` to our app. To do this,
    right-click the solution in the solution view, click `sqlite-net-pcl`. Since at
    the time of writing this book the latest stable release is version **1.7.335**,
    select that version and select the Android, iOS, and UWP heads in the project
    list. Then, click **Install**. Now we need to add code to create, load, and write
    the SQLite database:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to add a class whose objects we want to persist using
    SQLite. For this, add a new class called `OwnedTicket` inside the `ViewModels`
    folder. You can find the source code for this class on GitHub here: [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter05/DigitalTicket.Shared/ViewModels/OwnedTicket.cs](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter05/DigitalTicket.Shared/ViewModels/OwnedTicket.cs).'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are two important things to know:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Since every SQLite table needs a primary key, we added the `DBId` property with
    the PrimaryKey and `AutoIncrement` attributes. Using these properties, we let
    `sqlite-net-pcl` manage the primary keys for us and we don't have to deal with
    this.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: When passing objects to `sqlite-net-pcl` to persist them into a SQLite database,
    only properties will be persisted. Since we don't want to persist `ShowQRCodeCommand`
    (and actually can't), this is only a field, not a property.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象传递给`sqlite-net-pcl`以将它们持久化到SQLite数据库中，只有属性将被持久化。由于我们不想持久化`ShowQRCodeCommand`（实际上也不能），这只是一个字段，而不是属性。
- en: 'Now create the `OwnedTicketsRepository` class inside the `Models` folder and
    add the following code to it:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在`Models`文件夹中创建`OwnedTicketsRepository`类，并向其中添加以下代码：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `InitializeDatabase` function handles creating the file for our SQLite database
    and creating the table if it does not exist, but also loads the existing database
    if the file already exists. Inside the `SaveTicketsAsync` function, we update
    and save the passed ticket to the database or update the ticket if it already
    existed in the database.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`InitializeDatabase`函数处理创建我们的SQLite数据库文件和创建表（如果不存在），但也会在文件已经存在时加载现有数据库。在`SaveTicketsAsync`函数中，我们更新并保存传递的车票到数据库，或者如果数据库中已存在该车票，则更新该车票。'
- en: 'Update `App.xaml.cs` to include the following code at the start of the `OnLaunched`
    function and change the `OnLaunched` function to be async:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`App.xaml.cs`以在`OnLaunched`函数的开头包含以下代码，并将`OnLaunched`函数更改为异步：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will initialize the SQLite connection when the app starts since creating
    the connection on demand is not ideal, especially when loading the owned tickets
    page.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在应用程序启动时初始化SQLite连接，因为按需创建连接并不理想，特别是在加载所拥有的车票页面时。
- en: Now update `JourneyBookingViewModel` to save the ticket to `OwnedTicketsRepository`.
    To do this, remove the current creation of `BookJourney` and uncomment the `using`
    statements at the top of the file and the code inside the `JourneyBookingViewModel`
    constructor.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更新`JourneyBookingViewModel`以将车票保存到`OwnedTicketsRepository`。为此，请删除当前创建`BookJourney`并取消注释文件顶部的`using`语句以及`JourneyBookingViewModel`构造函数中的代码。
- en: Now let's talk about the steps we just did. First of all, we created our `OwnedTicket`
    object, which we will write to SQLite and also load from SQLite in the next section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈我们刚刚做的步骤。首先，我们创建了我们的`OwnedTicket`对象，我们将在下一节中将其写入SQLite并从SQLite中加载。
- en: 'We then added `OwnedTicketsRepository`, which we use to interact with our SQLite
    database. Before any requests can be made to the SQLite database, we first need
    to initialize it, for which we will need a file to write the SQLite database into.
    Using the following code, we ensure that the file we want to write our database
    to exists:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加了`OwnedTicketsRepository`，我们用它来与我们的SQLite数据库交互。在可以向SQLite数据库发出任何请求之前，我们首先需要初始化它，为此我们需要一个文件来将SQLite数据库写入其中。使用以下代码，我们确保我们要将数据库写入的文件存在：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After that, we create a `SQLiteAsyncConnection` object for our database. The
    `SQLiteAsyncConnection` object will handle all communication to SQLite, including
    creating tables and saving and loading data. Since we also need a table to write
    our data to, we use `SQLiteAsyncConnection` to create a table for our `OwnedTickets`
    objects if the table doesn't already exist within our SQLite database. To ensure
    that those steps will be done before any request to our database has been made,
    we call `OwnedTicketsRepository.InitializeDatabase()` inside our app constructor.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们为我们的数据库创建了一个`SQLiteAsyncConnection`对象。`SQLiteAsyncConnection`对象将处理与SQLite的所有通信，包括创建表和保存和加载数据。由于我们还需要一个表来写入我们的数据，我们使用`SQLiteAsyncConnection`为我们的`OwnedTickets`对象创建一个表，如果该表在我们的SQLite数据库中不存在。为了确保在对数据库进行任何请求之前执行这些步骤，我们在我们的应用程序构造函数中调用`OwnedTicketsRepository.InitializeDatabase()`。
- en: The last step was to update our `JourneyBookingViewModel` class to also persist
    data to the SQLite database. While we only add new items to our database, we still
    need to watch whether you are updating existing entries or adding a new entry,
    which is why the `SavedTicketAsync` function ensures we are only creating items
    if there is no ID present.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是更新我们的`JourneyBookingViewModel`类，以便将数据持久化到SQLite数据库中。虽然我们只向数据库中添加新项目，但我们仍然需要注意是否正在更新现有条目或添加新条目，这就是为什么`SavedTicketAsync`函数确保我们只在没有ID存在时才创建项目。
- en: Loading data from SQLite
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从SQLite加载数据
- en: Now that we have covered how to persist data, of course, we also need to load
    the data; otherwise, we wouldn't need to persist the data in the first place.
    Let's change this by adding an overview of all the tickets booked by the user.
    Since UnoBookRail customers will need to present their tickets when boarding a
    train or when tickets are checked, we also want to be able to display a QR code
    for every ticket. Since we will use `ZXing.Net.Mobile` for this, please add that
    **NuGet** package to your solution now, namely the Android, iOS, and UWP heads.
    Note that at the time of writing, version **2.4.1** was the latest stable release
    and we will use that version for this chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了如何持久化数据，当然，我们也需要加载数据；否则，我们就不需要首先持久化数据。让我们通过添加用户预订的所有车票的概述来改变这一点。由于UnoBookRail的客户需要在登上火车或检查车票时出示他们的车票，我们还希望能够为每张车票显示QR码。由于我们将使用`ZXing.Net.Mobile`来实现这一点，请立即将该**NuGet**包添加到您的解决方案中，即Android、iOS和UWP头。请注意，在撰写本文时，版本**2.4.1**是最新的稳定版本，我们将在本章中使用该版本。
- en: 'Before we want to display all tickets, we first need to load them from our
    SQLite database. To do this, add the following method to our `OwnedTicketsRepository`
    class:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们想要显示所有车票之前，我们首先需要从SQLite数据库中加载它们。为此，向我们的`OwnedTicketsRepository`类添加以下方法：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Thanks to `sqlite-net-pcl`, this is all we need to do. The library handles the
    rest for us, including reading the table and converting the rows into `OwnedTicket`
    objects.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`sqlite-net-pcl`，这就是我们需要做的一切。该库为我们处理了其余部分，包括读取表并将行转换为`OwnedTicket`对象。
- en: 'Now that we can also load tickets, we can update the `OwnedTicketsPage` class
    we created at the beginning of this chapter to display all the tickets booked
    by the user. In our app, this means that we will only display the tickets that
    have been booked on this device. In a real app, we would also access the tickets
    from a remote server and download them to the device; however, we won''t do this
    since it is out of scope for this chapter:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们也可以加载票了，我们可以更新本章开头创建的`OwnedTicketsPage`类，以显示用户预订的所有票。在我们的应用程序中，这意味着我们只会显示在此设备上预订的票。在真实的应用程序中，我们还会从远程服务器访问票务并将其下载到设备上；但是，由于这超出了本章的范围，我们不会这样做：
- en: 'Before we update our owned tickets page, first add an `OwnedTicketsViewModel`
    class inside the `ViewModels` folder. The source code for the class is available
    here: [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter05/DigitalTicket.Shared/ViewModels/OwnedTicketsViewModel.cs](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter05/DigitalTicket.Shared/ViewModels/OwnedTicketsViewModel.cs).'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更新拥有的票页面之前，首先在`ViewModels`文件夹中添加一个`OwnedTicketsViewModel`类。该类的源代码在此处可用：[https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter05/DigitalTicket.Shared/ViewModels/OwnedTicketsViewModel.cs](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter05/DigitalTicket.Shared/ViewModels/OwnedTicketsViewModel.cs)。
- en: 'Now, update `OwnedTicketsPage.xaml` and `OwnedTicketsPage.xaml.cs`. You can
    find the source code for those two files on GitHub: [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter05/DigitalTicket.Shared/Views](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter05/DigitalTicket.Shared/Views).'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新`OwnedTicketsPage.xaml`和`OwnedTicketsPage.xaml.cs`。您可以在GitHub上找到这两个文件的源代码：[https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter05/DigitalTicket.Shared/Views](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter05/DigitalTicket.Shared/Views)。
- en: 'Now, if you start the app and navigate to the owned tickets page, you should
    see an empty page. If you have already booked a ticket, you should see something
    like on the left side of *Figure 5.3*. If you click on the small, wide, gray box
    below the ticket, you should see something like on the right side of *Figure 5.3*:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果启动应用程序并导航到拥有的票页面，您应该会看到一个空页面。如果您已经预订了一张票，您应该会看到*图5.3*左侧的内容。如果您点击票下方的小、宽、灰色框，您应该会看到*图5.3*右侧的内容：
- en: '![Figure 5.3 – Left: List of owned tickets with a single ticket; Right: Owned
    ticket and the QR code of the booked ticket'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 - 左：拥有单张票的票务列表；右：拥有的票和已预订票的QR码'
- en: '](img/Figure_5.03_B17132.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.03_B17132.jpg)'
- en: 'Figure 5.3 – Left: List of owned tickets with a single ticket; Right: Owned
    ticket and the QR code of the booked ticket'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 - 左：拥有单张票的票务列表；右：拥有的票和已预订票的QR码
- en: Of course, this is not the final UI yet; users should see text indicating that
    they haven't booked a ticket yet instead of a blank screen. Right now, though,
    it is expected that the text is missing and buttons don't have labels either since
    they are using `x:Uid` instead of having the `Text` or `Content` property set.
    In the next section, we will look at what `x:Uid` is and update our app so that
    all the labels are being displayed correctly.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这还不是最终的UI；用户应该看到指示他们尚未预订票的文本，而不是空白屏幕。不过，目前预计文本缺失，按钮也没有标签，因为它们使用的是`x:Uid`，而不是设置了`Text`或`Content`属性。在下一节中，我们将看看`x:Uid`是什么，并更新我们的应用程序，以便所有标签都能正确显示。
- en: Making your app ready for customers
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使您的应用程序准备好迎接客户
- en: In this section, we will update our app to be ready for our customers, including
    localization support to make the app easier to use for our customers. After adding
    localization support, we will update the icon and splash screen of our app so
    it is more easily recognizable for our users.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更新我们的应用程序，以便为我们的客户做好准备，包括本地化支持，使应用程序更易于客户使用。添加本地化支持后，我们将更新应用程序的图标和启动画面，以便用户更容易识别。
- en: Localizing your app
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地化您的应用程序
- en: If you are developing an app targeting customers, being able to provide translations
    for customers in their native tongue is very important, especially for apps that
    are targeted toward customers from different countries. In the previous section,
    we already added the `x:Uid` property and added entries to the `Strings.resw`
    file; however, there are also other ways to localize resources, which we will
    cover later. We will start localizing text with `x:Uid`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在开发一个面向客户的应用程序，能够以客户的母语提供翻译非常重要，特别是针对来自不同国家的客户的应用程序。在上一节中，我们已经添加了`x:Uid`属性并向`Strings.resw`文件添加了条目；但是，还有其他本地化资源的方法，我们将在后面介绍。我们将从`x:Uid`开始本地化文本。
- en: Using x:Uid to localize your UI
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用x:Uid本地化您的UI
- en: Using `x:Uid` and resource files (`.resw` files) is the easiest way to localize
    your app, especially since adding new translations, for example, for a new language,
    is very easy. But how do you localize your app using `x:Uid` and `.resw` files?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`x:Uid`和资源文件（.resw文件）是本地化应用程序的最简单方法，特别是因为添加新的翻译（例如，为新语言）非常容易。但是如何使用`x:Uid`和.resw文件本地化您的应用程序呢？
- en: 'The `x:Uid` property can be added to any elements of your XAML code. In addition
    to setting the `x:Uid` property on controls you would like to provide translations
    for, you also need to add those translations. This is where the `.resw` files
    come in. In a nutshell, `resw` files are XML documents that contain the necessary
    entries. The easiest way of thinking about them, though, is as a list of entries
    with three properties that is often represented as a table. Those properties (or
    columns) are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`x:Uid`属性可以添加到你的XAML代码的任何元素上。除了在你想要提供翻译的控件上设置`x:Uid`属性之外，你还需要添加这些翻译。这就是`.resw`文件发挥作用的地方。简而言之，`resw`文件是包含必要条目的XML文档。然而，最容易想到的方法是将它们视为一张包含三个属性的条目列表，通常表示为表格。这些属性（或列）如下：'
- en: '**Name**: The name you can use to find the resource. This path will also be
    used to determine which property on which control to set.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Name**：你可以用来查找资源的名称。这个路径也将用于确定要设置哪个控件上的哪个属性。'
- en: '**Value**: The text being set or the text being returned when looking up this
    resource.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Value**：设置的文本或查找此资源时返回的文本。'
- en: '**Comment**: You can use this column to provide comments explaining the row.
    This is especially useful when translating the app into a new language since you
    can use the comment to find out what the best translation would be. See the **Comment**
    column in *Figure 5.4* for how they might be used.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Comment**：你可以使用这一列提供解释该行的注释。当将应用程序翻译成新语言时，这是特别有用的，因为你可以使用注释找出最佳翻译是什么。查看*图5.4*中的**Comment**列，了解它们可能如何使用。'
- en: 'When opening a `.resw` file in Visual Studio, the representation will look
    as in *Figure 5.4*:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开`.resw`文件时，显示将如*图5.4*所示：
- en: '![Figure 5.4 – View of the .resw file in Visual Studio'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.4 - 在Visual Studio中查看.resw文件'
- en: '](img/Figure_5.04_B17132.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.04_B17132.jpg)'
- en: Figure 5.4 – View of the .resw file in Visual Studio
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 - 在Visual Studio中查看.resw文件
- en: When using the `x:Uid` property in combination with `.resw` files, you need
    to watch how you write the name entries for the resources. The name entry needs
    to start with the `x:Uid` value of the control followed by a dot (`.`) and the
    name of the property that should be set. So, in the preceding example, if we wanted
    to localize the text of the `TextBlock` element, we would add an entry with the
    name value being `ButtonTextBlock.Text` since we want to set the `Text` property
    of the `TextBlock` element.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当在XAML代码中使用`x:Uid`属性与`.resw`文件结合使用时，你需要注意如何编写资源的名称条目。名称条目需要以控件的`x:Uid`值开头，后跟一个点（`.`）和应该设置的属性的名称。因此，在前面的示例中，如果我们想要本地化`TextBlock`元素的文本，我们将添加一个名称值为`ButtonTextBlock.Text`的条目，因为我们想设置`TextBlock`元素的`Text`属性。
- en: '"But how does localization work with this?" you might ask. After all, we have
    only added a single entry; how would it know which language to pick? This is why
    the folder in which you place your `.resw` files is important. Inside your project,
    you need to have a `Strings` folder. In that folder, for every language you want
    to localize your app to, you need to have a folder with the `en-GB` while for
    *German (Germany)*, you would create a folder called `de-DE`. Inside the folders
    that you create for every language you want to support, you need to place your
    `.resw` files for the localization to work properly. Note that if a certain language
    is not available, the resource lookup will try to find the next best match. You
    can learn more about this procedure here since your Uno Platform app will behave
    the same on every platform: [https://docs.microsoft.com/windows/uwp/app-resources/how-rms-matches-lang-tags](https://docs.microsoft.com/windows/uwp/app-resources/how-rms-matches-lang-tags).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: “但是本地化是如何运作的呢？”你可能会问。毕竟，我们只添加了一个条目；它怎么知道选择哪种语言呢？这就是为什么你放置`.resw`文件的文件夹很重要。在你的项目中，你需要有一个`Strings`文件夹。在该文件夹中，对于你想要将应用本地化的每种语言，你需要创建一个文件夹，比如`en-GB`，而对于*德语（德国）*，你需要创建一个名为`de-DE`的文件夹。在你为每种想要支持的语言创建的文件夹中，你需要放置`.resw`文件，以便本地化能够正常工作。请注意，如果某种语言不可用，资源查找将尝试找到下一个最佳匹配。你可以在这里了解更多关于这个过程的信息，因为你的Uno平台应用在每个平台上的行为都是相同的：[https://docs.microsoft.com/windows/uwp/app-resources/how-rms-matches-lang-tags](https://docs.microsoft.com/windows/uwp/app-resources/how-rms-matches-lang-tags)。
- en: Important note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Be careful how you name those folders. The resource lookup will be done based
    on the folder's name. If the folder's name has a typo or does not adhere to the
    IETF BCP 47 standard, the resource lookup might fail and your users will be greeted
    with missing labels and texts or a mix of languages as resource lookup will fall
    back to languages where the texts have been translated.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要小心命名这些文件夹。资源查找将根据文件夹的名称进行。如果文件夹的名称有拼写错误或不符合IETF BCP 47标准，资源查找可能会失败，你的用户将看到缺少标签和文本，或者资源查找将退回到已翻译文本的语言混合。
- en: 'We already have a folder for the English text resources; however, we also want
    to support German translations. To do this, create a new folder inside the `Strings`
    folder named `de-DE`. Now, add a new `.resw` file with the name `Resources.resw`
    and add the following entries:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个用于英文文本资源的文件夹；然而，我们也想支持德语翻译。为此，在`Strings`文件夹内创建一个名为`de-DE`的新文件夹。现在，添加一个名为`Resources.resw`的新`.resw`文件，并添加以下条目：
- en: '![Table 5.2](img/Table_02.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![表5.2](img/Table_02.jpg)'
- en: If you start the app now and switch to German as the app's language, you will
    see that the journey booking page is now localized. If your device's language
    was already set to German, instead of showing the page in English, it should now
    be displayed in German, even if you don't switch to the German option now.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在启动应用并将应用的语言切换为德语，你会看到预订页面现在已本地化。如果你的设备语言已设置为德语，而不是以英语显示页面，现在应该显示为德语，即使你现在不切换到德语选项。
- en: Accessing resources from code-behind
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从代码后台访问资源
- en: 'Using `x:Uid` is not the only way to localize your app, though; we will now
    see how you can access a resource from code-behind. This is useful, for example,
    when you want to localize the items in a collection, for example, the list of
    owned tickets in our app. To access string resources, you can use the `ResourceLoader`
    class. We added the `LocalizedResources` class at the start of the chapter; however,
    until now, it hasn''t accessed any resources. Update `LocalizedResources` now
    by adding the following import and replacing the `GetString` function with the
    following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`x:Uid`并不是本地化应用程序的唯一方法；我们现在将看到如何可以从代码后台访问资源。例如，当您想要本地化集合中的项目时，例如我们应用程序中拥有的票证列表。要访问字符串资源，您可以使用`ResourceLoader`类。我们在本章开头添加了`LocalizedResources`类；然而，直到现在，它还没有访问任何资源。现在通过添加以下导入并替换`GetString`函数来更新`LocalizedResources`：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since we will be using the loaded resource often, we are caching the value to
    avoid having to call `GetForViewIndependentUse` as it is expensive.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将经常使用加载的资源，我们正在缓存该值，以避免调用`GetForViewIndependentUse`，因为这是昂贵的。
- en: 'Now that we have covered how `x:Uid` works and how you can access localized
    resources from code-behind, let''s update the rest of our app to be localized.
    Start by adding the necessary entries to our `.resw` files. The following is the
    table of entries you need for the `MainPage.xaml` file and their English and German
    entries:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了`x:Uid`的工作原理以及如何从代码后台访问本地化资源，让我们更新应用程序的其余部分以进行本地化。首先，通过向我们的`.resw`文件添加必要的条目来开始。以下是您需要为`MainPage.xaml`文件及其英语和德语条目的条目表：
- en: '![Table 5.3](img/Table_03.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![Table 5.3](img/Table_03.jpg)'
- en: 'Now, replace the `NavigationViewItems` property inside the `MainPage.xaml`
    file with the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请将`MainPage.xaml`文件中的`NavigationViewItems`属性替换为以下内容：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To update the rest of the app to be localized, please view the source code on
    GitHub. You can also find the updated `Resources.resw` files for English and German
    there. Note that we chose to not localize the station names as localizing street
    and place names might lead to confusion for customers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要将应用程序的其余部分本地化，请查看GitHub上的源代码。您还可以在那里找到英语和德语的更新的`Resources.resw`文件。请注意，我们选择不本地化车站名称，因为本地化街道和地名可能会让客户感到困惑。
- en: Important note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'You can also localize other resources such as images or audio files. To do
    that, you need to put them inside correctly named folders. For example, if you
    want to localize an image called `Recipe.png`, you need to put the localized version
    of the image for a language inside the `Assets/[language identifier]` folder,
    where `language identifier` is the IETF BCP 47 identifier of the language the
    image is for. You can learn more about customizing and localizing resources here:
    [https://docs.microsoft.com/windows/uwp/app-resources/images-tailored-for-scale-theme-contrast](https://docs.microsoft.com/windows/uwp/app-resources/images-tailored-for-scale-theme-contrast).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以本地化其他资源，如图像或音频文件。为此，您需要将它们放在正确命名的文件夹中。例如，如果您想本地化名为`Recipe.png`的图像，您需要将该图像的本地化版本放在`Assets/[语言标识符]`文件夹中，其中`语言标识符`是图像所属语言的IETF
    BCP 47标识符。您可以在这里了解有关自定义和本地化资源的更多信息：[https://docs.microsoft.com/windows/uwp/app-resources/images-tailored-for-scale-theme-contrast](https://docs.microsoft.com/windows/uwp/app-resources/images-tailored-for-scale-theme-contrast)。
- en: 'In this section, we covered how to localize your app using `x:Uid` and resources
    file. As your app becomes larger and more languages are provided, using the multilingual
    app toolkit might be helpful. It allows you to check more easily which language
    keys are not translated and integrates into Visual Studio. You can learn more
    about this here: [https://developer.microsoft.com/en-us/windows/downloads/multilingual-app-toolkit/](https://developer.microsoft.com/en-us/windows/downloads/multilingual-app-toolkit/).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了如何使用`x:Uid`和资源文件本地化您的应用程序。随着您的应用程序变得更大并提供更多语言，使用多语言应用程序工具包可能会有所帮助。它使您更容易地检查哪些语言键未被翻译，并集成到Visual
    Studio中。您可以在这里了解更多信息：[https://developer.microsoft.com/en-us/windows/downloads/multilingual-app-toolkit/](https://developer.microsoft.com/en-us/windows/downloads/multilingual-app-toolkit/)。
- en: Customizing your app's appearance
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义应用程序的外观
- en: When publishing an app to the store, you want your app to be recognizable to
    users and convey your brand. However, so far, all the apps we developed have used
    the standard Uno Platform app icon. Luckily, Uno Platform allows us to change
    our app's icon and lets us set the splash image for our app.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在将应用程序发布到商店时，您希望您的应用程序能够被用户识别并传达您的品牌。然而，到目前为止，我们开发的所有应用程序都使用了标准的Uno平台应用程序图标。幸运的是，Uno平台允许我们更改应用程序的图标，并允许我们为应用程序设置启动图像。
- en: Updating your app's icon
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新应用程序的图标
- en: 'One of the most important things to make your app recognizable by users is
    having an icon for your app. Updating the icon for your app is easy. You can find
    the image we will use here: [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter05/DigitalTicket.Shared/Assets/AppIcon.png](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter05/DigitalTicket.Shared/Assets/AppIcon.png).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让您的应用程序被用户识别的最重要的事情之一就是为您的应用程序添加图标。更新应用程序的图标很容易。您可以在这里找到我们将使用的图像：[https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter05/DigitalTicket.Shared/Assets/AppIcon.png](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/blob/main/Chapter05/DigitalTicket.Shared/Assets/AppIcon.png)。
- en: Updating the Android app's icon
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新Android应用程序的图标
- en: To update the app icon for the Android app, you just need to replace the `Icon.png`
    file inside the drawable folder of the Android project with your desired app logo.
    Note that you also need to select the correct image in the project properties.
    For this, double-click the `Appicon`, you would select the `android:icon` entry
    in the `AndroidManifest.xml` file inside the **Properties** node.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新Android应用程序的应用程序图标，您只需将Android项目的drawable文件夹中的`Icon.png`文件替换为所需的应用程序徽标。请注意，您还需要在项目属性中选择正确的图像。为此，请双击`Appicon`，您将在**Properties**节点内的`AndroidManifest.xml`文件中选择`android:icon`条目。
- en: Updating the iOS app's icon
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新iOS应用程序的图标
- en: Updating the icon of our iOS app requires a bit more work. For the iOS app,
    you will need your app's icon in different sizes depending on the device the app
    is installed on. To see the list of dimensions and to update the app icon of the
    iOS app, simply expand the **Assets Catalog** node of the iOS project and double-click
    on the **Media** entry inside there. Inside the **AppIcons** tab, you select the
    images for the different devices and categories, and dimensions. It is not required
    to provide an image for every single dimension; however, you should provide at
    least one icon for every category.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 更新我们的iOS应用程序图标需要更多的工作。对于iOS应用程序，您需要根据应用程序安装的设备不同的尺寸来设置应用程序图标。要查看尺寸列表并更新iOS应用程序的应用图标，只需展开iOS项目的**Assets
    Catalog**节点，然后双击其中的**Media**条目。在**AppIcons**选项卡中，您可以选择不同设备和类别的图像和尺寸。并不需要为每个尺寸提供图像；但是，您至少应该为每个类别提供一个图标。
- en: Updating the icon of the UWP app
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新UWP应用程序的图标
- en: The easiest way to update the app icon of the UWP head is using the `Package.appxmanifest`
    file. For this, double-click `Package.appxmanifest` and select the **App icon**
    option inside the **Visual Assets** tab. To update the app's icon, choose the
    source image, select the destination folder, and click **Generate**. This will
    generate the app's icon in different sizes and as such, update your app's icon
    to the image specified.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 更新UWP头部的应用程序图标的最简单方法是使用`Package.appxmanifest`文件。为此，请双击`Package.appxmanifest`，然后在**Visual
    Assets**选项卡中选择**App icon**选项。要更新应用程序的图标，请选择源图像，选择目标文件夹，然后单击**Generate**。这将生成不同尺寸的应用程序图标，并因此将您的应用程序图标更新为指定的图像。
- en: Updating the icon of the other projects
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新其他项目的图标
- en: 'While our app won''t be available on other platforms and we removed the heads
    for the respective platforms, you might want to update the icon for the other
    platforms in other projects:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的应用程序将不会在其他平台上可用，并且我们已经删除了相应平台的头部，但您可能希望在其他项目中更新其他平台的图标：
- en: '`Assets/xcassets/AppIcon.appiconset` folder. If you rename the images, be sure
    to also update the `Contents.json` file.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assets/xcassets/AppIcon.appiconset`文件夹。如果重命名图像，请确保还更新`Contents.json`文件。'
- en: '**Skia-based projects**: Right-click the project in Visual Studio and select
    **Properties**. Inside the **Application** tab, you can select a new icon using
    the **Browse** button in the **Resources** section.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于Skia的项目**：在Visual Studio中右键单击项目并选择**属性**。在**应用程序**选项卡中，您可以使用**资源**部分中的**浏览**按钮选择一个新图标。'
- en: '`favicon.ico` inside the project''s **Assets** folder.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`favicon.ico`在项目的**Assets**文件夹中。'
- en: Customizing your app's splash screen
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义您的应用程序启动画面
- en: Updating your app's icon is not the only way to make your app more recognizable.
    In addition to the app's icon, you can also customize the splash screen of your
    app. Note that at the time of writing this, only Android, iOS, UWP, and WASM apps
    support setting a splash screen. As with the icon, you can find the image resources
    for this on GitHub.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 更新您的应用程序图标并不是使您的应用程序更具识别性的唯一方法。除了应用程序图标之外，您还可以自定义应用程序的启动画面。请注意，目前只有Android、iOS、UWP和WASM应用程序支持设置启动画面。与图标一样，您可以在GitHub上找到此类图像资源。
- en: Updating the Android splash screen
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新Android启动画面
- en: 'To add a splash screen to the Android app, you will first need to add your
    splash screen image. In our case, we will name it `SplashScreen.png`. After this,
    add the following entry to the `Resource/values/Styles.xml` file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要向Android应用程序添加启动画面，您首先需要添加您的启动画面图像。在我们的情况下，我们将其命名为`SplashScreen.png`。之后，将以下条目添加到`Resource/values/Styles.xml`文件中：
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, you need to add the `splash.xml` file inside `Resources/drawable` and
    add the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要在`Resources/drawable`文件夹中添加`splash.xml`文件，并添加以下代码：
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Updating the iOS app's splash screen
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新iOS应用程序的启动画面
- en: 'As with any iOS app, the launch screen needs to be a storyboard. Uno Platform
    makes it easy to have a single image displayed as a launch screen. All it takes
    are these simple steps:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何iOS应用程序一样，启动画面需要是一个故事板。Uno Platform使得很容易显示一个单一图像作为启动画面。只需这些简单的步骤：
- en: In Solution Explorer, select the iOS project and press the **Show All Files**
    button.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中，选择iOS项目并按下**显示所有文件**按钮。
- en: You'll now be able to see a file called **LaunchScreeen.storyboard**. Right-click
    on this and select **Include In Project**. This will now automatically be used
    when you launch the app.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您将能够看到一个名为**LaunchScreeen.storyboard**的文件。右键单击此文件并选择**包含在项目中**。这将在启动应用程序时自动使用。
- en: If you run the app, you'll see the Uno Platform logo displayed when you launch
    the app. You can easily change this by replacing the images.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行应用程序，您将看到Uno Platform标志在启动应用程序时显示。您可以通过替换图像来轻松更改此内容。
- en: In the `SplashScreen@2x.png` and `SplashScreen@3x.png`. These are the files
    used by the storyboard. Replace their contents with the images you want.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SplashScreen@2x.png`和`SplashScreen@3x.png`中。这些是故事板使用的文件。用您想要的图像替换它们。
- en: To change the color used for the background, you can open the storyboard in
    the Xcode Interface Builder and change the color. Alternatively, you can open
    the storyboard file in an XML editor and change the `red`, `green`, and `blue`
    properties of the color with the `backgroundColor` key.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更改用于背景的颜色，您可以在Xcode Interface Builder中打开故事板并更改颜色。或者，您可以在XML编辑器中打开故事板文件，并更改颜色的`red`、`green`和`blue`属性，使用`backgroundColor`键。
- en: It's possible to use a storyboard file with any content you wish as your launch
    screen. To do this, you will need to use the Xcode Interface Builder. Prior to
    version **16.9**, Visual Studio included an iOS storyboard editor but this is
    no longer available. To edit a storyboard now, you need to open the project in
    Visual Studio for Mac, right-click on the file, and select **Open With** | **Xcode
    interface Builder**.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用任何您希望的内容作为启动屏幕的故事板文件。要做到这一点，您需要使用Xcode Interface Builder。在版本**16.9**之前，Visual
    Studio包括一个iOS故事板编辑器，但现在不再可用。要现在编辑故事板，您需要在Visual Studio for Mac中打开项目，右键单击文件，然后选择**打开方式**
    | **Xcode Interface Builder**。
- en: Updating the UWP app's splash screen
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新UWP应用程序的启动画面
- en: Similar to updating the app icon of your UWP app, use the `Package.appxmanifest`
    file and the `#008CFF`. Now, click **Generate** to generate the splash screen
    images for the UWP app.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与更新UWP应用程序的应用程序图标类似，使用`Package.appxmanifest`文件和`#008CFF`。现在，单击**生成**以生成UWP应用程序的启动画面图像。
- en: Updating the splash screen of the WASM app
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新WASM应用程序的启动画面
- en: To update the splash screen of your WASM head, add your new splash screen image
    inside the WASM project's `AppManifest.js` file inside the `WasmScripts` folder
    to reference that image and update the splash screen color if necessary.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新WASM头的启动画面，请将新的启动画面图像添加到WASM项目的`AppManifest.js`文件中的`WasmScripts`文件夹中，以引用该图像，并在必要时更新启动画面颜色。
- en: 'If you have followed the steps for our app successfully, you should be able
    to see the app in the app list on Android as seen on the left side of *Figure
    5.5*. Once you start the app, your app should look as on the right side of *Figure
    5.5* before showing the journey booking page. Note that the icon and splash screen
    provided are just examples here. In a real app, you would ensure that your app''s
    icon looks good even this small:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已成功按照我们的应用程序步骤进行操作，您应该能够在Android应用程序列表中看到应用程序，就像*图5.5*左侧所示。一旦启动应用程序，您的应用程序在显示旅程预订页面之前应该看起来像*图5.5*右侧所示。请注意，此处提供的图标和启动画面仅为示例。在真实的应用程序中，您应该确保您的应用程序图标即使很小也看起来不错：
- en: '![Figure 5.5 – Left: DigitalTicket in the list of apps; Right: Splash screen
    of DigitalTicket'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.5 – 左：应用程序列表中的DigitalTicket；右：DigitalTicket的启动画面'
- en: '](img/Author_Figure_5.05_B17132.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Author_Figure_5.05_B17132.jpg)'
- en: 'Figure 5.5 – Left: DigitalTicket in the list of apps; Right: Splash screen
    of DigitalTicket'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 左：应用程序列表中的DigitalTicket；右：DigitalTicket的启动画面
- en: Ensuring everyone can use your app
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保每个人都能使用您的应用程序
- en: To make sure everyone can use your app, you need to make it accessible. Accessibility
    is key when developing apps. People with all levels of ability will use your app;
    your app not being accessible will make the life of your customers harder or might
    even make it impossible for them to use your app.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保每个人都能使用您的应用程序，您需要使其具有无障碍性。在开发应用程序时，无障碍性至关重要。所有能力水平的人都会使用您的应用程序；如果您的应用程序不具有无障碍性，将使您的客户生活更加困难，甚至可能使他们无法使用您的应用程序。
- en: When thinking about accessibility, what comes to mind to most people is making
    your app accessible for blind people by adding labels and alt text for screen
    readers. However, accessibility is about so much more. For example, someone who
    has low vision but is not blind might not use a screen reader but instead might
    choose to use the high-contrast theme to make apps easier to use or might choose
    to increase the font size to make the text easier to read. Providing a dark theme
    is often seen as a purely aesthetic aspect; however, it is also important with
    regard to accessibility. Some people might be able to read text better while people
    with certain disabilities will have a harder time using your app.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑无障碍性时，大多数人首先想到的是通过为屏幕阅读器添加标签和替代文本来使应用程序对盲人无障碍。然而，无障碍性涉及的远不止这些。例如，视力较低但不是盲人的人可能不使用屏幕阅读器，而是选择使用高对比度主题使应用程序更易于使用，或者选择增大字体大小以便更容易阅读文本。提供暗色主题通常被视为纯粹的美学方面；然而，它在无障碍性方面也很重要。一些人可能能够更好地阅读文本，而某些残障人士可能会更难使用您的应用程序。
- en: 'If you are already familiar with the APIs available in UWP to make your app,
    there are a few things that are different when making your Uno Platform accessible.
    Since your app will run on different platforms and those platforms all have different
    APIs to provide accessible apps, Uno Platform only has a subset of properties
    available with regard to accessibility. At the time of writing, only the following
    properties are supported and work on every platform:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经熟悉UWP中可用的API来制作应用程序，那么在使您的Uno平台应用程序具有无障碍性时会有一些不同之处。由于您的应用程序将在不同的平台上运行，而这些平台都有不同的API来提供无障碍应用程序，Uno平台在无障碍性方面只提供了一部分可用属性。在撰写本文时，只支持以下属性，并且在每个平台上都可以使用：
- en: '`AutomationProperties.AutomationId`: You can set this property to allow easier
    navigation to controls with assistive technology.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AutomationProperties.AutomationId`: 您可以设置此属性以便使用辅助技术更轻松地导航到控件。'
- en: '`AutomationProperties.Name`: Assistive technology will use this property to
    announce controls to users.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AutomationProperties.Name`: 辅助技术将使用此属性向用户宣布控件。'
- en: '`AutomationProperties.LabeledBy`: When setting this property, the control you
    are setting this on will be announced using the control specified by this property.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AutomationProperties.LabeledBy`: 设置此属性时，将使用此属性指定的控件来宣布设置了此属性的控件。'
- en: '`AutomationProperties.AccessibilityView`: Using this property, you can indicate
    that a control should not be read out to users by assistive technology or that
    you want to include controls that would commonly not be announced.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AutomationProperties.AccessibilityView`: 使用此属性，您可以指示控件不应该被辅助技术向用户宣布，或者您想要包括通常不会被宣布的控件。'
- en: In addition to the properties listed previously, Uno Platform also supports
    the high-contrast theme on every platform. Since we are using the standard controls
    provided by Uno Platform, we won't need to watch out for this as Uno Platform
    already provides the right high-contrast look for our app. However, if you write
    your own controls, you should also check the high-contrast version of your app
    to ensure it is acceptable.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前列出的属性外，Uno平台还在每个平台上支持高对比度主题。由于我们使用Uno平台提供的标准控件，我们不需要特别关注这一点，因为Uno平台已经为我们的应用程序提供了正确的高对比度外观。但是，如果您编写自己的控件，您还应该检查您的应用程序的高对比度版本，以确保其可接受。
- en: Important note
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should always localize the resources that will be used by assistive technology.
    Not doing this will potentially make your app inaccessible since users might encounter
    a language barrier, especially if assistive technology expects to read out words
    from a language and finds words from a different one.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终本地化辅助技术将使用的资源。不这样做可能会使您的应用程序无法访问，因为用户可能会遇到语言障碍，特别是如果辅助技术期望从一种语言中读出单词，而实际上却是另一种语言的单词。
- en: To be able to ensure your app is accessible to people using assistive technology,
    you need to test your app using assistive technology. In the following section,
    you can find instructions to start a platform's default screen reader.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Starting the screen reader on different platforms
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the steps to activate a system's assistive technology vary depending on
    the platform, we will go through them one by one, starting with Android.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: TalkBack on Android
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Launch the **Settings** app and open the **Accessibility** page. Press **TalkBack**
    and tap on the switch to enable TalkBack. Finally, press **OK** to close the dialog.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: VoiceOver on iOS
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Open the **Settings** app and open the **Accessibility** options under **General**.
    Then, tap on **VoiceOver** in the **Vision** category and tap on the switch to
    enable it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: VoiceOver on macOS
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Launch **System Preferences** and click on **Accessibility**. Then, click on
    **VoiceOver** in the **Vision** category. Check **Enable VoiceOver** to use **VoiceOver**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Narrator on Windows (for UWP and WASM)
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To start the **Narrator** screen reader on Windows, you just need to press the
    Windows logo key, *Ctrl*, and *Enter* at the same time.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Updating our app to be accessible
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we haven't ensured that our app is accessible. While a lot
    of controls are already accessible on their own, for example, the button control
    that will announce its content, there are still controls that we need to improve
    accessibility-wise. If a user were to use the app with assistive technology, not
    everything will be announced in a meaningful manner. Let's change this now by
    updating our app's UI to have all the necessary properties set. To do this, we
    will first update our journey booking page.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `ComboBox` control on our journey booking page currently will just be
    announced as `ComboBox` control, and as such, users with assistive technology
    have no idea what the `ComboBox` control is actually for. Since we have already
    added `TextBlock` element that describes their purpose, we will update them to
    use the `AutomationProperties.LabeledBy` property:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, when a user navigates to the `ComboBox` control using assistive technology,
    the `ComboBox` control will be announced using the text of the `TextBlock` element
    referenced by `AutomationProperties.LabeledBy`. Since the rest of the controls
    on that page are already taking care of accessibility for us, let's move on to
    the owned tickets page.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'On the owned tickets page, there are two potential problems:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The icons beside the station names will be announced as a blank icon.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The QR code will only be announced as an image.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the icons are only for visual representation, we indicated to assistive
    technologies that the icons should not be announced using the `AutomationProperties.AccessibilityView`
    property and setting it to `Raw`. If you want to include a control for assistive
    technologies, you can set that property to `Content`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that the QR code image will be announced in a meaningful way, we
    will add a descriptive name to it. For simplicity, we will just announce that
    it is the QR for the currently selected ticket. First, you need to update the
    image element as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After this, add the following entries to the `Resources.resw` files:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '**English**:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.4](img/Table_04.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: '**German**:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.5](img/Table_05.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: By adding these entries, we have now provided a descriptive name for the QR
    code being displayed while also ensuring that this text will be localized.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we also need to update the settings page. Since it only contains a
    single `ComboBox` control, which is missing a name, add the following entries
    to the `Resources.resw` files:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '**English**:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.6](img/Table_06.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: '**German**:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.7](img/Table_07.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: 'In this section, we briefly covered accessibility in Uno Platform; however,
    there are also certain limitations and things to watch out for that we did not
    mention. You can read more about these limitations in the official documentation:
    [https://platform.uno/docs/articles/features/working-with-accessibility.html](https://platform.uno/docs/articles/features/working-with-accessibility.html).
    If you wish to learn more about accessibility in general, you can take a look
    at the following resources:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要介绍了Uno平台中的可访问性；但是，我们没有提到还有一些限制和需要注意的事项。您可以在官方文档中阅读更多关于这些限制的信息：[https://platform.uno/docs/articles/features/working-with-accessibility.html](https://platform.uno/docs/articles/features/working-with-accessibility.html)。如果您希望了解更多关于一般可访问性的信息，您可以查看以下资源：
- en: '[https://docs.microsoft.com/en-us/learn/paths/accessibility-fundamentals/](https://docs.microsoft.com/en-us/learn/paths/accessibility-fundamentals/)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: https://docs.microsoft.com/en-us/learn/paths/accessibility-fundamentals/
- en: '[https://developer.mozilla.org/en-US/docs/Learn/Accessibility/What_is_accessibility](https://developer.mozilla.org/en-US/docs/Learn/Accessibility/What_is_accessibility)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Learn/Accessibility/What_is_accessibility](https://developer.mozilla.org/en-US/docs/Learn/Accessibility/What_is_accessibility)'
- en: '[https://developers.google.com/web/fundamentals/accessibility](https://developers.google.com/web/fundamentals/accessibility)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/web/fundamentals/accessibility](https://developers.google.com/web/fundamentals/accessibility)'
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built a customer-facing app that runs on iOS and Android.
    We covered how to store data using SQLite, how to make your app accessible, and
    making it ready for customers. As part of this, we covered how to localize your
    app, letting users choose the language of the app, and providing a custom splash
    screen for your app.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个在iOS和Android上运行的面向客户的应用程序。我们介绍了如何使用SQLite存储数据，如何使您的应用程序具有可访问性，并使其为客户准备好。作为其中的一部分，我们介绍了如何本地化您的应用程序，让用户选择应用程序的语言，并为您的应用程序提供自定义启动画面。
- en: In the next chapter, we will write an information dashboard for UnoBookRail.
    The app will be targeted at employees of UnoBookRail and run on desktop and the
    web.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为UnoBookRail编写一个信息仪表板。该应用程序将面向UnoBookRail的员工，并在桌面和Web上运行。

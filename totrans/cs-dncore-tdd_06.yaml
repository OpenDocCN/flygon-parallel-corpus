- en: Mocking Dependencies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟依赖
- en: In [Chapter 5](ef706a31-a272-418d-9706-ed84089d89a4.xhtml), *Data-Driven Unit
    Tests*, we discussed data-driven unit testing using the xUnit framework, which
    allows us to create tests that run on data from different sources, such as flat
    files, databases, or inline data. Now, we will explain the concepts of mocking
    dependencies and explore how to use the Moq framework to isolate your class that
    is being tested from its dependencies, using mock objects created with Moq.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ef706a31-a272-418d-9706-ed84089d89a4.xhtml)中，我们讨论了使用xUnit框架进行数据驱动的单元测试，这使我们能够创建从不同来源（如平面文件、数据库或内联数据）获取数据的测试。现在，我们将解释模拟依赖的概念，并探讨如何使用Moq框架来隔离正在测试的类与其依赖关系，使用Moq创建的模拟对象。
- en: There are usually objects dependencies in the code base of software projects,
    whether for a simple or a complex project. This is because the various objects
    need to interact and share information across boundaries. However, to effectively
    unit test the objects and isolate their behaviors, each object must be tested
    in isolation, irrespective of the dependencies it has on other objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件项目的代码库中通常存在对象依赖，无论是简单项目还是复杂项目。这是因为各种对象需要相互交互并在边界之间共享信息。然而，为了有效地对对象进行单元测试并隔离它们的行为，每个对象必须在隔离的环境中进行测试，而不考虑它们对其他对象的依赖。
- en: In order to achieve this, the dependent objects in a class are replaced with
    mocks to allow the object being tested to be effective when tested in isolation,
    without having to go through the pain of constructing the dependent objects, which
    sometimes might not be fully implemented or may be impractical to construct at
    the time the object being tested is written.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，类中的依赖对象被替换为模拟对象，以便在测试时能够有效地进行隔离测试，而无需经历构造依赖对象的痛苦，有时这些依赖对象可能并未完全实现，或者在编写被测试对象时构造它们可能是不切实际的。
- en: '**Mock objects** are used to simulate or mimic real objects for the purpose
    of code testing. Mock objects are used to replace real objects; they are created
    from real interfaces or classes and used to verify interactions. Mock objects
    are essential instances of classes referenced in another class to be tested and
    are used to simulate the behavior of these classes. Since the components of a
    software system need to interact and collaborate, mock objects are used to replace
    the collaborators. A mock object, when used, verifies that the usage is correct
    and is as expected. Mocks can be created using a mocking framework or library
    or, alternatively, by generating code for them through handwritten mock objects.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟对象**用于模拟真实对象以进行代码测试。模拟对象用于替换真实对象；它们是从真实接口或类创建的，并用于验证交互。模拟对象是另一个类中引用的必要实例，用于模拟这些类的行为。由于软件系统的组件需要相互交互和协作，模拟对象用于替换协作者。使用模拟对象时，可以验证使用是否正确且符合预期。模拟对象可以使用模拟框架或库创建，或者通过手工编写模拟对象的代码生成。'
- en: The Moq framework will be explored in detail in this chapter and will be used
    to create mock objects. Moq is a fully functional mocking framework that can be
    set up easily. It can be used to create mock objects for use in unit tests. Moq
    has several basic and advanced features expected of a mocking framework to create
    useful mocks and essentially write good unit tests.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细探讨Moq框架，并将用它来创建模拟对象。Moq是一个功能齐全的模拟框架，可以轻松设置。它可用于创建用于单元测试的模拟对象。Moq具有模拟框架应具备的几个基本和高级特性，以创建有用的模拟对象，并基本上编写良好的单元测试。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The benefits of mocking objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟对象的好处
- en: The shortcomings of mocking frameworks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟框架的缺点
- en: Hand-rolling mocks versus using the mocking framework
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动编写模拟对象与使用模拟框架
- en: Mocking objects using Moq framework
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Moq框架进行模拟对象
- en: The benefits of mocking objects
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟对象的好处
- en: In a well-architected software system, there are usually objects that interact
    and coordinate to accomplish set objectives based on the business or automation
    requirements. Quite often, these objects are complex and rely on other external
    components or systems, such as databases, SOAP, or REST services for data and
    internal state updates.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在良好架构的软件系统中，通常有相互交互和协调以实现基于业务或自动化需求的设定目标的对象。这些对象往往复杂，并依赖于其他外部组件或系统，如数据库、SOAP或REST服务，用于数据和内部状态更新。
- en: Most developers are beginning to adopt TDD because of the many benefits that
    practicing it can offer and due to the awareness that it is the responsibility
    of programmers to write quality code that is bug free and well tested. However,
    some developers object to mocking objects due to several assumptions. For example,
    adding mock objects to unit tests increases the total time required to write unit
    tests. This assumption is false because using mock objects offers several benefits,
    as explained in the following sections.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发人员开始采用TDD，因为它可以提供许多好处，并且意识到程序员有责任编写质量良好、无错误且经过充分测试的代码。然而，一些开发人员反对模拟对象，因为存在一些假设。例如，向单元测试中添加模拟对象会增加编写单元测试所需的总时间。这种假设是错误的，因为使用模拟对象提供了几个好处，如下节所述。
- en: Fast running tests
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速运行测试
- en: The main characteristics of a unit test are that it should run very quickly
    and should give consistent results even when executed multiple times with the
    same set of data. However, to effectively run a unit test and maintain this attribute
    of having unit tests that are efficients and run quickly, it is important to have
    mock objects set up where there are dependencies in the code being tested.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的主要特征是它应该运行非常快，并且即使使用相同的数据集多次执行，也应该给出一致的结果。然而，为了有效地运行单元测试并保持具有高效和快速运行的单元测试的属性，重要的是在被测试的代码中存在依赖关系时设置模拟对象。
- en: 'For example, in the following code snippet, the `LoanRepository` class has
    a dependency on Entity Framework''s `DbContext` class which creates a connection
    to a database server for database operations. To write a unit test for the `GetCarLoans`
    method in the `LoanRepository` class will necessitate that the `DbContext` object
    be constructed. The `DbContext` object can be mocked to avoid the expensive operation
    of opening and closing database connections each time a unit test is run for that
    class:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下代码片段中，`LoanRepository`类依赖于Entity Framework的`DbContext`类，后者创建与数据库服务器的连接以进行数据库操作。要为`LoanRepository`类中的`GetCarLoans`方法编写单元测试，将需要构造`DbContext`对象。可以对`DbContext`对象进行模拟，以避免每次对该类运行单元测试时打开和关闭数据库连接的昂贵操作：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In a software system, based on the requirements, there will be the need to access
    external systems, such as large files, databases, or web connections. Interacting
    directly with these external systems in a unit test increases the runtime of the
    test. Therefore, it is desirable to mock these external systems to allow the tests
    to run quickly. The benefits of unit testing can be lost when you have long running
    tests that apparently waste productive time. A developer in such a situation can
    stop running the tests or totally stop unit testing on the assertion that unit
    testing is time wasting.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件系统中，根据需求，将需要访问外部系统，如大型文件、数据库或Web连接。在单元测试中直接与这些外部系统交互会增加测试的运行时间。因此，最好对这些外部系统进行模拟，以便测试能够快速运行。当您有长时间运行的测试时，单元测试的好处可能会丧失，因为这显然会浪费生产时间。在这种情况下，开发人员可以停止运行测试，或者完全停止单元测试，并断言单元测试是浪费时间。
- en: Dependencies isolation
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项隔离
- en: Using dependencies mocking, you technically create alternatives to the dependencies
    in your code that you can experiment with. When you have a mock implementation
    of dependencies in place, you can make changes and test the effect of the changes
    in isolation since the tests will be running against mock objects and not the
    real objects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用依赖项模拟，您在代码中实际上创建了依赖项的替代方案，可以进行实验。当您在适当位置有依赖项的模拟实现时，您可以进行更改并测试更改的效果，因为测试将针对模拟对象而不是真实对象运行。
- en: When you have the dependencies isolated, you can focus on the test being run,
    thereby limiting the scope of your test to the code that really matters for the
    test. In essence, with the reduced scope, you can easily refactor the code being
    tested as well as the test itself, giving you a clear picture of areas where the
    code can be improved.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将依赖项隔离时，您可以专注于正在运行的测试，从而将测试的范围限制在对测试真正重要的代码上。实质上，通过减少范围，您可以轻松重构被测试的代码以及测试本身，从而清晰地了解代码可以改进的地方。
- en: 'In order to test the `LoanRepository` class in the following snippet in isolation,
    the `DbContext` object that the class depends on can be mocked out. This will
    limit the scope of the unit tests to only the `LoanRepository` class:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在以下代码片段中隔离地测试`LoanRepository`类，可以对该类依赖的`DbContext`对象进行模拟。这将限制单元测试的范围仅限于`LoanRepository`类：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Also, keeping the scope of the test small through isolation of dependencies
    makes the test easy to understand and facilitates easy maintenance. Increasing
    the scope of the test by not mocking dependencies eventually makes test maintenance
    difficult and reduces the high level detailed coverage of the test. Since the
    dependencies will have to be tested, this can result in less detail being tested
    due to increased scope.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过隔离依赖项来保持测试范围较小，使得测试易于理解并促进了易于维护。通过不模拟依赖项来增加测试范围，最终会使测试维护变得困难，并减少测试的高级详细覆盖。由于必须对依赖项进行测试，这可能导致由于范围增加而导致测试的细节减少。
- en: Refactoring legacy code
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构遗留代码
- en: Legacy source code is the code that was written by you or someone else usually
    without tests or using an old framework, architecture, or technology. Such a code
    base can be difficult to rewrite or maintain. It can sometimes be tangled code
    that cannot be easily read and understood and as such is very difficult to change.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 遗留源代码是由您或其他人编写的代码，通常没有测试或使用旧的框架、架构或技术。这样的代码库可能很难重写或维护。它有时可能是难以阅读和理解的混乱代码，因此很难更改。
- en: When faced with the daunting task of maintaining a legacy code base, especially
    a code base written without adequate or proper testing, writing unit tests for
    such code can be difficult, and a waste of time, and can result in a lot of hard
    work. However, using a mocking framework can greatly simplify the refactoring
    process, as the new code being written can be isolated from the existing code
    and tested using mock objects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 面对维护遗留代码库的艰巨任务，特别是没有充分或适当测试的代码库，为这样的代码编写单元测试可能很困难，也可能是浪费时间，并且可能需要大量的辛苦工作。然而，使用模拟框架可以极大地简化重构过程，因为正在编写的新代码可以与现有代码隔离，并使用模拟对象进行测试。
- en: Wider test coverage
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更广泛的测试覆盖
- en: With mocks, you are sure of a wide test coverage, as you can easily use mock
    objects to simulate possible exceptions, execution scenarios, and conditions that
    otherwise would be difficult without mocks. For example, if you have a method
    that purges or drops a database table, it is safer to test this method using mock
    objects than run it on a live database each time the unit test is run.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过模拟，您可以确保进行广泛的测试覆盖，因为您可以轻松使用模拟对象来模拟可能的异常、执行场景和条件，否则这些情况将很难实现。例如，如果您有一个清除或删除数据库表的方法，使用模拟对象测试这个方法比每次运行单元测试时在实时数据库上运行更安全。
- en: The shortcomings of mocking frameworks
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟框架的缺点
- en: While mocking frameworks are very useful during TDD in that they simplify unit
    testing through the use of mock objects, they, however, have some limitations
    and downsides that can impact the design of the code or through excessive usage
    lead to the creation of tangled tests containing irrelevant mock objects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然模拟框架在TDD期间非常有用，因为它们通过使用模拟对象简化了单元测试，但它们也有一些限制和缺点，可能会影响代码的设计，或者通过过度使用导致包含不相关模拟对象的混乱测试的创建。
- en: Interface explosion
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口爆炸
- en: The architecture of the majority of the mocking frameworks necessitates that
    interfaces should be created in order to mock objects. In essence, you cannot
    mock a class directly; it has to be through the interface implemented by the class.
    In an attempt to mock dependencies during unit testing, an interface is created
    for each object or dependency to be mocked, even if the interface is not required
    to use the dependency in production code. This results in the creation of too
    many interfaces, a condition known as **interface explosion**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数嘲弄框架的架构要求必须创建接口来模拟对象。实质上，你不能直接模拟一个类；必须通过类实现的接口来进行。为了在单元测试期间模拟依赖关系，为每个要模拟的对象或依赖关系创建一个接口，即使在生产代码中使用该依赖关系时并不需要该接口。这导致创建了太多的接口，这种情况被称为**接口爆炸**。
- en: Extra complexity
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的复杂性
- en: Most mocking frameworks use reflection or create proxies to invoke the methods
    and create the mocks required in unit tests. This process is slow and adds overhead
    to the unit testing process. This is noticeable especially when it is desired
    to mock interactions between all classes and dependencies using mocks, which can
    lead to a situation where a mock returns other mocks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数模拟框架使用反射或创建代理来调用方法并创建单元测试中所需的模拟。这个过程很慢，并给单元测试过程增加了额外的开销。特别是当希望使用模拟来模拟所有类和依赖关系之间的交互时，这一点尤其明显，这可能导致模拟返回其他模拟的情况。
- en: Mock explosion
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟爆炸
- en: With the availability of several mocking frameworks, it is easier to get familiar
    with mocking concepts and create mocks for unit testing. However, a developer
    can start to over-mock, a situation where every object seems like a mock candidate.
    Also, having too many mocks can lead to writing fragile tests, making your tests
    prone to breaking when the interface changes. When you have too many mocks, this
    ends up slowing down the test suites and consequently increases development time.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有了几种模拟框架，更容易熟悉模拟概念并为单元测试创建模拟。然而，开发人员可能会开始过度模拟，即每个对象似乎都是模拟候选对象的情况。此外，拥有太多的模拟可能会导致编写脆弱的测试，使你的测试容易在接口更改时出现问题。当你有太多的模拟时，最终会减慢测试套件的速度，并因此增加开发时间。
- en: Hand-rolling mocks versus using a mocking framework
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动编写模拟与使用模拟框架
- en: Using a mocking framework can facilitate a smooth unit testing experience, especially
    when unit testing a portion of code with dependencies in which mock objects are
    created and substituted for the dependencies. While it is easier using mocking
    frameworks, you might sometimes prefer to hand-roll mock objects for your unit
    tests and not add extra complexity or additional libraries to your project or
    code base.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟框架可以促进流畅的单元测试体验，特别是在单元测试具有依赖关系的代码部分时，模拟对象被创建并替代依赖关系。虽然使用模拟框架更容易，但有时你可能更喜欢手动编写模拟对象进行单元测试，而不向项目或代码库添加额外的复杂性或附加库。
- en: Hand-rolled mocks are classes that are created for the purpose of testing and
    used to replace production objects. These created classes will have equivalent
    methods as the production classes with the same definitions and return values
    to effectively simulate the production classes and to use as substitute for dependencies
    in unit tests.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 手动编写的模拟是为了测试而创建的类，用于替换生产对象。这些创建的类将具有与生产类相同的方法和定义，以及返回值，以有效模拟生产类并用作单元测试中依赖关系的替代品。
- en: Mocking concept
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟概念
- en: The first step in creating mocks should be dependency identification. The goal
    of unit testing should be to have clean code and tests that run as quickly as
    possible with good coverage. You should identify dependencies that can slow down
    your tests. These are candidates for mocking, for example, a web service or database
    call.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模拟的第一步应该是识别依赖关系。单元测试的目标应该是编写清晰的代码，并尽可能快地运行具有良好覆盖率的测试。你应该识别可能减慢测试速度的依赖关系。例如，Web服务或数据库调用就是模拟的候选对象。
- en: The approach for creating mock objects can vary based on the type of dependencies
    being mocked. However, the concepts of mocking can follow the basic concepts that
    mock objects should return specific predefined values when the methods are invoked.
    There should be an appropriate validation mechanism in place to ensure the methods
    of the mock were called and the mock object can throw an exception if configured
    based on the test requirements.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模拟对象的方法可以根据被模拟的依赖关系的类型而变化。然而，模拟的概念可以遵循模拟对象在调用方法时应返回特定预定义值的基本概念。应该有适当的验证机制来确保模拟的方法被调用，并且如果根据测试要求进行配置，模拟对象可以抛出异常。
- en: It is important to understand the types of mock objects to effectively hand-roll
    mock objects. There are two types of mock objects that can be created—dynamic
    and static mock objects. **Dynamic objects** can be created through reflection
    or proxy classes. This is similar to how mocking frameworks work. **Static mock
    objects** can be created by having classes that implement an interface and sometimes
    the actual concrete class that is the dependency to be mocked. You are essentially
    creating static mock objects when you hand-roll mocks objects.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 了解模拟对象的类型对于有效地手动编写模拟对象非常重要。可以创建两种类型的模拟对象——动态和静态模拟对象。**动态对象**可以通过反射或代理类创建。这类似于模拟框架的工作方式。**静态模拟对象**可以通过实现接口的类以及有时作为要模拟的依赖关系的实际具体类来创建。当你手动编写模拟对象时，实质上你正在创建静态模拟对象。
- en: '**Reflection** can be used to create mock objects. Reflection in C# is a useful
    construct that allows you to create an object that is an instance of a type, as
    well as getting or binding a type to an existing object and invoking the available
    fields and method in the type. Additionally, you can use reflection to create
    objects that describe modules and assemblies.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**反射**可以用来创建模拟对象。C#中的反射是一个有用的构造，允许你创建一个类型的实例对象，以及获取或绑定类型到现有对象，并调用类型中可用的字段和方法。此外，你可以使用反射来创建描述模块和程序集的对象。'
- en: Benefits of hand-rolling mocks
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动编写模拟的好处
- en: Hand-rolling your mocks can sometimes be an effective approach to use, when
    you intend to have full control of your test setup and specify the behavior of
    the test setup. Also, when the test is relatively simple, using a mocking framework
    is not an option; it is better to roll the mock and keep everything simple.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 手动编写您的模拟有时可能是一种有效的方法，当您打算完全控制测试设置并指定测试设置的行为时。此外，当测试相对简单时，使用模拟框架不是一个选择；最好手动编写模拟并保持一切简单。
- en: When using mocking frameworks, making changes to the real object being mocked
    will necessitate changes to the mock objects wherever they are used. This is because
    changes made to the dependency will break the tests. If, for example, the method
    name on the dependent object changes, you have to change this in the dynamic mocks.
    Thus, changes have to be made in several parts of the code base. With hand-rolled
    mocks, you only have to make the changes at one point only since you are in control
    of what method is presented to the tests.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟框架时，对被模拟的真实对象进行更改将需要更改在其使用的任何地方的模拟对象。这是因为对依赖项进行的更改将破坏测试。例如，如果依赖对象上的方法名称发生更改，您必须在动态模拟中进行更改。因此，必须在代码库的几个部分进行更改。使用手动编写的模拟，您只需要在一个地方进行更改，因为您可以控制向测试呈现的方法。
- en: Mocks and stubs
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟和存根
- en: '**Mocks** and **stubs** are both similar because they are used to replace class
    dependencies or collaborators and most mocking frameworks provide the features
    to create both. Stubs can be hand-rolled in the same manner you hand-roll mocks.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟**和**存根**都很相似，因为它们用于替换类依赖项或协作者，并且大多数模拟框架都提供创建两者的功能。存根可以以与手动编写模拟相同的方式手动编写。'
- en: So what really differentiates mocks from stubs? Mocks are used to test collaboration.
    This includes verifying the expectations of the actual collaborator. Mocks are
    programmed to have the expectation containing the details of method invocations
    to be received, while stubs are used to simulate collaborators. Let's explain
    this further with an illustration.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 那么模拟和存根真正的区别是什么？模拟用于测试协作。这包括验证实际协作者的期望。模拟被编程为具有包含要接收的方法调用详细信息的期望，而存根用于模拟协作者。让我们通过一个例子进一步解释这一点。
- en: A stub can be used to represent the result from a database. In place of a database
    call to return a set of data, a C# list can be created with the data that can
    be used in executing a test. If the stub above the dependency interaction of the
    test is not validated, the test will only be concerned with the data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 存根可用于表示来自数据库的结果。可以创建一个C#列表，其中包含可用于执行测试的数据，以替代数据库调用返回一组数据。如果未验证测试的依赖项交互上方的存根，则测试将仅关注数据。
- en: 'The `LoanService` class in the following snippet has a `GetBadCarLoans` method
    that accepts a list of `Loan` objects to be retrieved from a database:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段中的`LoanService`类具有一个`GetBadCarLoans`方法，该方法接受要从数据库中检索的`Loan`对象列表：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The test for the `GetBadCarLoans` method, `Test_GetBadCarLoans_ShouldReturnLoans`,
    in the following snippet uses a stub, which is a list of `Loan` objects that is
    passed as a parameter to the `GetBadCarLoans` method, instead of making a database
    call to get the list of `Loan` objects to be used for the `Test` class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段中`Test_GetBadCarLoans_ShouldReturnLoans`的`GetBadCarLoans`方法的测试使用了存根，这是一个`Loan`对象列表，作为参数传递给`GetBadCarLoans`方法，而不是调用数据库以获取用于`Test`类的`Loan`对象列表：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `LoanService` class in the following snippet has a `LoanRepository` DI that
    connects to the database to fetch records. The class has a constructor, where
    the `ILoanRepository` object is injected. The `LoanService` class has a `GetBadCarLoans`
    method that calls the `GetCarLoan` method on the dependency, which in turn makes
    a call to get a list of `Loan` objects from the database:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段中的`LoanService`类具有连接到数据库以获取记录的`LoanRepository` DI。该类具有一个构造函数，在该构造函数中注入了`ILoanRepository`对象。`LoanService`类具有一个`GetBadCarLoans`方法，该方法调用依赖项上的`GetCarLoan`方法，后者又调用数据库获取`Loan`对象列表：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Unlike when using a stub, a mock will verify that a method in a dependency
    is called. This implies that the mock object will have a setup of the method to
    be called in the dependency. In the `LoanServiceTest` class in the following snippet,
    a mock object is created from `ILoanRepository`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用存根时不同，模拟将验证调用依赖项中的方法。这意味着模拟对象将设置依赖项中要调用的方法。在以下片段中的`LoanServiceTest`类中，从`ILoanRepository`创建了一个模拟对象：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the constructor of the `LoanServiceTest` class, the data to be returned by
    the mock object is first created, followed by the method set up in the line `loanRepository.Setup(x
    => x.GetCarLoans()).Returns(loans);`. The mock object is then passed to the `LoanService`
    constructor, `loanService= new loanService(loanRepository.Object);`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LoanServiceTest`类的构造函数中，首先创建了模拟对象要返回的数据，然后设置了依赖项中的方法，如`loanRepository.Setup(x
    => x.GetCarLoans()).Returns(loans);`。然后将模拟对象传递给`LoanService`构造函数，`loanService=
    new loanService(loanRepository.Object);`。
- en: Hand-rolled mock
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动编写模拟
- en: 'We can hand-roll a mock object to test the `LoanService` class. The mock object
    to be created will implement the `ILoanRepository` interface and will be used
    for the purpose of unit testing only since it is not needed in the production
    code. The mock object will return a list of `Loan` objects, which will simulate
    the actual call to the database:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动编写一个模拟对象来测试`LoanService`类。要创建的模拟对象将实现`ILoanRepository`接口，并且仅用于单元测试，因为在生产代码中不需要它。模拟对象将返回一个`Loan`对象列表，这将模拟对数据库的实际调用。
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `LoanRepositoryMock` class created can now be used in the `LoanService`
    class to mock `ILoanRepository` in place of using a mock object created from a
    mock framework. In the constructor of the `LoanServiceTest` class, the `LoanRepositoryMock`
    class will be instantiated and injected into the `LoanService` class, which is
    used in the `Test` class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在`LoanService`类中使用创建的`LoanRepositoryMock`类来模拟`ILoanRepository`，而不是使用从模拟框架创建的模拟对象。在`LoanServiceTest`类的构造函数中，将实例化`LoanRepositoryMock`类并将其注入到`LoanService`类中，该类在`Test`类中使用：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Because `LoanRepositoryMock` is used as a concrete class for the `ILoanRepository`
    interface, a dependency of the `LoanService` class, whenever the `GetCarLoans`
    method is called on the `ILoanRepository` interface, the `GetCarLoans` method
    of `LoanRepositoryMock` will be called to return the data required for the test
    to run.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`LoanRepositoryMock`被用作`ILoanRepository`接口的具体类，是`LoanService`类的依赖项，所以每当在`ILoanRepository`接口上调用`GetCarLoans`方法时，`LoanRepositoryMock`的`GetCarLoans`方法将被调用以返回测试运行所需的数据。
- en: Mocking objects using Moq framework
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Moq框架模拟对象
- en: Selecting a mock framework to use for mocking objects is important for a smooth
    unit testing experience. However, there are no written rules to be followed for
    this. You can consider some factors and features of the mocking framework when
    selecting a mocking framework for use in your tests.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 选择用于模拟对象的模拟框架对于顺利进行单元测试是很重要的。然而，并没有必须遵循的书面规则。在选择用于测试的模拟框架时，您可以考虑一些因素和功能。
- en: Performance and available features should be the first factors to be considered
    when selecting a mocking framework. You should examine the way the mocking framework
    creates mocks; frameworks that use inheritance, virtual, and static methods cannot
    be mocked. Other features to look out for can be methods, properties, events,
    and even if the framework supports LINQ.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择模拟框架时，性能和可用功能应该是首要考虑因素。您应该检查模拟框架创建模拟的方式；使用继承、虚拟和静态方法的框架无法被模拟。要注意的其他功能可能包括方法、属性、事件，甚至是框架是否支持LINQ。
- en: Additionally, nothing beats simplicity and the ease of use of a library. You
    should go for a framework that is easy to use, with good documentation of the
    available features. In the subsequent sections of this chapter, the other concepts
    of mocking will be explained using the Moq framework, an easy-to-use strongly
    typed library.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，没有什么比库的简单性和易用性更好。您应该选择一个易于使用的框架，并且具有良好的可用功能文档。在本章的后续部分中，将使用Moq框架来解释模拟的其他概念，这是一个易于使用的强类型库。
- en: When using Moq, the mock object is an actual dummy class that is created for
    you using reflection, which contains the implementation of methods contained in
    an interface that is being mocked. In the Moq setup, you will specify the interface
    you want to mock and the methods that the test class requires to effectively run
    the tests.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Moq时，模拟对象是一个实际的虚拟类，它是使用反射为您创建的，其中包含了被模拟的接口中包含的方法的实现。在Moq设置中，您将指定要模拟的接口以及测试类需要有效运行测试的方法。
- en: 'To use Moq, you need to install the library through the NuGet package manager
    or through the NuGet console:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Moq，您需要通过NuGet包管理器或NuGet控制台安装该库：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To explain mocking with Moq, let''s create an `ILoanRepository` interface with
    two methods, `GetCarLoan`, which retrieves car loans from the database as a list,
    and a `GetLoanTypes` method that returns a list of `LoanType` objects:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释使用Moq进行模拟，让我们创建一个`ILoanRepository`接口，其中包含两种方法，`GetCarLoan`用于从数据库中检索汽车贷款列表，以及`GetLoanTypes`方法，用于返回`LoanType`对象的列表：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `LoanRepository` class uses the Entity Framework as the ORM for data access
    and retrieval and implements `ILoanRepository`. The two methods, `GetLoanTypes`
    and `GetCarLoans`, have been implemented by the `LoanRepository` class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoanRepository`类使用Entity Framework作为数据访问和检索的ORM，并实现了`ILoanRepository`。`GetLoanTypes`和`GetCarLoans`两种方法已经被`LoanRepository`类实现：'
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's create a mock object for `ILoanRepository` to test the two methods without
    having to depend on any concrete class implementation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`ILoanRepository`创建一个模拟对象，以便在不依赖任何具体类实现的情况下测试这两种方法。
- en: 'Creating a mock object is easy with Moq:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Moq很容易创建一个模拟对象：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding line of code, a mock object has been created which implements
    the `ILoanRepository` interface. The object can be used as a regular implementation
    of `ILoanRepository` and injected into any class that has `ILoanRepository` as
    the dependency.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，已经创建了一个实现`ILoanRepository`接口的模拟对象。该对象可以被用作`ILoanRepository`的常规实现，并注入到任何具有`ILoanRepository`依赖的类中。
- en: Mocking methods, properties, and callback
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟方法、属性和回调
- en: Before the methods of the mock objects can be used in the test, they need to
    be set up. This setup is preferably done in the constructor of the test class
    after the mock object is created and before the object is injected into the class
    that requires the dependency.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中使用模拟对象的方法之前，它们需要被设置。这个设置最好是在测试类的构造函数中完成，模拟对象创建后，但在将对象注入到需要依赖的类之前。
- en: 'First, the data to be returned by the method to be set up will have to be created;
    this is the dummy data to be used in the test:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要创建要由设置的方法返回的数据；这是测试中要使用的虚拟数据：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At the point of setting up the method, the return data will be passed to it
    as well as any method parameter, if applicable. In the following line of code,
    the `GetCarLoans` method is set up with the list of the `Loan` objects passed
    as the return data. This means that whenever the `GetCarLoans` method is invoked
    in the unit test using the mock object, the list created earlier will be returned
    as the method return value:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置方法的时候，返回数据将被传递给它，以及任何方法参数（如果适用）。在下一行代码中，`GetCarLoans`方法被设置为以`Loan`对象的列表作为返回数据。这意味着每当在单元测试中使用模拟对象调用`GetCarLoans`方法时，之前创建的列表将作为方法的返回值返回：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can have a lazy evaluation of the method return value. This is a syntax
    sugar available with the use of LINQ:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以对方法返回值进行延迟评估。这是使用LINQ提供的语法糖：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Moq has an `It` object, which can be used to specify a matching condition for
    a parameter in the method being set up. `It` refers to the argument being matched.
    Assuming the `GetCarLoans` method has a string parameter, `loanType,` the syntax
    of the method setup can be changed to include the parameter with the return value:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Moq有一个`It`对象，它可以用来指定方法中参数的匹配条件。`It`指的是被匹配的参数。假设`GetCarLoans`方法有一个字符串参数`loanType`，那么方法设置的语法可以改变以包括参数和返回值：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It is possible to set up a method that returns a different return value each
    time it is invoked. For example, the setup of the `GetCarLoans` method can be
    done to return different sizes of the list each time the method is called:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设置一个方法，每次调用时返回不同的返回值。例如，可以设置`GetCarLoans`方法的设置，以便在每次调用该方法时返回不同大小的列表：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding snippet, a random number is generated between `1` and `3`,
    to set. This will ensure that the size of the list to be returned by the `GetCarLoans`
    method varies with each invocation. The first time the `GetCarLoans` method is
    called, the `Returns` method is called, while the code in the `Callback` is executed
    with subsequent calls to the `GetCarLoans` method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，生成了`1`和`3`之间的随机数，以设置。这将确保由`GetCarLoans`方法返回的列表的大小随每次调用而变化。第一次调用`GetCarLoans`方法时，将调用`Returns`方法，而在随后的调用中，将执行`Callback`中的代码。
- en: 'A feature of Moq is the provision of testing for exceptions. You can set up
    the method to test for exceptions. In the following method setup, the `GetCarLoans`
    method throws `InvalidOperationException` when called:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Moq的一个特性是提供异常测试的功能。您可以设置方法以测试异常。在以下方法设置中，当调用时，`GetCarLoans`方法会抛出`InvalidOperationException`：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Properties
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'If you have a dependency that has properties to be set which are used in the
    method calls, you can set dummy values for such properties using the Moq `SetupProperty`
    method. Let''s add two properties to the `ILoanRepository` interface, `LoanType`
    and `Rate`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个具有要在方法调用中使用的属性的依赖项，可以使用Moq的`SetupProperty`方法为这些属性设置虚拟值。让我们向`ILoanRepository`接口添加两个属性，`LoanType`和`Rate`：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With the Moq `SetupProperty` method, you can specify that the property should
    have a behavior, which in essence implies that whenever the property is requested,
    the value set in the `SetupProperty` method will be returned:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Moq的`SetupProperty`方法，您可以指定属性应具有的行为，这实质上意味着每当请求属性时，将返回在`SetupProperty`方法中设置的值：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The lines of code in the preceding snippet set the `LoanType` property to an
    enum value, `CarLoan`, and `Rate` to `12.5`. Whenever the properties are requested
    in a test, the set values will be returned to the calling points.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中的代码将`LoanType`属性设置为枚举值`CarLoan`，并将`Rate`设置为`12.5`。在测试中请求属性时，将返回设置的值到调用点。
- en: Setting the properties using the `SetupProperty` method automatically sets the
    property as a stub and will allow the values of the properties to be tracked and
    provide a default value for the property.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`SetupProperty`方法设置属性会自动将属性设置为存根，并允许跟踪属性的值并为属性提供默认值。
- en: 'Also, while setting up the property, you can use the `SetupSet` method, which
    accepts a lambda expression to specify a type for a call to a property setter
    and allows you to pass the value into the expression:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在设置属性时，还可以使用`SetupSet`方法，该方法接受lambda表达式来指定对属性设置器的调用类型，并允许您将值传递到表达式中：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Similar to `SetupSet` is `SetupGet`, which is used to specify a setup on the
    type for a call to a property getter:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetupSet`类似于`SetupGet`，用于为属性的调用指定类型的设置：'
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Recursive mocking allows you to mock complex object types, especially nested
    complex types. For example, you might want to mock the `Age` property in the `Person`
    complex type of the `Loan` type. The Moq framework can traverse this graph to
    mock the property in an elegant way:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 递归模拟允许您模拟复杂的对象类型，特别是嵌套的复杂类型。例如，您可能希望模拟`Loan`类型中`Person`复杂类型的`Age`属性。Moq框架可以以优雅的方式遍历此图以模拟属性：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can stub all the properties available on a mock, using the `SetupAllProperties`
    method. This method will specify that all properties on the mock have a property
    behavior set. By generating the default value for each property in the mock, the
    default property is generated using the `Mock.DefaultProperty` property of the
    Moq framework:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`SetupAllProperties`方法存根模拟对象上的所有属性。此方法将指定模拟上的所有属性都具有属性行为设置。通过在模拟中为每个属性生成默认值，使用Moq框架的`Mock.DefaultProperty`属性生成默认属性：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Matching parameters
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配参数
- en: When using Moq to create mock objects, you can match arguments to ensure that
    the expected parameters are passed during a test. Using this feature, you can
    ascertain the validity of the arguments passed into a method while the method
    is called while being tested. This is applicable only to methods that have arguments
    and the matching will be done during the method setup.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Moq创建模拟对象时，您可以匹配参数以确保在测试期间传递了预期的参数。使用此功能，您可以确定在测试期间调用方法时传递的参数的有效性。这仅适用于具有参数的方法，并且匹配将在方法设置期间进行。
- en: 'Using Moq''s `It` keyword, you can specify different expressions and validations
    for the method parameter during setup. Let''s add a `GetCarLoanDefaulters` method
    definition to the `ILoanRepository` interface. The implementation in the `LoanRepository`
    class accepts an integer parameter, which is the service year for a loan and returns
    a list of car loan defaulters. The `GetCarLoanDefaulters` method code is shown
    in the following snippet:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Moq的`It`关键字，您可以在设置期间为方法参数指定不同的表达式和验证。让我们向`ILoanRepository`接口添加一个`GetCarLoanDefaulters`方法定义。`LoanRepository`类中的实现接受一个整数参数，该参数是贷款的服务年限，并返回汽车贷款拖欠者的列表。以下片段显示了`GetCarLoanDefaulters`方法的代码：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s set up the `GetCarLoanDefaulters` method in the `LoanServiceTest`
    constructor to accept a different value for the `year` parameter using Moq''s `It`
    keyword:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`LoanServiceTest`构造函数中设置`GetCarLoanDefaulters`方法，以使用Moq的`It`关键字接受不同的`year`参数值：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A list of `Person` objects has been created, which will be passed to the `Returns`
    method of the mock setup. The `GetCarLoanDefaulters` method will now accept the
    value in the range specified, since the `It.IsInRange` method has been used with
    both the upper and lower range value supplied.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 已创建了一个`Person`对象列表，将传递给模拟设置的`Returns`方法。`GetCarLoanDefaulters`方法现在将接受指定范围内的值，因为`It.IsInRange`方法已经使用了上限和下限值。
- en: 'The `It` class has other useful methods for specifying the matching conditions
    for a method during setup instead of having to specify a particular value:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`It` 类有其他有用的方法，用于在设置期间指定方法的匹配条件，而不必指定特定的值：'
- en: '`IsRegex` is used for specifying a regular expression to match a string argument'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsRegex` 用于指定一个正则表达式来匹配一个字符串参数'
- en: '`Is` is used to specify a value that matches a given predicate'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Is` 用于指定与给定谓词匹配的值'
- en: '`IsAny<>` is used to match any value of the type specified'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsAny<>` 用于匹配指定类型的任何值'
- en: '`Ref<>` is used to match any value specified in a `ref` parameter'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ref<>` 用于匹配在 `ref` 参数中指定的任何值'
- en: 'You can create a custom matcher and use it in method setup. For example, let''s
    create a custom matcher, `IsOutOfRange`, for the `GetCarLoanDefaulters` method
    to ensure a value greater than `12` is not supplied as an argument. Creating a
    custom matcher is done by using `Match.Create`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建一个自定义匹配器，并在方法设置中使用它。例如，让我们为 `GetCarLoanDefaulters` 方法创建一个自定义匹配器 `IsOutOfRange`，以确保不会提供大于
    `12` 的值作为参数。通过使用 `Match.Create` 来创建自定义匹配器：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The created `IsOutOfRange` matcher can now be used in a method setup of a mock
    object:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在模拟对象的方法设置中使用创建的 `IsOutOfRange` 匹配器：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Events
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: 'Moq has a feature that allows you to raise an event on the mock object. To
    raise an event, you use the `Raise` method. The method has two parameters. The
    first is a Lambda expression with the event subscribed for the event to be raised
    on the mock. The second argument provides a parameter that will be included in
    the event. To raise a `LoanDefaulterNotification` event on the `loanRepository`
    mock object with an empty argument, you can use the following line of code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Moq 有一个功能，允许您在模拟对象上引发事件。要引发事件，您使用 `Raise` 方法。该方法有两个参数。第一个是 Lambda 表达式，用于订阅事件以在模拟上引发事件。第二个参数提供将包含在事件中的参数。要在
    `loanRepository` 模拟对象上引发 `LoanDefaulterNotification` 事件，并使用空参数，您可以使用以下代码行：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Real use cases are used when you want to have a mock object raise an event
    in response to an action or raise an event in response to a method invocation.
    When setting up a method on a mock to allow events to be raised, the `Returns`
    method on the mock is replaced with the `Raises` method, which indicates that
    when the method is called in the test, an event should be raised:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 真实用例是当您希望模拟对象响应动作引发事件或响应方法调用引发事件时。在模拟对象上设置方法以允许引发事件时，模拟上的 `Returns` 方法将被替换为
    `Raises` 方法，该方法指示在测试中调用方法时，应该引发事件：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Callbacks
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调
- en: Using the `Callback` method of Moq, you can specify the callback to be invoked
    before and after a method is called. There are some test scenarios that might
    not be easily tested using the simple mock expectations. In such complex scenarios,
    you can use a callback to execute specific actions when the mock objects are called.
    The `Callback` method accepts an action parameter, which will be executed based
    on whether the callback is set up before or after the method invocation. The action
    can be an expression to be evaluated or another method to be called.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Moq 的 `Callback` 方法，您可以指定在调用方法之前和之后要调用的回调。有一些测试场景可能无法使用简单的模拟期望轻松测试。在这种复杂的情况下，您可以使用回调来执行特定的操作，当调用模拟对象时。`Callback`
    方法接受一个动作参数，根据回调是在方法调用之前还是之后设置，将执行该动作。该动作可以是要评估的表达式或要调用的另一个方法。
- en: For example, you can have a callback set up to change the data after a specific
    method has been called. This feature allows you to create tests that offer more
    flexibility while simplifying test complexities. Let's add a callback to the `loanRepository`
    mock object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以设置一个回调，在调用特定方法之后更改数据。此功能允许您创建提供更大灵活性的测试，同时简化测试复杂性。让我们向 `loanRepository`
    模拟对象添加一个回调。
- en: 'The callback can be a method that will be invoked or a property that you need
    to set with values:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 回调可以是一个将被调用的方法，或者是您需要设置值的属性：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding snippet has two callbacks set up for the method setup. The `CarLoanDefaultersCallback`
    method is called before the actual `GetCarLoanDefaulters` method is invoked and
    `CarLoanDefaultersCallbackAfter` will be called after the `GetCarLoanDefaulters`
    method has been called on the mock object. `CarLoanDefaultersCallback` adds a
    new `Person` object to the `List` and `CarLoanDefaultersCallback` removes the
    first element in the list:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的片段为方法设置设置了两个回调。`CarLoanDefaultersCallback` 方法在实际调用 `GetCarLoanDefaulters`
    方法之前被调用，`CarLoanDefaultersCallbackAfter` 在在模拟对象上调用 `GetCarLoanDefaulters` 方法之后被调用。`CarLoanDefaultersCallback`
    向 `List` 添加一个新的 `Person` 对象，`CarLoanDefaultersCallback` 删除列表中的第一个元素：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Mock customization
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟定制
- en: 'When using the Moq framework, you can further customize mock object, to enhance
    the effective unit testing experience. The `MockBehavior` enum can be passed into
    Moq''s `Mock` object constructor to specify the behavior of the mock. The enum
    members are `Default`, `Strict`, and `Loose`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Moq 框架时，您可以进一步定制模拟对象，以增强有效的单元测试体验。可以将 `MockBehavior` 枚举传递到 Moq 的 `Mock`
    对象构造函数中，以指定模拟的行为。枚举成员有 `Default`、`Strict` 和 `Loose`：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When a `Loose` member is selected, the mock will not throw any exceptions.
    The default values will always be returned. This means null will be returned for
    reference types, and zero or empty arrays and enumerables will be returned for
    value types:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择 `Loose` 成员时，模拟将不会抛出任何异常。默认值将始终返回。这意味着对于引用类型，将返回 null，对于值类型，将返回零或空数组和可枚举类型：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Selecting a `Strict` member will make the mock throw exceptions for every call
    on the mock that does not have a proper setup. Lastly, the `Default` member is
    the default behavior of the mock, which technically equals the `Loose` enum member.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 `Strict` 成员将使模拟对于每次在模拟上没有适当设置的调用都抛出异常。最后，`Default` 成员是模拟的默认行为，从技术上讲等同于 `Loose`
    枚举成员。
- en: CallBase
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CallBase
- en: '`CallBase`, when initialized during a mock construction, is used to specify
    whether the base class virtual implementation will be invoked for mocked dependencies
    if no setup is matched. The default value is `false`. This is useful when mocking
    HTML/web controls of the `System.Web` namespace:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟构造期间初始化`CallBase`时，用于指定是否在没有匹配的设置时调用基类虚拟实现。默认值为`false`。这在模拟`System.Web`命名空间的HTML/web控件时非常有用：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Mock repository
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟存储库
- en: 'Instead of having mock objects creation code scattered across your tests, you
    can avoid repetitive code by using `MockRepository`, available in Moq for creating
    and verifying mocks in a single location, thereby ensuring that you can do mock
    configuration by setting `CallBase`, `DefaultValue`, and `MockBehavior` and verifying
    the the mocks in one place:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Moq中的`MockRepository`，可以避免在测试中分散创建模拟对象的代码，从而避免重复的代码。`MockRepository`可用于在单个位置创建和验证模拟，从而确保您可以通过设置`CallBase`、`DefaultValue`和`MockBehavior`进行模拟配置，并在一个地方验证模拟：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code snippet, a mock repository is created with `MockBehaviour.Strict`,
    and two mock objects are created, each with the `loanRepository` mock, overriding
    the default `MockBehaviour` specified in the repository. The last statement is
    an invocation of the `Verify` method to verify all expectations on all the mock
    objects created in the repository.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，使用`MockBehaviour.Strict`创建了一个模拟存储库，并创建了两个模拟对象，每个对象都使用`loanRepository`模拟，覆盖了存储库中指定的默认`MockBehaviour`。最后一条语句是对`Verify`方法的调用，以验证存储库中创建的所有模拟对象的所有期望。
- en: Implementing multiple interfaces in a mock
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模拟中实现多个接口
- en: 'Additionally, you can implement multiple interfaces in a single mock. For example,
    we can create a mock that implements `ILoanRepository` and later implements the
    `IDisposable` interface using the `As<>` method, which is used to add an interface
    implementation to a mock and to specify a setup for it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以在单个模拟中实现多个接口。例如，我们可以创建一个模拟，实现`ILoanRepository`，然后使用`As<>`方法实现`IDisposable`接口，该方法用于向模拟添加接口实现并为其指定设置：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Verification method and property invocations with Moq
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Moq进行验证的方法和属性调用
- en: Mock behaviors are specified during the setup. This is the expected behavior
    of an object and the collaborator. While unit testing, mocking is not complete
    until all the mocked dependencie's invocations have been verified. It can be helpful
    to be aware of the number of times methods were executed or properties accessed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟行为在设置期间指定。这是对象和协作者的预期行为。在单元测试时，模拟不完整，直到验证了所有模拟依赖项的调用。了解方法执行的次数或属性访问的次数可能会有所帮助。
- en: The Moq framework has useful verification methods that can be used to verify
    mocked methods and properties. Also, the `Times` structure contains useful members
    showing the number of calls that can be allowed on a method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Moq框架具有有用的验证方法，可用于验证模拟的方法和属性。此外，`Times`结构包含有用的成员，显示可以在方法上允许的调用次数。
- en: 'The `Verify` method can be used to verify that a method invocation, together
    with the supplied parameters performed on a mock, match what was earlier configured
    during the mock setup and used with the default `MockBehaviour`, which is `Loose`.
    To explain verification concepts in Moq, let''s create a `LoanService` class that
    depends on `ILoanRepository` for data and add a method, `GetOlderCarLoanDefaulters`,
    to it to return a list of loan defaulters older than `20` years of age. `ILoanRepository`
    is injected to `LoanService` through the constructor:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Verify`方法可用于验证在模拟上执行的方法调用及提供的参数是否与先前在模拟设置期间配置的内容匹配，并且使用了默认的`MockBehaviour`，即`Loose`。为了解释Moq中的验证概念，让我们创建一个依赖于`ILoanRepository`的`LoanService`类，并向其添加一个名为`GetOlderCarLoanDefaulters`的方法，以返回年龄大于`20`岁的贷款拖欠人的列表。`ILoanRepository`通过构造函数注入到`LoanService`中：'
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To test the `LoanService` class, we will create a `LoanServiceTest` test class
    that uses dependency mocking to isolate `LoanService` for unit testing. `LoanServiceTest`
    will contain a constructor for setting up a mock for `ILoanRepository`, required
    by the `LoanService` class:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`LoanService`类，我们将创建一个`LoanServiceTest`测试类，该类使用依赖模拟来隔离`LoanService`进行单元测试。`LoanServiceTest`将包含一个构造函数，用于设置`LoanService`类所需的`ILoanRepository`的模拟：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`The LoanServiceTest` constructor contains a mock set up for the `GetCarLoanDefaulters`
    method of the `ILoanRepository` interface, with the arguments expectation and
    the return value. Let''s create a test method, `Test_GetOlderCarLoanDefaulters_ShouldReturnList`,
    to test `GetCarLoanDefaulters`. After the assert statements, there is the `Verify`
    method to check if `GetCarLoanDefaulters` was called once:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoanServiceTest`构造函数包含对`ILoanRepository`接口的`GetCarLoanDefaulters`方法的模拟设置，包括参数期望和返回值。让我们创建一个名为`Test_GetOlderCarLoanDefaulters_ShouldReturnList`的测试方法，以测试`GetCarLoanDefaulters`。在断言语句之后，有`Verify`方法来检查`GetCarLoanDefaulters`是否被调用了一次：'
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `Verify` method takes two arguments: the method to be verified and the
    `Time` structure. `Time.Once` was used, which specifies that the mocked method
    should only be called once.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Verify`方法接受两个参数：要验证的方法和`Time`结构。使用了`Time.Once`，指定模拟方法只能被调用一次。'
- en: '`Times.AtLeast(int callCount)`, when used, is to specify that a mocked method
    should be called in the minimum number of times specified in the value of the
    `callCount` parameter. This can be used to verify that a method was called in
    the number of times specified:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Times.AtLeast(int callCount)`用于指定模拟方法应该被调用的最小次数，该次数由`callCount`参数的值指定。这可用于验证方法被调用的次数：'
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the preceding test snippet, `Times.AtLeast(2)` was passed to the `Verify`
    method. The test, when run, will fail with `Moq.MoqException` because the `GetCarLoanDefaulters`
    method was only called once in the code being tested:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述测试片段中，将`Times.AtLeast(2)`传递给`Verify`方法。当运行测试时，由于被测试的代码中的`GetCarLoanDefaulters`方法只被调用了一次，测试将失败，并显示`Moq.MoqException`。
- en: '![](img/5fc37630-7401-4e5b-91eb-3b83646e10be.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5fc37630-7401-4e5b-91eb-3b83646e10be.png)'
- en: '`Times.AtLeastOnce` can be used to specify that a mocked method should be called
    a minimum of one time, which means the method can be called many times in the
    code being tested. We can modify the `Verify` method in `Test_GetOlderCarLoanDefaulters_ShouldReturnList`
    to take a second parameter as `Time.AtLeastOnce` to validate after the test is
    run that the `GetCarLoanDefaulters` was called at least once in the code being
    tested:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`Times.AtMost(int callCount)` can be used to specify the maximum number of
    times that a mocked method should be called in the code being tested. The `callCount`
    parameter is used to pass the value for the maximum invocation time for a method.
    This can be used to limit the calls allowed to a mocked method. A Moq exception
    is thrown if the method is called more than the `callCount` value specified:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`Times.AtMostOnce` is similar to `Time.Once` or `Time.AtLeastOnce`, but with
    the difference being that the mocked method can only be called at most one time.
    A Moq exception is thrown if the method is called more than once, but if the method
    is not called when the code is run, no exception will be thrown:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`Times.Between(callCountFrom,callCountTo, Range)` can be used in the `Verify`
    method to specify that the mocked method should be called between `callCountFrom`
    and `callCountTo` and the `Range` enum used to specify whether to include or exclude
    the range specified:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`Times.Exactly(callCount)` is very useful when you want to specify that a mocked
    method should be called at the `callCount` specified. If the mocked method is
    called fewer times than the `callCount` specified or more times, a Moq exception
    will be generated with a detailed description of the expectation and what failed:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s check the code now:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6b75b04-d6c5-4546-9ac3-c279e4a9d943.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: 'Also important is `Times.Never`. When used, it can verify that a mocked method
    is never used. You can use this when you don''t want a mocked method to be invoked:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'A mocked property verification is done in a similar manner to mocked methods
    using the `VerifySet` and `VerifyGet` methods. The `VerifySet` method is used
    to verify that a property was set on the mock. Also, the `VerifyGet` method is
    used to validate that a property was read on a mock, regardless of the value contained
    in the property:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To verify that a property has been set on a mock, irrespective of whatever
    value was set, you can use the `VerifySet` method with this syntax:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'At times, you might want to validate that a particular value was assigned to
    a property on the mock. You can do this by assigning the value to verify to the
    property in the `VerifySet` method:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `VerifyNoOtherCalls()` method introduced in Moq 4.8 can be used to ascertain
    that no calls were made other than the ones already verified. The `VerifyAll()`
    method is used to verify all expectations, irrespective of if they have been flagged
    as verifiable.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: LINQ to mocks
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Language-Integrated Query** (**LINQ**) is a language construct introduced
    in .NET 4.0, which provides query capabilities in the .NET Framework. LINQ has
    query expressions that are written in a declarative query syntax. There are different
    implementations of LINQ-LINQ to XML, used for querying XML documents, LINQ to
    entities, which is used for ADO.NET Entity Framework operations, LINQ to objects
    used for querying .NET collections, files, strings, and so on.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we have created mock objects using Lambda expressions
    syntax. Another exciting feature available in the Moq framework is **LINQ to mocks**,
    which allows you to set up mocks using LINQ like syntax.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: LINQ to Mocks is great for simple mocks, and for stubbing out dependencies when
    you really do not care about the verification. Using the `Of<>` method, you can
    create a mock object of the specified type.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use LINQ to Mocks to have multiple setups done on a single mock and
    recursive mocks, using LINQ like syntax:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding mock initialization, the `Rate` and `LoanType` properties were
    set up as stubs, with the default values for the properties, when accessed during
    the tests invocation.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Moq features
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, the default values provided by Moq might not be suitable for some
    test scenarios and you need to create a custom default value generation approach
    to complement what Moq currently provides, which are `DefaultValue.Empty` and
    `DefaultValue.Mock`. This can be done through extending `DefaultValueProvider`
    or `LookupOrFallbackDefaultValueProvider`, which are available in Moq 4.8 and
    higher:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `TestDefaultValueProvider` class created the sub-classes `LookupOrFallbackDefaultValueProvider`
    and implemented default values for both `string` and `List`. For any type of `string`,
    `string.empty` is returned and an empty list is created with a `List` of any type.
    `TestDefaultValueProvider` can now be used in mock creation, in the `Mock` constructor:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `objectName` variable in the preceding snippet will contain a string of
    zero characters since the implementation in `TestDefaultValueProvider` indicates
    that the `string` type should be assigned an empty string.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Mocking internal types
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on your project requirements, you might need to create mock objects
    for internal types. Internal types or members in C# are accessible only within
    files in the same assembly. Mocking internal types can be done by adding custom
    attributes to the `AssemblyInfo.cs` file of the concerned projects.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: If the assembly containing the internal types does not already have the `AssemblyInfo.cs`
    file, you can add it. Also, when the assembly is not strongly-named, you can add
    the `InternalsVisibleTo` attribute, which has the public key excluded. You have
    to specify the name of the project to share visibility with, which in this case
    should be the test project.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'If you change the `LoanService` access modifier to internal, you will get the
    error, `LoanService`. It is inaccessible due to its protection level. To be able
    to test `LoanService`, without changing the access modifier, we then add the `AssemblyInfo.cs`
    file to the project, and add the required attribute with the test project name
    specified in order to share the assembly that contains `LoanService` with the
    test project:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d577ffd0-5843-454d-ae40-c150b5f0c98b.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: 'The attribute added to the `AssemblyInfo.cs` file is shown in the following
    snippet:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Moq framework, when used together with the xUnit.net framework, can deliver
    a smooth unit testing experience and make the overall TDD process worthwhile.
    Moq provides powerful features that, when used effectively, can simplify the creation
    of dependencies mocking for unit tests.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Mock objects created with Moq can allow you to substitute the concrete dependencies
    in your unit tests for the created mocks created by you in order to isolate different
    units in your code for testing and subsequent refactoring, which can facilitate
    crafting elegant production-ready code. Also, you can use mock objects to experiment
    and test features available in dependencies that otherwise might not be easily
    done by using the live dependencies.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have explored the basics of mocking, and extensively used
    mocks in unit tests. Also, we configured mocks to set up methods and properties
    and return exceptions. Some other features provided by the Moq library were explained
    and mocks verification was covered.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Project hosting and continuous integration will be covered in the next chapter.
    This will include test and enterprise approaches to automate the running of tests
    to ensure that quality feedback can be provided on the code coverage.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL

- en: Variants of Trees
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树的变体
- en: In the previous chapters, you have learned about many data structures, starting
    with simple ones, such as arrays. Now, it is time for you to get to know a significantly
    more complex group of data structures, namely **trees**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，您已经了解了许多数据结构，从简单的数组开始。现在，是时候让您了解一组显著更复杂的数据结构，即**树**。
- en: At the beginning of this chapter, the basic tree will be presented, together
    with its implementation in the C# language and some examples showing it in action.
    Then, the binary tree will be introduced with a detailed description of its implementation
    and an example of its application. The binary search tree is another tree variant,
    which is one of the most popular types of trees, used in many algorithms. The
    following two sections will cover self-balancing trees, namely AVL and red-black
    trees.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，将介绍基本树，以及在C#语言中的实现和一些示例展示它的运行情况。然后，将介绍二叉树，详细描述其实现并举例说明其应用。二叉搜索树是另一种树的变体，是许多算法中使用的最流行的树类型之一。接下来的两节将涵盖自平衡树，即AVL和红黑树。
- en: 'The remaining part of the chapter is dedicated to heaps as tree-based data
    structures. Three kinds of heaps will be presented: binary, binomial, and Fibonacci.
    Such types will be briefly introduced, and the application of these data structures
    will be shown, using the external package.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将专门介绍堆作为基于树的数据结构。将介绍三种堆：二叉堆、二项式堆和斐波那契堆。这些类型将被简要介绍，并将展示这些数据结构的应用，使用外部包。
- en: Arrays, lists, stacks, queues, dictionaries, sets, and now... trees. Are you
    ready to increase the level of difficulty and learn the next set of data structures?
    If so, let's start reading!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 数组、列表、栈、队列、字典、集合，现在...树。您准备好提高难度并学习下一组数据结构了吗？如果是这样，让我们开始阅读！
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将涵盖以下主题：
- en: Basic trees
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本树
- en: Binary trees
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二叉树
- en: Binary search trees
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: AVL trees
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AVL树
- en: Red-black trees
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红黑树
- en: Binary heaps
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二叉堆
- en: Binomial heaps
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二项式堆
- en: Fibonacci heaps
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 斐波那契堆
- en: Basic trees
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本树
- en: 'Let''s start with introducing trees. What are they? Do you have any ideas about
    how such a data structure should look? If not, let''s take a look at the following
    diagram, which depicts a tree with captions regarding its particular elements:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从介绍树开始。它们是什么？您对这样的数据结构应该是什么样子有任何想法吗？如果没有，让我们看一下以下图表，其中描述了一个带有关于其特定元素的标题的树：
- en: '![](img/7c15bf17-435a-40a2-a6ab-3b2768d96d92.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c15bf17-435a-40a2-a6ab-3b2768d96d92.png)'
- en: A tree consists of multiple **nodes**, including one **root** (**100** in the
    diagram). The root does not contain a **parent** node, while all other nodes do.
    For example, the parent element of node **1** is **100**, while node **96** has
    node **30** as the **parent**. Moreover, each node can have any number of **child**
    nodes, such as three **children** (that is, **50**, **1**, and **150**) in the
    case of the **root**. The child nodes of the same node can be named **siblings**,
    as in the case of nodes **70** and **61**. A node without children is named a **leaf**,
    such as **45** and **6** in the diagram. Take a look at the rectangle with three
    nodes (that is, **30**, **96**, and **9**). Such a part of the tree can be called
    a **subtree**. Of course, you can find many subtrees in the tree.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 树由多个**节点**组成，包括一个**根**（图表中的**100**）。根不包含**父**节点，而所有其他节点都包含。例如，节点**1**的父元素是**100**，而节点**96**的父元素是**30**。此外，每个节点可以有任意数量的**子**节点，例如**根**的情况下有三个**子**节点（即**50**、**1**和**150**）。同一节点的子节点可以被称为**兄弟**，就像节点**70**和**61**的情况一样。没有子节点的节点称为**叶子**，例如图表中的**45**和**6**。看一下包含三个节点（即**30**、**96**和**9**）的矩形。树的这一部分可以称为**子树**。当然，您可以在树中找到许多子树。
- en: Let's briefly talk about the minimum and maximum numbers of children of a node.
    In general, such numbers are not limited and each node can contain zero, one,
    two, three, or even more children. However, in practical applications, the number
    of children is often limited to two, as you will see in the following section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论节点的最小和最大子节点数。一般来说，这些数字是没有限制的，每个节点可以包含零、一个、两个、三个，甚至更多的子节点。然而，在实际应用中，子节点的数量通常限制为两个，正如您将在以下部分中看到的。
- en: Implementation
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: The C#-based implementation of a basic tree seems to be quite obvious and not
    complicated. To do so, you can declare two classes, representing a single node
    and a whole tree, as described in the following section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 基本树的C#实现似乎是相当明显和不复杂的。为此，您可以声明两个类，表示单个节点和整个树，如下一节所述。
- en: Node
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点
- en: 'The first class is named `TreeNode` and is declared as the generic class to
    provide a developer with the ability to specify the type of data stored in each
    node. Thus, you can create the strongly-typed solution, which eliminates the necessity
    of casting objects to target types. The code is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个类名为`TreeNode`，声明为通用类，以便为开发人员提供指定存储在每个节点中的数据类型的能力。因此，您可以创建强类型化的解决方案，从而消除了将对象转换为目标类型的必要性。代码如下：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The class contains three properties: the data stored in the node (`Data`) of
    the type (`T`) specified while creating an instance of the class, a reference
    to the parent node (`Parent`), and a collection of references to child nodes (`Children`).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含三个属性：节点中存储的数据（`Data`）是在创建类的实例时指定的类型（`T`）的引用，指向父节点（`Parent`）的引用，以及指向子节点（`Children`）的引用的集合。
- en: Apart from the properties, the `TreeNode` class contains the `GetHeight` method,
    which returns a height of the node, that is, the distance to the root node. The
    implementation of this method is very simple, because it just uses the `while`
    loop to go up from the node until there is no parent element (when the root is
    reached).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了属性之外，“TreeNode”类还包含“GetHeight”方法，该方法返回节点的高度，即到根节点的距离。该方法的实现非常简单，因为它只是使用“while”循环从节点向上移动，直到没有父元素（达到根时）。
- en: Tree
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树
- en: 'The next necessary class is named `Tree`, and it represents the whole tree.
    Its code is even simpler than that presented in the preceding section, and is
    as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个必要的类名为`Tree`，它代表整个树。它的代码甚至比前一节中呈现的更简单，如下所示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The class contains only one property, `Root`. You can use this property to get
    access to the root node, and then you can use its `Children` property to obtain
    data of other nodes located in the tree.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该类只包含一个属性，`Root`。您可以使用此属性访问根节点，然后可以使用其`Children`属性获取树中其他节点的数据。
- en: It is worth noting that both `TreeNode` and `Tree` classes are generic and the
    same type is used in the case of these classes. For instance, if tree nodes should
    store `string` values, the `string` type should be used in the case of instances
    of `Tree` and `TreeNode` classes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`TreeNode`和`Tree`类都是泛型的，这些类使用相同的类型。例如，如果树节点应存储`string`值，则在`Tree`和`TreeNode`类的实例中应使用`string`类型。
- en: Example – hierarchy of identifiers
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 标识符的层次结构
- en: Do you want to see how to use a tree in a C#-based application? Let's take a
    look at the first example. The aim is to construct the tree with a few nodes,
    as shown in the following diagram. Only the group of nodes with darker backgrounds
    will be presented in the code. However, it is a good idea to adjust the code to
    extend this tree by yourself.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您想看看如何在基于C#的应用程序中使用树吗？让我们看看第一个示例。目标是构建具有几个节点的树，如下图所示。只有深色背景的节点组将在代码中呈现。但是，调整代码以自行扩展此树是一个好主意。
- en: '![](img/6afd0e1c-87c6-4057-a278-d08277502586.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6afd0e1c-87c6-4057-a278-d08277502586.png)'
- en: 'As you can see in the example, each node stores an integer value. Thus, `int`
    will be the type used for both `Tree` and `TreeNode` classes. The following part
    of code should be placed in the `Main` method in the `Program` class:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在示例中看到的那样，每个节点都存储一个整数值。因此，`int`将是`Tree`和`TreeNode`类都使用的类型。以下代码的一部分应放在`Program`类的`Main`方法中：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code looks quite simple, doesn't it?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来相当简单，不是吗？
- en: At the beginning, a new instance of the `Tree` class is created. Then, the root
    node is configured by creating a new instance of the `TreeNode` class, setting
    a value of the `Data` property (to `100`), and assigning a reference to the `TreeNode`
    instance to the `Root` property.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建`Tree`类的新实例。然后，通过创建`TreeNode`类的新实例，设置`Data`属性的值（为`100`），并将对`TreeNode`实例的引用分配给`Root`属性来配置根节点。
- en: In the following lines, the child nodes of the root node are specified—nodes
    with values equal to `50`, `1`, and `150`. For each of them, a value of the `Parent`
    property is set to a reference to the previously-added root node.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几行中，指定了根节点的子节点，其值分别为`50`，`1`和`150`。对于每个节点，`Parent`属性的值都设置为对先前添加的根节点的引用。
- en: The remaining part of the code shows how to add a child node for a given node,
    namely for the third child of the root node, that is, the node with value equal
    to `150`. Here, only one node is added, the one with the value set to `30`. Of
    course, you need to specify a reference to the parent node as well.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分显示了如何为给定节点添加子节点，即根节点的第三个子节点，即值等于`150`的节点。在这里，只添加了一个节点，其值设置为`30`。当然，您还需要指定对父节点的引用。
- en: That's all! You have created the first program that uses trees. Now you can
    run it, but you will not see any output in the console. If you want to see how
    data of nodes are organized, you can debug the program and see values of variables
    while debugging.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！您已经创建了使用树的第一个程序。现在可以运行它，但您在控制台中看不到任何输出。如果要查看节点数据是如何组织的，可以调试程序并在调试时查看变量的值。
- en: Example – company structure
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 公司结构
- en: 'In the previous example, you saw how to use integer values as data for each
    node in a tree. However, it is also possible to store instances of user-defined
    classes in nodes. In this example, you will see how to create a tree presenting
    the structure of a company, divided into three main departments: development,
    research, and sales.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您看到如何将整数值用作树中每个节点的数据。但是，还可以将用户定义的类的实例存储在节点中。在此示例中，您将看到如何创建一个树，展示公司的结构，分为三个主要部门：开发、研究和销售。
- en: Within each department there can be another structure, such as in the case of
    the development team. Here, **John Smith** is **Head of Development**. He is a
    boss for **Chris Morris**, who is a manager for two junior developers, **Eric
    Green** and **Ashley Lopez**. The latter is also a supervisor of **Emily Young**,
    who is a **Developer Intern**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个部门中都可以有另一个结构，例如开发团队的情况。在这里，**John Smith**是**开发部门主管**。他是**Chris Morris**的上司，后者是两名初级开发人员**Eric
    Green**和**Ashley Lopez**的经理。后者还是**Emily Young**的主管，后者是**开发实习生**。
- en: 'An example tree is shown in the following diagram:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例树的示意图：
- en: '![](img/d22420a3-eabe-4864-abeb-a7c8eeb5b16b.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d22420a3-eabe-4864-abeb-a7c8eeb5b16b.png)'
- en: 'As you can see, each node should store more information than just an integer
    value. There should be an identifier, a name, and a role. Such data are stored
    as values of properties in an instance of the `Person` class, as shown in the
    following code snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，每个节点应存储的信息不仅仅是一个整数值。应该有一个标识符、一个名称和一个角色。这些数据存储为`Person`类实例的属性值，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The class contains three properties ( `Id`, `Name`, and `Role`), as well as
    two constructors. The first constructor does not take any parameters, while the
    other takes three and sets values of particular properties.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含三个属性（`Id`，`Name`和`Role`），以及两个构造函数。第一个构造函数不带任何参数，而另一个带有三个参数，并设置特定属性的值。
- en: 'Apart from creating a new class, it is also necessary to add some code in the
    `Main` method in the `Program` class. The necessary lines are as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建一个新类之外，还需要在`Program`类的`Main`方法中添加一些代码。必要的行如下：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the first line, a new instance of the `Tree` class is created. It is worth
    mentioning that the `Person` class is used as a type specified while creating
    new instances of `Tree` and `TreeNode` classes. Thus, you can easily store more
    than one simple data for each node.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，创建了`Tree`类的一个新实例。值得一提的是，在创建`Tree`和`TreeNode`类的新实例时，使用了`Person`类作为指定类型。因此，你可以轻松地为每个节点存储多个简单数据。
- en: The remaining lines of code look similar to the first example for basic trees.
    Here, you also specify the root node (for the `CEO` role), then configure its
    child elements (`John Smith`, `Mary Fox`, and `Lily Smith`), and set a child node
    for one of the existing nodes, namely the node for the `Head of Sales`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分看起来与基本树的第一个示例相似。在这里，你还指定了根节点（`CEO`角色），然后配置了它的子元素（`John Smith`，`Mary Fox`和`Lily
    Smith`），并为现有节点之一设置了一个子节点，即`Head of Sales`的节点。
- en: 'Does it look simple and straightforward? In the next section, you will see
    a more restricted, but very important and well-known, variant of trees: the binary
    tree.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来简单明了吗？在下一节中，你将看到一种更受限制但非常重要和著名的树的变体：二叉树。
- en: Binary trees
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉树
- en: 'Generally speaking, each node in a basic tree can contain any number of children.
    However, in the case of **binary trees**, a node cannot contain more than two
    children. It means that it can contain zero, one, or two child nodes. Such a requirement
    has an important impact on the shape of a binary tree, as shown in the following
    two diagrams presenting binary trees:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，基本树中的每个节点可以包含任意数量的子节点。然而，在**二叉树**的情况下，一个节点不能包含超过两个子节点。这意味着它可以包含零个、一个或两个子节点。这一要求对二叉树的形状有重要影响，如下图所示展示了二叉树：
- en: '![](img/97d1ae70-d6ba-4cba-bddc-beef55c0cba2.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97d1ae70-d6ba-4cba-bddc-beef55c0cba2.png)'
- en: As already mentioned, a node in a binary tree can contain at most two children.
    For this reason, they are referred to as the **left child** and **right child**.
    In the case of the binary tree shown on the left-hand side of the preceding diagram,
    node **21** has two children, **68** as the left child and **12** as the right
    child, while node **100** has only a left child.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，二叉树中的节点最多可以包含两个子节点。因此，它们被称为**左子节点**和**右子节点**。在前面图中左侧显示的二叉树中，节点**21**有两个子节点，**68**为左子节点，**12**为右子节点，而节点**100**只有一个左子节点。
- en: 'Have you thought about how you can iterate through all the nodes in a tree?
    How can you specify an order of nodes during **traversal** of a tree? There are
    three common approaches: pre-order, in-order, and post-order, as shown in the
    following diagram:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有想过如何遍历树中的所有节点？在树的遍历过程中，你如何指定节点的顺序？有三种常见的方法：前序遍历、中序遍历和后序遍历，如下图所示：
- en: '![](img/6203e8c5-d23c-41ca-b4ec-f7addeb54a82.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6203e8c5-d23c-41ca-b4ec-f7addeb54a82.png)'
- en: As you can see in the diagram, there are clearly visible differences between
    the approaches. However, do you have any idea how you can apply pre-order, in-order,
    or post-order traversals for binary trees? Let's explain all of these approaches
    in detail.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在图中所看到的，这些方法之间存在明显的差异。然而，你有没有想过如何在二叉树中应用前序遍历、中序遍历或后序遍历？让我们详细解释所有这些方法。
- en: If you want to traverse a binary tree with the **pre-order** approach, you first
    need to visit the root node. Then, you visit the left child. Finally, the right
    child is visited. Of course, such a rule does not apply only to the root node,
    but to any node within a tree. For this reason, you can understand the order of
    pre-order traversal as first visiting the current node, then its left child (the
    whole left subtree using the pre-order approach recursively), and finally its
    right child (the right subtree in a similar way).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用**前序遍历**方法遍历二叉树，首先需要访问根节点。然后，访问左子节点。最后，访问右子节点。当然，这样的规则不仅适用于根节点，而且适用于树中的任何节点。因此，你可以理解前序遍历的顺序为首先访问当前节点，然后访问它的左子节点（使用前序遍历递归地遍历整个左子树），最后访问它的右子节点（以类似的方式遍历右子树）。
- en: The explanation can sound a bit complicated, so let's take a look at the simple
    example regarding the tree shown on the left of the preceding diagram. First,
    the root node (that is, **1**) is visited. Then, you analyze its left child node.
    For this reason, the next visited node is the current node, **9**. The next step
    is the pre-order traversal of its left child. Thus, **5** is visited. As this
    node does not contain any children, you can return to the stage of traversing
    when **9** is the current node. It has already been visited, as has its left child
    node, so it is time to proceed to its right child. Here, you first visit the current
    node, **6**, and follow to its left child, **3**. You can apply the same rules
    to continue traversing the tree. The final order is **1**, **9**, **5**, **6**,
    **3**, **4**, **2**, **7**, **8**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 解释可能听起来有点复杂，所以让我们看一个简单的例子，关于前面图中左侧显示的树。首先，访问根节点（即**1**）。然后，分析它的左子节点。因此，下一个访问的节点是当前节点**9**。下一步是它的左子节点的前序遍历。因此，访问**5**。由于这个节点不包含任何子节点，你可以返回到遍历时**9**是当前节点的阶段。它已经被访问过，它的左子节点也是，所以现在是时候继续到它的右子节点。在这里，首先访问当前节点**6**，然后转到它的左子节点**3**。你可以应用相同的规则来继续遍历树。最终的顺序是**1**，**9**，**5**，**6**，**3**，**4**，**2**，**7**，**8**。
- en: 'If it still sounds a bit confusing, the following diagram should remove any
    confusions:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来有点令人困惑，下图应该消除任何困惑：
- en: '![](img/7b456784-0ec6-474b-9b66-0f372d545dfb.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b456784-0ec6-474b-9b66-0f372d545dfb.png)'
- en: The diagram presents the following steps of the pre-order traversal with additional
    indicators: **C** for the **current node**, **L** for the **left child**, and
    **R** for the **right child**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 该图展示了前序遍历的以下步骤，并附有额外的指示：**C**表示**当前节点**，**L**表示**左子节点**，**R**表示**右子节点**。
- en: 'The second traversal mode is called **in-order**. It differs from the pre-order
    approach in the order that nodes are visited in: first the left child, then the
    current node, and then the right child. If you take a look at the example shown
    in the diagram with all three traversal modes, you can see that the first visited
    node is **5**. Why? At the beginning, the root node is analyzed, but it is not
    visited, because the in-order traversal starts with the left child node. Thus,
    it analyzes node **9**, but it also has a left child, **5**, so you proceed to
    this node. As this node does not have any children, the current node (**5**) is
    visited. Then, you return to the step when the current node is **9** and—as its
    left child has been already visited—you visit also the current node. Next, you
    follow to the right child, but it has a left child, **3**, which should be visited
    first. According to the same rules, you visit the remaining nodes in the binary
    tree. The final order is **5**, **9**, **3**, **6**, **1**, **4**, **7**, **8**, **2**.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个遍历模式称为**中序遍历**。它与前序遍历方法的区别在于节点访问的顺序：首先是左子节点，然后是当前节点，然后是右子节点。如果您看一下图表中显示的具有所有三种遍历模式的示例，您会发现第一个访问的节点是**5**。为什么？开始时，分析根节点，但不访问，因为中序遍历从左子节点开始。因此，它分析节点**9**，但它也有一个左子节点**5**，所以您继续到这个节点。由于此节点没有任何子节点，因此访问当前节点（**5**）。然后，返回到当前节点为**9**的步骤，并且
    - 由于其左子节点已经被访问 - 您还访问当前节点。接下来，您转到右子节点，但它有一个左子节点**3**，应该先访问。根据相同的规则，您访问二叉树中的剩余节点。最终顺序是**5**，**9**，**3**，**6**，**1**，**4**，**7**，**8**，**2**。
- en: 'The last traversal mode is named **post-order** and supports the following
    order of node traversal: the left child, the right child, then the current node.
    Let''s analyze the post-order example shown on the right side of the diagram.
    At the beginning, the root node is analyzed, but it is not visited, because the
    post-order traversal starts with the left child node. Thus—as in the case of the
    in-order approach—you proceed to node **9**, then **5**. Then, you need to analyze
    the right child of node **9**. However, node **6** has the left child (**3**),
    which should be visited first. For this reason, after **5**, you visit **3**,
    and then **6**, followed by **9**. What is interesting is that the root node of
    the binary tree is visited at the end. The final order is **5**, **3**, **6**,
    **9**, **8**, **7**, **2**, **4**, **1**.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的遍历模式称为**后序遍历**，支持以下节点遍历顺序：左子节点，右子节点，然后是当前节点。让我们分析图表右侧显示的后序遍历示例。开始时，分析根节点，但不访问，因为后序遍历从左子节点开始。因此
    - 与中序遍历方法一样 - 继续到节点**9**，然后**5**。然后，需要分析节点**9**的右子节点。然而，节点**6**有左子节点（**3**），应该先访问。因此，在**5**之后，访问**3**，然后**6**，然后是**9**。有趣的是，二叉树的根节点在最后访问。最终顺序是**5**，**3**，**6**，**9**，**8**，**7**，**2**，**4**，**1**。
- en: You can find more information about binary trees at [https://en.wikipedia.org/wiki/Binary_tree](https://en.wikipedia.org/wiki/Binary_tree).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://en.wikipedia.org/wiki/Binary_tree](https://en.wikipedia.org/wiki/Binary_tree)找到有关二叉树的更多信息。
- en: After this short introduction, let's proceed to the C#-based implementation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的介绍之后，让我们继续进行基于C#的实现。
- en: Implementation
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: The implementation of a binary tree is really simple, especially if you use
    the already-described code for the basic tree. For your convenience, the whole
    necessary code is placed in the following sections, but only its new parts are
    explained in detail.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树的实现真的很简单，特别是如果您使用了已经描述的基本树的代码。为了您的方便，整个必要的代码都放在了以下部分，但只有它的新部分被详细解释。
- en: Node
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点
- en: 'A node in a binary tree is represented by an instance of `BinaryTreeNode`,
    which inherits from the `TreeNode` generic class with the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树中的节点由`BinaryTreeNode`的实例表示，它继承自`TreeNode`泛型类，具有以下代码：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `BinaryTreeNode` class, it is necessary to declare two properties, `Left`
    and `Right`, which represent both possible children of a node. The relevant part
    of code is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BinaryTreeNode`类中，需要声明两个属性`Left`和`Right`，它们分别表示节点的两个可能的子节点。代码的相关部分如下：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Moreover, you need to ensure that the collection of child nodes contains exactly
    two items, initially set to `null`. You can achieve this goal by assigning a default
    value to the `Children` property in the constructor, as shown in the preceding
    code. Thus, if you want to add a child node, a reference to it should be placed
    as the first or the second element of the list (the `Children` property). Therefore,
    such a collection always has exactly two elements and you can access the first
    or the second element without any exception. If it is set to any node, a reference
    to it is returned, otherwise `null` is returned.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您需要确保子节点的集合包含确切两个项目，最初设置为`null`。您可以通过在构造函数中为`Children`属性分配默认值来实现此目标，如前面的代码所示。因此，如果要添加子节点，应将对其的引用放置为列表（`Children`属性）的第一个或第二个元素。因此，这样的集合始终具有确切两个元素，并且可以访问第一个或第二个元素而不会出现任何异常。如果它设置为任何节点，则返回对其的引用，否则返回`null`。
- en: Tree
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树
- en: 'The next necessary class is named `BinaryTree`. It represents the whole binary
    tree. By using the generic class, you can easily specify a type of data stored
    in each node. The first part of the implementation of the `BinaryTree` class is
    as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个必要的类名为`BinaryTree`。它表示整个二叉树。通过使用泛型类，您可以轻松指定存储在每个节点中的数据类型。`BinaryTree`类的实现的第一部分如下：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `BinaryTree` class contains two properties: `Root`, which indicates the
    root node (as an instance of the `BinaryTreeNode` class), as well as `Count`,
    which has the total number of nodes placed in the tree. Of course, these are not
    the only members of the class, because it can also be equipped with a set of methods
    regarding traversing the tree.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinaryTree`类包含两个属性：`Root`，表示根节点（作为`BinaryTreeNode`类的实例），以及`Count`，表示树中放置的节点的总数。当然，这些不是类的唯一成员，因为它还可以配备一组关于遍历树的方法。'
- en: 'The first traversal method, described in this book, is pre-order. As a reminder,
    it first visits the current node, then its left child, followed by the right child.
    The code of the `TraversePreOrder` method is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的第一个遍历方法是先序遍历。作为提醒，它首先访问当前节点，然后是其左子节点，最后是右子节点。`TraversePreOrder`方法的代码如下：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The method takes two parameters: the current node (`node`) and the list of
    already-visited nodes (`result`). The recursive implementation is very simple.
    First, you check whether the node exists by ensuring that the parameter is not
    equal to `null`. Then, you add the current node to the collection of visited nodes,
    start the same traversal method for the left child, and—at the end—start it for
    the right child.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受两个参数：当前节点（`node`）和已访问节点的列表（`result`）。递归实现非常简单。首先，通过确保参数不等于`null`来检查节点是否存在。然后，将当前节点添加到已访问节点的集合中，开始对左子节点执行相同的遍历方法，最后对右子节点执行相同的遍历方法。
- en: 'Similar implementation is possible for the in-order and post-order traversal
    modes. Let''s start with the code of the `TraverseInOrder` method, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的实现也适用于中序和后序遍历模式。让我们从`TraverseInOrder`方法的代码开始：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, you recursively call the `TraverseInOrder` method for the left child,
    add the current node to the list of visited nodes, and start the in-order traversal
    for the right child.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您递归调用`TraverseInOrder`方法来处理左子节点，将当前节点添加到已访问节点的列表中，并开始对右子节点进行中序遍历。
- en: 'The next method is related to the post-order traversal mode, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法与后序遍历模式有关，如下所示：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code is very similar to the already-described methods, but, of course, another
    order of visiting nodes is applied. Here, you start with the left child, then
    you visit the right child, followed by the current node.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码与已描述的方法非常相似，但是应用了另一种访问节点的顺序。在这里，您首先访问左子节点，然后访问右子节点，最后访问当前节点。
- en: 'Finally, let''s add the public method for traversing the tree in various modes,
    which calls private methods presented earlier. The relevant code is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加用于以各种模式遍历树的公共方法，该方法调用先前介绍的私有方法。相关代码如下：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The method takes only one parameter, a value of the `TraversalEnum` enumeration,
    which chooses the proper mode from pre-order, in-order, and post-order. The `Traverse`
    method uses the `switch` statement to call a suitable private method, depending
    on a value of the parameter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法只接受一个参数，即`TraversalEnum`枚举的值，选择适当的先序、中序和后序模式。`Traverse`方法使用`switch`语句根据参数的值调用适当的私有方法。
- en: 'For using the `Traverse` method, it is also necessary to declare the `TraversalEnum`
    enumeration, as shown in the following code snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`Traverse`方法，还需要声明`TraversalEnum`枚举，如下所示：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The last method described in this section is `GetHeight`. It returns the height
    of the tree, which can be understood as the maximum number of steps to travel
    from any leaf node to the root. The implementation is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中描述的最后一个方法是`GetHeight`。它返回树的高度，可以理解为从任何叶节点到根节点所需的最大步数。实现如下：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code just iterates through all nodes of the tree using the pre-order traversal,
    reads the height for the current node (using the `GetHeight` method from the `TreeNode`
    class, described earlier), and saves it as the maximum one, if it is larger than
    the current maximum value. At the end, the calculated height is returned.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码只是使用先序遍历遍历树的所有节点，读取当前节点的高度（使用先前描述的`TreeNode`类的`GetHeight`方法），如果大于当前最大值，则将其保存为最大值。最后返回计算出的高度。
- en: After the introduction to the topic of binary trees, let's see an example where
    this data structure is used for storing questions and answers in a simple quiz.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了二叉树的主题之后，让我们看一个示例，其中使用这种数据结构来存储简单测验中的问题和答案。
- en: Example – simple quiz
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 简单的测验
- en: As an example of a binary tree, a simple quiz application will be used. The
    quiz consists of a few questions and answers, shown depending on the previously-taken
    decisions. The application presents the question, waits until the user presses
    *Y* (yes) or *N* (no), and proceeds to the next question or shows the answer.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 作为二叉树的一个示例，将使用一个简单的测验应用程序。测验由几个问题和答案组成，根据先前做出的决定显示。应用程序呈现问题，等待用户按下*Y*（是）或*N*（否），然后继续下一个问题或显示答案。
- en: 'The structure of the quiz is created in the form of a binary tree, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 测验的结构以二叉树的形式创建，如下所示：
- en: '![](img/2679026d-3aac-4d4d-8868-2b46f7dfbe2f.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2679026d-3aac-4d4d-8868-2b46f7dfbe2f.png)'
- en: At the beginning, the user is asked whether he or she has any experience in
    application development. If so, the program asks whether he or she has worked
    as a developer for more than five years. In the case of a positive answer, the
    result regarding applying to work as a senior developer is presented. Of course,
    other answers and questions are shown in the case of different decisions taken
    by the user.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，用户被问及是否有应用程序开发经验。如果是，程序会询问他或她是否已经作为开发人员工作了五年以上。在肯定答案的情况下，将呈现关于申请成为高级开发人员的结果。当然，在用户做出不同决定的情况下，还会显示其他答案和问题。
- en: 'The implementation of the simple quiz requires the `BinaryTree` and `BinaryTreeNode`
    classes, which were presented and explained earlier. Apart from them, you should
    declare the `QuizItem` class to represent a single item, such as a question or
    an answer. Each item contains only the textual content, stored as a value of the
    `Text` property. The proper implementation is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 简单测验的实现需要`BinaryTree`和`BinaryTreeNode`类，这些类在先前已经介绍和解释过。除此之外，还应该声明`QuizItem`类来表示单个项目，例如问题或答案。每个项目只包含文本内容，存储为`Text`属性的值。适当的实现如下：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Some modifications are necessary in the `Program` class. Let''s take a look
    at the modified `Main` method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Program`类中需要进行一些修改。让我们来看一下修改后的`Main`方法：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the first line within the method, the `GetTree` method (shown in the following
    code snippet) is called to construct the tree with questions and answers. Then,
    the root node is taken as the current node, for which the following operations
    are taken until the answer is reached.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法中的第一行，调用`GetTree`方法（如下面的代码片段所示）来构建具有问题和答案的树。然后，将根节点作为当前节点，直到到达答案为止。
- en: At the beginning, you check whether the left or right child node exists, that
    is, whether it is a question (not an answer). Then, the textual content is written
    in the console and the program waits until the user presses a key. If it is equal
    to *Y*, the information about choosing the *yes* option is shown and the current
    node's left child is used as the current node. Similar operations are performed
    in the case of choosing *no*, but then the current node's right child is used
    instead.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查左侧或右侧子节点是否存在，即是否为问题（而不是答案）。然后，在控制台中写入文本内容，并等待用户按键。如果等于*Y*，则显示有关选择*是*选项的信息，并使用当前节点的左子节点作为当前节点。在选择*否*的情况下执行类似的操作，但然后使用当前节点的右子节点。
- en: When decisions taken by the user cause the answer to be shown, it is presented
    in the console and `null` is assigned to the `node` variable. Therefore, you break
    out of the `while` loop.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户做出的决定导致答案显示时，它会在控制台中呈现，并将`null`赋给`node`变量。因此，您会跳出`while`循环。
- en: 'As mentioned, the `GetTree` method is used to construct the binary tree with
    questions and answers. Its code is presented as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`GetTree`方法用于构建具有问题和答案的二叉树。其代码如下所示：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At the beginning, a new instance of the `BinaryTree` generic class is created.
    It is also configured that each node contains data as an instance of the `QuizItem`
    class. Then, you assign a new instance of the `BinaryTreeNode` to the `Root` property.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建`BinaryTree`泛型类的新实例。还配置每个节点包含`QuizItem`类的实例的数据。然后，将`Root`属性分配给`BinaryTreeNode`的新实例。
- en: What is interesting is that even while creating questions and answers programmatically,
    you create some kind of tree-like structure, because you use the `Children` property
    and specify items directly within such constructions. Therefore, you do not need
    to create many local variables for all questions and answers. It is worth noting
    that a question-related node is an instance of the `BinaryTreeNode` class with
    two child nodes (for  *yes* and *no* decisions), while an answer-related node
    cannot contain any child nodes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，即使在以编程方式创建问题和答案时，您也会创建某种类似树的结构，因为您使用`Children`属性并直接在这些结构中指定项目。因此，您无需为所有问题和答案创建许多本地变量。值得注意的是，与问题相关的节点是`BinaryTreeNode`类的实例，具有两个子节点（用于*是*和*否*决定），而与答案相关的节点不能包含任何子节点。
- en: In the presented solution, the values of the `Parent` property of the `BinaryTreeNode`
    instances are not set. If you want to use them or get the height of a node or
    a tree, you should set them on your own.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在所提供的解决方案中，`BinaryTreeNode`实例的`Parent`属性的值未设置。如果要使用它们或获取节点或树的高度，则应自行设置它们。
- en: 'The last auxiliary method is `WriteAnswer`, with the code being as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个辅助方法是`WriteAnswer`，代码如下：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The method just presents the text, passed as the parameter, in the white color
    in the console. It is used to show decisions taken by the user and the textual
    content of the answer.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法只是在控制台中以白色显示传递的文本参数。它用于显示用户做出的决定和答案的文本内容。
- en: The simple quiz application is ready! You can build the project, launch it,
    and answer a few questions to see the results. Then, let's close the program and
    proceed to the next section, where a variant of the binary tree data structure
    is presented.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的测验应用程序已准备就绪！您可以构建项目，启动它，并回答一些问题以查看结果。然后，让我们关闭程序并继续到下一部分，介绍二叉树数据结构的变体。
- en: Binary search trees
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: 'A binary tree is an interesting data structure that allows creating a hierarchy
    of elements, with the restriction that each node can contain at most two children,
    but without any rules about relationships between the nodes. For this reason,
    if you want to check whether the binary tree contains a given value, you need
    to check each node, traversing the tree using one of three available modes: pre-order,
    in-order, or post-order. This means that the lookup time is linear, namely *O(n)*.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树是一种有趣的数据结构，允许创建元素的层次结构，每个节点最多可以包含两个子节点，但没有关于节点之间关系的任何规则。因此，如果要检查二叉树是否包含给定值，需要检查每个节点，使用三种可用模式之一遍历树：前序，中序或后序。这意味着查找时间是线性的，即*O(n)*。
- en: What about a situation where there are some precise rules regarding relations
    between nodes in the tree? Let's imagine a scenario where you know that the left
    subtree contains nodes with values smaller than the root's value, while the right
    subtree contains nodes with values greater than the root's value. Then, you can
    compare the searched value with the current node and decide whether you should
    continue searching in the left or right subtree. Such an approach can significantly
    limit the number of operations necessary to check whether the tree contains a
    given value. It seems quite interesting, doesn't it?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果树中存在一些关于节点关系的明确规则呢？假设有这样一种情况，左子树包含小于根值的节点，而右子树包含大于根值的节点。然后，您可以将搜索值与当前节点进行比较，并决定是否应继续在左侧或右侧子树中搜索。这种方法可以显著限制检查树是否包含给定值所需的操作数量。这似乎很有趣，不是吗？
- en: 'This approach is applied in the **binary search tree** data structure, which
    is also referred to as **BST**. It is a kind of a binary tree that introduces
    two strict rules regarding relations between nodes in the tree. The rules states
    that for any node:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法应用于**二叉搜索树**数据结构，也称为**BST**。它是一种二叉树，引入了两个关于树中节点关系的严格规则。规则规定对于任何节点：
- en: Values of all nodes in its left subtree must be smaller than its value
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其左子树中所有节点的值必须小于其值
- en: Values of all nodes in its right subtree must be greater than its value
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其右子树中所有节点的值必须大于其值
- en: In general, a BST can contain two or more elements with the same value. However,
    within this book a simplified version is given, which does not accept more than
    one element with the same value.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，二叉搜索树可以包含两个或更多具有相同值的元素。但是，在本书中给出了一个简化版本，不接受多个具有相同值的元素。
- en: 'How does it look in practice? Let''s take a look at the following diagram of
    BSTs:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上是什么样子？让我们看一下以下二叉搜索树的图表：
- en: '![](img/3cf99bb5-d124-494d-a022-c15038af2e46.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3cf99bb5-d124-494d-a022-c15038af2e46.png)'
- en: The tree shown on the left-hand side contains 12 nodes. Let's check whether
    it complies with the BST rule. You can do so by analyzing each node, except leaf
    nodes, in the tree.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧显示的树包含12个节点。让我们检查它是否符合二叉搜索树的规则。您可以通过分析树中除了叶节点以外的每个节点来进行检查。
- en: Let's start with the root node (with value **50**) that contains four descendant
    nodes in the left subtree (**40**, **30**, **45**, **43**), all smaller than **50**.
    The root node contains seven descendant nodes in the right subtree (**60**, **80**,
    **70**, **65**, **75**, **90**, **100**), all greater than **50**. That means
    that the BST rule is satisfied for the root node. If you want to check the BST
    rule for the node **80**, you will see that the values of all descendant nodes
    in the left subtree (**70**, **65**, **75**) are smaller than **80**, while the
    values in the right subtree (**90**, **100**) are greater than **80**. You should
    perform the same verification for all nodes in the tree. Similarly, you can confirm
    that the BST from the right-hand side of the diagram adheres to the rules.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从根节点（值为**50**）开始，它在左子树中包含四个后代节点（**40**、**30**、**45**、**43**），都小于**50**。根节点在右子树中包含七个后代节点（**60**、**80**、**70**、**65**、**75**、**90**、**100**），都大于**50**。这意味着根节点满足了二叉搜索树的规则。如果您想检查节点**80**的二叉搜索树规则，您会发现左子树中所有后代节点的值（**70**、**65**、**75**）都小于**80**，而右子树中的值（**90**、**100**）都大于**80**。您应该对树中的所有节点执行相同的验证。同样，您可以确认图表右侧的二叉搜索树遵守了规则。
- en: 'However, two such BSTs significantly differ in their topology. Both have the
    same height, but the number of nodes is different—12 and 7\. The one on the left
    seems to be fat, while the other is rather skinny. Which one is better? To answer
    to this question, let''s think about the algorithm of searching a value in the
    tree. As an example, the process of searching for the value **43** is described
    and presented in the following diagram:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这两个二叉搜索树在拓扑结构上有很大的不同。它们的高度相同，但节点的数量不同——12和7。左边的看起来很胖，而另一个则相对瘦。哪一个更好？为了回答这个问题，让我们考虑一下在树中搜索一个值的算法。例如，搜索值**43**的过程在下图中描述和展示：
- en: '![](img/32e6b37f-f619-4268-b1b6-0c81a8af6846.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32e6b37f-f619-4268-b1b6-0c81a8af6846.png)'
- en: At the beginning, you take a value of the root node (that is, **50**) and check
    whether the given value (**43**) is smaller or greater. It is smaller, so you
    proceed to searching in the left subtree. Thus, you compare **43** with **40**.
    This time, the right subtree is chosen, because **43** is greater than **40**.
    Next, **43** is compared with **45** and the left subtree is chosen. Here, you
    compare **43** with **43**. Thus, the given value is found. If you take a look
    at the tree, you will see that only four comparisons are necessary and the impact
    on performance is obvious.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时，您取根节点的值（即**50**）并检查给定的值（**43**）是较小还是较大。它较小，所以您继续在左子树中搜索。因此，您将**43**与**40**进行比较。这次选择右子树，因为**43**大于**40**。接下来，**43**与**45**进行比较，并选择左子树。在这里，您将**43**与**43**进行比较。因此，找到了给定的值。如果您看一下树，您会发现只需要四次比较，对性能的影响是显而易见的。
- en: For this reason, it is clear than the shape of a tree has a great impact on
    the lookup performance. Of course, it is much better to have a fat tree with limited
    height than a skinny tree with bigger height. The performance boost is caused
    by making decisions as to whether searching should be continued in the left or
    right subtree, without the necessity of analyzing values of all nodes. If nodes
    do not have both subtrees, the positive impact on the performance will be limited.
    In the worst case, when each node contains only one child, the search time is
    even linear. However, in the ideal BST, the lookup time is the *O(log n)* operation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，很明显树的形状对查找性能有很大影响。当然，拥有高度有限的胖树要比高度更大的瘦树好得多。性能提升是由于在继续在左子树或右子树中搜索时做出决策，而无需分析所有节点的值。如果节点没有两个子树，对性能的积极影响将受到限制。在最坏的情况下，当每个节点只包含一个子节点时，搜索时间甚至是线性的。然而，在理想的二叉搜索树中，查找时间是*O(log
    n)*操作。
- en: You can find more information about BSTs at [https://en.wikipedia.org/wiki/Binary_search_tree](https://en.wikipedia.org/wiki/Binary_search_tree).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://en.wikipedia.org/wiki/Binary_search_tree](https://en.wikipedia.org/wiki/Binary_search_tree)找到更多关于二叉搜索树的信息。
- en: After this short introduction, let's proceed to the implementation in the C#
    language. At the end, you will see the example that shows how to use this data
    structure in practice.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的介绍之后，让我们继续使用C#语言进行实现。最后，您将看到一个示例，展示了如何在实践中使用这种数据结构。
- en: Implementation
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: The implementation of a BST is more difficult than the previously-described
    variants of trees. For example, it requires you to prepare operations of insertion
    and removal of nodes from a tree, which do not break the rule regarding arrangement
    of elements in the BST. What is more, you need to introduce a mechanism for comparing
    nodes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树的实现比先前描述的树的变体更困难。例如，它要求您准备树中节点的插入和删除操作，这些操作不会违反二叉搜索树中元素排列的规则。此外，您需要引入一个比较节点的机制。
- en: Node
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点
- en: 'Let''s start with the class representing a single node in a tree. Fortunately,
    you can use the implementation of the class already described for the binary tree
    (`BinaryTreeNode`) as a base. The modified code is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从表示树中单个节点的类开始。幸运的是，您可以使用已经描述的二叉树类（`BinaryTreeNode`）的实现作为基础。修改后的代码如下：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As a BST is a variant of a binary tree, each node has a reference to its left
    and right child node (or `null` if it does not exist), as well as to the parent
    node. A node stores also a value of a given type. As you can see in the preceding
    code, two members are added to the `BinaryTreeNode` class, namely the `Parent`
    property (of the `BinaryTreeNode` type) and the `GetHeight` method. They are moved
    and adjusted from the implementation of the `TreeNode` class. Its final code is
    as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于BST是二叉树的一种变体，每个节点都有对其左右子节点（如果不存在则为`null`）以及父节点的引用。节点还存储给定类型的值。正如您在前面的代码中所看到的，`BinaryTreeNode`类添加了两个成员，即`Parent`属性（`BinaryTreeNode`类型）和`GetHeight`方法。它们是从`TreeNode`类的实现中移动和调整的。最终代码如下：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The reason for the modification is to provide a developer with the simple way
    of accessing the parent node for a given node without casting from `TreeNode`
    to `BinaryTreeNode`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 修改的原因是为开发人员提供一种简单的方法，以便在不需要从`TreeNode`到`BinaryTreeNode`进行转换的情况下访问给定节点的父节点。
- en: Tree
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树
- en: 'The whole tree is represented by an instance of the `BinarySearchTree` class,
    which inherits from the `BinaryTree` generic class, as in the following code snippet:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 整个树由`BinarySearchTree`类的实例表示，该类继承自`BinaryTree`泛型类，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It is worth mentioning that a type of data, stored in each node, should be comparable.
    For this reason, it has to implement the `IComparable` interface. Such a requirement
    is necessary because the algorithm needs to know the relationships between values.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，每个节点中存储的数据类型应该是可比较的。因此，它必须实现`IComparable`接口。这种要求是必要的，因为算法需要了解值之间的关系。
- en: Of course, it is not the final version of the implementation of the `BinarySearchTree`
    class. You will see how to add new features, such as lookup, insertion, and removal
    of nodes, in the following sections.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不是`BinarySearchTree`类实现的最终版本。在接下来的部分中，您将看到如何添加新功能，比如查找、插入和删除节点。
- en: Lookup
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找
- en: 'Let''s take a look at the `Contains` method, which checks whether the tree
    contains a node with a given value. Of course, this method takes into account
    the BST rule regarding arrangement of nodes to limit the amount of comparisons.
    The code is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`Contains`方法，它检查树中是否包含具有给定值的节点。当然，此方法考虑了有关节点排列的BST规则，以限制比较的数量。代码如下：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The method takes only one parameter, the value that should be found in the tree.
    Inside the method, the `while` loop exists. Within it, the searched value is compared
    with the value of the current node. If they are equal (the comparison returns
    `0` as the result), the value is found and the `true` Boolean value is returned
    to inform that the search is completed successfully. If the searched value is
    smaller than the value of the current node, the algorithm continues searching
    in the subtree with the left child of the current node as the root. Otherwise,
    the right subtree is used instead.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法只接受一个参数，即应在树中找到的值。在方法内部，存在`while`循环。在其中，将搜索的值与当前节点的值进行比较。如果它们相等（比较返回`0`作为结果），则找到该值，并返回`true`布尔值以通知搜索成功完成。如果搜索的值小于当前节点的值，则算法继续在以当前节点的左子节点为根的子树中搜索。否则，使用右子树。
- en: The `CompareTo` method is provided by implementation of the `IComparable` interface
    from the `System` namespace. Such a method makes it possible to compare values.
    If they are equal, `0` is returned. If the object on which the method is called
    is bigger than the parameter, a value higher than `0` is returned. Otherwise,
    a value lower than `0` is returned.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompareTo`方法由`System`命名空间中的`IComparable`接口的实现提供。这种方法使得比较值成为可能。如果它们相等，则返回`0`。如果调用该方法的对象大于参数，则返回大于`0`的值。否则，返回小于`0`的值。'
- en: The loop is executed until the node is found or there is no suitable child node
    to follow.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 循环执行直到找到节点或没有合适的子节点可以跟随。
- en: Insertion
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入
- en: 'The next necessary operation is insertion of a node into a BST. Such a task
    is a bit more complicated, because you need to find a place for adding a new element
    that will not violate the BST rules. Let''s take a look at the code of the `Add`
    method:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个必要的操作是将节点插入BST。这项任务有点复杂，因为您需要找到一个不会违反BST规则的新元素添加位置。让我们来看一下`Add`方法的代码：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The method takes one parameter, a value that should be added to the tree. Within
    the method, you find a parent element (using the `GetParentForNewNode` auxiliary
    method), where a new node should be added as a child. Then, a new instance of
    the `BinaryTreeNode` class is created and the values of its `Data` and `Parent`
    properties are set.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个参数，即应添加到树中的值。在方法内部，找到应将新节点添加为子节点的父元素（使用`GetParentForNewNode`辅助方法），然后创建`BinaryTreeNode`类的新实例，并设置其`Data`和`Parent`属性的值。
- en: In the following part of the method, you check whether the found parent element
    is equal to `null`. It means that there are no nodes in the tree and the new node
    should be added as the root, which is well visible in the line, where a reference
    to the node is assigned to the `Root` property. The next comparison checks whether
    the value for addition is smaller than the value of the parent node. In such a
    case, the new node should be added as the left child of the parent node. Otherwise,
    the new node is placed as the right child of the parent node. At the end, the
    number of elements stored in the tree is incremented.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法的后续部分，您检查找到的父元素是否等于`null`。这意味着树中没有节点，新节点应该被添加为根节点，这在将节点的引用分配给`Root`属性的行中很明显。下一个比较检查要添加的值是否小于父节点的值。在这种情况下，新节点应该被添加为父节点的左子节点。否则，新节点将被放置为父节点的右子节点。最后，树中存储的元素数量增加。
- en: 'Let''s take a look at the auxiliary method for finding the parent element for
    a new node:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看用于查找新节点的父元素的辅助方法：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method is named `GetParentForNewNode` and takes one parameter, the value
    of the new node. Within this method, you declare two variables representing the
    currently-analyzed node (`current`) and the parent node (`parent`). Such values
    are modified in the `while` loop until the algorithm finds a proper place for
    the new node.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法名为`GetParentForNewNode`，只需要一个参数，即新节点的值。在这个方法中，您声明了两个变量，表示当前分析的节点（`current`）和父节点（`parent`）。这些值在`while`循环中被修改，直到算法找到新节点的合适位置。
- en: In the loop, you store a reference to the current node as the potential parent
    node. Then, the comparisons are performed, as in the case of the previously-described
    code snippet. First, you check whether the value for addition is equal to the
    value of the current node. If so, an exception is thrown, because it is not allowed
    to add more than one element with the same value to the analyzed version of the
    BST. If the value for addition is smaller than the value of the current node,
    the algorithm continues searching for the place for the new node in the left subtree.
    Otherwise, the right subtree of the current node is used. At the end, the value
    of the `parent` variable is returned to indicate the found location for the new
    node.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，您将当前节点的引用存储为潜在的父节点。然后，进行比较，就像在先前描述的代码片段中一样。首先，您检查要添加的值是否等于当前节点的值。如果是，将抛出异常，因为不允许向分析版本的BST中添加多个具有相同值的元素。如果要添加的值小于当前节点的值，则算法继续在左子树中搜索新节点的位置。否则，使用当前节点的右子树。最后，将`parent`变量的值返回以指示找到新节点的位置。
- en: Removal
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除
- en: Now you know how to create a new BST, add some nodes to it, as well as check
    whether a given value already exists in the tree. However, can you also remove
    an item from a tree? Of course! You will learn how to achieve this goal in this
    section.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何创建一个新的BST，向其中添加一些节点，并检查树中是否已经存在给定的值。但是，你也能从树中删除一个项目吗？当然可以！您将在本节中学习如何实现这一目标。
- en: 'The main method regarding removal of a node from the tree is named `Remove`
    and takes only one parameter, the value of the node that should be removed. The
    implementation of the `Remove` method is as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从树中删除节点的主要方法名为`Remove`，只需要一个参数，即应该被删除的节点的值。`Remove`方法的实现如下：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see, the method just calls another method, also named `Remove`.
    The implementation of this method is more complicated and is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，该方法只是调用另一个名为`Remove`的方法。该方法的实现更加复杂，如下所示：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: At the beginning, the method checks whether the current node (the `node` parameter)
    exists. If not, the exception is thrown. Then, the `Remove` method tries to find
    the node to remove. That is achieved by comparing the value of the current node
    with the value for removal and calling the `Remove` method recursively for either
    the left or right subtree of the current node. Such operations are performed in
    the conditional statements with conditions `data.CompareTo(node.Data) < 0` and
    `data.CompareTo(node.Data) > 0`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，该方法检查当前节点（`node`参数）是否存在。如果不存在，则会抛出异常。然后，`Remove`方法尝试找到要删除的节点。通过将当前节点的值与要删除的值进行比较，并递归调用`Remove`方法，尝试在当前节点的左子树或右子树中找到要删除的节点。这些操作在条件语句中执行，条件为`data.CompareTo(node.Data)
    < 0`和`data.CompareTo(node.Data) > 0`。
- en: 'The most interesting operations are performed in the following part of the
    method. Here, you need to handle four scenarios of node removal, namely:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的操作是在方法的以下部分执行的。在这里，您需要处理节点删除的四种情况，即：
- en: Removing a leaf node
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除叶节点
- en: Removing a node with only a left child
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有左子节点的节点
- en: Removing a node with only a right child
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有右子节点的节点
- en: Removing a node with both left and right children
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除具有左右子节点的节点
- en: In the first case, you just update a reference to the deleted node in the parent
    element. Therefore, there will be no reference from the parent node to the deleted
    node and it cannot be reached while traversing the tree.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况中，您只需更新父元素中对被删除节点的引用。因此，父节点到被删除节点的引用将不存在，无法在遍历树时到达。
- en: 'The second case is also simple, because you only need to replace a reference
    to the deleted node (in the parent element) with the node that is a left child
    of the deleted node. This scenario is shown in the following diagram, which presents
    how to remove node **80** with only the left child:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况也很简单，因为您只需要用被删除节点的左子节点替换父元素中对被删除节点的引用。这种情况在下图中显示，演示了如何删除只有左子节点的节点**80**：
- en: '![](img/a8d6e2e8-5b7d-4c51-a014-bcc3cc5a5750.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8d6e2e8-5b7d-4c51-a014-bcc3cc5a5750.png)'
- en: The third case is very similar to the second case. Thus, you just replace a
    reference to the deleted node (in the parent element) with the node that is a
    right child of the deleted node.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种情况与第二种情况非常相似。因此，您只需用被删除节点的右子节点替换对被删除节点（在父元素中）的引用。
- en: 'All those three cases are handled in the code in a similar way, by calling
    the auxiliary method (`ReplaceInParent`). It takes two parameters: the node for
    removal and the node that should replace it in the parent node. For this reason,
    if you want to remove a leaf node, you just pass `null` as the second parameter,
    because you do not want to replace the removed node with anything else. In the
    case of removing a node with only one child, you pass a reference to the left
    or right child. Of course, you also need to decrement the counter storing the
    number of elements located in the tree.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这三种情况都通过调用辅助方法（`ReplaceInParent`）在代码中以类似的方式处理。它接受两个参数：要删除的节点和应该在父节点中替换它的节点。因此，如果要删除叶节点，只需将`null`作为第二个参数传递，因为您不希望用其他任何东西替换已删除的节点。在仅具有一个子节点的情况下，您将传递到左侧或右侧子节点的引用。当然，您还需要递减存储在树中的元素数量的计数器。
- en: 'The related part of code is as follows (it differs for various cases):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的相关部分如下（对于不同情况有所不同）：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Of course, the most complicated scenario is removal of a node with both child
    nodes. In such a case, you find a node with the minimum value in the right subtree
    of the node for removal. Then, you swap the value of the node for removal with
    the value of the found node. Finally, you just need to call the `Remove` method
    recursively for the found node. The relevant part of code is shown in the following
    code snippet:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最复杂的情况是删除具有两个子节点的节点。在这种情况下，您会在要删除的节点的右子树中找到具有最小值的节点。然后，您交换要删除的节点的值与找到的节点的值。最后，您只需要对找到的节点递归调用`Remove`方法。代码的相关部分如下所示：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The important role is performed by the `ReplaceInParent` auxiliary method,
    the code for which is as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的角色由`ReplaceInParent`辅助方法执行，其代码如下：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The method takes two parameters: the node for removal (`node`) and the node
    that should replace it in the parent node (`newNode`). If the node for removal
    is not the root, you check whether it is the left child of the parent. If so,
    a proper reference is updated, that is, the new node is set as the left child
    of the parent node of the node for removal. In a similar way, the method handles
    the scenario when the node for removal is the right child of the parent. If the
    node for removal is the root, the node for replacing is set as the root.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受两个参数：要删除的节点（`node`）和应该在父节点中替换它的节点（`newNode`）。如果要删除的节点不是根，则检查它是否是父节点的左子节点。如果是，则更新适当的引用，也就是将新节点设置为要删除的节点的父节点的左子节点。以类似的方式，该方法处理了要删除的节点是父节点的右子节点的情况。如果要删除的节点是根，则将替换节点设置为根。
- en: At the end, you check whether the new node is not equal to `null`, that is,
    you are not removing a leaf node. In such a case, you set a value of the `Parent`
    property to indicate that the new node should have the same parent as the node
    for removal.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您检查新节点是否不等于`null`，也就是说，您没有删除叶节点。在这种情况下，您将`Parent`属性的值设置为指示新节点应该与要删除的节点具有相同父节点。
- en: 'The last auxiliary method is named `FindMinimumInSubtree` and is as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的辅助方法名为`FindMinimumInSubtree`，代码如下：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The method takes only one parameter, namely the root of the subtree, where the
    minimum value should be found. Within the method, the `while` loop is used to
    get the leftmost element. When there is no left child, the current value of the
    `node` variable is returned.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法只接受一个参数，即应找到最小值的子树的根。在方法内部，使用`while`循环来获取最左边的元素。当没有左子节点时，返回`node`变量的当前值。
- en: The presented implementation of the BST is based on the code shown at [https://en.wikipedia.org/wiki/Binary_search_tree](https://en.wikipedia.org/wiki/Binary_search_tree).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 所呈现的BST实现基于[https://en.wikipedia.org/wiki/Binary_search_tree](https://en.wikipedia.org/wiki/Binary_search_tree)上显示的代码。
- en: 'The code looks quite simple, doesn''t it? However, how does it work in practice?
    Let''s take a look at a diagram depicting the removal of a node with two children:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来相当简单，不是吗？但是，在实践中它是如何工作的呢？让我们看一下图表，描述了删除具有两个子节点的节点的过程：
- en: '![](img/ee7545af-cf87-4982-bbd0-9c8dd810140b.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee7545af-cf87-4982-bbd0-9c8dd810140b.png)'
- en: The diagram shows how to remove the node with **40** as the value. To do so,
    you need to find the successor, that is, the node with the minimum value in the
    right subtree of the node for removal. The successor is node **42**, which replaces
    node **40**.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了如何删除值为**40**的节点。为此，您需要找到继承者，也就是要删除的节点右子树中具有最小值的节点。继承者是节点**42**，它替换了节点**40**。
- en: Example – BST visualization
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-BST可视化
- en: While reading the part regarding the BSTs, you have learned a lot about the
    data structure. As such, it is high time to create an example program to see this
    variant of trees in action. The application will show how to create a BST, add
    some nodes (both manually and using the previously-presented method for insertion),
    remove nodes, traverse the tree, and visualize the tree in the console.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读有关BST的部分时，您已经了解了有关数据结构的很多知识。因此，现在是时候创建一个示例程序，以查看这种树的变体如何运作。该应用程序将展示如何创建BST，手动添加一些节点（使用先前呈现的插入方法），删除节点，遍历树，并在控制台中可视化树。
- en: 'Let''s adjust the code of the `Program` class, as shown in the following block
    of code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调整`Program`类的代码，如下所示：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'At the beginning, a new tree (with nodes storing integer values) is prepared
    by creating a new instance of the `BinarySearchTree` class. It is configured manually
    by adding three nodes, together with indicating proper references for children
    and parent elements. The relevent part of code is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，通过创建`BinarySearchTree`类的新实例来准备一个新树（其中节点存储整数值）。通过手动配置，添加了三个节点，并指示了适当的子节点和父节点元素的引用。代码的相关部分如下：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, you use the `Add` method to add some nodes to the tree, and visualize
    the current state of the tree using the `VisualizeTree` method, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`Add`方法向树中添加一些节点，并使用`VisualizeTree`方法可视化树的当前状态，如下所示：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The next set of operations is related to the removal of various nodes from
    the tree, together with visualization of particular changes. The code is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的一系列操作与从树中删除各种节点以及可视化特定更改相关。代码如下：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At the end, all three traversal modes are presented. The part of code related
    to the pre-order approach is as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，展示了所有三种遍历模式。与前序遍历相关的代码部分如下：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Another interesting task is the development of the visualization of the tree
    in the console. Such a feature is really useful, because it allows a comfortable
    and fast way of observing the tree without the necessity of debugging the application
    in the IDE and expanding the following elements in the tooltip with the current
    values of variables. However, presenting the tree in the console is not a trivial
    task. Fortunately, you do not need to worry about it, because you will learn how
    to implement such a feature in this section.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的任务是在控制台中开发树的可视化。这样的功能非常有用，因为它允许舒适快速地观察树，而无需在IDE中调试应用程序并展开工具提示中的当前变量值。然而，在控制台中呈现树并不是一项简单的任务。幸运的是，您不需要担心，因为您将在本节中学习如何实现这样的功能。
- en: 'First, let''s take a look at the `VisualizeTree` method:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下`VisualizeTree`方法：
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The method takes two parameters: an instance of the `BinarySearchTree` class
    representing the whole tree, and the caption that should be shown above the visualization.
    Within the method, the jagged array (with characters that should be presented
    in the console) is initialized using the `InitializeVisualization` auxiliary method.
    Then, you call the `VisualizeNode` recursive method to fill various parts of the
    jagged array with data regarding particular nodes existing in the tree. At the
    end, the caption and all rows from the buffer (represented by the jagged array)
    are written in the console.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受两个参数：代表整个树的`BinarySearchTree`类的实例，以及应该显示在可视化上方的标题。在方法内部，使用`InitializeVisualization`辅助方法初始化了不规则数组（其中包含应在控制台中显示的字符）。然后，调用`VisualizeNode`递归方法，将不同部分的不规则数组填充为有关树中特定节点的数据。最后，在控制台中写入标题和缓冲区（由不规则数组表示）中的所有行。
- en: 'The next interesting method is `InitializeVisualization`, which creates the
    afore mentioned jagged array, as presented in the following code snippet:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个有趣的方法是`InitializeVisualization`，它创建了前面提到的不规则数组，如下面的代码片段所示：
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The jagged array contains the number of rows equal to the height of the tree
    multiplied by `2` to have space also for lines connecting nodes with parents.
    The number of columns is calculated according to the formula *width* * 2*^(height)*
    - 1, where *width* is the constant value `COLUMN_WIDTH` and *height* is the height
    of the tree. These values can be simpler to understand if you take a look at the
    result in the console:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 不规则数组包含的行数等于树的高度乘以`2`，以便为连接节点与父节点的线留出空间。列数根据公式*宽度* * 2*^(高度)* - 1计算，其中*宽度*是常量值`COLUMN_WIDTH`，*高度*是树的高度。如果您在控制台中查看结果，这些值可能更容易理解：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, the jagged array has 8 elements. Each is an array with 75 elements. Of
    course, you can understand it as a screen buffer with 8 rows and 75 columns.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，不规则数组有8个元素。每个都是一个包含75个元素的数组。当然，您可以将其理解为具有8行和75列的屏幕缓冲区。
- en: 'In the `VisualizeTree` method, `VisualizeNode` is called. Are you interested
    to learn about how it works and how you can present not only the values of nodes,
    but also lines? If so, let''s take a look at its code, which is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在`VisualizeTree`方法中，调用了`VisualizeNode`。您是否有兴趣了解它是如何工作的，以及如何呈现节点的值以及线条？如果是的话，让我们看一下它的代码，如下所示：
- en: '[PRE38]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `VisualizeNode` method takes five parameters: the current node for visualization
    (`node`), the index of a row (`row`), the index of a column (`column`), the jagged
    array as the buffer (`console`), and the width (`width`). Within the method, there
    is a check for whether the current node exists. If it does, the value of the node
    is obtained as the `char` array, the margin is calculated, and the `char` array
    (with character-based representation of the value) is written in the buffer (the
    `console` variable).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`VisualizeNode`方法接受五个参数：用于可视化的当前节点（`node`）、行的索引（`row`）、列的索引（`column`）、作为缓冲区的不规则数组（`console`）和宽度（`width`）。在方法内部，检查当前节点是否存在。如果存在，则获取节点的值作为`char`数组，计算边距，并将`char`数组（表示值的基于字符的表示）写入缓冲区（`console`变量）。'
- en: In the following lines of code, the `VisualizeNode` method is called for left
    and right child nodes of the current node. Of course, you need to adjust the index
    of the row (by adding `2`) and the index of the column (by adding or subtracting
    the calculated value).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码中，为当前节点的左右子节点调用了`VisualizeNode`方法。当然，您需要调整行的索引（加`2`）和列的索引（加或减计算出的值）。
- en: 'At the end, the lines are drawn by calling the `DrawLineLeft` and `DrawLineRight`
    methods. The first is presented in the following code snippet:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过调用`DrawLineLeft`和`DrawLineRight`方法来绘制线条。第一个方法在以下代码片段中呈现：
- en: '[PRE39]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The method also takes five parameters: the current node for which the line
    should be drawn (`node`), the index of a row (`row`), the index of a column (`column`),
    the jagged array as the buffer (`console`), and the delta value calculated in
    the `VisualizeNode` method (`columnDelta`). At the beginning, you check whether
    the current node contains a left child, because only then is it necessary to draw
    the left part of the line. If so, you calculate the start and end indices of columns,
    and fill the proper elements of the jagged array with dashes. At the end, the
    plus sign is added to the jagged array in the place where the drawn line will
    be connected with the right line of another element. Moreover, the Unicode character
    ┌ (`\u250c`) is added on the other side of the line to create a user-friendly
    visualization.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法还接受五个参数：应该绘制线的当前节点（`node`）、行索引（`row`）、列索引（`column`）、作为缓冲区的嵌套数组（`console`）和在`VisualizeNode`方法中计算的增量值（`columnDelta`）。首先，你检查当前节点是否包含左子节点，因为只有在这种情况下才需要绘制线的左部分。如果是这样，你计算列的起始和结束索引，并用破折号填充嵌套数组的适当元素。最后，在绘制的线将与另一个元素的右线连接的地方，加入加号到嵌套数组中。此外，Unicode字符┌（`\u250c`）也被添加到线的另一侧，以创建用户友好的可视化。
- en: 'In almost the same way, you can draw the right line for the current node. Of
    course, you need to adjust the code regarding calculating column start and end
    indices, and change a character used to present changing direction of the line.
    The final version of the code of the `DrawLineRight` method is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎以相同的方式，你可以为当前节点绘制右线。当然，你需要调整代码以计算列的起始和结束索引，并更改用于表示线方向变化的字符。`DrawLineRight`方法的最终代码版本如下：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'That''s all! You have written the whole code necessary to build the project,
    launch the program, and see it in action. Just after launching, you will see the
    first BST, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！你已经编写了构建项目、启动程序并看到它运行所需的全部代码。启动后，你将看到第一个BST，如下所示：
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After adding the next two nodes, `75` and `125`, the BST looks a bit different:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了下一个两个节点`75`和`125`之后，BST看起来有点不同：
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, you perform the insertion operation for the next five elements. These
    operations have a very visible impact on the tree shape, as presented in the console:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你执行下一个五个元素的插入操作。这些操作对树形状有非常明显的影响，如在控制台中呈现的那样：
- en: '[PRE43]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After adding 10 elements, the program shows an impact of removing a particular
    node on the shape of the tree. To start, let''s remove the leaf node with `25`
    as the value:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了10个元素后，程序展示了删除特定节点对树形状的影响。首先，让我们删除值为`25`的叶节点：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, the program checks removing a node with only one child node, namely the
    right one. What is interesting is that the right child also has a right child.
    However, the presented algorithm works properly in such conditions and you receive
    the following result:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，程序检查删除只有一个子节点的节点，即右侧节点。有趣的是右子节点也有一个右子节点。然而，在这种情况下，呈现的算法也能正常工作，你会得到以下结果：
- en: '[PRE45]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The last removal operation is the most complicated one because it requires
    you to remove the node with both children, and it also performs the role of the
    root. In such a case, the leftmost element from the right subtree of the root
    is found and replaces the node for removal, as shown in the final view of the
    tree:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的删除操作是最复杂的，因为它需要你删除具有两个子节点的节点，并且还扮演着根的角色。在这种情况下，找到根的右子树中最左边的元素，并替换要删除的节点，如树的最终视图所示：
- en: '[PRE46]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'One more set of operations left—the traversal of the tree in three different
    modes: pre-order, in-order, and post-order. The application presents the following
    results:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一组操作剩下——以三种不同的方式遍历树：前序、中序和后序。应用程序呈现以下结果：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The created application looks quite impressive, doesn't it? You have created
    not only the implementation of the binary search tree from scratch, but also prepared
    the platform for its visualization in the console. Great job!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的应用程序看起来相当令人印象深刻，不是吗？你不仅从头开始创建了二叉搜索树的实现，还为在控制台中可视化它做好了准备。干得好！
- en: Let's take one more look at the results of the in-order approach. As you can
    see, it gives you the nodes sorted in the ascending order in the case of a binary
    search tree.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再来看看中序遍历方法的结果。正如你所看到的，它会给出二叉搜索树中按升序排序的节点。
- en: However, can you see a potential problem with the created solution? What about
    a scenario where you remove nodes only from the given area of the tree or when
    you insert the already-sorted values? It could mean that the fat tree, with proper
    breadth-depth ratio, could become a skinny one. In the worst case, it could even
    be depicted as a list, where all nodes have only one child. Do you have any idea
    how to solve the problem of unbalanced trees and keep them balanced all the time?
    If not, let's proceed to the next sections, where two variants of self-balancing
    trees are presented.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你能看到创建的解决方案存在潜在问题吗？如果你只从树的给定区域删除节点，或者插入已排序的值，会怎么样？这可能意味着，具有适当宽度深度比的胖树可能变成瘦树。在最坏的情况下，它甚至可能被描述为一个列表，其中所有节点只有一个子节点。你有没有想法如何解决不平衡树的问题，并始终保持它们平衡？如果没有，让我们继续到下一节，介绍两种自平衡树的变体。
- en: AVL trees
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AVL树
- en: In this section, you will get to know one of the variants of **self-balancing
    trees**, which keeps the tree balanced all the time while adding and removing
    nodes. However, why is it so important? As already mentioned, the performance
    of the lookup time depends on the shape of the tree. In the case of improper organization
    of nodes, forming a list, the process of searching for a given value can be the
    *O(n)* operation. With a correctly arranged tree, the performance can be significantly
    improved to *O(log n)*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你将了解一种自平衡树的变体，它在添加和删除节点时始终保持树的平衡。然而，为什么这么重要呢？如前所述，查找时间的性能取决于树的形状。在节点的组织不当形成列表的情况下，查找给定值的过程可能是*O(n)*操作。通过正确排列树，性能可以显著提高到*O(log
    n)*。
- en: 'Do you know that a BST can very easily become an **unbalanced tree**? Let''s
    make a simple test of adding the following nine numbers to the tree, from 1 to
    9\. Then, you will receive the tree with the shape shown in the following diagram
    on the left. However, the same values can be arranged in another way, as a **balanced
    tree**, with significantly better breadth-depth ratio, which is shown on the right:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道BST很容易变成**失衡树**吗？让我们对树添加以下九个数字进行简单测试，从1到9。然后，您将得到左侧图表中显示的形状的树。然而，相同的值可以以另一种方式排列，作为**平衡树**，具有明显更好的宽度深度比，如右侧图表所示：
- en: '![](img/1c2951c6-4cf9-43dd-88e7-a0b612a15078.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c2951c6-4cf9-43dd-88e7-a0b612a15078.png)'
- en: You know what unbalanced and balanced trees are, as well as the aim of self-balancing
    trees—but what is an AVL tree? How does it work? What rules should be taken into
    account while using this data structure?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道什么是失衡和平衡树，以及自平衡树的目的，但AVL树是什么？它是如何工作的？在使用这种数据结构时应该考虑哪些规则？
- en: An AVL tree is a binary search tree with the additional requirement that, for
    each node, the height of its left and right subtrees cannot differ by more than
    one. Of course, that rule must be maintained after adding and removing nodes from
    a tree. The important role is performed by **rotations**, used to fix incorrect
    arrangements of nodes.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: AVL树是具有附加要求的二叉搜索树，对于每个节点，其左右子树的高度不能相差超过一。当然，在向树中添加和删除节点后，必须保持这个规则。**旋转**起着重要作用，用于修复节点的不正确排列。
- en: While talking about the AVL trees, it is also crucial to indicate the performance
    of this data structure. In this case, both average and worst-case scenarios of
    insertion, removal, and lookup are *O(log n)*, so there is significant improvement
    in the worst-case scenarios in comparison with the binary search tree.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论AVL树时，还必须指出这种数据结构的性能。在这种情况下，插入、删除和查找的平均和最坏情况都是*O(log n)*，因此与二叉搜索树相比，在最坏情况下有显着的改进。
- en: You can find more information about AVL trees at [https://en.wikipedia.org/wiki/AVL_tree](https://en.wikipedia.org/wiki/AVL_tree).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://en.wikipedia.org/wiki/AVL_tree](https://en.wikipedia.org/wiki/AVL_tree)找到有关AVL树的更多信息。
- en: After this short introduction, let's proceed to the implementation.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的介绍之后，让我们继续实现。
- en: Implementation
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: The implementation of the AVL trees, including various rotations necessary to
    keep the balanced state of a tree, seems to be quite complicated. Fortunately,
    you do not need to create its implementation from scratch, because you can use
    one of the available NuGet packages, such as **Adjunct**, which will be used for
    creating our example.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: AVL树的实现，包括保持树平衡状态所需的各种旋转，似乎相当复杂。幸运的是，您不需要从头开始创建其实现，因为您可以使用其中一个可用的NuGet包，例如**Adjunct**，它将用于创建我们的示例。
- en: 'More information about the Adjunct library can be found at:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Adjunct库的更多信息可以在以下网址找到：
- en: '[http://adjunct.codeplex.com/](http://adjunct.codeplex.com/)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://adjunct.codeplex.com/](http://adjunct.codeplex.com/)'
- en: '[https://www.nuget.org/packages/adjunct-System.DataStructures.AvlTree/](https://www.nuget.org/packages/adjunct-System.DataStructures.AvlTree/).'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.nuget.org/packages/adjunct-System.DataStructures.AvlTree/](https://www.nuget.org/packages/adjunct-System.DataStructures.AvlTree/)。'
- en: The package provides developers with a few classes that can be used while creating
    C#-based applications. Let's focus on the `AvlTree` generic class, which represents
    an AVL tree. The class is very simple to use, so you do not need to know all internal
    details of the AVL trees and you can easily benefit from its advantages.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 该软件包为开发人员提供了一些类，可用于创建基于C#的应用程序。让我们专注于`AvlTree`泛型类，它代表AVL树。该类非常易于使用，因此您无需了解AVL树的所有内部细节，就可以轻松地从中受益。
- en: For example, the `AvlTree` class is equipped with the `Add` method, which inserts
    a new node in a proper location in the tree. You can easily remove a node using
    the `Remove` method. What is more, you can get the height for a given node by
    calling the `Height` method. It is also possible to get the balance factor for
    a given node, using `GetBalanceFactor`, which is calculated as the difference
    between the height of the left and right subtrees.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`AvlTree`类配备有`Add`方法，该方法在树中的适当位置插入新节点。您可以使用`Remove`方法轻松删除节点。此外，您可以通过调用`Height`方法获取给定节点的高度。还可以使用`GetBalanceFactor`获取给定节点的平衡因子，该平衡因子是左右子树高度之差计算得出的。
- en: Another important class is `AvlTreeNode`. It implements the `IBinaryTreeNode`
    interface and contains four properties representing the height of the node (`Height`),
    references to the left and right nodes (`Left` and `Right`, respectively), as
    well as the value stored in the node (`Value`) with a type specified while creating
    an instance of the class.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的类是`AvlTreeNode`。它实现了`IBinaryTreeNode`接口，并包含四个属性，表示节点的高度（`Height`），左右节点的引用（`Left`和`Right`），以及节点中存储的值（`Value`），在创建类的实例时指定了类型。
- en: Example – keep the tree balanced
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-保持树平衡
- en: As mentioned in the introduction to the topic of AVL trees, there is a very
    simple test that can cause a BST tree to become unbalanced. You can just add ordered
    numbers to create a long and skinny tree. So, let's try to create an example of
    adding exactly the same set of data to an AVL tree, implemented using the `Adjunct`
    library.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: AVL树的介绍中提到，有一个非常简单的测试可以导致BST树失衡。您只需添加有序数字即可创建一个又长又瘦的树。因此，让我们尝试创建一个使用`Adjunct`库实现的AVL树的示例，添加完全相同的数据集。
- en: 'The code placed in the `Main` method in the `Program` class is as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program`类中`Main`方法中的代码如下：'
- en: '[PRE48]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: At the beginning, a new instance of the `AvlTree` class is created with indication
    that nodes will store integer values. Then, the `for` loop is used to add the
    following numbers (from 1 to 9) to the tree, using the `Add` method. After execution
    of the loop, the tree should contain 9 nodes, arranged according to the rules
    of AVL trees.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建`AvlTree`类的新实例，并指示节点将存储整数值。然后，使用`for`循环将以下数字（从1到9）添加到树中，使用`Add`方法。循环执行后，树应包含9个节点，按照AVL树的规则排列。
- en: 'Moreover, you can traverse the tree using the regular methods: the in-order
    (`GetInorderEnumerator`), post-order (`GetPostorderEnumerator`), and breadth-first
    (`GetBreadthFirstEnumerator`) approaches. You have already learned about the first
    two, but what is **breadth-first traversal**? Its aim is to first visit all nodes
    on the same depth and then proceed to the next depth, until the maximum depth
    is reached.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用常规方法遍历树：中序（`GetInorderEnumerator`），后序（`GetPostorderEnumerator`）和广度优先（`GetBreadthFirstEnumerator`）方法。您已经了解了前两种方法，但是**广度优先遍历**是什么？它的目的是首先访问同一深度上的所有节点，然后继续到下一深度，直到达到最大深度。
- en: 'When you run the application, you will receive the following results for the
    traversals:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行应用程序时，您将收到以下遍历的结果：
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The last part of code shows the lookup feature of the AVL tree, using the `FindNode`
    method. It is used to get the `AvlTreeNode` instance representing a node with
    the given value. Then, you can easily get various data regarding the node, such
    as its height, as well as the values of left and right children, using the properties
    of the `AvlTreeNode` class. The part of the console output regarding the lookup
    feature is as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分显示了AVL树的查找功能，使用`FindNode`方法。它用于获取表示具有给定值的节点的`AvlTreeNode`实例。然后，您可以轻松地获取有关节点的各种数据，例如其高度，以及`AvlTreeNode`类的属性的左右子节点的值。有关查找功能的控制台输出部分如下：
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Easy, convenient, and without significant development effort—that quite precisely
    describes the process of applying one of the available packages to support AVL
    trees. By using it, you do not need to prepare complex code on your own and the
    number of possible problems can be significantly limited.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 简单、方便，而且不需要太多的开发工作——这很准确地描述了应用其中一个可用包来支持AVL树的过程。通过使用它，您无需自己准备复杂的代码，可能出现的问题数量也可以得到显著减少。
- en: Red-black trees
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 红黑树
- en: 'A **Red-black tree**, also referred to as an **RBT**, is the next variant of
    the self-balancing binary search trees. As a variant of BSTs, this data structure
    requires that the standard BST rules be maintained. Moreover, the following rules
    must be taken into account:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**红黑树**，也称为**RBT**，是自平衡二叉搜索树的下一个变体。作为BST的变体，这种数据结构要求维护标准的BST规则。此外，必须考虑以下规则：'
- en: Each node must be colored either red or black. Thus, you need to add additional
    data for a node that stores a color.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个节点必须被着为红色或黑色。因此，您需要为存储颜色的节点添加额外的数据。
- en: All nodes with values cannot be leaf nodes. For this reason, the NIL pseudo-nodes
    should be used as leaves in the tree, while all other nodes are internal ones.
    Moreover, all NIL pseudo-nodes must be black.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有具有值的节点不能是叶节点。因此，NIL伪节点应该用作树中的叶子节点，而所有其他节点都是内部节点。此外，所有NIL伪节点必须是黑色的。
- en: If a node is red, both its children must be black.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个节点是红色，那么它的两个子节点必须是黑色。
- en: For any node, the number of black nodes on the route to a descendant leaf (that
    is, the NIL pseudo-node) must be the same.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何节点，到后代叶子节点（即NIL伪节点）的路径上黑色节点的数量必须相同。
- en: 'The proper RBT is presented in the following diagram:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 适当的RBT如下图所示：
- en: '![](img/897476a0-63da-4e1d-9ae4-d1330f1566d1.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/897476a0-63da-4e1d-9ae4-d1330f1566d1.png)'
- en: The tree consists of nine nodes, each colored red or black. It is worth mentioning
    the NIL pseudo-nodes, which are added as leaf nodes. If you again take a look
    at the set of rules listed afore, you can confirm that all such rules are maintained
    in this case.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 树由九个节点组成，每个节点都着为红色或黑色。值得一提的是NIL伪节点，它们被添加为叶子节点。如果您再次查看前面列出的规则集，您可以确认在这种情况下所有这些规则都得到了遵守。
- en: Similarly to AVL trees, RBTs also must maintain the rules after adding or removing
    a node. In this case, the process of restoring the RBT properties is even more
    complicated, because it involves both **recoloring** and **rotations**. Fortunately,
    you do not need to know and understand the internal details, which are quite complex,
    to benefit from this data structure and apply it in your projects.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 与AVL树类似，RBT在添加或删除节点后也必须维护规则。在这种情况下，恢复RBT属性的过程更加复杂，因为它涉及**重新着色**和**旋转**。幸运的是，您无需了解和理解内部细节，这些细节相当复杂，才能从这种数据结构中受益并将其应用于您的项目中。
- en: While talking about this variant of self-balancing BSTs, it is also worth noting
    the performance. In both average and worst-case scenarios, insertion, removal,
    and lookup are *O(log n)* operations, so they are the same as in the case of the
    AVL trees and much better in worst-case scenarios in comparison with the BSTs.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论这种自平衡BST的变体时，还值得注意性能。在平均和最坏情况下，插入、删除和查找都是*O(log n)*操作，因此它们与AVL树的情况相同，并且在最坏情况下与BST相比要好得多。
- en: You can find more information about RBTs at [https://en.wikipedia.org/wiki/Red-black_tree](https://en.wikipedia.org/wiki/Red-black_tree).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://en.wikipedia.org/wiki/Red-black_tree](https://en.wikipedia.org/wiki/Red-black_tree)找到有关RBT的更多信息。
- en: You have already learned some basic information about RBTs, so let's proceed
    to the implementation using one of the available libraries.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学习了一些关于RBT的基本信息，所以让我们继续使用其中一个可用的库来实现。
- en: Implementation
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: If you want to use an RBT in your application, you can either implement it from
    scratch or use one of the available libraries, such as `TreeLib`, which you can
    easily install using the NuGet Package Manager. This library supports a few kinds
    of trees, among which the RBTs exist.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在应用程序中使用RBT，您可以从头开始实现它，也可以使用其中一个可用的库，例如`TreeLib`，您可以使用NuGet软件包管理器轻松安装它。该库支持几种树，其中包括RBT。
- en: You can find more information about the library at [http://programmatom.github.io/TreeLib/](http://programmatom.github.io/TreeLib/)
    and [https://www.nuget.org/packages/TreeLib](https://www.nuget.org/packages/TreeLib).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://programmatom.github.io/TreeLib/](http://programmatom.github.io/TreeLib/)和[https://www.nuget.org/packages/TreeLib](https://www.nuget.org/packages/TreeLib)找到有关该库的更多信息。
- en: As the library provides developers with many classes, it is a good idea to take
    a look at those related to RBTs. The first class is named `RedBlackTreeList` and
    represents an RBT. It is a generic class, so you can easily specify a type of
    data stored in each node.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该库为开发人员提供了许多类，因此最好查看与RBT相关的类。第一个类名为`RedBlackTreeList`，表示RBT。它是一个通用类，因此您可以轻松指定存储在每个节点中的数据类型。
- en: The class contains a set of methods, including `Add` for inserting a new element
    to the tree, `Remove` for deleting a node with a particular value, `ContainsKey`
    for checking whether the tree contains a given value, and `Greatest` and `Least`
    for returning the maximum and minimum values stored in the tree. Moreover, the
    class is equipped with a few variants of iterating through the nodes, including
    the enumerator.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含一组方法，包括`Add`用于向树中插入新元素，`Remove`用于删除具有特定值的节点，`ContainsKey`用于检查树是否包含给定值，以及`Greatest`和`Least`用于返回树中存储的最大和最小值。此外，该类配备了几种遍历节点的变体，包括枚举器。
- en: Example – RBT-related features
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-RBT相关功能
- en: As in the case of AVL trees, let's prepare the example for RBTs, using the external
    library. The simple program will show how to create a new tree, add elements,
    remove a particular node, and benefit from other features of the library.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 与AVL树一样，让我们使用外部库为RBT准备示例。简单的程序将展示如何创建新树，添加元素，删除特定节点，并从库的其他功能中受益。
- en: 'Let''s take a look at the following fragments of the code, which should be
    added to the `Main` method in the `Program` class. The first part is as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码片段，它应该添加到`Program`类中的`Main`方法中。第一部分如下：
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, a new instance of the `RedBlackTreeList` class is created. It is indicated
    that the nodes will store integer values. Then, the `for` loop is used to add
    10 numbers (ordered from 1 to 10) to the tree, using the `Add` method. After execution,
    the properly-arranged RBT with 10 elements should be ready.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建了`RedBlackTreeList`类的新实例。指定节点将存储整数值。然后，使用`for`循环将10个数字（从1到10排序）添加到树中，使用`Add`方法。执行后，具有10个元素的正确排列的RBT应该准备就绪。
- en: 'In the next line, the `Remove` method is used to delete the node with the value
    equal to 9:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行中，使用`Remove`方法删除值等于9的节点：
- en: '[PRE52]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following lines of code check whether the tree contains a node with the
    value equal to `5`. The returned Boolean value is then used to present the message
    in the console:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行检查树是否包含值等于`5`的节点。然后使用返回的布尔值在控制台中呈现消息：
- en: '[PRE53]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The next part of the code shows how to use the `Count` property, as well as
    the `Greatest` and `Least` methods. Such features allow the calculation of the
    total number of elements in the tree, as well as the minimum and maximum values
    stored within it. The relevant lines of code are as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的下一部分显示了如何使用`Count`属性以及`Greatest`和`Least`方法。这些功能允许计算树中元素的总数，以及存储在其中的最小和最大值。相关的代码行如下：
- en: '[PRE54]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'While using a tree data structure, you could need some way of getting values
    of nodes. You can achieve this goal using the `GetEnumerable` method, as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用树数据结构时，您可能需要一种获取节点值的方法。您可以使用`GetEnumerable`方法来实现这个目标，如下所示：
- en: '[PRE55]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Another way of iterating through nodes in the tree involves the `foreach` loop,
    as presented in the following code snippet:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在树中遍历节点的另一种方法涉及`foreach`循环，如以下代码片段所示：
- en: '[PRE56]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As you can see, using the `TreeLib` library is really simple and you can add
    it to your application in just a few minutes. However, what is the result shown
    in the console after launching the program? Let''s see:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，使用`TreeLib`库非常简单，您可以在几分钟内将其添加到您的应用程序中。但是，在启动程序后控制台中显示的结果是什么？让我们看看：
- en: '[PRE57]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It is worth noting that `TreeLib` is not the only package that supports RBTs,
    so it is a good idea to take a look at various solutions and choose the one that
    the best suits your needs.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`TreeLib`并不是唯一支持RBT的软件包，因此最好看看各种解决方案，并选择最适合您需求的软件包。
- en: You have reached the end of the part of the chapter regarding self-balancing
    binary search trees. Now, let's proceed to the last part, which is related to
    heaps. What are they and why are they located in the chapter about trees? You
    will learn answers to these and many other questions very soon!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经到达关于自平衡二叉搜索树部分的章节的末尾。现在，让我们继续进行与堆相关的最后一部分。它们是什么，为什么它们位于树的章节中？您很快就会得到这些问题的答案以及许多其他问题的答案！
- en: Binary heaps
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉堆
- en: 'A **heap** is another variant of a tree, which exists in two versions: **min-heap**
    and **max-heap**. For each of them, an additional property must be satisfied:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆**是树的另一种变体，存在两个版本：**最小堆**和**最大堆**。对于它们中的每一个，必须满足一个额外的属性：'
- en: '**For min-heap**: The value of each node must be greater than or equal to the
    value of its parent node'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于最小堆：每个节点的值必须大于或等于其父节点的值
- en: '**For max-heap**: The value of each node must be less than or equal to the
    value of its parent node'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于最大堆：每个节点的值必须小于或等于其父节点的值
- en: These rules perform a very important role, because they dictate that the root
    node always contains the smallest (in the min-heap) or the largest (in the max-heap)
    value. For this reason, it is a convenient data structure for implementing a priority
    queue, described in [Chapter 3](c0fd3ad7-ebfd-4df4-ae4a-fda9573a2b40.xhtml), *Stacks
    and Queues*.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则起着非常重要的作用，因为它们规定了根节点始终包含最小值（在最小堆中）或最大值（在最大堆中）。因此，它是实现优先队列的便捷数据结构，详见[第3章](c0fd3ad7-ebfd-4df4-ae4a-fda9573a2b40.xhtml)
    *栈和队列*。
- en: 'Heaps come in many variants, including **binary heaps**, which are the topic
    of this section. In this case, a heap must comply to one of the previously-mentioned
    rules (depending on the kind: min-heap or max-heap) and it must adhere to the
    **complete binary tree** rule, which requires that each node cannot contain more
    than two children, as well as all levels of a tree must be fully filled, except
    the last one, which must be filled from left to right and can have some empty
    space on the right.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 堆有许多变体，包括**二叉堆**，这是本节的主题。在这种情况下，堆必须符合先前提到的规则之一（取决于种类：最小堆或最大堆），并且必须遵守**完全二叉树**规则，该规则要求每个节点不能包含超过两个子节点，以及树的所有层都必须是完全填充的，除了最后一层，该层必须从左到右填充，并且右侧可能有一些空间。
- en: 'Let''s take a look at the following two binary heaps:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下以下两个二叉堆：
- en: '![](img/57b79610-a0d6-41ec-beea-325932ddc8fa.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57b79610-a0d6-41ec-beea-325932ddc8fa.png)'
- en: You can easily check whether both heaps adhere to all the rules. As an example,
    let's verify the heap property for the node with value equal to **20** from the
    min-heap variant (shown on the left). The node has two children with values **35**
    and **50**, which are both greater than **20**. In the same way, you can check
    the remaining nodes in the heap. The binary tree rule is also maintained, as each
    node contains at most two children. The last requirement is that each level of
    the tree is fully filled, except the last one which does not need to be fully
    filled, but must contain nodes from left to right. In the min-heap example, three
    levels are fully filled (with one, two, and four nodes), while the last level
    contains two nodes (**25** and **70**), placed on the two leftmost positions.
    In the same way, you can confirm that the max-heap (shown on the right) is configured
    properly.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松检查两个堆是否遵守所有规则。例如，让我们验证最小堆变体（左侧显示）中值等于**20**的节点的堆属性。该节点有两个子节点，值分别为**35**和**50**，均大于**20**。同样，您可以检查堆中的其余节点。二叉树规则也得到了遵守，因为每个节点最多包含两个子节点。最后一个要求是树的每一层都是完全填充的，除了最后一层不需要完全填充，但必须从左到右包含节点。在最小堆示例中，有三个层是完全填充的（分别有一个、两个和四个节点），而最后一层包含两个节点（**25**和**70**），位于最左边的两个位置。同样，您可以确认右侧显示的最大堆是否正确配置。
- en: At the end of this short introduction to the topic of heaps, and especially
    to binary heaps, it is worth mentioning the broad range of applications. As already
    mentioned, this data structure is a convenient way of implementing the priority
    queue with the operation of inserting a new value and removing the smallest (in
    the min-heap) or the largest value (in the max-heap). Moreover, a heap is used
    in the heap sort algorithm, which is described in the example that follows. The
    data structure has also many other applications, such as in graph algorithms.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个关于堆的简短介绍，特别是关于二叉堆的介绍中，值得一提的是其广泛的应用范围。正如前面提到的，这种数据结构是实现优先队列的便捷方式，可以插入新值并移除最小值（在最小堆中）或最大值（在最大堆中）。此外，堆还用于堆排序算法，该算法将在接下来的示例中进行描述。该数据结构还有许多其他应用，例如在图算法中。
- en: You can find more information about binary heaps at [https://en.wikipedia.org/wiki/Binary_heap](https://en.wikipedia.org/wiki/Binary_heap).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://en.wikipedia.org/wiki/Binary_heap](https://en.wikipedia.org/wiki/Binary_heap)找到有关二叉堆的更多信息。
- en: Are you ready to take a look at the implementation of heaps? If so, let's proceed
    to the next section, where one of the available libraries supporting heaps is
    presented.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您准备好看堆的实现了吗？如果是的话，让我们继续到下一节，介绍支持堆的可用库之一。
- en: Implementation
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: A binary heap can be implemented either from scratch or you can use some of
    the already-available implementations. One of the solutions is named `Hippie`
    and can be installed to the project using the NuGet Package Manager. The library
    contains implementation of a few variants of heaps, including binary, binomial,
    and Fibonacci heaps, which are presented and described in this chapter of the
    book.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉堆可以从头开始实现，也可以使用一些已有的实现。其中一个解决方案名为`Hippie`，可以通过NuGet软件包管理器安装到项目中。该库包含了堆的几个变体的实现，包括二叉堆、二项式堆和斐波那契堆，这些都在本书的本章中进行了介绍和描述。
- en: You can find more information about the library at [https://github.com/pomma89/Hippie](https://github.com/pomma89/Hippie)
    and [https://www.nuget.org/packages/Hippie](https://www.nuget.org/packages/Hippie).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/pomma89/Hippie](https://github.com/pomma89/Hippie)和[https://www.nuget.org/packages/Hippie](https://www.nuget.org/packages/Hippie)找到有关该库的更多信息。
- en: 'The library contains a few classes, such as the `MultiHeap` generic class,
    which is common for various variants of heaps, including binary ones. However,
    if the same class is used for binary, binomial, and Fibonacci heaps, how can you
    choose which type of heap you want to use? You can use the static methods from
    the `HeapFactory` class to solve this problem. As an example, a binary heap can
    be created using the `NewBinaryHeap` method, as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 该库包含了一些类，比如通用类`MultiHeap`，它适用于各种堆的变体，包括二叉堆。但是，如果同一个类用于二叉堆、二项式堆和斐波那契堆，那么您如何选择要使用哪种类型的堆呢？您可以使用`HeapFactory`类的静态方法来解决这个问题。例如，可以使用`NewBinaryHeap`方法创建二叉堆，如下所示：
- en: '[PRE58]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `MultiHeap` class is equipped with a few properties, such as `Count` for
    getting the total number of elements in the heap and `Min` for retrieving the
    minimum value. Moreover, the available methods allow adding a new element (`Add`),
    removing a particular item (`Remove`), removing the minimum value (`RemoveMin`),
    removing all elements (`Clear`), checking whether the given value exists in the
    heap (`Contains`), and merging two heaps (`Merge`).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultiHeap`类配备了一些属性，例如用于获取堆中元素总数的`Count`和用于检索最小值的`Min`。此外，可用的方法允许添加新元素（`Add`），删除特定项（`Remove`），删除最小值（`RemoveMin`），删除所有元素（`Clear`），检查给定值是否存在于堆中（`Contains`）以及合并两个堆（`Merge`）。'
- en: Example – heap sort
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-堆排序
- en: 'As an example of the binary heap, implemented using the `Hippie` library, the
    heap sort algorithm is presented and described below. The C#-based implementation,
    which should be added to the `Main` method in the `Program` class, is as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用`Hippie`库实现的二进制堆的示例，堆排序算法如下所示。应该将基于C#的实现添加到`Program`类中的`Main`方法中，如下所示：
- en: '[PRE59]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can see, the implementation is very simple and short. At the beginning,
    you create a list with unsorted integer values as the input for the algorithm.
    Then, a new binary heap is prepared and you add each input value to the heap.
    At this stage, the elements from the input list are written in the console.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，实现非常简单和简短。首先，您创建一个包含未排序整数值的列表作为算法的输入。然后，准备一个新的二进制堆，并将每个输入值添加到堆中。在这个阶段，从输入列表中的元素写入控制台。
- en: In the following part of the code, a new list is created. It will contain the
    sorted values and therefore it will contain the result of the algorithm. Then,
    the `while` loop is used to remove the minimum value from the heap in each iteration.
    The loop is executed until there are no elements in the heap. At the end, the
    sorted list is shown in the console.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的下一部分中，创建了一个新列表。它将包含排序后的值，因此它将包含算法的结果。然后，使用`while`循环在每次迭代中从堆中删除最小值。循环执行，直到堆中没有元素为止。最后，在控制台中显示排序后的列表。
- en: The heap sort algorithm has *O(n * log(n))* time complexity.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 堆排序算法的时间复杂度为*O(n * log(n))*。
- en: 'When you build the project and run the application, you will see the following
    result:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建项目并运行应用程序时，您将看到以下结果：
- en: '[PRE60]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As already mentioned, binary heaps are not the only variant of heaps. Among
    others, a binomial heap is one of the very interesting approaches, which is the
    topic of the next section.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，二进制堆并不是堆的唯一变体。除其他外，二项堆是非常有趣的方法之一，这是下一节的主题。
- en: Binomial heaps
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二项堆
- en: 'Another kind of heap is a **binomial heap**. This data structure consists of
    a set of **binomial trees** with different orders. The binomial tree with order
    *0* is just a single node. You can construct the tree with order *n* using two
    binomial trees with order *n-1*. One of them should be attached as the left-most
    child of the parent of the first tree. It does sound a bit complicated, but the
    following diagram should remove any confusion:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种堆是**二项堆**。这种数据结构由一组具有不同顺序的**二项树**组成。顺序为*0*的二项树只是一个单个节点。您可以使用两个顺序为*n-1*的二项树构造顺序为*n*的树。其中一个应该作为第一个树的父节点的最左子节点附加。听起来有点复杂，但以下图表应该消除任何困惑：
- en: '![](img/6d4e9b3e-b52d-44ad-a437-08ea02ad2aa7.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d4e9b3e-b52d-44ad-a437-08ea02ad2aa7.png)'
- en: As already mentioned, the binomial tree with order **0** is only a single node,
    as shown on the left. The tree with order **1** consists of two trees with order
    **0** (marked with the dashed border) connected to each other. In the case of
    the tree with order **2**, two trees with order **1** are used. The second is
    attached as the left-most child of the parent of the first tree. In the same way,
    you can configure the binomial trees with the following orders.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，顺序为**0**的二项树只是一个单个节点，如左侧所示。顺序为**1**的树由两个顺序为**0**的树（用虚线边框标记）连接在一起。在顺序为**2**的树的情况下，使用两个顺序为**1**的树。第二个作为第一个树的父节点的最左子节点附加。以同样的方式，您可以配置具有以下顺序的二项树。
- en: 'However, how can you know how many binomial trees should be located in the
    binomial heap, as well as how many nodes should they contain? The answer could
    be a bit surprising, because you need to prepare the binary representation of
    the number of nodes. As an example, let''s create a binomial heap with **13**
    elements. The number **13** has the following binary representation: **1101**,
    namely *1*2⁰ + 0*2¹ + 1*2² + 1*2³*.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您如何知道二项堆中应该放置多少个二项树，以及它们应该包含多少个节点？答案可能有点令人惊讶，因为您需要准备节点数的二进制表示。例如，让我们创建一个包含**13**个元素的二项堆。数字**13**的二进制表示如下：**1101**，即*1*2⁰
    + 0*2¹ + 1*2² + 1*2³*。
- en: 'You need to get zero-based positions of the set bits, that is, **0**, **2**,
    and **3** in this example. Such positions indicate orders of binomial trees that
    should be configured:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 需要获取集合位的基于零的位置，即在这个例子中的**0**，**2**和**3**。这些位置表示应该配置的二项树的顺序：
- en: '![](img/9c7fc557-a3a4-4140-a694-2fff25163a83.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c7fc557-a3a4-4140-a694-2fff25163a83.png)'
- en: Moreover, there cannot be more than one binomial tree with the same order (such
    as two trees with order **2**) in the binomial heap. Is it also worth noting that
    each binomial tree must maintain the min-heap property.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在二项堆中不能有两个具有相同顺序（例如两个顺序为**2**的树）。还值得注意的是，每个二项树必须保持最小堆属性。
- en: You can find more information about binomial heaps at [https://en.wikipedia.org/wiki/Binomial_heap](https://en.wikipedia.org/wiki/Binomial_heap).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://en.wikipedia.org/wiki/Binomial_heap](https://en.wikipedia.org/wiki/Binomial_heap)找到有关二项堆的更多信息。
- en: The implementation of the binomial heap is significantly more complicated than
    the binary heap. For this reason, it may be a good idea to use one of the available
    implementations instead of writing your own from scratch. As stated in the case
    of binary heaps, the `Hippie` library is a solution that supports various variants
    of heaps, including binomial.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'It could be surprising, but the only difference in the code, in comparison
    with the example of the binary heap, is modification of the line where a new instance
    of the `MultiHeap` class is created. For supporting a binomial heap, you need
    to use the `NewBinomialHeap` method from the `HeapFactory` class, as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: No more changes are necessary! Now you can perform the remaining operations,
    such as insertion or removal of elements, in the exact same way as in the case
    of the binary heap.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: You have already learned about two kinds of heaps, namely binary and binomial
    ones. In the next section, the Fibonacci heap is briefly described.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Fibonacci heaps
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Fibonacci heap** is an interesting variant of heaps, which in some ways
    is similar to a binomial heap. First of all, it also consists of many trees, but
    there are no constraints regarding the shape of each tree, so it is much more
    flexible than the binomial heap. Moreover, it is allowed to have more than one
    tree with exactly the same shape in the heap.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a Fibonacci heap is as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ebf3b19-9827-4b21-b359-3ed027961a35.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
- en: One of the important assumptions is that each tree is a min-heap. Thus, the
    minimum value in the whole Fibonacci heap is certainly a root node in one of the
    trees. Moreover, the presented data structure supports performing various operations
    in the *lazy* way. That means that it does not perform additional complex operations
    unless it is really necessary. For example, it can add a new node just as a new
    tree with only one node.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about Fibonacci heaps at [https://en.wikipedia.org/wiki/Fibonacci_heap](https://en.wikipedia.org/wiki/Fibonacci_heap).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to the binomial heap, the implementation of the Fibonacci heap is
    also not a trivial task and requires good understanding of the internal details
    of this data structure. For this reason, if you need to use Fibonacci heaps in
    your application, it may be a good idea to use one of the available implementations
    instead of writing your own from scratch. As stated previously, the `Hippie` library
    is a solution that supports many variants of heaps, including Fibonacci ones.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth mentioning that the only difference in the code, in comparison
    with the binary and binomial heaps, is modification of the line where a new instance
    of the `MultiHeap` class is created. For supporting a Fibonacci heap, you need
    to use the `NewFibonacciHeap` method from the `HeapFactory` class, as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: That's all! You have just read a brief introduction to the topic of Fibonacci
    heaps, as another variant of a heap and, therefore, another kind of a tree. That
    was the last subject in this chapter, so it is time to proceed to the summary.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current chapter is the longest so far in the book. However, it contains
    a lot of information about variants of trees. Such data structures perform very
    important role in many algorithms and it is good to learn more about them, as
    well as to know how to use them in your applications. For this reason, this chapter
    contains not only short theoretical introductions, but also diagrams, explanations,
    and code samples.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning, the concept of a tree was described. As a reminder, a tree
    consists of nodes, including one root. The root does not contain a parent node,
    while all other nodes do. Each node can have any number of child nodes. The child
    nodes of the same node can be named siblings, while a node without children is
    named a leaf.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Various variants of trees follow this structure. The first one described in
    the chapter is a binary tree. In this case, a node can contain at most two children.
    However, the rules for BSTs are even more strict. For any node in such trees,
    the values of all nodes in its left subtree must be smaller than the value of
    the node, while the values of all nodes in its right subtree must be greater than
    the value of the node. BSTs have a very broad range of applications and provide
    developers with significant improvements of the lookup performance. Unfortunately,
    it is possible to easily make a tree unbalanced while adding sorted values to
    the tree. Therefore, the positive impact on the performance can be limited.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 树的各种变体都遵循这种结构。章节中描述的第一种是二叉树。在这种情况下，一个节点最多可以包含两个子节点。然而，BST的规则更加严格。对于这种树中的任何节点，其左子树中所有节点的值必须小于节点的值，而右子树中所有节点的值必须大于节点的值。BST具有非常广泛的应用，并且可以显著提高查找性能。不幸的是，很容易在向树中添加排序值时使树失衡。因此，性能的积极影响可能会受到限制。
- en: 'To solve this problem, you can use some kind of self-balancing tree, which
    remains balanced all the time while adding or removing nodes. In this chapter,
    two variants of self-balancing trees were presented: AVL trees and RBTs. The first
    kind has the additional requirement that, for each node, the height of its left
    and right subtrees cannot differ by more than one. The RBT is a bit more complex,
    because it introduces the concept of coloring nodes, either to red or black, as
    well as the NIL pseudo-nodes. Moreover, it is required that if a node is red,
    both its children must be black, and for any node, the number of black nodes on
    the route to a descendant leaf must be the same. As you have seen while analyzing
    such data structures, their implementation is significantly more difficult. Thus,
    the additional libraries, available to download using the NuGet Package Manager,
    were presented.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，可以使用某种自平衡树，它在添加或删除节点时始终保持平衡。在本章中，介绍了两种自平衡树的变体：AVL树和RBT。第一种类型有额外的要求，即对于每个节点，其左右子树的高度不能相差超过一。RBT稍微复杂一些，因为它引入了将节点着色为红色或黑色的概念，以及NIL伪节点。此外，要求如果一个节点是红色，那么它的两个子节点必须是黑色，并且对于任何节点，到后代叶子的路径上的黑色节点数量必须相同。正如您在分析这些数据结构时所看到的，它们的实现要困难得多。因此，本章还介绍了可通过NuGet软件包管理器下载的额外库。
- en: The remaining part of the chapter was related to heaps. As a reminder, a heap
    is another variant of a tree, which exists in two versions, min-heap and max-heap.
    It is worth noting that the value of each node must be greater than or equal to
    (for min-heaps) or less than or equal to (for max-heaps) the value of its parent
    node. The heaps exist in many variants, including binary, binomial, and Fibonacci
    ones. All of these kinds were briefly presented in the chapter, together with
    information about using the implementation from one of the NuGet packages.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩下的部分与堆有关。作为提醒，堆是树的另一种变体，有两个版本，最小堆和最大堆。值得注意的是，每个节点的值必须大于或等于（对于最小堆）或小于或等于（对于最大堆）其父节点的值。堆存在许多变体，包括二叉堆、二项式堆和斐波那契堆。本章简要介绍了所有这些类型，以及关于使用来自NuGet软件包之一的实现的信息。
- en: Let's proceed to graphs, which are the subject of the next chapter!
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论下一章的主题——图！

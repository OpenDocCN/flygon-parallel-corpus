- en: '01'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hello, C#! Welcome, .NET!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first chapter, the goals are setting up your development environment,
    understanding the similarities and differences between modern .NET, .NET Core,
    .NET Framework, Mono, Xamarin, and .NET Standard, creating the simplest application
    possible with C# 10 and .NET 6 using various code editors, and then discovering
    good places to look for help.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GitHub repository for this book has solutions using full application projects
    for all code tasks and notebooks when possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6](https://github.com/markjprice/cs10dotnet6)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply press the . (dot) key or change `.com` to `.dev` in the link above to
    change the GitHub repository into a live editor using Visual Studio Code for the
    Web, as shown in *Figure 1.1* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application Description automatically generated](img/Image00007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Visual Studio Code for the Web live editing the book''s GitHub
    repository'
  prefs: []
  type: TYPE_NORMAL
- en: This is great to run alongside your chosen code editor as you work through the
    book's coding tasks. You can compare your code to the solution code and easily
    copy and paste parts if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, I use the term **modern .NET** to refer to .NET 6 and
    its predecessors like .NET 5 that come from .NET Core. I use the term **legacy
    .NET** to refer to .NET Framework, Mono, Xamarin, and .NET Standard. Modern .NET
    is a unification of those legacy platforms and standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this first chapter, the book can be divided into three parts: first,
    the grammar and vocabulary of the C# language; second, the types available in
    .NET for building app features; and third, examples of common cross-platform apps
    you can build using C# and .NET.'
  prefs: []
  type: TYPE_NORMAL
- en: Most people learn complex topics best by imitation and repetition rather than
    reading a detailed explanation of the theory; therefore, I will not overload you
    with detailed explanations of every step throughout this book. The idea is to
    get you to write some code and see it run.
  prefs: []
  type: TYPE_NORMAL
- en: You don't need to know all the nitty-gritty details immediately. That will be
    something that comes with time as you build your own apps and go beyond what any
    book can teach you.
  prefs: []
  type: TYPE_NORMAL
- en: In the words of Samuel Johnson, author of the English dictionary in 1755, I
    have committed "a few wild blunders, and risible absurdities, from which no work
    of such multiplicity is free." I take sole responsibility for these and hope you
    appreciate the challenge of my attempt to lash the wind by writing this book about
    rapidly evolving technologies like C# and .NET, and the apps that you can build
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This first chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building console apps using Visual Studio 2022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building console apps using Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring code using .NET Interactive Notebooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing the folders and files for projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making good use of the GitHub repository for this book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking for help
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up your development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you start programming, you''ll need a code editor for C#. Microsoft
    has a family of code editors and **Integrated Development Environments** (**IDEs**
    ), which include:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 for Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio 2022 for Mac
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code for Windows, Mac, or Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub Codespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third parties have created their own C# code editors, for example, JetBrains
    Rider.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the appropriate tool and application type for learning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is the best tool and application type for learning C# and .NET?
  prefs: []
  type: TYPE_NORMAL
- en: When learning, the best tool is one that helps you write code and configuration
    but does not hide what is really happening. IDEs provide graphical user interfaces
    that are friendly to use, but what are they doing for you underneath? A more basic
    code editor that is closer to the action while providing help to write your code
    is better while you are learning.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, you can make the argument that the best tool is the one you
    are already familiar with or that you or your team will use as your daily development
    tool. For that reason, I want you to be free to choose any C# code editor or IDE
    to complete the coding tasks in this book, including Visual Studio Code, Visual
    Studio for Windows, Visual Studio for Mac, or even JetBrains Rider.
  prefs: []
  type: TYPE_NORMAL
- en: In the third edition of this book, I gave detailed step-by-step instructions
    for both Visual Studio for Windows and Visual Studio Code for all coding tasks.
    Unfortunately, that got messy and confusing quickly. In this sixth edition, I
    give detailed step-by-step instructions for how to create multiple projects in
    both Visual Studio 2022 for Windows and Visual Studio Code only in *Chapter 1*
    . After that, I give names of projects and general instructions that work with
    all tools so you can use whichever tool you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: The best application type for learning the C# language constructs and many of
    the .NET libraries is one that does not distract with unnecessary application
    code. For example, there is no need to create an entire Windows desktop application
    or a website just to learn how to write a `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: For that reason, I believe the best method for learning the C# and .NET topics
    in *Chapters 1* to *12* is to build console applications. Then, in *Chapter 13*
    to *19* onward, you will build websites, services, and graphical desktop and mobile
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: Pros and cons of the .NET Interactive Notebooks extension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another benefit of Visual Studio Code is the .NET Interactive Notebooks extension.
    This extension provides an easy and safe place to write simple code snippets.
    It enables you to create a single notebook file that mixes "cells" of Markdown
    (richly formatted text) and code using C# and other related languages, such as
    PowerShell, F#, and SQL (for databases).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, .NET Interactive Notebooks does have some limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: They cannot read input from the user, for example, you cannot use `ReadLine`
    or `ReadKey` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They cannot have arguments passed to them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They do not allow you to define your own namespaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They do not have any debugging tools (but these are coming in the future).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Visual Studio Code for cross-platform development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most modern and lightweight code editor to choose from, and the only one
    from Microsoft that is cross-platform, is Microsoft Visual Studio Code. It can
    run on all common operating systems, including Windows, macOS, and many varieties
    of Linux, including Red Hat Enterprise Linux (RHEL) and Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code is a good choice for modern cross-platform development because
    it has an extensive and growing set of extensions to support many languages beyond
    C#.
  prefs: []
  type: TYPE_NORMAL
- en: Being cross-platform and lightweight, it can be installed on all platforms that
    your apps will be deployed to for quick bug fixes and so on. Choosing Visual Studio
    Code means a developer can use a cross-platform code editor to develop cross-platform
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code has strong support for web development, although it currently
    has weak support for mobile and desktop development.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code is supported on ARM processors so that you can develop on
    Apple Silicon computers and Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code is by far the most popular integrated development environment,
    with over 70% of professional developers selecting it in the Stack Overflow 2021
    survey.
  prefs: []
  type: TYPE_NORMAL
- en: Using GitHub Codespaces for development in the cloud
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GitHub Codespaces is a fully configured development environment based on Visual
    Studio Code that can be spun up in an environment hosted in the cloud and accessed
    through any web browser. It supports Git repos, extensions, and a built-in command-line
    interface so you can edit, run, and test from any device.
  prefs: []
  type: TYPE_NORMAL
- en: Using Visual Studio for Mac for general development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microsoft Visual Studio 2022 for Mac can create most types of applications,
    including console apps, websites, web services, desktop, and mobile apps.
  prefs: []
  type: TYPE_NORMAL
- en: To compile apps for Apple operating systems like iOS to run on devices like
    the iPhone and iPad, you must have Xcode, which only runs on macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Using Visual Studio for Windows for general development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microsoft Visual Studio 2022 for Windows can create most types of applications,
    including console apps, websites, web services, desktop, and mobile apps. Although
    you can use Visual Studio 2022 for Windows with its Xamarin extensions to write
    a cross-platform mobile app, you still need macOS and Xcode to compile it.
  prefs: []
  type: TYPE_NORMAL
- en: It only runs on Windows, version 7 SP1 or later. You must run it on Windows
    10 or Windows 11 to create **Universal Windows Platform** (**UWP** ) apps that
    are installed from the Microsoft Store and run in a sandbox to protect your computer.
  prefs: []
  type: TYPE_NORMAL
- en: What I used
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To write and test the code for this book, I used the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: HP Spectre (Intel) laptop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apple Silicon Mac mini (M1) desktop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspberry Pi 400 (ARM v8) desktop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And I used the following software:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio Code on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS on an Apple Silicon Mac mini (M1) desktop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows 10 on an HP Spectre (Intel) laptop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubuntu 64 on a Raspberry Pi 400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Visual Studio 2022 for Windows on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows 10 on an HP Spectre (Intel) laptop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Visual Studio 2022 for Mac on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS on an Apple Silicon Mac mini (M1) desktop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I hope that you have access to a variety of hardware and software too, because
    seeing the differences in platforms deepens your understanding of development
    challenges, although any one of the above combinations is enough to learn the
    fundamentals of C# and .NET and how to build practical apps and websites.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information** : You can learn how to write code with C# and .NET using
    a Raspberry Pi 400 with Ubuntu Desktop 64-bit by reading an extra article that
    I wrote at the following link: [https://github.com/markjprice/cs9dotnet5-extras/blob/main/raspberry-pi-ubuntu64/README.md](https://github.com/markjprice/cs9dotnet5-extras/blob/main/raspberry-pi-ubuntu64/README.md)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying cross-platform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your choice of code editor and operating system for development does not limit
    where your code gets deployed.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET 6 supports the following platforms for deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows** : Windows 7 SP1, or later. Windows 10 version 1607, or later, including
    Windows 11\. Windows Server 2012 R2 SP1, or later. Nano Server version 1809, or
    later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mac** : macOS Mojave (version 10.14), or later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux** : Alpine Linux 3.13, or later. CentOS 7, or later. Debian 10, or
    later. Fedora 32, or later. openSUSE 15, or later. Red Hat Enterprise Linux (RHEL)
    7, or later. SUSE Enterprise Linux 12 SP2, or later. Ubuntu 16.04, 18.04, 20.04,
    or later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android** : API 21, or later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iOS** : 10, or later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows ARM64 support in .NET 5 and later means you can develop on, and deploy
    to, Windows ARM devices like Microsoft Surface Pro X. But developing on an Apple
    M1 Mac using Parallels and a Windows 10 ARM virtual machine is apparently twice
    as fast!
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and installing Visual Studio 2022 for Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many professional Microsoft developers use Visual Studio 2022 for Windows in
    their day-to-day development work. Even if you choose to use Visual Studio Code
    to complete the coding tasks in this book, you might want to familiarize yourself
    with Visual Studio 2022 for Windows too.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not have a Windows computer, then you can skip this section and continue
    to the next section where you will download and install Visual Studio Code on
    macOS or Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since October 2014, Microsoft has made a professional quality edition of Visual
    Studio for Windows available to students, open source contributors, and individuals
    for free. It is called Community Edition. Any of the editions are suitable for
    this book. If you have not already installed it, let''s do so now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download Microsoft Visual Studio 2022 version 17.0 or later for Windows from
    the following link: [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)
    .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the **Workloads** tab, select the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ASP.NET and web development**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure development**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET desktop development**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Desktop development with C++**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Universal Windows Platform development**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mobile development with .NET**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the **Individual components** tab, in the **Code tools** section, select
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Class Designer**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Git for Windows**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PreEmptive Protection - Dotfuscator**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click **Install** and wait for the installer to acquire the selected software
    and install it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the installation is complete, click **Launch** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first time that you run Visual Studio, you will be prompted to sign in.
    If you have a Microsoft account, you can use that account. If you don''t, then
    register for a new one at the following link: [https://signup.live.com/](https://signup.live.com/)
    .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first time that you run Visual Studio, you will be prompted to configure
    your environment. For **Development Settings** , choose **Visual C#** . For the
    color theme, I chose **Blue** , but you can choose whatever tickles your fancy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to customize your keyboard shortcuts, navigate to **Tools** | **Options…**
    , and then select the **Keyboard** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Microsoft Visual Studio for Windows keyboard shortcuts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this book, I will avoid showing keyboard shortcuts since they are often
    customized. Where they are consistent across code editors and commonly used, I
    will try to show them. If you want to identify and customize your keyboard shortcuts,
    then you can, as shown at the following link: [https://docs.microsoft.com/en-us/visualstudio/ide/identifying-and-customizing-keyboard-shortcuts-in-visual-studio](https://docs.microsoft.com/en-us/visualstudio/ide/identifying-and-customizing-keyboard-shortcuts-in-visual-studio)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and installing Visual Studio Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio Code has rapidly improved over the past couple of years and has
    pleasantly surprised Microsoft with its popularity. If you are brave and like
    to live on the bleeding edge, then there is an Insiders edition, which is a daily
    build of the next version.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you plan to only use Visual Studio 2022 for Windows for development,
    I recommend that you download and install Visual Studio Code and try the coding
    tasks in this chapter using it, and then decide if you want to stick with just
    using Visual Studio 2022 for the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now download and install Visual Studio Code, the .NET SDK, and the C#
    and .NET Interactive Notebooks extensions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and install either the Stable build or the Insiders edition of Visual
    Studio Code from the following link: [https://code.visualstudio.com/](https://code.visualstudio.com/)
    .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**More Information** : If you need more help installing Visual Studio Code,
    you can read the official setup guide at the following link: [https://code.visualstudio.com/docs/setup/setup-overview](https://code.visualstudio.com/docs/setup/setup-overview)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and install the .NET SDKs for versions 3.1, 5.0, and 6.0 from the
    following link: [https://www.microsoft.com/net/download](https://www.microsoft.com/net/download)
    .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To fully learn how to control .NET SDKs, we need multiple versions installed.
    .NET Core 3.1, .NET 5.0, and .NET 6.0 are the three currently supported versions.
    You can safely install multiple ones side by side. You will learn how to target
    the one you want throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: To install the C# extension, you must first launch the Visual Studio Code application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, click the **Extensions** icon or navigate to **View**
    | **Extensions** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C# is one of the most popular extensions available, so you should see it at
    the top of the list, or you can enter `C#` in the search box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Install** and wait for supporting packages to download and install.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `.NET Interactive` in the search box to find the **.NET Interactive Notebooks**
    extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Install** and wait for it to install.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing other extensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In later chapters of this book, you will use more extensions. If you want to
    install them now, all the extensions that we will use are shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Extension name and identifier | Description |'
  prefs: []
  type: TYPE_TB
- en: '| C# for Visual Studio Code (powered by OmniSharp)`ms-dotnettools.csharp` |
    C# editing support, including syntax highlighting, IntelliSense, Go to Definition,
    Find All References, debugging support for .NET, and support for `csproj` projects
    on Windows, macOS, and Linux. |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Interactive Notebooks`ms-dotnettools.dotnet-interactive-vscode` | This
    extension adds support for using .NET Interactive in a Visual Studio Code notebook.
    It has a dependency on the Jupyter extension (`ms-toolsai.jupyter` ). |'
  prefs: []
  type: TYPE_TB
- en: '| MSBuild project tools`tinytoy.msbuild-project-tools` | Provides IntelliSense
    for MSBuild project files, including autocomplete for `<PackageReference>` elements.
    |'
  prefs: []
  type: TYPE_TB
- en: '| REST Client`humao.rest-client` | Send an HTTP request and view the response
    directly in Visual Studio Code. |'
  prefs: []
  type: TYPE_TB
- en: '| ILSpy .NET Decompiler`icsharpcode.ilspy-vscode` | Decompile MSIL assemblies
    – support for modern .NET, .NET Framework, .NET Core, and .NET Standard. |'
  prefs: []
  type: TYPE_TB
- en: '| Azure Functions for Visual Studio Code`ms-azuretools.vscode-azurefunctions`
    | Create, debug, manage, and deploy serverless apps directly from VS Code. It
    has dependencies on Azure Account (`ms-vscode.azure-account` ) and Azure Resources
    (`ms-azuretools.vscode-azureresourcegroups` ) extensions. |'
  prefs: []
  type: TYPE_TB
- en: '| GitHub Repositories`github.remotehub` | Browse, search, edit, and commit
    to any remote GitHub repository directly from within Visual Studio Code. |'
  prefs: []
  type: TYPE_TB
- en: '| SQL Server (mssql) for Visual Studio Code`ms-mssql.mssql` | For developing
    Microsoft SQL Server, Azure SQL Database, and SQL Data Warehouse everywhere with
    a rich set of functionalities. |'
  prefs: []
  type: TYPE_TB
- en: '| Protobuf 3 support for Visual Studio Code`zxh404.vscode-proto3` | Syntax
    highlighting, syntax validation, code snippets, code completion, code formatting,
    brace matching, and line and block commenting. |'
  prefs: []
  type: TYPE_TB
- en: Understanding Microsoft Visual Studio Code versions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Microsoft releases a new feature version of Visual Studio Code (almost) every
    month and bug fix versions more frequently. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Version 1.59, August 2021 feature release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version 1.59.1, August 2021 bug fix release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The version used in this book is 1.59, but the version of Microsoft Visual Studio
    Code is less important than the version of the C# for Visual Studio Code extension
    that you installed.
  prefs: []
  type: TYPE_NORMAL
- en: While the C# extension is not required, it provides IntelliSense as you type,
    code navigation, and debugging features, so it's something that's very handy to
    install and keep updated to support the latest C# language features.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Visual Studio Code keyboard shortcuts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this book, I will avoid showing keyboard shortcuts used for tasks like creating
    a new file since they are often different on different operating systems. The
    situations where I will show keyboard shortcuts are when you need to repeatedly
    press the key, for example, while debugging. These are also more likely to be
    consistent across operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to customize your keyboard shortcuts for Visual Studio Code, then
    you can, as shown at the following link: [https://code.visualstudio.com/docs/getstarted/keybindings](https://code.visualstudio.com/docs/getstarted/keybindings)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'I recommend that you download a PDF of keyboard shortcuts for your operating
    system from the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows** : [https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**macOS** : [https://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux** : [https://code.visualstudio.com/shortcuts/keyboard-shortcuts-linux.pdf](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-linux.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET 6, .NET Core, .NET Framework, and Xamarin are related and overlapping platforms
    for developers used to build applications and services. In this section, I'm going
    to introduce you to each of these .NET concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding .NET Framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET Framework is a development platform that includes a **Common Language Runtime**
    (**CLR** ), which manages the execution of code, and a **Base Class Library**
    (**BCL** ), which provides a rich library of classes to build applications from.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft originally designed .NET Framework to have the possibility of being
    cross-platform, but Microsoft put their implementation effort into making it work
    best with Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Since .NET Framework 4.5.2, it has been an official component of the Windows
    operating system. Components have the same support as their parent products, so
    4.5.2 and later follow the life cycle policy of the Windows OS on which it is
    installed. .NET Framework is installed on over one billion computers, so it must
    change as little as possible. Even bug fixes can cause problems, so it is updated
    infrequently.
  prefs: []
  type: TYPE_NORMAL
- en: For .NET Framework 4.0 or later, all of the apps on a computer written for .NET
    Framework share the same version of the CLR and libraries stored in the **Global
    Assembly Cache** (**GAC** ), which can lead to issues if some of them need a specific
    version for compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Practically speaking, .NET Framework is Windows-only and
    a legacy platform. Do not create new apps using it.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Mono, Xamarin, and Unity projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Third parties developed a .NET Framework implementation named the **Mono** project.
    Mono is cross-platform, but it fell well behind the official implementation of
    .NET Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Mono has found a niche as the foundation of the **Xamarin** mobile platform
    as well as cross-platform game development platforms like **Unity** .
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft purchased Xamarin in 2016 and now gives away what used to be an expensive
    Xamarin extension for free with Visual Studio. Microsoft renamed the Xamarin Studio
    development tool, which could only create mobile apps, to Visual Studio for Mac
    and gave it the ability to create other types of projects like console apps and
    web services. With Visual Studio 2022 for Mac, Microsoft has replaced parts of
    the Xamarin Studio editor with parts from Visual Studio 2022 for Windows to provide
    closer parity of experience and performance. Visual Studio 2022 for Mac was also
    rewritten to be a truly native macOS UI app to improve reliability and work with
    macOS's built-in assistive technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding .NET Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Today, we live in a truly cross-platform world where modern mobile and cloud
    development have made Windows, as an operating system, much less important. Because
    of that, Microsoft has been working on an effort to decouple .NET from its close
    ties with Windows. While rewriting .NET Framework to be truly cross-platform,
    they've taken the opportunity to refactor and remove major parts that are no longer
    considered core.
  prefs: []
  type: TYPE_NORMAL
- en: This new product was branded .NET Core and includes a cross-platform implementation
    of the CLR known as CoreCLR and a streamlined BCL known as CoreFX.
  prefs: []
  type: TYPE_NORMAL
- en: Scott Hunter, Microsoft Partner Director Program Manager for .NET, has said
    that "Forty percent of our .NET Core customers are brand-new developers to the
    platform, which is what we want with .NET Core. We want to bring new people in."
  prefs: []
  type: TYPE_NORMAL
- en: .NET Core is fast-moving, and because it can be deployed side by side with an
    app, it can change frequently, knowing those changes will not affect other .NET
    Core apps on the same machine. Most improvements that Microsoft makes to .NET
    Core and modern .NET cannot be easily added to .NET Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the journey to one .NET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the Microsoft Build developer conference in May 2020, the .NET team announced
    that their plans for the unification of .NET had been delayed. They said that
    .NET 5 would be released on November 10, 2020, and it would unify all the various
    .NET platforms except mobile. It would not be until .NET 6 in November 2021 that
    mobile will also be supported by the unified .NET platform.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Core has been renamed .NET and the major version number has skipped the
    number four to avoid confusion with .NET Framework 4.x. Microsoft plans on annual
    major version releases every November, rather like Apple does major version number
    releases of iOS every September.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows when the key versions of modern .NET were released,
    when future releases are planned, and which version is used by the various editions
    of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Version | Released | Edition | Published |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Core RC1 | November 2015 | First | March 2016 |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Core 1.0 | June 2016 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Core 1.1 | November 2016 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Core 1.0.4 and .NET Core 1.1.1 | March 2017 | Second | March 2017 |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Core 2.0 | August 2017 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Core for UWP in Windows 10 Fall Creators Update | October 2017 | Third
    | November 2017 |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Core 2.1 (LTS) | May 2018 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Core 2.2 (Current) | December 2018 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Core 3.0 (Current) | September 2019 | Fourth | October 2019 |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Core 3.1 (LTS) | December 2019 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Blazor WebAssembly 3.2 (Current) | May 2020 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| .NET 5.0 (Current) | November 2020 | Fifth | November 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| .NET 6.0 (LTS) | November 2021 | Sixth | November 2021 |'
  prefs: []
  type: TYPE_TB
- en: '| .NET 7.0 (Current) | November 2022 | Seventh | November 2022 |'
  prefs: []
  type: TYPE_TB
- en: '| .NET 8.0 (LTS) | November 2023 | Eighth | November 2023 |'
  prefs: []
  type: TYPE_TB
- en: .NET Core 3.1 included Blazor Server for building web components. Microsoft
    had also planned to include Blazor WebAssembly in that release, but it was delayed.
    Blazor WebAssembly was later released as an optional add-on for .NET Core 3.1\.
    I include it in the table above because it was versioned as 3.2 to exclude it
    from the LTS of .NET Core 3.1.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding .NET support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '.NET versions are either **Long Term Support** (**LTS** ) or **Current** ,
    as described in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LTS** releases are stable and require fewer updates over their lifetime.
    These are a good choice for applications that you do not intend to update frequently.
    LTS releases will be supported for 3 years after general availability, or 1 year
    after the next LTS release ships, whichever is longer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Current** releases include features that may change based on feedback. These
    are a good choice for applications that you are actively developing because they
    provide access to the latest improvements. After a 6-month maintenance period,
    or 18 months after general availability, the previous minor version will no longer
    be supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both receive critical fixes throughout their lifetime for security and reliability.
    You must stay up to date with the latest patches to get support. For example,
    if a system is running 1.0 and 1.0.1 has been released, 1.0.1 will need to be
    installed to get support.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand your choices of Current and LTS releases, it is helpful
    to see it visually, with 3-year-long black bars for LTS releases, and variable-length
    gray bars for Current releases that end with cross-hatching for the 6 months after
    a new major or minor release that they retain support for, as shown in *Figure
    1.2* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text Description automatically generated with low confidence](img/Image00008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Support for various versions'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you had created a project using .NET Core 3.0, then when Microsoft
    released .NET Core 3.1 in December 2019, you had to upgrade your project to .NET
    Core 3.1 by March 2020\. (Before .NET 5, the maintenance period for Current releases
    was only three months.)
  prefs: []
  type: TYPE_NORMAL
- en: If you need long-term support from Microsoft, then choose .NET 6.0 today and
    stick with it until .NET 8.0, even once Microsoft releases .NET 7.0\. This is
    because .NET 7.0 will be a current release and it will therefore lose support
    before .NET 6.0 does. Just remember that even with LTS releases you must upgrade
    to bug fix releases like 6.0.1.
  prefs: []
  type: TYPE_NORMAL
- en: 'All versions of .NET Core and modern .NET have reached their end of life except
    those shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET 5.0 will reach end of life in May 2022.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Core 3.1 will reach end of life on December 3, 2022.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET 6.0 will reach end of life in November 2024.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding .NET Runtime and .NET SDK versions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: .NET Runtime versioning follows semantic versioning, that is, a major increment
    indicates breaking changes, minor increments indicate new features, and patch
    increments indicate bug fixes.
  prefs: []
  type: TYPE_NORMAL
- en: .NET SDK versioning does not follow semantic versioning. The major and minor
    version numbers are tied to the runtime version it is matched with. The patch
    number follows a convention that indicates the major and minor versions of the
    SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see an example of this in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Change | Runtime | SDK |'
  prefs: []
  type: TYPE_TB
- en: '| Initial release | 6.0.0 | 6.0.100 |'
  prefs: []
  type: TYPE_TB
- en: '| SDK bug fix | 6.0.0 | 6.0.101 |'
  prefs: []
  type: TYPE_TB
- en: '| Runtime and SDK bug fix | 6.0.1 | 6.0.102 |'
  prefs: []
  type: TYPE_TB
- en: '| SDK new feature | 6.0.1 | 6.0.200 |'
  prefs: []
  type: TYPE_TB
- en: Removing old versions of .NET
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: .NET Runtime updates are compatible with a major version such as 6.x, and updated
    releases of the .NET SDK maintain the ability to build applications that target
    previous versions of the runtime, which enables the safe removal of older versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see which SDKs and runtimes are currently installed using the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dotnet --list-sdks`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet --list-runtimes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Windows, use the **App & features** section to remove .NET SDKs. On macOS
    or Windows, use the `dotnet-core-uninstall` tool. This tool is not installed by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, while writing the fourth edition, I used the following command
    every month:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: dotnet-core-uninstall remove --all-previews-but-latest --sdk
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: What is different about modern .NET?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modern .NET is modularized compared to the legacy .NET Framework, which is monolithic.
    It is open source and Microsoft makes decisions about improvements and changes
    in the open. Microsoft has put particular effort into improving the performance
    of modern .NET.
  prefs: []
  type: TYPE_NORMAL
- en: It is smaller than the last version of .NET Framework due to the removal of
    legacy and non-cross-platform technologies. For example, workloads such as Windows
    Forms and **Windows Presentation Foundation** (**WPF** ) can be used to build
    **graphical user** **interface** (**GUI** ) applications, but they are tightly
    bound to the Windows ecosystem, so they are not included with .NET on macOS and
    Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Windows development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the features of modern .NET is support for running old Windows Forms
    and WPF applications using the Windows Desktop Pack that is included with the
    Windows version of .NET Core 3.1 or later, which is why it is bigger than the
    SDKs for macOS and Linux. You can make some small changes to your legacy Windows
    app if necessary, and then rebuild it for .NET 6 to take advantage of new features
    and performance improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Web development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ASP.NET Web Forms and Windows Communication Foundation (WCF) are old web application
    and service technologies that fewer developers are choosing to use for new development
    projects today, so they have also been removed from modern .NET. Instead, developers
    prefer to use ASP.NET MVC, ASP.NET Web API, SignalR, and gRPC. These technologies
    have been refactored and combined into a platform that runs on modern .NET, named
    ASP.NET Core. You'll learn about the technologies in *Chapter 14* , *Building
    Websites Using ASP.NET Core Razor Pages* , *Chapter 15* , *Building Websites Using
    the Model-View-Controller Pattern* , *Chapter 16* , *Building and Consuming Web
    Services* , and *Chapter 18* , *Building and Consuming Specialized Services* (Chapter
    18 available at [https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf](https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '**More Information** : Some .NET Framework developers are upset that ASP.NET
    Web Forms, WCF, and Windows Workflow (WF) are missing from modern .NET and would
    like Microsoft to change their minds. There are open source projects to enable
    WCF and WF to migrate to modern .NET. You can read more at the following link:
    [https://devblogs.microsoft.com/dotnet/supporting-the-community-with-wf-and-wcf-oss-projects/](https://devblogs.microsoft.com/dotnet/supporting-the-community-with-wf-and-wcf-oss-projects/)
    . There is an open source project for Blazor Web Forms components at the following
    link: [https://github.com/FritzAndFriends/BlazorWebFormsComponents](https://github.com/FritzAndFriends/BlazorWebFormsComponents)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Database development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Entity Framework** (**EF** ) 6 is an object-relational mapping technology
    that is designed to work with data that is stored in relational databases such
    as Oracle and Microsoft SQL Server. It has gained baggage over the years, so the
    cross-platform API has been slimmed down, has been given support for non-relational
    databases like Microsoft Azure Cosmos DB, and has been renamed Entity Framework
    Core. You will learn about it in *Chapter 10* , *Working with Data Using Entity
    Framework Core* .'
  prefs: []
  type: TYPE_NORMAL
- en: If you have existing apps that use the old EF, then version 6.3 is supported
    on .NET Core 3.0 or later.
  prefs: []
  type: TYPE_NORMAL
- en: Themes of modern .NET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Microsoft has created a website using Blazor that shows the major themes of
    modern .NET: [https://themesof.net/](https://themesof.net/) .'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding .NET Standard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The situation with .NET in 2019 was that there were three forked .NET platforms
    controlled by Microsoft, as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**.NET Core** : For cross-platform and new apps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET Framework** : For legacy apps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Xamarin** : For mobile apps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each had strengths and weaknesses because they were all designed for different
    scenarios. This led to the problem that a developer had to learn three platforms,
    each with annoying quirks and limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Because of that, Microsoft defined .NET Standard – a specification for a set
    of APIs that all .NET platforms could implement to indicate what level of compatibility
    they have. For example, basic support is indicated by a platform being compliant
    with .NET Standard 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: With .NET Standard 2.0 and later, Microsoft made all three platforms converge
    on a modern minimum standard, which made it much easier for developers to share
    code between any flavor of .NET.
  prefs: []
  type: TYPE_NORMAL
- en: For .NET Core 2.0 and later, this added most of the missing APIs that developers
    need to port old code written for .NET Framework to the cross-platform .NET Core.
    However, some APIs are implemented but throw an exception to indicate to a developer
    that they should not actually be used! This is usually due to differences in the
    operating system on which you run .NET. You'll learn how to handle these exceptions
    in *Chapter 2* , *Speaking C#.*
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that .NET Standard is just a standard. You are
    not able to install .NET Standard in the same way that you cannot install HTML5\.
    To use HTML5, you must install a web browser that implements the HTML5 standard.
  prefs: []
  type: TYPE_NORMAL
- en: To use .NET Standard, you must install a .NET platform that implements the .NET
    Standard specification. The last .NET Standard, version 2.1, is implemented by
    .NET Core 3.0, Mono, and Xamarin. Some features of C# 8.0 require .NET Standard
    2.1\. .NET Standard 2.1 is not implemented by .NET Framework 4.8, so we should
    treat .NET Framework as legacy.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the release of .NET 6 in November 2021, the need for .NET Standard has
    reduced significantly because there is now a single .NET for all platforms, including
    mobile. .NET 6 has a single BCL and two CLRs: CoreCLR is optimized for server
    or desktop scenarios like websites and Windows desktop apps, and the Mono runtime
    is optimized for mobile and web browser apps that have limited resources.'
  prefs: []
  type: TYPE_NORMAL
- en: Even now, apps and websites created for .NET Framework will need to be supported,
    so it is important to understand that you can create .NET Standard 2.0 class libraries
    that are backward compatible with legacy .NET platforms.
  prefs: []
  type: TYPE_NORMAL
- en: .NET platforms and tools used by the book editions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the first edition of this book, which was written in March 2016, I focused
    on .NET Core functionality but used .NET Framework when important or useful features
    had not yet been implemented in .NET Core because that was before the final release
    of .NET Core 1.0\. Visual Studio 2015 was used for most examples, with Visual
    Studio Code shown only briefly.
  prefs: []
  type: TYPE_NORMAL
- en: The second edition was (almost) completely purged of all .NET Framework code
    examples so that readers were able to focus on .NET Core examples that truly run
    cross-platform.
  prefs: []
  type: TYPE_NORMAL
- en: The third edition completed the switch. It was rewritten so that all of the
    code was pure .NET Core. But giving step-by-step instructions for both Visual
    Studio Code and Visual Studio 2017 for all tasks added complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth edition continued the trend by only showing coding examples using
    Visual Studio Code for all but the last two chapters. In *Chapter 20* , *Building
    Windows Desktop Apps* , it used Visual Studio running on Windows 10, and in *Chapter
    21* , *Building Cross-Platform Mobile Apps* , it used Visual Studio for Mac.
  prefs: []
  type: TYPE_NORMAL
- en: In the fifth edition, *Chapter 20* , *Building Windows Desktop Apps* , was moved
    to *Appendix B* to make space for a new *Chapter 20* , *Building Web User Interfaces
    Using Blazor* . Blazor projects can be created using Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: In this sixth edition, *Chapter 19* , *Building Mobile and Desktop Apps Using
    .NET MAUI* , was updated to show how mobile and desktop cross-platform apps can
    be created using Visual Studio 2022 and **.NET MAUI** (**Multi-platform App UI**
    ). You can find it at [https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf](https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf)
    .
  prefs: []
  type: TYPE_NORMAL
- en: By the seventh edition and the release of .NET 7, Visual Studio Code will have
    an extension to support .NET MAUI. At that point, readers will be able to use
    Visual Studio Code for all examples in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding intermediate language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C# compiler (named **Roslyn** ) used by the `dotnet` CLI tool converts your
    C# source code into **intermediate language** (**IL** ) code and stores the IL
    in an **assembly** (a DLL or EXE file). IL code statements are like assembly language
    instructions, which are executed by .NET's virtual machine, known as CoreCLR.
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, CoreCLR loads the IL code from the assembly, the **just-in-time**
    (**JIT** ) compiler compiles it into native CPU instructions, and then it is executed
    by the CPU on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of this two-step compilation process is that Microsoft can create
    CLRs for Linux and macOS, as well as for Windows. The same IL code runs everywhere
    because of the second compilation step, which generates code for the native operating
    system and CPU instruction set.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of which language the source code is written in, for example, C#,
    Visual Basic, or F#, all .NET applications use IL code for their instructions
    stored in an assembly. Microsoft and others provide disassembler tools that can
    open an assembly and reveal this IL code, such as the ILSpy .NET Decompiler extension.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing .NET technologies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can summarize and compare .NET technologies today, as shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Technology | Description | Host operating systems |'
  prefs: []
  type: TYPE_TB
- en: '| Modern .NET | A modern feature set, full C# 8, 9, and 10 support, used to
    port existing apps or create new desktop, mobile, and web apps and services |
    Windows, macOS, Linux, Android, iOS |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Framework | A legacy feature set, limited C# 8 support, no C# 9 or 10
    support, used to maintain existing applications only | Windows only |'
  prefs: []
  type: TYPE_TB
- en: '| Xamarin | Mobile and desktop apps only | Android, iOS, macOS |'
  prefs: []
  type: TYPE_TB
- en: Building console apps using Visual Studio 2022
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this section is to showcase how to build a console app using Visual
    Studio 2022 for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not have a Windows computer or you want to use Visual Studio Code,
    then you can skip this section since the code will be the same, just the tooling
    experience is different.
  prefs: []
  type: TYPE_NORMAL
- en: Managing multiple projects using Visual Studio 2022
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio 2022 has a concept named a **solution** that allows you to open
    and manage multiple projects simultaneously. We will use a solution to manage
    the two projects that you will create in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code using Visual Studio 2022
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started writing code!
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2022.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Start window, click **Create a new project** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Create a new project** dialog, enter `console` in the **Search for
    templates** box, and select **Console Application** , making sure that you have
    chosen the C# project template rather than another language, such as F# or Visual
    Basic, as shown in *Figure 1.3* :![](img/Image00009.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 1.3: Selecting the Console Application project template'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Configure your new project** dialog, enter `HelloCS` for the project
    name, enter `C:\Code` for the location, and enter `Chapter01` for the solution
    name, as shown in *Figure 1.4* :![](img/Image00010.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 1.4: Configuring names and locations for your new project'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are deliberately going to use the older project template for .NET 5.0 to
    see what a full console application looks like. In the next section, you will
    create a console application using .NET 6.0 and see what has changed.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Additional information** dialog, in the **Target Framework** drop-down
    list, note the choices of Current and long-term support versions of .NET, and
    then select **.NET 5.0 (Current)** and click **Create** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Solution Explorer** , double-click to open the file named `Program.cs`
    , and note that **Solution Explorer** shows the **HelloCS** project, as shown
    in *Figure 1.5* :![](img/Image00011.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 1.5: Editing Program.cs in Visual Studio 2022'
  prefs: []
  type: TYPE_NORMAL
- en: In `Program.cs` , modify line 9 so that the text that is being written to the
    console says `Hello, C#!`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compiling and running code using Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next task is to compile and run the code.
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, navigate to **Debug** | **Start Without Debugging** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The output in the console window will show the result of running your application,
    as shown in *Figure 1.6* :![Graphical user interface, text, application Description
    automatically generated](img/Image00012.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 1.6: Running the console app on Windows'
  prefs: []
  type: TYPE_NORMAL
- en: Press any key to close the console window and return to Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **HelloCS** project and then, in the **Solution Explorer** toolbar,
    toggle on the **Show All Files** button, and note that the compiler-generated
    `bin` and `obj` folders are visible, as shown in *Figure 1.7* :![Graphical user
    interface, text, application, email Description automatically generated](img/Image00013.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 1.7: Showing the compiler-generated folders and files'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the compiler-generated folders and files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two compiler-generated folders were created, named `obj` and `bin` . You do
    not need to look inside these folders or understand their files yet. Just be aware
    that the compiler needs to create temporary folders and files to do its work.
    You could delete these folders and their files, and they can be recreated later.
    Developers often do this to "clean" a project. Visual Studio even has a command
    on the **Build** menu named **Clean Solution** that deletes some of these temporary
    files for you. The equivalent command with Visual Studio Code is `dotnet clean`
    .
  prefs: []
  type: TYPE_NORMAL
- en: The `obj` folder contains one compiled *object* file for each source code file.
    These objects haven't been linked together into a final executable yet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `bin` folder contains the *binary* executable for the application or class
    library. We will look at this in more detail in *Chapter 7* , *Packaging and Distributing
    .NET Types* .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing top-level programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might be thinking that was a lot of code just to output `Hello, C#!` .
  prefs: []
  type: TYPE_NORMAL
- en: Although the boilerplate code is written for you by the project template, is
    there a simpler way?
  prefs: []
  type: TYPE_NORMAL
- en: Well, in C# 9 or later, there is, and it is known as **top-level programs**
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compare the console app created by the project template, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System;
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: HelloCS
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Program
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: Main
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '[] args'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine("Hello World!"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'To the new top-level program minimum console app, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System;
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine("Hello World!"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: That is a lot simpler, right? If you had to start with a blank file and write
    all the statements yourself, this is better. But how does it work?
  prefs: []
  type: TYPE_NORMAL
- en: During compilation, all the boilerplate code to define a namespace, the `Program`
    class, and its `Main` method, is generated and wrapped around the statements you
    write.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key points to remember about top-level programs include the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Any `using` statements still must to go at the top of the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There can be only one file like this in a project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `using System;` statement at the top of the file imports the `System` namespace.
    This enables the `Console.WriteLine` statement to work. You will learn more about
    namespaces in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a second project using Visual Studio 2022
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s add a second project to our solution to explore top-level programs:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, navigate to **File** | **Add** | **New Project** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Add a new project** dialog, in **Recent project templates** , select
    **Console Application [C#]** and then click **Next** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Configure your new project** dialog, for the **Project name** , enter
    `TopLevelProgram` , leave the location as `C:\Code\Chapter01` , and then click
    **Next** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Additional information** dialog, select **.NET 6.0 (Long-term support)**
    , and then click **Create** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Solution Explorer** , in the `TopLevelProgram` project, double-click `Program.cs`
    to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs` , note the code consists of only a comment and a single statement
    because it uses the top-level program feature introduced in C# 9, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // See https://aka.ms/new-console-template for more information
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine("Hello, World!"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But when I introduced the concept of top-level programs earlier, we needed a
    `using System;` statement. Why don't we need that here?
  prefs: []
  type: TYPE_NORMAL
- en: Implicitly imported namespaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The trick is that we do still need to import the `System` namespace, but it
    is now done for us using a feature introduced in C# 10\. Let''s see how:'
  prefs: []
  type: TYPE_NORMAL
- en: In **Solution Explorer** , select the `TopLevelProgram` project and toggle on
    the **Show All Files** button, and note that the compiler-generated `bin` and
    `obj` folders are visible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the `obj` folder, expand the `Debug` folder, expand the `net6.0` folder,
    and open the file named `TopLevelProgram.GlobalUsings.g.cs` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that this file is automatically created by the compiler for projects that
    target .NET 6, and that it uses a feature introduced in C# 10 called **global
    imports** that imports some commonly used namespaces like `System` for use in
    all code files, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // <autogenerated />
  prefs: []
  type: TYPE_NORMAL
- en: global
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: global
  prefs: []
  type: TYPE_NORMAL
- en: ::System;
  prefs: []
  type: TYPE_NORMAL
- en: global
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: global
  prefs: []
  type: TYPE_NORMAL
- en: ::System.Collections.Generic;
  prefs: []
  type: TYPE_NORMAL
- en: global
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: global
  prefs: []
  type: TYPE_NORMAL
- en: ::System.IO;
  prefs: []
  type: TYPE_NORMAL
- en: global
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: global
  prefs: []
  type: TYPE_NORMAL
- en: ::System.Linq;
  prefs: []
  type: TYPE_NORMAL
- en: global
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: global
  prefs: []
  type: TYPE_NORMAL
- en: ::System.Net.Http;
  prefs: []
  type: TYPE_NORMAL
- en: global
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: global
  prefs: []
  type: TYPE_NORMAL
- en: ::System.Threading;
  prefs: []
  type: TYPE_NORMAL
- en: global
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: global
  prefs: []
  type: TYPE_NORMAL
- en: ::System.Threading.Tasks;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: I will explain more about this feature in the next chapter. For now, just note
    that a significant change between .NET 5 and .NET 6 is that many of the project
    templates, like the one for console applications, use new language features to
    hide what is really happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `TopLevelProgram` project, in `Program.cs` , modify the statement to
    output a different message and the version of the operating system, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine("Hello from a Top Level Program!"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(Environment.OSVersion.VersionString);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In **Solution Explorer** , right-click the **Chapter01** solution, select **Set
    Startup Projects…** , set **Current selection** , and then click **OK** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Solution Explorer** , click the **TopLevelProgram** project (or any file
    or folder within it), and note that Visual Studio indicates that **TopLevelProgram**
    is now the startup project by making the project name bold.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Debug** | **Start Without Debugging** to run the **TopLevelProgram**
    project, and note the result, as shown in *Figure 1.8* :![](img/Image00014.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 1.8: Running a top-level program in a Visual Studio solution with two
    projects on Windows'
  prefs: []
  type: TYPE_NORMAL
- en: Building console apps using Visual Studio Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this section is to showcase how to build a console app using Visual
    Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: If you never want to try Visual Studio Code or .NET Interactive Notebooks, then
    please feel free to skip this section and the next, and then continue with the
    *Reviewing the folders and files for projects* section.
  prefs: []
  type: TYPE_NORMAL
- en: Both the instructions and screenshots in this section are for Windows, but the
    same actions will work with Visual Studio Code on the macOS and Linux variants.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main differences will be native command-line actions such as deleting a
    file: both the command and the path are likely to be different on Windows or macOS
    and Linux. Luckily, the `dotnet` command-line tool will be identical on all platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: Managing multiple projects using Visual Studio Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio Code has a concept named a **workspace** that allows you to open
    and manage multiple projects simultaneously. We will use a workspace to manage
    the two projects that you will create in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code using Visual Studio Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started writing code!
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that you do not have any open files, folders, or workspaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **File** | **Save Workspace As…** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the dialog box, navigate to your user folder on macOS (mine is named `markjprice`
    ), your `Documents` folder on Windows, or any directory or drive in which you
    want to save your projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **New Folder** button and name the folder `Code` . (If you completed
    the section for Visual Studio 2022, then this folder will already exist.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Code` folder, create a new folder named `Chapter01-vscode` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Chapter01-vscode` folder, save the workspace as `Chapter01.code-workspace`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **File** | **Add Folder to Workspace…** or click the **Add Folder**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Chapter01-vscode` folder, create a new folder named `HelloCS` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `HelloCS` folder and click the **Add** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **View** | **Terminal** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are deliberately going to use the older project template for .NET 5.0 to
    see what a full console application looks like. In the next section, you will
    create a console application using .NET 6.0 and see what has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In **TERMINAL** , make sure that you are in the `HelloCS` folder, and then
    use the `dotnet` command-line tool to create a new console app that targets .NET
    5.0, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: dotnet new console -f net5.0
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You will see that the `dotnet` command-line tool creates a new **Console Application**
    project for you in the current folder, and the **EXPLORER** window shows the two
    files created, `HelloCS.csproj` and `Program.cs` , and the `obj` folder, as shown
    in *Figure 1.9* :![](img/Image00015.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 1.9: The EXPLORER window will show that two files and a folder have
    been created'
  prefs: []
  type: TYPE_NORMAL
- en: 'In **EXPLORER** , click on the file named `Program.cs` to open it in the editor
    window. The first time that you do this, Visual Studio Code may have to download
    and install C# dependencies like OmniSharp, .NET Core Debugger, and Razor Language
    Server, if it did not do this when you installed the C# extension or if they need
    updating. Visual Studio Code will show progress in the **Output** window and eventually
    the message `Finished` , as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Installing C# dependencies...
  prefs: []
  type: TYPE_NORMAL
- en: 'Platform: win32, x86_64'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading package 'OmniSharp for Windows (.NET 4.6 / x64)' (36150 KB)....................
    Done!
  prefs: []
  type: TYPE_NORMAL
- en: Validating download...
  prefs: []
  type: TYPE_NORMAL
- en: Integrity Check succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: Installing package 'OmniSharp for Windows (.NET 4.6 / x64)'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading package '.NET Core Debugger (Windows / x64)' (45048 KB)....................
    Done!
  prefs: []
  type: TYPE_NORMAL
- en: Validating download...
  prefs: []
  type: TYPE_NORMAL
- en: Integrity Check succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: Installing package '.NET Core Debugger (Windows / x64)'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading package 'Razor Language Server (Windows / x64)' (52344 KB)....................
    Done!
  prefs: []
  type: TYPE_NORMAL
- en: Installing package 'Razor Language Server (Windows / x64)'
  prefs: []
  type: TYPE_NORMAL
- en: Finished
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding output is from Visual Studio Code on Windows. When run on macOS
    or Linux, the output will look slightly different, but the equivalent components
    for your operating system will be downloaded and installed.
  prefs: []
  type: TYPE_NORMAL
- en: Folders named `obj` and `bin` will have been created and when you see a notification
    saying that required assets are missing, click **Yes** , as shown in *Figure 1.10*
    :![Graphical user interface, text, application, email Description automatically
    generated](img/Image00016.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 1.10: Warning message to add required build and debug assets'
  prefs: []
  type: TYPE_NORMAL
- en: If the notification disappears before you can interact with it, then you can
    click the bell icon in the far-right corner of the status bar to show it again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a few seconds, another folder named `.vscode` will be created with some
    files that are used by Visual Studio Code to provide features like IntelliSense
    during debugging, which you will learn more about in *Chapter 4* , *Writing, Debugging,
    and Testing Functions* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Program.cs` , modify line 9 so that the text that is being written to the
    console says `Hello, C#!`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice** : Navigate to **File** | **Auto Save** . This toggle will
    save the annoyance of remembering to save before rebuilding your application each
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and running code using the dotnet CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next task is to compile and run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to **View** | **Terminal** and enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: dotnet run
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The output in the **TERMINAL** window will show the result of running your application,
    as shown in *Figure 1.11* :![Graphical user interface, text, application, email
    Description automatically generated](img/Image00017.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 1.11: The output of running your first console application'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a second project using Visual Studio Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s add a second project to our workspace to explore top-level programs:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio Code, navigate to **File** | **Add Folder to Workspace…** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Chapter01-vscode` folder, use the **New Folder** button to create a
    new folder named `TopLevelProgram` , select it, and click **Add** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Terminal** | **New Terminal** , and in the drop-down list that
    appears, select **TopLevelProgram** . Alternatively, in **EXPLORER** , right-click
    the `TopLevelProgram` folder and then select **Open in Integrated Terminal** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In **TERMINAL** , confirm that you are in the `TopLevelProgram` folder, and
    then enter the command to create a new console application, as shown in the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: dotnet new console
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : When using workspaces, be careful when entering commands
    in **TERMINAL** . Be sure that you are in the correct folder before entering potentially
    destructive commands! That is why I got you to create a new terminal for `TopLevelProgram`
    before issuing the command to create a new console app.'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **View** | **Command Palette** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter `omni` , and then, in the drop-down list that appears, select **OmniSharp:
    Select Project** .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the drop-down list of two projects, select the **TopLevelProgram** project,
    and when prompted, click **Yes** to add required assets to debug.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice** : To enable debugging and other useful features, like code
    formatting and Go to Definition, you must tell OmniSharp which project you are
    actively working on in Visual Studio Code. You can quickly toggle active projects
    by clicking the project/folder to the right of the flame icon on the left side
    of the status bar.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In **EXPLORER** , in the `TopLevelProgram` folder, select `Program.cs` , and
    then change the existing statement to output a different message and also output
    the operating system version string, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine("Hello from a Top Level Program!"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(Environment.OSVersion.VersionString);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In **TERMINAL** , enter the command to run a program, as shown in the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: dotnet run
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Note the output in the **TERMINAL** window, as shown in *Figure 1.12* :![](img/Image00018.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 1.12: Running a top-level program in a Visual Studio Code workspace
    with two projects on Windows'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to run the program on macOS Big Sur, the environment operating
    system would be different, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Hello from a Top Level Program!
  prefs: []
  type: TYPE_NORMAL
- en: Unix 11.2.3
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Managing multiple files using Visual Studio Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have multiple files that you want to work with at the same time, then
    you can put them side by side as you edit them:'
  prefs: []
  type: TYPE_NORMAL
- en: In **EXPLORER** , expand the two projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open both `Program.cs` files from the two projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click, hold, and drag the edit window tab for one of your open files to arrange
    them so that you can see both files at the same time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exploring code using .NET Interactive Notebooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET Interactive Notebooks makes writing code even easier than top-level programs.
    It requires Visual Studio Code, so if you did not install it earlier, please install
    it now.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a notebook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to create a notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio Code, close any open workspaces or folders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **View** | **Command Palette** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type `.net inter` , and then select **.NET Interactive: Create new blank notebook**
    , as shown in *Figure 1.13* :![](img/Image00019.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 1.13: Creating a new blank .NET notebook'
  prefs: []
  type: TYPE_NORMAL
- en: When prompted to select the file extension, choose **Create as '.dib'** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.dib` is an experimental file format defined by Microsoft to avoid confusion
    and compatibility issues with the .`ipynb` format used by Python interactive notebooks.
    The file extension was historically only for Jupyter notebooks that can contain
    an interactive (I) mix of data, Python code (PY), and output in a notebook file
    (NB). With .NET Interactive Notebooks, the concept has expanded to allow a mix
    of C#, F#, SQL, HTML, JavaScript, Markdown, and other languages. `.dib` is polyglot,
    meaning it supports mixed languages. Conversion between the `.dib` and `.ipynb`
    file formats is supported.'
  prefs: []
  type: TYPE_NORMAL
- en: Select **C#** for the default language for code cells in the notebook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If a newer version of .NET Interactive is available, you might have to wait
    for it to uninstall the older version and install the newer one. Navigate to **View**
    | **Output** and select **.NET Interactive : diagnostics** in the drop-down list.
    Please be patient. It can take a few minutes for the notebook to appear because
    it has to start up a hosting environment for .NET. If nothing happens after a
    few minutes, then close Visual Studio Code and restart it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the .NET Interactive Notebooks extension is downloaded and installed,
    the **OUTPUT** window diagnostics will show that a Kernel process has started
    (your process and port number will be different from the output below), as shown
    in the following output, which has been edited to save space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Extension started for VS Code Stable.
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: Kernel process 12516 Port 59565 is using tunnel uri http://localhost:59565/
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Writing and running code in a notebook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we can write code in the notebook cells:'
  prefs: []
  type: TYPE_NORMAL
- en: The first cell should already be set to **C# (.NET Interactive)** , but if it
    is set to anything else, then click the language selector in the bottom-right
    corner of the code cell and then select **C# (.NET Interactive)** as the language
    mode for that cell, and note your other choices of language for a code cell, as
    shown in *Figure 1.14* :![](img/Image00020.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 1.14: Changing the language for a code cell in a .NET Interactive notebook'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the **C# (.NET Interactive)** code cell, enter a statement to output
    a message to the console, and note that you do not need to end the statement with
    a semicolon, as you normally would in a full application, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine("Hello, .NET Interactive!"
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Execute Cell** button to the left of the code cell and note the
    output that appears in the gray box under the code cell, as shown in *Figure 1.15*
    :![](img/Image00021.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 1.15: Running code in a notebook and seeing the output below'
  prefs: []
  type: TYPE_NORMAL
- en: Saving a notebook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like any other file, we should save the notebook before continuing further:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **File** | **Save As…** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change to the `Chapter01-vscode` folder and save the notebook as `Chapter01.dib`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the `Chapter01.dib` editor tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding Markdown and special commands to a notebook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can mix and match cells containing Markdown and code with special commands:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **File** | **Open File…** , and select the `Chapter01.dib` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are prompted with `Do you` `trust the authors of these files?` , click
    **Open** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hover your mouse above the code block and click **+ Markup** to add a Markdown
    cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type a heading level 1, as shown in the following Markdown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 - Hello, C#! Welcome, .NET!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mixing *rich*
  prefs: []
  type: TYPE_NORMAL
- en: '**text**'
  prefs: []
  type: TYPE_NORMAL
- en: and code is cool!
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Click the tick in the top-right corner of the cell to stop editing the cell
    and view the processed Markdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your cells are in the wrong order, then you can drag and drop to rearrange
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Hover between the Markdown cell and the code cell and click **+ Code** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type a special command to output version information about .NET Interactive,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '#!about'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Execute Cell** button and note the output, as shown in *Figure 1.16*
    :![](img/Image00022.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 1.16: Mixing Markdown, code, and special commands in a .NET Interactive
    notebook'
  prefs: []
  type: TYPE_NORMAL
- en: Executing code in multiple cells
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you have multiple code cells in a notebook, you must execute the preceding
    code cells before their context becomes available in subsequent code cells:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the notebook, add a new code cell, and then type a statement
    to declare a variable and assign an integer value, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: number = 8
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the notebook, add a new code cell, and then type a statement
    to output the `number` variable, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(number);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Note the second code cell does not know about the `number` variable because
    it was defined and assigned in another code cell, aka context, as shown in *Figure
    1.17* :![](img/Image00023.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 1.17: The number variable does not exist in the current cell or context'
  prefs: []
  type: TYPE_NORMAL
- en: In the first cell, click the **Execute Cell** button to declare and assign a
    value to the variable, and then in the second cell, click the **Execute Cell**
    button to output the `number` variable, and note that this works. (Alternatively,
    in the first cell, you can click the **Execute Cell and Below** button.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice** : If you have related code split between two cells, remember
    to execute the preceding cell before executing the subsequent cell. At the top
    of the notebook, there are the following buttons – **Clear Outputs** and **Run
    All** . These are very handy because you can click one and then the other to ensure
    that all code cells are executed properly, as long as they are in the correct
    order.'
  prefs: []
  type: TYPE_NORMAL
- en: Using .NET Interactive Notebooks for the code in this book
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Throughout the rest of the chapters, I will not give explicit instructions
    to use notebooks, but the GitHub repository for the book has solution notebooks
    when appropriate. I expect many readers will want to run my pre-created notebooks
    for language and library features covered in *Chapters 2* to *12* , which they
    want to see in action and learn about without having to write a complete application,
    even if it is just a console app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/tree/main/notebooks](https://github.com/markjprice/cs10dotnet6/tree/main/notebooks)'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the folders and files for projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you created two projects named `HelloCS` and `TopLevelProgram`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code uses a workspace file to manage multiple projects. Visual
    Studio 2022 uses a solution file to manage multiple projects. You also created
    a .NET Interactive notebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is a folder structure and files that will be repeated in subsequent
    chapters, although with more than just two projects, as shown in *Figure 1.18*
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.18: Folder structure and files for the two projects in this chapter'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the common folders and files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although `.code-workspace` and `.sln` files are different, the project folders
    and files such as `HelloCS` and `TopLevelProgram` are identical for Visual Studio
    2022 and Visual Studio Code. This means that you can mix and match between both
    code editors if you like:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio 2022, with a solution open, navigate to **File** | **Add Existing
    Project…** to add a project file created by another tool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Visual Studio Code, with a workspace open, navigate to **File** | **Add Folder
    to Workspace…** to add a project folder created by another tool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice** : Although the source code, like the `.csproj` and `.cs`
    files, is identical, the `bin` and `obj` folders that are automatically generated
    by the compiler could have mismatched file versions that give errors. If you want
    to open the same project in both Visual Studio 2022 and Visual Studio Code, delete
    the temporary `bin` and `obj` folders before opening the project in the other
    code editor. This is why I asked you to create a different folder for the Visual
    Studio Code solutions in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the solution code on GitHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The solution code in the GitHub repository for this book includes separate
    folders for Visual Studio Code, Visual Studio 2022, and .NET Interactive notebook
    files, as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio 2022 solutions: [https://github.com/markjprice/cs10dotnet6/tree/main/vs4win](https://github.com/markjprice/cs10dotnet6/tree/main/vs4win)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Visual Studio Code solutions: [https://github.com/markjprice/cs10dotnet6/tree/main/vscode](https://github.com/markjprice/cs10dotnet6/tree/main/vscode)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET Interactive Notebook solutions: [https://github.com/markjprice/cs10dotnet6/tree/main/notebooks](https://github.com/markjprice/cs10dotnet6/tree/main/notebooks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice** : If you need to, return to this chapter to remind yourself
    how to create and manage multiple projects in the code editor of your choice.
    The GitHub repository has step-by-step instructions for four code editors (Visual
    Studio 2022 for Windows, Visual Studio Code, Visual Studio 2022 for Mac, and JetBrains
    Rider), along with additional screenshots: [https://github.com/markjprice/cs10dotnet6/blob/main/docs/code-editors/](https://github.com/markjprice/cs10dotnet6/blob/main/docs/code-editors/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Making good use of the GitHub repository for this book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git is a commonly used source code management system. GitHub is a company, website,
    and desktop application that makes it easier to manage Git. Microsoft purchased
    GitHub in 2018, so it will continue to get closer integration with Microsoft tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'I created a GitHub repository for this book, and I use it for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: To store the solution code for the book that can be maintained after the print
    publication date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To provide extra materials that extend the book, like errata fixes, small improvements,
    lists of useful links, and longer articles that cannot fit in the printed book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To provide a place for readers to get in touch with me if they have issues with
    the book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raising issues with the book
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you get stuck following any of the instructions in this book, or if you
    spot a mistake in the text or the code in the solutions, please raise an issue
    in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your favorite browser to navigate to the following link: [https://github.com/markjprice/cs10dotnet6/issues](https://github.com/markjprice/cs10dotnet6/issues)
    .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **New Issue** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter as much detail as possible that will help me to diagnose the issue. For
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your operating system, for example, Windows 11 64-bit, or macOS Big Sur version
    11.2.3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your hardware, for example, Intel, Apple Silicon, or ARM CPU.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your code editor, for example, Visual Studio 2022, Visual Studio Code, or something
    else, including the version number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As much of your code and configuration that you feel is relevant and necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Description of expected behavior and the behavior experienced.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Screenshots (if possible).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing this book is a side hustle for me. I have a full-time job, so I mostly
    work on the book at weekends. This means that I cannot always respond immediately
    to issues. But I want all my readers to be successful with my book, so if I can
    help you (and others) without too much trouble, then I will gladly do so.
  prefs: []
  type: TYPE_NORMAL
- en: Giving me feedback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you'd like to give me more general feedback about the book, then the GitHub
    repository `README.md` page has links to some surveys. You can provide the feedback
    anonymously, or if you would like a response from me, then you can supply an email
    address. I will only use this email address to answer your feedback.
  prefs: []
  type: TYPE_NORMAL
- en: I love to hear from my readers about what they like about my book, as well as
    suggestions for improvements and how they are working with C# and .NET, so don't
    be shy. Please get in touch!
  prefs: []
  type: TYPE_NORMAL
- en: Thank you in advance for your thoughtful and constructive feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading solution code from the GitHub repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I use GitHub to store solutions to all the hands-on, step-by-step coding examples
    throughout chapters and the practical exercises that are featured at the end of
    each chapter. You will find the repository at the following link: [https://github.com/markjprice/cs10dotnet6](https://github.com/markjprice/cs10dotnet6)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you just want to download all the solution files without using Git, click
    the green **Code** button and then select **Download ZIP** , as shown in *Figure
    1.19* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table Description automatically generated](img/Image00025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.19: Downloading the repository as a ZIP file'
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you add the preceding link to your favorite bookmarks because
    I also use the GitHub repository for this book for publishing errata (corrections)
    and other useful links.
  prefs: []
  type: TYPE_NORMAL
- en: Using Git with Visual Studio Code and the command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio Code has support for Git, but it will use your operating system's
    Git installation, so you must install Git 2.0 or later first before you get these
    features.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install Git from the following link: [https://git-scm.com/download](https://git-scm.com/download)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you like to use a GUI, you can download GitHub Desktop from the following
    link: [https://desktop.github.com](https://desktop.github.com) .'
  prefs: []
  type: TYPE_NORMAL
- en: Cloning the book solution code repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s clone the book solution code repository. In the steps that follow, you
    will use the Visual Studio Code terminal, but you could enter the commands at
    any command prompt or terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder named `Repos-vscode` in your user or `Documents` folder, or
    wherever you want to store your Git repositories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, open the `Repos-vscode` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to **View** | **Terminal** , and enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: git clone https://github.com/markjprice/cs10dotnet6.git
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Note that cloning all the solutions for all of the chapters will take a minute
    or so, as shown in *Figure 1.20* :![Graphical user interface, text, application,
    email Description automatically generated](img/Image00026.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 1.20: Cloning the book solution code using Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: Looking for help
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is all about how to find quality information about programming
    on the web.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Microsoft documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The definitive resource for getting help with Microsoft developer tools and
    platforms is Microsoft Docs, and you can find it at the following link: [https://docs.microsoft.com/](https://docs.microsoft.com/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Getting help for the dotnet tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the command line, you can ask the `dotnet` tool for help with its commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To open the official documentation in a browser window for the `dotnet new`
    command, enter the following at the command line or in the Visual Studio Code
    terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: dotnet help new
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get help output at the command line, use the `-h` or `--help` flag, as shown
    in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: dotnet new console -h
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Console Application (C#)
  prefs: []
  type: TYPE_NORMAL
- en: 'Author: Microsoft'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: A project for creating a command-line application that can run
    on .NET Core on Windows, Linux and macOS'
  prefs: []
  type: TYPE_NORMAL
- en: 'Options:'
  prefs: []
  type: TYPE_NORMAL
- en: -f|--framework. The target framework for the project.
  prefs: []
  type: TYPE_NORMAL
- en: net6.0           - Target net6.0
  prefs: []
  type: TYPE_NORMAL
- en: net5.0           - Target net5.0
  prefs: []
  type: TYPE_NORMAL
- en: netcoreapp3.1\.   - Target netcoreapp3.1
  prefs: []
  type: TYPE_NORMAL
- en: netcoreapp3.0\.   - Target netcoreapp3.0
  prefs: []
  type: TYPE_NORMAL
- en: 'Default: net6.0'
  prefs: []
  type: TYPE_NORMAL
- en: --langVersion    Sets langVersion in the created project file text – Optional
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Getting definitions of types and their members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most useful features of a code editor is **Go To Definition** . It
    is available in Visual Studio Code and Visual Studio 2022\. It will show what
    the public definition of the type or member looks like by reading the metadata
    in the compiled assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Some tools, such as ILSpy .NET Decompiler, will even reverse-engineer from the
    metadata and IL code back into C# for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to use the **Go To Definition** feature:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio 2022 or Visual Studio Code, open the solution/workspace named
    `Chapter01` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `HelloCS` project, in `Program.cs` , in `Main` , enter the following
    statement to declare an integer variable named `z` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: z;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Click inside `int` and then right-click and choose **Go To Definition** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the code window that appears, you can see how the `int` data type is defined,
    as shown in *Figure 1.21* :![Graphical user interface, text, application Description
    automatically generated](img/Image00027.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 1.21: The int data type metadata'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that `int` :'
  prefs: []
  type: TYPE_NORMAL
- en: Is defined using the `struct` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is in the `System.Runtime` assembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is in the `System` namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is named `Int32`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is therefore an alias for the `System.Int32` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements interfaces such as `IComparable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has constant values for its maximum and minimum values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has methods such as `Parse`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice** : When you try to use **Go To Definition** in Visual Studio
    Code, you will sometimes see an error saying **No definition found** . This is
    because the C# extension does not know about the current project. To fix this
    issue, navigate to **View** | **Command Palette** , enter `omni` , select **OmniSharp:
    Select Project** , and then select the project that you want to work with.'
  prefs: []
  type: TYPE_NORMAL
- en: Right now, the **Go To Definition** feature is not that useful to you because
    you do not yet know what all of this information means.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the first part of this book, which consists of *Chapters* *2*
    to *6* , and which teaches you about C#, you will know enough for this feature
    to become very handy.
  prefs: []
  type: TYPE_NORMAL
- en: In the code editor window, scroll down to find the `Parse` method with a single
    `string` parameter on line 106, and the comments that document it on lines 86
    to 105, as shown in *Figure 1.22* :![Graphical user interface, text, application
    Description automatically generated](img/Image00028.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 1.22: The comments for the Parse method with a string parameter'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the comments, you will see that Microsoft has documented the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A summary that describes the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters like the `string` value that can be passed to the method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return value of the method, including its data type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three exceptions that might occur if you call this method, including `ArgumentNullException`
    , `FormatException` , and `OverflowException` . Now, we know that we could choose
    to wrap a call to this method in a `try` statement and which exceptions to catch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hopefully, you are getting impatient to learn what all this means!
  prefs: []
  type: TYPE_NORMAL
- en: Be patient for a little longer. You are almost at the end of this chapter, and
    in the next chapter, you will dive into the details of the C# language. But first,
    let's see where else you can look for help.
  prefs: []
  type: TYPE_NORMAL
- en: Looking for answers on Stack Overflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Stack Overflow is the most popular third-party website for getting answers
    to difficult programming questions. It''s so popular that search engines such
    as DuckDuckGo have a special way to write a query to search the site:'
  prefs: []
  type: TYPE_NORMAL
- en: Start your favorite web browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to [DuckDuckGo.com](https://duckduckgo.com/) , enter the following
    query, and note the search results, which are also shown in *Figure 1.23* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '!so securestring'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application Description automatically generated](img/Image00029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.23: Stack Overflow search results for securestring'
  prefs: []
  type: TYPE_NORMAL
- en: Searching for answers using Google
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can search Google with advanced search options to increase the likelihood
    of finding what you need:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to Google.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for information about `garbage collection` using a simple Google query,
    and note that you will probably see a lot of ads for garbage collection services
    in your local area before you see the Wikipedia definition of garbage collection
    in computer science.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Improve the search by restricting it to a useful site such as Stack Overflow,
    and by removing languages that we might not care about, such as C++, Rust, and
    Python, or by adding C# and .NET explicitly, as shown in the following search
    query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: garbage collection site:stackoverflow.com +C# -Java
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to the official .NET blog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To keep up to date with .NET, an excellent blog to subscribe to is the official
    .NET Blog, written by the .NET engineering teams, and you can find it at the following
    link: [https://devblogs.microsoft.com/dotnet/](https://devblogs.microsoft.com/dotnet/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Watching Scott Hanselman's videos
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scott Hanselman from Microsoft has an excellent YouTube channel about computer
    stuff they didn''t teach you: [http://computerstufftheydidntteachyou.com/](http://computerstufftheydidntteachyou.com/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: I recommend it to everyone working with computers.
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now test your knowledge and understanding by trying to answer some questions,
    getting some hands-on practice, and going into the topics covered throughout this
    chapter in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.1 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Try to answer the following questions, remembering that although most answers
    can be found in this chapter, you should do some online research or code writing
    to answer others:'
  prefs: []
  type: TYPE_NORMAL
- en: Is Visual Studio 2022 better than Visual Studio Code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is .NET 6 better than .NET Framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is .NET Standard and why is it still important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why can a programmer use different languages, for example, C# and F#, to write
    applications that run on .NET?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name of the entry point method of a .NET console application and
    how should it be declared?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a top-level program and how do you access any command-line arguments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do you type at the prompt to build and execute C# source code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some benefits of using .NET Interactive Notebooks to write C# code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where would you look for help for a C# keyword?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where would you look for solutions to common programming problems?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Appendix* , *Answers to the Test Your Knowledge Questions* , is available
    to download from a link in the README on the GitHub repository: [https://github.com/markjprice/cs10dotnet6](https://github.com/markjprice/cs10dotnet6)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.2 – Practice C# anywhere
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You don't need Visual Studio Code or even Visual Studio 2022 for Windows or
    Mac to write C#. You can go to .NET Fiddle – [https://dotnetfiddle.net/](https://dotnetfiddle.net/)
    – and start coding online.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.3 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A book is a curated experience. I have tried to find the right balance of topics
    to include in the printed book. Other content that I have written can be found
    in the GitHub repository for this book.
  prefs: []
  type: TYPE_NORMAL
- en: I believe that this book covers all the fundamental knowledge and skills a C#
    and .NET developer should have or be aware of. Some longer examples are best included
    as links to Microsoft documentation or third-party article authors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more details about the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-1---hello-c-welcome-net](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-1---hello-c-welcome-net)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up your development environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussed the similarities and differences between modern .NET, .NET Core, .NET
    Framework, Xamarin, and .NET Standard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used Visual Studio Code with the .NET SDK and Visual Studio 2022 for Windows
    to create some simple console applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used .NET Interactive Notebooks to execute snippets of code for learning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned how to download the solution code for this book from a GitHub repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, most importantly, learned how to find help.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to "speak" C#.
  prefs: []
  type: TYPE_NORMAL

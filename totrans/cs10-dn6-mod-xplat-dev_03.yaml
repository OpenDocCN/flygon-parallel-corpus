- en: '03'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '03'
- en: Controlling Flow, Converting Types, and Handling Exceptions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流，类型转换和异常处理
- en: This chapter is all about writing code that performs simple operations on variables,
    makes decisions, performs pattern matching, repeats statements or blocks, converts
    variable or expression values from one type to another, handles exceptions, and
    checks for overflows in number variables.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要讲述编写对变量执行简单操作的代码，做出决策，执行模式匹配，重复语句或块，将变量或表达式值从一种类型转换为另一种类型，处理异常，并检查数字变量的溢出。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Operating on variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对变量进行操作
- en: Understanding selection statements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解选择语句
- en: Understanding iteration statements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解迭代语句
- en: Casting and converting between types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换和类型转换
- en: Handling exceptions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异常
- en: Checking for overflow
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查溢出
- en: Operating on variables
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对变量进行操作
- en: '**Operators** apply simple operations such as addition and multiplication to
    **operands** such as variables and literal values. They usually return a new value
    that is the result of the operation that can be assigned to a variable.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**运算符**对**操作数**（如变量和文字值）应用简单的操作，如加法和乘法。它们通常返回一个新值，这个值是操作的结果，可以分配给一个变量。'
- en: 'Most operators are binary, meaning that they work on two operands, as shown
    in the following pseudocode:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数运算符是二元的，意味着它们作用于两个操作数，如下伪代码所示：
- en: '```cs'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: var
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: var
- en: resultOfOperation = firstOperand operator
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: resultOfOperation = firstOperand operator
- en: secondOperand;
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: secondOperand;
- en: '```'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Examples of binary operators include adding and multiplying, as shown in the
    following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 二元运算符的示例包括加法和乘法，如下代码所示：
- en: '```cs'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: x = 5
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: x = 5
- en: ;
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: int
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: y = 3
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: y = 3
- en: ;
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: int
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: resultOfAdding = x + y;
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: resultOfAdding = x + y;
- en: int
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: resultOfMultiplying = x * y;
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: resultOfMultiplying = x * y;
- en: '```'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Some operators are unary, meaning they work on a single operand, and can apply
    before or after the operand, as shown in the following pseudocode:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一些运算符是一元的，意味着它们作用于单个操作数，并且可以在操作数之前或之后应用，如下伪代码所示：
- en: '```cs'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: var
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: var
- en: resultOfOperation = onlyOperand operator
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: resultOfOperation = onlyOperand operator
- en: ;
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: var
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: var
- en: resultOfOperation2 = operator
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: resultOfOperation2 = operator
- en: onlyOperand;
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: onlyOperand;
- en: '```'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Examples of unary operators include incrementors and retrieving a type or its
    size in bytes, as shown in the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一元运算符的示例包括递增器和检索类型或其大小（以字节为单位），如下代码所示：
- en: '```cs'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: x = 5
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: x = 5
- en: ;
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: int
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: postfixIncrement = x++;
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 后缀递增= x++;
- en: int
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: prefixIncrement = ++x;
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀递增= ++x;
- en: Type theTypeOfAnInteger = typeof
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 整数的类型theTypeOfAnInteger = typeof
- en: (int
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: (int
- en: );
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: int
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: howManyBytesInAnInteger = sizeof
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: howManyBytesInAnInteger = sizeof
- en: (int
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: (int
- en: );
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'A ternary operator works on three operands, as shown in the following pseudocode:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 三元运算符作用于三个操作数，如下伪代码所示：
- en: '```cs'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: var
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: var
- en: resultOfOperation = firstOperand firstOperator
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: resultOfOperation = firstOperand firstOperator
- en: secondOperand secondOperator thirdOperand;
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: secondOperand secondOperator thirdOperand;
- en: '```'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Exploring unary operators
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索一元运算符
- en: 'Two common unary operators are used to increment, `++` , and decrement, `--`
    , a number. Let us write some example code to show how they work:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 两个常见的一元运算符用于递增，`++`，和递减，`--`，一个数字。让我们编写一些示例代码来展示它们是如何工作的：
- en: If you've completed the previous chapters, then you will already have a `Code`
    folder. If not, then you'll need to create it.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已经完成了前几章，那么您已经有了一个`Code`文件夹。如果没有，那么您需要创建它。
- en: 'Use your preferred coding tool to create a new console app, as defined in the
    following list:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的编码工具创建一个新的控制台应用程序，如下列表所示：
- en: 'Project template: **Console Application** / `console`'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `控制台`
- en: 'Workspace/solution file and folder: `Chapter03`'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作区/解决方案文件和文件夹：`第03章`
- en: 'Project file and folder: `Operators`'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`运算符`
- en: At the top of `Program.cs` , statically import `System.Console` .
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的顶部，静态导入`System.Console`。
- en: 'In `Program.cs` , declare two integer variables named `a` and `b` , set `a`
    to `3` , increment `a` while assigning the result to `b` , and then output their
    values, as shown in the following code:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，声明两个名为`a`和`b`的整数变量，将`a`设置为`3`，在将结果分配给`b`的同时递增`a`，然后输出它们的值，如下代码所示：
- en: '```cs'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: a = 3
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: a = 3
- en: ;
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: int
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: b = a++;
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: b = a++;
- en: WriteLine($"a is
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"a是
- en: '{a}'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '{a}'
- en: ', b is'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ，b是
- en: '{b}'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '{b}'
- en: '"'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Before running the console application, ask yourself a question: what do you
    think the value of `b` will be when output? Once you''ve thought about that, run
    the code, and compare your prediction against the actual result, as shown in the
    following output:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行控制台应用程序之前，问问自己一个问题：当输出时，你认为`b`的值会是多少？一旦你考虑过这个问题，运行代码，并将你的预测与实际结果进行比较，如下输出所示：
- en: '```cs'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: a is 4, b is 3
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: a是4，b是3
- en: '```'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The variable `b` has the value `3` because the `++` operator executes *after*
    the assignment; this is known as a **postfix operator** . If you need to increment
    *before* the assignment, then use the **prefix operator** .
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`b`的值为`3`，因为`++`运算符在分配之后执行；这被称为**后缀运算符**。如果您需要在分配之前递增，那么使用**前缀运算符**。
- en: 'Copy and paste the statements, and then modify them to rename the variables
    and use the prefix operator, as shown in the following code:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制并粘贴语句，然后修改它们以重命名变量并使用前缀运算符，如下代码所示：
- en: '```cs'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: c = 3
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: c = 3
- en: ;
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: int
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: d = ++c; // increment c before assigning it
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: d = ++c; // 在分配之前递增c
- en: WriteLine($"c is
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"c是
- en: '{c}'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '{c}'
- en: ', d is'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ，d是
- en: '{d}'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '{d}'
- en: '"'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Rerun the code and note the result, as shown in the following output:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行代码并注意结果，如下输出所示：
- en: '```cs'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: a is 4, b is 3
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: a是4，b是3
- en: c is 4, d is 4
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: c是4，d是4
- en: '```'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : Due to the confusion between prefix and postfix for the
    increment and decrement operators when combined with an assignment, the Swift
    programming language designers decided to drop support for this operator in version
    3\. My recommendation for usage in C# is to never combine the use of `++` and
    `--` operators with an assignment operator, `=` . Perform the operations as separate
    statements.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好的实践**：由于Swift编程语言设计者在版本3中决定放弃对这个运算符的支持，因为在与赋值运算符`=`结合使用时，增量和减量运算符的前缀和后缀之间的混淆，我建议在C#中永远不要将`++`和`--`运算符与赋值运算符`=`结合使用。将操作作为单独的语句执行。'
- en: Exploring binary arithmetic operators
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索二进制算术运算符
- en: 'Increment and decrement are unary arithmetic operators. Other arithmetic operators
    are usually binary and allow you to perform arithmetic operations on two numbers,
    as the following shows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 增量和减量是一元算术运算符。其他算术运算符通常是二元的，允许您对两个数字执行算术运算，如下所示：
- en: 'Add the statements to declare and assign values to two integer variables named
    `e` and `f` , and then apply the five common binary arithmetic operators to the
    two numbers, as shown in the following code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句来声明并为名为`e`和`f`的两个整数变量分配值，然后应用这两个数字的五个常见二进制算术运算符，如下面的代码所示：
- en: '```cs'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: e = 11
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: e = 11
- en: ;
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: int
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: f = 3
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: f = 3
- en: ;
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: WriteLine($"e is
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"e is
- en: '{e}'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '{e}'
- en: ', f is'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ', f is'
- en: '{f}'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '{f}'
- en: '"'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"e + f =
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"e + f =
- en: '{e + f}'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '{e + f}'
- en: '"'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"e - f =
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"e - f =
- en: '{e - f}'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '{e - f}'
- en: '"'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: WriteLine($"e * f =
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"e * f =
- en: '{e * f}'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '{e * f}'
- en: '"'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"e / f =
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"e / f =
- en: '{e / f}'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '{e / f}'
- en: '"'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"e % f =
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"e % f =
- en: '{e % f}'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '{e % f}'
- en: '"'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and note the result, as shown in the following output:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '```cs'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: e is 11, f is 3
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: e是11，f是3
- en: e + f = 14
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: e + f = 14
- en: e - f = 8
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: e - f = 8
- en: e * f = 33
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: e * f = 33
- en: e / f = 3
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: e / f = 3
- en: e % f = 2
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: e % f = 2
- en: '```'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: To understand the divide `/` and modulo `%` operators when applied to integers,
    you need to think back to primary school. Imagine you have eleven sweets and three
    friends.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解应用于整数的除法`/`和模数`%`运算符，您需要回想起小学时的情景。想象一下你有十一颗糖果和三个朋友。
- en: How can you divide the sweets between your friends? You can give three sweets
    to each of your friends, and there will be two left over. Those two sweets are
    the **modulus** , also known as the **remainder** after dividing. If you have
    twelve sweets, then each friend gets four of them, and there are none left over,
    so the remainder would be 0.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何在朋友之间分糖果？你可以给每个朋友三颗糖果，然后还剩两颗。这两颗糖果是**模数**，也称为除法后的**余数**。如果你有十二颗糖果，那么每个朋友得到四颗，没有剩下的，所以余数是0。
- en: 'Add statements to declare and assign a value to a `double` variable named `g`
    to show the difference between whole number and real number divisions, as shown
    in the following code:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句来声明并为名为`g`的`double`变量分配一个值，以显示整数和实数除法之间的区别，如下面的代码所示：
- en: '```cs'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: double
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: double
- en: g = 11.0
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: g = 11.0
- en: ;
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: WriteLine($"g is
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"g is
- en: '{g:N1}'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '{g:N1}'
- en: ', f is'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ', f is'
- en: '{f}'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '{f}'
- en: '"'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"g / f =
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"g / f =
- en: '{g / f}'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '{g / f}'
- en: '"'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and note the result, as shown in the following output:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '```cs'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: g is 11.0, f is 3
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: g是11.0，f是3
- en: g / f = 3.6666666666666665
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: g / f = 3.6666666666666665
- en: '```'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: If the first operand is a floating-point number, such as `g` with the value
    `11.0` , then the divide operator returns a floating-point value, such as `3.6666666666665`
    , rather than a whole number.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个操作数是浮点数，例如值为`11.0`的`g`，那么除法运算符返回浮点数值，例如`3.6666666666665`，而不是整数。
- en: Assignment operators
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: You have already been using the most common assignment operator, `=` .
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在使用最常见的赋值运算符`=`。
- en: 'To make your code more concise, you can combine the assignment operator with
    other operators like arithmetic operators, as shown in the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使您的代码更加简洁，您可以将赋值运算符与算术运算符等其他运算符结合起来，如下面的代码所示：
- en: '```cs'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: p = 6
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: p = 6
- en: ;
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: p += 3
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: p += 3
- en: ; // equivalent to p = p + 3;
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ; // 等同于 p = p + 3;
- en: p -= 3
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: p -= 3
- en: ; // equivalent to p = p - 3;
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ; // 等同于 p = p - 3;
- en: p *= 3
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: p *= 3
- en: ; // equivalent to p = p * 3;
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ; // 等同于 p = p * 3;
- en: p /= 3
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: p /= 3
- en: ; // equivalent to p = p / 3;
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ; // 等同于 p = p / 3;
- en: '```'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Exploring logical operators
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索逻辑运算符
- en: 'Logical operators operate on Boolean values, so they return either `true` or
    `false` . Let''s explore binary logical operators that operate on two Boolean
    values:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符操作布尔值，因此它们返回`true`或`false`。让我们探索作用于两个布尔值的二进制逻辑运算符：
- en: Use your preferred coding tool to add a new console app to the `Chapter03` workspace/solution
    named `BooleanOperators` .
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的编码工具将一个新的控制台应用添加到名为`BooleanOperators`的`Chapter03`工作区/解决方案中。
- en: In Visual Studio Code, select `BooleanOperators` as the active OmniSharp project.
    When you see the pop-up warning message saying that required assets are missing,
    click **Yes** to add them.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`BooleanOperators`作为活动的OmniSharp项目。当您看到弹出的警告消息说缺少所需的资产时，点击**是**以添加它们。
- en: In Visual Studio, set the start up project for the solution to the current selection.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，将解决方案的启动项目设置为当前选择。
- en: '**Good Practice** : Remember to statically import the `System.Console` type
    to simplify statements.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好的实践**：记住静态导入`System.Console`类型以简化语句。'
- en: 'In `Program.cs` , add statements to declare two Boolean variables with values
    of `true` and `false` , and then output truth tables showing the results of applying
    AND, OR, and XOR (exclusive OR) logical operators, as shown in the following code:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句来声明两个布尔变量，值为`true`和`false`，然后输出应用AND、OR和XOR（异或）逻辑运算符的真值表，如下面的代码所示：
- en: '```cs'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: bool
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: bool
- en: a = true
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: a = true
- en: ;
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: bool
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: bool
- en: b = false
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: b = false
- en: ;
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: WriteLine($"AND  | a     | b    "
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"AND  | a     | b    "
- en: );
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"a    |
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"a    |
- en: '{a & a,'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '{a & a,'
- en: '-5'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '-5'
- en: '}'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '|'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '{a & b,'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '{a & b,'
- en: '-5'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '-5'
- en: '}'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"b    |
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"b    |
- en: '{b & a,'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '{b & a,'
- en: '-5'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '-5'
- en: '}'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '|'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '{b & b,'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '{b & b,'
- en: '-5'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '-5'
- en: '}'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine();
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine();
- en: WriteLine($"OR   | a     | b    "
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"OR   | a     | b    "
- en: );
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"a    |
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"a    |
- en: '{a | a,'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '{a | a,'
- en: '-5'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '-5'
- en: '}'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '|'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '{a | b,'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '{a | b,'
- en: '-5'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '-5'
- en: '}'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"b    |
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"b    |
- en: '{b | a,'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '{b | a，'
- en: '-5'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '-5'
- en: '}'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '|'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '{b | b,'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '{b | b，'
- en: '-5'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '-5'
- en: '}'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: WriteLine();
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine（）;
- en: WriteLine($"XOR  | a     | b    "
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine（$“XOR  | a     | b    "
- en: );
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: WriteLine($"a    |
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine（$“a    |
- en: '{a ^ a,'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '{a ^ a，'
- en: '-5'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '-5'
- en: '}'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '|'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '{a ^ b,'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '{a ^ b，'
- en: '-5'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '-5'
- en: '}'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: WriteLine($"b    |
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine（$“b    |
- en: '{b ^ a,'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '{b ^ a，'
- en: '-5'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '-5'
- en: '}'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '|'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '{b ^ b,'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '{b ^ b，'
- en: '-5'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '-5'
- en: '}'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '```'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '```cs'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: AND  | a     | b
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: AND  | a     | b
- en: a    | True  | False
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: a    | 真  | 假
- en: b    | False | False
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: b    | 假 | 假
- en: OR   | a     | b
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: OR   | a     | b
- en: a    | True  | True
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: a    | 真  | 真
- en: b    | True  | False
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: b    | 真  | 假
- en: XOR  | a     | b
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: XOR  | a     | b
- en: a    | False | True
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: a    | 假 | 真
- en: b    | True  | False
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: b    | 真  | 假
- en: '```'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: For the AND `&` logical operator, both operands must be `true` for the result
    to be `true` . For the OR `|` logical operator, either operand can be `true` for
    the result to be `true` . For the XOR `^` logical operator, either operand can
    be `true` (but not both!) for the result to be `true` .
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 对于AND `&`逻辑运算符，两个操作数必须都为`true`才能得到`true`的结果。对于OR `|`逻辑运算符，任一操作数都可以为`true`才能得到`true`的结果。对于XOR
    `^`逻辑运算符，任一操作数都可以为`true`（但不能都为真！）才能得到`true`的结果。
- en: Exploring conditional logical operators
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索条件逻辑运算符
- en: Conditional logical operators are like logical operators, but you use two symbols
    instead of one, for example, `&&` instead of `&` , or `||` instead of `|` .
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 条件逻辑运算符类似于逻辑运算符，但您使用两个符号而不是一个，例如，`&&`而不是`&`，或`||`而不是`|`。
- en: In *Chapter 4* , *Writing, Debugging, and Testing Functions* , you will learn
    about functions in more detail, but I need to introduce functions now to explain
    conditional logical operators, also known as short-circuiting Boolean operators.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4章*，*编写、调试和测试函数*中，您将更详细地了解函数，但我现在需要介绍函数来解释条件逻辑运算符，也称为短路布尔运算符。
- en: 'A function executes statements and then returns a value. That value could be
    a Boolean value like `true` that is used in a Boolean operation. Let''s make use
    of conditional logical operators:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 函数执行语句，然后返回一个值。该值可以是布尔值，如`true`，用于布尔运算。让我们利用条件逻辑运算符：
- en: 'At the bottom of `Program.cs` , write statements to declare a function that
    writes a message to the console and returns `true` , as shown in the following
    code:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的底部，编写语句来声明一个向控制台写入消息并返回`true`的函数，如下面的代码所示：
- en: '```cs'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: static
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: bool
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔
- en: DoStuff
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: DoStuff
- en: ()
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: （）
- en: '{'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine("I am doing some stuff."
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine（“我正在做一些事情。”
- en: );
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: return
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: 'true'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 'true'
- en: ;
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : If you are using .NET Interactive Notebook, write the `DoStuff`
    function in a separate code cell and then execute it to make its context available
    to other code cells.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：如果您正在使用.NET交互式笔记本，请在单独的代码单元中编写`DoStuff`函数，然后执行它，以使其上下文可用于其他代码单元。'
- en: 'After the previous `WriteLine` statements, perform an AND `&` operation on
    the `a` and `b` variables and the result of calling the function, as shown in
    the following code:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前的`WriteLine`语句之后，对`a`和`b`变量以及调用函数的结果执行AND `&`操作，如下面的代码所示：
- en: '```cs'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: WriteLine();
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine（）;
- en: WriteLine($"a & DoStuff() =
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine（$“a & DoStuff（）=
- en: '{a & DoStuff()}'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '{a & DoStuff（）}'
- en: '"'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: WriteLine($"b & DoStuff() =
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine（$“b & DoStuff（）=
- en: '{b & DoStuff()}'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '{b & DoStuff（）}'
- en: '"'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '```'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code, view the result, and note that the function was called twice,
    once for a and once for b, as shown in the following output:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意函数被调用了两次，一次是为a，一次是为b，如下面的输出所示：
- en: '```cs'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: I am doing some stuff.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在做一些事情。
- en: a & DoStuff() = True
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: a & DoStuff（）= 真
- en: I am doing some stuff.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在做一些事情。
- en: b & DoStuff() = False
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: b & DoStuff（）= 假
- en: '```'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Change the `&` operators into `&&` operators, as shown in the following code:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`&`运算符更改为`&&`运算符，如下面的代码所示：
- en: '```cs'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: WriteLine($"a && DoStuff() =
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine（$“a && DoStuff（）=
- en: '{a && DoStuff()}'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '{a && DoStuff（）}'
- en: '"'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: WriteLine($"b && DoStuff() =
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine（$“b && DoStuff（）=
- en: '{b && DoStuff()}'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '{b && DoStuff（）}'
- en: '"'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '```'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code, view the result, and note that the function does run when combined
    with the `a` variable. It does not run when combined with the `b` variable because
    the `b` variable is `false` so the result will be `false` anyway, so it does not
    need to execute the function, as shown in the following output:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意当与变量`a`结合时，函数确实运行。当与变量`b`结合时，它不会运行，因为变量`b`是`false`，所以结果将是`false`，因此不需要执行函数，如下面的输出所示：
- en: '```cs'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: I am doing some stuff.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在做一些事情。
- en: a && DoStuff() = True
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: a && DoStuff（）= 真
- en: b && DoStuff() = False // DoStuff function was not executed!
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: b && DoStuff（）= 假 // DoStuff函数未被执行！
- en: '```'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : Now you can see why the conditional logical operators are
    described as being short-circuiting. They can make your apps more efficient, but
    they can also introduce subtle bugs in cases where you assume that the function
    would always be called. It is safest to avoid them when used in combination with
    functions that cause side effects.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：现在你可以看到为什么条件逻辑运算符被描述为短路。它们可以使您的应用程序更有效，但也可能在您假定函数总是被调用的情况下引入微妙的错误。在与引起副作用的函数结合使用时，最安全的做法是避免它们。'
- en: Exploring bitwise and binary shift operators
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索位运算和二进制移位运算符
- en: Bitwise operators affect the bits in a number. Binary shift operators can perform
    some common arithmetic calculations much faster than traditional operators, for
    example, any multiplication by a factor of 2.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算符影响数字中的位。二进制移位运算符可以比传统运算符更快地执行一些常见的算术计算，例如，任何乘以2的因子。
- en: 'Let''s explore bitwise and binary shift operators:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索位运算和二进制移位运算符：
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter03`
    workspace/solution named `BitwiseAndShiftOperators` .
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的编码工具将一个新的**控制台应用程序**添加到名为`BitwiseAndShiftOperators`的`Chapter03`工作区/解决方案中。
- en: In Visual Studio Code, select `BitwiseAndShiftOperators` as the active OmniSharp
    project. When you see the pop-up warning message saying that required assets are
    missing, click **Yes** to add them.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，将`BitwiseAndShiftOperators`选择为活动的OmniSharp项目。当看到弹出的警告消息说缺少所需的资产时，点击**是**添加它们。
- en: 'In `Program.cs` , type statements to declare two integer variables with values
    10 and 6, and then output the results of applying AND, OR, and XOR bitwise operators,
    as shown in the following code:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，输入语句声明两个整数变量，值分别为10和6，然后输出应用AND、OR和XOR位运算符的结果，如下面的代码所示：
- en: '```cs'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: a = 10
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: a = 10
- en: ; // 00001010
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ; // 00001010
- en: int
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: b = 6
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: b = 6
- en: ;  // 00000110
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ;  // 00000110
- en: WriteLine($"a =
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"a =
- en: '{a}'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '{a}'
- en: '"'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"b =
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"b =
- en: '{b}'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '{b}'
- en: '"'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"a & b =
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"a & b =
- en: '{a & b}'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '{a & b}'
- en: '"'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: ); // 2-bit column only
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ); // 2-bit column only
- en: WriteLine($"a | b =
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"a | b =
- en: '{a | b}'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '{a | b}'
- en: '"'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: ); // 8, 4, and 2-bit columns
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: ); // 8, 4, and 2-bit columns
- en: WriteLine($"a ^ b =
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"a ^ b =
- en: '{a ^ b}'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '{a ^ b}'
- en: '"'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: ); // 8 and 4-bit columns
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ); // 8 and 4-bit columns
- en: '```'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '```cs'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: a = 10
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: a = 10
- en: b = 6
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: b = 6
- en: a & b = 2
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: a & b = 2
- en: a | b = 14
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: a | b = 14
- en: a ^ b = 12
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: a ^ b = 12
- en: '```'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add statements to output the results of applying the left-shift
    operator to move the bits of the variable `a` by three columns, multiplying `a`
    by 8, and right-shifting the bits of the variable `b` by one column, as shown
    in the following code:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，添加语句输出将变量 `a` 的位移三列，将 `a` 乘以8，以及将变量 `b` 的位移一列的结果，如下面的代码所示：
- en: '```cs'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // 01010000 left-shift a by three bit columns
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: // 01010000 将a左移三位
- en: WriteLine($"a << 3 =
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"a << 3 =
- en: '{a <<'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '{a <<'
- en: '3'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '}'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: // multiply a by 8
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: // 将a乘以8
- en: WriteLine($"a * 8 =
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"a * 8 =
- en: '{a *'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '{a *'
- en: '8'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '}'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: // 00000011 right-shift b by one bit column
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: // 00000011 将b向右移动一位列
- en: WriteLine($"b >> 1 =
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"b >> 1 =
- en: '{b >>'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '{b >>'
- en: '1'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '}'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '```cs'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: a << 3 = 80
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: a << 3 = 80
- en: a * 8 = 80
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: a * 8 = 80
- en: b >> 1 = 3
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: b >> 1 = 3
- en: '```'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `80` result is because the bits in it were shifted three columns to the
    left, so the 1-bits moved into the 64- and 16-bit columns and 64 + 16 = 80\. This
    is the equivalent of multiplying by 8, but CPUs can perform a bit-shift faster.
    The 3 result is because the 1-bits in `b` were shifted one column into the 2-
    and 1-bit columns.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`80` 的结果是因为其中的位向左移了三列，所以1位移入了64位和16位列，64 + 16 = 80。这相当于乘以8，但CPU可以更快地执行位移。`3`
    的结果是因为 `b` 中的1位向右移了一列，进入了2位和1位列。'
- en: '**Good Practice** : Remember that when operating on integer values, the `&`
    and `|` symbols are bitwise operators, and when operating on Boolean values like
    `true` and `false` , the `&` and `|` symbols are logical operators.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：记住，在操作整数值时，`&` 和 `|` 符号是位运算符，在操作像 `true` 和 `false` 这样的布尔值时，`&` 和 `|`
    符号是逻辑运算符。'
- en: 'We can illustrate the operations by converting the integer values into binary
    strings of zeros and ones:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将整数值转换为由零和一组成的二进制字符串来说明这些操作：
- en: 'At the bottom of `Program.cs` , add a function to convert an integer value
    into a binary (Base2) `string` of up to eight zeros and ones, as shown in the
    following code:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 底部，添加一个函数，将整数值转换为最多八个零和一的二进制（Base2）`string`，如下面的代码所示：
- en: '```cs'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: static
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: static
- en: string
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: ToBinaryString
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: ToBinaryString
- en: (
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: int
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: value
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: value
- en: )
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: Convert.ToString(value
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: Convert.ToString(value
- en: ', toBase: 2'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: ', toBase: 2'
- en: ).PadLeft(8
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: ).PadLeft(8
- en: ', ''0'''
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: ', ''0'''
- en: );
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Above the function, add statements to output `a` , `b` , and the results of
    the various bitwise operators, as shown in the following code:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数上方，添加语句输出 `a` 、 `b` 和各种位运算符的结果，如下面的代码所示：
- en: '```cs'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: WriteLine();
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine();
- en: WriteLine("Outputting integers as binary:"
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("将整数输出为二进制："
- en: );
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"a =
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"a =
- en: '{ToBinaryString(a)}'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '{ToBinaryString(a)}'
- en: '"'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"b =
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"b =
- en: '{ToBinaryString(b)}'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '{ToBinaryString(b)}'
- en: '"'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"a & b =
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"a & b =
- en: '{ToBinaryString(a & b)}'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '{ToBinaryString(a & b)}'
- en: '"'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"a | b =
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"a | b =
- en: '{ToBinaryString(a | b)}'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '{ToBinaryString(a | b)}'
- en: '"'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"a ^ b =
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"a ^ b =
- en: '{ToBinaryString(a ^ b)}'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '{ToBinaryString(a ^ b)}'
- en: '"'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and note the results, as shown in the following output:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '```cs'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Outputting integers as binary:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 将整数输出为二进制：
- en: a =     00001010
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: a =     00001010
- en: b =     00000110
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: b =     00000110
- en: a & b = 00000010
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: a & b = 00000010
- en: a | b = 00001110
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: a | b = 00001110
- en: a ^ b = 00001100
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: a ^ b = 00001100
- en: '```'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Miscellaneous operators
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他运算符
- en: '`nameof` and `sizeof` are convenient operators when working with types:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '`nameof` 和 `sizeof` 在处理类型时是方便的运算符：'
- en: '`nameof` returns the short name (without the namespace) of a variable, type,
    or member as a `string` value, which is useful when outputting exception messages.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nameof` 在处理类型时是一个方便的运算符，它返回变量、类型或成员的短名称（不包括命名空间）作为 `string` 值，这在输出异常消息时很有用。'
- en: '`sizeof` returns the size in bytes of simple types, which is useful for determining
    the efficiency of data storage.'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sizeof` 返回简单类型的字节大小，这对于确定数据存储的效率很有用。'
- en: 'There are many other operators; for example, the dot between a variable and
    its members is called the **member access operator** and the round brackets at
    the end of a function or method name are called the **invocation operator** ,
    as shown in the following code:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他运算符；例如，变量和其成员之间的点被称为**成员访问运算符**，函数或方法名称末尾的圆括号被称为**调用运算符**，如下面的代码所示：
- en: '```cs'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: age = 47
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: age = 47
- en: ;
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: // How many operators in the following statement?
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: // 以下语句中有多少个运算符？
- en: char
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: char
- en: firstDigit = age.ToString()[0
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: firstDigit = age.ToString()[0
- en: '];'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '];'
- en: '// There are four operators:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: // 有四个运算符：
- en: // = is the assignment operator
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: // = 是赋值运算符
- en: // . is the member access operator
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: // . 是成员访问运算符
- en: // () is the invocation operator
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: // () 是调用运算符
- en: // [] is the indexer access operator
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: // [] 是索引器访问运算符
- en: '```'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Understanding selection statements
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解选择语句
- en: Every application needs to be able to select from choices and branch along different
    code paths. The two selection statements in C# are `if` and `switch` . You can
    use `if` for all your code, but `switch` can simplify your code in some common
    scenarios such as when there is a single variable that can have multiple values
    that each require different processing.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都需要能够从选择中进行选择，并沿着不同的代码路径进行分支。C#中的两个选择语句是`if`和`switch`。您可以在所有代码中使用`if`，但在一些常见情况下，例如存在一个可以具有多个值并且每个值都需要不同处理的单个变量时，`switch`可以简化您的代码。
- en: Branching with the if statement
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用if语句进行分支
- en: The `if` statement determines which branch to follow by evaluating a Boolean
    expression. If the expression is `true` , then the block executes. The `else`
    block is optional, and it executes if the `if` expression is `false` . The `if`
    statement can be nested.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句通过评估布尔表达式来确定要遵循哪个分支。如果表达式为`true`，则执行该块。`else`块是可选的，如果`if`表达式为`false`，则执行。`if`语句可以嵌套。'
- en: 'The `if` statement can be combined with other `if` statements as `else if`
    branches, as shown in the following code:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句可以与其他`if`语句组合为`else if`分支，如下面的代码所示：'
- en: '```cs'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: if
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (expression1)
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: （表达式1）
- en: '{'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // runs if expression1 is true
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: //当expression1为true时运行
- en: '}'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 否则
- en: if
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (expression2)
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: （表达式2）
- en: '{'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // runs if expression1 is false and expression2 if true
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: //当expression1为false且expression2为true时运行
- en: '}'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 否则
- en: if
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (expression3)
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: （表达式3）
- en: '{'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // runs if expression1 and expression2 are false
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: //当expression1和expression2为false时运行
- en: // and expression3 is true
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: //并且expression3为true
- en: '}'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 否则
- en: '{'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // runs if all expressions are false
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: //当所有表达式都为false时运行
- en: '}'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Each `if` statement's Boolean expression is independent of the others and, unlike
    `switch` statements, does not need to reference a single value.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`if`语句的布尔表达式是独立的，不像`switch`语句那样，不需要引用单个值。
- en: 'Let''s write some code to explore selection statements like `if` :'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来探索`if`等选择语句：
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter03`
    workspace/solution named `SelectionStatements` .
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的编码工具向`Chapter03`工作区/解决方案中添加一个新的**控制台应用程序**，命名为`SelectionStatements`。
- en: In Visual Studio Code, select `SelectionStatements` as the active OmniSharp
    project.
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`SelectionStatements`作为活动的OmniSharp项目。
- en: 'In `Program.cs` , type statements to check if a password is at least eight
    characters, as shown in the following code:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，键入语句以检查密码是否至少有八个字符，如下面的代码所示：
- en: '```cs'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: string
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: password = "ninja"
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 密码="ninja"
- en: ;
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: if
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (password.Length < 8
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: （密码长度<8
- en: )
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: ）
- en: '{'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine("Your password is too short. Use at least 8 characters."
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("您的密码太短。至少使用8个字符。"
- en: );
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 否则
- en: '{'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine("Your password is strong."
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("您的密码很强壮。"
- en: );
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and note the result, as shown in the following output:'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意结果，如下面的输出所示：
- en: '```cs'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Your password is too short. Use at least 8 characters.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 您的密码太短。至少使用8个字符。
- en: '```'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Why you should always use braces with if statements
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么您应该始终在if语句中使用大括号
- en: 'As there is only a single statement inside each block, the preceding code could
    be written without the curly braces, as shown in the following code:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个块内只有一个语句，因此前面的代码可以不使用大括号编写，如下面的代码所示：
- en: '```cs'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: if
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (password.Length < 8
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: （密码长度<8
- en: )
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: ）
- en: WriteLine("Your password is too short. Use at least 8 characters."
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("您的密码太短。至少使用8个字符。"
- en: );
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: else
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 否则
- en: WriteLine("Your password is strong."
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("您的密码很强壮。"
- en: );
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This style of `if` statement should be avoided because it can introduce serious
    bugs, for example, the infamous #gotofail bug in Apple''s iPhone iOS operating
    system.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 应该避免使用这种风格的`if`语句，因为它可能会引入严重的错误，例如苹果iPhone iOS操作系统中臭名昭著的#gotofail错误。
- en: For 18 months after Apple's iOS 6 was released, in September 2012, it had a
    bug in its **Secure Sockets Layer** (**SSL** ) encryption code, which meant that
    any user running Safari, the device's web browser, who tried to connect to secure
    websites, such as their bank, was not properly secure because an important check
    was being accidentally skipped.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果iOS 6发布后的18个月内，即2012年9月，其**安全套接字层**（**SSL**）加密代码中存在一个错误，这意味着运行Safari的任何用户，设备的网络浏览器，尝试连接到安全网站（例如他们的银行）时，由于一个重要的检查被意外跳过，因此并不安全。
- en: Just because you can leave out the curly braces doesn't mean you should. Your
    code is not "more efficient" without them; instead, it is less maintainable and
    potentially more dangerous.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为您可以省略大括号并不意味着您应该这样做。没有它们，您的代码并不会“更高效”；相反，它会更难维护，可能更危险。
- en: Pattern matching with the if statement
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用if语句进行模式匹配
- en: 'A feature introduced with C# 7.0 and later is pattern matching. The `if` statement
    can use the `is` keyword in combination with declaring a local variable to make
    your code safer:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.0及更高版本引入的一个功能是模式匹配。`if`语句可以使用`is`关键字与声明一个局部变量结合使用，使您的代码更安全：
- en: 'Add statements so that if the value stored in the variable named `o` is an
    `int` , then the value is assigned to the local variable named `i` , which can
    then be used inside the `if` statement. This is safer than using the variable
    named `o` because we know for sure that `i` is an `int` variable and not something
    else, as shown in the following code:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句，以便如果存储在名为`o`的变量中的值是`int`，则将该值分配给名为`i`的局部变量，然后可以在`if`语句中使用。这比使用名为`o`的变量更安全，因为我们确切知道`i`是一个`int`变量，而不是其他东西，如下面的代码所示：
- en: '```cs'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // add and remove the "" to change the behavior
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: //添加和删除""以更改行为
- en: object
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 对象
- en: o = "3"
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: o="3"
- en: ;
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: int
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: j = 4
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: j=4
- en: ;
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: if
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (o is
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: （o是
- en: int
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: i)
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: i）
- en: '{'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine($"
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"```
- en: '{i}'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '{i}'
- en: x
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: x
- en: '{j}'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '{j}'
- en: '='
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '='
- en: '{i * j}'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '{i*j}'
- en: '"'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 否则
- en: '{'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine("o is not an int so it cannot multiply!"
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("o不是int，因此无法相乘！"
- en: );
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the results, as shown in the following output:'
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: o is not an int so it cannot multiply!
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: o不是int，因此无法相乘！
- en: '```'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Delete the double-quote characters around the `"3"` value so that the value
    stored in the variable named `o` is an `int` type instead of a `string` type.
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除围绕“`3`”值的双引号字符，以便存储在名为`o`的变量中的值是`int`类型，而不是`string`类型。
- en: 'Rerun the code to view the results, as shown in the following output:'
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行代码以查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 3 x 4 = 12
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 3 x 4 = 12
- en: '```'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Branching with the switch statement
  id: totrans-605
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用switch语句进行分支
- en: 'The `switch` statement is different from the `if` statement because `switch`
    compares a single expression against a list of multiple possible `case` statements.
    Every `case` statement is related to the single expression. Every `case` section
    must end with:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句与`if`语句不同，因为`switch`将单个表达式与多个可能的`case`语句列表进行比较。每个`case`语句都与单个表达式相关。每个`case`部分必须以：'
- en: The `break` keyword (like case 1 in the following code)
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`break`关键字（就像下面代码中的case 1一样）'
- en: Or the `goto` `case` keywords (like case 2 in the following code)
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者`goto` `case`关键字（就像下面代码中的case 2一样）
- en: Or they should have no statements (like case 3 in the following code)
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者它们不应该有语句（就像下面代码中的case 3一样）
- en: Or the `goto` keyword that references a named label (like case 5 in the following
    code)
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者引用命名标签的`goto`关键字（就像下面代码中的case 5一样）
- en: Or the `return` keyword to leave the current function (not shown in the code)
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者`return`关键字离开当前函数（代码中未显示）
- en: 'Let''s write some code to explore the `switch` statements:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码来探索`switch`语句：
- en: 'Type statements for a `switch` statement. You should note that the penultimate
    statement is a label that can be jumped to, and the first statement generates
    a random number between 1 and 6 (the number 7 in the code is an exclusive upper
    bound). The `switch` statement branches are based on the value of this random
    number, as shown in the following code:'
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`switch`语句的类型语句。您应该注意，倒数第二个语句是可以跳转到的标签，第一个语句生成1到6之间的随机数（代码中的数字7是一个排他性的上限）。`switch`语句的分支基于这个随机数的值，如下面的代码所示：'
- en: '```cs'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: number = (new
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: number = (new
- en: Random()).Next(1
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: Random()).Next(1
- en: ', 7'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: ，7
- en: );
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: WriteLine($"My random number is
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"我的随机数是
- en: '{number}'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '{number}'
- en: '"'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: switch
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 开关
- en: (number)
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: （number）
- en: '{'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: case
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 案例
- en: '1'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: ':'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: ：
- en: WriteLine("One"
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("一个"
- en: );
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: break
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 休息
- en: ; // jumps to end of switch statement
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: ; // 跳转到switch语句的结尾
- en: case
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 案例
- en: '2'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: ':'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: ：
- en: WriteLine("Two"
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("二"
- en: );
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: goto
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 转到
- en: case
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 案例
- en: '1'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: ;
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: case
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 案例
- en: '3'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: ': // multiple case section'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: ： // 多个case部分
- en: case
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 案例
- en: '4'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: ':'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: ：
- en: WriteLine("Three or four"
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("三或四"
- en: );
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: goto
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 转到
- en: case
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 案例
- en: '1'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: ;
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: case
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 案例
- en: '5'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: ':'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: ：
- en: goto
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 转到
- en: A_label;
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: A_label;
- en: default
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 默认
- en: ':'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: ：
- en: WriteLine("Default"
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("默认"
- en: );
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: break
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 休息
- en: ;
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '} // end of switch statement'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '} // 结束switch语句'
- en: WriteLine("After end of switch"
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("开关结束后"
- en: );
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: 'A_label:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 'A_label:'
- en: WriteLine($"After A_label"
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"A_label之后"
- en: );
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : You can use the `goto` keyword to jump to another case
    or a label. The `goto` keyword is frowned upon by most programmers but can be
    a good solution to code logic in some scenarios. However, you should use it sparingly.'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：您可以使用`goto`关键字跳转到另一个case或标签。`goto`关键字受到大多数程序员的反对，但在某些情况下可以成为代码逻辑的良好解决方案。但是，您应该谨慎使用它。'
- en: 'Run the code multiple times to see what happens in various cases of random
    numbers, as shown in the following example output:'
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多次运行代码以查看在各种随机数情况下发生的情况，如下面的示例输出所示：
- en: '```cs'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // first random run
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: // 第一次随机运行
- en: My random number is 4
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 我的随机数是4
- en: Three or four
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 三或四
- en: One
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 一个
- en: After end of switch
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 开关结束后
- en: After A_label
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: A_label之后
- en: // second random run
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: // 第二次随机运行
- en: My random number is 2
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 我的随机数是2
- en: Two
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 二
- en: One
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 一个
- en: After end of switch
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 开关结束后
- en: After A_label
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: A_label之后
- en: // third random run
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: // 第三次随机运行
- en: My random number is 6
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 我的随机数是6
- en: Default
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 默认
- en: After end of switch
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 开关结束后
- en: After A_label
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: A_label之后
- en: // fourth random run
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: // 第四次随机运行
- en: My random number is 1
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 我的随机数是1
- en: One
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 一个
- en: After end of switch
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 开关结束后
- en: After A_label
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: A_label之后
- en: // fifth random run
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: // 第五次随机运行
- en: My random number is 5
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 我的随机数是5
- en: After A_label
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: A_label之后
- en: '```'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Pattern matching with the switch statement
  id: totrans-702
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用switch语句进行模式匹配
- en: Like the `if` statement, the `switch` statement supports pattern matching in
    C# 7.0 and later. The `case` values no longer need to be literal values; they
    can be patterns.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 与`if`语句一样，`switch`语句支持C# 7.0及更高版本中的模式匹配。`case`值不再需要是文字值；它们可以是模式。
- en: 'Let''s see an example of pattern matching with the `switch` statement using
    a folder path. If you are using macOS, then swap the commented statement that
    sets the path variable and replace my username with your user folder name:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用文件夹路径进行模式匹配的`switch`语句的示例。如果您使用的是macOS，则交换注释语句，设置路径变量并用您的用户文件夹名称替换我的用户名：
- en: 'Add statements to declare a `string` path to a file, open it as either a read-only
    or writeable stream, and then show a message based on what type and capabilities
    the stream has, as shown in the following code:'
  id: totrans-705
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句声明`string`路径到文件，将其打开为只读或可写流，然后根据流的类型和功能显示消息，如下面的代码所示：
- en: '```cs'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // string path = "/Users/markjprice/Code/Chapter03";
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: // string path = "/Users/markjprice/Code/Chapter03";
- en: string
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: path = @"C:\Code\Chapter03"
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: path = @"C:\Code\Chapter03"
- en: ;
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: 'Write("Press R for read-only or W for writeable: "'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: Write("按R进行只读或按W进行可写："
- en: );
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: ConsoleKeyInfo key = ReadKey();
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: ConsoleKeyInfo key = ReadKey();
- en: WriteLine();
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine();
- en: Stream? s;
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 流？s;
- en: if
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (key.Key == ConsoleKey.R)
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: （key.Key == ConsoleKey.R）
- en: '{'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: s =  File.Open(
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: s =  File.Open(
- en: Path.Combine(path, "file.txt"
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: Path.Combine(path, "file.txt"
- en: ),
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: ），
- en: FileMode.OpenOrCreate,
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: FileMode.OpenOrCreate，
- en: FileAccess.Read);
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: FileAccess.Read);
- en: '}'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 否则
- en: '{'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: s =  File.Open(
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: s =  File.Open(
- en: Path.Combine(path, "file.txt"
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: Path.Combine(path, "file.txt"
- en: ),
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: ），
- en: FileMode.OpenOrCreate,
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: FileMode.OpenOrCreate，
- en: FileAccess.Write);
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: FileAccess.Write);
- en: '}'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: string
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: message;
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 消息;
- en: switch
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 开关
- en: (s)
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: （s）
- en: '{'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: case
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 案例
- en: FileStream writeableFile when
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: FileStream writeableFile when
- en: 's.CanWrite:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 's.CanWrite:'
- en: message = "The stream is a file that I can write to."
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: message = "该流是我可以写入的文件。"
- en: ;
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: break
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 休息
- en: ;
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: case
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 案例
- en: 'FileStream readOnlyFile:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 'FileStream readOnlyFile:'
- en: message = "The stream is a read-only file."
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: message = "该流是只读文件。"
- en: ;
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: break
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 休息
- en: ;
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: case
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 案例
- en: 'MemoryStream ms:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 'MemoryStream ms:'
- en: message = "The stream is a memory address."
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: message = "该流是内存地址。"
- en: ;
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: break
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 休息
- en: ;
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: default
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 默认
- en: ': // always evaluated last despite its current position'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: ：//始终在当前位置之后评估
- en: message = "The stream is some other type."
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 消息=“流是其他类型。”
- en: ;
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: break
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 中断
- en: ;
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: case
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 案例
- en: 'null'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 'null'
- en: ':'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: ：
- en: message = "The stream is null."
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 消息=“流为空。”
- en: ;
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: break
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 中断
- en: ;
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: WriteLine(message);
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(message);
- en: '```'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and note that the variable named `s` is declared as a `Stream`
    type so it could be any subtype of stream, such as a memory stream or file stream.
    In this code, the stream is created using the `File.Open` method, which returns
    a file stream and, depending on your key press, it will be writeable or read-only,
    so the result will be a message that describes the situation, as shown in the
    following output:'
  id: totrans-773
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意名为`s`的变量被声明为`Stream`类型，因此它可以是流的任何子类型，例如内存流或文件流。在此代码中，流是使用`File.Open`方法创建的，该方法返回文件流，并且根据您的按键，它将是可写或只读的，因此结果将是描述情况的消息，如下面的输出所示：
- en: '```cs'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: The stream is a file that I can write to.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 流是我可以写入的文件。
- en: '```'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In .NET, there are multiple subtypes of `Stream` , including `FileStream` and
    `MemoryStream` . In C# 7.0 and later, your code can more concisely branch, based
    on the subtype of stream, and declare and assign a local variable to safely use
    it. You will learn more about the `System.IO` namespace and the `Stream` type
    in *Chapter 9* , *Working with Files, Streams, and Serialization* .
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，有多个`Stream`的子类型，包括`FileStream`和`MemoryStream`。在C# 7.0及更高版本中，您的代码可以更简洁地分支，基于流的子类型，并声明和分配一个本地变量以安全地使用它。您将在*第9章*中了解有关`System.IO`命名空间和`Stream`类型的更多信息，*使用文件、流和序列化*。
- en: Additionally, `case` statements can include a `when` keyword to perform more
    specific pattern matching. In the first case statement in the preceding code,
    `s` will only be a match if the stream is a `FileStream` and its `CanWrite` property
    is `true` .
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`case`语句可以包括`when`关键字以执行更具体的模式匹配。在前面代码中的第一个`case`语句中，只有当流是`FileStream`并且其`CanWrite`属性为`true`时，`s`才是匹配项。
- en: Simplifying switch statements with switch expressions
  id: totrans-779
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用switch表达式简化switch语句
- en: In C# 8.0 or later, you can simplify `switch` statements using **switch expressions**
    .
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 8.0或更高版本中，您可以使用**switch表达式**简化`switch`语句。
- en: Most `switch` statements are very simple, yet they require a lot of typing.
    `switch` expressions are designed to simplify the code you need to type while
    still expressing the same intent in scenarios where all cases return a value to
    set a single variable. `switch` expressions use a lambda, `=>` , to indicate a
    return value.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数`switch`语句非常简单，但是需要大量输入。`switch`表达式旨在简化您需要键入的代码，同时在所有情况下返回一个值以设置单个变量的情况下仍表达相同的意图。`switch`表达式使用lambda，`=>`，表示返回值。
- en: 'Let''s implement the previous code that used a `switch` statement using a `switch`
    expression so that you can compare the two styles:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`switch`表达式实现先前使用`switch`语句的代码，以便您可以比较这两种风格：
- en: 'Type statements to set the message based on what type and capabilities the
    stream has, using a `switch` expression, as shown in the following code:'
  id: totrans-783
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写语句以根据流的类型和功能设置消息，使用`switch`表达式，如下面的代码所示：
- en: '```cs'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: message = s switch
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 消息= s开关
- en: '{'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: FileStream writeableFile when
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: FileStream writeableFile when
- en: s.CanWrite
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: s.CanWrite
- en: => "The stream is a file that I can write to."
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: = > “流是我可以写入的文件。”
- en: ','
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: FileStream readOnlyFile
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: FileStream readOnlyFile
- en: => "The stream is a read-only file."
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: = > “流是只读文件。”
- en: ','
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: MemoryStream ms
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: MemoryStream ms
- en: => "The stream is a memory address."
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: = > “流是内存地址。”
- en: ','
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: 'null'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 空
- en: => "The stream is null."
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: = > “流为空。”
- en: ','
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: _
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: _
- en: => "The stream is some other type."
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: = > “流是其他类型。”
- en: '};'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: WriteLine(message);
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(message);
- en: '```'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The main differences are the removal of the `case` and `break` keywords. The
    underscore character `_` is used to represent the default return value.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于删除了`case`和`break`关键字。下划线字符`_`用于表示默认返回值。
- en: Run the code, and note the result is the same as before.
  id: totrans-806
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，注意结果与以前相同。
- en: Understanding iteration statements
  id: totrans-807
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解迭代语句
- en: Iteration statements repeat a block of statements either while a condition is
    true or for each item in a collection. The choice of which statement to use is
    based on a combination of ease of understanding to solve the logic problem and
    personal preference.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代语句重复一组语句，要么在条件为真时，要么对集合中的每个项目。选择使用哪个语句是基于解决逻辑问题的易理解性和个人偏好的组合。
- en: Looping with the while statement
  id: totrans-809
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用while语句循环
- en: 'The `while` statement evaluates a Boolean expression and continues to loop
    while it is true. Let''s explore iteration statements:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`语句评估布尔表达式，并在其为真时继续循环。让我们探索迭代语句：'
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter03`
    workspace/solution named `IterationStatements` .
  id: totrans-811
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的编码工具将新的**控制台应用程序**添加到名为`IterationStatements`的`Chapter03`工作区/解决方案中。
- en: In Visual Studio Code, select `IterationStatements` as the active OmniSharp
    project.
  id: totrans-812
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`IterationStatements`作为活动的OmniSharp项目。
- en: 'In `Program.cs` , type statements to define a `while` statement that loops
    while an integer variable has a value less than 10, as shown in the following
    code:'
  id: totrans-813
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，编写语句以定义`while`语句，当整数变量的值小于10时循环，如下面的代码所示：
- en: '```cs'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: x = 0
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: x = 0
- en: ;
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: while
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 而
- en: (x < 10
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: (x < 10
- en: )
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: ）
- en: '{'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine(x);
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(x);
- en: x++;
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: x ++;
- en: '}'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the results, which should be the numbers 0 to 9, as shown
    in the following output:'
  id: totrans-826
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，应该是0到9的数字，如下面的输出所示：
- en: '```cs'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '0'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '5'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '6'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '7'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '8'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '9'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: '```'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Looping with the do statement
  id: totrans-839
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用do语句循环
- en: 'The `do` statement is like `while` , except the Boolean expression is checked
    at the bottom of the block instead of the top, which means that the block always
    executes at least once, as the following shows:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: '`do`语句类似于`while`，只是在块的底部检查布尔表达式，而不是在顶部检查，这意味着块始终至少执行一次，如下所示：'
- en: 'Type statements to define a `do` loop, as shown in the following code:'
  id: totrans-841
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写语句以定义`do`循环，如下面的代码所示：
- en: '```cs'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: string
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: '? password;'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: ？密码;
- en: do
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 做
- en: '{'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: 'Write("Enter your password: "'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: Write("输入您的密码： "```
- en: );
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: password = ReadLine();
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 密码= ReadLine（）;
- en: '}'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: while
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 而
- en: (password != "Pa$$w0rd"
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: （密码！= "Pa$$w0rd"
- en: );
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: WriteLine("Correct!"
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine（"正确！"
- en: );
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '```'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code, and note that you are prompted to enter your password repeatedly
    until you enter it correctly, as shown in the following output:'
  id: totrans-857
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，并注意您将被提示重复输入密码，直到正确输入为止，如下面的输出所示：
- en: '```cs'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Enter your password: password'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 输入密码：密码
- en: 'Enter your password: 12345678'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 输入密码：12345678
- en: 'Enter your password: ninja'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 输入密码：忍者
- en: 'Enter your password: correct horse battery staple'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 输入密码：正确的马，电池，订书钉
- en: 'Enter your password: Pa$$w0rd'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 输入密码：Pa$$w0rd
- en: Correct!
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 正确！
- en: '```'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As an optional challenge, add statements so that the user can only make ten
    attempts before an error message is displayed.
  id: totrans-866
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为可选挑战，添加语句，以便用户在显示错误消息之前只能尝试十次。
- en: Looping with the for statement
  id: totrans-867
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`for`语句循环
- en: 'The `for` statement is like `while` , except that it is more succinct. It combines:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句类似于`while`，只是更简洁。它结合了：'
- en: An **initializer expression** , which executes once at the start of the loop.
  id: totrans-869
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**初始化表达式**，它在循环开始时执行一次。
- en: A **conditional expression** , which executes on every iteration at the start
    of the loop to check whether the looping should continue.
  id: totrans-870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**条件表达式**，它在循环开始时的每次迭代中执行，以检查循环是否应该继续。
- en: An **iterator expression** , which executes on every loop at the bottom of the
    statement.
  id: totrans-871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**迭代器表达式**，它在语句底部的每次循环中执行。
- en: 'The `for` statement is commonly used with an integer counter. Let''s explore
    some code:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句通常与整数计数器一起使用。让我们来探索一些代码：'
- en: 'Type a `for` statement to output the numbers 1 to 10, as shown in the following
    code:'
  id: totrans-873
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键入`for`语句以输出1到10的数字，如下面的代码所示：
- en: '```cs'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: for
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 为
- en: (int
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: （int
- en: y = 1
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: y = 1
- en: ; y <= 10
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: ; y <= 10
- en: ; y++)
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: ; y ++）
- en: '{'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine(y);
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine（y）;
- en: '}'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Run the code to view the result, which should be the numbers 1 to 10.
  id: totrans-884
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以查看结果，应该是1到10的数字。
- en: Looping with the foreach statement
  id: totrans-885
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`foreach`语句循环
- en: The `foreach` statement is a bit different from the previous three iteration
    statements.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`语句与前三个迭代语句有些不同。'
- en: It is used to perform a block of statements on each item in a sequence, for
    example, an array or collection. Each item is usually read-only, and if the sequence
    structure is modified during iteration, for example, by adding or removing an
    item, then an exception will be thrown.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 它用于对序列中的每个项目执行一组语句，例如数组或集合。每个项目通常是只读的，如果在迭代期间修改了序列结构，例如通过添加或删除项目，则会抛出异常。
- en: 'Try the following example:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下示例：
- en: 'Type statements to create an array of string variables and then output the
    length of each one, as shown in the following code:'
  id: totrans-889
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键入语句以创建字符串变量的数组，然后输出每个字符串的长度，如下面的代码所示：
- en: '```cs'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: string
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: '[] names = { "Adam"'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '[] names = { "亚当"'
- en: ', "Barry"'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: ，“巴里”
- en: ', "Charlie"'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: ，“查理”
- en: '};'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: foreach
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: foreach
- en: (string
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: （字符串
- en: name in
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 名字在
- en: names)
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 名字）
- en: '{'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine($"
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{name}'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: '{name}'
- en: has
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 有
- en: '{name.Length}'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '{name.Length}'
- en: characters."
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 字符。"
- en: );
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '}'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the results, as shown in the following output:'
  id: totrans-909
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Adam has 4 characters.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 亚当有4个字符。
- en: Barry has 5 characters.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 巴里有5个字符。
- en: Charlie has 7 characters.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 查理有7个字符。
- en: '```'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Understanding how foreach works internally
  id: totrans-915
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解`foreach`的内部工作原理
- en: A creator of any type that represents multiple items, like an array or collection,
    should make sure that a programmer can use the `foreach` statement to enumerate
    through the type's items.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 任何代表多个项目的类型的创建者，例如数组或集合，都应确保程序员可以使用`foreach`语句枚举类型的项目。
- en: 'Technically, the `foreach` statement will work on any type that follows these
    rules:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，`foreach`语句将适用于遵循以下规则的任何类型：
- en: The type must have a method named `GetEnumerator` that returns an object.
  id: totrans-918
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型必须有一个名为`GetEnumerator`的方法，返回一个对象。
- en: The returned object must have a property named `Current` and a method named
    `MoveNext` .
  id: totrans-919
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回的对象必须有一个名为`Current`的属性和一个名为`MoveNext`的方法。
- en: The `MoveNext` method must change the value of `Current` and return `true` if
    there are more items to enumerate through or return `false` if there are no more
    items.
  id: totrans-920
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MoveNext`方法必须更改`Current`的值并返回`true`，如果有更多项目要枚举，或者如果没有更多项目，则返回`false`。'
- en: There are interfaces named `IEnumerable` and `IEnumerable<T>` that formally
    define these rules, but technically the compiler does not require the type to
    implement these interfaces.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 有名为`IEnumerable`和`IEnumerable<T>`的接口，正式定义了这些规则，但从技术上讲，编译器不要求类型实现这些接口。
- en: 'The compiler turns the `foreach` statement in the preceding example into something
    like the following pseudocode:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将前面示例中的`foreach`语句转换为以下伪代码：
- en: '```cs'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: IEnumerator e = names.GetEnumerator();
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: IEnumerator e = names.GetEnumerator（）;
- en: while
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 而
- en: (e.MoveNext())
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: （e.MoveNext（））
- en: '{'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: string
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: name = (string
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: name =（string
- en: )e.Current; // Current is read-only!
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: ）e.Current; // Current是只读的！
- en: WriteLine($"
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine（$"
- en: '{name}'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '{name}'
- en: has
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 有
- en: '{name.Length}'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '{name.Length}'
- en: characters."
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 字符。"
- en: );
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '}'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Due to the use of an iterator, the variable declared in a `foreach` statement
    cannot be used to modify the value of the current item.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了迭代器，`foreach`语句中声明的变量不能用于修改当前项目的值。
- en: Casting and converting between types
  id: totrans-940
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制转换和类型转换
- en: You will often need to convert values of variables between different types.
    For example, data input is often entered as text at the console, so it is initially
    stored in a variable of the `string` type, but it then needs to be converted into
    a date/time, or number, or some other data type, depending on how it should be
    stored and processed.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 通常需要在不同类型的变量值之间进行转换。例如，数据输入通常以文本形式输入到控制台，因此最初存储在`string`类型的变量中，但随后需要将其转换为日期/时间，或数字，或其他数据类型，具体取决于应该如何存储和处理。
- en: Sometimes you will need to convert between number types, like between an integer
    and a floating point, before performing calculations.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要在数字类型之间进行转换，例如在整数和浮点数之间进行转换，然后执行计算。
- en: 'Converting is also known as **casting** , and it has two varieties: **implicit**
    and **explicit** . Implicit casting happens automatically, and it is safe, meaning
    that you will not lose any information.'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 转换也被称为**转换**，有两种类型：**隐式**和**显式**。隐式转换会自动发生，它是安全的，意味着您不会丢失任何信息。
- en: Explicit casting must be performed manually because it may lose information,
    for example, the precision of a number. By explicitly casting, you are telling
    the C# compiler that you understand and accept the risk.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可能会丢失信息，因此必须手动执行显式转换，例如数字的精度。通过显式转换，您告诉C#编译器您理解并接受风险。
- en: Casting numbers implicitly and explicitly
  id: totrans-945
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式和显式地转换数字
- en: 'Implicitly casting an `int` variable into a `double` variable is safe because
    no information can be lost as the following shows:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 将`int`变量隐式转换为`double`变量是安全的，因为不会丢失任何信息，如下所示：
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter03`
    workspace/solution named `CastingConverting` .
  id: totrans-947
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的编码工具将一个新的**控制台应用程序**添加到名为`Chapter03`的工作区/解决方案中，命名为`CastingConverting`。
- en: In Visual Studio Code, select `CastingConverting` as the active OmniSharp project.
  id: totrans-948
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`CastingConverting`作为活动的OmniSharp项目。
- en: 'In `Program.cs` , type statements to declare and assign an `int` variable and
    a `double` variable, and then implicitly cast the integer''s value when assigning
    it to the `double` variable, as shown in the following code:'
  id: totrans-949
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，输入语句来声明和分配一个`int`变量和一个`double`变量，然后在将整数值隐式转换为`double`变量时，如下面的代码所示：
- en: '```cs'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: a = 10
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: a = 10
- en: ;
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: double
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: double
- en: b = a; // an int can be safely cast into a double
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: b = a; // int可以安全地转换为double
- en: WriteLine(b);
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(b);
- en: '```'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Type statements to declare and assign a `double` variable and an `int` variable,
    and then implicitly cast the `double` value when assigning it to the `int` variable,
    as shown in the following code:'
  id: totrans-958
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句来声明和分配一个`double`变量和一个`int`变量，然后在将`double`值隐式转换为`int`变量时，如下面的代码所示：
- en: '```cs'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: double
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: double
- en: c = 9.8
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: c = 9.8
- en: ;
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: int
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: d = c; // compiler gives an error for this line
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: d = c; // 编译器会为这一行报错
- en: WriteLine(d);
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(d);
- en: '```'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and note the error message, as shown in the following output:'
  id: totrans-967
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意错误消息，如下面的输出所示：
- en: '```cs'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Error: (6,9): error CS0266: Cannot implicitly convert type ''double'' to ''int''.
    An explicit conversion exists (are you missing a cast?)'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: '错误：(6,9): error CS0266: Cannot implicitly convert type ''double'' to ''int''.
    An explicit conversion exists (are you missing a cast?)'
- en: '```'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This error message will also appear in the Visual Studio Error List or Visual
    Studio Code PROBLEMS window.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误消息也会出现在Visual Studio错误列表或Visual Studio Code问题窗口中。
- en: You cannot implicitly cast a `double` variable into an `int` variable because
    it is potentially unsafe and could lose data, like the value after the decimal
    point. You must explicitly cast a `double` variable into an `int` variable using
    a pair of round brackets around the type you want to cast the `double` type into.
    The pair of round brackets is the **cast operator** . Even then, you must beware
    that the part after the decimal point will be trimmed off without warning because
    you have chosen to perform an explicit cast and therefore understand the consequences.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能将`double`变量隐式转换为`int`变量，因为这可能是不安全的，并且可能会丢失数据，比如小数点后的值。您必须使用一对圆括号将`double`变量显式转换为`int`变量。一对圆括号是**转换运算符**。即使如此，您也必须注意，小数点后的部分将被截断而没有警告，因为您选择执行显式转换，因此理解后果。
- en: 'Modify the assignment statement for the `d` variable, as shown in the following
    code:'
  id: totrans-973
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`d`变量的赋值语句，如下面的代码所示：
- en: '```cs'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: d = (int
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: d = (int
- en: )c;
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: )c;
- en: WriteLine(d); // d is 9 losing the .8 part
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(d); // d是9，丢失了.8部分
- en: '```'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code to view the results, as shown in the following output:'
  id: totrans-980
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '10'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: '9'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: '```'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We must perform a similar operation when converting values between larger integers
    and smaller integers. Again, beware that you might lose information because any
    value too big will have its bits copied and then be interpreted in ways that you
    might not expect!
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 在将较大的整数值和较小的整数值之间转换值时，我们必须执行类似的操作。同样，要注意，您可能会丢失信息，因为任何太大的值都将被复制其位，然后以您可能意想不到的方式进行解释！
- en: 'Enter statements to declare and assign a long 64-bit variable to an int 32-bit
    variable, both using a small value that will work and a too-large value that will
    not, as shown in the following code:'
  id: totrans-986
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句来声明并将一个64位长整型变量分配给一个32位整型变量，两者都使用一个可以工作的小值和一个太大的值，如下面的代码所示：
- en: '```cs'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: long
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: long
- en: e = 10
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: e = 10
- en: ;
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: int
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: f = (int
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: f = (int
- en: )e;
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: )e;
- en: WriteLine($"e is
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"e is
- en: '{e:N0}'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '{e:N0}'
- en: and f is
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 和f是
- en: '{f:N0}'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '{f:N0}'
- en: '"'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: e = long
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: e = long
- en: .MaxValue;
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: .MaxValue;
- en: f = (int
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: f = (int
- en: )e;
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: )e;
- en: WriteLine($"e is
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"e is
- en: '{e:N0}'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: '{e:N0}'
- en: and f is
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 和f是
- en: '{f:N0}'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: '{f:N0}'
- en: '"'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code to view the results, as shown in the following output:'
  id: totrans-1011
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: e is 10 and f is 10
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: e是10，f是10
- en: e is 9,223,372,036,854,775,807 and f is -1
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: e是9,223,372,036,854,775,807，f是-1
- en: '```'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Modify the value of `e` to 5 billion, as shown in the following code:'
  id: totrans-1016
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`e`的值为50亿，如下面的代码所示：
- en: '```cs'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: e = 5
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: e = 5
- en: _000_000_000;
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: _000_000_000;
- en: '```'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code to view the results, as shown in the following output:'
  id: totrans-1021
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码以查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: e is 5,000,000,000 and f is 705,032,704
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: e是5,000,000,000，f是705,032,704
- en: '```'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Converting with the System.Convert type
  id: totrans-1025
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用System.Convert类型进行转换
- en: An alternative to using the cast operator is to use the `System.Convert` type.
    The `System.Convert` type can convert to and from all the C# number types, as
    well as Booleans, strings, and date and time values.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`System.Convert`类型的替代方法是使用`System.Convert`类型。`System.Convert`类型可以在C#的所有数字类型之间进行转换，还可以在布尔值、字符串和日期时间值之间进行转换。
- en: 'Let''s write some code to see this in action:'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码来看看它的运行情况：
- en: 'At the top of `Program.cs` , statically import the `System.Convert` class,
    as shown in the following code:'
  id: totrans-1028
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的顶部，静态导入`System.Convert`类，如下面的代码所示：
- en: '```cs'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: using
- en: static
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: static
- en: System.Convert;
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: System.Convert;
- en: '```'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'At the bottom of `Program.cs` , type statements to declare and assign a value
    to a `double` variable, convert it to an integer, and then write both values to
    the console, as shown in the following code:'
  id: totrans-1034
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的底部，输入语句以声明并分配一个`double`变量的值，将其转换为整数，然后将两个值都写入控制台，如下面的代码所示：
- en: '```cs'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: double
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 双精度
- en: g = 9.8
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: g = 9.8
- en: ;
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: int
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: h = ToInt32(g); // a method of System.Convert
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: h = ToInt32(g); // System.Convert的一个方法
- en: WriteLine($"g is
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"g 是
- en: '{g}'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: '{g}'
- en: and h is
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 和 h 是
- en: '{h}'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: '{h}'
- en: '"'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1048
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: g is 9.8 and h is 10
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: g 是 9.8 和 h 是 10
- en: '```'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: One difference between casting and converting is that converting rounds the
    `double` value `9.8` up to `10` instead of trimming the part after the decimal
    point.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 强制转换和转换之间的一个区别是，转换将`double`值`9.8`四舍五入为`10`，而不是截取小数点后的部分。
- en: Rounding numbers
  id: totrans-1053
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 四舍五入数字
- en: You have now seen that the cast operator trims the decimal part of a real number
    and that the `System.Convert` methods round up or down. However, what is the rule
    for rounding?
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经看到强制转换运算符截取实数的小数部分，而`System.Convert`方法四舍五入。然而，四舍五入的规则是什么呢？
- en: Understanding the default rounding rules
  id: totrans-1055
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解默认的四舍五入规则
- en: In British primary schools for children aged 5 to 11, pupils are taught to round
    *up* if the decimal part is .5 or higher and round *down* if the decimal part
    is less.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 在英国的小学中，5到11岁的学生被教导如果小数部分为.5或更高，则四舍五入为*向上*，如果小数部分小于.5，则四舍五入为*向下*。
- en: 'Let''s explore if C# follows the same primary school rule:'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨一下C#是否遵循相同的小学规则：
- en: 'Type statements to declare and assign an array of `double` values, convert
    each of them to an integer, and then write the result to the console, as shown
    in the following code:'
  id: totrans-1058
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型语句以声明并分配一个`double`值数组，将每个值转换为整数，然后将结果写入控制台，如下面的代码所示：
- en: '```cs'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: double
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: double
- en: '[] doubles = new'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '[] 双精度 = new'
- en: '[]'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: '[]'
- en: '{ 9.49'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 9.49'
- en: ', 9.5'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: ', 9.5'
- en: ', 9.51'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: ', 9.51'
- en: ', 10.49'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: ', 10.49'
- en: ', 10.5'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: ', 10.5'
- en: ', 10.51'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: ', 10.51'
- en: '};'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: foreach
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个
- en: (double
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: （双精度
- en: n in
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: n 在
- en: doubles)
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 双精度)
- en: '{'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine($"ToInt32(
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"ToInt32(
- en: '{n}'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: '{n}'
- en: ) is
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: ）是
- en: '{ToInt32(n)}'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: '{ToInt32(n)}'
- en: '"'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1083
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: ToInt32(9.49) is 9
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: ToInt32(9.49) 是 9
- en: ToInt32(9.5) is 10
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: ToInt32(9.5) 是 10
- en: ToInt32(9.51) is 10
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: ToInt32(9.51) 是 10
- en: ToInt32(10.49) is 10
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: ToInt32(10.49) 是 10
- en: ToInt32(10.5) is 10
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: ToInt32(10.5) 是 10
- en: ToInt32(10.51) is 11
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: ToInt32(10.51) 是 11
- en: '```'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We have shown that the rule for rounding in C# is subtly different from the
    primary school rule:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经证明了C#中的四舍五入规则与小学规则略有不同：
- en: It always rounds *down* if the decimal part is less than the midpoint .5.
  id: totrans-1093
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果小数部分小于中点.5，它总是四舍五入*向下*。
- en: It always rounds *up* if the decimal part is more than the midpoint .5.
  id: totrans-1094
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果小数部分大于中点.5，它总是四舍五入*向上*。
- en: It will round *up* if the decimal part is the midpoint .5 and the non-decimal
    part is *odd* , but it will round *down* if the non-decimal part is *even* .
  id: totrans-1095
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果小数部分是中点.5，非小数部分是*奇数*，它将四舍五入*向上*，但如果非小数部分是*偶数*，它将四舍五入*向下*。
- en: This rule is known as **Banker's Rounding** , and it is preferred because it
    reduces bias by alternating when it rounds up or down. Sadly, other languages
    such as JavaScript use the primary school rule.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则被称为**银行家舍入**，它更受欢迎，因为它通过交替四舍五入来减少偏差。不幸的是，其他语言如JavaScript使用小学规则。
- en: Taking control of rounding rules
  id: totrans-1097
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制四舍五入规则
- en: 'You can take control of the rounding rules by using the `Round` method of the
    `Math` class:'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`Math`类的`Round`方法来控制四舍五入规则：
- en: 'Type statements to round each of the `double` values using the "away from zero"
    rounding rule, also known as rounding "up," and then write the result to the console,
    as shown in the following code:'
  id: totrans-1099
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型语句以使用“远离零”四舍五入规则（也称为“向上”四舍五入）对每个`double`值进行四舍五入，然后将结果写入控制台，如下面的代码所示：
- en: '```cs'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: foreach
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个
- en: (double
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: （双精度
- en: n in
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: n 在
- en: doubles)
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 双精度)
- en: '{'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: 'WriteLine(format:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine(format:'
- en: '"Math.Round({0}, 0, MidpointRounding.AwayFromZero) is {1}"'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '"Math.Round({0}, 0, MidpointRounding.AwayFromZero) 是 {1}"'
- en: ','
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: 'arg0: n,'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg0: n,'
- en: 'arg1: Math.Round(value'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg1: Math.Round(value'
- en: ': n, digits: 0'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: ': n, digits: 0'
- en: ','
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: 'mode: MidpointRounding.AwayFromZero));'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 模式：MidpointRounding.AwayFromZero));
- en: '}'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Math.Round(9.49, 0, MidpointRounding.AwayFromZero) is 9
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: Math.Round(9.49, 0, MidpointRounding.AwayFromZero) 是 9
- en: Math.Round(9.5, 0, MidpointRounding.AwayFromZero) is 10
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: Math.Round(9.5, 0, MidpointRounding.AwayFromZero) 是 10
- en: Math.Round(9.51, 0, MidpointRounding.AwayFromZero) is 10
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: Math.Round(9.51, 0, MidpointRounding.AwayFromZero) 是 10
- en: Math.Round(10.49, 0, MidpointRounding.AwayFromZero) is 10
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: Math.Round(10.49, 0, MidpointRounding.AwayFromZero) 是 10
- en: Math.Round(10.5, 0, MidpointRounding.AwayFromZero) is 11
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: Math.Round(10.5, 0, MidpointRounding.AwayFromZero) 是 11
- en: Math.Round(10.51, 0, MidpointRounding.AwayFromZero) is 11
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: Math.Round(10.51, 0, MidpointRounding.AwayFromZero) 是 11
- en: '```'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : For every programming language that you use, check its
    rounding rules. They may not work the way you expect!'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：对于您使用的每种编程语言，请检查其四舍五入规则。它们可能不会按照您的期望工作！'
- en: Converting from any type to a string
  id: totrans-1126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从任何类型转换为字符串
- en: The most common conversion is from any type into a `string` variable for outputting
    as human-readable text, so all types have a method named `ToString` that they
    inherit from the `System.Object` class.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的转换是从任何类型转换为`string`变量以输出为人类可读的文本，因此所有类型都有一个名为`ToString`的方法，它们从`System.Object`类继承而来。
- en: The `ToString` method converts the current value of any variable into a textual
    representation. Some types can't be sensibly represented as text, so they return
    their namespace and type name instead.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToString`方法将当前变量的值转换为文本表示。一些类型无法合理地表示为文本，因此它们返回它们的命名空间和类型名称。'
- en: 'Let''s convert some types into a `string` :'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将一些类型转换为`string`：
- en: 'Type statements to declare some variables, convert them to their `string` representation,
    and write them to the console, as shown in the following code:'
  id: totrans-1130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型语句以声明一些变量，将它们转换为它们的`string`表示，并将它们写入控制台，如下面的代码所示：
- en: '```cs'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: number = 12
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: number = 12
- en: ;
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: WriteLine(number.ToString());
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(number.ToString());
- en: bool
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值
- en: boolean = true
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值 = true
- en: ;
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: WriteLine(boolean.ToString());
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: '];'
- en: DateTime now = DateTime.Now;
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: ."
- en: WriteLine(now.ToString());
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: '{encoded}'
- en: object
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: me = new
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: // allocate array of 128 bytes
- en: ();
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: WriteLine(me.ToString());
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: I was born 27 years ago.
- en: '```'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Write($"
- en: '```cs'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: byte
- en: '12'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 26 EE
- en: 'True'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: The opposite of `ToString` is `Parse` . Only a few types have a `Parse` method,
    including all the number types and `DateTime` .
- en: 02/28/2021 17:33:54
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: System.Object
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 'Run the code and view the result, as shown in the following output:'
- en: '```'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: Converting from a binary object to a string
  id: totrans-1154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Binary Object as bytes:'
- en: When you have a binary object like an image or video that you want to either
    store or transmit, you sometimes do not want to send the raw bits because you
    do not know how those bits could be misinterpreted, for example, by the network
    protocol transmitting them or another operating system that is reading the store
    binary object.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: (int
- en: The safest thing to do is to convert the binary object into a `string` of safe
    characters. Programmers call this **Base64** encoding.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: '{birthday:D}'
- en: 'The `Convert` type has a pair of methods, `ToBase64String` and `FromBase64String`
    , that perform this conversion for you. Let''s see them in action:'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: 'Type statements to create an array of bytes randomly populated with byte values,
    write each byte nicely formatted to the console, and then write the same bytes
    converted to Base64 to the console, as shown in the following code:'
  id: totrans-1158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: index = 0
- en: '```cs'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: // allocate array of 128 bytes
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: '[] binaryObject = new'
- en: byte
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: '[128'
- en: '[] binaryObject = new'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: My birthday is 04 July 1980.
- en: byte
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '[128'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: (new
- en: '];'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: Parsing from strings to numbers or dates and times
- en: // populate array with random bytes
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("Binary Object as bytes:"
- en: (new
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: '**Good Practice** : Use the standard date and time format specifiers, as shown
    at the following link: [https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#table-of-format-specifiers](https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#table-of-format-specifiers)'
- en: Random()).NextBytes(binaryObject);
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: Errors using Parse
- en: WriteLine("Binary Object as bytes:"
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: '{birthday}'
- en: );
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: When you have a binary object like an image or video that you want to either
    store or transmit, you sometimes do not want to send the raw bits because you
    do not know how those bits could be misinterpreted, for example, by the network
    protocol transmitting them or another operating system that is reading the store
    binary object.
- en: for
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: '{age}'
- en: (int
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: years ago."
- en: index = 0
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: encoded = ToBase64String(binaryObject);
- en: ; index < binaryObject.Length; index++)
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: '{'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: byte
- en: Write($"
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 'Binary Object as Base64: s01V3i0Ou8++TeZTw8KbZwNF +eUgYX5PeoHsSfBJHY7U99tU
    r6CBBbi+zvg2kHrUNkIEdYEbq1HOBWOsInLedC9Xf8vnR7diw/QtYZOFGOoGFxKuRKgNuEyJha k81eJG4FnJ3xCv7e+KobGN7kq+SO
    x5pQpfLzCHSsd/XcENJu4='
- en: '{binaryObject[index]:X}'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 10 AF ED EF 8AA1 B1 8D EE 4A BE 48 EC 79 A5 A 5F 2F 30 87 4A C7 7F 5D C1 D
- en: '"'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 02/28/2021 17:33:54
- en: );
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 61 93 85 18 EA 6 17 12 AE 44 A8 D B8 4C 89 85 A9 3C D5 E2 46 E0 59 C9 DF
- en: '}'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine();
- en: WriteLine();
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"My birthday is
- en: // convert to Base64 string and output as text
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: string
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: encoded = ToBase64String(binaryObject);
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: System.Object
- en: 'WriteLine($"Binary Object as Base64:'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '{encoded}'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '"'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: DateTime now = DateTime.Now;
- en: );
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 'Run the code and view the result, as shown in the following output:'
- en: '```'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: By default, an `int` value would output assuming decimal notation, that is,
    base10\. You can use format codes such as `:X` to format the value using hexadecimal
    notation.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: age = int
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WriteLine(boolean.ToString());
- en: '```cs'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Binary Object as bytes:'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 'Type statements to parse an integer and a date and time value from strings
    and then write the result to the console, as shown in the following code:'
- en: B3 4D 55 DE 2D E BB CF BE 4D E6 53 C3 C2 9B 67 3 45 F9 E5 20 61 7E 4F 7A 81
    EC 49 F0 49 1D 8E D4 F7 DB 54 AF A0 81 5 B8 BE CE F8 36 90 7A D4 36 42
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"I was born
- en: 4 75 81 1B AB 51 CE 5 63 AC 22 72 DE 74 2F 57 7F CB E7 47 B7 62 C3 F4 2D
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: 61 93 85 18 EA 6 17 12 AE 44 A8 D B8 4C 89 85 A9 3C D5 E2 46 E0 59 C9 DF
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: One problem with the `Parse` method is that it gives errors if the `string`
    cannot be converted.
- en: 10 AF ED EF 8AA1 B1 8D EE 4A BE 48 EC 79 A5 A 5F 2F 30 87 4A C7 7F 5D C1 D
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: By default, a date and time value outputs with the short date and time format.
    You can use format codes such as `D` to output only the date part using the long
    date format.
- en: 26 EE
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Binary Object as Base64: s01V3i0Ou8++TeZTw8KbZwNF +eUgYX5PeoHsSfBJHY7U99tU
    r6CBBbi+zvg2kHrUNkIEdYEbq1HOBWOsInLedC9Xf8vnR7diw/QtYZOFGOoGFxKuRKgNuEyJha k81eJG4FnJ3xCv7e+KobGN7kq+SO
    x5pQpfLzCHSsd/XcENJu4='
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: DateTime birthday = DateTime.Parse("4 July 1980"
- en: Parsing from strings to numbers or dates and times
  id: totrans-1201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: object
- en: The second most common conversion is from strings to numbers or date and time
    values.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: The safest thing to do is to convert the binary object into a `string` of safe
    characters. Programmers call this **Base64** encoding.
- en: The opposite of `ToString` is `Parse` . Only a few types have a `Parse` method,
    including all the number types and `DateTime` .
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: Converting from a binary object to a string
- en: 'Let''s see `Parse` in action:'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `Convert` type has a pair of methods, `ToBase64String` and `FromBase64String`
    , that perform this conversion for you. Let''s see them in action:'
- en: 'Type statements to parse an integer and a date and time value from strings
    and then write the result to the console, as shown in the following code:'
  id: totrans-1205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '```cs'
- en: '```cs'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: .Parse("27"
- en: int
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(now.ToString());
- en: age = int
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: '{binaryObject[index]:X}'
- en: .Parse("27"
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 4 75 81 1B AB 51 CE 5 63 AC 22 72 DE 74 2F 57 7F CB E7 47 B7 62 C3 F4 2D
- en: );
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: DateTime birthday = DateTime.Parse("4 July 1980"
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: The second most common conversion is from strings to numbers or date and time
    values.
- en: );
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: // convert to Base64 string and output as text
- en: WriteLine($"I was born
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: for
- en: '{age}'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: years ago."
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine($"Binary Object as Base64:'
- en: );
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: By default, an `int` value would output assuming decimal notation, that is,
    base10\. You can use format codes such as `:X` to format the value using hexadecimal
    notation.
- en: WriteLine($"My birthday is
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: ."
- en: '{birthday}'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 'Type statements to create an array of bytes randomly populated with byte values,
    write each byte nicely formatted to the console, and then write the same bytes
    converted to Base64 to the console, as shown in the following code:'
- en: ."
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: );
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: // populate array with random bytes
- en: WriteLine($"My birthday is
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '{birthday:D}'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 'Let''s see `Parse` in action:'
- en: ."
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 'Run the code and view the result, as shown in the following output:'
- en: );
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"My birthday is
- en: '```'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: ; index < binaryObject.Length; index++)
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '```'
- en: '```cs'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: I was born 27 years ago.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: me = new
- en: My birthday is 04/07/1980 00:00:00\.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(me.ToString());
- en: My birthday is 04 July 1980.
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: Random()).NextBytes(binaryObject);
- en: '```'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: By default, a date and time value outputs with the short date and time format.
    You can use format codes such as `D` to output only the date part using the long
    date format.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: My birthday is 04/07/1980 00:00:00\.
- en: '**Good Practice** : Use the standard date and time format specifiers, as shown
    at the following link: [https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#table-of-format-specifiers](https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#table-of-format-specifiers)'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: B3 4D 55 DE 2D E BB CF BE 4D E6 53 C3 C2 9B 67 3 45 F9 E5 20 61 7E 4F 7A 81
    EC 49 F0 49 1D 8E D4 F7 DB 54 AF A0 81 5 B8 BE CE F8 36 90 7A D4 36 42
- en: Errors using Parse
  id: totrans-1234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '12'
- en: One problem with the `Parse` method is that it gives errors if the `string`
    cannot be converted.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: 'Type a statement to attempt to parse a string containing letters into an integer
    variable, as shown in the following code:'
  id: totrans-1236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Type a statement to attempt to parse a string containing letters into an integer
    variable, as shown in the following code:'
- en: '```cs'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: count = int
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: count = int
- en: .Parse("abc"
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: .Parse("abc"
- en: );
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Unhandled Exception: System.FormatException: Input string was not in a correct
    format.'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 未处理的异常：System.FormatException：输入字符串的格式不正确。
- en: '```'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As well as the preceding exception message, you will see a stack trace. I have
    not included stack traces in this book because they take up too much space.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的异常消息，您还将看到堆栈跟踪。我没有在本书中包含堆栈跟踪，因为它们占用太多空间。
- en: Avoiding exceptions using the TryParse method
  id: totrans-1248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用TryParse方法避免异常
- en: To avoid errors, you can use the `TryParse` method instead. `TryParse` attempts
    to convert the input `string` and returns `true` if it can convert it and `false`
    if it cannot.
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免错误，您可以使用`TryParse`方法。`TryParse`尝试转换输入的`string`，如果可以转换，则返回`true`，如果无法转换，则返回`false`。
- en: The `out` keyword is required to allow the `TryParse` method to set the count
    variable when the conversion works.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: '`out`关键字是必需的，以允许`TryParse`方法在转换成功时设置计数变量。'
- en: 'Let''s see `TryParse` in action:'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`TryParse`的运行情况：
- en: 'Replace the `int` `count` declaration with statements to use the `TryParse`
    method and ask the user to input a count for a number of eggs, as shown in the
    following code:'
  id: totrans-1252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`int` `count`声明替换为使用`TryParse`方法的语句，并要求用户输入鸡蛋数量的计数，如下面的代码所示：
- en: '```cs'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Write("How many eggs are there? "
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: Write("有多少鸡蛋？"
- en: );
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: string
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: '? input = ReadLine(); // or use "12" in notebook'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: '? input = ReadLine(); // or use "12" in notebook'
- en: if
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: if
- en: (int
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: (int
- en: .TryParse(input, out
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: .TryParse(input, out
- en: int
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: count))
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: count))
- en: '{'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine($"There are
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"There are
- en: '{count}'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: '{count}'
- en: eggs."
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 鸡蛋。"
- en: );
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: '{'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine("I could not parse the input."
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("I could not parse the input."
- en: );
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code, enter `12` , and view the result, as shown in the following output:'
  id: totrans-1275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入`12`，并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: How many eggs are there? 12
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少鸡蛋？12
- en: There are 12 eggs.
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 有12个鸡蛋。
- en: '```'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code, enter `twelve` (or change the `string` value to `"twelve"` in
    a notebook), and view the result, as shown in the following output:'
  id: totrans-1280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入`twelve`（或在笔记本中将`string`值更改为`"twelve"`），并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: How many eggs are there? twelve
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少鸡蛋？twelve
- en: I could not parse the input.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法解析输入。
- en: '```'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You can also use methods of the `System.Convert` type to convert `string` values
    into other types; however, like the `Parse` method, it gives an error if it cannot
    convert.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`System.Convert`类型的方法将`string`值转换为其他类型；但是，就像`Parse`方法一样，如果无法转换，它会报错。
- en: Handling exceptions
  id: totrans-1286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常
- en: You've seen several scenarios where errors have occurred when converting types.
    Some languages return error codes when something goes wrong. .NET uses exceptions
    that are richer and designed only for failure reporting compared to return values
    that have multiple uses. When this happens, we say a *runtime exception has been
    thrown* .
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了几种在转换类型时发生错误的情况。有些语言在出现问题时返回错误代码。.NET使用异常，它们比具有多种用途的返回值更丰富，并且仅设计用于报告失败。当这种情况发生时，我们说*发生了运行时异常*。
- en: When an exception is thrown, the thread is suspended and if the calling code
    has defined a `try-catch` statement, then it is given a chance to handle the exception.
    If the current method does not handle it, then its calling method is given a chance,
    and so on up the call stack.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 当抛出异常时，线程被挂起，如果调用代码定义了`try-catch`语句，则有机会处理异常。如果当前方法没有处理它，那么它的调用方法将有机会处理，依此类推。
- en: As you have seen, the default behavior of a console application or a .NET Interactive
    notebook is to output a message about the exception, including a stack trace,
    and then stop running the code. The application is terminated. This is better
    than allowing the code to continue executing in a potentially corrupt state. Your
    code should only catch and handle exceptions that it understands and can properly
    fix.
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，控制台应用程序或.NET交互式笔记本的默认行为是输出有关异常的消息，包括堆栈跟踪，然后停止运行代码。应用程序被终止。这比允许代码继续在可能处于损坏状态的情况下执行要好。您的代码应该只捕获和处理它理解并且可以正确修复的异常。
- en: '**Good Practice** : Avoid writing code that will throw an exception whenever
    possible, perhaps by performing `if` statement checks. Sometimes you can''t, and
    sometimes it is best to allow the exception to be caught by a higher-level component
    that is calling your code. You will learn how to do this in *Chapter 4* , *Writing,
    Debugging, and Testing Functions* .'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：尽量避免编写可能引发异常的代码，也许可以通过执行`if`语句检查来实现。有时候你不能，有时候最好让异常被调用你的代码的更高级组件捕获。您将在*第4章*，*编写、调试和测试函数*中学习如何做到这一点。'
- en: Wrapping error-prone code in a try block
  id: totrans-1291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将易出错的代码包装在try块中
- en: When you know that a statement can cause an error, you should wrap that statement
    in a `try` block. For example, parsing from text to a number can cause an error.
    Any statements in the `catch` block will be executed only if an exception is thrown
    by a statement in the `try` block.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 当您知道某个语句可能会导致错误时，应该将该语句包装在`try`块中。例如，从文本解析为数字可能会导致错误。`catch`块中的任何语句只有在`try`块中的语句抛出异常时才会执行。
- en: 'We don''t have to do anything inside the `catch` block. Let''s see this in
    action:'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必在`catch`块中做任何事情。让我们看看它的运行情况：
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter03`
    workspace/solution named `HandlingExceptions` .
  id: totrans-1294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的编码工具将新的**控制台应用程序**添加到名为`HandlingExceptions`的`Chapter03`工作区/解决方案中。
- en: In Visual Studio Code, select `HandlingExceptions` as the active OmniSharp project.
  id: totrans-1295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，将`HandlingExceptions`选择为活动的OmniSharp项目。
- en: 'Type statements to prompt the user to enter their age and then write their
    age to the console, as shown in the following code:'
  id: totrans-1296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入语句提示用户输入他们的年龄，然后将他们的年龄写入控制台，如下面的代码所示：
- en: '```cs'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: WriteLine("Before parsing"
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("Before parsing"
- en: );
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Write("What is your age? "
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: Write("你多大了？ "
- en: );
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: string
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: '? input = ReadLine(); // or use "49" in a notebook'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: '? input = ReadLine(); // or use "49" in a notebook'
- en: try
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试
- en: '{'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: age = int
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 年龄 = int
- en: .Parse(input);
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: .Parse(input);
- en: WriteLine($"You are
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"您今年
- en: '{age}'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: '{年龄}'
- en: years old."
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 岁了。"
- en: );
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: catch
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: catch
- en: '{'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '}'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: WriteLine("After parsing"
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("解析之后"
- en: );
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'You will see the following compiler message: `Warning CS8604 Possible null
    reference argument for parameter ''s'' in ''int int.Parse(string s)''.` By default
    in new .NET 6 projects, Microsoft has enabled nullable reference types so you
    will see many more compiler warnings like this. In production code, you should
    add code to check for `null` and handle that possibility appropriately. In this
    book, I will not include these `null` checks because the code samples are not
    designed to be production quality and `null` checks everywhere will clutter the
    code and use up valuable pages. In this case, it is impossible for `input` to
    be `null` because the user must press Enter for `ReadLine` to return and that
    will return an empty `string` . You will see hundreds of more examples of potentially
    `null` variables throughout the code samples in this book. Those warnings are
    safe to ignore for the book code examples. You only need similar warnings when
    you write your own production code. You will see more about null handling in *Chapter
    6* , *Implementing Interfaces and Inheriting Classes* .'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下编译器消息：`警告 CS8604 可能的空引用参数's'在'int int.Parse(string s)'中。`在新的.NET 6项目中，默认情况下，Microsoft
    已启用了可空引用类型，因此您将看到更多类似的编译器警告。在生产代码中，您应该添加代码来检查 `null` 并适当处理可能性。在本书中，我不会包括这些 `null`
    检查，因为代码示例并非设计为生产质量，而且到处都是 `null` 检查会使代码混乱，并占用宝贵的页面。在这种情况下，`input` 不可能为 `null`，因为用户必须按
    Enter 键才能使 `ReadLine` 返回，并且这将返回一个空的 `string`。在本书的代码示例中，您将看到数百个潜在的 `null` 变量示例。这些警告在书中的代码示例中是可以忽略的。只有在编写自己的生产代码时才需要类似的警告。在
    *第6章*，*实现接口和继承类* 中，您将了解更多关于空值处理的内容。
- en: This code includes two messages to indicate *before* parsing and *after* parsing
    to make clearer the flow through the code. These will be especially useful as
    the example code grows more complex.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包括两条消息，指示*解析之前*和*解析之后*，以便更清楚地了解代码的流程。随着示例代码变得更加复杂，这将特别有用。
- en: 'Run the code, enter `49` , and view the result, as shown in the following output:'
  id: totrans-1322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入 `49`，并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Before parsing
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 解析之前
- en: What is your age? 49
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 你多大了？ 49
- en: You are 49 years old.
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 你今年49岁。
- en: After parsing
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 解析之后
- en: '```'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code, enter `Kermit` , and view the result, as shown in the following
    output:'
  id: totrans-1329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，输入 `Kermit`，并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Before parsing
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 解析之前
- en: What is your age? Kermit
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 你多大了？ Kermit
- en: After parsing
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 解析之后
- en: '```'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: When the code was executed, the error exception was caught and the default message
    and stack trace were not output, and the console application continued running.
    This is better than the default behavior, but it might be useful to see the type
    of error that occurred.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码被执行时，错误异常被捕获，但默认消息和堆栈跟踪没有输出，控制台应用程序继续运行。这比默认行为要好，但可能有必要看到发生的错误类型。
- en: '**Good Practice** : You should never use an empty `catch` statement like this
    in production code because it "swallows" exceptions and hides potential problems.
    You should at least log the exception if you cannot or do not want to handle it
    properly, or rethrow it so that higher-level code can decide instead. You will
    learn about logging in *Chapter 4* , *Writing, Debugging, and Testing Functions*
    .'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：在生产代码中，您不应该使用空的 `catch` 语句，因为它会“吞没”异常并隐藏潜在的问题。如果您无法或不想正确处理异常，至少应该记录异常，或者重新抛出异常，以便更高级别的代码可以决定。您将在
    *第4章*，*编写、调试和测试函数* 中了解有关日志记录的内容。'
- en: Catching all exceptions
  id: totrans-1337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获所有异常
- en: 'To get information about any type of exception that might occur, you can declare
    a variable of type `System.Exception` to the `catch` block:'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取可能发生的任何类型的异常信息，可以在 `catch` 块中声明一个类型为 `System.Exception` 的变量：
- en: 'Add an exception variable declaration to the `catch` block and use it to write
    information about the exception to the console, as shown in the following code:'
  id: totrans-1339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `catch` 块中添加异常变量声明，并使用它将异常信息写入控制台，如下面的代码所示：
- en: '```cs'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: catch (Exception ex)
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: catch (Exception ex)
- en: '{'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine($"
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{ex.GetType()}'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: '{ex.GetType()}'
- en: says
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 说
- en: '{ex.Message}'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: '{ex.Message}'
- en: '"'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code, enter `Kermit` again, and view the result, as shown in the following
    output:'
  id: totrans-1351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，再次输入 `Kermit`，并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Before parsing
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 解析之前
- en: What is your age? Kermit
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 你多大了？ Kermit
- en: System.FormatException says Input string was not in a correct format.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: System.FormatException 表示输入字符串格式不正确。
- en: After parsing
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 解析之后
- en: '```'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Catching specific exceptions
  id: totrans-1358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获特定异常
- en: 'Now that we know which specific type of exception occurred, we can improve
    our code by catching just that type of exception a nd customizing the message
    that we display to the user:'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道发生了哪种特定类型的异常，我们可以通过仅捕获该类型的异常并自定义向用户显示的消息来改进我们的代码：
- en: 'Leave the existing `catch` block, and above it, add a new `catch` block for
    the format exception type, as shown in the following highlighted code:'
  id: totrans-1360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留现有的 `catch` 块，并在其上方添加一个新的格式异常类型的 `catch` 块，如下面突出显示的代码所示：
- en: '```cs'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '**catch (FormatException)**'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: '**catch (FormatException)**'
- en: '**{**'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: '**WriteLine(**'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: '**WriteLine(**'
- en: '**"The age you entered is not a valid number format."**'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: '**"您输入的年龄不是有效的数字格式。"**'
- en: '**);**'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: '**);**'
- en: '**}**'
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: catch (Exception ex)
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: catch (Exception ex)
- en: '{'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine($"
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{ex.GetType()}'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: '{ex.GetType()}'
- en: says
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 说
- en: '{ex.Message}'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: '{ex.Message}'
- en: '"'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code, enter `Kermit` again, and view the result, as shown in the following
    output:'
  id: totrans-1378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，再次输入 `Kermit`，并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Before parsing
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 解析之前
- en: What is your age? Kermit
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 你多大了？ Kermit
- en: The age you entered is not a valid number format.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 您输入的年龄不是有效的数字格式。
- en: After parsing
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 解析之后
- en: '```'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The reason we want to leave the more general catch below is that there might
    be other types of exceptions that can occur.
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, enter `9876543210` , and view the result, as shown in the following
    output:'
  id: totrans-1386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: Before parsing
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
- en: What is your age? 9876543210
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
- en: System.OverflowException says Value was either too large or too small for an
    Int32.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
- en: After parsing
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
- en: Let's add another `catch` block for this type of exception.
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
- en: 'Leave the existing `catch` blocks, and add a new `catch` block for the overflow
    exception type, as shown in the following highlighted code:'
  id: totrans-1394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
- en: '**catch (OverflowException)**'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
- en: '**WriteLine(**'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
- en: '**"Your age is a valid number format but it is either too big or small."**'
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
- en: '**);**'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
- en: catch (FormatException)
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("The age you entered is not a valid number format."
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, enter `9876543210` , and view the result, as shown in the following
    output:'
  id: totrans-1408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
- en: Before parsing
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: What is your age? 9876543210
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
- en: Your age is a valid number format but it is either too big or small.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
- en: After parsing
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
- en: The order in which you catch exceptions is important. The correct order is related
    to the inheritance hierarchy of the exception types. You will learn about inheritance
    in *Chapter 5* , *Building Your Own Types with Object-Oriented Programming* .
    However, don't worry too much about this—the compiler will give you build errors
    if you get exceptions in the wrong order anyway.
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Avoid over-catching exceptions. They should often be allowed
    to propagate up the call stack to be handled at a level where more information
    is known about the circumstances that could change the logic of how they should
    be handled. You will learn about this in *Chapter 4* , *Writing, Debugging, and
    Testing Functions* .'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
- en: Catching with filters
  id: totrans-1417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also add filters to a catch statement using the `when` keyword, as
    shown in the following code:'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
- en: 'Write("Enter an amount: "'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
- en: '? amount = ReadLine();'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: try
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
- en: amountValue = decimal
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
- en: .Parse(amount);
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
- en: catch (FormatException) when
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: (amount.Contains("$"
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
- en: ))
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Amounts cannot use the dollar sign!"
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: catch (FormatException)
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Amounts must only contain digits!"
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
- en: Checking for overflow
  id: totrans-1443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we saw that when casting between number types, it was possible to lose
    information, for example, when casting from a `long` variable to an `int` variable.
    If the value stored in a type is too big, it will overflow.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: Throwing overflow exceptions with the checked statement
  id: totrans-1445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `checked` statement tells .NET to throw an exception when an overflow happens
    instead of allowing it to happen silently, which is done by default for performance
    reasons.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
- en: 'We will set the initial value of an `int` variable to its maximum value minus
    one. Then, we will increment it several times, outputting its value each time.
    Once it gets above its maximum value, it overflows to its minimum value and continues
    incrementing from there. Let''s see this in action:'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter03`
    workspace/solution named `CheckingForOverflow` .
  id: totrans-1448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `CheckingForOverflow` as the active OmniSharp
    project.
  id: totrans-1449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs` , type statements to declare and assign an integer to one less
    than its maximum possible value, and then increment it and write its value to
    the console three times, as shown in the following code:'
  id: totrans-1450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
- en: x = int
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: .MaxValue - 1
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Initial value:'
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: '{x}'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
- en: x++;
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"After incrementing:'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
- en: '{x}'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
- en: x++;
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"After incrementing:'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
- en: '{x}'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: x++;
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"After incrementing:'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: '{x}'
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result that shows the value overflowing silently
    and wrapping around to large negative values, as shown in the following output:'
  id: totrans-1476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: 'Initial value: 2147483646'
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: 'After incrementing: 2147483647'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
- en: 'After incrementing: -2147483648'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: 'After incrementing: -2147483647'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s get the compiler to warn us about the overflow by wrapping the
    statements using a `checked` statement block, as shown highlighted in the following
    code:'
  id: totrans-1483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过使用`checked`语句块来包装语句，让编译器警告我们溢出，如下面的代码中所示：
- en: '```cs'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '**checked**'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: '**checked**'
- en: '**{**'
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: int
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: x = int
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: x = int
- en: .MaxValue - 1
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: .MaxValue - 1
- en: ;
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: 'WriteLine($"Initial value:'
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"初始值：
- en: '{x}'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: '{x}'
- en: '"'
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: x++;
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: x++;
- en: 'WriteLine($"After incrementing:'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"递增后：
- en: '{x}'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: '{x}'
- en: '"'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: x++;
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: x++;
- en: 'WriteLine($"After incrementing:'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"递增后：
- en: '{x}'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: '{x}'
- en: '"'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: x++;
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: x++;
- en: 'WriteLine($"After incrementing:'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"递增后：
- en: '{x}'
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: '{x}'
- en: '"'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '**}**'
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '```'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result that shows the overflow being checked and
    causing an exception to be thrown, as shown in the following output:'
  id: totrans-1512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，显示检查溢出并导致抛出异常，如下面的输出所示：
- en: '```cs'
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Initial value: 2147483646'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 初始值：2147483646
- en: 'After incrementing: 2147483647'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: 递增后：2147483647
- en: 'Unhandled Exception: System.OverflowException: Arithmetic operation resulted
    in an overflow.'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 未处理的异常：System.OverflowException：算术运算导致溢出。
- en: '```'
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Just like any other exception, we should wrap these statements in a `try` statement
    block and display a nicer error message for the user, as shown in the following
    code:'
  id: totrans-1518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像任何其他异常一样，我们应该将这些语句包装在`try`语句块中，并为用户显示一个更好的错误消息，如下面的代码所示：
- en: '```cs'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: try
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: try
- en: '{'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // previous code goes here
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: // 前面的代码放在这里
- en: '}'
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: catch (OverflowException)
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: catch (OverflowException)
- en: '{'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine("The code overflowed but I caught the exception."
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("代码溢出，但我捕获了异常。"
- en: );
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Initial value: 2147483646'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: 初始值：2147483646
- en: 'After incrementing: 2147483647'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 递增后：2147483647
- en: The code overflowed but I caught the exception.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 代码溢出，但我捕获了异常。
- en: '```'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Disabling compiler overflow checks with the unchecked statement
  id: totrans-1536
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用未经检查的语句禁用编译器溢出检查
- en: The previous section was about the default overflow behavior at *runtime* and
    how to use the `checked` statement to change that behavior. This section is about
    *compile time* overflow behavior and how to use the `unchecked` statement to change
    that behavior.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节是关于*运行时*的默认溢出行为以及如何使用`checked`语句来更改该行为。本节是关于*编译时*溢出行为以及如何使用`unchecked`语句来更改该行为。
- en: 'A related keyword is `unchecked` . This keyword switches off overflow checks
    performed by the compiler within a block of code. Let''s see how to do this:'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的关键字是`unchecked`。这个关键字关闭编译器在一段代码块中执行的溢出检查。让我们看看如何做到这一点：
- en: 'Type the following statement at the end of the previous statements. The compiler
    will not compile this statement because it knows it would overflow:'
  id: totrans-1539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的语句末尾键入以下语句。编译器不会编译此语句，因为它知道会溢出：
- en: '```cs'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: y = int
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: y = int
- en: .MaxValue + 1
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: .MaxValue + 1
- en: ;
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '```'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Hover your mouse pointer over the error, and note a compile-time check is shown
    as an error message, as shown in *Figure 3.1* :![Graphical user interface, text,
    application, email Description automatically generated](img/Image00039.jpg)
  id: totrans-1546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标指针悬停在错误上，并注意显示编译时检查的错误消息，如*图3.1*所示：![图形用户界面，文本，应用程序，电子邮件自动生成的描述](img/Image00039.jpg)
- en: 'Figure 3.1: A compile-time check in the PROBLEMS window'
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：在PROBLEMS窗口中的编译时检查
- en: 'To disable compile-time checks, wrap the statement in an `unchecked` block,
    write the value of `y` to the console, decrement it, and repeat, as shown in the
    following code:'
  id: totrans-1548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要禁用编译时检查，将语句包装在`unchecked`块中，将`y`的值写入控制台，递减它，并重复，如下面的代码所示：
- en: '```cs'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: unchecked
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 未经检查的
- en: '{'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: y = int
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: y = int
- en: .MaxValue + 1
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: .MaxValue + 1
- en: ;
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: 'WriteLine($"Initial value:'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"初始值：
- en: '{y}'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: '{y}'
- en: '"'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: y--;
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: y--;
- en: 'WriteLine($"After decrementing:'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"递减后：
- en: '{y}'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: '{y}'
- en: '"'
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: y--;
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: y--;
- en: 'WriteLine($"After decrementing:'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"递减后：
- en: '{y}'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: '{y}'
- en: '"'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the results, as shown in the following output:'
  id: totrans-1572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Initial value: -2147483648'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 初始值：-2147483648
- en: 'After decrementing: 2147483647'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: 递减后：2147483647
- en: 'After decrementing: 2147483646'
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 递减后：2147483646
- en: '```'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Of course, it would be rare that you would want to explicitly switch off a check
    like this because it allows an overflow to occur. But perhaps you can think of
    a scenario where you might want that behavior.
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你很少会想要明确关闭这样的检查，因为它允许溢出发生。但也许你可以想到一个情景，你可能希望出现这种行为。
- en: Practicing and exploring
  id: totrans-1579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore with deeper research into this chapter's topics.
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题来测试你的知识和理解，进行一些实践，并深入研究本章主题。
- en: Exercise 3.1 – Test your knowledge
  id: totrans-1581
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.1 - 测试你的知识
- en: 'Answer the following questions:'
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题：
- en: What happens when you divide an `int` variable by `0` ?
  id: totrans-1583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你将`int`变量除以`0`时会发生什么？
- en: What happens when you divide a `double` variable by `0` ?
  id: totrans-1584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你将`double`变量除以`0`时会发生什么？
- en: What happens when you overflow an `int` variable, that is, set it to a value
    beyond its range?
  id: totrans-1585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你溢出一个`int`变量时会发生什么？
- en: What is the difference between `x = y++;` and `x = ++y;` ?
  id: totrans-1586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x = y++;`和`x = ++y;`之间有什么区别？'
- en: What is the difference between `break` , `continue` , and `return` when used
    inside a loop statement?
  id: totrans-1587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环语句中使用`break`，`continue`和`return`时有什么区别？
- en: What are the three parts of a `for` statement and which of them are required?
  id: totrans-1588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`for`语句的三个部分是什么，它们中的哪些是必需的？'
- en: What is the difference between the `=` and `==` operators?
  id: totrans-1589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`=`和`==`运算符之间有什么区别？'
- en: Does the following statement compile?
  id: totrans-1590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下语句是否编译？
- en: '```cs'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: for
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: for
- en: ( ; true
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: ( ; true
- en: ; ) ;
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: ; ) ;
- en: '```'
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: What does the underscore `_` represent in a `switch` expression?
  id: totrans-1596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`switch`表达式中的下划线`_`代表什么？'
- en: What interface must an object implement to be enumerated over by using the `foreach`
    statement?
  id: totrans-1597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象必须实现哪个接口才能通过`foreach`语句进行枚举？
- en: Exercise 3.2 – Explore loops and overflow
  id: totrans-1598
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.2 - 探索循环和溢出
- en: What will happen if this code executes?
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这段代码执行会发生什么？
- en: '```cs'
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: max = 500
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: max = 500
- en: ;
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: for
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: for
- en: (byte
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: (byte
- en: i = 0
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: ; i < max; i++)
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: ; i < max; i++)
- en: '{'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine(i);
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine(i);
- en: '}'
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Create a console application in `Chapter03` named `Exercise02` and enter the
    preceding code. Run the console application and view the output. What happens?
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter03`中创建一个名为`Exercise02`的控制台应用程序，并输入上述代码。运行控制台应用程序并查看输出。会发生什么？
- en: What code could you add (don't change any of the preceding code) to warn us
    about the problem?
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加什么代码（不要更改任何先前的代码）来警告我们有关问题？
- en: Exercise 3.3 – Practice loops and operators
  id: totrans-1614
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.3–练习循环和运算符
- en: '**FizzBuzz** is a group word game for children to teach them about division.
    Players take turns to count incrementally, replacing any number divisible by three
    with the word *fizz* , any number divisible by five with the word *buzz* , and
    any number divisible by both with *fizzbuzz* .'
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: '**FizzBuzz**是一个儿童的团体词游戏，教他们关于除法。玩家轮流递增计数，用单词*fizz*替换任何可以被三整除的数字，用单词*buzz*替换任何可以被五整除的数字，用*fizzbuzz*替换任何可以同时被三和五整除的数字。'
- en: 'Create a console application in `Chapter03` named `Exercise03` that outputs
    a simulated FizzBuzz game counting up to 100\. The output should look something
    like *Figure 3.2* :'
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter03`中创建一个名为`Exercise03`的控制台应用程序，输出一个模拟的FizzBuzz游戏，计数到100。输出应该类似于*图3.2*：
- en: '![Text Description automatically generated](img/Image00040.jpg)'
  id: totrans-1617
  prefs: []
  type: TYPE_IMG
  zh: '![自动生成的文本描述](img/Image00040.jpg)'
- en: 'Figure 3.2: A simulated FizzBuzz game output'
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：模拟的FizzBuzz游戏输出
- en: Exercise 3.4 – Practice exception handling
  id: totrans-1619
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.4–练习异常处理
- en: 'Create a console application in `Chapter03` named `Exercise04` that asks the
    user for two numbers in the range 0-255 and then divides the first number by the
    second:'
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter03`中创建一个名为`Exercise04`的控制台应用程序，询问用户两个范围在0-255之间的数字，然后将第一个数字除以第二个数字：
- en: '```cs'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Enter a number between 0 and 255: 100'
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个介于0和255之间的数字：100
- en: 'Enter another number between 0 and 255: 8'
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: 输入另一个介于0和255之间的数字：8
- en: 100 divided by 8 is 12
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 100除以8等于12
- en: '```'
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Write exception handlers to catch any thrown errors, as shown in the following
    output:'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 编写异常处理程序以捕获任何抛出的错误，如下面的输出所示：
- en: '```cs'
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Enter a number between 0 and 255: apples'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个介于0和255之间的数字：苹果
- en: 'Enter another number between 0 and 255: bananas'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: 输入另一个介于0和255之间的数字：香蕉
- en: 'FormatException: Input string was not in a correct format.'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 格式异常：输入字符串格式不正确。
- en: '```'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Exercise 3.5 – Test your knowledge of operators
  id: totrans-1632
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.5–测试您对运算符的了解
- en: What are the values of `x` and `y` after the following statements execute?
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下语句执行后，`x`和`y`的值是多少？
- en: 'Increment and addition operators:'
  id: totrans-1634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递增和加法运算符：
- en: '```cs'
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: x = 3
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: x = 3
- en: ;
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: y = 2
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: y = 2
- en: + ++x;
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: + ++x;
- en: '```'
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Binary shift operators:'
  id: totrans-1641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二进制移位运算符：
- en: '```cs'
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: x = 3
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: x = 3
- en: << 2
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: << 2
- en: ;
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: y = 10
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: y = 10
- en: '>> 1'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: '>> 1'
- en: ;
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '```'
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Bitwise operators:'
  id: totrans-1650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 位运算符：
- en: '```cs'
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: x = 10
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: x = 10
- en: '& 8'
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: '& 8'
- en: ;
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: y = 10
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: y = 10
- en: '| 7'
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: '| 7'
- en: ;
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '```'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Exercise 3.6 – Explore topics
  id: totrans-1659
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.6–探索主题
- en: 'Use the links on the following page to learn about the topics covered in this
    chapter in more detail:'
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下页面上的链接详细了解本章涵盖的主题：
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-3---controlling-flow-and-converting-types](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-3---controlling-flow-and-converting-types)'
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-3---controlling-flow-and-converting-types](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-3---controlling-flow-and-converting-types)'
- en: Summary
  id: totrans-1662
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you experimented with some operators, learned how to branch
    and loop, how to convert between types, and how to catch exceptions.
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您尝试了一些运算符，学习了如何分支和循环，如何在类型之间转换，以及如何捕获异常。
- en: You are now ready to learn how to reuse blocks of code by defining functions,
    how to pass values into them and get values back, and how to track down bugs in
    your code and squash them!
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经准备好学习如何通过定义函数重用代码块，如何将值传递给它们并获取返回值，以及如何跟踪代码中的错误并消除它们！

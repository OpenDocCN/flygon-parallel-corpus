- en: 08
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Common .NET Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about some common types that are included with .NET. These include
    types for manipulating numbers, text, collections, network access, reflection,
    and attributes; improving working with spans, indexes, and ranges; manipulating
    images; and internationalization.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with dates and times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching with regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing multiple objects in collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with spans, indexes, and ranges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with network resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with reflection and attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalizing your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common types of data is numbers. The most common types in .NET
    for working with numbers are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Namespace | Example type(s) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `System` | `SByte` , `Int16` , `Int32` , `Int64` | Integers; that is, zero
    and positive and negative whole numbers |'
  prefs: []
  type: TYPE_TB
- en: '| `System` | `Byte` , `UInt16` , `UInt32` , `UInt64` | Cardinals; that is,
    zero and positive whole numbers |'
  prefs: []
  type: TYPE_TB
- en: '| `System` | `Half` , `Single` , `Double` | Reals; that is, floating-point
    numbers |'
  prefs: []
  type: TYPE_TB
- en: '| `System` | `Decimal` | Accurate reals; that is, for use in science, engineering,
    or financial scenarios |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Numerics` | `BigInteger` , `Complex` , `Quaternion` | Arbitrarily
    large integers, complex numbers, and quaternion numbers |'
  prefs: []
  type: TYPE_TB
- en: .NET has had the 32-bit float and 64-bit double types since .NET Framework 1.0\.
    The IEEE 754 specification also defines a 16-bit floating point standard. Machine
    learning and other algorithms would benefit from this smaller, lower-precision
    number type so Microsoft introduced the `System.Half` type with .NET 5 and later.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the C# language does not define a `half` alias so you must use the
    .NET type `System.Half` . This might change in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Working with big integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The largest whole number that can be stored in .NET types that have a C# alias
    is about eighteen and a half quintillion, stored in an unsigned `long` integer.
    But what if you need to store numbers larger than that?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore numerics:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to create a new solution/workspace named `Chapter08`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a console app project, as defined in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console Application** / `console`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `Chapter08`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `WorkingWithNumbers`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs` , delete the existing statements and add a statement to import
    `System.Numerics` , as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.Numerics;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to output the maximum value of the `ulong` type, and a number
    with 30 digits using `BigInteger` , as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Working with large integers:"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("-----------------------------------"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: ulong
  prefs: []
  type: TYPE_NORMAL
- en: big = ulong
  prefs: []
  type: TYPE_NORMAL
- en: .MaxValue;
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{big,'
  prefs: []
  type: TYPE_NORMAL
- en: '40'
  prefs: []
  type: TYPE_NORMAL
- en: :N0}
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: BigInteger bigger =
  prefs: []
  type: TYPE_NORMAL
- en: BigInteger.Parse("123456789012345678901234567890"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{bigger,'
  prefs: []
  type: TYPE_NORMAL
- en: '40'
  prefs: []
  type: TYPE_NORMAL
- en: :N0}
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The `40` in the format code means right-align 40 characters, so both numbers
    are lined up to the right-hand edge. The `N0` means use thousand separators and
    zero decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with large integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '----------------------------------------'
  prefs: []
  type: TYPE_NORMAL
- en: 18,446,744,073,709,551,615
  prefs: []
  type: TYPE_NORMAL
- en: 123,456,789,012,345,678,901,234,567,890
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Working with complex numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A complex number can be expressed as *a + bi* , where *a* and *b* are real numbers,
    and *i* is an imaginary unit, where *i* ² *= −1* . If the real part *a* is zero,
    it is a pure imaginary number. If the imaginary part *b* is zero, it is a real
    number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complex numbers have practical applications in many **STEM** (**science, technology,
    engineering, and mathematics** ) fields of study. Additionally, they are added
    by separately adding the real and imaginary parts of the summands; consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: (a + bi) + (c + di) = (a + c) + (b + d)i
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore complex numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to add two complex numbers, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Working with complex numbers:"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Complex c1 = new
  prefs: []
  type: TYPE_NORMAL
- en: '(real: 4'
  prefs: []
  type: TYPE_NORMAL
- en: ', imaginary: 2'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Complex c2 = new
  prefs: []
  type: TYPE_NORMAL
- en: '(real: 3'
  prefs: []
  type: TYPE_NORMAL
- en: ', imaginary: 7'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Complex c3 = c1 + c2;
  prefs: []
  type: TYPE_NORMAL
- en: // output using default ToString implementation
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{c1}'
  prefs: []
  type: TYPE_NORMAL
- en: added to
  prefs: []
  type: TYPE_NORMAL
- en: '{c2}'
  prefs: []
  type: TYPE_NORMAL
- en: is
  prefs: []
  type: TYPE_NORMAL
- en: '{c3}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: // output using custom format
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0} + {1}i added to {2} + {3}i is {4} + {5}i"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: c1.Real, c1.Imaginary,
  prefs: []
  type: TYPE_NORMAL
- en: c2.Real, c2.Imaginary,
  prefs: []
  type: TYPE_NORMAL
- en: c3.Real, c3.Imaginary);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with complex numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: (4, 2) added to (3, 7) is (7, 9)
  prefs: []
  type: TYPE_NORMAL
- en: 4 + 2i added to 3 + 7i is 7 + 9i
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding quaternions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quaternions are a number system that extends complex numbers. They form a four-dimensional
    associative normed division algebra over the real numbers, and therefore also
    a domain.
  prefs: []
  type: TYPE_NORMAL
- en: Huh? Yes, I know. I don't understand that either. Don't worry; we're not going
    to write any code using them! Suffice to say, they are good at describing spatial
    rotations, so video game engines use them, as do many computer simulations and
    flight control systems.
  prefs: []
  type: TYPE_NORMAL
- en: Working with text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the other most common types of data for variables is text. The most
    common types in .NET for working with text are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Namespace | Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `System` | `Char` | Storage for a single text character |'
  prefs: []
  type: TYPE_TB
- en: '| `System` | `String` | Storage for multiple text characters |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Text` | `StringBuilder` | Efficiently manipulates strings |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Text.RegularExpressions` | `Regex` | Efficiently pattern-matches
    strings |'
  prefs: []
  type: TYPE_TB
- en: Getting the length of a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore some common tasks when working with text; for example, sometimes
    you need to find out the length of a piece of text stored in a `string` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to add a new console app named `WorkingWithText`
    to the `Chapter08` solution/workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, set the startup project for the solution to the current selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithText` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `WorkingWithText` project, in `Program.cs` , add statements to define
    a variable to store the name of the city London, and then write its name and length
    to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: city = "London"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{city}'
  prefs: []
  type: TYPE_NORMAL
- en: is
  prefs: []
  type: TYPE_NORMAL
- en: '{city.Length}'
  prefs: []
  type: TYPE_NORMAL
- en: characters long."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: London is 6 characters long.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Getting the characters of a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `string` class uses an array of `char` internally to store the text. It
    also has an indexer, which means that we can use the array syntax to read its
    characters. Array indexes start at zero, so the third character will be at index
    2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a statement to write the characters at the first and third positions in
    the `string` variable, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"First char is
  prefs: []
  type: TYPE_NORMAL
- en: '{city['
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: ']}'
  prefs: []
  type: TYPE_NORMAL
- en: and third is
  prefs: []
  type: TYPE_NORMAL
- en: '{city['
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: ']}'
  prefs: []
  type: TYPE_NORMAL
- en: ."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: First char is L and third is n.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Splitting a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to split some text wherever there is a character, such
    as a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to define a single `string` variable containing comma-separated
    city names, then use the `Split` method and specify that you want to treat commas
    as the separator, and then enumerate the returned array of `string` values, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: cities = "Paris,Tehran,Chennai,Sydney,New York,Medellín"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '[] citiesArray = cities.Split('','''
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"There are
  prefs: []
  type: TYPE_NORMAL
- en: '{citiesArray.Length}'
  prefs: []
  type: TYPE_NORMAL
- en: items in the array."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (string
  prefs: []
  type: TYPE_NORMAL
- en: item in
  prefs: []
  type: TYPE_NORMAL
- en: citiesArray)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(item);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: There are 6 items in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Paris
  prefs: []
  type: TYPE_NORMAL
- en: Tehran
  prefs: []
  type: TYPE_NORMAL
- en: Chennai
  prefs: []
  type: TYPE_NORMAL
- en: Sydney
  prefs: []
  type: TYPE_NORMAL
- en: New York
  prefs: []
  type: TYPE_NORMAL
- en: Medellín
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, you will learn how to handle more complex scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Getting part of a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to get part of some text. The `IndexOf` method has nine
    overloads that return the index position of a specified `char` or `string` within
    a `string` . The `Substring` method has two overloads, as shown in the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Substring(startIndex, length)` : returns a substring starting at `startIndex`
    and containing the next `length` characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Substring(startIndex)` : returns a substring starting at `startIndex` and
    containing all characters up to the end of the string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s explore a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to store a person''s full name in a `string` variable with a
    space character between the first and last name, find the position of the space,
    and then extract the first name and last name as two parts so that they can be
    recombined in a different order, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: fullName = "Alan Jones"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: indexOfTheSpace = fullName.IndexOf(' '
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: firstName = fullName.Substring(
  prefs: []
  type: TYPE_NORMAL
- en: 'startIndex: 0'
  prefs: []
  type: TYPE_NORMAL
- en: ', length: indexOfTheSpace);'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: lastName = fullName.Substring(
  prefs: []
  type: TYPE_NORMAL
- en: 'startIndex: indexOfTheSpace + 1'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Original:'
  prefs: []
  type: TYPE_NORMAL
- en: '{fullName}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Swapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '{lastName}'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: '{firstName}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Original: Alan Jones'
  prefs: []
  type: TYPE_NORMAL
- en: 'Swapped: Jones, Alan'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If the format of the initial full name was different, for example, `"LastName,
    FirstName"` , then the code would need to be different. As an optional exercise,
    try writing some statements that would change the input `"Jones, Alan"` into `"Alan
    Jones"` .
  prefs: []
  type: TYPE_NORMAL
- en: Checking a string for content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to check whether a piece of text starts or ends with some
    characters or contains some characters. You can achieve this with methods named
    `StartsWith` , `EndsWith` , and `Contains` :'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to store a `string` value and then check if it starts with or
    contains a couple of different `string` values, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: company = "Microsoft"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: startsWithM = company.StartsWith("M"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: containsN = company.Contains("N"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Text:'
  prefs: []
  type: TYPE_NORMAL
- en: '{company}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Starts with M:'
  prefs: []
  type: TYPE_NORMAL
- en: '{startsWithM}'
  prefs: []
  type: TYPE_NORMAL
- en: ', contains an N:'
  prefs: []
  type: TYPE_NORMAL
- en: '{containsN}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text: Microsoft'
  prefs: []
  type: TYPE_NORMAL
- en: 'Starts with M: True, contains an N: False'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Joining, formatting, and other string members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many other `string` members, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Member | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `Trim` , `TrimStart` , `TrimEnd` | These methods trim whitespace characters
    such as space, tab, and carriage return from the beginning and/or end. |'
  prefs: []
  type: TYPE_TB
- en: '| `ToUpper` , `ToLower` | These convert all the characters into uppercase or
    lowercase. |'
  prefs: []
  type: TYPE_TB
- en: '| `Insert` , `Remove` | These methods insert or remove some text. |'
  prefs: []
  type: TYPE_TB
- en: '| `Replace` | This replaces some text with other text. |'
  prefs: []
  type: TYPE_TB
- en: '| `string.Empty` | This can be used instead of allocating memory each time
    you use a literal `string` value using an empty pair of double quotes (`""` ).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `string.Concat` | This concatenates two `string` variables. The + operator
    does the equivalent when used between `string` operands. |'
  prefs: []
  type: TYPE_TB
- en: '| `string.Join` | This concatenates one or more `string` variables with a character
    in between each one. |'
  prefs: []
  type: TYPE_TB
- en: '| `string.IsNullOrEmpty` | This checks whether a `string` variable is `null`
    or empty. |'
  prefs: []
  type: TYPE_TB
- en: '| `string.IsNullOrWhitespace` | This checks whether a `string` variable is
    `null` or whitespace; that is, a mix of any number of horizontal and vertical
    spacing characters, for example, tab, space, carriage return, line feed, and so
    on. |'
  prefs: []
  type: TYPE_TB
- en: '| `string.Format` | An alternative method to string interpolation for outputting
    formatted `string` values, which uses positioned instead of named parameters.
    |'
  prefs: []
  type: TYPE_TB
- en: Some of the preceding methods are static methods. This means that the method
    can only be called from the type, not from a variable instance. In the preceding
    table, I indicated the static methods by prefixing them with `string.` , as in
    `string.Format` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore some of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to take an array of string values and combine them back together
    into a single string variable with separators using the `Join` method, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: recombined = string
  prefs: []
  type: TYPE_NORMAL
- en: .Join(" => "
  prefs: []
  type: TYPE_NORMAL
- en: ', citiesArray);'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(recombined);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Paris => Tehran => Chennai => Sydney => New York => Medellín
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to use positioned parameters and interpolated string formatting
    syntax to output the same three variables twice, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: fruit = "Apples"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  prefs: []
  type: TYPE_NORMAL
- en: price =  0.39
  prefs: []
  type: TYPE_NORMAL
- en: M;
  prefs: []
  type: TYPE_NORMAL
- en: DateTime when
  prefs: []
  type: TYPE_NORMAL
- en: = DateTime.Today;
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Interpolated:'
  prefs: []
  type: TYPE_NORMAL
- en: '{fruit}'
  prefs: []
  type: TYPE_NORMAL
- en: cost
  prefs: []
  type: TYPE_NORMAL
- en: '{price:C}'
  prefs: []
  type: TYPE_NORMAL
- en: 'on'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: when
  prefs: []
  type: TYPE_NORMAL
- en: :dddd}
  prefs: []
  type: TYPE_NORMAL
- en: ."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(string
  prefs: []
  type: TYPE_NORMAL
- en: '.Format("string.Format: {0} cost {1:C} on {2:dddd}."'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: fruit, arg1: price, arg2: when'
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interpolated:  Apples cost £0.39 on Thursday.'
  prefs: []
  type: TYPE_NORMAL
- en: 'string.Format: Apples cost £0.39 on Thursday.'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we could have simplified the second statement because `WriteLine`
    supports the same format codes as `string.Format` , as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("WriteLine: {0} cost {1:C} on {2:dddd}."'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: fruit, arg1: price, arg2: when'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Building strings efficiently
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can concatenate two strings to make a new `string` using the `String.Concat`
    method or simply by using the `+` operator. But both of these choices are bad
    practice because .NET must create a completely new `string` in memory.
  prefs: []
  type: TYPE_NORMAL
- en: This might not be noticeable if you are only adding two `string` values, but
    if you concatenate inside a loop with many iterations, it can have a significant
    negative impact on performance and memory use. In *Chapter 12* , *Improving Performance
    and Scalability Using Multitasking* , you will learn how to concatenate `string`
    variables efficiently using the `StringBuilder` type.
  prefs: []
  type: TYPE_NORMAL
- en: Working with dates and times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After numbers and text, the next most popular types of data to work with are
    dates and times. The two main types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DateTime` : represents a combined date and time value for a fixed point in
    time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimeSpan` : represents a duration of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two types are often used together. For example, if you subtract one `DateTime`
    value from another, the result is a `TimeSpan` . If you add a `TimeSpan` to a
    `DateTime` then the result is a `DateTime` value.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying date and time values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common way to create a date and time value is to specify individual values
    for the date and time components like day and hour, as described in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Date/time parameter | Value range |'
  prefs: []
  type: TYPE_TB
- en: '| `year` | 1 to 9999 |'
  prefs: []
  type: TYPE_TB
- en: '| `month` | 1 to 12 |'
  prefs: []
  type: TYPE_TB
- en: '| `day` | 1 to the number of days in that month |'
  prefs: []
  type: TYPE_TB
- en: '| `hour` | 0 to 23 |'
  prefs: []
  type: TYPE_TB
- en: '| `minute` | 0 to 59 |'
  prefs: []
  type: TYPE_TB
- en: '| `second` | 0 to 59 |'
  prefs: []
  type: TYPE_TB
- en: An alternative is to provide the value as a `string` to be parsed, but this
    can be misinterpreted depending on the default culture of the thread. For example,
    in the UK, dates are specified as day/month/year, compared to the US, where dates
    are specified as month/day/year.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what you might want to do with dates and times:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithTime`
    to the `Chapter08` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithTime` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs` , delete the existing statements and then add statements to
    initialize some special date/time values, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("Earliest date/time value is: {0}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: DateTime.MinValue);'
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("UNIX epoch date/time value is: {0}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: DateTime.UnixEpoch);'
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("Date/time value Now is: {0}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: DateTime.Now);'
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("Date/time value Today is: {0}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: DateTime.Today);'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Earliest date/time value is: 01/01/0001 00:00:00'
  prefs: []
  type: TYPE_NORMAL
- en: 'UNIX epoch date/time value is: 01/01/1970 00:00:00'
  prefs: []
  type: TYPE_NORMAL
- en: 'Date/time value Now is: 23/04/2021 14:14:54'
  prefs: []
  type: TYPE_NORMAL
- en: 'Date/time value Today is: 23/04/2021 00:00:00'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to define Christmas Day in 2021 (if this is in the past then
    use a future year) and display it in various ways, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: DateTime christmas = new
  prefs: []
  type: TYPE_NORMAL
- en: '(year: 2021'
  prefs: []
  type: TYPE_NORMAL
- en: ', month: 12'
  prefs: []
  type: TYPE_NORMAL
- en: ', day: 25'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("Christmas: {0}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: christmas); // default format'
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("Christmas: {0:dddd, dd MMMM yyyy}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: christmas); // custom format'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Christmas is in month {0} of the year."
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: christmas.Month);'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Christmas is day {0} of the year."
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: christmas.DayOfYear);'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Christmas {0} is on a {1}."
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: christmas.Year,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: christmas.DayOfWeek);'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Christmas: 25/12/2021 00:00:00'
  prefs: []
  type: TYPE_NORMAL
- en: 'Christmas: Saturday, 25 December 2021'
  prefs: []
  type: TYPE_NORMAL
- en: Christmas is in month 12 of the year.
  prefs: []
  type: TYPE_NORMAL
- en: Christmas is day 359 of the year.
  prefs: []
  type: TYPE_NORMAL
- en: Christmas 2021 is on a Saturday.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to perform addition and subtraction with Christmas, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: DateTime beforeXmas = christmas.Subtract(TimeSpan.FromDays(12
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: DateTime afterXmas = christmas.AddDays(12
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("12 days before Christmas is: {0}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: beforeXmas);'
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("12 days after Christmas is: {0}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: afterXmas);'
  prefs: []
  type: TYPE_NORMAL
- en: TimeSpan untilChristmas = christmas - DateTime.Now;
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("There are {0} days and {1} hours until Christmas."
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: untilChristmas.Days,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: untilChristmas.Hours);'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("There are {0:N0} hours until Christmas."
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: untilChristmas.TotalHours);'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '12 days before Christmas is: 13/12/2021 00:00:00'
  prefs: []
  type: TYPE_NORMAL
- en: '12 days after Christmas is: 06/01/2022 00:00:00'
  prefs: []
  type: TYPE_NORMAL
- en: There are 245 days and 9 hours until Christmas.
  prefs: []
  type: TYPE_NORMAL
- en: There are 5,890 hours until Christmas.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to define the time on Christmas Day that your children might
    wake up to open presents, and display it in various ways, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: DateTime kidsWakeUp = new
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: 'year: 2021'
  prefs: []
  type: TYPE_NORMAL
- en: ', month: 12'
  prefs: []
  type: TYPE_NORMAL
- en: ', day: 25'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'hour: 6'
  prefs: []
  type: TYPE_NORMAL
- en: ', minute: 30'
  prefs: []
  type: TYPE_NORMAL
- en: ', second: 0'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("Kids wake up on Christmas: {0}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: kidsWakeUp);'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("The kids woke me up at {0}"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: kidsWakeUp.ToShortTimeString());'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kids wake up on Christmas: 25/12/2021 06:30:00'
  prefs: []
  type: TYPE_NORMAL
- en: The kids woke me up at 06:30
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Globalization with dates and times
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The current culture controls how dates and times are parsed:'
  prefs: []
  type: TYPE_NORMAL
- en: At the top of `Program.cs` , import the `System.Globalization` namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements to show the current culture that is used to display date and
    time values, and then parse United States Independence Day and display it in various
    ways, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("Current culture is: {0}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: CultureInfo.CurrentCulture.Name);'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: textDate = "4 July 2021"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: DateTime independenceDay = DateTime.Parse(textDate);
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("Text: {0}, DateTime: {1:d MMMM}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: textDate,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: independenceDay);'
  prefs: []
  type: TYPE_NORMAL
- en: textDate = "7/4/2021"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: independenceDay = DateTime.Parse(textDate);
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("Text: {0}, DateTime: {1:d MMMM}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: textDate,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: independenceDay);'
  prefs: []
  type: TYPE_NORMAL
- en: independenceDay = DateTime.Parse(textDate,
  prefs: []
  type: TYPE_NORMAL
- en: 'provider: CultureInfo.GetCultureInfo("en-US"'
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("Text: {0}, DateTime: {1:d MMMM}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: textDate,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: independenceDay);'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Current culture is: en-GB'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text: 4 July 2021, DateTime: 4 July'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text: 7/4/2021, DateTime: 7 April'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text: 7/4/2021, DateTime: 4 July'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: On my computer, the current culture is British English. If a date is given as
    4 July 2021, then it is correctly parsed regardless of whether the current culture
    is British or American. But if the date is given as 7/4/2021, then it is wrongly
    parsed as 7 April. You can override the current culture by specifying the correct
    culture as a provider when parsing, as shown in the third example above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to loop from the year 2020 to 2025, displaying if the year is
    a leap year and how many days there are in February, and then show if Christmas
    and Independence Day are during daylight saving time, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: for
  prefs: []
  type: TYPE_NORMAL
- en: (int
  prefs: []
  type: TYPE_NORMAL
- en: year = 2020
  prefs: []
  type: TYPE_NORMAL
- en: ; year < 2026
  prefs: []
  type: TYPE_NORMAL
- en: ; year++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Write($"
  prefs: []
  type: TYPE_NORMAL
- en: '{year}'
  prefs: []
  type: TYPE_NORMAL
- en: 'is a leap year:'
  prefs: []
  type: TYPE_NORMAL
- en: '{DateTime.IsLeapYear(year)}'
  prefs: []
  type: TYPE_NORMAL
- en: . "
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("There are {0} days in February {1}."
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: DateTime.DaysInMonth(year: year, month: 2'
  prefs: []
  type: TYPE_NORMAL
- en: '), arg1: year);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Is Christmas daylight saving time? {0}"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: christmas.IsDaylightSavingTime());'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Is July 4th daylight saving time? {0}"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: independenceDay.IsDaylightSavingTime());'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '2020 is a leap year: True. There are 29 days in February 2020.'
  prefs: []
  type: TYPE_NORMAL
- en: '2021 is a leap year: False. There are 28 days in February 2021.'
  prefs: []
  type: TYPE_NORMAL
- en: '2022 is a leap year: False. There are 28 days in February 2022.'
  prefs: []
  type: TYPE_NORMAL
- en: '2023 is a leap year: False. There are 28 days in February 2023.'
  prefs: []
  type: TYPE_NORMAL
- en: '2024 is a leap year: True. There are 29 days in February 2024.'
  prefs: []
  type: TYPE_NORMAL
- en: '2025 is a leap year: False. There are 28 days in February 2025.'
  prefs: []
  type: TYPE_NORMAL
- en: Is Christmas daylight saving time? False
  prefs: []
  type: TYPE_NORMAL
- en: Is July 4th daylight saving time? True
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Working with only a date or a time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET 6 introduces some new types for working with only a date value or only
    a time value named `DateOnly` and `TimeOnly` . These are better than using a `DateTime`
    value with a zero time to store a date-only value because it is type-safe and
    avoids misuse. `DateOnly` also maps better to database column types, for example,
    a `date` column in SQL Server. `TimeOnly` is good for setting alarms and scheduling
    regular meetings or events, and it maps to a `time` column in SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use them to plan a party for the Queen of England:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to define the Queen''s birthday, and a time for her party to
    start, and then combine the two values to make a calendar entry so we don''t miss
    her party, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: DateOnly queensBirthday = new
  prefs: []
  type: TYPE_NORMAL
- en: '(year: 2022'
  prefs: []
  type: TYPE_NORMAL
- en: ', month: 4'
  prefs: []
  type: TYPE_NORMAL
- en: ', day: 21'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"The Queen's next birthday is on
  prefs: []
  type: TYPE_NORMAL
- en: '{queensBirthday}'
  prefs: []
  type: TYPE_NORMAL
- en: ."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: TimeOnly partyStarts = new
  prefs: []
  type: TYPE_NORMAL
- en: '(hour: 20'
  prefs: []
  type: TYPE_NORMAL
- en: ', minute: 30'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"The Queen's party starts at
  prefs: []
  type: TYPE_NORMAL
- en: '{partyStarts}'
  prefs: []
  type: TYPE_NORMAL
- en: ."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: DateTime calendarEntry = queensBirthday.ToDateTime(partyStarts);
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Add to your calendar:'
  prefs: []
  type: TYPE_NORMAL
- en: '{calendarEntry}'
  prefs: []
  type: TYPE_NORMAL
- en: ."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and note the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: The Queen's next birthday is on 21/04/2022.
  prefs: []
  type: TYPE_NORMAL
- en: The Queen's party starts at 20:30.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add to your calendar: 21/04/2022 20:30:00.'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching with regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular expressions are useful for validating input from the user. They are
    very powerful and can get very complicated. Almost all programming languages have
    support for regular expressions and use a common set of special characters to
    define them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try out some example regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithRegularExpressions`
    to the `Chapter08` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithRegularExpressions` as the active
    OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs` , import the following namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.Text.RegularExpressions;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Checking for digits entered as text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by implementing the common example of validating number input:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to prompt the user to enter their age and then check that it
    is valid using a regular expression that looks for a digit character, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write("Enter your age: "'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? input = ReadLine();'
  prefs: []
  type: TYPE_NORMAL
- en: Regex ageChecker = new
  prefs: []
  type: TYPE_NORMAL
- en: (@"\d"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (ageChecker.IsMatch(input))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Thank you!"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"This is not a valid age:'
  prefs: []
  type: TYPE_NORMAL
- en: '{input}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following about the code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@` character switches off the ability to use escape characters in the string.
    Escape characters are prefixed with a backslash. For example, `\t` means a tab
    and `\n` means a new line. When writing regular expressions, we need to disable
    this feature. To paraphrase the television show The West Wing, "Let backslash
    be backslash."
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once escape characters are disabled with `@` , then they can be interpreted
    by a regular expression. For example, `\d` means digit. You will learn more regular
    expressions that are prefixed with a backslash later in this topic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the code, enter a whole number such as `34` for the age, and view the result,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter your age: 34'
  prefs: []
  type: TYPE_NORMAL
- en: Thank you!
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code again, enter `carrots` , and view the result, as shown in the
    following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter your age: carrots'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not a valid age: carrots'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code again, enter `bob30smith` , and view the result, as shown in the
    following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter your age: bob30smith'
  prefs: []
  type: TYPE_NORMAL
- en: Thank you!
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The regular expression we used is `\d` , which means *one digit* . However,
    it does not specify what can be entered before and after that one digit. This
    regular expression could be described in English as "Enter any characters you
    want as long as you enter at least one digit character."
  prefs: []
  type: TYPE_NORMAL
- en: In regular expressions, you indicate the start of some input with the caret
    `^` symbol and the end of some input with the dollar `$` symbol. Let's use these
    symbols to indicate that we expect nothing else between the start and end of the
    input except for a digit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the regular expression to `^\d$` , as shown highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Regex ageChecker = new
  prefs: []
  type: TYPE_NORMAL
- en: (@"^
  prefs: []
  type: TYPE_NORMAL
- en: '**\d$"**'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Run the code again and note that it rejects any input except a single digit.
    We want to allow one or more digits. To do this, we add a `+` after the `\d` expression
    to modify the meaning to one or more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the regular expression, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Regex ageChecker = new
  prefs: []
  type: TYPE_NORMAL
- en: (@"^
  prefs: []
  type: TYPE_NORMAL
- en: '**\d+$"**'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Run the code again and note the regular expression only allows zero or positive
    whole numbers of any length.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Regular expression performance improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The .NET types for working with regular expressions are used throughout the
    .NET platform and many of the apps built with it. As such, they have a significant
    impact on performance, but until now, they have not received much optimization
    attention from Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: With .NET 5 and later, the `System.Text.RegularExpressions` namespace has rewritten
    internals to squeeze out maximum performance. Common regular expression benchmarks
    using methods like `IsMatch` are now five times faster. And the best thing is,
    you do not have to change your code to get the benefits!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the syntax of a regular expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some common regular expression symbols that you can use in regular
    expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Symbol | Meaning | Symbol | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Start of input | `$` | End of input |'
  prefs: []
  type: TYPE_TB
- en: '| `\d` | A single digit | `\D` | A single NON-digit |'
  prefs: []
  type: TYPE_TB
- en: '| `\s` | Whitespace | `\S` | NON-whitespace |'
  prefs: []
  type: TYPE_TB
- en: '| `\w` | Word characters | `\W` | NON-word characters |'
  prefs: []
  type: TYPE_TB
- en: '| `[A-Za-z0-9]` | Range(s) of characters | `\^` | ^ (caret) character |'
  prefs: []
  type: TYPE_TB
- en: '| `[aeiou]` | Set of characters | `[^aeiou]` | NOT in a set of characters |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | Any single character | `\.` | . (dot) character |'
  prefs: []
  type: TYPE_TB
- en: 'In addition, here are some regular expression quantifiers that affect the previous
    symbols in a regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Symbol | Meaning | Symbol | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | One or more | `?` | One or none |'
  prefs: []
  type: TYPE_TB
- en: '| `{3}` | Exactly three | `{3,5}` | Three to five |'
  prefs: []
  type: TYPE_TB
- en: '| `{3,}` | At least three | `{,3}` | Up to three |'
  prefs: []
  type: TYPE_TB
- en: Examples of regular expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some examples of regular expressions with a description of their meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| `\d` | A single digit somewhere in the input |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | The character *a* somewhere in the input |'
  prefs: []
  type: TYPE_TB
- en: '| `Bob` | The word *Bob* somewhere in the input |'
  prefs: []
  type: TYPE_TB
- en: '| `^Bob` | The word *Bob* at the start of the input |'
  prefs: []
  type: TYPE_TB
- en: '| `Bob$` | The word *Bob* at the end of the input |'
  prefs: []
  type: TYPE_TB
- en: '| `^\d{2}$` | Exactly two digits |'
  prefs: []
  type: TYPE_TB
- en: '| `^[0-9]{2}$` | Exactly two digits |'
  prefs: []
  type: TYPE_TB
- en: '| `^[A-Z]{4,}$` | At least four uppercase English letters in the ASCII character
    set only |'
  prefs: []
  type: TYPE_TB
- en: '| `^[A-Za-z]{4,}$` | At least four upper or lowercase English letters in the
    ASCII character set only |'
  prefs: []
  type: TYPE_TB
- en: '| `^[A-Z]{2}\d{3}$` | Two uppercase English letters in the ASCII character
    set and three digits only |'
  prefs: []
  type: TYPE_TB
- en: '| `^[A-Za-z\u00c0-\u017e]+$` | At least one uppercase or lowercase English
    letter in the ASCII character set or European letters in the Unicode character
    set, as shown in the following list:ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿıŒœŠšŸ
    Žž |'
  prefs: []
  type: TYPE_TB
- en: '| `^d.g$` | The letter *d* , then any character, and then the letter *g* ,
    so it would match both *dig* and *dog* or any single character between the *d*
    and *g* |'
  prefs: []
  type: TYPE_TB
- en: '| `^d\.g$` | The letter *d* , then a dot (.), and then the letter *g* , so
    it would match *d.g* only |'
  prefs: []
  type: TYPE_TB
- en: '**Good Practice** : Use regular expressions to validate input from the user.
    The same regular expressions can be reused in other languages such as JavaScript
    and Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Splitting a complex comma-separated string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this chapter, you learned how to split a simple comma-separated string
    variable. But what about the following example of film titles?
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '"Monsters, Inc."'
  prefs: []
  type: TYPE_NORMAL
- en: ',"I, Tonya"'
  prefs: []
  type: TYPE_NORMAL
- en: ',"Lock, Stock and Two Smoking Barrels"'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The `string` value uses double quotes around each film title. We can use these
    to identify whether we need to split on a comma (or not). The `Split` method is
    not powerful enough, so we can use a regular expression instead.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : You can read a fuller explanation in the Stack Overflow
    article that inspired this task at the following link: [https://stackoverflow.com/questions/18144431/regex-to-split-a-csv](https://stackoverflow.com/questions/18144431/regex-to-split-a-csv)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To include double quotes inside a `string` value, we prefix them with a backslash:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to store a complex comma-separated `string` variable, and then
    split it in a dumb way using the `Split` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: films = "\"Monsters, Inc.\",\"I, Tonya\",\"Lock, Stock and Two Smoking Barrels\""
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Films to split:'
  prefs: []
  type: TYPE_NORMAL
- en: '{films}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '[] filmsDumb = films.Split('','''
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Splitting with string.Split method:"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (string
  prefs: []
  type: TYPE_NORMAL
- en: film in
  prefs: []
  type: TYPE_NORMAL
- en: filmsDumb)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(film);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to define a regular expression to split and write the film titles
    in a smart way, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: Regex csv = new
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: '"(?:^|,)(?=[^\"]|(\")?)\"?((?(1)[^\"]*|[^,\"]*))\"?(?=,|$)"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: MatchCollection filmsSmart = csv.Matches(films);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Splitting with regular expression:"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (Match film in
  prefs: []
  type: TYPE_NORMAL
- en: filmsSmart)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(film.Groups[2
  prefs: []
  type: TYPE_NORMAL
- en: '].Value);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Splitting with string.Split method:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Monsters'
  prefs: []
  type: TYPE_NORMAL
- en: Inc."
  prefs: []
  type: TYPE_NORMAL
- en: '"I'
  prefs: []
  type: TYPE_NORMAL
- en: Tonya"
  prefs: []
  type: TYPE_NORMAL
- en: '"Lock'
  prefs: []
  type: TYPE_NORMAL
- en: Stock and Two Smoking Barrels"
  prefs: []
  type: TYPE_NORMAL
- en: 'Splitting with regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: Monsters, Inc.
  prefs: []
  type: TYPE_NORMAL
- en: I, Tonya
  prefs: []
  type: TYPE_NORMAL
- en: Lock, Stock and Two Smoking Barrels
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Storing multiple objects in collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another of the most common types of data is collections. If you need to store
    multiple values in a variable, then you can use a collection.
  prefs: []
  type: TYPE_NORMAL
- en: A collection is a data structure in memory that can manage multiple items in
    different ways, although all collections have some shared functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common types in .NET for working with collections are shown in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Namespace | Example type(s) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `System .Collections` | `IEnumerable` , `IEnumerable<T>` | Interfaces and
    base classes used by collections. |'
  prefs: []
  type: TYPE_TB
- en: '| `System .Collections .Generic` | `List<T>` , `Dictionary<T>` , `Queue<T>`
    , `Stack<T>` | Introduced in C# 2.0 with .NET Framework 2.0\. These collections
    allow you to specify the type you want to store using a generic type parameter
    (which is safer, faster, and more efficient). |'
  prefs: []
  type: TYPE_TB
- en: '| `System .Collections .Concurrent` | `BlockingCollection` , `ConcurrentDictionary`
    , `ConcurrentQueue` | These collections are safe to use in multithreaded scenarios.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `System .Collections .Immutable` | `ImmutableArray` , `ImmutableDictionary`
    , `ImmutableList` , `ImmutableQueue` | Designed for scenarios where the contents
    of the original collection will never change, although they can create modified
    collections as a new instance. |'
  prefs: []
  type: TYPE_TB
- en: Common features of all collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All collections implement the `ICollection` interface; this means that they
    must have a `Count` property to tell you how many objects are in them, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: System.Collections
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: interface
  prefs: []
  type: TYPE_NORMAL
- en: ICollection
  prefs: []
  type: TYPE_NORMAL
- en: ': IEnumerable'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: Count { get
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: IsSynchronized { get
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: object
  prefs: []
  type: TYPE_NORMAL
- en: SyncRoot { get
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: CopyTo
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: Array array,
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: index
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we had a collection named `passengers` , we could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: howMany = passengers.Count;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'All collections implement the `IEnumerable` interface, which means that they
    can be iterated using the `foreach` statement. They must have a `GetEnumerator`
    method that returns an object that implements `IEnumerator` ; this means that
    the returned `object` must have `MoveNext` and `Reset` methods for navigating
    through the collection and a `Current` property containing the current item in
    the collection, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: System.Collections
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: interface
  prefs: []
  type: TYPE_NORMAL
- en: IEnumerable
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: IEnumerator
  prefs: []
  type: TYPE_NORMAL
- en: GetEnumerator
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: System.Collections
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: interface
  prefs: []
  type: TYPE_NORMAL
- en: IEnumerator
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: object
  prefs: []
  type: TYPE_NORMAL
- en: Current { get
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: MoveNext
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: Reset
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to perform an action on each object in the `passengers` collection,
    we could write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (Passenger p in
  prefs: []
  type: TYPE_NORMAL
- en: passengers)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // perform an action on each passenger
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As well as `object` -based collection interfaces, there are also generic interfaces
    and classes, where the generic type defines the type stored in the collection,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: System.Collections.Generic
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: interface
  prefs: []
  type: TYPE_NORMAL
- en: ICollection
  prefs: []
  type: TYPE_NORMAL
- en: <T
  prefs: []
  type: TYPE_NORMAL
- en: ': IEnumerable'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <T
  prefs: []
  type: TYPE_NORMAL
- en: '>, IEnumerable'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: Count { get
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: IsReadOnly { get
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: Add
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: T item
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: Clear
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: Contains
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: T item
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: CopyTo
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: T[] array,
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: index
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: Remove
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: T item
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Improving performance by ensuring the capacity of a collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since .NET 1.1, types like `StringBuilder` have had a method named `EnsureCapacity`
    that can presize its internal storage array to the expected final size of the
    `string` . This improves performance because it does not have to repeatedly increment
    the size of the array as more characters are appended.
  prefs: []
  type: TYPE_NORMAL
- en: Since .NET Core 2.1, types like `Dictionary<T>` and `HashSet<T>` have also had
    `EnsureCapacity` .
  prefs: []
  type: TYPE_NORMAL
- en: 'In .NET 6 and later, collections like `List<T>` , `Queue<T>` , and `Stack<T>`
    now have an `EnsureCapacity` method too, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: List<string
  prefs: []
  type: TYPE_NORMAL
- en: names = new
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ();
  prefs: []
  type: TYPE_NORMAL
- en: names.EnsureCapacity(10
  prefs: []
  type: TYPE_NORMAL
- en: _000);
  prefs: []
  type: TYPE_NORMAL
- en: // load ten thousand names into the list
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding collection choices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several different choices of collection that you can use for different
    purposes: lists, dictionaries, stacks, queues, sets, and many other more specialized
    collections.'
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lists, that is, a type that implements `IList<T>` , are **ordered collections**
    , as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: System.Collections.Generic
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '[DefaultMember('
  prefs: []
  type: TYPE_NORMAL
- en: '"Item"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '] // aka this indexer'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: interface
  prefs: []
  type: TYPE_NORMAL
- en: IList
  prefs: []
  type: TYPE_NORMAL
- en: <T
  prefs: []
  type: TYPE_NORMAL
- en: ': ICollection'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <T
  prefs: []
  type: TYPE_NORMAL
- en: '>, IEnumerable'
  prefs: []
  type: TYPE_NORMAL
- en: <T
  prefs: []
  type: TYPE_NORMAL
- en: '>, IEnumerable'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: T this
  prefs: []
  type: TYPE_NORMAL
- en: '[int'
  prefs: []
  type: TYPE_NORMAL
- en: index] { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: IndexOf
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: T item
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: Insert
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: index, T item
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: RemoveAt
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: index
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '`IList<T>` derives from `ICollection<T>` so it has a `Count` property, and
    an `Add` method to put an item at the end of the collection, as well as an `Insert`
    method to put an item in the list at a specified position, and `RemoveAt` to remove
    an item at a specified position.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists are a good choice when you want to manually control the order of items
    in a collection. Each item in a list has a unique index (or position) that is
    automatically assigned. Items can be any type defined by `T` and items can be
    duplicated. Indexes are `int` types and start from `0` , so the first item in
    a list is at index `0` , as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Index | Item |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | London |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Paris |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | London |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Sydney |'
  prefs: []
  type: TYPE_TB
- en: 'If a new item (for example, Santiago) is inserted between London and Sydney,
    then the index of Sydney is automatically incremented. Therefore, you must be
    aware that an item''s index can change after inserting or removing items, as shown
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Index | Item |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | London |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Paris |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | London |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Santiago |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Sydney |'
  prefs: []
  type: TYPE_TB
- en: Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dictionaries are a good choice when each **value** (or object) has a unique
    sub value (or a made-up value) that can be used as a **key** to quickly find a
    value in the collection later. The key must be unique. For example, if you are
    storing a list of people, you could choose to use a government-issued identity
    number as the key.
  prefs: []
  type: TYPE_NORMAL
- en: Think of the key as being like an index entry in a real-world dictionary. It
    allows you to quickly find the definition of a word because the words (for example,
    keys) are kept sorted, and if we know we're looking for the definition of *manatee*
    , we would jump to the middle of the dictionary to start looking, because the
    letter *M* is in the middle of the alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries in programming are similarly smart when looking something up.
    They must implement the interface `IDictionary<TKey, TValue>` , as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: System.Collections.Generic
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '[DefaultMember('
  prefs: []
  type: TYPE_NORMAL
- en: '"Item"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '] // aka this indexer'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: interface
  prefs: []
  type: TYPE_NORMAL
- en: IDictionary
  prefs: []
  type: TYPE_NORMAL
- en: <TKey
  prefs: []
  type: TYPE_NORMAL
- en: ', TValue'
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: ': ICollection'
  prefs: []
  type: TYPE_NORMAL
- en: <KeyValuePair
  prefs: []
  type: TYPE_NORMAL
- en: <TKey
  prefs: []
  type: TYPE_NORMAL
- en: ', TValue'
  prefs: []
  type: TYPE_NORMAL
- en: '>>,'
  prefs: []
  type: TYPE_NORMAL
- en: IEnumerable
  prefs: []
  type: TYPE_NORMAL
- en: <KeyValuePair
  prefs: []
  type: TYPE_NORMAL
- en: <TKey
  prefs: []
  type: TYPE_NORMAL
- en: ', TValue'
  prefs: []
  type: TYPE_NORMAL
- en: '>>, IEnumerable'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: TValue this
  prefs: []
  type: TYPE_NORMAL
- en: '[TKey key] { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: ICollection<TKey> Keys { get
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: ICollection<TValue> Values { get
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: Add
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: TKey key, TValue
  prefs: []
  type: TYPE_NORMAL
- en: value
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: ContainsKey
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: TKey key
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: Remove
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: TKey key
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: TryGetValue
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: TKey key, [MaybeNullWhen(
  prefs: []
  type: TYPE_NORMAL
- en: 'false'
  prefs: []
  type: TYPE_NORMAL
- en: )]
  prefs: []
  type: TYPE_NORMAL
- en: out
  prefs: []
  type: TYPE_NORMAL
- en: TValue
  prefs: []
  type: TYPE_NORMAL
- en: value
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Items in a dictionary are instances of the `struct` , aka the value type `KeyValuePair<TKey,
    TValue>` , where `TKey` is the type of the key and `TValue` is the type of the
    value, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: System.Collections.Generic
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: readonly
  prefs: []
  type: TYPE_NORMAL
- en: struct
  prefs: []
  type: TYPE_NORMAL
- en: KeyValuePair<TKey, TValue>
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: KeyValuePair
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: TKey key, TValue
  prefs: []
  type: TYPE_NORMAL
- en: value
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: TKey Key { get
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: TValue Value { get
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '[EditorBrowsable(EditorBrowsableState.Never)'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: Deconstruct
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: out
  prefs: []
  type: TYPE_NORMAL
- en: TKey key,
  prefs: []
  type: TYPE_NORMAL
- en: out
  prefs: []
  type: TYPE_NORMAL
- en: TValue
  prefs: []
  type: TYPE_NORMAL
- en: value
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: override
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: ToString
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example `Dictionary<string, Person>` uses a `string` as the key and a `Person`
    instance as the value. `Dictionary<string, string>` uses `string` values for both,
    as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Key | Value |'
  prefs: []
  type: TYPE_TB
- en: '| BSA | Bob Smith |'
  prefs: []
  type: TYPE_TB
- en: '| MW | Max Williams |'
  prefs: []
  type: TYPE_TB
- en: '| BSB | Bob Smith |'
  prefs: []
  type: TYPE_TB
- en: '| AM | Amir Mohammed |'
  prefs: []
  type: TYPE_TB
- en: Stacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Stacks are a good choice when you want to implement **last-in, first-out** (**LIFO**
    ) behavior. With a stack, you can only directly access or remove the one item
    at the top of the stack, although you can enumerate to read through the whole
    stack of items. You cannot, for example, directly access the second item in a
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: For example, word processors use a stack to remember the sequence of actions
    you have recently performed, and then when you press Ctrl + Z , it will undo the
    last action in the stack, and then the next-to-last action, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Queues are a good choice when you want to implement the **first-in, first-out**
    (**FIFO** ) behavior. With a queue, you can only directly access or remove the
    one item at the front of the queue, although you can enumerate to read through
    the whole queue of items. You cannot, for example, directly access the second
    item in a queue.
  prefs: []
  type: TYPE_NORMAL
- en: For example, background processes use a queue to process work items in the order
    that they arrive, just like people standing in line at the post office.
  prefs: []
  type: TYPE_NORMAL
- en: .NET 6 introduces the `PriorityQueue` , where each item in the queue has a priority
    value assigned as well as their position in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sets are a good choice when you want to perform set operations between two collections.
    For example, you may have two collections of city names, and you want to know
    which names appear in both sets (known as the *intersect* between the sets). Items
    in a set must be unique.
  prefs: []
  type: TYPE_NORMAL
- en: Collection methods summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each collection has a different set of methods for adding and removing items,
    as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Collection | Add methods | Remove methods | Description |'
  prefs: []
  type: TYPE_TB
- en: '| List | `Add` , `Insert` | `Remove` , `RemoveAt` | Lists are ordered so items
    have an integer index position. `Add` will add a new item at the end of the list.
    `Insert` will add a new item at the index position specified. |'
  prefs: []
  type: TYPE_TB
- en: '| Dictionary | `Add` | `Remove` | Dictionaries are not ordered so items do
    not have integer index positions. You can check if a key has been used by calling
    the `ContainsKey` method. |'
  prefs: []
  type: TYPE_TB
- en: '| Stack | `Push` | `Pop` | Stacks always add a new item at the top of the stack
    using the `Push` method. The first item is at the bottom. Items are always removed
    from the top of the stack using the `Pop` method. Call the `Peek` method to see
    this value without removing it. |'
  prefs: []
  type: TYPE_TB
- en: '| Queue | `Enqueue` | `Dequeue` | Queues always add a new item at the end of
    the queue using the `Enqueue` method. The first item is at the front of the queue.
    Items are always removed from the front of the queue using the `Dequeue` method.
    Call the `Peek` method to see this value without removing it. |'
  prefs: []
  type: TYPE_TB
- en: Working with lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore lists:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithCollections`
    to the `Chapter08` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithCollections` as the active OmniSharp
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs` , delete the existing statements and then define a function
    to output a collection of `string` values with a title, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: title, IEnumerable<
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: collection
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(title);
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (string
  prefs: []
  type: TYPE_NORMAL
- en: item in
  prefs: []
  type: TYPE_NORMAL
- en: collection)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{item}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a static method named `WorkingWithLists` to illustrate some of the common
    ways of defining and working with lists, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: WorkingWithLists
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // Simple syntax for creating a list and adding three items
  prefs: []
  type: TYPE_NORMAL
- en: List<string
  prefs: []
  type: TYPE_NORMAL
- en: cities = new
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ();
  prefs: []
  type: TYPE_NORMAL
- en: cities.Add("London"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: cities.Add("Paris"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: cities.Add("Milan"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: /* Alternative syntax that is converted by the compiler into
  prefs: []
  type: TYPE_NORMAL
- en: the three Add method calls above
  prefs: []
  type: TYPE_NORMAL
- en: List<string> cities = new()
  prefs: []
  type: TYPE_NORMAL
- en: '{ "London", "Paris", "Milan" };'
  prefs: []
  type: TYPE_NORMAL
- en: '*/'
  prefs: []
  type: TYPE_NORMAL
- en: /* Alternative syntax that passes an
  prefs: []
  type: TYPE_NORMAL
- en: array of string values to AddRange method
  prefs: []
  type: TYPE_NORMAL
- en: List<string> cities = new();
  prefs: []
  type: TYPE_NORMAL
- en: cities.AddRange(new[] { "London", "Paris", "Milan" });
  prefs: []
  type: TYPE_NORMAL
- en: '*/'
  prefs: []
  type: TYPE_NORMAL
- en: Output("Initial list"
  prefs: []
  type: TYPE_NORMAL
- en: ', cities);'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"The first city is
  prefs: []
  type: TYPE_NORMAL
- en: '{cities['
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: ']}'
  prefs: []
  type: TYPE_NORMAL
- en: ."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"The last city is
  prefs: []
  type: TYPE_NORMAL
- en: '{cities[cities.Count -'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: ']}'
  prefs: []
  type: TYPE_NORMAL
- en: ."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: cities.Insert(0
  prefs: []
  type: TYPE_NORMAL
- en: ', "Sydney"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Output("After inserting Sydney at index 0"
  prefs: []
  type: TYPE_NORMAL
- en: ', cities);'
  prefs: []
  type: TYPE_NORMAL
- en: cities.RemoveAt(1
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: cities.Remove("Milan"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Output("After removing two cities"
  prefs: []
  type: TYPE_NORMAL
- en: ', cities);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs` , after the namespace imports, call the `WorkingWithLists`
    method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WorkingWithLists();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Initial list
  prefs: []
  type: TYPE_NORMAL
- en: London
  prefs: []
  type: TYPE_NORMAL
- en: Paris
  prefs: []
  type: TYPE_NORMAL
- en: Milan
  prefs: []
  type: TYPE_NORMAL
- en: The first city is London.
  prefs: []
  type: TYPE_NORMAL
- en: The last city is Milan.
  prefs: []
  type: TYPE_NORMAL
- en: After inserting Sydney at index 0
  prefs: []
  type: TYPE_NORMAL
- en: Sydney
  prefs: []
  type: TYPE_NORMAL
- en: London
  prefs: []
  type: TYPE_NORMAL
- en: Paris
  prefs: []
  type: TYPE_NORMAL
- en: Milan
  prefs: []
  type: TYPE_NORMAL
- en: After removing two cities
  prefs: []
  type: TYPE_NORMAL
- en: Sydney
  prefs: []
  type: TYPE_NORMAL
- en: Paris
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Working with dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , define a static method named `WorkingWithDictionaries` to
    illustrate some of the common ways of working with dictionaries, for example,
    looking up word definitions, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: WorkingWithDictionaries
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary<string
  prefs: []
  type: TYPE_NORMAL
- en: ', string'
  prefs: []
  type: TYPE_NORMAL
- en: keywords = new
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ();
  prefs: []
  type: TYPE_NORMAL
- en: // add using named parameters
  prefs: []
  type: TYPE_NORMAL
- en: 'keywords.Add(key: "int"'
  prefs: []
  type: TYPE_NORMAL
- en: ', value'
  prefs: []
  type: TYPE_NORMAL
- en: ': "32-bit integer data type"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: // add using positional parameters
  prefs: []
  type: TYPE_NORMAL
- en: keywords.Add("long"
  prefs: []
  type: TYPE_NORMAL
- en: ', "64-bit integer data type"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: keywords.Add("float"
  prefs: []
  type: TYPE_NORMAL
- en: ', "Single precision floating point number"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: /* Alternative syntax; compiler converts this to calls to Add method
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary<string, string> keywords = new()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '{ "int", "32-bit integer data type" },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ "long", "64-bit integer data type" },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ "float", "Single precision floating point number" },'
  prefs: []
  type: TYPE_NORMAL
- en: '}; */'
  prefs: []
  type: TYPE_NORMAL
- en: /* Alternative syntax; compiler converts this to calls to Add method
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary<string, string> keywords = new()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '["int"] = "32-bit integer data type",'
  prefs: []
  type: TYPE_NORMAL
- en: '["long"] = "64-bit integer data type",'
  prefs: []
  type: TYPE_NORMAL
- en: '["float"] = "Single precision floating point number", // last comma is optional'
  prefs: []
  type: TYPE_NORMAL
- en: '}; */'
  prefs: []
  type: TYPE_NORMAL
- en: Output("Dictionary keys:"
  prefs: []
  type: TYPE_NORMAL
- en: ', keywords.Keys);'
  prefs: []
  type: TYPE_NORMAL
- en: Output("Dictionary values:"
  prefs: []
  type: TYPE_NORMAL
- en: ', keywords.Values);'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Keywords and their definitions"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (KeyValuePair<string
  prefs: []
  type: TYPE_NORMAL
- en: ', string'
  prefs: []
  type: TYPE_NORMAL
- en: item in
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: keywords)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{item.Key}'
  prefs: []
  type: TYPE_NORMAL
- en: ':'
  prefs: []
  type: TYPE_NORMAL
- en: '{item.Value}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // lookup a value using a key
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: key = "long"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"The definition of
  prefs: []
  type: TYPE_NORMAL
- en: '{key}'
  prefs: []
  type: TYPE_NORMAL
- en: is
  prefs: []
  type: TYPE_NORMAL
- en: '{keywords[key]}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs` , comment out the previous method call and then
    call the `WorkingWithDictionaries` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // WorkingWithLists();
  prefs: []
  type: TYPE_NORMAL
- en: WorkingWithDictionaries();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionary keys:'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: long
  prefs: []
  type: TYPE_NORMAL
- en: float
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionary values:'
  prefs: []
  type: TYPE_NORMAL
- en: 32-bit integer data type
  prefs: []
  type: TYPE_NORMAL
- en: 64-bit integer data type
  prefs: []
  type: TYPE_NORMAL
- en: Single precision floating point number
  prefs: []
  type: TYPE_NORMAL
- en: Keywords and their definitions
  prefs: []
  type: TYPE_NORMAL
- en: 'int: 32-bit integer data type'
  prefs: []
  type: TYPE_NORMAL
- en: 'long: 64-bit integer data type'
  prefs: []
  type: TYPE_NORMAL
- en: 'float: Single precision floating point number'
  prefs: []
  type: TYPE_NORMAL
- en: The definition of long is 64-bit integer data type
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Working with queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore queues:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , define a static method named `WorkingWithQueues` to illustrate
    some of the common ways of working with queues, for example, handling customers
    in a queue for coffee, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: WorkingWithQueues
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Queue<string
  prefs: []
  type: TYPE_NORMAL
- en: coffee = new
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ();
  prefs: []
  type: TYPE_NORMAL
- en: coffee.Enqueue("Damir"
  prefs: []
  type: TYPE_NORMAL
- en: ); // front of queue
  prefs: []
  type: TYPE_NORMAL
- en: coffee.Enqueue("Andrea"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: coffee.Enqueue("Ronald"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: coffee.Enqueue("Amin"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: coffee.Enqueue("Irina"
  prefs: []
  type: TYPE_NORMAL
- en: ); // back of queue
  prefs: []
  type: TYPE_NORMAL
- en: Output("Initial queue from front to back"
  prefs: []
  type: TYPE_NORMAL
- en: ', coffee);'
  prefs: []
  type: TYPE_NORMAL
- en: // server handles next person in queue
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: served = coffee.Dequeue();
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Served:'
  prefs: []
  type: TYPE_NORMAL
- en: '{served}'
  prefs: []
  type: TYPE_NORMAL
- en: ."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: // server handles next person in queue
  prefs: []
  type: TYPE_NORMAL
- en: served = coffee.Dequeue();
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Served:'
  prefs: []
  type: TYPE_NORMAL
- en: '{served}'
  prefs: []
  type: TYPE_NORMAL
- en: ."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Output("Current queue from front to back"
  prefs: []
  type: TYPE_NORMAL
- en: ', coffee);'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{coffee.Peek()}'
  prefs: []
  type: TYPE_NORMAL
- en: is next in line."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Output("Current queue from front to back"
  prefs: []
  type: TYPE_NORMAL
- en: ', coffee);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: At the top of `Program.cs` , comment out the previous method calls and call
    the `WorkingWithQueues` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Initial queue from front to back
  prefs: []
  type: TYPE_NORMAL
- en: Damir
  prefs: []
  type: TYPE_NORMAL
- en: Andrea
  prefs: []
  type: TYPE_NORMAL
- en: Ronald
  prefs: []
  type: TYPE_NORMAL
- en: Amin
  prefs: []
  type: TYPE_NORMAL
- en: Irina
  prefs: []
  type: TYPE_NORMAL
- en: 'Served: Damir.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Served: Andrea.'
  prefs: []
  type: TYPE_NORMAL
- en: Current queue from front to back
  prefs: []
  type: TYPE_NORMAL
- en: Ronald
  prefs: []
  type: TYPE_NORMAL
- en: Amin
  prefs: []
  type: TYPE_NORMAL
- en: Irina
  prefs: []
  type: TYPE_NORMAL
- en: Ronald is next in line.
  prefs: []
  type: TYPE_NORMAL
- en: Current queue from front to back
  prefs: []
  type: TYPE_NORMAL
- en: Ronald
  prefs: []
  type: TYPE_NORMAL
- en: Amin
  prefs: []
  type: TYPE_NORMAL
- en: Irina
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a static method named `OutputPQ` , as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: OutputPQ
  prefs: []
  type: TYPE_NORMAL
- en: <
  prefs: []
  type: TYPE_NORMAL
- en: TElement
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: TPriority
  prefs: []
  type: TYPE_NORMAL
- en: '>('
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: title,
  prefs: []
  type: TYPE_NORMAL
- en: IEnumerable<(TElement Element, TPriority Priority
  prefs: []
  type: TYPE_NORMAL
- en: )> collection)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(title);
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: ((TElement, TPriority) item in
  prefs: []
  type: TYPE_NORMAL
- en: collection)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{item.Item1}'
  prefs: []
  type: TYPE_NORMAL
- en: ':'
  prefs: []
  type: TYPE_NORMAL
- en: '{item.Item2}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `OutputPQ` method is generic. You can specify the two types used
    in the tuples that are passed in as `collection` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a static method named `WorkingWithPriorityQueues` , as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: WorkingWithPriorityQueues
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: PriorityQueue<string
  prefs: []
  type: TYPE_NORMAL
- en: ', int'
  prefs: []
  type: TYPE_NORMAL
- en: vaccine = new
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ();
  prefs: []
  type: TYPE_NORMAL
- en: // add some people
  prefs: []
  type: TYPE_NORMAL
- en: // 1 = high priority people in their 70s or poor health
  prefs: []
  type: TYPE_NORMAL
- en: // 2 = medium priority e.g. middle aged
  prefs: []
  type: TYPE_NORMAL
- en: // 3 = low priority e.g. teens and twenties
  prefs: []
  type: TYPE_NORMAL
- en: vaccine.Enqueue("Pamela"
  prefs: []
  type: TYPE_NORMAL
- en: ', 1'
  prefs: []
  type: TYPE_NORMAL
- en: );  // my mum (70s)
  prefs: []
  type: TYPE_NORMAL
- en: vaccine.Enqueue("Rebecca"
  prefs: []
  type: TYPE_NORMAL
- en: ', 3'
  prefs: []
  type: TYPE_NORMAL
- en: ); // my niece (teens)
  prefs: []
  type: TYPE_NORMAL
- en: vaccine.Enqueue("Juliet"
  prefs: []
  type: TYPE_NORMAL
- en: ', 2'
  prefs: []
  type: TYPE_NORMAL
- en: );  // my sister (40s)
  prefs: []
  type: TYPE_NORMAL
- en: vaccine.Enqueue("Ian"
  prefs: []
  type: TYPE_NORMAL
- en: ', 1'
  prefs: []
  type: TYPE_NORMAL
- en: );     // my dad (70s)
  prefs: []
  type: TYPE_NORMAL
- en: OutputPQ("Current queue for vaccination:"
  prefs: []
  type: TYPE_NORMAL
- en: ', vaccine.UnorderedItems);'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{vaccine.Dequeue()}'
  prefs: []
  type: TYPE_NORMAL
- en: has been vaccinated."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{vaccine.Dequeue()}'
  prefs: []
  type: TYPE_NORMAL
- en: has been vaccinated."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: OutputPQ("Current queue for vaccination:"
  prefs: []
  type: TYPE_NORMAL
- en: ', vaccine.UnorderedItems);'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{vaccine.Dequeue()}'
  prefs: []
  type: TYPE_NORMAL
- en: has been vaccinated."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: vaccine.Enqueue("Mark"
  prefs: []
  type: TYPE_NORMAL
- en: ', 2'
  prefs: []
  type: TYPE_NORMAL
- en: ); // me (40s)
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{vaccine.Peek()}'
  prefs: []
  type: TYPE_NORMAL
- en: will be next to be vaccinated."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: OutputPQ("Current queue for vaccination:"
  prefs: []
  type: TYPE_NORMAL
- en: ', vaccine.UnorderedItems);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: At the top of `Program.cs` , comment out the previous method calls and call
    the `WorkingWithPriorityQueues` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Current queue for vaccination:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pamela: 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rebecca: 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'Juliet: 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ian: 1'
  prefs: []
  type: TYPE_NORMAL
- en: Pamela has been vaccinated.
  prefs: []
  type: TYPE_NORMAL
- en: Ian has been vaccinated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Current queue for vaccination:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Juliet: 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rebecca: 3'
  prefs: []
  type: TYPE_NORMAL
- en: Juliet has been vaccinated.
  prefs: []
  type: TYPE_NORMAL
- en: Mark will be next to be vaccinated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Current queue for vaccination:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mark: 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rebecca: 3'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `List<T>` class can be sorted by manually calling its `Sort` method (but remember
    that the indexes of each item will change). Manually sorting a list of `string`
    values or other built-in types will work without extra effort on your part, but
    if you create a collection of your own type, then that type must implement an
    interface named `IComparable` . You learned how to do this in *Chapter 6* , *Implementing
    Interfaces and Inheriting Classes* .
  prefs: []
  type: TYPE_NORMAL
- en: A `Stack<T>` or `Queue<T>` collection cannot be sorted because you wouldn't
    usually want that functionality; for example, you would probably never sort a
    queue of guests checking into a hotel. But sometimes, you might want to sort a
    dictionary or a set.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it would be useful to have an automatically sorted collection, that
    is, one that maintains the items in a sorted order as you add and remove them.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple auto-sorting collections to choose from. The differences
    between these sorted collections are often subtle but can have an impact on the
    memory requirements and performance of your application, so it is worth putting
    effort into picking the most appropriate option for your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common auto-sorting collections are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Collection | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `SortedDictionary<TKey, TValue>` | This represents a collection of key/value
    pairs that are sorted by key. |'
  prefs: []
  type: TYPE_TB
- en: '| `SortedList<TKey, TValue>` | This represents a collection of key/value pairs
    that are sorted by key. |'
  prefs: []
  type: TYPE_TB
- en: '| `SortedSet<T>` | This represents a collection of unique objects that are
    maintained in a sorted order. |'
  prefs: []
  type: TYPE_TB
- en: More specialized collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few other collections for special situations.
  prefs: []
  type: TYPE_NORMAL
- en: Working with a compact array of bit values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `System.Collections.BitArray` collection manages a compact array of bit
    values, which are represented as Booleans, where `true` indicates that the bit
    is on (value is 1) and `false` indicates the bit is off (value is 0).
  prefs: []
  type: TYPE_NORMAL
- en: Working with efficient lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `System.Collections.Generics.LinkedList<T>` collection represents a doubly
    linked list where every item has a reference to its previous and next items. They
    provide better performance compared to `List<T>` for scenarios where you will
    frequently insert and remove items from the middle of the list. In a `LinkedList<T>`
    the items do not have to be rearranged in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Using immutable collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you need to make a collection immutable, meaning that its members
    cannot change; that is, you cannot add or remove them.
  prefs: []
  type: TYPE_NORMAL
- en: If you import the `System.Collections.Immutable` namespace, then any collection
    that implements `IEnumerable<T>` is given six extension methods to convert it
    into an immutable list, dictionary, hash set, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WorkingWithCollections` project, in `Program.cs` , import the `System.Collections.Immutable`
    namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `WorkingWithLists` method, add statements to the end of the method to
    convert the `cities` list into an immutable list and then add a new city to it,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: ImmutableList<string
  prefs: []
  type: TYPE_NORMAL
- en: immutableCities = cities.ToImmutableList();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ImmutableList<string
  prefs: []
  type: TYPE_NORMAL
- en: newList = immutableCities.Add("Rio"
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Output("Immutable list of cities:"
  prefs: []
  type: TYPE_NORMAL
- en: ', immutableCities);'
  prefs: []
  type: TYPE_NORMAL
- en: Output("New list of cities:"
  prefs: []
  type: TYPE_NORMAL
- en: ', newList);'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: At the top of `Program.cs` , comment the previous method calls and uncomment
    the call to the `WorkingWithLists` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code, view the result, and note that the immutable list of cities does
    not get modified when you call the `Add` method on it; instead, it returns a new
    list with the newly added city, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Immutable list of cities:'
  prefs: []
  type: TYPE_NORMAL
- en: Sydney
  prefs: []
  type: TYPE_NORMAL
- en: Paris
  prefs: []
  type: TYPE_NORMAL
- en: 'New list of cities:'
  prefs: []
  type: TYPE_NORMAL
- en: Sydney
  prefs: []
  type: TYPE_NORMAL
- en: Paris
  prefs: []
  type: TYPE_NORMAL
- en: Rio
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : To improve performance, many applications store a shared
    copy of commonly accessed objects in a central cache. To safely allow multiple
    threads to work with those objects knowing they won''t change, you should make
    them immutable or use a concurrent collection type that you can read about at
    the following link: [https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent](https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent)'
  prefs: []
  type: TYPE_NORMAL
- en: Good practice with collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say you need to create a method to process a collection. For maximum
    flexibility, you could declare the input parameter to be `IEnumerable<T>` and
    make the method generic, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: ProcessCollection
  prefs: []
  type: TYPE_NORMAL
- en: <
  prefs: []
  type: TYPE_NORMAL
- en: T
  prefs: []
  type: TYPE_NORMAL
- en: '>('
  prefs: []
  type: TYPE_NORMAL
- en: IEnumerable<T> collection
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // process the items in the collection,
  prefs: []
  type: TYPE_NORMAL
- en: // perhaps using a foreach statement
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: I could pass an array, a list, a queue, a stack, or anything else that implements
    `IEnumerable<T>` into this method and it will process the items. However, the
    flexibility to pass any collection to this method comes at a performance cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the performance problems with `IEnumerable<T>` is also one of its benefits:
    deferred execution, also known as lazy loading. Types that implement this interface
    do not have to implement deferred execution, but many do.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But the worst performance problem with `IEnumerable<T>` is that the iteration
    has to allocate an object on the heap. To avoid this memory allocation, you should
    define your method using a concrete type, as shown highlighted in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: ProcessCollection
  prefs: []
  type: TYPE_NORMAL
- en: <
  prefs: []
  type: TYPE_NORMAL
- en: T
  prefs: []
  type: TYPE_NORMAL
- en: '>('
  prefs: []
  type: TYPE_NORMAL
- en: '**List<T>**'
  prefs: []
  type: TYPE_NORMAL
- en: collection
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // process the items in the collection,
  prefs: []
  type: TYPE_NORMAL
- en: // perhaps using a foreach statement
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This will use the `List<T>.Enumerator GetEnumerator()` method that returns a
    `struct` instead of the `IEnumerator<T> GetEnumerator()` method that returns a
    reference type. Your code will be two to three times faster and require less memory.
    As with all recommendations related to performance, you should confirm the benefit
    by running performance tests on your actual code in a product environment. You
    will learn how to do this in *Chapter 12* , *Improving Performance and Scalability
    Using Multitasking* .
  prefs: []
  type: TYPE_NORMAL
- en: Working with spans, indexes, and ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of Microsoft's goals with .NET Core 2.1 was to improve performance and resource
    usage. A key .NET feature that enables this is the `Span<T>` type.
  prefs: []
  type: TYPE_NORMAL
- en: Using memory efficiently using spans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When manipulating arrays, you will often create new copies of subsets of existing
    ones so that you can process just the subset. This is not efficient because duplicate
    objects must be created in memory.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to work with a subset of an array, use a **span** because it is
    like a window into the original array. This is more efficient in terms of memory
    usage and improves performance. Spans only work with arrays, not collections,
    because the memory must be contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at spans in more detail, we need to understand some related
    objects: indexes and ranges.'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying positions with the Index type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C# 8.0 introduced two features for identifying an item's index within an array
    and a range of items using two indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You learned in the previous topic that objects in a list can be accessed by
    passing an integer into their indexer, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: index = 3
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: Person p = people[index]; // fourth person in array
  prefs: []
  type: TYPE_NORMAL
- en: char
  prefs: []
  type: TYPE_NORMAL
- en: letter = name[index]; // fourth letter in name
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Index` value type is a more formal way of identifying a position, and
    supports counting from the end, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // two ways to define the same index, 3 in from the start
  prefs: []
  type: TYPE_NORMAL
- en: Index i1 = new
  prefs: []
  type: TYPE_NORMAL
- en: (value
  prefs: []
  type: TYPE_NORMAL
- en: ': 3'
  prefs: []
  type: TYPE_NORMAL
- en: ); // counts from the start
  prefs: []
  type: TYPE_NORMAL
- en: Index i2 = 3
  prefs: []
  type: TYPE_NORMAL
- en: ; // using implicit int conversion operator
  prefs: []
  type: TYPE_NORMAL
- en: // two ways to define the same index, 5 in from the end
  prefs: []
  type: TYPE_NORMAL
- en: Index i3 = new
  prefs: []
  type: TYPE_NORMAL
- en: (value
  prefs: []
  type: TYPE_NORMAL
- en: ': 5'
  prefs: []
  type: TYPE_NORMAL
- en: ', fromEnd: true'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Index i4 = ^5
  prefs: []
  type: TYPE_NORMAL
- en: ; // using the caret operator
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying ranges with the Range type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Range` value type uses `Index` values to indicate the start and end of
    its range, using its constructor, C# syntax, or its static methods, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Range r1 = new
  prefs: []
  type: TYPE_NORMAL
- en: '(start: new'
  prefs: []
  type: TYPE_NORMAL
- en: Index(3
  prefs: []
  type: TYPE_NORMAL
- en: '), end: new'
  prefs: []
  type: TYPE_NORMAL
- en: Index(7
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: Range r2 = new
  prefs: []
  type: TYPE_NORMAL
- en: '(start: 3'
  prefs: []
  type: TYPE_NORMAL
- en: ', end: 7'
  prefs: []
  type: TYPE_NORMAL
- en: ); // using implicit int conversion
  prefs: []
  type: TYPE_NORMAL
- en: Range r3 = 3..7
  prefs: []
  type: TYPE_NORMAL
- en: ; // using C# 8.0 or later syntax
  prefs: []
  type: TYPE_NORMAL
- en: Range r4 = Range.StartAt(3
  prefs: []
  type: TYPE_NORMAL
- en: ); // from index 3 to last index
  prefs: []
  type: TYPE_NORMAL
- en: Range r5 = 3.
  prefs: []
  type: TYPE_NORMAL
- en: .; // from index 3 to last index
  prefs: []
  type: TYPE_NORMAL
- en: Range r6 = Range.EndAt(3
  prefs: []
  type: TYPE_NORMAL
- en: ); // from index 0 to index 3
  prefs: []
  type: TYPE_NORMAL
- en: Range r7 = ..3
  prefs: []
  type: TYPE_NORMAL
- en: ; // from index 0 to index 3
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods have been added to `string` values (that internally use an
    array of `char` ), `int` arrays, and spans to make ranges easier to work with.
    These extension methods accept a range as a parameter and return a `Span<T>` .
    This makes them very memory efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Using indexes, ranges, and spans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore using indexes and ranges to return spans:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithRanges`
    to the `Chapter08` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithRanges` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs` , type statements to compare using the `string` type''s `Substring`
    method using ranges to extract parts of someone''s name, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: name = "Samantha Jones"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: // Using Substring
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: lengthOfFirst = name.IndexOf(' '
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: lengthOfLast = name.Length - lengthOfFirst - 1
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: firstName = name.Substring(
  prefs: []
  type: TYPE_NORMAL
- en: 'startIndex: 0'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'length: lengthOfFirst);'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: lastName = name.Substring(
  prefs: []
  type: TYPE_NORMAL
- en: 'startIndex: name.Length - lengthOfLast,'
  prefs: []
  type: TYPE_NORMAL
- en: 'length: lengthOfLast);'
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"First name:'
  prefs: []
  type: TYPE_NORMAL
- en: '{firstName}'
  prefs: []
  type: TYPE_NORMAL
- en: ', Last name:'
  prefs: []
  type: TYPE_NORMAL
- en: '{lastName}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: // Using spans
  prefs: []
  type: TYPE_NORMAL
- en: ReadOnlySpan<char
  prefs: []
  type: TYPE_NORMAL
- en: nameAsSpan = name.AsSpan();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ReadOnlySpan<char
  prefs: []
  type: TYPE_NORMAL
- en: firstNameSpan = nameAsSpan[0.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: .lengthOfFirst];
  prefs: []
  type: TYPE_NORMAL
- en: ReadOnlySpan<char
  prefs: []
  type: TYPE_NORMAL
- en: lastNameSpan = nameAsSpan[^lengthOfLast..^0
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '];'
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("First name: {0}, Last name: {1}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: firstNameSpan.ToString(),'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: lastNameSpan.ToString());'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'First name: Samantha, Last name: Jones'
  prefs: []
  type: TYPE_NORMAL
- en: 'First name: Samantha, Last name: Jones'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Working with network resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you will need to work with network resources. The most common types
    in .NET for working with network resources are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Namespace | Example type(s) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Net` | `Dns` , `Uri` , `Cookie` , `WebClient` , `IPAddress` | These
    are for working with DNS servers, URIs, IP addresses, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Net` | `FtpStatusCode` , `FtpWebRequest` , `FtpWebResponse` | These
    are for working with FTP servers. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Net` | `HttpStatusCode` , `HttpWebRequest` , `HttpWebResponse` |
    These are for working with HTTP servers; that is, websites and services. Types
    from `System.Net.Http` are easier to use. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Net.Http` | `HttpClient` , `HttpMethod` , `HttpRequestMessage` ,
    `HttpResponseMessage` | These are for working with HTTP servers; that is, websites
    and services. You will learn how to use these in *Chapter 16* , *Building and
    Consuming Web Services* . |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Net.Mail` | `Attachment` , `MailAddress` , `MailMessage` , `SmtpClient`
    | These are for working with SMTP servers; that is, sending email messages. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Net .NetworkInformation` | `IPStatus` , `NetworkChange` , `Ping`
    , `TcpStatistics` | These are for working with low-level network protocols. |'
  prefs: []
  type: TYPE_TB
- en: Working with URIs, DNS, and IP addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore some common types for working with network resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithNetworkResources`
    to the `Chapter08` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithNetworkResources` as the active OmniSharp
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs` , import the namespace for working with the network,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.Net; // IPHostEntry, Dns, IPAddress
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type statements to prompt the user to enter a website address, and then use
    the `Uri` type to break it down into its parts, including the scheme (HTTP, FTP,
    and so on), port number, and host, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write("Enter a valid web address: "'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: string? url = ReadLine();
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (string
  prefs: []
  type: TYPE_NORMAL
- en: .IsNullOrWhiteSpace(url))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: url = "https://stackoverflow.com/search?q=securestring"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Uri uri = new
  prefs: []
  type: TYPE_NORMAL
- en: (url);
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '{url}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '{uri.Scheme}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Port:'
  prefs: []
  type: TYPE_NORMAL
- en: '{uri.Port}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Host:'
  prefs: []
  type: TYPE_NORMAL
- en: '{uri.Host}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Path:'
  prefs: []
  type: TYPE_NORMAL
- en: '{uri.AbsolutePath}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Query:'
  prefs: []
  type: TYPE_NORMAL
- en: '{uri.Query}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, the code also allows the user to press ENTER to use an example
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, enter a valid website address or press ENTER , and view the result,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a valid web address:'
  prefs: []
  type: TYPE_NORMAL
- en: 'URL: https://stackoverflow.com/search?q=securestring'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scheme: https'
  prefs: []
  type: TYPE_NORMAL
- en: 'Port: 443'
  prefs: []
  type: TYPE_NORMAL
- en: 'Host: stackoverflow.com'
  prefs: []
  type: TYPE_NORMAL
- en: 'Path: /search'
  prefs: []
  type: TYPE_NORMAL
- en: 'Query: ?q=securestring'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to get the IP address for the entered website, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: IPHostEntry entry = Dns.GetHostEntry(uri.Host);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{entry.HostName}'
  prefs: []
  type: TYPE_NORMAL
- en: has the following IP addresses:"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (IPAddress address in
  prefs: []
  type: TYPE_NORMAL
- en: entry.AddressList)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{address}'
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: '{address.AddressFamily}'
  prefs: []
  type: TYPE_NORMAL
- en: )"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, enter a valid website address or press ENTER , and view the result,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'stackoverflow.com has the following IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: 151.101.193.69 (InterNetwork)
  prefs: []
  type: TYPE_NORMAL
- en: 151.101.129.69 (InterNetwork)
  prefs: []
  type: TYPE_NORMAL
- en: 151.101.1.69 (InterNetwork)
  prefs: []
  type: TYPE_NORMAL
- en: 151.101.65.69 (InterNetwork)
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Pinging a server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now you will add code to ping a web server to check its health:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the namespace to get more information about networks, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.Net.NetworkInformation; // Ping, PingReply, IPStatus
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to ping the entered website, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: try
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Ping ping = new
  prefs: []
  type: TYPE_NORMAL
- en: ();
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Pinging server. Please wait..."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: PingReply reply = ping.Send(uri.Host);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{uri.Host}'
  prefs: []
  type: TYPE_NORMAL
- en: 'was pinged and replied:'
  prefs: []
  type: TYPE_NORMAL
- en: '{reply.Status}'
  prefs: []
  type: TYPE_NORMAL
- en: ."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (reply.Status == IPStatus.Success)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Reply from {0} took {1:N0}ms"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: reply.Address,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: reply.RoundtripTime);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: catch (Exception ex)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{ex.GetType().ToString()}'
  prefs: []
  type: TYPE_NORMAL
- en: says
  prefs: []
  type: TYPE_NORMAL
- en: '{ex.Message}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, press ENTER , and view the result, as shown in the following
    output on macOS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Pinging server. Please wait...
  prefs: []
  type: TYPE_NORMAL
- en: 'stackoverflow.com was pinged and replied: Success.'
  prefs: []
  type: TYPE_NORMAL
- en: Reply from 151.101.193.69 took 18ms took 136ms
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code again but this time enter [http://google.com](http://google.com)
    , as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a valid web address: http://google.com'
  prefs: []
  type: TYPE_NORMAL
- en: 'URL: http://google.com'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scheme: http'
  prefs: []
  type: TYPE_NORMAL
- en: 'Port: 80'
  prefs: []
  type: TYPE_NORMAL
- en: 'Host: google.com'
  prefs: []
  type: TYPE_NORMAL
- en: 'Path: /'
  prefs: []
  type: TYPE_NORMAL
- en: 'Query:'
  prefs: []
  type: TYPE_NORMAL
- en: 'google.com has the following IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: 2a00:1450:4009:807::200e (InterNetworkV6)
  prefs: []
  type: TYPE_NORMAL
- en: 216.58.204.238 (InterNetwork)
  prefs: []
  type: TYPE_NORMAL
- en: Pinging server. Please wait...
  prefs: []
  type: TYPE_NORMAL
- en: 'google.com was pinged and replied: Success.'
  prefs: []
  type: TYPE_NORMAL
- en: Reply from 2a00:1450:4009:807::200e took 24ms
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Working with reflection and attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Reflection** is a programming feature that allows code to understand and
    manipulate itself. An assembly is made up of up to four parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assembly metadata and manifest** : Name, assembly, and file version, referenced
    assemblies, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type metadata** : Information about the types, their members, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IL code** : Implementation of methods, properties, constructors, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embedded resources** (optional): Images, strings, JavaScript, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The metadata comprises items of information about your code. The metadata is
    generated automatically from your code (for example, information about the types
    and members) or applied to your code using attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attributes can be applied at multiple levels: to assemblies, to types, and
    to their members, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // an assembly-level attribute
  prefs: []
  type: TYPE_NORMAL
- en: '[assembly: AssemblyTitle('
  prefs: []
  type: TYPE_NORMAL
- en: '"Working with Reflection"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: // a type-level attribute
  prefs: []
  type: TYPE_NORMAL
- en: '[Serializable'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Person
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // a member-level attribute
  prefs: []
  type: TYPE_NORMAL
- en: '[Obsolete('
  prefs: []
  type: TYPE_NORMAL
- en: '"Deprecated: use Run instead."'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: Walk
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Attribute-based programming is used a lot in app models like ASP.NET Core to
    enable features like routing, security, and caching.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning of assemblies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Version numbers in .NET are a combination of three numbers, with two optional
    additions. If you follow the rules of semantic versioning, the three numbers denote
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Major** : Breaking changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minor** : Non-breaking changes, including new features, and often bug fixes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Patch** : Non-breaking bug fixes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice** : When updating a NuGet package that you already use in a
    project, to be safe you should specify an optional flag to make sure that you
    only upgrade to the highest minor to avoid breaking changes, or to the highest
    patch if you are extra cautious and only want to receive bug fixes, as shown in
    the following commands: `Update-Package Newtonsoft.Json -ToHighestMinor` or `Update-Package
    Newtonsoft.Json -ToHighestPatch` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, a version can include these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prerelease** : Unsupported preview releases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build number** : Nightly builds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice** : Follow the rules of semantic versioning, as described at
    the following link: [http://semver.org](http://semver.org)'
  prefs: []
  type: TYPE_NORMAL
- en: Reading assembly metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore working with attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithReflection`
    to the `Chapter08` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithReflection` as the active OmniSharp
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs` , import the namespace for reflection, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.Reflection; // Assembly
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to get the console app''s assembly, output its name and location,
    and get all assembly-level attributes and output their types, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Assembly metadata:"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Assembly? assembly = Assembly.GetEntryAssembly();
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (assembly is
  prefs: []
  type: TYPE_NORMAL
- en: 'null'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Failed to get entry assembly."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"  Full name:'
  prefs: []
  type: TYPE_NORMAL
- en: '{assembly.FullName}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"  Location:'
  prefs: []
  type: TYPE_NORMAL
- en: '{assembly.Location}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: IEnumerable<Attribute> attributes = assembly.GetCustomAttributes();
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"  Assembly-level attributes:"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (Attribute a in
  prefs: []
  type: TYPE_NORMAL
- en: attributes)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{a.GetType()}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assembly metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Full name: WorkingWithReflection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null'
  prefs: []
  type: TYPE_NORMAL
- en: 'Location: /Users/markjprice/Code/Chapter08/WorkingWithReflection/bin/Debug/net6.0/WorkingWithReflection.dll'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assembly-level attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: System.Runtime.CompilerServices.CompilationRelaxationsAttribute
  prefs: []
  type: TYPE_NORMAL
- en: System.Runtime.CompilerServices.RuntimeCompatibilityAttribute
  prefs: []
  type: TYPE_NORMAL
- en: System.Diagnostics.DebuggableAttribute
  prefs: []
  type: TYPE_NORMAL
- en: System.Runtime.Versioning.TargetFrameworkAttribute
  prefs: []
  type: TYPE_NORMAL
- en: System.Reflection.AssemblyCompanyAttribute
  prefs: []
  type: TYPE_NORMAL
- en: System.Reflection.AssemblyConfigurationAttribute
  prefs: []
  type: TYPE_NORMAL
- en: System.Reflection.AssemblyFileVersionAttribute
  prefs: []
  type: TYPE_NORMAL
- en: System.Reflection.AssemblyInformationalVersionAttribute
  prefs: []
  type: TYPE_NORMAL
- en: System.Reflection.AssemblyProductAttribute
  prefs: []
  type: TYPE_NORMAL
- en: System.Reflection.AssemblyTitleAttribute
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that because the full name of an assembly must uniquely identify the assembly,
    it is a combination of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name** , for example, `WorkingWithReflection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version** , for example, `1.0.0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Culture** , for example, `neutral`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public key token** , although this can be `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know some of the attributes decorating the assembly, we can ask
    for them specifically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to get the `AssemblyInformationalVersionAttribute` and `AssemblyCompanyAttribute`
    classes and then output their values, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: AssemblyInformationalVersionAttribute? version = assembly
  prefs: []
  type: TYPE_NORMAL
- en: .GetCustomAttribute<AssemblyInformationalVersionAttribute>();
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"  Version:'
  prefs: []
  type: TYPE_NORMAL
- en: '{version?.InformationalVersion}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: AssemblyCompanyAttribute? company = assembly
  prefs: []
  type: TYPE_NORMAL
- en: .GetCustomAttribute<AssemblyCompanyAttribute>();
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"  Company:'
  prefs: []
  type: TYPE_NORMAL
- en: '{company?.Company}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: 1.0.0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Company: WorkingWithReflection'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hmmm, unless you set the version, it defaults to 1.0.0, and unless you set
    the company, it defaults to the name of the assembly. Let''s explicitly set this
    information. The legacy .NET Framework way to set these values was to add attributes
    in the C# source code file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '[assembly: AssemblyCompany('
  prefs: []
  type: TYPE_NORMAL
- en: '"Packt Publishing"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[assembly: AssemblyInformationalVersion('
  prefs: []
  type: TYPE_NORMAL
- en: '"1.3.0"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The Roslyn compiler used by .NET sets these attributes automatically, so we
    can't use the old way. Instead, they must be set in the project file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `WorkingWithReflection.csproj` project file to add elements for version
    and company, as shown highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <Project Sdk="Microsoft.NET.Sdk"
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: <PropertyGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <OutputType>Exe</OutputType>
  prefs: []
  type: TYPE_NORMAL
- en: <TargetFramework>net6.0
  prefs: []
  type: TYPE_NORMAL
- en: </TargetFramework>
  prefs: []
  type: TYPE_NORMAL
- en: <Nullable>enable</Nullable>
  prefs: []
  type: TYPE_NORMAL
- en: <ImplicitUsings>enable</ImplicitUsings>
  prefs: []
  type: TYPE_NORMAL
- en: '**<Version>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.3.12**'
  prefs: []
  type: TYPE_NORMAL
- en: '**</Version>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**<Company>Packt Publishing</Company>**'
  prefs: []
  type: TYPE_NORMAL
- en: </PropertyGroup>
  prefs: []
  type: TYPE_NORMAL
- en: </Project>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version: 6.3.12'
  prefs: []
  type: TYPE_NORMAL
- en: 'Company: Packt Publishing'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can define your own attributes by inheriting from the `Attribute` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a class file to your project named `CoderAttribute.cs` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define an attribute class that can decorate either classes or methods with
    two properties to store the name of a coder and the date they last modified some
    code, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method,'
  prefs: []
  type: TYPE_NORMAL
- en: AllowMultiple = true)
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: CoderAttribute
  prefs: []
  type: TYPE_NORMAL
- en: ': Attribute'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: Coder { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: DateTime LastModified { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: CoderAttribute
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: coder,
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: lastModified
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Coder = coder;
  prefs: []
  type: TYPE_NORMAL
- en: LastModified = DateTime.Parse(lastModified);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , import some namespaces, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.Runtime.CompilerServices; // CompilerGeneratedAttribute
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared; // CoderAttribute
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , add a class with a method, and decorate the
    method with the `Coder` attribute with data about two coders, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Animal
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '[Coder('
  prefs: []
  type: TYPE_NORMAL
- en: '"Mark Price"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: '"22 August 2021"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[Coder('
  prefs: []
  type: TYPE_NORMAL
- en: '"Johnni Rasmussen"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: '"13 September 2021"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: Speak
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Woof..."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , above the `Animal` class, add code to get the types, enumerate
    their members, read any `Coder` attributes on those members, and output the information,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"* Types:"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Type[] types = assembly.GetTypes();
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (Type type in
  prefs: []
  type: TYPE_NORMAL
- en: types)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Type:'
  prefs: []
  type: TYPE_NORMAL
- en: '{type.FullName}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: MemberInfo[] members = type.GetMembers();
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (MemberInfo member in
  prefs: []
  type: TYPE_NORMAL
- en: members)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("{0}: {1} ({2})"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: member.MemberType,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: member.Name,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg2: member.DeclaringType?.Name);'
  prefs: []
  type: TYPE_NORMAL
- en: IOrderedEnumerable<CoderAttribute> coders =
  prefs: []
  type: TYPE_NORMAL
- en: member.GetCustomAttributes<CoderAttribute>()
  prefs: []
  type: TYPE_NORMAL
- en: .OrderByDescending(c => c.LastModified);
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (CoderAttribute coder in
  prefs: []
  type: TYPE_NORMAL
- en: coders)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("-> Modified by {0} on {1}"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: coder.Coder, coder.LastModified.ToShortDateString());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '* Types:'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type: Animal'
  prefs: []
  type: TYPE_NORMAL
- en: 'Method: Speak (Animal)'
  prefs: []
  type: TYPE_NORMAL
- en: ->
  prefs: []
  type: TYPE_NORMAL
- en: Modified by Johnni Rasmussen on 13/09/2021
  prefs: []
  type: TYPE_NORMAL
- en: ->
  prefs: []
  type: TYPE_NORMAL
- en: Modified by Mark Price on 22/08/2021
  prefs: []
  type: TYPE_NORMAL
- en: 'Method: GetType (Object)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Method: ToString (Object)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Method: Equals (Object)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Method: GetHashCode (Object)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor: .ctor (Program)'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type: <Program>$+<>c'
  prefs: []
  type: TYPE_NORMAL
- en: 'Method: GetType (Object)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Method: ToString (Object)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Method: Equals (Object)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Method: GetHashCode (Object)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor: .ctor (<>c)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Field: <>9 (<>c)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Field: <>9__0_0 (<>c)'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: What is the `<Program>$+<>c` type?
  prefs: []
  type: TYPE_NORMAL
- en: It is a compiler-generated **display class** . `<>` indicates compiler-generated
    and `c` indicates a display class. They are undocumented implementation details
    of the compiler and could change at any time. You can ignore them, so as an optional
    challenge, add statements to your console application to filter compiler-generated
    types by skipping types decorated with `CompilerGeneratedAttribute` .
  prefs: []
  type: TYPE_NORMAL
- en: Doing more with reflection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is just a taster of what can be achieved with reflection. We only used
    reflection to read metadata from our code. Reflection can also do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamically load assemblies that are not currently referenced** : [https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability](https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamically execute code** : [https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodbase.invoke](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodbase.invoke)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamically generate new code and assemblies** : [https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.assemblybuilder](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.assemblybuilder)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ImageSharp is a third-party cross-platform 2D graphics library. When .NET Core
    1.0 was in development, there was negative feedback from the community about the
    missing `System.Drawing` namespace for working with 2D images.
  prefs: []
  type: TYPE_NORMAL
- en: The **ImageSharp** project was started to fill that gap for modern .NET applications.
  prefs: []
  type: TYPE_NORMAL
- en: In their official documentation for `System.Drawing` , Microsoft says, "The
    `System.Drawing` namespace is not recommended for new development due to not being
    supported within a Windows or ASP.NET service, and it is not cross-platform. ImageSharp
    and SkiaSharp are recommended as alternatives."
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see what can be achieved with ImageSharp:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithImages`
    to the `Chapter08` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithImages` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `images` folder and download the nine images from the following link:
    [https://github.com/markjprice/cs10dotnet6/tree/master/Assets/Categories](https://github.com/markjprice/cs10dotnet6/tree/master/Assets/Categories)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a package reference for `SixLabors.ImageSharp` , as shown in the following
    markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <PackageReference Include="SixLabors.ImageSharp"
  prefs: []
  type: TYPE_NORMAL
- en: Version="1.0.3"
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: </ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Build the `WorkingWithImages` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs` , import some namespaces for working with images,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: SixLabors.ImageSharp;
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: SixLabors.ImageSharp.Processing;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , enter statements to convert all the files in the images folder
    into grayscale thumbnails at one-tenth size, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: imagesFolder = Path.Combine(
  prefs: []
  type: TYPE_NORMAL
- en: Environment.CurrentDirectory, "images"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: IEnumerable<string
  prefs: []
  type: TYPE_NORMAL
- en: images =
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Directory.EnumerateFiles(imagesFolder);
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (string
  prefs: []
  type: TYPE_NORMAL
- en: imagePath in
  prefs: []
  type: TYPE_NORMAL
- en: images)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: thumbnailPath = Path.Combine(
  prefs: []
  type: TYPE_NORMAL
- en: Environment.CurrentDirectory, "images"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: Path.GetFileNameWithoutExtension(imagePath)
  prefs: []
  type: TYPE_NORMAL
- en: + "-thumbnail"
  prefs: []
  type: TYPE_NORMAL
- en: + Path.GetExtension(imagePath));
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (Image image = Image.Load(imagePath))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: image.Mutate(x => x.Resize(image.Width / 10
  prefs: []
  type: TYPE_NORMAL
- en: ', image.Height / 10'
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: image.Mutate(x => x.Grayscale());
  prefs: []
  type: TYPE_NORMAL
- en: image.Save(thumbnailPath);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Image processing complete. View the images folder."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Run the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the filesystem, open the `images` folder and note the much-smaller-in-bytes
    grayscale thumbnails, as shown in *Figure 8.1* :![A picture containing application
    Description automatically generated](img/Image00085.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.1: Images after processing'
  prefs: []
  type: TYPE_NORMAL
- en: 'ImageSharp also has NuGet packages for programmatically drawing images and
    working with images on the web, as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SixLabors.ImageSharp.Drawing`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SixLabors.ImageSharp.Web`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalizing your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Internationalization is the process of enabling your code to run correctly
    all over the world. It has two parts: **globalization** and **localization** .'
  prefs: []
  type: TYPE_NORMAL
- en: Globalization is about writing your code to accommodate multiple languages and
    region combinations. The combination of a language and a region is known as a
    culture. It is important for your code to know both the language and region because,
    for example, the date and currency formats are different in Quebec and Paris,
    despite them both using the French language.
  prefs: []
  type: TYPE_NORMAL
- en: There are **International Organization for Standardization** (**ISO** ) codes
    for all culture combinations. For example, in the code `da-DK` , `da` indicates
    the Danish language and `DK` indicates the Denmark region, and in the code `fr-CA`
    , `fr` indicates the French language and `CA` indicates the Canada region.
  prefs: []
  type: TYPE_NORMAL
- en: ISO is not an acronym. ISO is a reference to the Greek word *isos* (which means
    equal).
  prefs: []
  type: TYPE_NORMAL
- en: Localization is about customizing the user interface to support a language,
    for example, changing the label of a button to be Close (`en` ) or Fermer (`fr`
    ). Since localization is more about the language, it doesn't always need to know
    about the region, although ironically enough, standardization (`en-US` ) and standardisation
    (`en-GB` ) suggest otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting and changing the current culture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Internationalization is a huge topic on which several thousand-page books have
    been written. In this section, you will get a brief introduction to the basics
    using the `CultureInfo` type in the `System.Globalization` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write some code:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `Internationalization`
    to the `Chapter08` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `Internationalization` as the active OmniSharp
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs` , import the namespace for using globalization types,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.Globalization; // CultureInfo
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to get the current globalization and localization cultures and
    output some information about them, and then prompt the user to enter a new culture
    code and show how that affects the formatting of common values such as dates and
    currency, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: CultureInfo globalization = CultureInfo.CurrentCulture;
  prefs: []
  type: TYPE_NORMAL
- en: CultureInfo localization = CultureInfo.CurrentUICulture;
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("The current globalization culture is {0}: {1}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: globalization.Name, globalization.DisplayName);
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("The current localization culture is {0}: {1}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: localization.Name, localization.DisplayName);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("en-US: English (United States)"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("da-DK: Danish (Denmark)"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("fr-CA: French (Canada)"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'Write("Enter an ISO culture code: "'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? newCulture = ReadLine();'
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (!string
  prefs: []
  type: TYPE_NORMAL
- en: .IsNullOrEmpty(newCulture))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: CultureInfo ci = new
  prefs: []
  type: TYPE_NORMAL
- en: (newCulture);
  prefs: []
  type: TYPE_NORMAL
- en: // change the current cultures
  prefs: []
  type: TYPE_NORMAL
- en: CultureInfo.CurrentCulture = ci;
  prefs: []
  type: TYPE_NORMAL
- en: CultureInfo.CurrentUICulture = ci;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: 'Write("Enter your name: "'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? name = ReadLine();'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write("Enter your date of birth: "'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? dob = ReadLine();'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write("Enter your salary: "'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? salary = ReadLine();'
  prefs: []
  type: TYPE_NORMAL
- en: DateTime date = DateTime.Parse(dob);
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: minutes = (int
  prefs: []
  type: TYPE_NORMAL
- en: )DateTime.Today.Subtract(date).TotalMinutes;
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  prefs: []
  type: TYPE_NORMAL
- en: earns = decimal
  prefs: []
  type: TYPE_NORMAL
- en: .Parse(salary);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(
  prefs: []
  type: TYPE_NORMAL
- en: '"{0} was born on a {1:dddd}, is {2:N0} minutes old, and earns {3:C}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: name, date, minutes, earns);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: When you run an application, it automatically sets its thread to use the culture
    of the operating system. I am running my code in London, UK, so the thread is
    set to English (United Kingdom).
  prefs: []
  type: TYPE_NORMAL
- en: The code prompts the user to enter an alternative ISO code. This allows your
    applications to replace the default culture at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The application then uses standard format codes to output the day of the week
    using format code `dddd` ; the number of minutes with thousand separators using
    format code `N0` ; and the salary with the currency symbol. These adapt automatically,
    based on the thread's culture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and enter `en-GB` for the ISO code and then enter some sample
    data including a date in a format valid for British English, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter an ISO culture code: en-GB'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter your name: Alice'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter your date of birth: 30/3/1967'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter your salary: 23500'
  prefs: []
  type: TYPE_NORMAL
- en: Alice was born on a Thursday, is 25,469,280 minutes old, and earns
  prefs: []
  type: TYPE_NORMAL
- en: £23,500.00
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If you enter `en-US` instead of `en-GB` , then you must enter the date using
    month/day/year.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rerun the code and try a different culture, such as Danish in Denmark, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter an ISO culture code: da-DK'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter your name: Mikkel'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter your date of birth: 12/3/1980'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter your salary: 340000'
  prefs: []
  type: TYPE_NORMAL
- en: Mikkel was born on a onsdag, is 18.656.640 minutes old, and earns 340.000,00
    kr.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, only the date and salary are globalized into Danish. The rest
    of the text is hardcoded as English. This book does not currently include how
    to translate text from one language to another. If you would like me to include
    that in the next edition, please let me know.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Consider whether your application needs to be internationalized
    and plan for that before you start coding! Write down all the pieces of text in
    the user interface that will need to be localized. Think about all the data that
    will need to be globalized (date formats, number formats, and sorting text behavior).'
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore with deeper research into the topics in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8.1 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the web to answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the maximum number of characters that can be stored in a `string` variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When and why should you use a `SecureString` type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it appropriate to use a `StringBuilder` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use a `LinkedList<T>` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use a `SortedDictionary<T>` class rather than a `SortedList<T>`
    class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the ISO culture code for Welsh?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between localization, globalization, and internationalization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a regular expression, what does `$` mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a regular expression, how can you represent digits?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you *not* use the official standard for email addresses to create
    a regular expression to validate a user's email address?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 8.2 – Practice regular expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Chapter08` solution/workspace, create a console application named `Exercise02`
    that prompts the user to enter a regular expression and then prompts the user
    to enter some input and compare the two for a match until the user presses *Esc*
    , as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: The default regular expression checks for at least one digit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a regular expression (or press ENTER to use the default): ^[a-z]+$'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter some input: apples'
  prefs: []
  type: TYPE_NORMAL
- en: apples matches ^[a-z]+$? True
  prefs: []
  type: TYPE_NORMAL
- en: Press ESC to end or any key to try again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a regular expression (or press ENTER to use the default): ^[a-z]+$'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter some input: abc123xyz'
  prefs: []
  type: TYPE_NORMAL
- en: abc123xyz matches ^[a-z]+$? False
  prefs: []
  type: TYPE_NORMAL
- en: Press ESC to end or any key to try again.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8.3 – Practice writing extension methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `Chapter08` solution/workspace, create a class library named `Exercise03`
    that defines extension methods that extend number types such as `BigInteger` and
    `int` with a method named `ToWords` that returns a `string` describing the number;
    for example, `18,000,000` would be eighteen million, and `18,456,002,032,011,000,007`
    would be eighteen quintillion, four hundred and fifty-six quadrillion, two trillion,
    thirty-two billion, eleven million, and seven.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about names for large numbers at the following link: [https://en.wikipedia.org/wiki/Names_of_large_numbers](https://en.wikipedia.org/wiki/Names_of_large_numbers)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8.4 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more detail about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-8---working-with-common-net-types](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-8---working-with-common-net-types)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you explored some choices for types to store and manipulate
    numbers, dates and times, and text including regular expressions, and which collections
    to use for storing multiple items; worked with indexes, ranges, and spans; used
    some network resources; reflected on code and attributes; manipulated images using
    a Microsoft-recommended third-party library; and learned how to internationalize
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will manage files and streams, encode and decode text,
    and perform serialization.
  prefs: []
  type: TYPE_NORMAL

- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Improving Performance and Scalability Using Multitasking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about allowing multiple actions to occur at the same time to
    improve performance, scalability, and user productivity for the applications that
    you build.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding processes, threads, and tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring performance and resource usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tasks asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing access to shared resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding `async` and `await`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding processes, threads, and tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **process** , with one example being each of the console applications we have
    created, has resources like memory and threads allocated to it.
  prefs: []
  type: TYPE_NORMAL
- en: A **thread** executes your code, statement by statement. By default, each process
    only has one thread, and this can cause problems when we need to do more than
    one task at the same time. Threads are also responsible for keeping track of things
    like the currently authenticated user and any internationalization rules that
    should be followed for the current language and region.
  prefs: []
  type: TYPE_NORMAL
- en: Windows and most other modern operating systems use **preemptive multitasking**
    , which simulates the parallel execution of tasks. It divides the processor time
    among the threads, allocating a **time slice** to each thread one after another.
    The current thread is suspended when its time slice finishes. The processor then
    allows another thread to run for a time slice.
  prefs: []
  type: TYPE_NORMAL
- en: When Windows switches from one thread to another, it saves the context of the
    thread and reloads the previously saved context of the next thread in the thread
    queue. This takes both time and resources to complete.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, if you have a small number of complex pieces of work and you
    want complete control over them, then you could create and manage individual `Thread`
    instances. If you have one main thread and multiple small pieces of work that
    can be executed in the background, then you can use the `ThreadPool` class to
    add delegate instances that point to those pieces of work implemented as methods
    to a queue, and they will be automatically allocated to threads in the thread
    pool.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use the `Task` type to manage threads at a higher abstraction
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Threads may have to compete for and also wait for access to shared resources,
    such as variables, files, and database objects. There are types for managing this
    that you will see in action later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the task, doubling the number of threads (workers) to perform a
    task does not halve the number of seconds that it will take to complete that task.
    In fact, it can increase the duration of the task.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Never assume that more threads will improve performance!
    Run performance tests on a baseline code implementation without multiple threads,
    and then again on a code implementation with multiple threads. You should also
    perform performance tests in a staging environment that is as close as possible
    to the production environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring performance and resource usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can improve the performance of any code, we need to be able to monitor
    its speed and efficiency to record a baseline that we can then measure improvements
    against.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating the efficiency of types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What is the best type to use for a scenario? To answer this question, we need
    to carefully consider what we mean by "best", and through this, we should consider
    the following factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functionality** : This can be decided by checking whether the type provides
    the features you need.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory size** : This can be decided by the number of bytes of memory the
    type takes up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance** : This can be decided by how fast the type is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Future needs** : This depends on the changes in requirements and maintainability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will be scenarios, such as when storing numbers, where multiple types
    have the same functionality, so we will need to consider memory and performance
    to make a choice.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to store millions of numbers, then the best type to use would be
    the one that requires the fewest bytes of memory. But if we only need to store
    a few numbers, yet we need to perform lots of calculations on them, then the best
    type to use would be the one that runs fastest on a specific CPU.
  prefs: []
  type: TYPE_NORMAL
- en: You have seen the use of the `sizeof()` function, which shows the number of
    bytes a single instance of a type uses in memory. When we are storing a large
    number of values in more complex data structures, such as arrays and lists, then
    we need a better way of measuring memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: You can read lots of advice online and in books, but the only way to know for
    sure what the best type would be for your code is to compare the types yourself.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to write code to monitor the actual
    memory requirements and performance when using different types.
  prefs: []
  type: TYPE_NORMAL
- en: Today a `short` variable might be the best choice, but it might be an even better
    choice to use an `int` variable, even though it takes twice as much space in the
    memory. This is because we might need a wider range of values to be stored in
    the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an important metric that developers often forget: maintenance. This
    is a measure of how much effort another programmer would have to put in to understand
    and modify your code. If you make a nonobvious choice of type without explaining
    that choice with a helpful comment, then it might confuse the programmer who comes
    along later and needs to fix a bug or add a feature.'
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring performance and memory using diagnostics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `System.Diagnostics` namespace has lots of useful types for monitoring
    your code. The first useful type that we will look at is the `Stopwatch` type:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to create a new workspace/solution named `Chapter12`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a class library project, as defined in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Class Library** / `classlib`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `Chapter12`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `MonitoringLib`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a console app project, as defined in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console Application** / `console`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `Chapter12`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `MonitoringApp`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, set the startup project for the solution to the current selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `MonitoringApp` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `MonitoringLib` project, rename the `Class1.cs` file to `Recorder.cs`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `MonitoringApp` project, add a project reference to the `MonitoringLib`
    class library, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <ProjectReference
  prefs: []
  type: TYPE_NORMAL
- en: Include="..\MonitoringLib\MonitoringLib.csproj"
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: </ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Build the `MonitoringApp` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Useful members of the Stopwatch and Process types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Stopwatch` type has some useful members, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Member | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `Restart` method | This resets the elapsed time to zero and then starts the
    timer. |'
  prefs: []
  type: TYPE_TB
- en: '| `Stop` method | This stops the timer. |'
  prefs: []
  type: TYPE_TB
- en: '| `Elapsed` property | This is the elapsed time stored as a `TimeSpan` format
    (for example, hours:minutes:seconds) |'
  prefs: []
  type: TYPE_TB
- en: '| `ElapsedMilliseconds` property | This is the elapsed time in milliseconds
    stored as an `Int64` value. |'
  prefs: []
  type: TYPE_TB
- en: 'The `Process` type has some useful members, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Member | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `VirtualMemorySize64` | This displays the amount of virtual memory, in bytes,
    allocated for the process. |'
  prefs: []
  type: TYPE_TB
- en: '| `WorkingSet64` | This displays the amount of physical memory, in bytes, allocated
    for the process. |'
  prefs: []
  type: TYPE_TB
- en: Implementing a Recorder class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will create a `Recorder` class that makes it easy to monitor time and memory
    resource usage. To implement our `Recorder` class, we will use the `Stopwatch`
    and `Process` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Recorder.cs` , change its contents to use a `Stopwatch` instance to record
    timings and the current `Process` instance to record memory usage, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.Diagnostics; // Stopwatch
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.Console;
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.Diagnostics.Process; // GetCurrentProcess()
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Recorder
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: private
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: Stopwatch timer = new
  prefs: []
  type: TYPE_NORMAL
- en: ();
  prefs: []
  type: TYPE_NORMAL
- en: private
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: long
  prefs: []
  type: TYPE_NORMAL
- en: bytesPhysicalBefore = 0
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: private
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: long
  prefs: []
  type: TYPE_NORMAL
- en: bytesVirtualBefore = 0
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: Start
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // force two garbage collections to release memory that is
  prefs: []
  type: TYPE_NORMAL
- en: // no longer referenced but has not been released yet
  prefs: []
  type: TYPE_NORMAL
- en: GC.Collect();
  prefs: []
  type: TYPE_NORMAL
- en: GC.WaitForPendingFinalizers();
  prefs: []
  type: TYPE_NORMAL
- en: GC.Collect();
  prefs: []
  type: TYPE_NORMAL
- en: // store the current physical and virtual memory use
  prefs: []
  type: TYPE_NORMAL
- en: bytesPhysicalBefore = GetCurrentProcess().WorkingSet64;
  prefs: []
  type: TYPE_NORMAL
- en: bytesVirtualBefore = GetCurrentProcess().VirtualMemorySize64;
  prefs: []
  type: TYPE_NORMAL
- en: timer.Restart();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: Stop
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: timer.Stop();
  prefs: []
  type: TYPE_NORMAL
- en: long
  prefs: []
  type: TYPE_NORMAL
- en: bytesPhysicalAfter =
  prefs: []
  type: TYPE_NORMAL
- en: GetCurrentProcess().WorkingSet64;
  prefs: []
  type: TYPE_NORMAL
- en: long
  prefs: []
  type: TYPE_NORMAL
- en: bytesVirtualAfter =
  prefs: []
  type: TYPE_NORMAL
- en: GetCurrentProcess().VirtualMemorySize64;
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0:N0} physical bytes used."
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: bytesPhysicalAfter - bytesPhysicalBefore);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0:N0} virtual bytes used."
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: bytesVirtualAfter - bytesVirtualBefore);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0} time span ellapsed."
  prefs: []
  type: TYPE_NORMAL
- en: ', timer.Elapsed);'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0:N0} total milliseconds ellapsed."
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: timer.ElapsedMilliseconds);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The `Start` method of the `Recorder` class uses the `GC` type (garbage collector)
    to ensure that any currently allocated but not referenced memory is collected
    before recording the amount of used memory. This is an advanced technique that
    you should almost never use in application code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , write statements to start and stop the `Recorder` while generating
    an array of 10,000 integers, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared; // Recorder
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.Console;
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Processing. Please wait..."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Recorder.Start();
  prefs: []
  type: TYPE_NORMAL
- en: // simulate a process that requires some memory resources...
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '[] largeArrayOfInts = Enumerable.Range('
  prefs: []
  type: TYPE_NORMAL
- en: 'start: 1'
  prefs: []
  type: TYPE_NORMAL
- en: ', count: 10'
  prefs: []
  type: TYPE_NORMAL
- en: _000).ToArray();
  prefs: []
  type: TYPE_NORMAL
- en: // ...and takes some time to complete
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Sleep(new
  prefs: []
  type: TYPE_NORMAL
- en: Random().Next(5
  prefs: []
  type: TYPE_NORMAL
- en: ', 10'
  prefs: []
  type: TYPE_NORMAL
- en: ) * 1000
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Recorder.Stop();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Processing. Please wait...
  prefs: []
  type: TYPE_NORMAL
- en: 655,360 physical bytes used.
  prefs: []
  type: TYPE_NORMAL
- en: 536,576 virtual bytes used.
  prefs: []
  type: TYPE_NORMAL
- en: 00:00:09.0038702 time span ellapsed.
  prefs: []
  type: TYPE_NORMAL
- en: 9,003 total milliseconds ellapsed.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that the time elapsed is randomly between 5 and 10 seconds. Your results
    will vary. For example, when run on my Mac mini M1, less physical memory but more
    virtual memory was used, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Processing. Please wait...
  prefs: []
  type: TYPE_NORMAL
- en: 294,912 physical bytes used.
  prefs: []
  type: TYPE_NORMAL
- en: 10,485,760 virtual bytes used.
  prefs: []
  type: TYPE_NORMAL
- en: 00:00:06.0074221 time span ellapsed.
  prefs: []
  type: TYPE_NORMAL
- en: 6,007 total milliseconds ellapsed.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Measuring the efficiency of processing strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you've seen how the `Stopwatch` and `Process` types can be used to
    monitor your code, we will use them to evaluate the best way to process `string`
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , comment out the previous statements by wrapping them in multi-line
    comment characters: `/* */` .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write statements to create an array of 50,000 `int` variables and then concatenate
    them with commas as separators using a `string` and `StringBuilder` class, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '[] numbers = Enumerable.Range('
  prefs: []
  type: TYPE_NORMAL
- en: 'start: 1'
  prefs: []
  type: TYPE_NORMAL
- en: ', count: 50'
  prefs: []
  type: TYPE_NORMAL
- en: _000).ToArray();
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Using string with +"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Recorder.Start();
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: s = string
  prefs: []
  type: TYPE_NORMAL
- en: .Empty; // i.e. ""
  prefs: []
  type: TYPE_NORMAL
- en: for
  prefs: []
  type: TYPE_NORMAL
- en: (int
  prefs: []
  type: TYPE_NORMAL
- en: i = 0
  prefs: []
  type: TYPE_NORMAL
- en: ; i < numbers.Length; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: s += numbers[i] + ", "
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Recorder.Stop();
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Using StringBuilder"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Recorder.Start();
  prefs: []
  type: TYPE_NORMAL
- en: System.Text.StringBuilder builder = new
  prefs: []
  type: TYPE_NORMAL
- en: ();
  prefs: []
  type: TYPE_NORMAL
- en: for
  prefs: []
  type: TYPE_NORMAL
- en: (int
  prefs: []
  type: TYPE_NORMAL
- en: i = 0
  prefs: []
  type: TYPE_NORMAL
- en: ; i < numbers.Length; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: builder.Append(numbers[i]);
  prefs: []
  type: TYPE_NORMAL
- en: builder.Append(", "
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Recorder.Stop();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Using string with +
  prefs: []
  type: TYPE_NORMAL
- en: 14,883,072 physical bytes used.
  prefs: []
  type: TYPE_NORMAL
- en: 3,609,728 virtual bytes used.
  prefs: []
  type: TYPE_NORMAL
- en: 00:00:01.6220879 time span ellapsed.
  prefs: []
  type: TYPE_NORMAL
- en: 1,622 total milliseconds ellapsed.
  prefs: []
  type: TYPE_NORMAL
- en: Using StringBuilder
  prefs: []
  type: TYPE_NORMAL
- en: 12,288 physical bytes used.
  prefs: []
  type: TYPE_NORMAL
- en: 0 virtual bytes used.
  prefs: []
  type: TYPE_NORMAL
- en: 00:00:00.0006038 time span ellapsed.
  prefs: []
  type: TYPE_NORMAL
- en: 0 total milliseconds ellapsed.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can summarize the results as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `string` class with the `+` operator used about 14 MB of physical memory,
    1.5 MB of virtual memory, and took 1.5 seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `StringBuilder` class used 12 KB of physical memory, zero virtual memory,
    and took less than 1 millisecond.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this scenario, `StringBuilder` is more than 1,000 times faster and about
    10,000 times more memory efficient when concatenating text! This is because `string`
    concatenation creates a new `string` each time you use it because `string` values
    are immutable so they can be safely pooled for reuse. `StringBuilder` creates
    a single buffer while it appends more characters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Avoid using the `String.Concat` method or the `+` operator
    inside loops. Use `StringBuilder` instead.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've learned how to measure the performance and resource efficiency
    of your code using types built into .NET, let's learn about a NuGet package that
    provides more sophisticated performance measurements.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring performance and memory using Benchmark.NET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a popular benchmarking NuGet package for .NET that Microsoft uses
    in its blog posts about performance improvements, so it is good for .NET developers
    to know how it works and use it for their own performance testing. Let''s see
    how we could use it to compare performance between `string` concatenation and
    `StringBuilder` :'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `Benchmarking` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `Benchmarking` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a package reference to Benchmark.NET, remembering that you can find out
    the latest version and use that instead of the version I used, as shown in the
    following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <PackageReference Include="BenchmarkDotNet"
  prefs: []
  type: TYPE_NORMAL
- en: Version="0.13.1"
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: </ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Build the project to restore packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs` , delete the existing statements and then import the namespace
    for running benchmarks, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: BenchmarkDotNet.Running;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new class file named `StringBenchmarks.cs` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `StringBenchmarks.cs` , add statements to define a class with methods for
    each benchmark you want to run, in this case, two methods that both combine twenty
    numbers comma-separated using either `string` concatenation or `StringBuilder`
    , as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: BenchmarkDotNet.Attributes; // [Benchmark]
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: StringBenchmarks
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '[] numbers;'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: StringBenchmarks
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: numbers = Enumerable.Range(
  prefs: []
  type: TYPE_NORMAL
- en: 'start: 1'
  prefs: []
  type: TYPE_NORMAL
- en: ', count: 20'
  prefs: []
  type: TYPE_NORMAL
- en: ).ToArray();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[Benchmark(Baseline = true)'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: StringConcatenationTest
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: s = string
  prefs: []
  type: TYPE_NORMAL
- en: .Empty; // e.g. ""
  prefs: []
  type: TYPE_NORMAL
- en: for
  prefs: []
  type: TYPE_NORMAL
- en: (int
  prefs: []
  type: TYPE_NORMAL
- en: i = 0
  prefs: []
  type: TYPE_NORMAL
- en: ; i < numbers.Length; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: s += numbers[i] + ", "
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: s;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[Benchmark'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: StringBuilderTest
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: System.Text.StringBuilder builder = new
  prefs: []
  type: TYPE_NORMAL
- en: ();
  prefs: []
  type: TYPE_NORMAL
- en: for
  prefs: []
  type: TYPE_NORMAL
- en: (int
  prefs: []
  type: TYPE_NORMAL
- en: i = 0
  prefs: []
  type: TYPE_NORMAL
- en: ; i < numbers.Length; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: builder.Append(numbers[i]);
  prefs: []
  type: TYPE_NORMAL
- en: builder.Append(", "
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: builder.ToString();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add a statement to run the benchmarks, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: BenchmarkRunner.Run<StringBenchmarks>();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio 2022, in the toolbar, set **Solution Configurations** to **Release**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, in a terminal, use the `dotnet run --configuration Release`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the console app and note the results, including some artifacts like report
    files, and the most important, a summary table that shows that `string` concatenation
    took a mean of 412.990 ns and `StringBuilder` took a mean of 275.082 ns, as shown
    in the following partial output and in *Figure 12.1* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '// ***** BenchmarkRunner: Finish  *****'
  prefs: []
  type: TYPE_NORMAL
- en: // * Export *
  prefs: []
  type: TYPE_NORMAL
- en: BenchmarkDotNet.Artifacts\results\StringBenchmarks-report.csv
  prefs: []
  type: TYPE_NORMAL
- en: BenchmarkDotNet.Artifacts\results\StringBenchmarks-report-github.md
  prefs: []
  type: TYPE_NORMAL
- en: BenchmarkDotNet.Artifacts\results\StringBenchmarks-report.html
  prefs: []
  type: TYPE_NORMAL
- en: // * Detailed results *
  prefs: []
  type: TYPE_NORMAL
- en: 'StringBenchmarks.StringConcatenationTest: DefaultJob'
  prefs: []
  type: TYPE_NORMAL
- en: Runtime = .NET 6.0.0 (6.0.21.37719), X64 RyuJIT; GC = Concurrent Workstation
  prefs: []
  type: TYPE_NORMAL
- en: Mean = 412.990 ns, StdErr = 2.353 ns (0.57%), N = 46, StdDev = 15.957 ns
  prefs: []
  type: TYPE_NORMAL
- en: Min = 373.636 ns, Q1 = 413.341 ns, Median = 417.665 ns, Q3 = 420.775 ns, Max
    = 434.504 ns
  prefs: []
  type: TYPE_NORMAL
- en: IQR = 7.433 ns, LowerFence = 402.191 ns, UpperFence = 431.925 ns
  prefs: []
  type: TYPE_NORMAL
- en: ConfidenceInterval = [404.708 ns; 421.273 ns] (CI 99.9%), Margin = 8.282 ns
    (2.01% of Mean)
  prefs: []
  type: TYPE_NORMAL
- en: Skewness = -1.51, Kurtosis = 4.09, MValue = 2
  prefs: []
  type: TYPE_NORMAL
- en: '-------------------- Histogram --------------------'
  prefs: []
  type: TYPE_NORMAL
- en: '[370.520 ns ; 382.211 ns) | @@@@@@'
  prefs: []
  type: TYPE_NORMAL
- en: '[382.211 ns ; 394.583 ns) | @'
  prefs: []
  type: TYPE_NORMAL
- en: '[394.583 ns ; 411.300 ns) | @@'
  prefs: []
  type: TYPE_NORMAL
- en: '[411.300 ns ; 422.990 ns) | @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@'
  prefs: []
  type: TYPE_NORMAL
- en: '[422.990 ns ; 436.095 ns) | @@@@@'
  prefs: []
  type: TYPE_NORMAL
- en: '---------------------------------------------------'
  prefs: []
  type: TYPE_NORMAL
- en: 'StringBenchmarks.StringBuilderTest: DefaultJob'
  prefs: []
  type: TYPE_NORMAL
- en: Runtime = .NET 6.0.0 (6.0.21.37719), X64 RyuJIT; GC = Concurrent Workstation
  prefs: []
  type: TYPE_NORMAL
- en: Mean = 275.082 ns, StdErr = 0.558 ns (0.20%), N = 15, StdDev = 2.163 ns
  prefs: []
  type: TYPE_NORMAL
- en: Min = 271.059 ns, Q1 = 274.495 ns, Median = 275.403 ns, Q3 = 276.553 ns, Max
    = 278.030 ns
  prefs: []
  type: TYPE_NORMAL
- en: IQR = 2.058 ns, LowerFence = 271.409 ns, UpperFence = 279.639 ns
  prefs: []
  type: TYPE_NORMAL
- en: ConfidenceInterval = [272.770 ns; 277.394 ns] (CI 99.9%), Margin = 2.312 ns
    (0.84% of Mean)
  prefs: []
  type: TYPE_NORMAL
- en: Skewness = -0.69, Kurtosis = 2.2, MValue = 2
  prefs: []
  type: TYPE_NORMAL
- en: '-------------------- Histogram --------------------'
  prefs: []
  type: TYPE_NORMAL
- en: '[269.908 ns ; 278.682 ns) | @@@@@@@@@@@@@@@'
  prefs: []
  type: TYPE_NORMAL
- en: '---------------------------------------------------'
  prefs: []
  type: TYPE_NORMAL
- en: // * Summary *
  prefs: []
  type: TYPE_NORMAL
- en: BenchmarkDotNet=v0.13.1, OS=Windows 10.0.19043.1165 (21H1/May2021Update)
  prefs: []
  type: TYPE_NORMAL
- en: 11th Gen Intel Core i7-1165G7 2.80GHz, 1 CPU, 8 logical and 4 physical cores
  prefs: []
  type: TYPE_NORMAL
- en: .NET SDK=6.0.100
  prefs: []
  type: TYPE_NORMAL
- en: '[Host]     : .NET 6.0.0 (6.0.21.37719), X64 RyuJIT'
  prefs: []
  type: TYPE_NORMAL
- en: 'DefaultJob : .NET 6.0.0 (6.0.21.37719), X64 RyuJIT'
  prefs: []
  type: TYPE_NORMAL
- en: '|                  Method |     Mean |   Error |   StdDev | Ratio | RatioSD
    |'
  prefs: []
  type: TYPE_TB
- en: '|------------------------ |---------:|--------:|---------:|------:|--------:|'
  prefs: []
  type: TYPE_NORMAL
- en: '| StringConcatenationTest | 413.0 ns | 8.28 ns | 15.96 ns |  1.00 |    0.00
    |'
  prefs: []
  type: TYPE_TB
- en: '|       StringBuilderTest | 275.1 ns | 2.31 ns |  2.16 ns |  0.69 |    0.04
    |'
  prefs: []
  type: TYPE_TB
- en: // * Hints *
  prefs: []
  type: TYPE_NORMAL
- en: Outliers
  prefs: []
  type: TYPE_NORMAL
- en: 'StringBenchmarks.StringConcatenationTest: Default -> 7 outliers were removed,
    14 outliers were detected (376.78 ns..391.88 ns, 440.79 ns..506.41 ns)'
  prefs: []
  type: TYPE_NORMAL
- en: 'StringBenchmarks.StringBuilderTest: Default       -> 2 outliers were detected
    (274.68 ns, 274.69 ns)'
  prefs: []
  type: TYPE_NORMAL
- en: // * Legends *
  prefs: []
  type: TYPE_NORMAL
- en: 'Mean    : Arithmetic mean of all measurements'
  prefs: []
  type: TYPE_NORMAL
- en: 'Error   : Half of 99.9% confidence interval'
  prefs: []
  type: TYPE_NORMAL
- en: 'StdDev  : Standard deviation of all measurements'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ratio   : Mean of the ratio distribution ([Current]/[Baseline])'
  prefs: []
  type: TYPE_NORMAL
- en: 'RatioSD : Standard deviation of the ratio distribution ([Current]/[Baseline])'
  prefs: []
  type: TYPE_NORMAL
- en: '1 ns    : 1 Nanosecond (0.000000001 sec)'
  prefs: []
  type: TYPE_NORMAL
- en: '// ***** BenchmarkRunner: End *****'
  prefs: []
  type: TYPE_NORMAL
- en: // ** Remained 0 benchmark(s) to run **
  prefs: []
  type: TYPE_NORMAL
- en: 'Run time: 00:01:13 (73.35 sec), executed benchmarks: 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'Global total time: 00:01:29 (89.71 sec), executed benchmarks: 2'
  prefs: []
  type: TYPE_NORMAL
- en: // * Artifacts cleanup *
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00099.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Summary table that shows StringBuilder takes 69% of the time compared
    to string concatenation'
  prefs: []
  type: TYPE_NORMAL
- en: The `Outliers` section is especially interesting because it shows that not only
    is `string` concatenation slower than `StringBuilder` , but it is also more inconsistent
    in how long it takes. Your results will vary, of course.
  prefs: []
  type: TYPE_NORMAL
- en: You have now seen two ways to measure performance. Now let's see how we can
    run tasks asynchronously to potentially improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: Running tasks asynchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand how multiple tasks can be run simultaneously (at the same time),
    we will create a console application that needs to execute three methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'There will be three methods that need to be executed: the first takes 3 seconds,
    the second takes 2 seconds, and the third takes 1 second. To simulate that work,
    we can use the `Thread` class to tell the current thread to go to sleep for a
    specified number of milliseconds.'
  prefs: []
  type: TYPE_NORMAL
- en: Running multiple actions synchronously
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we make the tasks run simultaneously, we will run them synchronously,
    that is, one after the other.
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `WorkingWithTasks` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithTasks` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs` , import the namespace to work with a stopwatch (namespaces
    for working with threading and tasks are implicitly imported), and statically
    import `Console` , as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.Diagnostics; // Stopwatch
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.Console;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , create a method to output information about
    the current thread, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: OutputThreadInfo
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Thread t = Thread.CurrentThread;
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(
  prefs: []
  type: TYPE_NORMAL
- en: '"Thread Id: {0}, Priority: {1}, Background: {2}, Name: {3}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: t.ManagedThreadId, t.Priority,
  prefs: []
  type: TYPE_NORMAL
- en: t.IsBackground, t.Name ?? "null"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , add three methods that simulate work, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: MethodA
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Starting Method A..."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: OutputThreadInfo();
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Sleep(3000
  prefs: []
  type: TYPE_NORMAL
- en: ); // simulate three seconds of work
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Finished Method A."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: MethodB
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Starting Method B..."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: OutputThreadInfo();
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Sleep(2000
  prefs: []
  type: TYPE_NORMAL
- en: ); // simulate two seconds of work
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Finished Method B."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: MethodC
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Starting Method C..."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: OutputThreadInfo();
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Sleep(1000
  prefs: []
  type: TYPE_NORMAL
- en: ); // simulate one second of work
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Finished Method C."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs` , add statements to call the method to output information
    about the thread, define and start a stopwatch, call the three simulated work
    methods, and then output the milliseconds elapsed, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: OutputThreadInfo();
  prefs: []
  type: TYPE_NORMAL
- en: Stopwatch timer = Stopwatch.StartNew();
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Running methods synchronously on one thread."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: MethodA();
  prefs: []
  type: TYPE_NORMAL
- en: MethodB();
  prefs: []
  type: TYPE_NORMAL
- en: MethodC();
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{timer.ElapsedMilliseconds:#,##'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: ms elapsed."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, view the result, and note that when there is only one unnamed
    foreground thread doing the work, the total time required is just over 6 seconds,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread Id: 1, Priority: Normal, Background: False, Name: null'
  prefs: []
  type: TYPE_NORMAL
- en: Running methods synchronously on one thread.
  prefs: []
  type: TYPE_NORMAL
- en: Starting Method A...
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread Id: 1, Priority: Normal, Background: False, Name: null'
  prefs: []
  type: TYPE_NORMAL
- en: Finished Method A.
  prefs: []
  type: TYPE_NORMAL
- en: Starting Method B...
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread Id: 1, Priority: Normal, Background: False, Name: null'
  prefs: []
  type: TYPE_NORMAL
- en: Finished Method B.
  prefs: []
  type: TYPE_NORMAL
- en: Starting Method C...
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread Id: 1, Priority: Normal, Background: False, Name: null'
  prefs: []
  type: TYPE_NORMAL
- en: Finished Method C.
  prefs: []
  type: TYPE_NORMAL
- en: 6,017ms elapsed.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Running multiple actions asynchronously using tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Thread` class has been available since the first version of .NET and can
    be used to create new threads and manage them, but it can be tricky to work with
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Framework 4.0 introduced the `Task` class in 2010, which is a wrapper around
    a thread that enables easier creation and management. Managing multiple threads
    wrapped in tasks will allow our code to execute at the same time, aka asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Each `Task` has a `Status` property and a `CreationOptions` property. A `Task`
    has a `ContinueWith` method that can be customized with the `TaskContinuationOptions`
    enum, and can be managed with the `TaskFactory` class.
  prefs: []
  type: TYPE_NORMAL
- en: Starting tasks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will look at three ways to start the methods using `Task` instances. There
    are links in the GitHub repository to articles that discuss the pros and cons.
    Each has a slightly different syntax, but they all define a `Task` and start it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment out the calls to the three methods and their associated console message,
    and add statements to create and start three tasks, one for each method, as shown
    highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: OutputThreadInfo();
  prefs: []
  type: TYPE_NORMAL
- en: Stopwatch timer = Stopwatch.StartNew();
  prefs: []
  type: TYPE_NORMAL
- en: '**/***'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Running methods synchronously on one thread.");
  prefs: []
  type: TYPE_NORMAL
- en: MethodA();
  prefs: []
  type: TYPE_NORMAL
- en: MethodB();
  prefs: []
  type: TYPE_NORMAL
- en: MethodC();
  prefs: []
  type: TYPE_NORMAL
- en: '***/**'
  prefs: []
  type: TYPE_NORMAL
- en: '**WriteLine(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"Running methods asynchronously on multiple threads."**'
  prefs: []
  type: TYPE_NORMAL
- en: '**);**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Task taskA =**'
  prefs: []
  type: TYPE_NORMAL
- en: '**new**'
  prefs: []
  type: TYPE_NORMAL
- en: '**(MethodA);**'
  prefs: []
  type: TYPE_NORMAL
- en: '**taskA.Start();**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Task taskB = Task.Factory.StartNew(MethodB);**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Task taskC = Task.Run(MethodC);**'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{timer.ElapsedMilliseconds:#,##'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: ms elapsed."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, view the result, and note that the elapsed milliseconds appear
    almost immediately. This is because each of the three methods is now being executed
    by three new background worker threads allocated from the thread pool, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread Id: 1, Priority: Normal, Background: False, Name: null'
  prefs: []
  type: TYPE_NORMAL
- en: Running methods asynchronously on multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: Starting Method A...
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread Id: 4, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  prefs: []
  type: TYPE_NORMAL
- en: Starting Method C...
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread Id: 7, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  prefs: []
  type: TYPE_NORMAL
- en: Starting Method B...
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread Id: 6, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  prefs: []
  type: TYPE_NORMAL
- en: 6ms elapsed.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: It is even possible that the console app will end before one or more of the
    tasks have a chance to start and write to the console!
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to wait for a task to complete before continuing. To do
    this, you can use the `Wait` method on a `Task` instance, or the `WaitAll` or
    `WaitAny` static methods on an array of tasks, as described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `t.Wait()` | This waits for the task instance named `t` to complete execution.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Task.WaitAny(Task[])` | This waits for any of the tasks in the array to
    complete execution. |'
  prefs: []
  type: TYPE_TB
- en: '| `Task.WaitAll(Task[])` | This waits for all the tasks in the array to complete
    execution. |'
  prefs: []
  type: TYPE_TB
- en: Using wait methods with tasks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's see how we can use these wait methods to fix the problem with our console
    app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements after creating the three tasks and before
    outputting the elapsed time to combine references to the three tasks into an array
    and pass them to the `WaitAll` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Task[] tasks = { taskA, taskB, taskC };
  prefs: []
  type: TYPE_NORMAL
- en: Task.WaitAll(tasks);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, and note the original thread will pause on
    the call to `WaitAll` , waiting for all three tasks to finish before outputting
    the elapsed time, which is a little over 3 seconds, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Id: 1, Priority: Normal, Background: False, Name: null'
  prefs: []
  type: TYPE_NORMAL
- en: Running methods asynchronously on multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: Starting Method A...
  prefs: []
  type: TYPE_NORMAL
- en: 'Id: 6, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  prefs: []
  type: TYPE_NORMAL
- en: Starting Method B...
  prefs: []
  type: TYPE_NORMAL
- en: 'Id: 7, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  prefs: []
  type: TYPE_NORMAL
- en: Starting Method C...
  prefs: []
  type: TYPE_NORMAL
- en: 'Id: 4, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  prefs: []
  type: TYPE_NORMAL
- en: Finished Method C.
  prefs: []
  type: TYPE_NORMAL
- en: Finished Method B.
  prefs: []
  type: TYPE_NORMAL
- en: Finished Method A.
  prefs: []
  type: TYPE_NORMAL
- en: 3,013ms elapsed.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The three new threads execute their code simultaneously, and they can potentially
    start in any order. `MethodC` should finish first because it takes only 1 second,
    then `MethodB` , which takes 2 seconds, and finally `MethodA` , because it takes
    3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: However, the actual CPU used has a big effect on the results. It is the CPU
    that allocates time slices to each process to allow them to execute their threads.
    You have no control over when themethods run.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with another task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If all three tasks can be performed at the same time, then waiting for all tasks
    to finish will be all we need to do. However, often a task is dependent on the
    output from another task. To handle this scenario, we need to define **continuation
    tasks** .
  prefs: []
  type: TYPE_NORMAL
- en: We will create some methods to simulate a call to a web service that returns
    a monetary amount that then needs to be used to retrieve how many products cost
    more than that amount in a database. The result returned from the first method
    needs to be fed into the input of the second method. This time, instead of waiting
    for fixed amounts of time, we will use the `Random` class to wait for a random
    interval between 2 and 4 seconds for each method call to simulate the work.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , add two methods that simulate calling a web
    service and a database-stored procedure, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  prefs: []
  type: TYPE_NORMAL
- en: CallWebService
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Starting call to web service..."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: OutputThreadInfo();
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Sleep((new
  prefs: []
  type: TYPE_NORMAL
- en: Random()).Next(2000
  prefs: []
  type: TYPE_NORMAL
- en: ', 4000'
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Finished call to web service."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: '89.99'
  prefs: []
  type: TYPE_NORMAL
- en: M;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: CallStoredProcedure
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  prefs: []
  type: TYPE_NORMAL
- en: amount
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Starting call to stored procedure..."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: OutputThreadInfo();
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Sleep((new
  prefs: []
  type: TYPE_NORMAL
- en: Random()).Next(2000
  prefs: []
  type: TYPE_NORMAL
- en: ', 4000'
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Finished call to stored procedure."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: $"12 products cost more than
  prefs: []
  type: TYPE_NORMAL
- en: '{amount:C}'
  prefs: []
  type: TYPE_NORMAL
- en: ."
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Comment out the calls to the previous three tasks by wrapping them in multiline
    comment characters, `/* */` . Leave the statement that outputs the elapsed milliseconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements before the existing statement to output the total time, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Passing the result of one task as an input into another."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Task<string
  prefs: []
  type: TYPE_NORMAL
- en: taskServiceThenSProc = Task.Factory
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: .StartNew(CallWebService) // returns Task<decimal>
  prefs: []
  type: TYPE_NORMAL
- en: .ContinueWith(previousTask => // returns Task<string>
  prefs: []
  type: TYPE_NORMAL
- en: CallStoredProcedure(previousTask.Result));
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Result:'
  prefs: []
  type: TYPE_NORMAL
- en: '{taskServiceThenSProc.Result}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread Id: 1, Priority: Normal, Background: False, Name: null'
  prefs: []
  type: TYPE_NORMAL
- en: Passing the result of one task as an input into another.
  prefs: []
  type: TYPE_NORMAL
- en: Starting call to web service...
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread Id: 4, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  prefs: []
  type: TYPE_NORMAL
- en: Finished call to web service.
  prefs: []
  type: TYPE_NORMAL
- en: Starting call to stored procedure...
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread Id: 6, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  prefs: []
  type: TYPE_NORMAL
- en: Finished call to stored procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Result: 12 products cost more than 89.99.'
  prefs: []
  type: TYPE_NORMAL
- en: 5,463ms elapsed.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You might see different threads running the web service and stored procedure
    calls as in the output above (threads 4 and 6), or the same thread might be reused
    since it is no longer busy.
  prefs: []
  type: TYPE_NORMAL
- en: Nested and child tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As well as defining dependencies between tasks, you can define nested and child
    tasks. A **nested task** is a task that is created inside another task. A **child
    task** is a nested task that must finish before its parent task is allowed to
    finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore how these types of tasks work:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `NestedAndChildTasks` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `NestedAndChildTasks` as the active OmniSharp
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs` , delete the existing statements, statically import `Console`
    , and then add two methods, one of which starts a task to run the other, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: OuterMethod
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Outer method starting..."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Task innerTask = Task.Factory.StartNew(InnerMethod);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Outer method finished."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: InnerMethod
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Inner method starting..."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Sleep(2000
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Inner method finished."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Above the methods, add statements to start a task to run the outer method and
    wait for it to finish before stopping, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Task outerTask = Task.Factory.StartNew(OuterMethod);
  prefs: []
  type: TYPE_NORMAL
- en: outerTask.Wait();
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Console app is stopping."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Outer method starting...
  prefs: []
  type: TYPE_NORMAL
- en: Inner method starting...
  prefs: []
  type: TYPE_NORMAL
- en: Outer method finished.
  prefs: []
  type: TYPE_NORMAL
- en: Console app is stopping.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Note that, although we wait for the outer task to finish, its inner task does
    not have to finish as well. In fact, the outer task might finish, and the console
    app could end, before the inner task even starts!
  prefs: []
  type: TYPE_NORMAL
- en: To link these nested tasks as parent and child, we must use a special option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the existing code that defines the inner task to add a `TaskCreationOption`
    value of `AttachedToParent` , as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Task innerTask = Task.Factory.StartNew(InnerMethod,
  prefs: []
  type: TYPE_NORMAL
- en: '**TaskCreationOptions.AttachedToParent**'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, view the result, and note that the inner task must finish before
    the outer task can, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Outer method starting...
  prefs: []
  type: TYPE_NORMAL
- en: Inner method starting...
  prefs: []
  type: TYPE_NORMAL
- en: Outer method finished.
  prefs: []
  type: TYPE_NORMAL
- en: Inner method finished.
  prefs: []
  type: TYPE_NORMAL
- en: Console app is stopping.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The `OuterMethod` can finish before the `InnerMethod` , as shown by its writing
    to the console, butits task must wait, as shown by the console not stopping until
    both the outer and inner tasks finish.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping tasks around other objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes you might have a method that you want to be asynchronous, but the
    result to be returned is not itself a task. You can wrap the return value in a
    successfully completed task, return an exception, or indicate that the task was
    canceled by using one of the methods shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `FromResult<TResult>(TResult)` | Creates a `Task<TResult>` object whose `Result`
    property is the non-task result and whose `Status` property is `RanToCompletion`
    . |'
  prefs: []
  type: TYPE_TB
- en: '| `FromException<TResult>(Exception)` | Creates a `Task<TResult>` that''s completed
    with a specified exception. |'
  prefs: []
  type: TYPE_TB
- en: '| `FromCanceled<TResult>(CancellationToken)` | Creates a `Task<TResult>` that''s
    completed due to cancellation with a specified cancellation token. |'
  prefs: []
  type: TYPE_TB
- en: 'These methods are useful when you need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement an interface that has async methods, but your implementation is synchronous.
    This is common for websites and services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mock asynchronous implementations during unit testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Chapter 7* , *Packaging and Distributing .NET Types* , we created a class
    library with functions to check valid XML, passwords, and hex codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had wanted to make those methods conform to an interface that requires
    a `Task<T>` to be returned, we could use these helpful methods, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.Text.RegularExpressions;
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: StringExtensions
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: Task<
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: IsValidXmlTagAsync
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: this
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: input
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (input == null
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: Task.FromException<bool
  prefs: []
  type: TYPE_NORMAL
- en: '>('
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: ArgumentNullException("Missing input parameter"
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (input.Length == 0
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: Task.FromException<bool
  prefs: []
  type: TYPE_NORMAL
- en: '>('
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: ArgumentException("input parameter is empty."
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: Task.FromResult(Regex.IsMatch(input,
  prefs: []
  type: TYPE_NORMAL
- en: '@"^<([a-z]+)([^<]+)*(?:>(.*)<\/\1>|\s+\/>)$"'
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // other methods
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the method you need to implement returns a `Task` (equivalent to `void`
    in a synchronous method) then you can return a predefined completed `Task` object,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: Task
  prefs: []
  type: TYPE_NORMAL
- en: DeleteCustomerAsync
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // ...
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: Task.CompletedTask;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing access to shared resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have multiple threads executing at the same time, there is a possibility
    that two or more of the threads may access the same variable or another resource
    at the same time, and as a result, may cause a problem. For this reason, you should
    carefully consider how to make your code **thread-safe** .
  prefs: []
  type: TYPE_NORMAL
- en: The simplest mechanism for implementing thread safety is to use an object variable
    as a flag or traffic light to indicate when a shared resource has an exclusive
    lock applied.
  prefs: []
  type: TYPE_NORMAL
- en: In William Golding's *Lord of the Flies* , Piggy and Ralph spot a conch shell
    and use it to call a meeting. The boys impose a "rule of the conch" on themselves,
    deciding that no one can speak unless they're holding the conch.
  prefs: []
  type: TYPE_NORMAL
- en: I like to name the object variable I use for implementing thread-safe code the
    "conch." When a thread has the conch, no other thread should access the shared
    resource(s) represented by that conch. Note that I say, *should* . Only code that
    respects the conch enables synchronized access. Aconch is not a lock.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore a couple of types that can be used to synchronize access to
    shared resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Monitor` : An object that can be used by multiple threads to check if they
    should access a shared resource within the same process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Interlocked` : An object for manipulating simple numeric types at the CPU
    level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing a resource from multiple threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `SynchronizingResourceAccess` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `SynchronizingResourceAccess` as the active OmniSharp
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs` , delete the existing statements and then add statements to
    do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the namespace for diagnostic types like `Stopwatch` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statically import the `Console` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , create a static class with two fields:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A field to generate random wait times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `string` field to store a message (this is a shared resource).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Above the class, create two static methods that add a letter, A or B, to the
    shared `string` five times in a loop, and wait for a random interval of up to
    2 seconds for each iteration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: MethodA
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: for
  prefs: []
  type: TYPE_NORMAL
- en: (int
  prefs: []
  type: TYPE_NORMAL
- en: i = 0
  prefs: []
  type: TYPE_NORMAL
- en: ; i < 5
  prefs: []
  type: TYPE_NORMAL
- en: ; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Sleep(SharedObjects.Random.Next(2000
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: SharedObjects.Message += "A"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: Write("."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: MethodB
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: for
  prefs: []
  type: TYPE_NORMAL
- en: (int
  prefs: []
  type: TYPE_NORMAL
- en: i = 0
  prefs: []
  type: TYPE_NORMAL
- en: ; i < 5
  prefs: []
  type: TYPE_NORMAL
- en: ; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Sleep(SharedObjects.Random.Next(2000
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: SharedObjects.Message += "B"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: Write("."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: SharedObjects
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: Random Random = new
  prefs: []
  type: TYPE_NORMAL
- en: ();
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? Message; // a shared resource'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the namespace imports, write statements to execute both methods on separate
    threads using a pair of tasks and wait for them to complete before outputting
    the elapsed milliseconds, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Please wait for the tasks to complete."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Stopwatch watch = Stopwatch.StartNew();
  prefs: []
  type: TYPE_NORMAL
- en: Task a = Task.Factory.StartNew(MethodA);
  prefs: []
  type: TYPE_NORMAL
- en: Task b = Task.Factory.StartNew(MethodB);
  prefs: []
  type: TYPE_NORMAL
- en: Task.WaitAll(new
  prefs: []
  type: TYPE_NORMAL
- en: Task[] { a, b });
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Results:'
  prefs: []
  type: TYPE_NORMAL
- en: '{SharedObjects.Message}'
  prefs: []
  type: TYPE_NORMAL
- en: ."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{watch.ElapsedMilliseconds:N0}'
  prefs: []
  type: TYPE_NORMAL
- en: elapsed milliseconds."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Please wait for the tasks to complete.
  prefs: []
  type: TYPE_NORMAL
- en: '..........'
  prefs: []
  type: TYPE_NORMAL
- en: 'Results: BABABAABBA.'
  prefs: []
  type: TYPE_NORMAL
- en: 5,753 elapsed milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This shows that both threads were modifying the message concurrently. In an
    actual application, this could be a problem. But we can prevent concurrent access
    by applying a mutually exclusive lock to a conch object and code to the two methods
    to voluntarily check the conch before modifying the shared resource, which we
    will do in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a mutually exclusive lock to a conch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's use a conch to ensure that only one thread accesses the shared resource
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `SharedObjects` , declare and instantiate an `object` variable to act as
    a conch, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: object
  prefs: []
  type: TYPE_NORMAL
- en: Conch = new
  prefs: []
  type: TYPE_NORMAL
- en: ();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In both `MethodA` and `MethodB` , add a `lock` statement for the conch around
    the `for` statements, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '**lock**'
  prefs: []
  type: TYPE_NORMAL
- en: '**(SharedObjects.Conch)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: for
  prefs: []
  type: TYPE_NORMAL
- en: (int
  prefs: []
  type: TYPE_NORMAL
- en: i = 0
  prefs: []
  type: TYPE_NORMAL
- en: ; i < 5
  prefs: []
  type: TYPE_NORMAL
- en: ; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Sleep(SharedObjects.Random.Next(2000
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: SharedObjects.Message += "A"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: Write("."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Note that since checking the conch is voluntary, if you
    only use the `lock` statement in one of the two methods, the shared resource will
    continue to be accessed by both methods. Make sure that all methods that access
    a shared resource respect the conch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Please wait for the tasks to complete.
  prefs: []
  type: TYPE_NORMAL
- en: '..........'
  prefs: []
  type: TYPE_NORMAL
- en: 'Results: BBBBBAAAAA.'
  prefs: []
  type: TYPE_NORMAL
- en: 10,345 elapsed milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Although the time elapsed was longer, only one method at a time could access
    the shared resource. Either `MethodA` or `MethodB` can start first. Once a method
    has finished its work on theshared resource, then the conch gets released, and
    the other method has the chance to do itswork.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the lock statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might wonder what the `lock` statement does when it "locks" an object variable
    (hint: it does not lock the object!), as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: lock
  prefs: []
  type: TYPE_NORMAL
- en: (SharedObjects.Conch)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // work with shared resource
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The C# compiler changes the `lock` statement into a `try` -`finally` statement
    that uses the `Monitor` class to *enter* and *exit* the conch object (I like to
    think of it as *take* and *release* the conch object), as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: try
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Monitor.Enter(SharedObjects.Conch);
  prefs: []
  type: TYPE_NORMAL
- en: // work with shared resource
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: finally
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Monitor.Exit(SharedObjects.Conch);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: When a thread calls `Monitor.Enter` on any object, aka reference type, it checks
    to see if some other thread has already taken the conch. If it has, the thread
    waits. If it has not, the thread takes the conch and gets on with its work on
    the shared resource. Once the thread has finished its work, it calls `Monitor.Exit`
    , releasing the conch. If another thread was waiting, it can now take the conch
    and do its work. This requires all threads to respect the conch by calling `Monitor.Enter`
    and `Monitor.Exit` appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding deadlocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Knowing how the `lock` statement is translated by the compiler to method calls
    on the `Monitor` class is also important because using the `lock` statement can
    cause a deadlock.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deadlocks can occur when there are two or more shared resources (each with
    a conch to monitor which thread is currently doing work on each shared resource),
    and the following sequence of events happens:'
  prefs: []
  type: TYPE_NORMAL
- en: Thread X "locks" conch A and starts working on shared resource A.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread Y "locks" conch B and starts working on shared resource B.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While still working on resource A, thread X needs to also work with resource
    B, and so it attempts to "lock" conch B but is blocked because thread Y already
    has conch B.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While still working on resource B, thread Y needs to also work with resource
    A, and so it attempts to "lock" conch A but is blocked because thread X already
    has conch A.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One way to prevent deadlocks is to specify a timeout when attempting to get
    a lock. To do this, you must manually use the `Monitor` class instead of using
    the `lock` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your code to replace the `lock` statements with code that tries to enter
    the conch with a timeout and outputs an error and then exits the monitor, allowing
    other threads to enter the monitor, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '**try**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**if**'
  prefs: []
  type: TYPE_NORMAL
- en: '**(Monitor.TryEnter(SharedObjects.Conch, TimeSpan.FromSeconds(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**15**'
  prefs: []
  type: TYPE_NORMAL
- en: '**)))**'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: for
  prefs: []
  type: TYPE_NORMAL
- en: (int
  prefs: []
  type: TYPE_NORMAL
- en: i = 0
  prefs: []
  type: TYPE_NORMAL
- en: ; i < 5
  prefs: []
  type: TYPE_NORMAL
- en: ; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Sleep(SharedObjects.Random.Next(2000
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: SharedObjects.Message += "A"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: Write("."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**else**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**WriteLine(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"Method A timed out when entering a monitor on conch."**'
  prefs: []
  type: TYPE_NORMAL
- en: '**);**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**finally**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Monitor.Exit(SharedObjects.Conch);**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and view the result, which should return the same results as before
    (although either A or B could grab the conch first) but is better code because
    it will prevent potential deadlocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice** : Only use the `lock` keyword if you can write your code
    such that it avoids potential deadlocks. If you cannot avoid potential deadlocks,
    then always use the `Monitor.TryEnter` method instead of `lock` , in combination
    with a `try` -`finally` statement, so that you can supply a timeout and one of
    the threads will back out of a deadlock if it occurs. You can read more about
    good threading practices at the following link: [https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices](https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices)'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 6* , *Implementing Interfaces and Inheriting Classes* , you learned
    how to raise and handle events. But .NET events are not thread-safe, so you should
    avoid using them in multithreaded scenarios and follow the standard event raising
    code I showed you earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'After learning that .NET events are not thread-safe, some developers attempt
    to use exclusive locks when adding and removing event handlers or when raising
    an event, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // event delegate field
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: event
  prefs: []
  type: TYPE_NORMAL
- en: EventHandler Shout;
  prefs: []
  type: TYPE_NORMAL
- en: // conch
  prefs: []
  type: TYPE_NORMAL
- en: private
  prefs: []
  type: TYPE_NORMAL
- en: object
  prefs: []
  type: TYPE_NORMAL
- en: eventLock = new
  prefs: []
  type: TYPE_NORMAL
- en: ();
  prefs: []
  type: TYPE_NORMAL
- en: // method
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: Poke
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: lock
  prefs: []
  type: TYPE_NORMAL
- en: (eventLock) // bad idea
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // if something is listening...
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (Shout != null
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // ...then call the delegate to raise the event
  prefs: []
  type: TYPE_NORMAL
- en: Shout(this
  prefs: []
  type: TYPE_NORMAL
- en: ', EventArgs.Empty);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : You can read more about events and thread-safety at the
    following link: [https://docs.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful](https://docs.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful)'
  prefs: []
  type: TYPE_NORMAL
- en: 'But it is complicated, as explained by Stephen Cleary in the following blog
    post: [https://blog.stephencleary.com/2009/06/threadsafe-events.html](https://blog.stephencleary.com/2009/06/threadsafe-events.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Making CPU operations atomic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Atomic is from the Greek word **atomos** , which means *undividable* . It is
    important to understand which operations are atomic in multithreading because
    if they are not atomic, then they could be interrupted by another thread partway
    through their operation. Is the C# increment operator atomic, as shown in the
    following code?
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: x = 3
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: x++; // is this an atomic CPU operation?
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not atomic! Incrementing an integer requires the following three CPU
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Load a value from an instance variable into a register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment the value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the value in the instance variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A thread could be interrupted after executing the first two steps. A second
    thread could then execute all three steps. When the first thread resumes execution,
    it will overwrite the value in the variable, and the effect of the increment or
    decrement performed by the second thread will be lost!
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a type named `Interlocked` that can perform atomic actions on value
    types, such as integers and floats. Let''s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare another field in the `SharedObjects` class that will count how many
    operations have occurred, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: Counter; // another shared resource
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In both methods A and B, inside the `for` statement and after modifying the
    `string` value, add a statement to safely increment the counter, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Interlocked.Increment(ref
  prefs: []
  type: TYPE_NORMAL
- en: SharedObjects.Counter);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'After outputting the elapsed time, write the current value of the counter to
    the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{SharedObjects.Counter}'
  prefs: []
  type: TYPE_NORMAL
- en: string modifications."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown highlighted in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Please wait for the tasks to complete.
  prefs: []
  type: TYPE_NORMAL
- en: '..........'
  prefs: []
  type: TYPE_NORMAL
- en: 'Results: BBBBBAAAAA.'
  prefs: []
  type: TYPE_NORMAL
- en: 13,531 elapsed milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: '**10 string modifications.**'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Observant readers will realize that the existing conch object protects all shared
    resources accessed within a block of code locked by the conch, and therefore it
    is actually unnecessary to use `Interlocked` in this specific example. But if
    we had not already been protecting another shared resource like `Message` then
    using `Interlocked` would be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Applying other types of synchronization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Monitor` and `Interlocked` are mutually exclusive locks that are simple and
    effective, but sometimes, you need more advanced options to synchronize access
    to shared resources, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `ReaderWriterLock` and `ReaderWriterLockSlim` | These allow multiple threads
    to be in **read mode** , one thread to be in **write mode** with exclusive ownership
    of the write lock, and one thread that has read access to be in **upgradeable
    read mode** , from which the thread can upgrade to write mode without having to
    relinquish its read access to the resource. |'
  prefs: []
  type: TYPE_TB
- en: '| `Mutex` | Like `Monitor` , this provides exclusive access to a shared resource,
    except it is used for inter-process synchronization. |'
  prefs: []
  type: TYPE_TB
- en: '| `Semaphore` and `SemaphoreSlim` | These limit the number of threads that
    can access a resource or pool of resources concurrently by defining slots. This
    is known as resource throttling rather than resource locking. |'
  prefs: []
  type: TYPE_TB
- en: '| `AutoResetEvent` and `ManualResetEvent` | Event wait handles allow threads
    to synchronize activities by signaling each other and by waiting for each other''s
    signals. |'
  prefs: []
  type: TYPE_TB
- en: Understanding async and await
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C# 5 introduced two C# keywords when working with the `Task` type. They are
    especially useful for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing multitasking for a **graphical user interface** (**GUI** ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the scalability of web applications and web services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Chapter 15* , *Building Websites Using the Model-View-Controller Pattern*
    , we will see how the `async` and `await` keywords can improve scalability for
    websites.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 19* , *Building Mobile and Desktop Apps Using .NET MAUI* , we will
    see how the `async` and `await` keywords can implement multitasking for a GUI.
    You can find it at [https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf](https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf)
    .
  prefs: []
  type: TYPE_NORMAL
- en: But for now, let's learn the theory of why these two C# keywords were introduced,
    and then later you will see them used in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Improving responsiveness for console apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the limitations with console applications is that you can only use the
    `await` keyword inside methods that are marked as `async` but C# 7 and earlier
    do not allow the `Main` method to be marked as async! Luckily, a new feature introduced
    in C# 7.1 was support for `async` in `Main` :'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `AsyncConsole` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `AsyncConsole` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs` , delete the existing statements and statically import `Console`
    , as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.Console;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to create an `HttpClient` instance, make a request for Apple''s
    home page, and output how many bytes it has, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: HttpClient client = new
  prefs: []
  type: TYPE_NORMAL
- en: ();
  prefs: []
  type: TYPE_NORMAL
- en: HttpResponseMessage response =
  prefs: []
  type: TYPE_NORMAL
- en: await
  prefs: []
  type: TYPE_NORMAL
- en: client.GetAsync("http://www.apple.com/"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Apple's home page has {0:N0} bytes."
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: response.Content.Headers.ContentLength);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the project and note that it builds successfully. In .NET 5 and earlier,
    you would have seen an error message, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Program.cs(14,9): error CS4033: The ''await'' operator can only be used within
    an async method. Consider marking this method with the ''async'' modifier and
    changing its return type to ''Task''. [/Users/markjprice/Code/ Chapter12/AsyncConsole/AsyncConsole.csproj]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You would have had to add the `async` keyword to the `Main` method and change
    its return type to `Task` . With .NET 6 and later, the console app project template
    uses the top-level program feature to automatically define the `Program` class
    with an asynchronous `Main` method for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, which is likely to have a different number
    of bytes since Apple changes its home page frequently, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Apple's home page has 40,252 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Improving responsiveness for GUI apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far in this book, we have only built console applications. Life for a programmer
    gets more complicated when building web applications, web services, and apps with
    GUIs such as Windows desktop and mobile apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'One reason for this is that for a GUI app, there is a special thread: the **user
    interface** (**UI** ) thread.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two rules for working in GUIs:'
  prefs: []
  type: TYPE_NORMAL
- en: Do not perform long-running tasks on the UI thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not access UI elements on any thread except the UI thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To handle these rules, programmers used to have to write complex code to ensure
    that long- running tasks were executed by a non-UI thread, but once complete,
    the results of the task weresafely passed to the UI thread to present to the
    user. It could quickly get messy!
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, with C# 5 and later, you have the use of `async` and `await` . They
    allow you to continue to write your code as if it is synchronous, which keeps
    your code clean and easy to understand, but underneath, the C# compiler creates
    a complex state machine and keeps track of running threads. It's kind of magical!
  prefs: []
  type: TYPE_NORMAL
- en: Let's see an example. We will build a Windows desktop app using WPF that gets
    employees from the Northwind database in an SQL Server database using low-level
    types like `SqlConnection` , `SqlCommand` , and `SqlDataReader` . You will only
    be able to complete this task if you have Windows and the Northwind database stored
    in SQL Server. This is the only section in this book that is not cross-platform
    and modern (WPF is 16 years old!).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are focusing on making a GUI app responsive. You will learn
    about XAML and building cross-platform GUI apps in *Chapter 19* , *Building Mobile
    and Desktop Apps Using .NET MAUI* (available at [https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf](https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf)
    ). Since this book does not cover WPF elsewhere, I thought this task would be
    a good opportunity to at least see an example app built using WPF even if we do
    not look at it in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio 2022 for Windows, add a new **WPF Application
    [C#]** project named `WpfResponsive` to the `Chapter12` solution. If you are using
    Visual Studio Code, use the following command: `dotnet new wpf` .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the project file, note the output type is a Windows EXE, the target framework
    is .NET 6 for Windows (it will not run on other platforms like macOS and Linux),
    and the project uses WPF.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a package reference for `Microsoft.Data.SqlClient` to the project, as shown
    highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <Project Sdk="Microsoft.NET.Sdk"
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: <PropertyGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <OutputType>WinExe</OutputType>
  prefs: []
  type: TYPE_NORMAL
- en: <TargetFramework>net6.0
  prefs: []
  type: TYPE_NORMAL
- en: -windows</TargetFramework>
  prefs: []
  type: TYPE_NORMAL
- en: <Nullable>enable</Nullable>
  prefs: []
  type: TYPE_NORMAL
- en: <UseWPF>true
  prefs: []
  type: TYPE_NORMAL
- en: </UseWPF>
  prefs: []
  type: TYPE_NORMAL
- en: </PropertyGroup>
  prefs: []
  type: TYPE_NORMAL
- en: '**<ItemGroup>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**<PackageReference Include=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"Microsoft.Data.SqlClient"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Version=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"3.0.0"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**/>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**</ItemGroup>**'
  prefs: []
  type: TYPE_NORMAL
- en: </Project>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Build the project to restore packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `MainWindow.xaml` , in the `<Grid>` element, add elements to define two
    buttons, a text box and a list box, laid out vertically in a stack panel, as shown
    highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <
  prefs: []
  type: TYPE_NORMAL
- en: Grid
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '**<**'
  prefs: []
  type: TYPE_NORMAL
- en: '**StackPanel**'
  prefs: []
  type: TYPE_NORMAL
- en: '**>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**<**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Button**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**'
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"GetEmployeesSyncButton"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Click**'
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"GetEmployeesSyncButton_Click"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Get Employees Synchronously**'
  prefs: []
  type: TYPE_NORMAL
- en: '**</**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Button**'
  prefs: []
  type: TYPE_NORMAL
- en: '**>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**<**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Button**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**'
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"GetEmployeesAsyncButton"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Click**'
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"GetEmployeesAsyncButton_Click"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Get Employees Asynchronously**'
  prefs: []
  type: TYPE_NORMAL
- en: '**</**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Button**'
  prefs: []
  type: TYPE_NORMAL
- en: '**>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**<**'
  prefs: []
  type: TYPE_NORMAL
- en: '**TextBox**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HorizontalAlignment**'
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"Stretch"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Text**'
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"Type in here"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**/>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**<**'
  prefs: []
  type: TYPE_NORMAL
- en: '**ListBox**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**'
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"EmployeesListBox"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Height**'
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"400"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**/>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**</**'
  prefs: []
  type: TYPE_NORMAL
- en: '**StackPanel**'
  prefs: []
  type: TYPE_NORMAL
- en: '**>**'
  prefs: []
  type: TYPE_NORMAL
- en: </
  prefs: []
  type: TYPE_NORMAL
- en: Grid
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 for Windows has good support for building WPF apps and will
    provide IntelliSense as you edit code and XAML markup. Visual Studio Code does
    not.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MainWindow.xaml.cs` , in the `MainWindow` class, import the `System.Diagnostics`
    and `Microsoft.Data.SqlClient` namespaces, then create two `string` constants
    for the database connection string and SQL statement and create event handlers
    for clicking on the two buttons that use those `string` constants to open a connection
    to the Northwind database and populate the list box with the ids and names of
    all employees, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: private
  prefs: []
  type: TYPE_NORMAL
- en: const
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: connectionString =
  prefs: []
  type: TYPE_NORMAL
- en: '"Data Source=.;"'
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: '"Initial Catalog=Northwind;"'
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: '"Integrated Security=true;"'
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: '"MultipleActiveResultSets=true;"'
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: private
  prefs: []
  type: TYPE_NORMAL
- en: const
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: sql =
  prefs: []
  type: TYPE_NORMAL
- en: '"WAITFOR DELAY ''00:00:05'';"'
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: '"SELECT EmployeeId, FirstName, LastName FROM Employees"'
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: private
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: GetEmployeesSyncButton_Click
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: object
  prefs: []
  type: TYPE_NORMAL
- en: sender, RoutedEventArgs e
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Stopwatch timer = Stopwatch.StartNew();
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (SqlConnection connection = new
  prefs: []
  type: TYPE_NORMAL
- en: (connectionString))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: connection.Open();
  prefs: []
  type: TYPE_NORMAL
- en: SqlCommand command = new
  prefs: []
  type: TYPE_NORMAL
- en: (sql, connection);
  prefs: []
  type: TYPE_NORMAL
- en: SqlDataReader reader = command.ExecuteReader();
  prefs: []
  type: TYPE_NORMAL
- en: while
  prefs: []
  type: TYPE_NORMAL
- en: (reader.Read())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: employee = string
  prefs: []
  type: TYPE_NORMAL
- en: '.Format("{0}: {1} {2}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: reader.GetInt32(0
  prefs: []
  type: TYPE_NORMAL
- en: ), reader.GetString(1
  prefs: []
  type: TYPE_NORMAL
- en: ), reader.GetString(2
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: EmployeesListBox.Items.Add(employee);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: reader.Close();
  prefs: []
  type: TYPE_NORMAL
- en: connection.Close();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'EmployeesListBox.Items.Add($"Sync:'
  prefs: []
  type: TYPE_NORMAL
- en: '{timer.ElapsedMilliseconds:N0}'
  prefs: []
  type: TYPE_NORMAL
- en: ms"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: private
  prefs: []
  type: TYPE_NORMAL
- en: async
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: GetEmployeesAsyncButton_Click
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: object
  prefs: []
  type: TYPE_NORMAL
- en: sender, RoutedEventArgs e
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Stopwatch timer = Stopwatch.StartNew();
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (SqlConnection connection = new
  prefs: []
  type: TYPE_NORMAL
- en: (connectionString))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: await
  prefs: []
  type: TYPE_NORMAL
- en: connection.OpenAsync();
  prefs: []
  type: TYPE_NORMAL
- en: SqlCommand command = new
  prefs: []
  type: TYPE_NORMAL
- en: (sql, connection);
  prefs: []
  type: TYPE_NORMAL
- en: SqlDataReader reader = await
  prefs: []
  type: TYPE_NORMAL
- en: command.ExecuteReaderAsync();
  prefs: []
  type: TYPE_NORMAL
- en: while
  prefs: []
  type: TYPE_NORMAL
- en: (await
  prefs: []
  type: TYPE_NORMAL
- en: reader.ReadAsync())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: employee = string
  prefs: []
  type: TYPE_NORMAL
- en: '.Format("{0}: {1} {2}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: await
  prefs: []
  type: TYPE_NORMAL
- en: reader.GetFieldValueAsync<int
  prefs: []
  type: TYPE_NORMAL
- en: '>(0'
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: await
  prefs: []
  type: TYPE_NORMAL
- en: reader.GetFieldValueAsync<string
  prefs: []
  type: TYPE_NORMAL
- en: '>(1'
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: await
  prefs: []
  type: TYPE_NORMAL
- en: reader.GetFieldValueAsync<string
  prefs: []
  type: TYPE_NORMAL
- en: '>(2'
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: EmployeesListBox.Items.Add(employee);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: await
  prefs: []
  type: TYPE_NORMAL
- en: reader.CloseAsync();
  prefs: []
  type: TYPE_NORMAL
- en: await
  prefs: []
  type: TYPE_NORMAL
- en: connection.CloseAsync();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'EmployeesListBox.Items.Add($"Async:'
  prefs: []
  type: TYPE_NORMAL
- en: '{timer.ElapsedMilliseconds:N0}'
  prefs: []
  type: TYPE_NORMAL
- en: ms"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The SQL statement uses the SQL Server command `WAITFOR DELAY` to simulate processing
    that takes five seconds. It then selects three columns from the `Employees` table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GetEmployeesSyncButton_Click` event handler uses synchronous methods to
    open a connection and fetch the employee rows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GetEmployeesAsyncButton_Click` event handler is marked as `async` and uses
    asynchronous methods with the `await` keyword to open a connection and fetch the
    employee rows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both event handlers use a stopwatch to record the number of milliseconds the
    operation takes and add it to the list box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start the WPF app without debugging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click in the text box, enter some text, and note the GUI is responsive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Get Employees Synchronously** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to click in the text box, and note the GUI is not responsive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for at least five seconds until the list box is filled with employees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click in the text box, enter some text, and note the GUI is responsive again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Get Employees Asynchronously** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click in the text box, enter some text, and note the GUI is still responsive
    while it performs the operation. Continue typing until the list box is filled
    with the employees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note the difference in timings for the two operations. The UI is blocked when
    fetching data synchronously, while the UI remains responsive when fetching data
    asynchronously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the WPF app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Improving scalability for web applications and web services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `async` and `await` keywords can also be applied on the server side when
    building websites, applications, and services. From the client application's point
    of view, nothing changes (or they might even notice a small increase in the time
    taken for a request to return). So, from a single client's point of view, the
    use of `async` and `await` to implement multitasking on the server side makes
    their experience worse!
  prefs: []
  type: TYPE_NORMAL
- en: On the server side, additional, cheaper worker threads are created to wait for
    long-running tasks to finish so that expensive I/O threads can handle other client
    requests instead of being blocked. This improves the overall scalability of a
    web application or service. More clients can be supported simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Common types that support multitasking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many common types that have asynchronous methods that you can await,
    as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Methods |'
  prefs: []
  type: TYPE_TB
- en: '| `DbContext<T>` | `AddAsync` , `AddRangeAsync` , `FindAsync` , and `SaveChangesAsync`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DbSet<T>` | `AddAsync` , `AddRangeAsync` , `ForEachAsync` , `SumAsync` ,
    `ToListAsync` , `ToDictionaryAsync` , `AverageAsync` , and `CountAsync` |'
  prefs: []
  type: TYPE_TB
- en: '| `HttpClient` | `GetAsync` , `PostAsync` , `PutAsync` , `DeleteAsync` , and
    `SendAsync` |'
  prefs: []
  type: TYPE_TB
- en: '| `StreamReader` | `ReadAsync` , `ReadLineAsync` , and `ReadToEndAsync` |'
  prefs: []
  type: TYPE_TB
- en: '| `StreamWriter` | `WriteAsync` , `WriteLineAsync` , and `FlushAsync` |'
  prefs: []
  type: TYPE_TB
- en: '**Good Practice** : Any time you see a method that ends in the suffix `Async`
    , check to see whether it returns `Task` or `Task<T>` . If it does, then you could
    use it instead of the synchronous non-`Async` suffixed method. Remember to call
    it using `await` and decorate your method with `async` .'
  prefs: []
  type: TYPE_NORMAL
- en: Using await in catch blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When `async` and `await` were first introduced in C# 5, it was only possible
    to use the `await` keyword in a `try` block, but not in a `catch` block. In C#
    6 and later, it is now possible to use `await` in both `try` and `catch` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Working with async streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With .NET Core 3.0, Microsoft introduced the asynchronous processing of streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can complete a tutorial about async streams at the following link: [https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream](https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream)'
  prefs: []
  type: TYPE_NORMAL
- en: Before C# 8.0 and .NET Core 3.0, the `await` keyword only worked with tasks
    that return scalar values. Async stream support in .NET Standard 2.1 allows an
    `async` method to return a sequence of values.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see a simulated example that returns three random integers as an async
    stream.
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `AsyncEnumerable` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `AsyncEnumerable` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs` , delete the existing statements and statically import `Console`
    , as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.Console; // WriteLine()
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , create a method that uses the `yield` keyword
    to return a random sequence of three numbers asynchronously, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: async
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: IAsyncEnumerable<
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: GetNumbersAsync
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Random r = new
  prefs: []
  type: TYPE_NORMAL
- en: ();
  prefs: []
  type: TYPE_NORMAL
- en: // simulate work
  prefs: []
  type: TYPE_NORMAL
- en: await
  prefs: []
  type: TYPE_NORMAL
- en: Task.Delay(r.Next(1500
  prefs: []
  type: TYPE_NORMAL
- en: ', 3000'
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: yield
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: r.Next(0
  prefs: []
  type: TYPE_NORMAL
- en: ', 1001'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: await
  prefs: []
  type: TYPE_NORMAL
- en: Task.Delay(r.Next(1500
  prefs: []
  type: TYPE_NORMAL
- en: ', 3000'
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: yield
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: r.Next(0
  prefs: []
  type: TYPE_NORMAL
- en: ', 1001'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: await
  prefs: []
  type: TYPE_NORMAL
- en: Task.Delay(r.Next(1500
  prefs: []
  type: TYPE_NORMAL
- en: ', 3000'
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: yield
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: r.Next(0
  prefs: []
  type: TYPE_NORMAL
- en: ', 1001'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Above `GetNumbersAsync` , add statements to enumerate the sequence of numbers,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: await
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (int
  prefs: []
  type: TYPE_NORMAL
- en: number
  prefs: []
  type: TYPE_NORMAL
- en: in
  prefs: []
  type: TYPE_NORMAL
- en: GetNumbersAsync
  prefs: []
  type: TYPE_NORMAL
- en: ())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Number:'
  prefs: []
  type: TYPE_NORMAL
- en: '{number}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number: 509'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number: 813'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number: 307'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore this chapter's topics with deeper research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.1  Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What information can you find out about a process?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How accurate is the `Stopwatch` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By convention, what suffix should be applied to a method that returns `Task`
    or `Task<T>` ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To use the `await` keyword inside a method, what keyword must be applied to
    the method declaration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you create a child task?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you avoid the `lock` keyword?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use the `Interlocked` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use the `Mutex` class instead of the `Monitor` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of using `async` and `await` in a website or web service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you cancel a task? If so, how?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 12.2  Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following webpage to learn more detail about the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-12---improving-performance-and-scalability-using-multitasking](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-12---improving-performance-and-scalability-using-multitasking)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned not only how to define and start a task but also
    how to wait for one or more tasks to finish and how to control task completion
    order. You've also learned how to synchronize access to shared resources and the
    magic behind `async` and `await` .
  prefs: []
  type: TYPE_NORMAL
- en: In the seven chapters that follow, you will learn how to create applications
    for the **app models** , aka **workloads** supported by .NET, such as websites
    and services, and cross-platform desktop and mobile apps.
  prefs: []
  type: TYPE_NORMAL

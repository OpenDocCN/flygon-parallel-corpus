- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Improving Performance and Scalability Using Multitasking
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多任务处理改进性能和可伸缩性
- en: This chapter is about allowing multiple actions to occur at the same time to
    improve performance, scalability, and user productivity for the applications that
    you build.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于允许多个操作同时发生，以改进您构建的应用程序的性能、可伸缩性和用户生产力。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding processes, threads, and tasks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解进程、线程和任务
- en: Monitoring performance and resource usage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视性能和资源使用
- en: Running tasks asynchronously
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步运行任务
- en: Synchronizing access to shared resources
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步访问共享资源
- en: Understanding `async` and `await`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解`async`和`await`
- en: Understanding processes, threads, and tasks
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解进程、线程和任务
- en: A **process** , with one example being each of the console applications we have
    created, has resources like memory and threads allocated to it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程，例如我们创建的每个控制台应用程序，都分配了内存和线程等资源。
- en: A **thread** executes your code, statement by statement. By default, each process
    only has one thread, and this can cause problems when we need to do more than
    one task at the same time. Threads are also responsible for keeping track of things
    like the currently authenticated user and any internationalization rules that
    should be followed for the current language and region.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 线程逐条执行您的代码。默认情况下，每个进程只有一个线程，当我们需要同时执行多个任务时，这可能会导致问题。线程还负责跟踪当前经过身份验证的用户以及应遵循的当前语言和地区的任何国际化规则。
- en: Windows and most other modern operating systems use **preemptive multitasking**
    , which simulates the parallel execution of tasks. It divides the processor time
    among the threads, allocating a **time slice** to each thread one after another.
    The current thread is suspended when its time slice finishes. The processor then
    allows another thread to run for a time slice.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Windows和大多数其他现代操作系统使用抢占式多任务处理，模拟任务的并行执行。它将处理器时间分配给线程，依次为每个线程分配一个时间片。当前线程的时间片结束时，该线程被挂起。然后处理器允许另一个线程运行一段时间。
- en: When Windows switches from one thread to another, it saves the context of the
    thread and reloads the previously saved context of the next thread in the thread
    queue. This takes both time and resources to complete.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当Windows从一个线程切换到另一个线程时，它会保存线程的上下文，并重新加载线程队列中下一个线程的先前保存的上下文。这需要时间和资源来完成。
- en: As a developer, if you have a small number of complex pieces of work and you
    want complete control over them, then you could create and manage individual `Thread`
    instances. If you have one main thread and multiple small pieces of work that
    can be executed in the background, then you can use the `ThreadPool` class to
    add delegate instances that point to those pieces of work implemented as methods
    to a queue, and they will be automatically allocated to threads in the thread
    pool.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，如果您有少量复杂的工作，并且希望完全控制它们，那么您可以创建和管理单独的`Thread`实例。如果您有一个主线程和多个可以在后台执行的小任务，那么您可以使用`ThreadPool`类将指向作为方法实现的这些小任务的委托实例添加到队列中，它们将自动分配给线程池中的线程。
- en: In this chapter, we will use the `Task` type to manage threads at a higher abstraction
    level.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用`Task`类型以更高的抽象级别管理线程。
- en: Threads may have to compete for and also wait for access to shared resources,
    such as variables, files, and database objects. There are types for managing this
    that you will see in action later in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可能必须竞争并等待访问共享资源，例如变量、文件和数据库对象。有一些类型可以管理这一点，您将在本章后面看到它们的作用。
- en: Depending on the task, doubling the number of threads (workers) to perform a
    task does not halve the number of seconds that it will take to complete that task.
    In fact, it can increase the duration of the task.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据任务的不同，将线程（工作者）数量加倍以执行任务并不会减少完成该任务所需的秒数。事实上，这可能会增加任务的持续时间。
- en: '**Good Practice** : Never assume that more threads will improve performance!
    Run performance tests on a baseline code implementation without multiple threads,
    and then again on a code implementation with multiple threads. You should also
    perform performance tests in a staging environment that is as close as possible
    to the production environment.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 良好实践：永远不要假设更多的线程会提高性能！在没有多个线程的基线代码实现上运行性能测试，然后再在具有多个线程的代码实现上运行性能测试。您还应该在尽可能接近生产环境的暂存环境中进行性能测试。
- en: Monitoring performance and resource usage
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视性能和资源使用
- en: Before we can improve the performance of any code, we need to be able to monitor
    its speed and efficiency to record a baseline that we can then measure improvements
    against.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在改进任何代码的性能之前，我们需要能够监视其速度和效率，以记录我们可以根据其进行改进的基线。
- en: Evaluating the efficiency of types
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估类型的效率
- en: 'What is the best type to use for a scenario? To answer this question, we need
    to carefully consider what we mean by "best", and through this, we should consider
    the following factors:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定情景，使用哪种类型最好？要回答这个问题，我们需要仔细考虑“最好”的含义，并通过这一点，我们应该考虑以下因素：
- en: '**Functionality** : This can be decided by checking whether the type provides
    the features you need.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能：这可以通过检查类型是否提供所需的功能来决定。
- en: '**Memory size** : This can be decided by the number of bytes of memory the
    type takes up.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存大小：这可以通过类型占用的内存字节数来决定。
- en: '**Performance** : This can be decided by how fast the type is.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能：这可以通过类型的速度来决定。
- en: '**Future needs** : This depends on the changes in requirements and maintainability.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来需求：这取决于需求变化和可维护性。
- en: There will be scenarios, such as when storing numbers, where multiple types
    have the same functionality, so we will need to consider memory and performance
    to make a choice.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储数字等多种类型具有相同功能的情况下，我们需要考虑内存和性能来做出选择。
- en: If we need to store millions of numbers, then the best type to use would be
    the one that requires the fewest bytes of memory. But if we only need to store
    a few numbers, yet we need to perform lots of calculations on them, then the best
    type to use would be the one that runs fastest on a specific CPU.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要存储数百万个数字，那么最好使用需要最少字节内存的类型。但如果我们只需要存储少量数字，但需要对它们进行大量计算，那么最好使用在特定 CPU 上运行最快的类型。
- en: You have seen the use of the `sizeof()` function, which shows the number of
    bytes a single instance of a type uses in memory. When we are storing a large
    number of values in more complex data structures, such as arrays and lists, then
    we need a better way of measuring memory usage.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了 `sizeof()` 函数的使用，它显示了类型的单个实例在内存中使用的字节数。当我们在更复杂的数据结构中存储大量值时，例如数组和列表，那么我们需要更好的方法来测量内存使用情况。
- en: You can read lots of advice online and in books, but the only way to know for
    sure what the best type would be for your code is to compare the types yourself.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在网上和书籍中阅读很多建议，但要确定最适合您的代码的最佳类型的唯一方法是自己比较这些类型。
- en: In the next section, you will learn how to write code to monitor the actual
    memory requirements and performance when using different types.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何编写代码来监视使用不同类型时的实际内存需求和性能。
- en: Today a `short` variable might be the best choice, but it might be an even better
    choice to use an `int` variable, even though it takes twice as much space in the
    memory. This is because we might need a wider range of values to be stored in
    the future.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，`short` 变量可能是最佳选择，但使用 `int` 变量可能是更好的选择，即使它在内存中占用的空间是 `short` 的两倍。这是因为我们可能需要将来存储更广泛范围的值。
- en: 'There is an important metric that developers often forget: maintenance. This
    is a measure of how much effort another programmer would have to put in to understand
    and modify your code. If you make a nonobvious choice of type without explaining
    that choice with a helpful comment, then it might confuse the programmer who comes
    along later and needs to fix a bug or add a feature.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的开发者经常忽视的指标：维护。这是另一个程序员需要付出多少努力来理解和修改您的代码的度量。如果您选择了一个不明显的类型而没有用有帮助的注释来解释这个选择，那么可能会让后来的程序员困惑，他们需要修复错误或添加功能。
- en: Monitoring performance and memory using diagnostics
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用诊断监视性能和内存
- en: 'The `System.Diagnostics` namespace has lots of useful types for monitoring
    your code. The first useful type that we will look at is the `Stopwatch` type:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Diagnostics` 命名空间有很多有用的类型来监视您的代码。我们将首先看一下有用的 `Stopwatch` 类型：'
- en: Use your preferred coding tool to create a new workspace/solution named `Chapter12`
    .
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的编码工具创建一个名为 `Chapter12` 的新工作空间/解决方案。
- en: 'Add a class library project, as defined in the following list:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个类库项目，如下列表所定义：
- en: 'Project template: **Class Library** / `classlib`'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**类库** / `classlib`
- en: 'Workspace/solution file and folder: `Chapter12`'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作空间/解决方案文件和文件夹：`Chapter12`
- en: 'Project file and folder: `MonitoringLib`'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`MonitoringLib`
- en: 'Add a console app project, as defined in the following list:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个控制台应用程序项目，如下列表所定义：
- en: 'Project template: **Console Application** / `console`'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Workspace/solution file and folder: `Chapter12`'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作空间/解决方案文件和文件夹：`Chapter12`
- en: 'Project file and folder: `MonitoringApp`'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`MonitoringApp`
- en: In Visual Studio, set the startup project for the solution to the current selection.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，将解决方案的启动项目设置为当前选择。
- en: In Visual Studio Code, select `MonitoringApp` as the active OmniSharp project.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中，选择 `MonitoringApp` 作为活动的 OmniSharp 项目。
- en: In the `MonitoringLib` project, rename the `Class1.cs` file to `Recorder.cs`
    .
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MonitoringLib` 项目中，将 `Class1.cs` 文件重命名为 `Recorder.cs` 。
- en: 'In the `MonitoringApp` project, add a project reference to the `MonitoringLib`
    class library, as shown in the following markup:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MonitoringApp` 项目中，添加对 `MonitoringLib` 类库的项目引用，如下标记所示：
- en: '```cs'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: <ItemGroup>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <ItemGroup>
- en: <ProjectReference
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <ProjectReference
- en: Include="..\MonitoringLib\MonitoringLib.csproj"
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Include="..\MonitoringLib\MonitoringLib.csproj"
- en: />
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: />
- en: </ItemGroup>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: </ItemGroup>
- en: '```'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Build the `MonitoringApp` project.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 `MonitoringApp` 项目。
- en: Useful members of the Stopwatch and Process types
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Stopwatch` 和 `Process` 类型的有用成员'
- en: 'The `Stopwatch` type has some useful members, as shown in the following table:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stopwatch` 类型有一些有用的成员，如下表所示：'
- en: '| Member | Description |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 成员 | 描述 |'
- en: '| `Restart` method | This resets the elapsed time to zero and then starts the
    timer. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `Restart` 方法 | 这将重置经过的时间为零，然后启动计时器。 |'
- en: '| `Stop` method | This stops the timer. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `Stop` 方法 | 这将停止计时器。 |'
- en: '| `Elapsed` property | This is the elapsed time stored as a `TimeSpan` format
    (for example, hours:minutes:seconds) |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `Elapsed` 属性 | 这是以 `TimeSpan` 格式（例如，小时：分钟：秒）存储的经过时间。 |'
- en: '| `ElapsedMilliseconds` property | This is the elapsed time in milliseconds
    stored as an `Int64` value. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `ElapsedMilliseconds` 属性 | 这是以 `Int64` 值存储的毫秒为单位的经过时间。 |'
- en: 'The `Process` type has some useful members, as shown in the following table:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Process` 类型有一些有用的成员，如下表所示：'
- en: '| Member | Description |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 成员 | 描述 |'
- en: '| `VirtualMemorySize64` | This displays the amount of virtual memory, in bytes,
    allocated for the process. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `VirtualMemorySize64` | 这显示为进程分配的虚拟内存量（以字节为单位）。 |'
- en: '| `WorkingSet64` | This displays the amount of physical memory, in bytes, allocated
    for the process. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `WorkingSet64` | 这显示为进程分配的物理内存量（以字节为单位）。 |'
- en: Implementing a Recorder class
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现一个 Recorder 类
- en: 'We will create a `Recorder` class that makes it easy to monitor time and memory
    resource usage. To implement our `Recorder` class, we will use the `Stopwatch`
    and `Process` classes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 `Recorder` 类，使得监视时间和内存资源使用变得容易。为了实现我们的 `Recorder` 类，我们将使用 `Stopwatch`
    和 `Process` 类：
- en: 'In `Recorder.cs` , change its contents to use a `Stopwatch` instance to record
    timings and the current `Process` instance to record memory usage, as shown in
    the following code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Recorder.cs` 中，更改其内容以使用 `Stopwatch` 实例记录时间和当前 `Process` 实例记录内存使用情况，如下面的代码所示：
- en: '```cs'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: System.Diagnostics; // Stopwatch
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: System.Diagnostics; // Stopwatch
- en: using
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: static
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: System.Console;
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: System.Console;
- en: using
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: static
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: System.Diagnostics.Process; // GetCurrentProcess()
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: System.Diagnostics.Process; // GetCurrentProcess()
- en: namespace
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: Packt.Shared
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: ;
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 公共的
- en: static
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: class
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Recorder
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Recorder
- en: '{'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: private
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 私人的
- en: static
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: Stopwatch timer = new
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Stopwatch timer =新的
- en: ();
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: private
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 私人的
- en: static
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: long
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 长
- en: bytesPhysicalBefore = 0
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: bytesPhysicalBefore = 0
- en: ;
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: private
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 私人的
- en: static
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: long
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 长
- en: bytesVirtualBefore = 0
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: bytesVirtualBefore = 0
- en: ;
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 公共的
- en: static
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: void
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Start
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 开始
- en: ()
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // force two garbage collections to release memory that is
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: // 强制进行两次垃圾收集以释放内存
- en: // no longer referenced but has not been released yet
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: // 不再被引用，但尚未被释放
- en: GC.Collect();
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: GC.Collect();
- en: GC.WaitForPendingFinalizers();
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: GC.WaitForPendingFinalizers();
- en: GC.Collect();
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: GC.Collect();
- en: // store the current physical and virtual memory use
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: // 存储当前的物理和虚拟内存使用情况
- en: bytesPhysicalBefore = GetCurrentProcess().WorkingSet64;
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: bytesPhysicalBefore = GetCurrentProcess().WorkingSet64;
- en: bytesVirtualBefore = GetCurrentProcess().VirtualMemorySize64;
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: bytesVirtualBefore = GetCurrentProcess().VirtualMemorySize64;
- en: timer.Restart();
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: timer.Restart();
- en: '}'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 公共的
- en: static
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: void
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Stop
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 停止
- en: ()
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: timer.Stop();
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: timer.Stop();
- en: long
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 长
- en: bytesPhysicalAfter =
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: bytesPhysicalAfter =
- en: GetCurrentProcess().WorkingSet64;
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: GetCurrentProcess().WorkingSet64;
- en: long
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 长
- en: bytesVirtualAfter =
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: bytesVirtualAfter =
- en: GetCurrentProcess().VirtualMemorySize64;
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: GetCurrentProcess().VirtualMemorySize64;
- en: WriteLine("{0:N0} physical bytes used."
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("{0:N0}物理字节已使用。"
- en: ','
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: bytesPhysicalAfter - bytesPhysicalBefore);
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: bytesPhysicalAfter - bytesPhysicalBefore);
- en: WriteLine("{0:N0} virtual bytes used."
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("{0:N0}虚拟字节已使用。"
- en: ','
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: bytesVirtualAfter - bytesVirtualBefore);
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: bytesVirtualAfter - bytesVirtualBefore);
- en: WriteLine("{0} time span ellapsed."
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("{0}时间跨度已过。"
- en: ', timer.Elapsed);'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ', timer.Elapsed);'
- en: WriteLine("{0:N0} total milliseconds ellapsed."
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("{0:N0}总毫秒已过。"
- en: ','
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: timer.ElapsedMilliseconds);
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器.ElapsedMilliseconds);
- en: '}'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `Start` method of the `Recorder` class uses the `GC` type (garbage collector)
    to ensure that any currently allocated but not referenced memory is collected
    before recording the amount of used memory. This is an advanced technique that
    you should almost never use in application code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Recorder`类的`Start`方法使用`GC`类型（垃圾收集器）来确保在记录已使用的内存量之前收集当前分配但未引用的内存。这是一种高级技术，您几乎永远不应该在应用程序代码中使用。'
- en: 'In `Program.cs` , write statements to start and stop the `Recorder` while generating
    an array of 10,000 integers, as shown in the following code:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，编写语句以启动和停止`Recorder`，同时生成一个包含10,000个整数的数组，如下面的代码所示：
- en: '```cs'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: Packt.Shared; // Recorder
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared; // Recorder
- en: using
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: static
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: System.Console;
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: System.Console;
- en: WriteLine("Processing. Please wait..."
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("处理中。请稍候..."
- en: );
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Recorder.Start();
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Recorder.Start();
- en: // simulate a process that requires some memory resources...
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: // 模拟需要一些内存资源的过程...
- en: int
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: '[] largeArrayOfInts = Enumerable.Range('
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[] largeArrayOfInts = Enumerable.Range('
- en: 'start: 1'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 开始：1
- en: ', count: 10'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ，计数：10
- en: _000).ToArray();
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: _000).ToArray();
- en: // ...and takes some time to complete
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: // ...并且需要一些时间来完成
- en: Thread.Sleep(new
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Thread.Sleep(new
- en: Random().Next(5
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Random().Next(5
- en: ', 10'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ', 10'
- en: ) * 1000
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ) * 1000
- en: );
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Recorder.Stop();
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Recorder.Stop();
- en: '```'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Processing. Please wait...
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 处理中。请稍候...
- en: 655,360 physical bytes used.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 655,360物理字节已使用。
- en: 536,576 virtual bytes used.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用了536,576虚拟字节。
- en: 00:00:09.0038702 time span ellapsed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 00:00:09.0038702时间跨度已过。
- en: 9,003 total milliseconds ellapsed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 9,003毫秒总时间已过。
- en: '```'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Remember that the time elapsed is randomly between 5 and 10 seconds. Your results
    will vary. For example, when run on my Mac mini M1, less physical memory but more
    virtual memory was used, as shown in the following output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，经过的时间在5到10秒之间是随机的。您的结果会有所不同。例如，在我的Mac mini M1上运行时，使用的物理内存较少，但虚拟内存较多，如下面的输出所示：
- en: '```cs'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Processing. Please wait...
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 处理中。请稍候...
- en: 294,912 physical bytes used.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 294,912物理字节已使用。
- en: 10,485,760 virtual bytes used.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 10,485,760虚拟字节已使用。
- en: 00:00:06.0074221 time span ellapsed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 00:00:06.0074221时间跨度已过。
- en: 6,007 total milliseconds ellapsed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 6,007毫秒总时间已过。
- en: '```'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Measuring the efficiency of processing strings
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 衡量处理字符串的效率
- en: Now that you've seen how the `Stopwatch` and `Process` types can be used to
    monitor your code, we will use them to evaluate the best way to process `string`
    variables.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了`Stopwatch`和`Process`类型如何用于监视您的代码，我们将使用它们来评估处理`string`变量的最佳方法。
- en: 'In `Program.cs` , comment out the previous statements by wrapping them in multi-line
    comment characters: `/* */` .'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，通过使用多行注释字符`/* */`将先前的语句注释掉。
- en: 'Write statements to create an array of 50,000 `int` variables and then concatenate
    them with commas as separators using a `string` and `StringBuilder` class, as
    shown in the following code:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写语句以创建一个包含50,000个`int`变量的数组，然后使用`string`和`StringBuilder`类将它们连接起来，分隔符为逗号，如下面的代码所示：
- en: '```cs'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: '[] numbers = Enumerable.Range('
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[] numbers = Enumerable.Range('
- en: 'start: 1'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 开始：1
- en: ', count: 50'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ，计数：50
- en: _000).ToArray();
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: _000).ToArray();
- en: WriteLine("Using string with +"
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("使用带有+的字符串"
- en: );
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Recorder.Start();
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Recorder.Start();
- en: string
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: s = string
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: s =字符串
- en: .Empty; // i.e. ""
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: .Empty; // 即""
- en: for
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为
- en: (int
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: (int
- en: i = 0
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: ; i < numbers.Length; i++)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ; i < numbers.Length; i++)
- en: '{'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: s += numbers[i] + ", "
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: s += numbers[i] + ", "
- en: ;
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Recorder.Stop();
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Recorder.Stop();
- en: WriteLine("Using StringBuilder"
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("使用StringBuilder"
- en: );
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Recorder.Start();
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Recorder.Start();
- en: System.Text.StringBuilder builder = new
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: System.Text.StringBuilder builder =新的
- en: ();
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: for
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: for
- en: (int
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: (int
- en: i = 0
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: ; i < numbers.Length; i++)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ; i < numbers.Length; i++)
- en: '{'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: builder.Append(numbers[i]);
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: builder.Append(numbers[i]);
- en: builder.Append(", "
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: builder.Append(", "
- en: );
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Recorder.Stop();
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Recorder.Stop();
- en: '```'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Using string with +
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有+
- en: 14,883,072 physical bytes used.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 14,883,072物理字节已使用。
- en: 3,609,728 virtual bytes used.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 3,609,728虚拟字节已使用。
- en: 00:00:01.6220879 time span ellapsed.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 00:00:01.6220879时间跨度已过。
- en: 1,622 total milliseconds ellapsed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 1,622毫秒总时间已过。
- en: Using StringBuilder
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用StringBuilder
- en: 12,288 physical bytes used.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 12,288物理字节已使用。
- en: 0 virtual bytes used.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 0虚拟字节已使用。
- en: 00:00:00.0006038 time span ellapsed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 00:00:00.0006038时间跨度已过。
- en: 0 total milliseconds ellapsed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 0毫秒总时间已过。
- en: '```'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We can summarize the results as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以总结结果如下：
- en: The `string` class with the `+` operator used about 14 MB of physical memory,
    1.5 MB of virtual memory, and took 1.5 seconds.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`类与`+`运算符使用了约14 MB的物理内存，1.5 MB的虚拟内存，并花费了1.5秒。'
- en: The `StringBuilder` class used 12 KB of physical memory, zero virtual memory,
    and took less than 1 millisecond.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringBuilder`类使用了12 KB的物理内存，零虚拟内存，并且花费不到1毫秒。'
- en: In this scenario, `StringBuilder` is more than 1,000 times faster and about
    10,000 times more memory efficient when concatenating text! This is because `string`
    concatenation creates a new `string` each time you use it because `string` values
    are immutable so they can be safely pooled for reuse. `StringBuilder` creates
    a single buffer while it appends more characters.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`StringBuilder`连接文本时比`string`快1000多倍，内存效率约为10000倍！这是因为`string`连接每次使用时都会创建一个新的`string`，因为`string`值是不可变的，所以它们可以安全地用于重用。`StringBuilder`在追加更多字符时创建一个单一的缓冲区。
- en: '**Good Practice** : Avoid using the `String.Concat` method or the `+` operator
    inside loops. Use `StringBuilder` instead.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：避免在循环内使用`String.Concat`方法或`+`运算符。改用`StringBuilder`。'
- en: Now that you've learned how to measure the performance and resource efficiency
    of your code using types built into .NET, let's learn about a NuGet package that
    provides more sophisticated performance measurements.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何使用.NET内置的类型来测量代码的性能和资源效率，让我们了解一个提供更复杂性能测量的NuGet包。
- en: Monitoring performance and memory using Benchmark.NET
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Benchmark.NET监视性能和内存
- en: 'There is a popular benchmarking NuGet package for .NET that Microsoft uses
    in its blog posts about performance improvements, so it is good for .NET developers
    to know how it works and use it for their own performance testing. Let''s see
    how we could use it to compare performance between `string` concatenation and
    `StringBuilder` :'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: .NET有一个流行的基准测试NuGet包，微软在其关于性能改进的博客文章中使用它，因此对于.NET开发人员来说，了解它的工作原理并将其用于自己的性能测试是很好的。让我们看看如何使用它来比较`string`连接和`StringBuilder`之间的性能：
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `Benchmarking` .
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器将一个新的控制台应用程序添加到名为`Benchmarking`的`Chapter12`解决方案/工作区中。
- en: In Visual Studio Code, select `Benchmarking` as the active OmniSharp project.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，选择`Benchmarking`作为活动的OmniSharp项目。
- en: 'Add a package reference to Benchmark.NET, remembering that you can find out
    the latest version and use that instead of the version I used, as shown in the
    following markup:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对Benchmark.NET的包引用，记住您可以查找最新版本并使用该版本，而不是我使用的版本，如下面的标记所示：
- en: '```cs'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: <ItemGroup>
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: <ItemGroup>
- en: <PackageReference Include="BenchmarkDotNet"
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: <PackageReference Include="BenchmarkDotNet"
- en: Version="0.13.1"
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Version="0.13.1"
- en: />
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: />
- en: </ItemGroup>
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: </ItemGroup>
- en: '```'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Build the project to restore packages.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目以恢复包。
- en: 'In `Program.cs` , delete the existing statements and then import the namespace
    for running benchmarks, as shown in the following code:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有的语句，然后导入运行基准测试的命名空间，如下面的代码所示：
- en: '```cs'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: using
- en: BenchmarkDotNet.Running;
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: BenchmarkDotNet.Running;
- en: '```'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Add a new class file named `StringBenchmarks.cs` .
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`StringBenchmarks.cs`的新类文件。
- en: 'In `StringBenchmarks.cs` , add statements to define a class with methods for
    each benchmark you want to run, in this case, two methods that both combine twenty
    numbers comma-separated using either `string` concatenation or `StringBuilder`
    , as shown in the following code:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`StringBenchmarks.cs`中，添加语句来定义一个类，其中包含您想要运行的每个基准测试的方法，本例中，两种方法都使用`string`连接或`StringBuilder`连接二十个逗号分隔的数字，如下面的代码所示：
- en: '```cs'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: BenchmarkDotNet.Attributes; // [Benchmark]
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: BenchmarkDotNet.Attributes; // [Benchmark]
- en: public
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: class
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: class
- en: StringBenchmarks
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: StringBenchmarks
- en: '{'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: '[] numbers;'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[] numbers;'
- en: public
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: StringBenchmarks
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: StringBenchmarks
- en: ()
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: numbers = Enumerable.Range(
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: numbers = Enumerable.Range(
- en: 'start: 1'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 'start: 1'
- en: ', count: 20'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ，计数：20
- en: ).ToArray();
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ).ToArray();
- en: '}'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[Benchmark(Baseline = true)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[Benchmark(Baseline = true)'
- en: ']'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: public
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: string
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: StringConcatenationTest
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: StringConcatenationTest
- en: ()
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: string
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: s = string
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: s = string
- en: .Empty; // e.g. ""
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: .Empty; // 例如""
- en: for
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: for
- en: (int
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: (int
- en: i = 0
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: ; i < numbers.Length; i++)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ; i < numbers.Length; i++)
- en: '{'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: s += numbers[i] + ", "
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: s += numbers[i] + ", "
- en: ;
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: s;
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: s;
- en: '}'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[Benchmark'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[Benchmark'
- en: ']'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: public
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: string
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: StringBuilderTest
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: StringBuilderTest
- en: ()
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: System.Text.StringBuilder builder = new
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: System.Text.StringBuilder builder = new
- en: ();
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: for
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: for
- en: (int
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: (int
- en: i = 0
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: ; i < numbers.Length; i++)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ; i < numbers.Length; i++)
- en: '{'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: builder.Append(numbers[i]);
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: builder.Append(numbers[i]);
- en: builder.Append(", "
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: builder.Append(", "
- en: );
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '}'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: builder.ToString();
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: builder.ToString();
- en: '}'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Program.cs` , add a statement to run the benchmarks, as shown in the following
    code:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加一个语句来运行基准测试，如下面的代码所示：
- en: '```cs'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: BenchmarkRunner.Run<StringBenchmarks>();
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: BenchmarkRunner.Run<StringBenchmarks>();
- en: '```'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In Visual Studio 2022, in the toolbar, set **Solution Configurations** to **Release**
    .
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2022中，在工具栏中，将**解决方案配置**设置为**Release**。
- en: In Visual Studio Code, in a terminal, use the `dotnet run --configuration Release`
    command.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，在终端中使用`dotnet run --configuration Release`命令。
- en: 'Run the console app and note the results, including some artifacts like report
    files, and the most important, a summary table that shows that `string` concatenation
    took a mean of 412.990 ns and `StringBuilder` took a mean of 275.082 ns, as shown
    in the following partial output and in *Figure 12.1* :'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并注意结果，包括一些报告文件等工件，最重要的是，一个总结表，显示`string`连接的平均时间为412.990 ns，`StringBuilder`的平均时间为275.082
    ns，如下面的部分输出和*图12.1*所示：
- en: '```cs'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '// ***** BenchmarkRunner: Finish  *****'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '// ***** BenchmarkRunner: Finish  *****'
- en: // * Export *
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: // *导出*
- en: BenchmarkDotNet.Artifacts\results\StringBenchmarks-report.csv
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: BenchmarkDotNet.Artifacts\results\StringBenchmarks-report.csv
- en: BenchmarkDotNet.Artifacts\results\StringBenchmarks-report-github.md
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: BenchmarkDotNet.Artifacts\results\StringBenchmarks-report-github.md
- en: BenchmarkDotNet.Artifacts\results\StringBenchmarks-report.html
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: BenchmarkDotNet.Artifacts\results\StringBenchmarks-report.html
- en: // * Detailed results *
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: // *详细结果*
- en: 'StringBenchmarks.StringConcatenationTest: DefaultJob'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 'StringBenchmarks.StringConcatenationTest: DefaultJob'
- en: Runtime = .NET 6.0.0 (6.0.21.37719), X64 RyuJIT; GC = Concurrent Workstation
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Runtime = .NET 6.0.0 (6.0.21.37719), X64 RyuJIT; GC = Concurrent Workstation
- en: Mean = 412.990 ns, StdErr = 2.353 ns (0.57%), N = 46, StdDev = 15.957 ns
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值= 412.990 ns，StdErr= 2.353 ns (0.57%)，N= 46，StdDev= 15.957 ns
- en: Min = 373.636 ns, Q1 = 413.341 ns, Median = 417.665 ns, Q3 = 420.775 ns, Max
    = 434.504 ns
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值= 373.636 ns，Q1= 413.341 ns，中位数= 417.665 ns，Q3= 420.775 ns，最大值= 434.504 ns
- en: IQR = 7.433 ns, LowerFence = 402.191 ns, UpperFence = 431.925 ns
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: IQR= 7.433 ns，LowerFence= 402.191 ns，UpperFence= 431.925 ns
- en: ConfidenceInterval = [404.708 ns; 421.273 ns] (CI 99.9%), Margin = 8.282 ns
    (2.01% of Mean)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 置信区间= [404.708 ns; 421.273 ns] (CI 99.9%)，边际= 8.282 ns (平均值的2.01%)
- en: Skewness = -1.51, Kurtosis = 4.09, MValue = 2
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 偏度= -1.51，峰度= 4.09，M值= 2
- en: '-------------------- Histogram --------------------'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '-------------------- 直方图 --------------------'
- en: '[370.520 ns ; 382.211 ns) | @@@@@@'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '[370.520 ns ; 382.211 ns) | @@@@@@'
- en: '[382.211 ns ; 394.583 ns) | @'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '[382.211 ns ; 394.583 ns) | @'
- en: '[394.583 ns ; 411.300 ns) | @@'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[394.583 ns ; 411.300 ns) | @@'
- en: '[411.300 ns ; 422.990 ns) | @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '[411.300 ns ; 422.990 ns) | @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@'
- en: '[422.990 ns ; 436.095 ns) | @@@@@'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '[422.990 ns ; 436.095 ns) | @@@@@'
- en: '---------------------------------------------------'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '---------------------------------------------------'
- en: 'StringBenchmarks.StringBuilderTest: DefaultJob'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: StringBenchmarks.StringBuilderTest：默认作业
- en: Runtime = .NET 6.0.0 (6.0.21.37719), X64 RyuJIT; GC = Concurrent Workstation
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Runtime = .NET 6.0.0 (6.0.21.37719)，X64 RyuJIT；GC = Concurrent Workstation
- en: Mean = 275.082 ns, StdErr = 0.558 ns (0.20%), N = 15, StdDev = 2.163 ns
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值= 275.082 ns，StdErr= 0.558 ns (0.20%)，N= 15，StdDev= 2.163 ns
- en: Min = 271.059 ns, Q1 = 274.495 ns, Median = 275.403 ns, Q3 = 276.553 ns, Max
    = 278.030 ns
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值= 271.059 ns，Q1= 274.495 ns，中位数= 275.403 ns，Q3= 276.553 ns，最大值= 278.030 ns
- en: IQR = 2.058 ns, LowerFence = 271.409 ns, UpperFence = 279.639 ns
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: IQR= 2.058 ns，LowerFence= 271.409 ns，UpperFence= 279.639 ns
- en: ConfidenceInterval = [272.770 ns; 277.394 ns] (CI 99.9%), Margin = 2.312 ns
    (0.84% of Mean)
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 置信区间= [272.770 ns; 277.394 ns] (CI 99.9%)，边际= 2.312 ns (平均值的0.84%)
- en: Skewness = -0.69, Kurtosis = 2.2, MValue = 2
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 偏度= -0.69，峰度= 2.2，M值= 2
- en: '-------------------- Histogram --------------------'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '-------------------- 直方图 --------------------'
- en: '[269.908 ns ; 278.682 ns) | @@@@@@@@@@@@@@@'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '[269.908 ns ; 278.682 ns) | @@@@@@@@@@@@@@@'
- en: '---------------------------------------------------'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '---------------------------------------------------'
- en: // * Summary *
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: // * 摘要 *
- en: BenchmarkDotNet=v0.13.1, OS=Windows 10.0.19043.1165 (21H1/May2021Update)
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: BenchmarkDotNet=v0.13.1，OS=Windows 10.0.19043.1165 (21H1/May2021Update)
- en: 11th Gen Intel Core i7-1165G7 2.80GHz, 1 CPU, 8 logical and 4 physical cores
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 第11代英特尔酷睿i7-1165G7 2.80GHz，1个CPU，8个逻辑和4个物理内核
- en: .NET SDK=6.0.100
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: .NET SDK=6.0.100
- en: '[Host]     : .NET 6.0.0 (6.0.21.37719), X64 RyuJIT'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '[主机]：.NET 6.0.0 (6.0.21.37719)，X64 RyuJIT'
- en: 'DefaultJob : .NET 6.0.0 (6.0.21.37719), X64 RyuJIT'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: DefaultJob：.NET 6.0.0 (6.0.21.37719)，X64 RyuJIT
- en: '|                  Method |     Mean |   Error |   StdDev | Ratio | RatioSD
    |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 平均值 | 错误 | 标准偏差 | 比率 | RatioSD |'
- en: '|------------------------ |---------:|--------:|---------:|------:|--------:|'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '|------------------------ |---------:|--------:|---------:|------:|--------:|'
- en: '| StringConcatenationTest | 413.0 ns | 8.28 ns | 15.96 ns |  1.00 |    0.00
    |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| StringConcatenationTest | 413.0 ns | 8.28 ns | 15.96 ns |  1.00 |    0.00
    |'
- en: '|       StringBuilderTest | 275.1 ns | 2.31 ns |  2.16 ns |  0.69 |    0.04
    |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '|       StringBuilderTest | 275.1 ns | 2.31 ns |  2.16 ns |  0.69 |    0.04
    |'
- en: // * Hints *
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: // * 提示 *
- en: Outliers
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 异常值
- en: 'StringBenchmarks.StringConcatenationTest: Default -> 7 outliers were removed,
    14 outliers were detected (376.78 ns..391.88 ns, 440.79 ns..506.41 ns)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: StringBenchmarks.StringConcatenationTest：默认->删除了7个异常值，检测到14个异常值(376.78 ns..391.88
    ns，440.79 ns..506.41 ns)
- en: 'StringBenchmarks.StringBuilderTest: Default       -> 2 outliers were detected
    (274.68 ns, 274.69 ns)'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: StringBenchmarks.StringBuilderTest：默认->检测到2个异常值(274.68 ns，274.69 ns)
- en: // * Legends *
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: // * 图例 *
- en: 'Mean    : Arithmetic mean of all measurements'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值：所有测量的算术平均值
- en: 'Error   : Half of 99.9% confidence interval'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：99.9%置信区间的一半
- en: 'StdDev  : Standard deviation of all measurements'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: StdDev：所有测量的标准偏差
- en: 'Ratio   : Mean of the ratio distribution ([Current]/[Baseline])'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 比率：比率分布的平均值([当前]/[基线])
- en: 'RatioSD : Standard deviation of the ratio distribution ([Current]/[Baseline])'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: RatioSD：比率分布的标准偏差([当前]/[基线])
- en: '1 ns    : 1 Nanosecond (0.000000001 sec)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 1 ns：1纳秒(0.000000001秒)
- en: '// ***** BenchmarkRunner: End *****'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '// ***** BenchmarkRunner: End *****'
- en: // ** Remained 0 benchmark(s) to run **
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: // ** 剩余0个基准要运行 **
- en: 'Run time: 00:01:13 (73.35 sec), executed benchmarks: 2'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时间：00:01:13 (73.35秒)，执行基准测试：2
- en: 'Global total time: 00:01:29 (89.71 sec), executed benchmarks: 2'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 全局总时间：00:01:29 (89.71秒)，执行基准测试：2
- en: // * Artifacts cleanup *
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: // * 清理工件 *
- en: '```'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '![](img/Image00099.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00099.jpg)'
- en: 'Figure 12.1: Summary table that shows StringBuilder takes 69% of the time compared
    to string concatenation'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：摘要表，显示StringBuilder所占时间为字符串连接的69%
- en: The `Outliers` section is especially interesting because it shows that not only
    is `string` concatenation slower than `StringBuilder` , but it is also more inconsistent
    in how long it takes. Your results will vary, of course.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`异常值`部分特别有趣，因为它显示了`string`连接不仅比`StringBuilder`慢，而且在花费的时间上也更不一致。当然，您的结果会有所不同。'
- en: You have now seen two ways to measure performance. Now let's see how we can
    run tasks asynchronously to potentially improve performance.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经看到了衡量性能的两种方法。现在让我们看看如何异步运行任务，以潜在地提高性能。
- en: Running tasks asynchronously
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步运行任务
- en: To understand how multiple tasks can be run simultaneously (at the same time),
    we will create a console application that needs to execute three methods.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解如何同时运行多个任务(同时)，我们将创建一个需要执行三种方法的控制台应用程序。
- en: 'There will be three methods that need to be executed: the first takes 3 seconds,
    the second takes 2 seconds, and the third takes 1 second. To simulate that work,
    we can use the `Thread` class to tell the current thread to go to sleep for a
    specified number of milliseconds.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 需要执行三种方法：第一种需要3秒，第二种需要2秒，第三种需要1秒。为了模拟这项工作，我们可以使用`Thread`类告诉当前线程休眠指定的毫秒数。
- en: Running multiple actions synchronously
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步运行多个操作
- en: Before we make the tasks run simultaneously, we will run them synchronously,
    that is, one after the other.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使任务同时运行之前，我们将以同步方式运行它们，也就是一个接一个地运行。
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `WorkingWithTasks` .
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器向`Chapter12`解决方案/工作区添加一个名为`WorkingWithTasks`的新控制台应用程序。
- en: In Visual Studio Code, select `WorkingWithTasks` as the active OmniSharp project.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs` , import the namespace to work with a stopwatch (namespaces
    for working with threading and tasks are implicitly imported), and statically
    import `Console` , as shown in the following code:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: using
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: System.Diagnostics; // Stopwatch
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: using
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: System.Console;
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , create a method to output information about
    the current thread, as shown in the following code:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: OutputThreadInfo
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Thread t = Thread.CurrentThread;
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '"Thread Id: {0}, Priority: {1}, Background: {2}, Name: {3}"'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: ','
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: t.ManagedThreadId, t.Priority,
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: t.IsBackground, t.Name ?? "null"
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , add three methods that simulate work, as shown
    in the following code:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: MethodA
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Starting Method A..."
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: OutputThreadInfo();
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Sleep(3000
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: ); // simulate three seconds of work
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Finished Method A."
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: MethodB
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Starting Method B..."
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: OutputThreadInfo();
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Sleep(2000
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: ); // simulate two seconds of work
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Finished Method B."
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: MethodC
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Starting Method C..."
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: OutputThreadInfo();
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Sleep(1000
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: ); // simulate one second of work
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Finished Method C."
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs` , add statements to call the method to output information
    about the thread, define and start a stopwatch, call the three simulated work
    methods, and then output the milliseconds elapsed, as shown in the following code:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: OutputThreadInfo();
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: Stopwatch timer = Stopwatch.StartNew();
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Running methods synchronously on one thread."
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: MethodA();
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: MethodB();
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: MethodC();
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '{timer.ElapsedMilliseconds:#,##'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: ms elapsed."
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, view the result, and note that when there is only one unnamed
    foreground thread doing the work, the total time required is just over 6 seconds,
    as shown in the following output:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread Id: 1, Priority: Normal, Background: False, Name: null'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: Running methods synchronously on one thread.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: Starting Method A...
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread Id: 1, Priority: Normal, Background: False, Name: null'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: Finished Method A.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Starting Method B...
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread Id: 1, Priority: Normal, Background: False, Name: null'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: Finished Method B.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: Starting Method C...
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread Id: 1, Priority: Normal, Background: False, Name: null'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: Finished Method C.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: 6,017ms elapsed.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: Running multiple actions asynchronously using tasks
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Thread` class has been available since the first version of .NET and can
    be used to create new threads and manage them, but it can be tricky to work with
    directly.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: .NET Framework 4.0 introduced the `Task` class in 2010, which is a wrapper around
    a thread that enables easier creation and management. Managing multiple threads
    wrapped in tasks will allow our code to execute at the same time, aka asynchronously.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: Each `Task` has a `Status` property and a `CreationOptions` property. A `Task`
    has a `ContinueWith` method that can be customized with the `TaskContinuationOptions`
    enum, and can be managed with the `TaskFactory` class.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: Starting tasks
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will look at three ways to start the methods using `Task` instances. There
    are links in the GitHub repository to articles that discuss the pros and cons.
    Each has a slightly different syntax, but they all define a `Task` and start it:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment out the calls to the three methods and their associated console message,
    and add statements to create and start three tasks, one for each method, as shown
    highlighted in the following code:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: OutputThreadInfo();
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Stopwatch timer = Stopwatch.StartNew();
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '**/***'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Running methods synchronously on one thread.");
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: MethodA();
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: MethodB();
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: MethodC();
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '***/**'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '**WriteLine(**'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '**"Running methods asynchronously on multiple threads."**'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '**);**'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '**Task taskA =**'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '**new**'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '**(MethodA);**'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '**taskA.Start();**'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '**Task taskB = Task.Factory.StartNew(MethodB);**'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '**Task taskC = Task.Run(MethodC);**'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '{timer.ElapsedMilliseconds:#,##'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '{timer.ElapsedMilliseconds:#,##'
- en: '0'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '}'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ms elapsed."
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 毫秒已过。"
- en: );
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code, view the result, and note that the elapsed milliseconds appear
    almost immediately. This is because each of the three methods is now being executed
    by three new background worker threads allocated from the thread pool, as shown
    in the following output:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，查看结果，并注意经过的毫秒几乎立即出现。这是因为现在每个方法都是由从线程池分配的三个新后台工作线程执行的，如下面的输出所示：
- en: '```cs'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Thread Id: 1, Priority: Normal, Background: False, Name: null'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '线程Id: 1，优先级: 正常，后台: False，名称: null'
- en: Running methods asynchronously on multiple threads.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个线程上异步运行方法。
- en: Starting Method A...
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 开始方法A...
- en: 'Thread Id: 4, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '线程Id: 4，优先级: 正常，后台: True，名称: .NET ThreadPool Worker'
- en: Starting Method C...
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 开始方法C...
- en: 'Thread Id: 7, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '线程Id: 7，优先级: 正常，后台: True，名称: .NET ThreadPool Worker'
- en: Starting Method B...
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 开始方法B...
- en: 'Thread Id: 6, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '线程Id: 6，优先级: 正常，后台: True，名称: .NET ThreadPool Worker'
- en: 6ms elapsed.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 6ms经过。
- en: '```'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It is even possible that the console app will end before one or more of the
    tasks have a chance to start and write to the console!
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可能控制台应用程序在一个或多个任务有机会开始并写入控制台之前结束！
- en: Waiting for tasks
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待任务
- en: 'Sometimes, you need to wait for a task to complete before continuing. To do
    this, you can use the `Wait` method on a `Task` instance, or the `WaitAll` or
    `WaitAny` static methods on an array of tasks, as described in the following table:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要等待任务完成后才能继续。为此，您可以在`Task`实例上使用`Wait`方法，或者在任务数组上使用`WaitAll`或`WaitAny`静态方法，如下表所述：
- en: '| Method | Description |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| `t.Wait()` | This waits for the task instance named `t` to complete execution.
    |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| `t.Wait()` | 这等待任务实例` t`完成执行。|'
- en: '| `Task.WaitAny(Task[])` | This waits for any of the tasks in the array to
    complete execution. |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '| `Task.WaitAny(Task[])` | 这等待数组中的任何任务完成执行。|'
- en: '| `Task.WaitAll(Task[])` | This waits for all the tasks in the array to complete
    execution. |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| `Task.WaitAll(Task[])` | 这等待数组中的所有任务完成执行。|'
- en: Using wait methods with tasks
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用任务的等待方法
- en: Let's see how we can use these wait methods to fix the problem with our console
    app.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这些等待方法来解决控制台应用程序的问题。
- en: 'In `Program.cs` , add statements after creating the three tasks and before
    outputting the elapsed time to combine references to the three tasks into an array
    and pass them to the `WaitAll` method, as shown in the following code:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，在创建三个任务之后并在输出经过的时间之前，添加语句将对三个任务的引用组合成数组，并将它们传递给`WaitAll`方法，如下面的代码所示：
- en: '```cs'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Task[] tasks = { taskA, taskB, taskC };
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 任务[]任务= {任务A，任务B，任务C};
- en: Task.WaitAll(tasks);
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: Task.WaitAll(tasks);
- en: '```'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, and note the original thread will pause on
    the call to `WaitAll` , waiting for all three tasks to finish before outputting
    the elapsed time, which is a little over 3 seconds, as shown in the following
    output:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，并注意原始线程将在调用`WaitAll`时暂停，等待所有三个任务完成后再输出经过的时间，如下面的输出所示：超过3秒。
- en: '```cs'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Id: 1, Priority: Normal, Background: False, Name: null'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 'Id: 1, Priority: Normal, Background: False, Name: null'
- en: Running methods asynchronously on multiple threads.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个线程上异步运行方法。
- en: Starting Method A...
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 开始方法A...
- en: 'Id: 6, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 'Id: 6，优先级: 正常，后台: True，名称: .NET ThreadPool Worker'
- en: Starting Method B...
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 开始方法B...
- en: 'Id: 7, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 'Id: 7, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
- en: Starting Method C...
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 开始方法C...
- en: 'Id: 4, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 'Id: 4，优先级: 正常，后台: True，名称: .NET ThreadPool Worker'
- en: Finished Method C.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 完成方法C。
- en: Finished Method B.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 完成方法B。
- en: Finished Method A.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 完成方法A。
- en: 3,013ms elapsed.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 3,013ms经过。
- en: '```'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The three new threads execute their code simultaneously, and they can potentially
    start in any order. `MethodC` should finish first because it takes only 1 second,
    then `MethodB` , which takes 2 seconds, and finally `MethodA` , because it takes
    3 seconds.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 三个新线程同时执行它们的代码，并且它们可以以任何顺序开始。`MethodC`应该首先完成，因为它只需要1秒，然后是需要2秒的`MethodB`，最后是需要3秒的`MethodA`。
- en: However, the actual CPU used has a big effect on the results. It is the CPU
    that allocates time slices to each process to allow them to execute their threads.
    You have no control over when the methods run.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实际使用的CPU对结果有很大影响。CPU分配时间片给每个进程，以允许它们执行它们的线程。您无法控制方法何时运行。
- en: Continuing with another task
  id: totrans-576
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续进行另一个任务
- en: If all three tasks can be performed at the same time, then waiting for all tasks
    to finish will be all we need to do. However, often a task is dependent on the
    output from another task. To handle this scenario, we need to define **continuation
    tasks** .
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 如果三个任务都可以同时执行，那么等待所有任务完成将是我们需要做的。然而，通常一个任务依赖于另一个任务的输出。为了处理这种情况，我们需要定义**继续任务**。
- en: We will create some methods to simulate a call to a web service that returns
    a monetary amount that then needs to be used to retrieve how many products cost
    more than that amount in a database. The result returned from the first method
    needs to be fed into the input of the second method. This time, instead of waiting
    for fixed amounts of time, we will use the `Random` class to wait for a random
    interval between 2 and 4 seconds for each method call to simulate the work.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一些方法来模拟调用返回货币金额的网络服务，然后需要使用该金额来检索数据库中超过该金额的产品数量。第一个方法返回的结果需要输入到第二个方法中。这一次，我们将使用`Random`类来等待随机的时间间隔，每个方法调用的时间间隔在2到4秒之间，以模拟工作。
- en: 'At the bottom of `Program.cs` , add two methods that simulate calling a web
    service and a database-stored procedure, as shown in the following code:'
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的底部，添加两个模拟调用网络服务和数据库存储过程的方法，如下面的代码所示：
- en: '```cs'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: static
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的
- en: decimal
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 小数
- en: CallWebService
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: CallWebService
- en: ()
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine("Starting call to web service..."
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: OutputThreadInfo();
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Sleep((new
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: Random()).Next(2000
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: ', 4000'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: ));
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Finished call to web service."
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: return
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '89.99'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: M;
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: CallStoredProcedure
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: amount
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Starting call to stored procedure..."
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: OutputThreadInfo();
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Sleep((new
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: Random()).Next(2000
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: ', 4000'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: ));
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Finished call to stored procedure."
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: return
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: $"12 products cost more than
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: '{amount:C}'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: ."
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: Comment out the calls to the previous three tasks by wrapping them in multiline
    comment characters, `/* */` . Leave the statement that outputs the elapsed milliseconds.
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements before the existing statement to output the total time, as shown
    in the following code:'
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Passing the result of one task as an input into another."
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: Task<string
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: taskServiceThenSProc = Task.Factory
  id: totrans-629
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: .StartNew(CallWebService) // returns Task<decimal>
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: .ContinueWith(previousTask => // returns Task<string>
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: CallStoredProcedure(previousTask.Result));
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Result:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '{taskServiceThenSProc.Result}'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread Id: 1, Priority: Normal, Background: False, Name: null'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: Passing the result of one task as an input into another.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: Starting call to web service...
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread Id: 4, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: Finished call to web service.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: Starting call to stored procedure...
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread Id: 6, Priority: Normal, Background: True, Name: .NET ThreadPool Worker'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: Finished call to stored procedure.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: 'Result: 12 products cost more than £89.99.'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: 5,463ms elapsed.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: You might see different threads running the web service and stored procedure
    calls as in the output above (threads 4 and 6), or the same thread might be reused
    since it is no longer busy.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: Nested and child tasks
  id: totrans-652
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As well as defining dependencies between tasks, you can define nested and child
    tasks. A **nested task** is a task that is created inside another task. A **child
    task** is a nested task that must finish before its parent task is allowed to
    finish.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore how these types of tasks work:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `NestedAndChildTasks` .
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `NestedAndChildTasks` as the active OmniSharp
    project.
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs` , delete the existing statements, statically import `Console`
    , and then add two methods, one of which starts a task to run the other, as shown
    in the following code:'
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: OuterMethod
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Outer method starting..."
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: Task innerTask = Task.Factory.StartNew(InnerMethod);
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Outer method finished."
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: InnerMethod
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Inner method starting..."
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Sleep(2000
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Inner method finished."
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: 'Above the methods, add statements to start a task to run the outer method and
    wait for it to finish before stopping, as shown in the following code:'
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: Task outerTask = Task.Factory.StartNew(OuterMethod);
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: outerTask.Wait();
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Console app is stopping."
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-690
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: Outer method starting...
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: Inner method starting...
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: Outer method finished.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: Console app is stopping.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: Note that, although we wait for the outer task to finish, its inner task does
    not have to finish as well. In fact, the outer task might finish, and the console
    app could end, before the inner task even starts!
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: To link these nested tasks as parent and child, we must use a special option.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the existing code that defines the inner task to add a `TaskCreationOption`
    value of `AttachedToParent` , as shown highlighted in the following code:'
  id: totrans-699
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: Task innerTask = Task.Factory.StartNew(InnerMethod,
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: '**TaskCreationOptions.AttachedToParent**'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, view the result, and note that the inner task must finish before
    the outer task can, as shown in the following output:'
  id: totrans-705
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: Outer method starting...
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: Inner method starting...
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: Outer method finished.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 外部方法完成。
- en: Inner method finished.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 内部方法完成。
- en: Console app is stopping.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序正在停止。
- en: '```'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `OuterMethod` can finish before the `InnerMethod` , as shown by its writing
    to the console, but its task must wait, as shown by the console not stopping until
    both the outer and inner tasks finish.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '`OuterMethod` 可以在 `InnerMethod` 之前完成，如其写入控制台所示，但它的任务必须等待，如控制台不会停止直到外部和内部任务都完成所示。'
- en: Wrapping tasks around other objects
  id: totrans-714
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将任务包装在其他对象周围
- en: 'Sometimes you might have a method that you want to be asynchronous, but the
    result to be returned is not itself a task. You can wrap the return value in a
    successfully completed task, return an exception, or indicate that the task was
    canceled by using one of the methods shown in the following table:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能有一个希望是异步的方法，但要返回的结果本身不是一个任务。您可以使用下表中所示的方法之一将返回值包装在成功完成的任务中，返回一个异常，或者指示任务被取消。
- en: '| Method | Description |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| `FromResult<TResult>(TResult)` | Creates a `Task<TResult>` object whose `Result`
    property is the non-task result and whose `Status` property is `RanToCompletion`
    . |'
  id: totrans-717
  prefs: []
  type: TYPE_TB
  zh: '| `FromResult<TResult>(TResult)` | 创建一个 `Task<TResult>` 对象，其 `Result` 属性是非任务结果，`Status`
    属性是 `RanToCompletion` 。'
- en: '| `FromException<TResult>(Exception)` | Creates a `Task<TResult>` that''s completed
    with a specified exception. |'
  id: totrans-718
  prefs: []
  type: TYPE_TB
  zh: '| `FromException<TResult>(Exception)` | 使用指定的异常创建一个已完成的 `Task<TResult>` 。'
- en: '| `FromCanceled<TResult>(CancellationToken)` | Creates a `Task<TResult>` that''s
    completed due to cancellation with a specified cancellation token. |'
  id: totrans-719
  prefs: []
  type: TYPE_TB
  zh: '| `FromCanceled<TResult>(CancellationToken)` | 使用指定的取消令牌创建一个由于取消而完成的 `Task<TResult>`
    。'
- en: 'These methods are useful when you need to:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要时，这些方法非常有用：
- en: Implement an interface that has async methods, but your implementation is synchronous.
    This is common for websites and services.
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个具有异步方法的接口，但您的实现是同步的。这在网站和服务中很常见。
- en: Mock asynchronous implementations during unit testing.
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单元测试期间模拟异步实现。
- en: In *Chapter 7* , *Packaging and Distributing .NET Types* , we created a class
    library with functions to check valid XML, passwords, and hex codes.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第7章*，*打包和分发.NET类型* 中，我们创建了一个包含用于检查有效XML、密码和十六进制代码的函数的类库。
- en: 'If we had wanted to make those methods conform to an interface that requires
    a `Task<T>` to be returned, we could use these helpful methods, as shown in the
    following code:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使这些方法符合要求返回 `Task<T>` 的接口，我们可以使用下面代码中所示的这些有用的方法：
- en: '```cs'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: using
- en: System.Text.RegularExpressions;
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: System.Text.RegularExpressions;
- en: namespace
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: namespace
- en: Packt.Shared
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: ;
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: static
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: static
- en: class
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: class
- en: StringExtensions
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: StringExtensions
- en: '{'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: static
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: static
- en: Task<
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: Task<
- en: bool
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: bool
- en: '>'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: IsValidXmlTagAsync
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: IsValidXmlTagAsync
- en: (
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: this
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: this
- en: string
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: input
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: input
- en: )
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: if
- en: (input == null
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: (input == null
- en: )
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: Task.FromException<bool
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: Task.FromException<bool
- en: '>('
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: new
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: new
- en: ArgumentNullException("Missing input parameter"
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: ArgumentNullException("缺少输入参数"
- en: ));
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: '}'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: if
- en: (input.Length == 0
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: (input.Length == 0
- en: )
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: Task.FromException<bool
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: Task.FromException<bool
- en: '>('
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: new
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: new
- en: ArgumentException("input parameter is empty."
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: ArgumentException("输入参数为空。"
- en: ));
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: '}'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: Task.FromResult(Regex.IsMatch(input,
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: Task.FromResult(Regex.IsMatch(input,
- en: '@"^<([a-z]+)([^<]+)*(?:>(.*)<\/\1>|\s+\/>)$"'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '@"^<([a-z]+)([^<]+)*(?:>(.*)<\/\1>|\s+\/>)$"'
- en: ));
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: '}'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: // other methods
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: // 其他方法
- en: '}'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If the method you need to implement returns a `Task` (equivalent to `void`
    in a synchronous method) then you can return a predefined completed `Task` object,
    as shown in the following code:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要实现的方法返回一个 `Task`（相当于同步方法中的 `void`），那么您可以返回一个预定义的已完成的 `Task` 对象，如下面的代码所示：
- en: '```cs'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: Task
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: Task
- en: DeleteCustomerAsync
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: DeleteCustomerAsync
- en: ()
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // ...
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: return
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: Task.CompletedTask;
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: Task.CompletedTask;
- en: '}'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Synchronizing access to shared resources
  id: totrans-790
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步访问共享资源
- en: When you have multiple threads executing at the same time, there is a possibility
    that two or more of the threads may access the same variable or another resource
    at the same time, and as a result, may cause a problem. For this reason, you should
    carefully consider how to make your code **thread-safe** .
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个线程同时执行时，有可能两个或更多的线程同时访问同一个变量或其他资源，从而可能导致问题。因此，您应该仔细考虑如何使您的代码**线程安全**。
- en: The simplest mechanism for implementing thread safety is to use an object variable
    as a flag or traffic light to indicate when a shared resource has an exclusive
    lock applied.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 实现线程安全的最简单机制是使用一个对象变量作为标志或交通灯，指示共享资源何时应用了独占锁。
- en: In William Golding's *Lord of the Flies* , Piggy and Ralph spot a conch shell
    and use it to call a meeting. The boys impose a "rule of the conch" on themselves,
    deciding that no one can speak unless they're holding the conch.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 在威廉·戈尔丁的《蝇王》中，皮基和拉尔夫发现了一只海螺壳，并用它召开会议。男孩们对自己实施了“海螺规则”，决定除非他们拿着海螺，否则谁也不能说话。
- en: I like to name the object variable I use for implementing thread-safe code the
    "conch." When a thread has the conch, no other thread should access the shared
    resource(s) represented by that conch. Note that I say, *should* . Only code that
    respects the conch enables synchronized access. A conch is not a lock.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢给用于实现线程安全代码的对象变量命名为“conch”。当一个线程拥有了conch，其他线程就不应该访问由该conch表示的共享资源。请注意，我说的是*应该*。只有尊重conch的代码才能实现同步访问。conch不是锁。
- en: 'We will explore a couple of types that can be used to synchronize access to
    shared resources:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨一些可以用来同步访问共享资源的类型：
- en: '`Monitor` : An object that can be used by multiple threads to check if they
    should access a shared resource within the same process.'
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Monitor`：一个可以被多个线程使用的对象，用于检查它们是否应该在同一个进程中访问共享资源。'
- en: '`Interlocked` : An object for manipulating simple numeric types at the CPU
    level.'
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Interlocked`：一个用于在CPU级别操作简单数值类型的对象。'
- en: Accessing a resource from multiple threads
  id: totrans-798
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从多个线程访问资源
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `SynchronizingResourceAccess` .
  id: totrans-799
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的代码编辑器向 `Chapter12` 解决方案/工作区中添加一个名为 `SynchronizingResourceAccess` 的新控制台应用程序。
- en: In Visual Studio Code, select `SynchronizingResourceAccess` as the active OmniSharp
    project.
  id: totrans-800
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中，将`SynchronizingResourceAccess`选择为活动的OmniSharp项目。
- en: 'In `Program.cs` , delete the existing statements and then add statements to
    do the following:'
  id: totrans-801
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有的语句，然后添加语句以执行以下操作：
- en: Import the namespace for diagnostic types like `Stopwatch` .
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入诊断类型的命名空间，如`Stopwatch`。
- en: Statically import the `Console` type.
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态地导入`Console`类型。
- en: 'At the bottom of `Program.cs` , create a static class with two fields:'
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Program.cs`的底部，创建一个带有两个字段的静态类：
- en: A field to generate random wait times.
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字段来生成随机等待时间。
- en: A `string` field to store a message (this is a shared resource).
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`string`字段来存储消息（这是一个共享资源）。
- en: 'Above the class, create two static methods that add a letter, A or B, to the
    shared `string` five times in a loop, and wait for a random interval of up to
    2 seconds for each iteration:'
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类的上方，创建两个静态方法，在循环中向共享的`string`添加五次字母A或B，并等待每次迭代的随机间隔最多2秒：
- en: '```cs'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: static
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: void
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: MethodA
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: MethodA
- en: ()
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: for
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 为
- en: (int
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: (int
- en: i = 0
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: ; i < 5
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: ; i < 5
- en: ; i++)
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: ; i ++)
- en: '{'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Thread.Sleep(SharedObjects.Random.Next(2000
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 线程休眠(SharedObjects.Random.Next(2000
- en: ));
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: SharedObjects.Message += "A"
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: SharedObjects.Message += "A"
- en: ;
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: Write("."
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 写("."
- en: );
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: static
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: void
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: MethodB
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: MethodB
- en: ()
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: for
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 为
- en: (int
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: (int
- en: i = 0
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: ; i < 5
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: ; i < 5
- en: ; i++)
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: ; i ++)
- en: '{'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Thread.Sleep(SharedObjects.Random.Next(2000
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 线程休眠(SharedObjects.Random.Next(2000
- en: ));
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: SharedObjects.Message += "B"
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: SharedObjects.Message += "B"
- en: ;
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: Write("."
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: Write("."
- en: );
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: static
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: class
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: SharedObjects
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: SharedObjects
- en: '{'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: static
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: Random Random = new
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: Random Random = new
- en: ();
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: public
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: static
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: string
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: '? Message; // a shared resource'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: ？消息； // 一个共享资源
- en: '}'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'After the namespace imports, write statements to execute both methods on separate
    threads using a pair of tasks and wait for them to complete before outputting
    the elapsed milliseconds, as shown in the following code:'
  id: totrans-861
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命名空间导入之后，编写语句以使用一对任务在单独的线程上执行两种方法，并在输出经过的毫秒数之前等待它们完成，如下面的代码所示：
- en: '```cs'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: WriteLine("Please wait for the tasks to complete."
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("请等待任务完成。"
- en: );
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Stopwatch watch = Stopwatch.StartNew();
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: Stopwatch watch = Stopwatch.StartNew();
- en: Task a = Task.Factory.StartNew(MethodA);
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 任务a = Task.Factory.StartNew(MethodA);
- en: Task b = Task.Factory.StartNew(MethodB);
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 任务b = Task.Factory.StartNew(MethodB);
- en: Task.WaitAll(new
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: Task.WaitAll(new
- en: Task[] { a, b });
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 任务[] { a, b });
- en: WriteLine();
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine();
- en: 'WriteLine($"Results:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"结果：
- en: '{SharedObjects.Message}'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '{SharedObjects.Message}'
- en: ."
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: ."
- en: );
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: WriteLine($"
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{watch.ElapsedMilliseconds:N0}'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '{watch.ElapsedMilliseconds:N0}'
- en: elapsed milliseconds."
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 经过的毫秒数。"
- en: );
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-880
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Please wait for the tasks to complete.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 请等待任务完成。
- en: '..........'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '..........'
- en: 'Results: BABABAABBA.'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 结果：BABABAABBA。
- en: 5,753 elapsed milliseconds.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 经过了5,753毫秒。
- en: '```'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This shows that both threads were modifying the message concurrently. In an
    actual application, this could be a problem. But we can prevent concurrent access
    by applying a mutually exclusive lock to a conch object and code to the two methods
    to voluntarily check the conch before modifying the shared resource, which we
    will do in the following section.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明两个线程同时修改了消息。在实际应用中，这可能是一个问题。但是我们可以通过对海螺对象应用互斥锁并在两种方法中自愿检查海螺来防止并发访问，我们将在下一节中进行。
- en: Applying a mutually exclusive lock to a conch
  id: totrans-888
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对海螺应用互斥锁
- en: Now, let's use a conch to ensure that only one thread accesses the shared resource
    at a time.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用海螺确保只有一个线程一次访问共享资源。
- en: 'In `SharedObjects` , declare and instantiate an `object` variable to act as
    a conch, as shown in the following code:'
  id: totrans-890
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedObjects`中，声明并实例化一个`object`变量，作为一个海螺，如下面的代码所示：
- en: '```cs'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: static
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: object
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: object
- en: Conch = new
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: Conch = new
- en: ();
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: '```'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In both `MethodA` and `MethodB` , add a `lock` statement for the conch around
    the `for` statements, as shown highlighted in the following code:'
  id: totrans-898
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MethodA`和`MethodB`中，为海螺周围的`for`语句添加一个`lock`语句，如下面的代码中所突出显示的那样：
- en: '```cs'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '**lock**'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '**锁**'
- en: '**(SharedObjects.Conch)**'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '**(SharedObjects.Conch)**'
- en: '**{**'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: '**{**'
- en: for
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 为
- en: (int
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: (int
- en: i = 0
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: i = 0
- en: ; i < 5
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: ; i < 5
- en: ; i++)
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: ; i ++)
- en: '{'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Thread.Sleep(SharedObjects.Random.Next(2000
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 线程休眠(SharedObjects.Random.Next(2000
- en: ));
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: ));
- en: SharedObjects.Message += "A"
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: SharedObjects.Message += "A"
- en: ;
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: Write("."
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: Write("."
- en: );
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '**}**'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '**}**'
- en: '```'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : Note that since checking the conch is voluntary, if you
    only use the `lock` statement in one of the two methods, the shared resource will
    continue to be accessed by both methods. Make sure that all methods that access
    a shared resource respect the conch.'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：请注意，由于检查海螺是自愿的，如果您只在两种方法中的一个中使用`lock`语句，则共享资源将继续被两种方法访问。确保所有访问共享资源的方法都尊重海螺。'
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-919
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：
- en: '```cs'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Please wait for the tasks to complete.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 请等待任务完成。
- en: '..........'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '..........'
- en: 'Results: BBBBBAAAAA.'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 结果：BBBBBAAAAA。
- en: 10,345 elapsed milliseconds.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 经过了10,345毫秒。
- en: '```'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Although the time elapsed was longer, only one method at a time could access
    the shared resource. Either `MethodA` or `MethodB` can start first. Once a method
    has finished its work on the shared resource, then the conch gets released, and
    the other method has the chance to do its work.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管经过的时间更长，但一次只能有一个方法访问共享资源。`MethodA`或`MethodB`可以先开始。一旦一个方法完成了对共享资源的工作，那么海螺就被释放，另一个方法就有机会做它的工作。
- en: Understanding the lock statement
  id: totrans-927
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解锁定语句
- en: 'You might wonder what the `lock` statement does when it "locks" an object variable
    (hint: it does not lock the object!), as shown in the following code:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 当“锁”语句“锁定”对象变量时，您可能会想知道它的作用（提示：它不会锁定对象！），如下面的代码所示：
- en: '```cs'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: lock
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 锁
- en: (SharedObjects.Conch)
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: (SharedObjects.Conch)
- en: '{'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // work with shared resource
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用共享资源
- en: '}'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The C# compiler changes the `lock` statement into a `try` -`finally` statement
    that uses the `Monitor` class to *enter* and *exit* the conch object (I like to
    think of it as *take* and *release* the conch object), as shown in the following
    code:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: try
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: Monitor.Enter(SharedObjects.Conch);
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: // work with shared resource
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: finally
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: Monitor.Exit(SharedObjects.Conch);
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: When a thread calls `Monitor.Enter` on any object, aka reference type, it checks
    to see if some other thread has already taken the conch. If it has, the thread
    waits. If it has not, the thread takes the conch and gets on with its work on
    the shared resource. Once the thread has finished its work, it calls `Monitor.Exit`
    , releasing the conch. If another thread was waiting, it can now take the conch
    and do its work. This requires all threads to respect the conch by calling `Monitor.Enter`
    and `Monitor.Exit` appropriately.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding deadlocks
  id: totrans-949
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Knowing how the `lock` statement is translated by the compiler to method calls
    on the `Monitor` class is also important because using the `lock` statement can
    cause a deadlock.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: 'Deadlocks can occur when there are two or more shared resources (each with
    a conch to monitor which thread is currently doing work on each shared resource),
    and the following sequence of events happens:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: Thread X "locks" conch A and starts working on shared resource A.
  id: totrans-952
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread Y "locks" conch B and starts working on shared resource B.
  id: totrans-953
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While still working on resource A, thread X needs to also work with resource
    B, and so it attempts to "lock" conch B but is blocked because thread Y already
    has conch B.
  id: totrans-954
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While still working on resource B, thread Y needs to also work with resource
    A, and so it attempts to "lock" conch A but is blocked because thread X already
    has conch A.
  id: totrans-955
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One way to prevent deadlocks is to specify a timeout when attempting to get
    a lock. To do this, you must manually use the `Monitor` class instead of using
    the `lock` statement.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your code to replace the `lock` statements with code that tries to enter
    the conch with a timeout and outputs an error and then exits the monitor, allowing
    other threads to enter the monitor, as shown highlighted in the following code:'
  id: totrans-957
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: '**try**'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: '**if**'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: '**(Monitor.TryEnter(SharedObjects.Conch, TimeSpan.FromSeconds(**'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: '**15**'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: '**)))**'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: for
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: (int
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: i = 0
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: ; i < 5
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: ; i++)
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: Thread.Sleep(SharedObjects.Random.Next(2000
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: ));
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: SharedObjects.Message += "A"
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: Write("."
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: '**else**'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: '**WriteLine(**'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: '**"Method A timed out when entering a monitor on conch."**'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: '**);**'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: '**finally**'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: '**Monitor.Exit(SharedObjects.Conch);**'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and view the result, which should return the same results as before
    (although either A or B could grab the conch first) but is better code because
    it will prevent potential deadlocks.
  id: totrans-992
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice** : Only use the `lock` keyword if you can write your code
    such that it avoids potential deadlocks. If you cannot avoid potential deadlocks,
    then always use the `Monitor.TryEnter` method instead of `lock` , in combination
    with a `try` -`finally` statement, so that you can supply a timeout and one of
    the threads will back out of a deadlock if it occurs. You can read more about
    good threading practices at the following link: [https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices](https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices)'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing events
  id: totrans-994
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 6* , *Implementing Interfaces and Inheriting Classes* , you learned
    how to raise and handle events. But .NET events are not thread-safe, so you should
    avoid using them in multithreaded scenarios and follow the standard event raising
    code I showed you earlier.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: 'After learning that .NET events are not thread-safe, some developers attempt
    to use exclusive locks when adding and removing event handlers or when raising
    an event, as shown in the following code:'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: // event delegate field
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: event
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: EventHandler Shout;
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: // conch
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: private
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: private
- en: object
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: object
- en: eventLock = new
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: eventLock = new
- en: ();
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: // method
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: // 方法
- en: public
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: void
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Poke
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: Poke
- en: ()
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: lock
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: lock
- en: (eventLock) // bad idea
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: (eventLock) // 不好的主意
- en: '{'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // if something is listening...
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: // 如果有东西在监听...
- en: if
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: if
- en: (Shout != null
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: (Shout != null
- en: )
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // ...then call the delegate to raise the event
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: // ...然后调用委托来触发事件
- en: Shout(this
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: Shout(this
- en: ', EventArgs.Empty);'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: ', EventArgs.Empty);'
- en: '}'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : You can read more about events and thread-safety at the
    following link: [https://docs.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful](https://docs.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful)'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好的实践**：您可以在以下链接中了解有关事件和线程安全性的更多信息：[https://docs.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful](https://docs.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful)'
- en: 'But it is complicated, as explained by Stephen Cleary in the following blog
    post: [https://blog.stephencleary.com/2009/06/threadsafe-events.html](https://blog.stephencleary.com/2009/06/threadsafe-events.html)'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如Stephen Cleary在以下博客文章中所解释的那样，情况很复杂：[https://blog.stephencleary.com/2009/06/threadsafe-events.html](https://blog.stephencleary.com/2009/06/threadsafe-events.html)
- en: Making CPU operations atomic
  id: totrans-1030
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使CPU操作变为原子
- en: Atomic is from the Greek word **atomos** , which means *undividable* . It is
    important to understand which operations are atomic in multithreading because
    if they are not atomic, then they could be interrupted by another thread partway
    through their operation. Is the C# increment operator atomic, as shown in the
    following code?
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 原子来自希腊词 **atomos** ，意思是 *不可分割的*。了解多线程中哪些操作是原子的很重要，因为如果它们不是原子的，那么它们可能会在操作过程中被另一个线程中断。C#的增量运算符是原子的吗，如下面的代码所示？
- en: '```cs'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: x = 3
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: x = 3
- en: ;
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: x++; // is this an atomic CPU operation?
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: x++; // 这是一个原子CPU操作吗？
- en: '```'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'It is not atomic! Incrementing an integer requires the following three CPU
    operations:'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是原子的！增加整数需要以下三个CPU操作：
- en: Load a value from an instance variable into a register.
  id: totrans-1039
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将实例变量的值加载到寄存器中。
- en: Increment the value.
  id: totrans-1040
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加值。
- en: Store the value in the instance variable.
  id: totrans-1041
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值存储在实例变量中。
- en: A thread could be interrupted after executing the first two steps. A second
    thread could then execute all three steps. When the first thread resumes execution,
    it will overwrite the value in the variable, and the effect of the increment or
    decrement performed by the second thread will be lost!
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 一个线程在执行前两个步骤后可能会被中断。然后第二个线程可能执行所有三个步骤。当第一个线程恢复执行时，它将覆盖变量中的值，并且第二个线程执行的增量或减量的效果将丢失！
- en: 'There is a type named `Interlocked` that can perform atomic actions on value
    types, such as integers and floats. Let''s see it in action:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`Interlocked`的类型，可以对值类型（如整数和浮点数）执行原子操作。让我们看看它的运行情况：
- en: 'Declare another field in the `SharedObjects` class that will count how many
    operations have occurred, as shown in the following code:'
  id: totrans-1044
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedObjects`类中声明另一个字段，用于计算已发生的操作次数，如下面的代码所示：
- en: '```cs'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: static
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: static
- en: int
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: Counter; // another shared resource
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: Counter; // 另一个共享资源
- en: '```'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In both methods A and B, inside the `for` statement and after modifying the
    `string` value, add a statement to safely increment the counter, as shown in the
    following code:'
  id: totrans-1051
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法A和B中，在`for`语句内和修改`string`值后，添加一个语句来安全地增加计数器，如下面的代码所示：
- en: '```cs'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Interlocked.Increment(ref
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: Interlocked.Increment(ref
- en: SharedObjects.Counter);
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: SharedObjects.Counter);
- en: '```'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'After outputting the elapsed time, write the current value of the counter to
    the console, as shown in the following code:'
  id: totrans-1056
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输出经过的时间后，将计数器的当前值写入控制台，如下面的代码所示：
- en: '```cs'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: WriteLine($"
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{SharedObjects.Counter}'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: '{SharedObjects.Counter}'
- en: string modifications."
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串修改。"
- en: );
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and view the result, as shown highlighted in the following output:'
  id: totrans-1063
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看结果，如下面的输出所示：```
- en: '```cs'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Please wait for the tasks to complete.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 请等待任务完成。
- en: '..........'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: '..........'
- en: 'Results: BBBBBAAAAA.'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 结果：BBBBBAAAAA。
- en: 13,531 elapsed milliseconds.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 13,531毫秒经过。
- en: '**10 string modifications.**'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: '**10个字符串修改。**'
- en: '```'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Observant readers will realize that the existing conch object protects all shared
    resources accessed within a block of code locked by the conch, and therefore it
    is actually unnecessary to use `Interlocked` in this specific example. But if
    we had not already been protecting another shared resource like `Message` then
    using `Interlocked` would be necessary.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 细心的读者会意识到现有的conch对象保护了由conch锁定的代码块内访问的所有共享资源，因此在这个特定的例子中实际上不需要在这里使用`Interlocked`。但是，如果我们没有已经保护像`Message`这样的另一个共享资源，那么使用`Interlocked`将是必要的。
- en: Applying other types of synchronization
  id: totrans-1072
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用其他类型的同步
- en: '`Monitor` and `Interlocked` are mutually exclusive locks that are simple and
    effective, but sometimes, you need more advanced options to synchronize access
    to shared resources, as shown in the following table:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: '`Monitor` 和 `Interlocked` 是相互排斥的锁，简单而有效，但有时，您需要更高级的选项来同步对共享资源的访问，如下表所示：'
- en: '| Type | Description |'
  id: totrans-1074
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| `ReaderWriterLock` and `ReaderWriterLockSlim` | These allow multiple threads
    to be in **read mode** , one thread to be in **write mode** with exclusive ownership
    of the write lock, and one thread that has read access to be in **upgradeable
    read mode** , from which the thread can upgrade to write mode without having to
    relinquish its read access to the resource. |'
  id: totrans-1075
  prefs: []
  type: TYPE_TB
  zh: '| `ReaderWriterLock` 和 `ReaderWriterLockSlim` | 这允许多个线程处于**读模式**，一个线程处于具有写锁的**写模式**，并且一个具有读访问权限的线程处于**可升级读模式**，从中线程可以升级到写模式，而无需放弃对资源的读访问权限。
    |'
- en: '| `Mutex` | Like `Monitor` , this provides exclusive access to a shared resource,
    except it is used for inter-process synchronization. |'
  id: totrans-1076
  prefs: []
  type: TYPE_TB
  zh: '| `Mutex` | 像 `Monitor` 一样，它提供对共享资源的独占访问，但它用于进程间同步。 |'
- en: '| `Semaphore` and `SemaphoreSlim` | These limit the number of threads that
    can access a resource or pool of resources concurrently by defining slots. This
    is known as resource throttling rather than resource locking. |'
  id: totrans-1077
  prefs: []
  type: TYPE_TB
  zh: '| `Semaphore` 和 `SemaphoreSlim` | 这些通过定义插槽来限制可以同时访问资源或资源池的线程数量。这被称为资源限流，而不是资源锁定。
    |'
- en: '| `AutoResetEvent` and `ManualResetEvent` | Event wait handles allow threads
    to synchronize activities by signaling each other and by waiting for each other''s
    signals. |'
  id: totrans-1078
  prefs: []
  type: TYPE_TB
- en: Understanding async and await
  id: totrans-1079
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C# 5 introduced two C# keywords when working with the `Task` type. They are
    especially useful for the following:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: Implementing multitasking for a **graphical user interface** (**GUI** ).
  id: totrans-1081
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the scalability of web applications and web services.
  id: totrans-1082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Chapter 15* , *Building Websites Using the Model-View-Controller Pattern*
    , we will see how the `async` and `await` keywords can improve scalability for
    websites.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 19* , *Building Mobile and Desktop Apps Using .NET MAUI* , we will
    see how the `async` and `await` keywords can implement multitasking for a GUI.
    You can find it at [https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf](https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf)
    .
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: But for now, let's learn the theory of why these two C# keywords were introduced,
    and then later you will see them used in practice.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: Improving responsiveness for console apps
  id: totrans-1086
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the limitations with console applications is that you can only use the
    `await` keyword inside methods that are marked as `async` but C# 7 and earlier
    do not allow the `Main` method to be marked as async! Luckily, a new feature introduced
    in C# 7.1 was support for `async` in `Main` :'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `AsyncConsole` .
  id: totrans-1088
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `AsyncConsole` as the active OmniSharp project.
  id: totrans-1089
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs` , delete the existing statements and statically import `Console`
    , as shown in the following code:'
  id: totrans-1090
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: using
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: System.Console;
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to create an `HttpClient` instance, make a request for Apple''s
    home page, and output how many bytes it has, as shown in the following code:'
  id: totrans-1096
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: HttpClient client = new
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: ();
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: HttpResponseMessage response =
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: await
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
- en: client.GetAsync("http://www.apple.com/"
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Apple's home page has {0:N0} bytes."
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: ','
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: response.Content.Headers.ContentLength);
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the project and note that it builds successfully. In .NET 5 and earlier,
    you would have seen an error message, as shown in the following output:'
  id: totrans-1108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: 'Program.cs(14,9): error CS4033: The ''await'' operator can only be used within
    an async method. Consider marking this method with the ''async'' modifier and
    changing its return type to ''Task''. [/Users/markjprice/Code/ Chapter12/AsyncConsole/AsyncConsole.csproj]'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: You would have had to add the `async` keyword to the `Main` method and change
    its return type to `Task` . With .NET 6 and later, the console app project template
    uses the top-level program feature to automatically define the `Program` class
    with an asynchronous `Main` method for you.
  id: totrans-1112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, which is likely to have a different number
    of bytes since Apple changes its home page frequently, as shown in the following
    output:'
  id: totrans-1113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: Apple's home page has 40,252 bytes.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: Improving responsiveness for GUI apps
  id: totrans-1117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far in this book, we have only built console applications. Life for a programmer
    gets more complicated when building web applications, web services, and apps with
    GUIs such as Windows desktop and mobile apps.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: 'One reason for this is that for a GUI app, there is a special thread: the **user
    interface** (**UI** ) thread.'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two rules for working in GUIs:'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: Do not perform long-running tasks on the UI thread.
  id: totrans-1121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not access UI elements on any thread except the UI thread.
  id: totrans-1122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To handle these rules, programmers used to have to write complex code to ensure
    that long- running tasks were executed by a non-UI thread, but once complete,
    the results of the task were safely passed to the UI thread to present to the
    user. It could quickly get messy!
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, with C# 5 and later, you have the use of `async` and `await` . They
    allow you to continue to write your code as if it is synchronous, which keeps
    your code clean and easy to understand, but underneath, the C# compiler creates
    a complex state machine and keeps track of running threads. It's kind of magical!
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
- en: Let's see an example. We will build a Windows desktop app using WPF that gets
    employees from the Northwind database in an SQL Server database using low-level
    types like `SqlConnection` , `SqlCommand` , and `SqlDataReader` . You will only
    be able to complete this task if you have Windows and the Northwind database stored
    in SQL Server. This is the only section in this book that is not cross-platform
    and modern (WPF is 16 years old!).
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are focusing on making a GUI app responsive. You will learn
    about XAML and building cross-platform GUI apps in *Chapter 19* , *Building Mobile
    and Desktop Apps Using .NET MAUI* (available at [https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf](https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf)
    ). Since this book does not cover WPF elsewhere, I thought this task would be
    a good opportunity to at least see an example app built using WPF even if we do
    not look at it in detail.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: Let's go!
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio 2022 for Windows, add a new **WPF Application
    [C#]** project named `WpfResponsive` to the `Chapter12` solution. If you are using
    Visual Studio Code, use the following command: `dotnet new wpf` .'
  id: totrans-1128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the project file, note the output type is a Windows EXE, the target framework
    is .NET 6 for Windows (it will not run on other platforms like macOS and Linux),
    and the project uses WPF.
  id: totrans-1129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a package reference for `Microsoft.Data.SqlClient` to the project, as shown
    highlighted in the following markup:'
  id: totrans-1130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: <Project Sdk="Microsoft.NET.Sdk"
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: <PropertyGroup>
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: <OutputType>WinExe</OutputType>
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: <TargetFramework>net6.0
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: -windows</TargetFramework>
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: <Nullable>enable</Nullable>
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: <UseWPF>true
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: </UseWPF>
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: </PropertyGroup>
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: '**<ItemGroup>**'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: '**<PackageReference Include=**'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: '**"Microsoft.Data.SqlClient"**'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: '**Version=**'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: '**"3.0.0"**'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: '**/>**'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: '**</ItemGroup>**'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: </Project>
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: Build the project to restore packages.
  id: totrans-1151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `MainWindow.xaml` , in the `<Grid>` element, add elements to define two
    buttons, a text box and a list box, laid out vertically in a stack panel, as shown
    highlighted in the following markup:'
  id: totrans-1152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: <
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: Grid
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: '**<**'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: '**StackPanel**'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: '**>**'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: '**<**'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: '**Button**'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: '**"GetEmployeesSyncButton"**'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: '**Click**'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: '**"GetEmployeesSyncButton_Click"**'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: '**>**'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: '**Get Employees Synchronously**'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: '**</**'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: '**Button**'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: '**>**'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: '**<**'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: '**Button**'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: '**"GetEmployeesAsyncButton"**'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: '**Click**'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: '**"GetEmployeesAsyncButton_Click"**'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: '**>**'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: '**Get Employees Asynchronously**'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: '**</**'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: '**Button**'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: '**>**'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: '**<**'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: '**TextBox**'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: '**HorizontalAlignment**'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: '**"Stretch"**'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: '**Text**'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: '**"Type in here"**'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: '**/>**'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: '**<**'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: '**ListBox**'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: '**"EmployeesListBox"**'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: '**Height**'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: '**=**'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: '**"400"**'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: '**/>**'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: '**</**'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
- en: '**StackPanel**'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: '**>**'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: </
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: Grid
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 for Windows has good support for building WPF apps and will
    provide IntelliSense as you edit code and XAML markup. Visual Studio Code does
    not.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MainWindow.xaml.cs` , in the `MainWindow` class, import the `System.Diagnostics`
    and `Microsoft.Data.SqlClient` namespaces, then create two `string` constants
    for the database connection string and SQL statement and create event handlers
    for clicking on the two buttons that use those `string` constants to open a connection
    to the Northwind database and populate the list box with the ids and names of
    all employees, as shown in the following code:'
  id: totrans-1212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: private
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: const
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: connectionString =
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: '"Data Source=.;"'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: +
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: '"Initial Catalog=Northwind;"'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: +
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
- en: '"Integrated Security=true;"'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: +
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: '"MultipleActiveResultSets=true;"'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
- en: private
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: const
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: sql =
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: '"WAITFOR DELAY ''00:00:05'';"'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: +
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: '"SELECT EmployeeId, FirstName, LastName FROM Employees"'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
- en: private
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: GetEmployeesSyncButton_Click
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: object
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: sender, RoutedEventArgs e
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: Stopwatch timer = Stopwatch.StartNew();
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
- en: using
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: (SqlConnection connection = new
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: (connectionString))
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: connection.Open();
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
- en: SqlCommand command = new
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: (sql, connection);
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: SqlDataReader reader = command.ExecuteReader();
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: while
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: (reader.Read())
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
- en: employee = string
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: '.Format("{0}: {1} {2}"'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: ','
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: reader.GetInt32(0
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: ), reader.GetString(1
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: ), reader.GetString(2
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: ));
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: EmployeesListBox.Items.Add(employee);
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: reader.Close();
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: connection.Close();
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: 'EmployeesListBox.Items.Add($"Sync:'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: '{timer.ElapsedMilliseconds:N0}'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: ms"
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: private
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: async
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: GetEmployeesAsyncButton_Click
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: object
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: sender, RoutedEventArgs e
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: Stopwatch timer = Stopwatch.StartNew();
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: using
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
- en: (SqlConnection connection = new
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: (connectionString))
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
- en: await
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: connection.OpenAsync();
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: SqlCommand command = new
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: (sql, connection);
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
- en: SqlDataReader reader = await
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
- en: command.ExecuteReaderAsync();
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
- en: while
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
- en: (await
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
- en: reader.ReadAsync())
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: employee = string
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: '.Format("{0}: {1} {2}"'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: ','
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: await
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
- en: reader.GetFieldValueAsync<int
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: '>(0'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: ),
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
- en: await
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: reader.GetFieldValueAsync<string
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: '>(1'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: ),
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
- en: await
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
- en: reader.GetFieldValueAsync<string
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
- en: '>(2'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: ));
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
- en: EmployeesListBox.Items.Add(employee);
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: await
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
- en: reader.CloseAsync();
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
- en: await
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
- en: connection.CloseAsync();
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
- en: 'EmployeesListBox.Items.Add($"Async:'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
- en: '{timer.ElapsedMilliseconds:N0}'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: ms"
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following:'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
- en: The SQL statement uses the SQL Server command `WAITFOR DELAY` to simulate processing
    that takes five seconds. It then selects three columns from the `Employees` table.
  id: totrans-1326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GetEmployeesSyncButton_Click` event handler uses synchronous methods to
    open a connection and fetch the employee rows.
  id: totrans-1327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GetEmployeesAsyncButton_Click` event handler is marked as `async` and uses
    asynchronous methods with the `await` keyword to open a connection and fetch the
    employee rows.
  id: totrans-1328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both event handlers use a stopwatch to record the number of milliseconds the
    operation takes and add it to the list box.
  id: totrans-1329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start the WPF app without debugging.
  id: totrans-1330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click in the text box, enter some text, and note the GUI is responsive.
  id: totrans-1331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Get Employees Synchronously** button.
  id: totrans-1332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to click in the text box, and note the GUI is not responsive.
  id: totrans-1333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for at least five seconds until the list box is filled with employees.
  id: totrans-1334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click in the text box, enter some text, and note the GUI is responsive again.
  id: totrans-1335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Get Employees Asynchronously** button.
  id: totrans-1336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click in the text box, enter some text, and note the GUI is still responsive
    while it performs the operation. Continue typing until the list box is filled
    with the employees.
  id: totrans-1337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note the difference in timings for the two operations. The UI is blocked when
    fetching data synchronously, while the UI remains responsive when fetching data
    asynchronously.
  id: totrans-1338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the WPF app.
  id: totrans-1339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Improving scalability for web applications and web services
  id: totrans-1340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `async` and `await` keywords can also be applied on the server side when
    building websites, applications, and services. From the client application's point
    of view, nothing changes (or they might even notice a small increase in the time
    taken for a request to return). So, from a single client's point of view, the
    use of `async` and `await` to implement multitasking on the server side makes
    their experience worse!
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
- en: On the server side, additional, cheaper worker threads are created to wait for
    long-running tasks to finish so that expensive I/O threads can handle other client
    requests instead of being blocked. This improves the overall scalability of a
    web application or service. More clients can be supported simultaneously.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
- en: Common types that support multitasking
  id: totrans-1343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many common types that have asynchronous methods that you can await,
    as shown in the following table:'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Methods |'
  id: totrans-1345
  prefs: []
  type: TYPE_TB
- en: '| `DbContext<T>` | `AddAsync` , `AddRangeAsync` , `FindAsync` , and `SaveChangesAsync`
    |'
  id: totrans-1346
  prefs: []
  type: TYPE_TB
- en: '| `DbSet<T>` | `AddAsync` , `AddRangeAsync` , `ForEachAsync` , `SumAsync` ,
    `ToListAsync` , `ToDictionaryAsync` , `AverageAsync` , and `CountAsync` |'
  id: totrans-1347
  prefs: []
  type: TYPE_TB
- en: '| `HttpClient` | `GetAsync` , `PostAsync` , `PutAsync` , `DeleteAsync` , and
    `SendAsync` |'
  id: totrans-1348
  prefs: []
  type: TYPE_TB
- en: '| `StreamReader` | `ReadAsync` , `ReadLineAsync` , and `ReadToEndAsync` |'
  id: totrans-1349
  prefs: []
  type: TYPE_TB
- en: '| `StreamWriter` | `WriteAsync` , `WriteLineAsync` , and `FlushAsync` |'
  id: totrans-1350
  prefs: []
  type: TYPE_TB
- en: '**Good Practice** : Any time you see a method that ends in the suffix `Async`
    , check to see whether it returns `Task` or `Task<T>` . If it does, then you could
    use it instead of the synchronous non-`Async` suffixed method. Remember to call
    it using `await` and decorate your method with `async` .'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
- en: Using await in catch blocks
  id: totrans-1352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When `async` and `await` were first introduced in C# 5, it was only possible
    to use the `await` keyword in a `try` block, but not in a `catch` block. In C#
    6 and later, it is now possible to use `await` in both `try` and `catch` blocks.
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
- en: Working with async streams
  id: totrans-1354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With .NET Core 3.0, Microsoft introduced the asynchronous processing of streams.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
- en: 'You can complete a tutorial about async streams at the following link: [https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream](https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream)'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
- en: Before C# 8.0 and .NET Core 3.0, the `await` keyword only worked with tasks
    that return scalar values. Async stream support in .NET Standard 2.1 allows an
    `async` method to return a sequence of values.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
- en: Let's see a simulated example that returns three random integers as an async
    stream.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app to the `Chapter12` solution/workspace
    named `AsyncEnumerable` .
  id: totrans-1359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `AsyncEnumerable` as the active OmniSharp project.
  id: totrans-1360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs` , delete the existing statements and statically import `Console`
    , as shown in the following code:'
  id: totrans-1361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
- en: using
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
- en: System.Console; // WriteLine()
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , create a method that uses the `yield` keyword
    to return a random sequence of three numbers asynchronously, as shown in the following
    code:'
  id: totrans-1367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
- en: async
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
- en: IAsyncEnumerable<
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
- en: GetNumbersAsync
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
- en: Random r = new
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
- en: ();
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
- en: // simulate work
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
- en: await
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
- en: Task.Delay(r.Next(1500
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
- en: ', 3000'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
- en: ));
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
- en: yield
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
- en: return
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
- en: r.Next(0
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
- en: ', 1001'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
- en: await
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
- en: Task.Delay(r.Next(1500
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
- en: ', 3000'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
- en: ));
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
- en: yield
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
- en: return
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
- en: r.Next(0
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
- en: ', 1001'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
- en: await
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
- en: Task.Delay(r.Next(1500
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
- en: ', 3000'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: ));
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
- en: yield
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
- en: return
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
- en: r.Next(0
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
- en: ', 1001'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
- en: 'Above `GetNumbersAsync` , add statements to enumerate the sequence of numbers,
    as shown in the following code:'
  id: totrans-1409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: await
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
- en: (int
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
- en: number
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
- en: in
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: GetNumbersAsync
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
- en: ())
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Number:'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
- en: '{number}'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
- en: 'Number: 509'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
- en: 'Number: 813'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: 'Number: 307'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  id: totrans-1431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore this chapter's topics with deeper research.
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.1 – Test your knowledge
  id: totrans-1433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: What information can you find out about a process?
  id: totrans-1435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How accurate is the `Stopwatch` class?
  id: totrans-1436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By convention, what suffix should be applied to a method that returns `Task`
    or `Task<T>` ?
  id: totrans-1437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To use the `await` keyword inside a method, what keyword must be applied to
    the method declaration?
  id: totrans-1438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you create a child task?
  id: totrans-1439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you avoid the `lock` keyword?
  id: totrans-1440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use the `Interlocked` class?
  id: totrans-1441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use the `Mutex` class instead of the `Monitor` class?
  id: totrans-1442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of using `async` and `await` in a website or web service?
  id: totrans-1443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you cancel a task? If so, how?
  id: totrans-1444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 12.2 – Explore topics
  id: totrans-1445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following webpage to learn more detail about the topics
    covered in this chapter:'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-12---improving-performance-and-scalability-using-multitasking](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-12---improving-performance-and-scalability-using-multitasking)'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned not only how to define and start a task but also
    how to wait for one or more tasks to finish and how to control task completion
    order. You've also learned how to synchronize access to shared resources and the
    magic behind `async` and `await` .
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
- en: In the seven chapters that follow, you will learn how to create applications
    for the **app models** , aka **workloads** supported by .NET, such as websites
    and services, and cross-platform desktop and mobile apps.
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL

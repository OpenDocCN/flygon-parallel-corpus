- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing Practical Applications of C# and .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third and final part of this book is about practical applications of C#
    and .NET. You will learn how to build cross-platform projects such as websites,
    services, and mobile and desktop apps.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft calls platforms for building applications **app models** or **workloads**
    .
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapters 1* to *18* and *20* , you can use OS-specific Visual Studio or
    cross-platform Visual Studio Code and JetBrains Rider to build all the apps. In
    *Chapter 19* , *Building Mobile and Desktop Apps Using .NET MAUI* (available at
    [https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf](https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf)
    ) , although you could use Visual Studio Code to build the mobile and desktop
    app, it is not easy. Visual Studio 2022 for Windows has better support for .NET
    MAUI than Visual Studio Code does (for now).
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you work through this and subsequent chapters sequentially
    because later chapters will reference projects in earlier chapters, and you will
    build up sufficient knowledge and skills to tackle the trickier problems in later
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding app models for C# and .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New features in ASP.NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using other project templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an entity data model for Northwind
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding app models for C# and .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since this book is about C# 10 and .NET 6, we will learn about app models that
    use them to build the practical applications that we will encounter in the remaining
    chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Learn More** : Microsoft has extensive guidance for implementing app models
    in its .NET Application Architecture Guidance documentation, which you can read
    at the following link: [https://www.microsoft.com/net/learn/architecture](https://www.microsoft.com/net/learn/architecture)'
  prefs: []
  type: TYPE_NORMAL
- en: Building websites using ASP.NET Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Websites are made up of multiple web pages loaded statically from the filesystem
    or generated dynamically by a server-side technology such as ASP.NET Core. A web
    browser makes `GET` requests using **Unique Resource Locators** (**URLs** ) that
    identify each page and can manipulate data stored on the server using `POST` ,
    `PUT` , and `DELETE` requests.
  prefs: []
  type: TYPE_NORMAL
- en: With many websites, the web browser is treated as a presentation layer, with
    almost all the processing performed on the server side. Some JavaScript might
    be used on the client side to implement some presentation features, such as carousels.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core provides multiple technologies for building websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ASP.NET Core Razor Pages** and **Razor class libraries** are ways to dynamically
    generate HTML for simple websites. You will learn about them in detail in *Chapter
    14* , *Building Websites Using ASP.NET Core Razor Pages* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ASP.NET Core MVC** is an implementation of the **Model-View-Controller**
    (**MVC** ) design pattern that is popular for developing complex websites. You
    will learn about it in detail in *Chapter 15* , *Building Websites Using the Model-View-Controller
    Pattern* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blazor** lets you build user interface components using C# and .NET instead
    of a JavaScript-based UI framework like Angular, React, and Vue. **Blazor WebAssembly**
    runs your code in the browser like a JavaScript-based framework would. **Blazor
    Server** runs your code on the server and updates the web page dynamically. You
    will learn about Blazor in detail in *Chapter 17* , *Building User Interfaces
    Using Blazor* . Blazor is not just for building websites; it can also be used
    to create hybrid mobile and desktop apps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building websites using a content management system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most websites have a lot of content, and if developers had to be involved every
    time some content needed to be changed, that would not scale well. A **Content
    Management System** (**CMS** ) enables developers to define content structure
    and templates to provide consistency and good design while making it easy for
    a non-technical content owner to manage the actual content. They can create new
    pages or blocks of content, and update existing content, knowing it will look
    great for visitors with minimal effort.
  prefs: []
  type: TYPE_NORMAL
- en: There is a multitude of CMSs available for all web platforms, like WordPress
    for PHP or Django CMS for Python. CMSs that support modern .NET include Optimizely
    Content Cloud, Piranha CMS, and Orchard Core.
  prefs: []
  type: TYPE_NORMAL
- en: The key benefit of using a CMS is that it provides a friendly content management
    user interface. Content owners log in to the website and manage the content themselves.
    The content is then rendered and returned to visitors using ASP.NET Core MVC controllers
    and views, or via web service endpoints, known as a **headless CMS** , to provide
    that content to "heads" implemented as mobile or desktop apps, in-store touchpoints,
    or clients built with JavaScript frameworks or Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: 'This book does not cover .NET CMSs, so I have included links where you can
    learn more about them in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#net-content-management-systems](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#net-content-management-systems)'
  prefs: []
  type: TYPE_NORMAL
- en: Building web applications using SPA frameworks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Web applications, also known as **Single-Page Applications** (**SPAs** ), are
    made up of a single web page built with a frontend technology such as Blazor WebAssembly,
    Angular, React, Vue, or a proprietary JavaScript library that can make requests
    to a backend web service for getting more data when needed and posting updated
    data using common serialization formats such as XML and JSON. The canonical examples
    are Google web apps like Gmail, Maps, and Docs.
  prefs: []
  type: TYPE_NORMAL
- en: With a web application, the client side uses JavaScript frameworks or Blazor
    WebAssembly to implement sophisticated user interactions, but most of the important
    processing and data access still happens on the server side, because the web browser
    has limited access to local system resources.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is loosely typed and is not designed for complex projects, so most
    JavaScript libraries these days use Microsoft TypeScript, which adds strong typing
    to JavaScript and is designed with many modern language features for handling
    complex implementations.
  prefs: []
  type: TYPE_NORMAL
- en: .NET SDK has project templates for JavaScript and TypeScript-based SPAs, but
    we will not spend any time learning how to build JavaScript- and TypeScript-based
    SPAs in this book, even though these are commonly used with ASP.NET Core as the
    backend, because this book is about C#, it is not about other languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, C# and .NET can be used on both the server side and the client
    side to build websites, as shown in *Figure 13.1* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00100.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: The use of C# and .NET to build websites on both the server side
    and the client side'
  prefs: []
  type: TYPE_NORMAL
- en: Building web and other services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although we will not learn about JavaScript- and TypeScript-based SPAs, we will
    learn how to build a web service using the **ASP.NET Core Web API** , and then
    call that web service from the server-side code in our ASP.NET Core websites,
    and then later, we will call that web service from Blazor WebAssembly components
    and cross-platform mobile and desktop apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are no formal definitions, but services are sometimes described based
    on their complexity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Service** : all functionality needed by a client app in one monolithic service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservice** : multiple services that each focus on a smaller set of functionalities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nanoservice** : a single function provided as a service. Unlike services
    and microservices that are hosted 24/7/365, nanoservices are often inactive until
    called upon to reduce resources and costs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As well as web services that use HTTP as the underlying communication technology
    and the design principles of the API, we will learn how to build services using
    other technologies and design philosophies, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**gRPC** for building highly efficient and performant services with support
    for almost any platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SignalR** for building real-time communications between components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OData** for wrapping Entity Framework Core and other data models with a web
    API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GraphQL** for letting the client control what data is retrieved across multiple
    data sources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Functions** for hosting serverless nanoservices in the cloud.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building mobile and desktop apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two major mobile platforms: Apple''s iOS and Google''s Android, each
    with its own programming languages and platform APIs. There are also two major
    desktop platforms: Apple''s macOS and Microsoft''s Windows, each with its own
    programming languages and platform APIs, as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**iOS** : Objective C or Swift and UIkit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android** : Java or Kotlin and the Android API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**macOS** : Objective C or Swift and AppKit or Catalyst.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows** : C, C++, or many other languages and the Win32 API or Windows
    App SDK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since this book is about modern cross-platform development using C# and .NET
    it does not include coverage of building desktop apps using **Windows Forms**
    , **Windows Presentation Foundation** (**WPF** ), or **Universal Windows Platform**
    (**UWP** ) apps because they are Windows-only.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform mobile and desktop apps can be built once for the **.NET Multi-platform
    App User Interfaces** (**MAUI** ) platform, and then can run on many mobile and
    desktop platforms.
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI makes it easy to develop those apps by sharing user interface components
    as well as business logic. They can target the same .NET APIs as used by console
    apps, websites, and web services. The app will be executed by the Mono runtime
    on mobile devices and the CoreCLR runtime on desktop devices. The Mono runtime
    is better optimized for mobile devices compared to the normal .NET CoreCLR runtime.
    Blazor WebAssembly also uses the Mono runtime because like a mobile app, it is
    resource constrained.
  prefs: []
  type: TYPE_NORMAL
- en: The apps can exist on their own, but they usually call services to provide an
    experience that spans across all your computing devices, from servers and laptops
    to phones and gaming systems.
  prefs: []
  type: TYPE_NORMAL
- en: Future updates to .NET MAUI will support existing MVVM and XAML patterns as
    well as ones like **Model-View-Update** (**MVU** ) with C#, which is like Apple's
    Swift UI.
  prefs: []
  type: TYPE_NORMAL
- en: The penultimate chapter in this sixth edition is *Chapter 19* , *Building Mobile
    and Desktop Apps Using .NET MAUI* (available at [https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf](https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf)
    ) , and covers using .NET MAUI to build cross-platform mobile and desktop apps.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to .NET MAUI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before Microsoft created .NET MAUI, third parties created open-source initiatives
    to enable .NET developers to build cross-platform apps using XAML named **Uno**
    and **Avalonia** .
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Uno Platform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As Uno state on their website, it is "the first and only UI Platform for single-codebase
    applications for Windows, WebAssembly, iOS, macOS, Android, and Linux."
  prefs: []
  type: TYPE_NORMAL
- en: Developers can reuse 99% of the business logic and UI layer across native mobile,
    web, and desktop.
  prefs: []
  type: TYPE_NORMAL
- en: Uno Platform uses the Xamarin native platform but not Xamarin.Forms. For WebAssembly,
    Uno uses the Mono-WASM runtime just like Blazor WebAssembly. For Linux, Uno uses
    Skia to draw the user interface on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Avalonia
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As stated on .NET Foundation's website, Avalonia "is a cross-platform XAML-based
    UI framework providing a flexible styling system and supporting a wide range of
    Operating Systems such as Windows, Linux via Xorg, macOS. Avalonia is ready for
    General-Purpose Desktop App Development."
  prefs: []
  type: TYPE_NORMAL
- en: You can think of Avalonia as a spiritual successor to WPF. WPF, Silverlight,
    and UWP developers familiar with WPF can continue to benefit from their years
    of pre-existing knowledge and skills.
  prefs: []
  type: TYPE_NORMAL
- en: It was used by JetBrains to modernize their WPF-based tools and take them cross-platform.
  prefs: []
  type: TYPE_NORMAL
- en: The Avalonia extension for Visual Studio and deep integration with JetBrains
    Rider makes development easier and more productive.
  prefs: []
  type: TYPE_NORMAL
- en: New features in ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Over the past few years, Microsoft has rapidly expanded the capabilities of
    ASP.NET Core. You should note which .NET platforms are supported, as shown in
    the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 1.0 to 2.2 runs on either .NET Core or .NET Framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ASP.NET Core 3.0 or later only runs on .NET Core 3.0 or later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ASP.NET Core 1.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASP.NET Core 1.0 was released in June 2016 and focused on implementing a minimum
    API suitable for building modern cross-platform web apps and services for Windows,
    macOS, and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 1.1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASP.NET Core 1.1 was released in November 2016 and focused on bug fixes and
    general improvements to features and performance.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 2.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASP.NET Core 2.0 was released in August 2017 and focused on adding new features
    such as Razor Pages, bundling assemblies into a `Microsoft.AspNetCore.All` metapackage,
    targeting .NET Standard 2.0, providing a new authentication model, and performance
    improvements.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest new features introduced with ASP.NET Core 2.0 are ASP.NET Core Razor
    Pages, which is covered in *Chapter 14* , *Building Websites Using ASP.NET Core
    Razor Pages* , and ASP.NET Core OData support, which is covered in *Chapter 18*
    , *Building and Consuming Specialized Services* (available at [https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf](https://github.com/markjprice/cs10dotnet6/blob/main/9781801077361_Bonus_Content.pdf)
    ) .
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 2.1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASP.NET Core 2.1 was released in May 2018 and was a **Long Term Support** (**LTS**
    ) release, meaning it was supported for three years until August 21, 2021 (LTS
    designation was not officially assigned to it until August 2018 with version 2.1.3).
  prefs: []
  type: TYPE_NORMAL
- en: 'It focused on adding new features such as **SignalR** for real-time communication,
    **Razor class libraries** for reusing web components, **ASP.NET Core Identity**
    for authentication, and better support for HTTPS and the European Union''s **General
    Data Protection Regulation** (**GDPR** ), including the topics listed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Chapter | Topic |'
  prefs: []
  type: TYPE_TB
- en: '| Razor class libraries | 14 | Using Razor class libraries |'
  prefs: []
  type: TYPE_TB
- en: '| GDPR support | 15 | Creating and exploring an ASP.NET Core MVC website |'
  prefs: []
  type: TYPE_TB
- en: '| Identity UI library and scaffolding | 15 | Exploring an ASP.NET Core MVC
    website |'
  prefs: []
  type: TYPE_TB
- en: '| Integration tests | 15 | Testing an ASP.NET Core MVC website |'
  prefs: []
  type: TYPE_TB
- en: '| `[ApiController]` , `ActionResult<T>` | 16 | Creating an ASP.NET Core Web
    API project |'
  prefs: []
  type: TYPE_TB
- en: '| Problem details | 16 | Implementing a Web API controller |'
  prefs: []
  type: TYPE_TB
- en: '| `IHttpClientFactory` | 16 | Configuring HTTP clients using HttpClientFactory
    |'
  prefs: []
  type: TYPE_TB
- en: '| ASP.NET Core SignalR | 18 | Implementing Real-time communication using SignalR
    |'
  prefs: []
  type: TYPE_TB
- en: ASP.NET Core 2.2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ASP.NET Core 2.2 was released in December 2018 and focused on improving the
    building of RESTful HTTP APIs, updating the project templates to Bootstrap 4 and
    Angular 6, an optimized configuration for hosting in Azure, and performance improvements,
    including the topics listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Chapter | Topic |'
  prefs: []
  type: TYPE_TB
- en: '| HTTP/2 in Kestrel | 14 | Classic ASP.NET versus modern ASP.NET Core |'
  prefs: []
  type: TYPE_TB
- en: '| In-process hosting model | 14 | Creating an ASP.NET Core project |'
  prefs: []
  type: TYPE_TB
- en: '| Endpoint routing | 14 | Understanding endpoint routing |'
  prefs: []
  type: TYPE_TB
- en: '| Health Check API | 16 | Implementing a health check API |'
  prefs: []
  type: TYPE_TB
- en: '| Open API analyzers | 16 | Implementing Open API analyzers and conventions
    |'
  prefs: []
  type: TYPE_TB
- en: ASP.NET Core 3.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ASP.NET Core 3.0 was released in September 2019 and focused on fully leveraging
    .NET Core 3.0 and .NET Standard 2.1, which meant it could not support .NET Framework,
    and it added useful refinements, including the topics listed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Chapter | Topic |'
  prefs: []
  type: TYPE_TB
- en: '| Static assets in Razor class libraries | 14 | Using Razor class libraries
    |'
  prefs: []
  type: TYPE_TB
- en: '| New options for MVC service registration | 15 | Understanding ASP.NET Core
    MVC startup |'
  prefs: []
  type: TYPE_TB
- en: '| ASP.NET Core gRPC | 18 | Building services using ASP.NET Core gRPC |'
  prefs: []
  type: TYPE_TB
- en: '| Blazor Server | 17 | Building components using Blazor Server |'
  prefs: []
  type: TYPE_TB
- en: ASP.NET Core 3.1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASP.NET Core 3.1 was released in December 2019 and is an LTS release, meaning
    it will be supported until December 3, 2022\. It focused on refinements like partial
    class support for Razor components and a new `<component>` tag helper.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor WebAssembly 3.2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blazor WebAssembly 3.2 was released in May 2020\. It was a Current release,
    meaning that projects had to be upgraded to the .NET 5 version within three months
    of the .NET 5 release, that is, by February 10, 2021\. Microsoft finally delivered
    on the promise of full-stack web development with .NET, and both Blazor Server
    and Blazor WebAssembly are covered in *Chapter 17* , *Building User Interfaces
    Using Blazor* .
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 5.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ASP.NET Core 5.0 was released in November 2020 and focused on bug fixes, performance
    improvements using caching for certificate authentication, HPACK dynamic compression
    of HTTP/2 response headers in Kestrel, nullable annotations for ASP.NET Core assemblies,
    and a reduction in container image sizes, including the topics listed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Chapter | Topic |'
  prefs: []
  type: TYPE_TB
- en: '| Extension method to allow anonymous access to an endpoint | 16 | Securing
    web services |'
  prefs: []
  type: TYPE_TB
- en: '| JSON extension methods for `HttpRequest` and `HttpResponse` | 16 | Getting
    customers as JSON in the controller |'
  prefs: []
  type: TYPE_TB
- en: ASP.NET Core 6.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ASP.NET Core 6.0 was released in November 2021 and focused on productivity
    improvements like minimizing code to implement basic websites and services, .NET
    Hot Reload, and new hosting options for Blazor, like hybrid apps using .NET MAUI,
    including the topics listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Chapter | Topic |'
  prefs: []
  type: TYPE_TB
- en: '| New empty web project template | 14 | Understanding the empty web template
    |'
  prefs: []
  type: TYPE_TB
- en: '| HTTP logging middleware | 16 | Enabling HTTP logging |'
  prefs: []
  type: TYPE_TB
- en: '| Minimal APIs | 16 | Implementing minimal Web APIs |'
  prefs: []
  type: TYPE_TB
- en: '| Blazor error boundaries | 17 | Defining Blazor error boundaries |'
  prefs: []
  type: TYPE_TB
- en: '| Blazor WebAssembly AOT | 17 | Enabling Blazor WebAssembly ahead-of-time compilation
    |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Hot Reload | 17 | Fixing code using .NET Hot Reload |'
  prefs: []
  type: TYPE_TB
- en: '| .NET MAUI Blazor apps | 19 | Hosting Blazor components in .NET MAUI apps
    |'
  prefs: []
  type: TYPE_TB
- en: Building Windows-only desktop apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Technologies for building Windows-only desktop apps include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows Forms** , 2002.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows Presentation Foundation** (**WPF** ), 2006.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows Store** apps, 2012.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Universal Windows Platform** (**UWP** ) apps, 2015.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows App SDK** (formerly **WinUI 3** and **Project Reunion** ) apps, 2021.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding legacy Windows application platforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the Microsoft Windows 1.0 release in 1985, the only way to create Windows
    applications was to use the C language and call functions in three core DLLs named
    kernel, user, and GDI. Once Windows became 32-bit with Windows 95, the DLLs were
    suffixed with 32 and became known as **Win32 API** .
  prefs: []
  type: TYPE_NORMAL
- en: In 1991, Microsoft introduced Visual Basic, which provided developers with a
    visual, drag-and-drop-from-a-toolbox-of-controls way to build the user interface
    for Windows applications. It was immensely popular, and the Visual Basic runtime
    is still distributed as part of Windows 10 today.
  prefs: []
  type: TYPE_NORMAL
- en: With the first version of C# and .NET Framework released in 2002, Microsoft
    provided technology for building Windows desktop applications named **Windows
    Forms** . The equivalent at the time for web development was named **Web Forms**
    , hence the complimentary names. The code could be written in either Visual Basic
    or C# languages. Windows Forms had a similar drag-and-drop visual designer, although
    it generated C# or Visual Basic code to define the user interface, which can be
    difficult for humans to understand and edit directly.
  prefs: []
  type: TYPE_NORMAL
- en: In 2006, Microsoft released a more powerful technology for building Windows
    desktop applications, named **Windows Presentation Foundation** (**WPF** ), as
    a key component of .NET Framework 3.0 alongside **Windows Communication Foundation**
    (**WCF** ) and **Windows Workflow** (**WF** ).
  prefs: []
  type: TYPE_NORMAL
- en: Although a WPF app can be created by writing only C# statements, it can also
    use **eXtensible Application Markup Language** (**XAML** ) to specify its user
    interface, which is easy for both humans and code to understand. Visual Studio
    for Windows is partially built with WPF.
  prefs: []
  type: TYPE_NORMAL
- en: In 2012, Microsoft released Windows 8 with its Windows Store apps that run in
    a protected sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: In 2015, Microsoft released Windows 10 with an updated Windows Store app concept
    named **Universal Windows Platform** (**UWP** ). UWP apps can be built using C++
    and the DirectX UI, or JavaScript and HTML, or C# using a custom fork of modern
    .NET that is not cross-platform but provides full access to the underlying WinRT
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: UWP apps can only execute on the Windows 10 platform, not earlier versions of
    Windows, but UWP apps can run on Xbox and Windows Mixed Reality headsets with
    motion controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Many Windows developers rejected Windows Store and UWP apps because they have
    limited access to the underlying system. Microsoft recently created **Project
    Reunion** and **WinUI 3** , which work together to allow Windows developers to
    bring some of the benefits of modern Windows development to their existing WPF
    apps and allow them to have the same benefits and system integrations that UWP
    apps have. This initiative is now known as **Windows App SDK** .
  prefs: []
  type: TYPE_NORMAL
- en: Understanding modern .NET support for legacy Windows platforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The on-disk size of the .NET SDKs for Linux and macOS is about 330 MB. The on-disk
    size of the .NET SDK for Windows is about 440 MB. This is because it includes
    the Windows Desktop Runtime, which allows the legacy Windows application platforms
    Windows Forms and WPF to be run on modern .NET.
  prefs: []
  type: TYPE_NORMAL
- en: There are many enterprise applications built using Windows Forms and WPF that
    need to be maintained or enhanced with new features, but until recently they were
    stuck on .NET Framework, which is now a legacy platform. With modern .NET and
    its Windows Desktop Pack, these apps can now use the full modern capabilities
    of .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How should you structure your projects? So far, we have built small individual
    console apps to illustrate language or library features. In the rest of this book,
    we will build multiple projects using different technologies that work together
    to provide a single solution.
  prefs: []
  type: TYPE_NORMAL
- en: With large, complex solutions, it can be difficult to navigate amongst all the
    code. So, the primary reason to structure your projects is to make it easier to
    find components. It is good to have an overall name for your solution or workspace
    that reflects the application or solution.
  prefs: []
  type: TYPE_NORMAL
- en: We will build multiple projects for a fictional company named **Northwind**
    . We will name the solution or workspace `PracticalApps` and use the name `Northwind`
    as a prefix for all the project names.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to structure and name projects and solutions, for example,
    using a folder hierarchy as well as a naming convention. If you work in a team,
    make sure you know how your team does it.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring projects in a solution or workspace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is good to have a naming convention for your projects in a solution or workspace
    so that any developer can tell what each one does instantly. A common choice is
    to use the type of project, for example, class library, console app, website,
    and so on, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.Common` | A class library project for common types like interfaces,
    enums, classes, records, and structs, used across multiple projects. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.Common.EntityModels` | A class library project for common EF Core
    entity models. Entity models are often used on both the server and client side,
    so it is best to separate dependencies on specific database providers. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.Common.DataContext` | A class library project for the EF Core
    database context with dependencies on specific database providers. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.Web` | An ASP.NET Core project for a simple website that uses
    a mixture of static HTML files and dynamic Razor Pages. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.Razor.Component` | A class library project for Razor Pages used
    in multiple projects. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.Mvc` | An ASP.NET Core project for a complex website that uses
    the MVC pattern and can be more easily unit tested. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.WebApi` | An ASP.NET Core project for an HTTP API service. A good
    choice for integrating with websites because they can use any JavaScript library
    or Blazor to interact with the service. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.OData` | An ASP.NET Core project for an HTTP API service that
    implements the OData standard to enable a client to control queries. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.GraphQL` | An ASP.NET Core project for an HTTP API service that
    implements the GraphQL standard to enable a client to control queries. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.gRPC` | An ASP.NET Core project for a gRPC service. A good choice
    for integrating with apps built with any language and platform since gRPC has
    wide support and is highly efficient and performant. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.SignalR` | An ASP.NET Core project for real-time communication.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.AzureFuncs` | An ASP.NET Core project for implementing a serverless
    nanoservice for hosting in Azure Functions. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.BlazorServer` | An ASP.NET Core Blazor Server project. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.BlazorWasm.Client` | An ASP.NET Core Blazor WebAssembly client-side
    project. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.BlazorWasm.Server` | An ASP.NET Core Blazor WebAssembly server-side
    project. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.Maui` | A .NET MAUI project for a cross-platform desktop/mobile
    app. |'
  prefs: []
  type: TYPE_TB
- en: '| `Northwind.MauiBlazor` | A .NET MAUI project for hosting Blazor components
    with native integrations with the OS. |'
  prefs: []
  type: TYPE_TB
- en: Using other project templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you install the .NET SDK, there are many project templates included:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At a command prompt or terminal, enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: dotnet new --list
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You will see a list of currently installed templates, including templates for
    Windows desktop development if you are running on Windows, as shown in *Figure
    13.2* :![](img/Image00101.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 13.2: A list of dotnet project templates'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the web-related project templates, including ones for creating SPAs using
    Blazor, Angular, and React. But another common JavaScript SPA library is missing:
    Vue.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing additional template packs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Developers can install lots of additional template packs:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a browser and navigate to [http://dotnetnew.azurewebsites.net/](http://dotnetnew.azurewebsites.net/)
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `vue` in the textbox and note the list of available templates for Vue.js,
    including one published by Microsoft, as shown in *Figure 13.3* :![](img/Image00102.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 13.3: A project template for Vue.js by Microsoft'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **ASP.NET Core with Vue.js** by Microsoft, and note the instructions
    for installing and using this template, as shown in the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: dotnet new --install "Microsoft.AspNetCore.SpaTemplates"
  prefs: []
  type: TYPE_NORMAL
- en: dotnet new vue
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Click **View other templates in this package** , and note that as well as a
    project template for Vue.js, it also has project templates for Aurelia and Knockout.js.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building an entity data model for the Northwind database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Practical applications usually need to work with data in a relational database
    or another data store. In this chapter, we will define an entity data model for
    the Northwind database stored in SQL Server or SQLite. It will be used in most
    of the apps that we create in subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The `Northwind4SQLServer.sql` and `Northwind4SQLite.sql` script files are different.
    The script for SQL Server creates 13 tables as well as related views and stored
    procedures. The script for SQLite is a simplified version that only creates 10
    tables because SQLite does not support as many features. The main projects in
    this book only need those 10 tables so you can complete every task in this book
    with either database.
  prefs: []
  type: TYPE_NORMAL
- en: Instructions to install SQL Server and SQLite can be found in *Chapter 10* ,
    *Working with Data Using Entity Framework Core* . In that chapter, you will also
    find instructions for installing the `dotnet-ef` tool, which you will use to scaffold
    an entity model from an existing database.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : You should create a separate class library project for
    your entity data models. This allows easier sharing between backend web servers
    and frontend desktop, mobile, and Blazor WebAssembly clients.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class library for entity models using SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will now define entity data models in a class library so that they can be
    reused in other types of projects including client-side app models. If you are
    not using SQL Server, you will need to create this class library for SQLite. If
    you are using SQL Server, then you can create both a class library for SQLite
    and one for SQL Server and then switch between them as you choose.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will automatically generate some entity models using the EF Core command-line
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to create a new solution/workspace named `PracticalApps`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a class library project, as defined in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Class Library** / `classlib`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `PracticalApps`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `Northwind.Common.EntityModels.Sqlite`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Northwind.Common.EntityModels.Sqlite` project, add package references
    for the SQLite database provider and EF Core design-time support, as shown in
    the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <PackageReference
  prefs: []
  type: TYPE_NORMAL
- en: Include="Microsoft.EntityFrameworkCore.Sqlite"
  prefs: []
  type: TYPE_NORMAL
- en: Version="6.0.0"
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: <PackageReference
  prefs: []
  type: TYPE_NORMAL
- en: Include="Microsoft.EntityFrameworkCore.Design"
  prefs: []
  type: TYPE_NORMAL
- en: Version="6.0.0"
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: <PrivateAssets>all</PrivateAssets>
  prefs: []
  type: TYPE_NORMAL
- en: <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
  prefs: []
  type: TYPE_NORMAL
- en: </PackageReference>
  prefs: []
  type: TYPE_NORMAL
- en: </ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the `Class1.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `Northwind.db` file for SQLite by copying the `Northwind4SQLite.sql`
    file into the `PracticalApps` folder, and then enter the following command at
    a command prompt or terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: sqlite3 Northwind.db -init Northwind4SQLite.sql
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Be patient because this command might take a while to create the database structure,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: -- Loading resources from Northwind4SQLite.sql
  prefs: []
  type: TYPE_NORMAL
- en: SQLite version 3.35.5 2021-04-19 14:49:49
  prefs: []
  type: TYPE_NORMAL
- en: Enter ".help" for usage hints.
  prefs: []
  type: TYPE_NORMAL
- en: sqlite>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Press Ctrl + C on Windows or Cmd + D on macOS to exit SQLite command mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a command prompt or terminal for the `Northwind.Common.EntityModels.Sqlite`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the command line, generate entity class models for all tables, as shown
    in the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: dotnet ef dbcontext scaffold "Filename=../Northwind.db" Microsoft.EntityFrameworkCore.Sqlite
    --namespace Packt.Shared --data-annotations
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command to perform: `dbcontext scaffold`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The connection strings. `"Filename=../Northwind.db"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The database provider: `Microsoft.EntityFrameworkCore.Sqlite`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The namespace: `--namespace Packt.Shared`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use data annotations as well as the Fluent API: `--data-annotations`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note the build messages and warnings, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Build started...
  prefs: []
  type: TYPE_NORMAL
- en: Build succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: To protect potentially sensitive information in your connection string, you
    should move it out of source code. You can avoid scaffolding the connection string
    by using the Name= syntax to read it from configuration - see https://go.microsoft.com/fwlink/?linkid=2131148\.
    For more guidance on storing connection strings, see http://go.microsoft.com/fwlink/?LinkId=723263.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Improving the class-to-table mapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `dotnet-ef` command-line tool generates different code for SQL Server and
    SQLite because they support different levels of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, SQL Server text columns can have limits to the number of characters.
    SQLite does not support this. So, `dotnet-ef` will generate validation attributes
    to ensure `string` properties are limited to a specified number of characters
    for SQL Server but not for SQLite, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // SQLite database provider-generated code
  prefs: []
  type: TYPE_NORMAL
- en: '[Column(TypeName ='
  prefs: []
  type: TYPE_NORMAL
- en: '"nvarchar (15)"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: CategoryName { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; } = null
  prefs: []
  type: TYPE_NORMAL
- en: '!;'
  prefs: []
  type: TYPE_NORMAL
- en: // SQL Server database provider-generated code
  prefs: []
  type: TYPE_NORMAL
- en: '[StringLength(15)'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: CategoryName { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; } = null
  prefs: []
  type: TYPE_NORMAL
- en: '!;'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Neither database provider will mark non-nullable `string` properties as required:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // no runtime validation of non-nullable property
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: CategoryName { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; } = null
  prefs: []
  type: TYPE_NORMAL
- en: '!;'
  prefs: []
  type: TYPE_NORMAL
- en: // nullable property
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? Description { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: // decorate with attribute to perform runtime validation
  prefs: []
  type: TYPE_NORMAL
- en: '[Required'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: CategoryName { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; } = null
  prefs: []
  type: TYPE_NORMAL
- en: '!;'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make some small changes to improve the entity model mapping and validation
    rules for SQLite:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Customer.cs` file and add a regular expression to validate its primary
    key value to only allow uppercase Western characters, as shown highlighted in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '[Key'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[Column(TypeName ='
  prefs: []
  type: TYPE_NORMAL
- en: '"nchar (5)"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '**[**'
  prefs: []
  type: TYPE_NORMAL
- en: '**RegularExpression(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"[A-Z]{5}"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**]**'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: CustomerId { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activate your code editor''s find and replace feature (in Visual Studio 2022,
    navigate to **Edit** | **Find and Replace** | **Quick Replace** ), toggle on **Use
    Regular Expressions** , and then type a regular expression in the search box,
    as shown in the following expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: \[Column\(TypeName = "(nchar|nvarchar) \((.*)\)"
  prefs: []
  type: TYPE_NORMAL
- en: \)\]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the replace box, type a replacement regular expression, as shown in the
    following expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: $&\n    [StringLength($2
  prefs: []
  type: TYPE_NORMAL
- en: )]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: After the newline character, `\n` , I have included four space characters to
    indent correctly on my system, which uses two space characters per indentation
    level. You can insert as many as you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Set the find and replace to search files in the current project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the search and replace to replace all, as shown in *Figure 13.4* :![](img/Image00103.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 13.4: Search and replace all matches using regular expressions in Visual
    Studio 2022'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change any date/time properties, for example, in `Employee.cs` , to use a nullable
    `DateTime` instead of an array of bytes, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // before
  prefs: []
  type: TYPE_NORMAL
- en: '[Column(TypeName ='
  prefs: []
  type: TYPE_NORMAL
- en: '"datetime"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: byte
  prefs: []
  type: TYPE_NORMAL
- en: '[] BirthDate { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: // after
  prefs: []
  type: TYPE_NORMAL
- en: '[Column(TypeName ='
  prefs: []
  type: TYPE_NORMAL
- en: '"datetime"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: DateTime? BirthDate { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Use your code editor's find feature to search for `"datetime"` to find all the
    properties that need changing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change any `money` properties, for example, in `Order.cs` , to use a nullable
    `decimal` instead of an array of bytes, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // before
  prefs: []
  type: TYPE_NORMAL
- en: '[Column(TypeName ='
  prefs: []
  type: TYPE_NORMAL
- en: '"money"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: byte
  prefs: []
  type: TYPE_NORMAL
- en: '[] Freight { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: // after
  prefs: []
  type: TYPE_NORMAL
- en: '[Column(TypeName ='
  prefs: []
  type: TYPE_NORMAL
- en: '"money"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  prefs: []
  type: TYPE_NORMAL
- en: '? Freight { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Use your code editor's find feature to search for `"money"` to find all the
    properties that need changing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change any `bit` properties, for example, in `Product.cs` , to use a `bool`
    instead of an array of bytes, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // before
  prefs: []
  type: TYPE_NORMAL
- en: '[Column(TypeName ='
  prefs: []
  type: TYPE_NORMAL
- en: '"bit"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: byte
  prefs: []
  type: TYPE_NORMAL
- en: '[] Discontinued { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; } = null
  prefs: []
  type: TYPE_NORMAL
- en: '!;'
  prefs: []
  type: TYPE_NORMAL
- en: // after
  prefs: []
  type: TYPE_NORMAL
- en: '[Column(TypeName ='
  prefs: []
  type: TYPE_NORMAL
- en: '"bit"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: Discontinued { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Use your code editor's find feature to search for `"bit"` to find all the properties
    that need changing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Category.cs` , make the `CategoryId` property an `int` , as shown highlighted
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '[Key'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: '**int**'
  prefs: []
  type: TYPE_NORMAL
- en: CategoryId { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Category.cs` , make the `CategoryName` property required, as shown highlighted
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '**[**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Required**'
  prefs: []
  type: TYPE_NORMAL
- en: '**]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[Column(TypeName ='
  prefs: []
  type: TYPE_NORMAL
- en: '"nvarchar (15)"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[StringLength(15)'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: CategoryName { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Customer.cs` , make the `CompanyName` property required, as shown highlighted
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '**[**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Required**'
  prefs: []
  type: TYPE_NORMAL
- en: '**]**'
  prefs: []
  type: TYPE_NORMAL
- en: '[Column(TypeName ='
  prefs: []
  type: TYPE_NORMAL
- en: '"nvarchar (40)"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[StringLength(40)'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: CompanyName { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In `Employee.cs` , make the `EmployeeId` property an `int` instead of a `long`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Employee.cs` , make the `FirstName` and `LastName` properties required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Employee.cs` , make the `ReportsTo` property an `int?` instead of a `long?`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `EmployeeTerritory.cs` , make the `EmployeeId` property an `int` instead
    of a `long` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `EmployeeTerritory.cs` , make the `TerritoryId` property required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Order.cs` , make the `OrderId` property an `int` instead of a `long` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Order.cs` , decorate the `CustomerId` property with a regular expression
    to enforce five uppercase characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Order.cs` , make the `EmployeeId` property an `int?` instead of a `long?`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Order.cs` , make the `ShipVia` property an `int?` instead of a `long?` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `OrderDetail.cs` , make the `OrderId` property an `int` instead of a `long`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `OrderDetail.cs` , make the `ProductId` property an `int` instead of a `long`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `OrderDetail.cs` , make the `Quantity` property a `short` instead of a `long`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Product.cs` , make the `ProductId` property an `int` instead of a `long`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Product.cs` , make the `ProductName` property required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Product.cs` , make the `SupplierId` and `CategoryId` properties an `int?`
    instead of a `long?` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Product.cs` , make the `UnitsInStock` , `UnitsOnOrder` , and `ReorderLevel`
    properties a `short?` instead of a `long?` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Shipper.cs` , make the `ShipperId` property an `int` instead of a `long`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Shipper.cs` , make the `CompanyName` property required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Supplier.cs` , make the `SupplierId` property an `int` instead of a `long`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Supplier.cs` , make the `CompanyName` property required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Territory.cs` , make the `RegionId` property an `int` instead of a `long`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Territory.cs` , make the `TerritoryId` and `TerritoryDescription` properties
    required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have a class library for the entity classes, we can create a class
    library for the database context.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class library for a Northwind database context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will now define a database context class library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a class library project to the solution/workspace, as defined in the following
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Class Library** / `classlib`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `PracticalApps`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `Northwind.Common.DataContext.Sqlite`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, set the startup project for the solution to the current selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `Northwind.Common.DataContext.Sqlite` as the active
    OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Northwind.Common.DataContext.Sqlite` project, add a project reference
    to the `Northwind.Common.EntityModels.Sqlite` project and add a package reference
    to the EF Core data provider for SQLite, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <PackageReference
  prefs: []
  type: TYPE_NORMAL
- en: Include="Microsoft.EntityFrameworkCore.SQLite"
  prefs: []
  type: TYPE_NORMAL
- en: Version="6.0.0"
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: </ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <ProjectReference Include=
  prefs: []
  type: TYPE_NORMAL
- en: '"..\Northwind.Common.EntityModels.Sqlite\Northwind.Common'
  prefs: []
  type: TYPE_NORMAL
- en: .EntityModels.Sqlite.csproj"
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: </ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The path to the project reference should not have a line break in your project
    file.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Northwind.Common.DataContext.Sqlite` project, delete the `Class1.cs`
    class file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the `Northwind.Common.DataContext.Sqlite` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the `NorthwindContext.cs` file from the `Northwind.Common.EntityModels.Sqlite`
    project/folder to the `Northwind.Common.DataContext.Sqlite` project/folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio **Solution Explorer** , if you drag and drop a file between
    projects it will be copied. If you hold down Shift while dragging and dropping,
    it will be moved. In Visual Studio Code **EXPLORER** , if you drag and drop a
    file between projects it will be moved. If you hold down Ctrl while dragging and
    dropping, it will be copied.
  prefs: []
  type: TYPE_NORMAL
- en: In `NorthwindContext.cs` , in the `OnConfiguring` method, remove the compiler
    `#warning` about the connection string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice** : We will override the default database connection string
    in any projects such as websites that need to work with the Northwind database,
    so the class derived from `DbContext` must have a constructor with a `DbContextOptions`
    parameter for this to work, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: NorthwindContext
  prefs: []
  type: TYPE_NORMAL
- en: (DbContextOptions<NorthwindContext> options)
  prefs: []
  type: TYPE_NORMAL
- en: ': base'
  prefs: []
  type: TYPE_NORMAL
- en: (options)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `OnModelCreating` method, remove all Fluent API statements that call
    the `ValueGeneratedNever` method to configure primary key properties like `SupplierId`
    to never generate a value automatically or call the `HasDefaultValueSql` method,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: modelBuilder.Entity<Supplier>(entity =>
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: entity.Property(e => e.SupplierId).ValueGeneratedNever();
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If we do not remove the configuration like the statements above, then when we
    add new suppliers, the `SupplierId` value would always be 0 and we would only
    be able to add one supplier with that value and then all other attempts would
    throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `Product` entity, tell SQLite that the `UnitPrice` can be converted
    from `decimal` to `double` . The `OnModelCreating` method should now be much simplified,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: protected
  prefs: []
  type: TYPE_NORMAL
- en: override
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: OnModelCreating
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: ModelBuilder modelBuilder
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: modelBuilder.Entity<OrderDetail>(entity =>
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: entity.HasKey(e => new
  prefs: []
  type: TYPE_NORMAL
- en: '{ e.OrderId, e.ProductId });'
  prefs: []
  type: TYPE_NORMAL
- en: entity.HasOne(d => d.Order)
  prefs: []
  type: TYPE_NORMAL
- en: .WithMany(p => p.OrderDetails)
  prefs: []
  type: TYPE_NORMAL
- en: .HasForeignKey(d => d.OrderId)
  prefs: []
  type: TYPE_NORMAL
- en: .OnDelete(DeleteBehavior.ClientSetNull);
  prefs: []
  type: TYPE_NORMAL
- en: entity.HasOne(d => d.Product)
  prefs: []
  type: TYPE_NORMAL
- en: .WithMany(p => p.OrderDetails)
  prefs: []
  type: TYPE_NORMAL
- en: .HasForeignKey(d => d.ProductId)
  prefs: []
  type: TYPE_NORMAL
- en: .OnDelete(DeleteBehavior.ClientSetNull);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: modelBuilder.Entity<Product>()
  prefs: []
  type: TYPE_NORMAL
- en: .Property(product => product.UnitPrice)
  prefs: []
  type: TYPE_NORMAL
- en: .HasConversion<double
  prefs: []
  type: TYPE_NORMAL
- en: '>();'
  prefs: []
  type: TYPE_NORMAL
- en: OnModelCreatingPartial(modelBuilder);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a class named `NorthwindContextExtensions.cs` and modify its contents to
    define an extension method that adds the Northwind database context to a collection
    of dependency services, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft.EntityFrameworkCore; // UseSqlite
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft.Extensions.DependencyInjection; // IServiceCollection
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: NorthwindContextExtensions
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: ///
  prefs: []
  type: TYPE_NORMAL
- en: <summary>
  prefs: []
  type: TYPE_NORMAL
- en: ///
  prefs: []
  type: TYPE_NORMAL
- en: Adds NorthwindContext to the specified IServiceCollection. Uses the Sqlite database
    provider.
  prefs: []
  type: TYPE_NORMAL
- en: ///
  prefs: []
  type: TYPE_NORMAL
- en: </summary>
  prefs: []
  type: TYPE_NORMAL
- en: ///
  prefs: []
  type: TYPE_NORMAL
- en: <param name="services"></param>
  prefs: []
  type: TYPE_NORMAL
- en: ///
  prefs: []
  type: TYPE_NORMAL
- en: <param name="relativePath">
  prefs: []
  type: TYPE_NORMAL
- en: Set to override the default of ".."
  prefs: []
  type: TYPE_NORMAL
- en: </param>
  prefs: []
  type: TYPE_NORMAL
- en: ///
  prefs: []
  type: TYPE_NORMAL
- en: <returns>
  prefs: []
  type: TYPE_NORMAL
- en: An IServiceCollection that can be used to add more services.
  prefs: []
  type: TYPE_NORMAL
- en: </returns>
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: IServiceCollection
  prefs: []
  type: TYPE_NORMAL
- en: AddNorthwindContext
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: this
  prefs: []
  type: TYPE_NORMAL
- en: IServiceCollection services,
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: relativePath =
  prefs: []
  type: TYPE_NORMAL
- en: '".."'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: databasePath = Path.Combine(relativePath, "Northwind.db"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: services.AddDbContext<NorthwindContext>(options =>
  prefs: []
  type: TYPE_NORMAL
- en: options.UseSqlite($"Data Source=
  prefs: []
  type: TYPE_NORMAL
- en: '{databasePath}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: services;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Build the two class libraries and fix any compiler errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a class library for entity models using SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use SQL Server, you will not need to do anything if you already set up the
    Northwind database in *Chapter 10* , *Working with Data Using Entity Framework
    Core* . But you will now create the entity models using the `dotnet-ef` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to create a new solution/workspace named `PracticalApps`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a class library project, as defined in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Class Library** / `classlib`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `PracticalApps`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `Northwind.Common.EntityModels.SqlServer`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Northwind.Common.EntityModels.SqlServer` project, add package references
    for the SQL Server database provider and EF Core design-time support, as shown
    in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <PackageReference
  prefs: []
  type: TYPE_NORMAL
- en: Include="Microsoft.EntityFrameworkCore.SqlServer"
  prefs: []
  type: TYPE_NORMAL
- en: Version="6.0.0"
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: <PackageReference
  prefs: []
  type: TYPE_NORMAL
- en: Include="Microsoft.EntityFrameworkCore.Design"
  prefs: []
  type: TYPE_NORMAL
- en: Version="6.0.0"
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: <PrivateAssets>all</PrivateAssets>
  prefs: []
  type: TYPE_NORMAL
- en: <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
  prefs: []
  type: TYPE_NORMAL
- en: </PackageReference>
  prefs: []
  type: TYPE_NORMAL
- en: </ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the `Class1.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a command prompt or terminal for the `Northwind.Common.EntityModels.SqlServer`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the command line, generate entity class models for all tables, as shown
    in the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: dotnet ef dbcontext scaffold "Data Source=.;Initial Catalog=Northwind;Integrated
    Security=true;" Microsoft.EntityFrameworkCore.SqlServer --namespace Packt.Shared
    --data-annotations
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command to perform: `dbcontext scaffold`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The connection strings. `"Data Source=.;Initial Catalog=Northwind;Integrated
    Security=true;"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The database provider: `Microsoft.EntityFrameworkCore.SqlServer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The namespace: `--namespace Packt.Shared`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use data annotations as well as the Fluent API: `--data-annotations`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `Customer.cs` , add a regular expression to validate its primary key value
    to only allow uppercase Western characters, as shown highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '[Key'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[StringLength(5)'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '**[**'
  prefs: []
  type: TYPE_NORMAL
- en: '**RegularExpression(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"[A-Z]{5}"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**]**'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: CustomerId { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; } = null
  prefs: []
  type: TYPE_NORMAL
- en: '!;'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In `Customer.cs` , make the `CustomerId` and `CompanyName` properties required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a class library project to the solution/workspace, as defined in the following
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Class Library** / `classlib`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `PracticalApps`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `Northwind.Common.DataContext.SqlServer`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `Northwind.Common.DataContext.SqlServer` as the
    active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Northwind.Common.DataContext.SqlServer` project, add a project reference
    to the `Northwind.Common.EntityModels.SqlServer` project and add a package reference
    to the EF Core data provider for SQL Server, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <PackageReference
  prefs: []
  type: TYPE_NORMAL
- en: Include="Microsoft.EntityFrameworkCore.SqlServer"
  prefs: []
  type: TYPE_NORMAL
- en: Version="6.0.0"
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: </ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <ProjectReference Include=
  prefs: []
  type: TYPE_NORMAL
- en: '"..\Northwind.Common.EntityModels.SqlServer\Northwind.Common'
  prefs: []
  type: TYPE_NORMAL
- en: .EntityModels.SqlServer.csproj"
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: </ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Northwind.Common.DataContext.SqlServer` project, delete the `Class1.cs`
    class file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the `Northwind.Common.DataContext.SqlServer` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the `NorthwindContext.cs` file from the `Northwind.Common.EntityModels.SqlServer`
    project/folder to the `Northwind.Common.DataContext.SqlServer` project/folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `NorthwindContext.cs` , remove the compiler warning about the connection
    string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a class named `NorthwindContextExtensions.cs` , and modify its contents
    to define an extension method that adds the Northwind database context to a collection
    of dependency services, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft.EntityFrameworkCore; // UseSqlServer
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft.Extensions.DependencyInjection; // IServiceCollection
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: NorthwindContextExtensions
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: ///
  prefs: []
  type: TYPE_NORMAL
- en: <summary>
  prefs: []
  type: TYPE_NORMAL
- en: ///
  prefs: []
  type: TYPE_NORMAL
- en: Adds NorthwindContext to the specified IServiceCollection. Uses the SqlServer
    database provider.
  prefs: []
  type: TYPE_NORMAL
- en: ///
  prefs: []
  type: TYPE_NORMAL
- en: </summary>
  prefs: []
  type: TYPE_NORMAL
- en: ///
  prefs: []
  type: TYPE_NORMAL
- en: <param name="services"></param>
  prefs: []
  type: TYPE_NORMAL
- en: ///
  prefs: []
  type: TYPE_NORMAL
- en: <param name="connectionString">
  prefs: []
  type: TYPE_NORMAL
- en: Set to override the default.
  prefs: []
  type: TYPE_NORMAL
- en: </param>
  prefs: []
  type: TYPE_NORMAL
- en: ///
  prefs: []
  type: TYPE_NORMAL
- en: <returns>
  prefs: []
  type: TYPE_NORMAL
- en: An IServiceCollection that can be used to add more services.
  prefs: []
  type: TYPE_NORMAL
- en: </returns>
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: IServiceCollection
  prefs: []
  type: TYPE_NORMAL
- en: AddNorthwindContext
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: this
  prefs: []
  type: TYPE_NORMAL
- en: IServiceCollection services,
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: connectionString =
  prefs: []
  type: TYPE_NORMAL
- en: '"Data Source=.;Initial Catalog=Northwind;"'
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: '"Integrated Security=true;MultipleActiveResultsets=true;"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: services.AddDbContext<NorthwindContext>(options =>
  prefs: []
  type: TYPE_NORMAL
- en: options.UseSqlServer(connectionString));
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: services;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Build the two class libraries and fix any compiler errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice** : We have provided optional arguments for the `AddNorthwindContext`
    method so that we can override the hardcoded SQLite database filename path or
    the SQL Server database connection string. This will allow us more flexibility,
    for example, to load these values from a configuration file.'
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Explore this chapter's topics with deeper research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 13.1 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET 6 is cross-platform. Windows Forms and WPF apps can run on .NET 6\. Can
    those apps therefore run on macOS and Linux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a Windows Forms app define its user interface, and why is this a potential
    problem?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can a WPF or UWP app define its user interface, and why is this good for
    developers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 13.2 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more detail about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-13---introducing-practical-applications-of-c-and-net](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-13---introducing-practical-applications-of-c-and-net)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have been introduced to some of the app models and workloads
    that you can use to build practical applications using C# and .NET.
  prefs: []
  type: TYPE_NORMAL
- en: You have created two to four class libraries to define an entity data model
    for working with the Northwind database using either SQLite or SQL Server or both.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following six chapters, you will learn the details about how to build
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple websites using static HTML pages and dynamic Razor Pages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex websites using the Model-View-Controller (MVC) design pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web services that can be called by any platform that can make an HTTP request
    and client websites that call those web services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blazor user interface components that can be hosted on a web server, in the
    browser, or on hybrid web-native mobile and desktop apps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services that implement remote procedure calls using gRPC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services that implement real-time communication using SignalR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services that provide easy and flexible access to an EF Core model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless nano services hosted in Azure Functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-platform native mobile and desktop apps using .NET MAUI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

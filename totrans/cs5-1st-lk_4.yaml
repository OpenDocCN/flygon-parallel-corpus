- en: Chapter 4. Creating a Windows Store App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first half of this book, we looked at how to set up your development
    environment to take advantage of C# 5.0, had a look at the history and evolution
    of C#, and reviewed the new features available to you in the latest release. In
    this chapter (and for the rest of the book), we will look at some practical applications
    where you can use these features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will walk you through creating a Windows Store app. This application
    will run in the new Windows Runtime Environment, which can target both x86 and
    ARM architectures. In this chapter we will create a Windows Store application,
    connect to an HTTP-based web service over the Internet and parsing JSON, and display
    the results in a XAML page.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: When you are done with this chapter, you will have a fully working project that
    you can use as the basis for your own application. You can then upload this application
    to the Windows Store and potentially make money off the sales.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Making a Flickr browser
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project we are going to create is an application to browse through images.
    As a source, we will use the popular picture website [http://flickr.com](http://flickr.com).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '![Making a Flickr browser](img/6761_04_04.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
- en: There are several reasons for choosing this as our project. First, Flickr provides
    an extensive web API to browse the various sections of their website, so it is
    an easy way to access data repositories. Secondly, many times you will find yourself
    accessing external data over the Internet, so this is a great example of how to
    handle this kind of access in a native application. And finally, pictures make
    for great eye candy, so the application ends up being something that you can show
    off.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Getting the project started
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are using Visual Studio Express, you have to be using the version called
    VS Express for Windows 8\. We begin the process by creating a new Windows Store
    application from the **New Project** dialog shown in the following screenshot:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting the project started](img/6761_04_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
- en: Choose the **Blank App (XAML)** project template, which gives you the bare minimum
    required to create an app. You should of course feel encouraged to create projects
    using the other templates to see how some common UI paradigms, such as grid apps,
    are created. But for now, the blank app template keeps things simple.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to Flickr
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have our project structure, we can begin the project by first connecting
    to the Flickr API. Once you have created a user account on Flickr, you can access
    the API documentation at [http://www.flickr.com/services/api/](http://www.flickr.com/services/api/).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to browse through the documentation to get an idea of what is possible.
    Once you are ready to continue, a key ingredient in gaining access to their data
    will be to provide an API key, and applying to get one is very easy—simply access
    the application form at [http://www.flickr.com/services/apps/create/apply/](http://www.flickr.com/services/apps/create/apply/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Apply for a non-commercial key, and then provide information about the app that
    you are going to build (name, description, and so on).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have completed the application, you will get two pieces of data: the
    API Key and API Secret. The Windows RT version of the .NET Framework contains
    a number of differences. For developers used to using the regular desktop version
    of the framework, one of those differences is the absence of the configuration
    system. So, although C# developers are used to entering static configuration values,
    such as an API Key, into an `app.config` file, we will not be able to do that
    here because those APIs are simply not available in WinRT applications. For a
    simple analog to a full configuration system, we can just create a static class
    to contain the constants and make them easily accessible.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by adding a new class to the `DataModel` namespace. If the project
    does not already contain it, simply add a folder named `DataModel`, and then add
    a new class with the following contents:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在`DataModel`命名空间中添加一个新类。如果项目中还没有它，只需添加一个名为`DataModel`的文件夹，然后添加一个包含以下内容的新类：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Of course, where it says, `<The API Key>` and `<The API Secret>`, you should
    replace this with the key and secret assigned to your own account.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在其中写`<The API Key>`和`<The API Secret>`的地方，您应该用分配给您自己帐户的密钥和秘密替换它。
- en: 'Next up, we need a way to actually access the API over the Internet. Because
    of the new `async` features in C# 5.0, this is very simple. Add another class,
    named `WebHelper`, to the `DataModel` folder, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一种实际访问互联网上的API的方法。由于C# 5.0中的新的`async`特性，这非常简单。添加另一个名为`WebHelper`的类到`DataModel`文件夹中，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Despite the small number of lines of code, there is actually a lot going on
    in this code. Using the `HttpClient` class, there is a single method call to download
    the data asynchronously. The data being returned will be in **JavaScript Object
    Notation** (**JSON**) format. Then, we use `DataContractJsonSerializer` to deserialize
    the result directly into a strongly typed class, which we define using the generic
    parameter on the method. That is one of the great things about C# 5.0; this method
    had many more lines of code in previous versions of the framework.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码行数很少，但实际上这段代码中发生了很多事情。使用`HttpClient`类，只需调用一个方法来异步下载数据。返回的数据将以**JavaScript对象表示法**（**JSON**）格式返回。然后，我们使用`DataContractJsonSerializer`将结果直接反序列化为我们使用方法的泛型参数定义的强类型类。这就是C#
    5.0的伟大之处之一；在框架的先前版本中，这个方法有更多的代码行。
- en: With the `WebHelper` class defined, we can start gathering the actual data from
    the remote API. One interesting API endpoint that Flickr provides is the Interesting
    list, which returns a list of the most interesting photos posted recently to their
    service. This is great because you are guaranteed to always have a fantastic set
    of pictures to display. You can become familiar with the method by reading through
    the API documentation at [http://www.flickr.com/services/api/flickr.interestingness.getList.html](http://www.flickr.com/services/api/flickr.interestingness.getList.html).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有了定义的`WebHelper`类，我们可以开始从远程API中收集实际数据。Flickr提供的一个有趣的API端点是有趣列表，它返回最近发布到其服务的照片列表。这很棒，因为您保证始终有一组精彩的图片可供显示。您可以通过阅读[http://www.flickr.com/services/api/flickr.interestingness.getList.html](http://www.flickr.com/services/api/flickr.interestingness.getList.html)上的API文档来熟悉该方法。
- en: 'The data that the service returns, when configured to use the JSON format,
    looks like the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置为使用JSON格式时，服务返回的数据如下所示：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The object that is returned as JSON contains paging information, such as what
    page you are currently on, and an array of photo information. As we are going
    to use the built-in `DataContractJsonSerializer` class to parse the JSON result,
    we need to create what are called **data contracts** . These are the classes that
    match the structure of the object represented by the JSON string; the serializer
    will take the data from the JSON string and populate the properties of the data
    contract, so you can access it in a strongly typed fashion.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为JSON返回的对象包含分页信息，例如当前所在的页面，以及照片信息数组。由于我们将使用内置的`DataContractJsonSerializer`类来解析JSON结果，因此需要创建所谓的**数据契约**。这些是与JSON字符串表示的对象结构匹配的类；序列化程序将从JSON字符串中获取数据并填充数据契约的属性，因此您可以以强类型方式访问它。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There are a number of other solutions available for working with JSON in C#.
    Arguably, one of the more popular solutions is James Newton-King's Json.NET, which
    you can find at [http://json.net](http://json.net).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中有许多其他解决方案可用于处理JSON。可以说，其中一个更受欢迎的解决方案是James Newton-King的Json.NET，您可以在[http://json.net](http://json.net)找到。
- en: It is a very flexible library that can be faster than other libraries when parsing
    and creating JSON strings. Many open source projects take a dependency on this
    library. The only reason we are not using it here is for the sake of simplicity,
    as `DataContractJsonSerializer` comes with the framework.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常灵活的库，可以在解析和创建JSON字符串时比其他库更快。许多开源项目都依赖于此库。我们之所以不在这里使用它，只是为了简单起见，因为`DataContractJsonSerializer`随框架提供。
- en: We begin creating data contracts by looking at the deepest level of the JSON
    structure, which represents information about a single photo. A data contract
    is simply a class with a property for each field in the JSON object that has been
    decorated with some attributes. At the top of the class definition, add the `[DataContract]`
    attribute, which just tells the serializer that this class can be used, and then
    for each property add a `[DataMember(Name=`"<field name>"`)]` attribute, which
    helps the serializer know which members map to which JSON properties.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始创建数据契约，通过查看JSON结构的最深层级，该层级表示有关单个照片的信息。数据契约只是一个类，其中每个字段在JSON对象中都有一个属性，并且已经用一些属性进行了装饰。在类定义的顶部，添加`[DataContract]`属性，这只是告诉序列化程序可以使用这个类，然后为每个属性添加一个`[DataMember(Name=`"<field
    name>"`)]`属性，这有助于序列化程序知道哪些成员映射到哪些JSON属性。
- en: 'Compare the class in the following example code with the JSON string:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下示例代码中的类与JSON字符串进行比较：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Name` parameter passed into the data member attribute is used here because
    the case of the property does not match what is coming back in the JSON object.
    Of course, you could just name the property exactly the same as the JSON object,
    but then it would not match regular .NET naming conventions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里传递给数据成员属性的`Name`参数是因为属性的大小写与JSON对象中返回的不匹配。当然，您也可以将属性命名为与JSON对象完全相同，但那样它就不符合常规的.NET命名约定了。
- en: One thing that you should notice is that the photo object itself does not have
    a URL to the image. Flickr gives you guidance on how to construct image URLs.
    The `.CreateUrl` method included in the class, in the previous example, will construct
    the URL to the image using the information in the properties of the class. You
    can get more information about the different options for constructing Flickr URLs
    at [http://www.flickr.com/services/api/misc.urls.html](http://www.flickr.com/services/api/misc.urls.html)
    .
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up the object chain, we have an object that contains some metadata about
    the result, such as the page, number of pages, and items per page. You can use
    this information to allow the user to page through the results. The object also
    contains an array of `ApiPhoto` objects, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And finally, we create an object to represent the outer level object, which
    has just one property, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have all of the data contracts created, we are ready to put everything
    together. Remember that this code will be going out over the Internet to retrieve
    data, which makes it a great candidate to use `async`/`await`. So, when we are
    planning out our interface, we want to make sure that it will be awaitable. Create
    a new class, named `Flickr.cs`, in the `Models` folder.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this class, we created a method called `.LoadInteresting()`, which constructs
    a URL pointing to the interesting endpoint using the API Key that we provisioned
    earlier in the chapter. Next, it uses the `WebHelper` class to make the HTTP call
    and passes in the `ApiResult` class, as that is the object that represents the
    format of the JSON result. Once the web call returns a value, it will be deserialized,
    and we return the photo information.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Creating the UI
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have the data in an easy-to-access method and are ready to begin creating
    the user interface. When you are working with XAML, as you will be when creating
    apps using C# for the Windows Store (formerly known as **Metro** ), a very common
    pattern for you to use is **Model-View-ViewModel** (**MVVM**). This architectural
    model is similar to **Model-View-Controller** (**MVC**), in that you have a model
    and view at either end, with a component in the middle to "glue" those pieces
    together. It differs from MVC in that the role of the "controller" is taken by
    the binding system provided by XAML, which takes care of updating the view whenever
    data changes. So, all you have to do is provide a light wrapper around your model
    to make certain binding scenarios a bit easier in the form of the ViewModel. So,
    all you have to do is provide a light wrapper around your model to make certain
    binding scenarios a bit easier in the form of the ViewModel as you can see in
    the following diagram:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the UI](img/6761EN_04_05.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: In this application, your **Model** component represents the core logic of your
    problem domain. The `ApiPhotos` and the `.LoadInteresting` methods represent the
    model in this relatively simple program. The **View** block is represented by
    the XAML code that we are going to create. So, we need the **ViewModel** block
    to link the **Model** block to the **View** block.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'When you created the project, there were several bits of code that were automatically
    included. One of these helpful pieces of code can be found in the `Common/StandardStyles.xaml`
    file. This file contains a number of helpful styles and templates that you can
    use in your application. We are going to use one of these templates to display
    our images. The template named `Standard250x250ItemTemplate` is defined as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Please pay attention to the way the data is being bound to the various properties
    of the controls of the template. This binding format automatically does a lot
    of the work that would normally be done in the "Controller" component of the MVC
    pattern. As a result, you may need to change the representation of the data in
    some of the models to make it easy to bind, which is why we use ViewModels.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'The properties being bound in this template are different from the properties
    available in the `ApiPhoto` class. We will use the ViewModel to convert the model
    into something that can easily be bound. Go ahead and create a new class, called
    `FlickrImage`, that contains the properties that the template is expecting, as
    follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板中绑定的属性与`ApiPhoto`类中可用的属性不同。我们将使用ViewModel将模型转换为可以轻松绑定的内容。继续创建一个名为`FlickrImage`的新类，其中包含模板期望的属性，如下所示：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the following field and method to the `Flickr` class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 向`Flickr`类添加以下字段和方法：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Load()` method starts by calling the `LoadInteresting()` method, which
    goes out to the Flickr API over the Internet and retrieves interesting photos
    (asynchronously, of course). It then converts the result into a list of the ViewModels
    using LINQ and updates the static `Images` property. Note how it does not reinstantiate
    the actual collection, instead of a regular list, the `Images` property is an
    `ObservableCollection` collection, which is the preferable collection type to
    use in ViewModels. You can bind to the XAML UI when you initialize the page and
    then reload the data any time you want, the collection takes care of notifying
    the UI, and the binding framework takes care of updating the screen.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Load()`方法首先调用`LoadInteresting()`方法，该方法通过互联网访问Flickr API并检索有趣的照片（当然是异步的）。然后使用LINQ将结果转换为ViewModels的列表，并更新静态的`Images`属性。请注意，它不会重新实例化实际的集合，而是`Images`属性是`ObservableCollection`集合，这是ViewModel中首选使用的集合类型。您可以在初始化页面时绑定到XAML
    UI，然后随时重新加载数据，集合会负责通知UI，绑定框架会负责更新屏幕。'
- en: 'With the ViewModel defined, we are ready to create the actual user interface.
    Begin by adding a **Basic Page** item from the **Visual C# | Windows Store** menu
    in the **Add New Item** dialog. Name the file `FlickrPage.xaml`, as shown in the
    following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了ViewModel后，我们准备创建实际的用户界面。首先从**Visual C# | Windows Store**菜单中的**添加新项**对话框中添加一个**基本页面**项目。将文件命名为`FlickrPage.xaml`，如下截图所示：
- en: '![Creating the UI](img/6761_04_02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![创建UI](img/6761_04_02.jpg)'
- en: This creates a very basic page with a few simple things such as a back button.
    You can change the page that the application starts up on by opening the `App.xaml.cs`
    file and changing the `OnLaunched` method to launch `FlickrPage` instead of `MainPage`,
    which is the default. We could, of course, have used `MainPage` for this sample,
    but most pages that you use will need a back button, so you should become comfortable
    with using the **Basic Page** template.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个非常基本的页面，其中包含一些简单的东西，如返回按钮。您可以通过打开`App.xaml.cs`文件并将`OnLaunched`方法更改为启动`FlickrPage`而不是默认的`MainPage`来更改应用程序启动时打开的页面。当然，我们可以在此示例中使用`MainPage`，但是您将使用的大多数页面都需要返回按钮，因此您应该熟悉使用**基本页面**模板。
- en: 'Our interface will be minimal, in fact, it consists of a single control that
    we will place in the `FlickrPage.xaml` file, below the section that contains the
    back button, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的界面将是最小化的，实际上，它只包含一个控件，我们将其放在`FlickrPage.xaml`文件中，放在包含返回按钮的部分下方，如下所示：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`GridView` will take care of displaying the items that we bind to it in a grid
    layout, perfect for displaying a bunch of pictures. We bind the `ItemsSource`
    property to our images, and `ItemTemplate`, which is used to format every single
    item, is bound to the standard template.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridView`将负责以网格布局显示我们绑定到它的项目，非常适合显示一堆图片。我们将`ItemsSource`属性绑定到我们的图像，`ItemTemplate`用于格式化每个单独的项目，绑定到标准模板。'
- en: 'Now that the XAML has been set up, all we have to do is actually load the data
    and set `DataContext` for the page! Open the file named `FlickrPage.xaml.cs` and
    add the two following lines of code to the `LoadState` method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在XAML已经设置好，我们所要做的就是实际加载数据并为页面设置`DataContext`！打开名为`FlickrPage.xaml.cs`的文件，并将以下两行代码添加到`LoadState`方法中：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We begin by initiating the load process. Remember that this is an asynchronous
    method, so it will start the process of requesting the data from the Internet.
    And then, we set the data context, which is what the XAML bindings use to pull
    their data from. See the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先启动加载过程。请记住，这是一个异步方法，因此它将开始从互联网请求数据的过程。然后，我们设置数据上下文，这是XAML绑定用来获取数据的。请参阅以下截图：
- en: '![Creating the UI](img/6761_04_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![创建UI](img/6761_04_03.jpg)'
- en: Summary
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter took you through the process of building a Windows Store application
    that uses a third party API to access information over the Internet. The asynchronous
    programming features of the language make it very easy to implement these features.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本章带您了解了构建Windows Store应用程序的过程，该应用程序使用第三方API访问互联网上的信息。语言的异步编程特性使得实现这些功能非常容易。
- en: 'Here are some ideas on how you can take the application you have built here
    further:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于如何进一步完善您在此构建的应用程序的想法：
- en: 'Make the application navigate to a larger version of the image when you tap
    on one of the thumbnails (**Hint**: Look at the `CreateUrl` method in `ApiPhoto`)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您点击缩略图时，使应用程序导航到图像的较大版本（**提示**：查看`ApiPhoto`中的`CreateUrl`方法）
- en: 'Find out what happens when the application cannot access the Internet (**Hint**:
    Review the *Error handling with asynchronous methods* section in [Chapter 3](ch03.html
    "Chapter 3. Asynchrony in Action"), *Asynchrony in Action*)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找出应用程序无法访问互联网时会发生什么（**提示**：查看[第3章](ch03.html "第3章。动态行为")中的*使用异步方法处理错误*部分，*动态行为*）
- en: 'Add the ability to look at different kinds of images (**Hint**: Experiment
    with the `Grid App` project template and look at different Flickr API methods,
    such as `flickr.photos.search`)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加查看不同类型图像的功能（**提示**：尝试使用`Grid App`项目模板，并查看不同的Flickr API方法，如`flickr.photos.search`）
- en: 'Think about adding paging to the list of photos (**Hint**: Look at the data
    in `ApiPhotos` and the `ISupportIncrementalLoading` interface)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思考将分页添加到照片列表中（**提示**：查看`ApiPhotos`中的数据和`ISupportIncrementalLoading`接口）
- en: Creating native applications that run on your local machine lets you optimize
    for hardware that is getting more powerful with every technology cycle. Using
    the new asynchronous programming functionality available to you in C# 5 will ensure
    that you can take advantage of that hardware. In the next chapter, we look to
    the cloud and build a web application using the ASP.NET MVC.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 创建在本地计算机上运行的本地应用程序，让您可以针对每个技术周期硬件性能不断提升进行优化。使用C# 5中可用的新的异步编程功能，将确保您能充分利用这些硬件。在下一章中，我们将转向云端，并使用ASP.NET
    MVC构建一个Web应用程序。

- en: Classes and Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Classes form the building blocks of software development and are essential
    for building good code. In this chapter, we will be looking at classes and generics
    and why we need to use them. The recipes we will be covering are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and implementing an abstract class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and implementing an interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using a generic class or method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using a generic interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you probably know, classes are simply containers for related methods and
    properties to describe an object in your software. An object is an instance of
    a specific class and, sometimes, mimics real-world things. When thinking of a
    car, you might create a vehicle class that contains certain attributes (properties)
    that all vehicles contain, such as automatic or manual transmission, wheel count
    (not all vehicles have only four wheels), or fuel type.
  prefs: []
  type: TYPE_NORMAL
- en: When we create an instance of the vehicle class, we can create a car object,
    an SUV object, and so on. Here lies the power of classes, which is to describe
    the world around us and translate it into a programming language that a compiler
    can understand.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and implementing an abstract class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many developers have heard about abstract classes, but their implementation
    is a mystery. How can you as a developer identify an abstract class and decide
    when to use one? The definition is quite a simple one actually. Once you understand
    this fundamental definition of an abstract class, when and why to use one becomes
    obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine for a moment that you are developing an application that manages the
    animals in a cat sanctuary. The cat sanctuary rehabilitates lions, tigers, jaguars,
    leopards, cheetahs, pumas, and even domestic cats. The common noun that describes
    all these animals is the word *cat*. You can, therefore, safely assume that the
    abstraction of all these animals is a cat, and thus, this word identifies our
    abstract class. You would then create an abstract class called `Cat`.
  prefs: []
  type: TYPE_NORMAL
- en: However, you need to keep in mind that you will never ever create an instance
    of the abstract class `Cat`. All the classes that inherit from the abstract class
    also share some functionality. This means that you will create a `Lion` class
    and a `Tiger` class that inherit from the abstract class `Cat`. In other words,
    the inherited classes are a kind of cat. Both classes share functionality in the
    form of `Sleep()`, `Eat()`, `Hunt()`, and various other methods. In this way,
    we can ensure that inherited classes all contain this common functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go ahead and create our abstract class for cat. We will then use it to
    inherit from and create other objects to define different types of cats.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new console application in Visual Studio and call it `ClassesAndGenerics`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an abstract class called `Cat`. To do this, add the `abstract` keyword
    to the class. We are now ready to describe the `Cat` abstract class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `abstract` keyword indicates to us that the object it is applied to has
    no implementation. When used in a class declaration, it basically tells the compiler
    that the class is to be used as a base class. This means that no instance of the
    class can be created. The only way in which implementation of the abstract class
    happens is when it is implemented by derived classes that inherit from the base
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your console application code should now look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add three methods to the abstract class called `Eat()`, `Hunt()`, and `Sleep()`.
    You will note that these methods don''t contain a body (curly braces). This is
    because they have been defined as abstract. As with abstract classes, the abstract
    methods contained within the abstract class contain no implementation. These three
    methods basically describe functionality that is common to all cats. All cats
    must eat, hunt, and sleep. Therefore, to ensure that all classes that inherit
    from the `Cat` abstract class contain this functionality, it is added to the abstract
    class. These methods are then implemented in the derived classes, which we will
    see in the upcoming steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to define two types of cats. The first type of cat we want to define
    is a lion. For this, we create a `Lion` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point in time, the `Lion` class is simply an ordinary class and does
    not contain any common functionality defined in the `Cat` abstract class. To inherit
    from the `Cat` abstract class, we need to add `: Cat` after the `Lion` class name.
    The colon indicates that the `Lion` class inherits from the `Cat` abstract class.
    The `Lion` class is therefore a derived class of the `Cat` abstract class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you specify that the `Lion` class inherits from the `Cat` class,
    Visual Studio will show you an error. This is expected, because we have told the
    compiler that the `Lion` class needs to inherit all the features of the `Cat`
    abstract class, but we have not actually added these features to the `Lion` class.
    The derived class is said to override the methods in the abstract class, and needs
    to specifically be written with the `override` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you hover over the red squiggly line underlining the `Lion` class, Visual
    Studio will offer an explanation for the error via the lightbulb feature. As you
    can see, Visual Studio is telling you that while you have defined the class to
    be inheriting from the abstract class, you have not implemented any of the abstract
    members of the `Cat` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_02_03.png)'
  prefs: []
  type: TYPE_IMG
- en: You can, therefore, see that using abstract classes is a fantastic way to enforce
    specific functionality within your system. If you define abstract members in an
    abstract class, the derived classes that inherit from that abstract class must
    implement those members; otherwise, your code will not compile. This can be used
    to enforce standards and practices adopted by your company or to simply allow
    other developers to implement certain best practices as they use your base class
    for their derived classes. With the advent of code analyzers in Visual Studio
    2015, the practice of enforcing certain code best practices is easily enforced.
  prefs: []
  type: TYPE_NORMAL
- en: To implement these members that Visual Studio is warning us about, place your
    mouse cursor on the `Lion` class name and hit *Ctrl* + *.* (period). You can also
    click on the Show potential fixes link in the lightbulb popup. Visual Studio will
    give you a small heads up, displaying the changes it will make to your code. You
    can preview these changes by clicking on the Preview changes link as well as fix
    all occurrences in the document, project, or solution by clicking on the appropriate
    link:![](img/B06434_02_04.png)
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: After Visual Studio has added the changes displayed in the suggestions window,
    your `Lion` class will be correct and will look like the code listing in the following
    step.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that Visual Studio automatically adds a `NotImplementedException`
    exception with the following line of code in each overridden method `throw new
    NotImplementedException();`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is the default behavior of Visual Studio when overriding methods in the
    base class. Basically, if you had to instantiate the `Lion` class without writing
    any implementation in the overridden methods, a runtime exception would be generated.
    The idea of inheriting from our abstract class was to extend it and implement
    common functionality. This is where we need to implement that functionality, and
    this is the reason there is no implementation in the abstract class. The abstract
    class just tells us that the following methods need to be implemented. The derived
    class does the actual implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and add some implementation to the overridden methods of the `Lion`
    class. First, add the `using static` statement for the `Console.WriteLine` method
    to the top of your class file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the implemented code for the methods as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create another class called `Tiger` that also derives from the
    abstract class `Cat`. Follow step 7 to step 10 to create the `Tiger` class and
    inherit the `Cat` abstract class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the same implementation for the `Tiger` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For our `Lion` class, add an enumerator for `ColorSpectrum` and a property
    called `LionColor`. It is here that the implementations of the `Lion` and `Tiger`
    classes will differ. While they both must implement the common functionality specified
    in the abstract class, namely, `Eat()`, `Hunt()`, and `Sleep()`, only the lion
    can have a color of either brown or white in its available range of colors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the `Lion()` constructor in our `Lion` class. This will allow us
    to specify a color for the lions in the cat sanctuary. The constructor also takes
    as a parameter a variable of the `ColorSpectrum` enumerator type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Slightly similar to this, but quite different in color, the `Tiger` class can
    only have a `ColorSpectrum` enumeration that defines tigers as being orange, white,
    gold, blue (yes, you actually get a blue tiger), or black. Add the `ColorSpectrum`
    enumerator to the `Tiger` class as well as a property called `TigerColor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will create a `Tiger()` constructor for our `Tiger` class to set
    the colors of tigers in the cat sanctuary to the valid colors that tigers are
    found in. By doing this, we are separating certain functionality specific only
    to tigers and lions in their respective classes, while all the common functionality
    is contained in the abstract class `Cat`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to instantiate the `Lion` and `Tiger` classes from the console
    application. You will see that we set the respective cat''s color from the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When you run your console application, you see that the methods are called in
    sequence:![](img/B06434_02_07.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the example illustrated earlier is a rather simplistic one, the theory
    is sound. The abstract class takes collective functionality across all cats and
    groups so that it can be shared inside each derived class. No implementation exists
    in the abstract class; it only defines what needs to happen. Think of abstract
    classes as a type of blueprint for classes that inherit from the abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the content of the implementation is up to you, the abstract class requires
    that you add the abstract methods it defines. From here on, you can create a solid
    foundation for similar classes in your applications that are supposed to share
    functionality. This is the goal of inheritance. Let''s recap the features of an
    abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: You can't instantiate an abstract class with the `new` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can only add abstract methods and accessors to an abstract class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can never modify an abstract class as `sealed`. The `sealed` modifiers prevents
    inheritance, while abstract requires inheritance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any class derived from your abstract class must include the implementations
    of the abstract methods that were inherited from the abstract class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because abstract methods inside the abstract class have no implementation, they
    don't contain a body either.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and implementing an interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For many developers, interfaces are equally confusing and their purpose not
    clearly understood. Interfaces are actually quite easy to get to grips with once
    you understand the concept that defines an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces act like verbs. So, for example, if we had to create two classes
    called `Lion` and `Tiger` that derive from the `Cat` abstract class, the interface
    would describe some sort of action. Lions and tigers can roar (but not purr).
    We can then create an interface called `IRoarable`. If we had to derive a class
    called `Cheetah` from our abstract class `Cat`, we would not be able to use the
    `IRoarable` interface, because cheetahs purr. We would need to create an `IPurrable`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating an interface is very similar to creating an abstract class. The difference
    is that the interface is describing what the class can do, in the case of the
    `Cheetah` class, by implementing `IPurrable`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you haven''t already done so in the previous recipe, create an abstract
    class called `Cat`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add a class called `Cheetah` that inherits from the `Cat` abstract class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you inherit from the `Cat` abstract class, Visual Studio will show
    you a warning via the lightbulb feature. As you inherited from the abstract class
    `Cat`, you have to implement the abstract members within the abstract class in
    your derived class `Cheetah`:![](img/B06434_02_08.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is easily fixable by typing *Ctrl* +*.* (period) and fixing all occurrences
    in the document. You can also do this for the project or solution. For our purpose,
    we only select the Document link at the bottom of the lightbulb suggestions. Visual
    Studio will automatically add the abstract methods defined in the abstract class
    to implement inside your `Cheetah` class:![](img/B06434_02_09.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will notice that Visual Studio adds just the methods you need to override
    but will throw `NotImplementedException` if you try to use the class as is. The
    reason for using an abstract class is to implement the functionality defined in
    the abstract class `Cat` in the derived class `Cheetah`. Not doing so contravenes
    the rules for using abstract classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To add some implementation, modify your `Cheetah` class as follows. The implementation
    in the overridden methods is simple, but this validates the rule of writing some
    sort of implementation in the overridden methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that the `WriteLine` method is used without the `Console` class.
    This is because we are using a new feature introduced in C# 6.0 that allows developers
    to bring static classes into scope by adding the `using static System.Console;`
    statement to the top of your class file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an interface called `IPurrable` that will be implemented in the `Cheetah`
    class. A common naming convention for interfaces dictates that the interface name
    should be prefixed with a capital `I`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add a method to the interface that any class implementing the
    interface must implement. You will notice that the interface''s `SoftPurr` method
    contains no implementation at all. It, however, specifies that we will need to
    pass this method an integer value for the decibel that the `Cheetah` class will
    purr at:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to implement the `IPurrable` interface in the `Cheetah` class.
    To do this, we need to add the `IPurrable` interface name after the `Cat` abstract
    class name. If the `Cheetah` class did not inherit from the abstract class, then
    the interface name would simply follow after the colon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: After specifying that the `Cheetah` class implements the `IPurrable` interface,
    Visual Studio once again displays a warning via the lightbulb feature. It is warning
    us that the `Cheetah` class does not implement the `SoftPurr` method defined in
    the interface `IPurrable`:![](img/B06434_02_10.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we did earlier, we can let Visual Studio suggest possible fixes for the problems
    encountered by typing *Ctrl* + *.* (period). Visual Studio suggests that the interface
    can be implemented implicitly or explicitly:![](img/B06434_02_11.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Knowing when to use an implicit or explicit implementation is also quite easy.
    We first need to know when using one over the other would be preferred. Let''s
    start off by implementing the `SoftPurr` method implicitly by selecting the first
    option in the lightbulb suggestion. You will see that this uses the `SoftPurr`
    method defined in the `IPurrable` interface as if it were part of the `Cheetah`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the `SoftPurr` method, it looks like a normal method inside the
    `Cheetah` class. This would be fine unless our `Cheetah` class already contains
    a property called `SoftPurr`. Go ahead and add a property called `SoftPurr` to
    your `Cheetah` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Visual Studio immediately displays a warning by telling us that the `Cheetah`
    class already contains a definition for `SoftPurr`:![](img/B06434_02_12-1.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is here that the use of an explicit implementation becomes evident. This
    specifies that the `SoftPurr` method is a member of the implementation defined
    in the `IPurrable` interface:![](img/B06434_02_13.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Therefore, selecting the second option to implement the interface explicitly
    will add the `SoftPurr` method to your `Cheetah` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The compiler now knows that this is an interface that is being implemented and
    is therefore a valid line of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purposes of this book, let''s just use the implicit implementation.
    Let''s write some implementation for the `SoftPurr` method and use the new `nameof`
    keyword (introduced in C# 6.0) as well as the interpolated string for the output.
    Also, remove the `SoftPurr` property added earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Heading over to our console application, we can call our `Cheetah` class as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Running the application will produce the following output:![](img/B06434_02_14.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, you might be wondering what the difference between an abstract class and
    an interface is. It basically comes down to where you want your implementation.
    If you need to share functionality between derived classes, then an abstract class
    is the best fit for your needs. In other words, we had specific things that were
    common to all cats (lions, tigers, and cheetahs) such as hunting, eating, and
    sleeping. This is then best used within an abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: If your implementation is specific to a class or several classes (but not all
    classes), then your best course of action would be to use an interface. In this
    case, the `IPurrable` interface can be applied to several classes (for example,
    cheetahs and domestic cats) but can't be applied to all cats (such as lions and
    tigers), because not all cats can purr.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing this difference and where you need to place your implementation will
    aid you in deciding whether you need to use an abstract class or an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using a generic class or method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics is a very interesting way of writing code. Instead of specifying the
    data type of the elements in the code at design time, you can actually delay the
    specification of those elements until they are used in code. This basically means
    that your class or method can work with any data type.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start off by writing a generic class that can take any data type as
    a parameter in its constructor and do something with it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Declaring a generic class is actually very easy. All that we need to do is
    create the class with the generic type parameter `<T>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The generic type parameter is basically a placeholder for a specific type that
    will need to be defined when the class of variable is instantiated. This means
    that the generic class `PerformAction<T>` can never just be used without specifying
    the type argument inside angle brackets when instantiating the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a `private` variable of the generic type parameter `T`. This will
    hold the value we pass to the generic class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to add a constructor to the generic class. The constructor will
    take as parameter a value of type `T`. The private variable `_value` will be set
    to the parameter passed to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to complete our generic class, create a void return method called
    `IdentifyDataType()`. All that this is going to do is tell us what data type we
    passed to the generic class. We can find the type of the variable using `GetType()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the true beauty of our generic class in action, instantiate the generic
    class in the console application and specify different data type arguments inside
    the angle brackets of each new instantiation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Running your console application will output the given data types that you instantiated
    the generic class with each time:![](img/B06434_02_15.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We used the exact same class but let it perform with three very different data
    types. This kind of flexibility is a very powerful feature in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another feature of C# is that you can constrain the generic types implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by telling the compiler that only types that implement the `IDisposable`
    interface can be used with the generic class. Change your generic class by adding
    `where T : IDisposable` to it. Your generic class should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Go back to the console application and take a look at the previous instantiations
    of the generic class:![](img/B06434_02_16.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio will tell you that the types underlined by the red squiggly lines
    do not implement `IDisposable` and therefore can't be supplied to the `PerformAction`
    generic class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment out those lines of code and add the following instantiation to your
    console application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that for this to work, you might need to add `using System.Data;` to your
    code file. This is needed so that you can declare a `DataSet`.
  prefs: []
  type: TYPE_NORMAL
- en: As you might know, a `DataSet` type implements `IDisposable` and therefore it
    is a valid type to pass to our generic class. Go ahead and run the console application:![](img/B06434_02_17.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `DataSet` type is valid, and the generic class performs as expected, identifying
    the type of the parameter passed to the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what about generic methods? Well, just like generic classes, generic methods
    also do not specify their type at design time. It is only known when the method
    is called. Let''s take a look at the following implementation of the generic methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and create a new helper class called `MyHelperClass`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this helper class, we will create a generic method called `InspectType`.
    What is interesting about this generic method is that it can return multiple types
    because the return type is also marked with the generic type parameter. Your generic
    method does not have to return anything. It can also be declared as `void`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate that this generic method can return multiple types, we will output
    the type passed to the generic method to the console window and then return that
    type and display it in the console application. You will notice that you need
    to cast the return type as `(T)` when returning it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the console application, go ahead and create an enumerator called `MyEnum`.
    The generic method can also accept enumerators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the enumerator, add the following code to the console application.
    We are instantiating and calling the `oHelper` class and passing different values
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If you run the console application, you will see that the generic method correctly
    identifies the type of the parameter passed to it and then returns that type to
    the calling code in the console application:![](img/B06434_02_18.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generic methods can be used in a multitude of situations. This is, however,
    only an introduction to generic classes and methods. It is recommended that you
    do further research to learn how to implement generics in your code appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the heart of generics lies the ability to reuse a single class or method.
    It allows developers to essentially not repeat similar code throughout your code
    base. This conforms well to the **Don't Repeat Yourself** (**DRY**) principle.
    This design principle states that a specific bit of logic should be represented
    in code only once.
  prefs: []
  type: TYPE_NORMAL
- en: Using generic classes, for example, also allows developers to create a class
    that is type safe when compiling. Type safe basically means that the developer
    can be assured of the type of the object and can use the class in a specific way
    without experiencing any unexpected behavior. Therefore, the compiler takes over
    the burden of type safety.
  prefs: []
  type: TYPE_NORMAL
- en: Generics also allow developers to write less code, because code can be reused
    and less code also performs better.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using a generic interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generic interfaces work in much the same way as the previous examples in generics.
    Let's assume that we want to find the properties of certain classes in our code,
    but we can't be sure how many classes we will need to inspect. A generic interface
    could come in very handy here.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to inspect several classes for their properties. To do this, we will
    create a generic interface that will return a list of all the properties found
    for a class as a list of strings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following implementation of the generic interface
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and create a generic interface called `IListClassProperties<T>`. The
    interface will define a method that needs to be used called `GetPropertyList()`
    that simply uses a LINQ query to return a `List<string>` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a generic class called `InspectClass<T>`. Let the generic class
    implement the `IListClassProperties<T>` interface created in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As usual, Visual Studio will highlight that the interface member `GetPropertyList()`
    has not been implemented in the `InspectClass<T>` generic class:![](img/B06434_02_19.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To show any potential fixes, type *Ctrl* + *.* (period) and implement the interface
    implicitly:![](img/B06434_02_20.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will create the `GetPropertyList()` method in your `InspectClass<T>` class
    without any implementation. You will add the implementation in a moment. If you
    try to run your code without adding any implementation to the `GetpropertyList()`
    method, the compiler will throw `NotImplementedException`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add a constructor to your `InspectClass<T>` class that takes a generic
    type parameter and sets it equal to a private variable `_classToInspect` that
    you also need to create. This is setting up the code that we will use to instantiate
    out class. We will pass to the object we need a list of properties from the constructor,
    and the constructor will set the private variable `_classToInspect` so that we
    can use it in our `GetPropertyList()` method implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish off our class, we need to add some implementation to the `GetPropertyList()`
    method. It is here that the LINQ query will be used to return a `List<string>`
    object of all the properties contained in the class supplied to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving to our console application, go ahead and create a simple class called
    `Invoice`. This is one of several classes that can be used in the system, and
    the `Invoice` class is one of the smaller classes. It usually just holds invoice
    data specific to a record in the invoices records of the data store you connect
    to. We need to find a list of the properties in this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now make use of our `InspectClass<T>` generic class that implements
    the `IListClassProperties<T>` generic interface. To do this, we will create a
    new instance of the `Invoice` class. We will then instantiate the `InspectClass<T>`
    class, passing the type in the angle brackets and the `oInvoice` object to the
    constructor. We are now ready to call the `GetPropertyList()` method. The result
    is returned to a `List<string>` object called `lstProps`. We can then run `foreach`
    on the list, writing the value of each `property` variable to the console window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and run the code to see the output generated by inspecting the properties
    of the `Invoice` class:![](img/B06434_02_21.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, the properties are listed as they exist in the `Invoice` class.
    The `IListClassProperties<T>` generic interface and the `InspectClass<T>` class
    don't care what type of class they need to inspect. They will take any class and
    run the code on it and produce a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the preceding implementation still poses a slight problem. Let''s
    take a look at one of the variations of this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code in the console application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we have easily passed an integer value and type to the `InspectClass<T>`
    class, and the code does not show any warnings at all. In fact, if you ran this
    code, nothing would be returned and nothing outputs to the console window. What
    we need to do is implement the constraints on our generic class and interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the interface implementation after the class, add the `where
    T : class` clause. The code now needs to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If we returned to our console application code, you will see that Visual Studio
    has underlined the `int` type passed to the `InspectClass<T>` class:![](img/B06434_02_22.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reason for this is because we defined a constraint against our generic class
    and interface. We told the compiler that we only accept reference types. Therefore,
    this applies to any class, interface array, type, or delegate. Our `Invoice` class
    will therefore be a valid type, and the constraint will not apply to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also be more specific in our type parameter constraints. The reason
    for this is that we perhaps do not want to constrain the parameters to reference
    types. If we, for example, wanted to button down the generic class and interface
    to only accept classes created inside our current system, we can implement a constraint
    that the argument for `T` needs to be derived from a specific object. Here, we
    can use abstract classes again:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an abstract class called `AcmeObject` and specify that all classes that
    inherit from `AcmeObject` implement a property called `ID`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now ensure that objects we create in our code which we need to read
    the properties from are derived from `AcmeObject`. To apply the constraint, modify
    the generic class and place the `where T : AcmeObject` constraint after the interface
    implementation. Your code should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the console application, modify the `Invoice` class to inherit from the
    `AcmeObject` abstract class. Implement the `ID` property as defined in the abstract
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Create two more classes called `SalesOrder` and `CreditNote`. This time, however,
    only make the `SalesOrder` class inherit from `AcmeObject`. Leave the `CreditNote`
    object as is. This is so that we can clearly see how the constraint can be applied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the code needed to get the property list for the `Invoice` and `SalesOrder`
    classes. The code is straightforward, and we can see that Visual Studio does not
    complain about either of these two classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If, however, we had to try do the same for our `CreditNote` class, we will see
    that Visual Studio will warn us that we can't pass the `CreditNote` class to the
    `InspectClass<T>` class because the constraint we implemented only accepts objects
    that derive from our `AcmeObject` abstract class. By doing this, we have effectively
    taken control over exactly what we allow to be passed to our generic class and
    interface by means of constraints:![](img/B06434_02_23.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Speaking of generic interfaces, we have seen that we can implement behavior
    on a generic class by implementing a generic interface. The power of using the
    generic class and generic interface is well illustrated earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, we do believe that knowing when to use constraints is also
    important so that you can close down your generic classes to only accept specific
    types that you want. This ensures that you don't get any surprises when someone
    accidentally passes an integer to your generic class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the constraints that you can use are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`where T: struct`: The type argument must be any value types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`where T: class`: The type argument must be any reference types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`where T: new()`: The type argument needs to have a parameterless constructor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`where T: <base class name>`: The type argument must derive from the given
    base class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`where T: <T must derive from object>`: `T` The type arg was must derive must
    derive from the object after the colon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`where T: <interface>`: The type argument must implement the interface specified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

- en: Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Regular expressions** (**regex**) are something of a mystery to many developers.
    We admit that they are something that we use often enough to warrant a deeper
    understanding of how they work. On the flip side, there are so many tried and
    tested regex patterns on the Internet, that just reusing one that already exists
    is easier than trying to create one yourself most times. The subject of regex
    is much larger than what can be explained in a single chapter in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in this chapter, we will merely introduce some of the concepts of
    regex. For a deeper understanding of regex, further study is needed. For the purpose
    of this book, however, we will take a closer look at how regular expression are
    created and how they can be applied to some common programming problems. In this
    chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with regex - Matching a valid date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sanitize input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic regex matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A regular expression is a pattern that describes a string through the use of
    special characters that denote a specific bit of text to match. The use of regular
    expression is not a new concept in programming. For regex to work, it needs to
    use a regex engine that does all the heavy lifting.
  prefs: []
  type: TYPE_NORMAL
- en: In the .NET Framework, Microsoft has provided for the use of regex. To use regex,
    you will need to import the `System.Text.RegularExpressions` assembly to your
    project. This will allow the compiler to use your regex pattern and apply it to
    the specific text you need to match.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, regex have a specific set of metacharacters that hold special meaning
    to the regex engine. These characters are `[ ]`, `{ }`, `( )`, `*`, `+`, , `?`,
    `|`, `$`, `.`, and `^`.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the curly brackets `{ }`, for example, enables developers to specify
    the number of times a specific set of characters need to occur. Using square brackets,
    on the other hand, defines exactly what needs to be matched.
  prefs: []
  type: TYPE_NORMAL
- en: If we, for example, specified `[abc]`, the pattern would look for lowercase
    As, Bs, and Cs. regex, therefore, also allows you to define a range, for example,
    `[a-c]`, which is interpreted in exactly the same way as the `[abc]` pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions then also allow you to define characters to exclude using
    the `^` character. Therefore, typing `[^a-c]` would find lowercase D through Z
    because the pattern is telling the regex engine to exclude lowercase As, Bs, and
    Cs.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions also define `d` and `D` a type of shortcut for `[0-9]` and
    `[^0-9]`, respectively. Therefore, `d` matches all numeric values, and `D` matches
    all non-numeric values. Another shortcut is `w` and `W`, which match any character
    from lowercase A to Z, irrespective of the case, all numeric values from 0 to
    9, and the underscore character. Therefore, `w` is `[a-zA-Z0-9_]`, while `W` is
    `[^a-zA-Z0-9_]`.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of regex are rather easy to understand, but there is a lot more that
    you can do with regex.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with regex - Matching a valid date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you haven''t done so already, create a new console application and add a
    class to the project called `RegExDemo`. Your code at this moment should look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the purpose of this book, we are using a console application to illustrate
    the use of regex. In reality, you would probably not have this logic mixed in
    between your production code, because this would result in code being rewritten.
    The best place to add something such as regex is in a helper class within an extension
    method.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the console application, add the following `using` statement so that we
    can use the regex assembly in .NET:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will create a regex to validate a date pattern of yyyy-mm-dd, yyyy/mm/dd,
    or yyyy.mm.dd. At first, the regex will look daunting, but bear with me. When
    you have completed the code and run the application, we will dissect the regex.
    Hopefully, the expression logic will become clear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `RegExDemo` class, create a new method called `ValidDate()` that
    takes a string as the parameter. This string will be the date pattern we want
    to validate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following regex pattern to your method to a variable in the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the regex to match the supplied string parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have done this, your method should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Going back to your console application, add the following code and debug your
    application by clicking on Start:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that if you add the `using static System.Console;` namespace,
    you then just need to call `Read()` instead of `Console.Read()`. This new feature
    where you could import static namespaces was added in C# 6.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The date strings are passed to the regex, and the pattern is matched against
    the date string in the parameter. The output is displayed in the console application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_05_008.png)'
  prefs: []
  type: TYPE_IMG
- en: If you look at the output carefully, you will notice that there is a mistake.
    We are validating the date string in the format yyyy-mm-dd, yyyy/mm/dd, and yyyy.mm.dd.
    If we use this logic, our regex has incorrectly flagged a valid date as invalid.
    This is the date `2016.4.10`, which is April 10, 2016, and is in fact quite valid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will explain shortly why the date `1800-01-21` is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to your `ValidDate()` method and change the regular expression to read
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the console application again and look at the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_05_009.png)'
  prefs: []
  type: TYPE_IMG
- en: This time the regex worked for all the given date strings. But what exactly
    did we do? This is how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the two expressions used in the previous code
    example. Comparing them with each other, you can see the change we made in yellow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we get to what that change means, let''s break up the expression and
    view the individual components. Our regex is basically saying that we must match
    all string dates that start with 19 or 20 and have the following separators:'
  prefs: []
  type: TYPE_NORMAL
- en: Dash (`-`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decimal (`.`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forward slash (`/`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand the expression better, we need to understand the following format
    of the expression *<Valid Years><Valid Separators><Valid Months><Valid Separators><Valid
    Days>*.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to be able to tell the regex engine to consider one *OR* another
    pattern. The word *OR* is symbolized by the `|` metacharacter. To make the regex
    engine consider the word *OR* without splitting up the whole expression, we wrap
    it in the parenthesis `()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the symbols used in the regex:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **The conditional OR** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | This denotes the *OR* metacharacter. |'
  prefs: []
  type: TYPE_TB
- en: '| **The year portion** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `(19&#124;20)` | Only allow 19 or 20 |'
  prefs: []
  type: TYPE_TB
- en: '| `dd` | Matches two single digits between 0 and 9\. To match only one digit
    between 0 and 9, you would use `d`. |'
  prefs: []
  type: TYPE_TB
- en: '| **The valid separator character set** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `[-./]` | Matches any of the following characters in the character set. These
    are our valid separators. To match a space date separator, you would change this
    to `[- ./]`, where you add a space anywhere in the character set. We added the
    space between the dash and the decimal. |'
  prefs: []
  type: TYPE_TB
- en: '| **Valid digits for months and days** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `0[1-9]` | Matches any part starting with zero followed by any digit between
    1 and 9\. This will match 01, 02, 03, 04, 05, 06, 07, 08, and 09. |'
  prefs: []
  type: TYPE_TB
- en: '| `1[0-2]` | Matches any part starting with 1 followed by any digit between
    0 and 2\. This will match 10, 11, or 12. |'
  prefs: []
  type: TYPE_TB
- en: '| `[1-9]` | Matches any digit between 1 and 9. |'
  prefs: []
  type: TYPE_TB
- en: '| `[12][0-9]` | Matches any part starting with 1 or 2 followed by any digit
    between 0 and 9\. This will match all number strings between 10 and 29. |'
  prefs: []
  type: TYPE_TB
- en: '| `3[01]` | Matches any part starting with 3 and followed by 0 or 1\. This
    will match 30 or 31. |'
  prefs: []
  type: TYPE_TB
- en: '| **Start and end of string** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Tells the regex engine to start at the beginning of the given string
    to match. |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | Tells the regex engine to stop at the end of the given string to match.
    |'
  prefs: []
  type: TYPE_TB
- en: 'The first regex we created, interprets as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`^`: Start at the beginning of the string to match'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(19|20)`: Check whether the string starts with 19 or 20'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dd`: After the check, follows two single digits between 0 and 9'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[-./]`: The year portion ends followed by a date separators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(0[1-9]|1[0-2])`: Find the month logic by looking for digits starting with
    0, followed by any digit between 1 and 9, *OR* digits starting with 1, followed
    by any digit between 0 and 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[-./]`: The month logic ends followed by a date separator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(0[1-9]|[12][0-9]|3[01])`: Then, find the day logic by looking for digits
    starting with 0, followed by a digit between 1 and 9, OR digits starting with
    1 or 2, followed by any digit between 0 and 9, OR a digit matching 3, followed
    by any digit between 0 and 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`: Do this until the end of the string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our first regex was incorrect because our month logic was incorrect. Our month
    logic dictates to find the month logic by looking for digits starting with a 0
    followed by any digit between 1 and 9 or digits starting with a 1 followed by
    any digit between 0 and 2 `(0[1-9]|1[0-2])`.
  prefs: []
  type: TYPE_NORMAL
- en: This will then find 01, 02, 03, 04, 05, 06, 07, 08, 09, or 10, 11, 12\. The
    date that it didn't match was `2016.4.10` (the date separators don't make a difference
    here). This is because our month came through as a single digit, and we were looking
    for months where the single digits started with a zero. To fix this, we had to
    modify the expression of the month logic to include single digits only between
    1 and 9\. We did this by adding `[1-9]` to the expression at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'The modified regex then read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`^`: Start at the beginning of the string to match'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(19|20)`: Check whether the string starts with 19 or 20'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dd`: After the check, follows two single digits between 0 and 9'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[-./]`: The year portion ends followed by a date separator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(0[1-9]|1[0-2])`: Find the month logic by looking for digits starting with
    0, followed by any digit between 1 and 9, OR digits starting with 1, followed
    by any digit between 0 and 2 or any single digits between 1 and 9'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[-./]`: The month logic ends followed by a date separator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(0[1-9]|[12][0-9]|3[01])`: Then, find the day logic by looking for digits
    starting with 0, followed by a digit between 1 and 9, OR digits starting with
    1 or 2, followed by any digit between 0 and 9, OR a digit matching 3, followed
    by any digit between 0 and 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`: Do this until the end of the string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a basic regex, and we say basic because there is a lot more we can do
    to make the expression better. We can include logic to consider alternative date
    formats such as mm-dd-yyyy or dd-mm-yyyy. We can add logic to check February and
    validate that it contains only 28 days, unless it is a leap year, in which case
    we need to allow the twenty-ninth day of February. Furthermore, we can also extend
    the regex to check that January, March, May, July, August, October, and December
    have 31 days while April, June, September, and November contain only 30 days.
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizing input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you will need to sanitize input. This could be to prevent SQL injections
    or ensure that an entered URL is valid. In this recipe, we will look at replacing
    the bad words in a string with asterisks. We are sure that there are more elegant
    and code-efficient methods of writing sanitation logic using regex (especially
    when we have a large collection of blacklist words), but we want to illustrate
    a concept here.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ensure that you have added the correct assembly to your class. At the top of
    your code file, add the following line of code if you haven''t done so already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new method in your `RegExDemo` class called `SanitizeInput()` and
    let it accept a string parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a list of type `List<string>` to the method that contains the bad words
    we want to remove from the input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In reality, you might make use of a database call to read the blacklisted words
    from a table in the database. You would usually not hardcode them in a list like
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start constructing the regex that we will use to look for the blacklisted words.
    You concatenate the words with the `|` (OR) metacharacter so that the regex will
    match any of the words. When the list is complete, you can append the `b` expression
    to either side of the regex. This denotes a word boundary and, therefore, will
    only match whole words:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will add the `Regex.Replace()` method that takes the input and
    looks for the occurrence of the words defined in the pattern, while ignoring case
    and replacing the bad words with `*****`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have completed this, your `SanitizeInput()` method will look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the console application, add the following code to call the `SanitizeInput()`
    method and run your application (if you have already instantiated an instance
    of `RegExDemo` in the previous recipe, you don''t need to do it again):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run your application, you will see the following in the console window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_05_011.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a closer look at the regular expression generated.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s step through the code to understand what is happening. We need to get
    a regex that looks like this: `b(wordToMatch1|wordToMatch2|wordToMatch3)b`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What this basically says is "find me any of the words and only whole words
    which are denoted by `b`". When we look at the list we created, we will see the
    words we want to remove from the input string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We then created a simple loop that will create the list of words to match using
    the OR metacharacter. We ended up with a `BadWord1|BadWord2|BadWord3` pattern
    after the `foreach` loop has completed. However, this is still not a valid regex:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_013.png)'
  prefs: []
  type: TYPE_IMG
- en: To complete the pattern resulting in the valid regex, we need to add the `b`
    expression on either side of the pattern to tell the regex engine to only match
    whole words. As you can see, we are using string interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is here, however, that we need to be very careful. Start off by writing
    the code to complete the pattern without the `@` sign as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run your console application, you will see that the bad words are not
    matched and filtered out. This is because we have not escaped the character before
    `b`. The compiler, therefore, interprets this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_014.png)'
  prefs: []
  type: TYPE_IMG
- en: The generated expression `[](BadWord1| BadWord2| BadWord3)[]` is not a valid
    expression and will, therefore, not sanitize the input string.
  prefs: []
  type: TYPE_NORMAL
- en: 'To correct this, we need to add the `@` symbol before the string to tell the
    compiler to treat the string as a literal. This means any escape sequences are
    ignored. The correctly formatted line of code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you do this, the string for the pattern is interpreted literally by the
    compiler, and the correct regex pattern generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With our correct regex pattern, we called the `Regex.Replace()` method. It
    takes the input to check, the regex to match, the text to replace the matched
    words with, and optionally allows for the ignoring of the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_016.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the string returns to the calling code in the console application, the
    string will be sanitized properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_05_017.png)'
  prefs: []
  type: TYPE_IMG
- en: Regex can become quite complex and can be used to perform a multitude of tasks
    to format and validate input and other text.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic regex matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does dynamic regex matching even mean? Well, it isn't an official term,
    but it is a term we use to explain a regex that uses variables at runtime to generate
    a specific expression. Assume for a minute that you are working on a document-management
    system that needs to implement versioning of documents for a company called ACME
    Corporation. To do this, the system validates that the document has a valid filename.
  prefs: []
  type: TYPE_NORMAL
- en: A business rule states that the filename of any file uploaded on a specific
    day must be prefixed with `acm` (for ACME) and today's date in the yyyy-mm-dd
    format. They can be only text files, Word documents (only `.docx`) and Excel documents
    (only `.xlsx`). Any documents not conforming to this file format are processed
    by another method that takes care of archive and invalid documents.
  prefs: []
  type: TYPE_NORMAL
- en: The only task that your method needs to perform is to process fresh documents
    as version one documents.
  prefs: []
  type: TYPE_NORMAL
- en: In a production system, further logic will probably be needed to determine whether
    the same document has been uploaded previously on the same day. This, however,
    is beyond the scope of this chapter. We are just trying to set the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ensure that you have added the correct assembly to your class. At the top of
    your code file, add the following line of code if you haven''t already done so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A really nice way to do this is to use an extension method. This way, you can
    call the extension method directly on the filename variable and have it validated.
    In your console application, start off by adding a new class called `CustomRegexHelper`
    with `public static` modifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the usual extension method code to the `CustomRegexHelper` class and call
    the `ValidAcmeCompanyFilename` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside your `ValidAcmeCompanyFilename` method, add the following regex. We
    will explain the makeup of this regex in the *How it works...* section of this
    recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When you completed this, your extension method should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in the console application, create a method with `void` return type called
    `DemoExtensionMethod()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some output text to show the current date and the valid filename types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the filename checking code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You will note that the `if` statement contains the call to the extension method
    on the variable that contains the filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have completed this, your method should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Going back to the console application, add the following code that simply calls
    the `void` method. This is just to simulate the versioning method talked about
    earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When you are done, run your console application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_05_018.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a closer look at the regex generated. The line of code we are looking
    at is the `return` statement in the extension method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To appreciate what is happening, we need to break this expression up into the
    different components:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **The conditional OR** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | This denotes the *OR* metacharacter. |'
  prefs: []
  type: TYPE_TB
- en: '| **The file prefix and separator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `acm` | The file must begin with the text `acm`. |'
  prefs: []
  type: TYPE_TB
- en: '| `[_]` | The only valid separator between the date components and the prefix
    in the file name is an underscore. |'
  prefs: []
  type: TYPE_TB
- en: '| **The date parts** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `{DateTime.Now.Year}` | The interpolated year part of the date for the file
    name. |'
  prefs: []
  type: TYPE_TB
- en: '| `{DateTime.Now.Month}` | The interpolated month part of the date for the
    file name. |'
  prefs: []
  type: TYPE_TB
- en: '| `0[{DateTime.Now.Month}]` | The interpolated month part of the date with
    a leading zero for the file name. |'
  prefs: []
  type: TYPE_TB
- en: '| `{DateTime.Now.Day}` | The interpolated day part of the date for the file
    name. |'
  prefs: []
  type: TYPE_TB
- en: '| `0[{DateTime.Now.Day}]` | The interpolated day part of the date with a leading
    zero for the file name. |'
  prefs: []
  type: TYPE_TB
- en: '| **Valid file formats** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `(.txt&#124;.docx&#124;.xlsx)` | Match any of these file extensions for text
    documents, Word documents, or Excel documents. |'
  prefs: []
  type: TYPE_TB
- en: '| **Start and end of string** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Tells the regex engine to start at the beginning of the given string
    to match |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | Tells the regex engine to stop at the end of the given string to match
    |'
  prefs: []
  type: TYPE_TB
- en: Creating the regex in this manner allows us to always have it stay up to date.
    As we have to always match the current date to the file being validated, this
    creates a unique challenge that is easily overcome using string interpolation,
    `DateTime`, and regex *OR* statements.
  prefs: []
  type: TYPE_NORMAL
- en: Having a look at some of the more useful bits of regex, you will see that this
    chapter has not even begun to scratch the surface of what can be accomplished.
    There is a whole lot more to explore and learn. There are many resources on the
    Internet as well as some free (some online) and commercial tools that will assist
    you in creating regex.
  prefs: []
  type: TYPE_NORMAL

- en: Composing Event-Based Programs Using Reactive Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter deals with **Reactive Extensions** (**Rx**). To understand Rx,
    we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Rx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events versus observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using LINQ to perform queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using schedulers in Rx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, during your day-to-day dealings with developing applications in C#, you
    will have to use asynchronous programming. You might also have to deal with many
    data sources. Think of a web service that returns the current exchange rates,
    a Twitter search returning a stream of related data, or even different events
    generated by multiple computers. Rx provides an elegant solution in the form of
    the `IObserver<T>` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'You use the `IObserver<T>` interface to subscribe to the events. Then, the
    `IObservable<T>` interface, which maintains a list of `IObserver<T>` interfaces,
    will notify them of the change of state. In essence, Rx will stick together multiple
    data sources (social media, RSS feeds, UI events, and so on) that generate data.
    Rx, therefore, brings these data sources together in one interface. In fact, Rx
    can be thought of as consisting of three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Observables**: The interface that brings together and represents all these
    datastreams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language-Integrated Query** (**LINQ**): The ability to use LINQ to query
    these multiple datastreams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Schedulers**: Parameterizing concurrency using schedulers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The question on many minds might be why developers should use (or find a use
    for) Rx. Here are a few examples where Rx is really useful.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a search that has an autocomplete function. You don't want the code
    to perform a search for each value you type into the search area. Rx allows you
    to throttle the search.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the UI of your application more responsive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being notified when data changes instead of having to poll the data for changes.
    Think of real-time stock prices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To keep up to date with Rx, you can take a look at the [https://github.com/Reactive-Extensions/Rx.NET](https://github.com/Reactive-Extensions/Rx.NET) 
    GitHub page[.](https://github.com/Reactive-Extensions/Rx.NET)
  prefs: []
  type: TYPE_NORMAL
- en: Installing Rx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can begin exploring Rx, we need to install it. The easiest way to
    do this is using NuGet.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter on Rx, we will not create a separate class. All the code will
    be written in a console application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a console application, and then right-click on your solution and select
    Manage NuGet Packages for Solution... from the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the window that is displayed afterwards, type in `System.Reactive` in the
    search textbox and search for the NuGet installer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: At the time of writing this book, the last stable release was version 3.1.1\.
    If you have more than a single project, select the projects that you want to install
    Rx on. Seeing that we only have a single Console application, just select Rx to
    be installed for the whole project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next screen that is displayed is a confirmation dialog box, asking you to
    confirm the changes to the project. It will show a preview of the changes it will
    be making to each project. If you are happy with the changes, click on the OK
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A license agreement might be presented to you in the last dialog screen, which
    you will need to accept. To continue, click on the I Accept button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the installation is complete, you will see the references added to the
    Rx under the References node in your project. These are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`System.Reactive.Core`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Reactive.Interfaces`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Reactive.Linq`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Reactive.PlatformServices`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NuGet is by far the easiest way to add additional components to your projects.
    As you can see from the added references, `System.Reactive` is the main assembly.
    To gain a better understanding of `System.Reactive`, view the assemblies in Object
    Browser. To do this, double-click on any of the assemblies in the References option
    of your project. This will display the Object Browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: '`System.Reactive.Linq` contains all the querying functionality in Rx. You will
    also notice that `System.Reactive.Concurrency` contains all the schedulers.'
  prefs: []
  type: TYPE_NORMAL
- en: Events versus observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Being developers, we should all be quite familiar with events. Most developers
    have been creating events since we started writing code. In fact, if you have
    even dropped a button control on a form and double-clicked the button to create
    the method that handles the click of the button, you have created an event. In
    .NET, we can declare events using the `event` keyword, publish to the event by
    invoking it, and subscribe to that event by adding a handler to the event. We,
    therefore, have the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Rx, we have a similar structure where we declare a datastream, publish
    data to that stream, and subscribe to it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will see how an event works in C#. We will then see the working of
    an event using Rx and, in doing so, highlight the differences.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In your console application, add a new class called `DotNet`. To this class,
    add a property called `AvailableDatatype`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the main program class, add a new static action event called `types`. Basically,
    this is just a delegate and will receive some value; in our case, the available
    .NET data types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `void Main`, create a `List<DotNet>` class called `lstTypes`. Inside
    this list, add several values of type `DotNet` class. Here, we will just add hardcoded
    data of some of the data types in .NET:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next task is to subscribe to this event with an event handler that is simply
    outputting the value of *x* to the console window. We then raise the event each
    time we loop through our `lstTypes` list by adding the line `types(lstTypes[i].AvailableDatatype);`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In reality, before raising an event we should always check that the event isn't
    null. Only after this check should we raise the event. For brevity, we have not
    added this check before raising the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have added all the code from step 1 to step 4, your console application
    should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Running your application will set our list with values and then raise the event
    created to output the values of the list to the console window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_10_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see the working of events using Rx. Add a static `Subject` of `string`.
    You might also need to add the `System.Reactive.Subjects` namespace to your project
    as `Subjects` live in this separate namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After the code that created the list of `DotNet`, we used `+=` to wire up an
    event handler. This time round, we will use `Subscribe`. This is the `IObservable`
    portion of the code. After you''ve added this, raise the event using the `OnNext`
    keyword. This is the `IObserver` portion of the code. Therefore, as we loop through
    our list, we will call `OnNext` to pump out the values to the subscribed `IObservable`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When you''ve completed adding all the code, your application should look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When you run your application, you will see the same items are output to the
    console window, as it did earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Rx, we can declare an event stream with the `Subject` keyword. So, we have
    a source of events that we can publish to using `OnNext`. To see those values
    in the console window, we subscribed to the event stream using `Subscribe`.
  prefs: []
  type: TYPE_NORMAL
- en: Rx allows you to have objects that are just publishers or just subscribers.
    This is because the `IObservable` and `IObserver` interfaces are in fact separate.
    Also, note that in Rx, the observables can be passed as parameters, returned as
    results, and stored in variables, which makes them first class.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_10_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Rx also allows you to specify that the event stream is completed or that an
    error occurred. This really sets Rx apart from events in .NET. Also, it is important
    to note that including the `System.Reactive.Linq` namespace in your project allows
    developers to write queries over the `Subject` type because a `Subject` is an
    `IObservable` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_10_05.png)'
  prefs: []
  type: TYPE_IMG
- en: This is another feature that sets Rx apart from the events in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Using LINQ to perform queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rx allows developers to use the `IObservable` interface, which represents synchronous
    datastreams, to write queries using LINQ. To recap, Rx can be thought of as consisting
    of three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Observables**: The interface that brings together and represents all these
    datastreams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language-Integrated Query** (**LINQ**): The ability to use LINQ to query
    these multiple datastreams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Schedulers**: Parameterizing concurrency using schedulers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will be looking at the LINQ functionality of Rx in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As observables are just datastreams, we can use LINQ to query them. In the following
    recipe, we will output text to the screen based on a LINQ query.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start by adding a new Windows forms project to your solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call the project `winformRx` and click on the OK button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Toolbox, search for the TextBox control and add it to your form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, add a label control to your form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_10_06.png)'
  prefs: []
  type: TYPE_IMG
- en: Right-click on your `winformRx` project and select Manage NuGet Packages...
    from the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the search textbox, enter `System.Reactive` to search for the NuGet package
    and click on the Install button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio will ask you to review the changes it's about to make to your
    project. Click on the OK button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before the installation starts, you might need to accept the license agreement
    by clicking on the I Accept button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the installation completes, you should see the newly added references
    to your `winformRx` project if you expand the References for the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, right-click on the project and set `winformRx` as your startup project
    by clicking on the Set as StartUp Project from the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the form load event handler for the form by double-clicking anywhere
    on the Windows form. To this form, add the `Observable` keyword. You will notice
    that the keyword is immediately underlined. This is because you are missing the
    reference to the LINQ assembly of `System.Reactive`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add this, press *Ctrl* + *.* (period) to bring up the possible suggestions
    to fix the issue. Select to add the `using System.Reactive.Linq` namespace to
    your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Continue adding the following code to your form load event. Basically, you
    are using LINQ and telling the compiler that you want to select the text from
    the event pattern that matches the text changed event of the textbox on the form
    called `textBox1`. After you have done that, add a subscription to the variable
    and tell it to output whatever it finds in the text to the label on the form called
    `label1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When we added the textbox and label to our form, we left the control names as
    default. If, however, you changed the default names, you would need to specify
    those names instead of `textBox1` and `label1` for the controls on the form.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the run button to run your application. The Windows form will be displayed
    with the textbox and label on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice that as you type, the text is output to the label on the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_10_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s jazz things up a bit by adding in a `Where` condition to the LINQ statement.
    We will specify that the `text` string must only select the text when it ends
    with a period. This means that the text will only be displayed in the label after
    each full sentence. As you can see, we aren''t doing anything special here. We
    are merely using standard LINQ to query our datastream and return the results
    to our `searchTerm` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your application and start typing in a line of text. You will see that
    nothing is output to the label control as you type, as was evident in the previous
    example before we added in our `Where` condition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_10_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a period and start adding a second line of text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_10_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will see that only after each period, the text entered is added to the
    label. Our `Where` condition is, therefore, working perfectly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_10_10-1.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The LINQ aspect of Rx allows developers to construct observables. Here are
    some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Observable.Empty<>`: This returns an empty observable sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable.Return<>`: This returns an observable sequence containing a single
    element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable.Throw<>`: This returns an observable sequence terminating with
    an exception'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable.Never<>`: This returns a non-terminating observable sequence that
    is infinite in duration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of LINQ in Rx allows the developer to manipulate and filter the datastream
    to return exactly what they need.
  prefs: []
  type: TYPE_NORMAL
- en: Using schedulers in Rx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we need to have an `IObservable` subscription run at a specific time.
    Imagine having to synchronize events across servers in different geographical
    areas and time zones. You might also need to read data from a queue while preserving
    the order in which the events occur. Another example would be to perform some
    kind of I/O task that could take some time to complete. Schedulers come in very
    handy in these situations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Additionally, you can consider reading up more on using schedulers on MSDN.
    Take a look at [https://msdn.microsoft.com/en-us/library/hh242963(v=vs.103).aspx.](https://msdn.microsoft.com/en-us/library/hh242963(v=vs.103).aspx)
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you haven't already done so, create a new Windows form application and call
    it `winformRx`. Open the form designer and in Toolbox, search for the TextBox
    control and add it to your form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add a label control to your form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click on your Windows form designer to create the onload event handler.
    Inside this handler, add some code to read the text entered into the textbox and
    only display that text 5 seconds after the user has stopped typing. This is achieved
    using the `Throttle` keyword. Add a subscription to the `searchTerm` variable,
    writing the result of the text input to the label control''s text property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that you might need to add `System.Reactive.Linq` in your `using` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run your application and start typing some text into the textbox. Immediately,
    we will receive an exception. It is a cross-thread violation. This occurs when
    there is an attempt to update the UI from a background thread. The `Observable`
    interface is running a timer from `System.Threading`, which isn''t on the same
    thread as the UI. Luckily, there is an easy way to overcome this. Well, it turns
    out that the UI-threading capabilities lie in a different assembly, which we find
    easiest to get via the Package Manager Console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_10_11.png)'
  prefs: []
  type: TYPE_IMG
- en: Navigate to View | Other Windows | Package Manager Console to access the Package
    Manager Console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will add the System.Reactive.Windows.Forms.3.1.1 to your `winformRx` project.
    You should, therefore, see the following in the output: Successfully installed
    'System.Reactive.Windows.Forms 3.1.1' to winformRx
  prefs: []
  type: TYPE_NORMAL
- en: Note that you need to ensure that the Default project selection is set to `winformRx`
    in the Package Manager Console. If you don't see this option, resize the Package
    Manager Console screen width ways until the option is displayed. This way you
    can be certain that the package is added to the correct project.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the installation completes, modify your code in the onload event handler
    and change `searchTerm.Subscribe(trm => label1.Text = trm);`, which does the subscription,
    to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that we are using the `ObserveOn` method here. What this basically
    tells the compiler is that the `this` keyword in `new ControlScheduler(this)`
    is actually a reference to our Windows form. Therefore, `ControlScheduler` will
    use the Windows forms timers to create the interval to update our UI. The message
    happens on the correct thread, and we no longer have our cross-thread violation.
  prefs: []
  type: TYPE_NORMAL
- en: If you have not added the `System.Reactive.Concurrency` namespace to your project,
    Visual Studio will underline the `ControlScheduler` line of code with a squiggly
    line. Pressing *Ctrl* + *.* (period) will allow you to add the missing namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This means that `System.Reactive.Concurrency` contains a scheduler that can
    talk to Windows forms controls so that it can do the scheduling. Run your application
    again and start typing some text into your textbox:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_10_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Around 5 seconds after we stop typing, the throttle condition is fulfilled
    and the text is output to our label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_10_13.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we need to keep in mind here from the code we created is that there is
    `ObserveOn` and `Subscribe`. You should not confuse the two. In most cases, when
    dealing with schedulers, you will use `ObserveOn`. The `ObserveOn` method allows
    you to parameterize where the `OnNext`, `OnCompleted`, and `OnError` messages
    run. With `Subscribe`, we parameterize where the actual subscribe and unsubscribe
    code runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to remember that Rx uses the threading timers (`System.Threading.Timer`)
    as a default, which is why we encountered the cross-thread violation earlier.
    As you saw though, we used schedulers to parameterize which timer to use. The
    way schedulers do this is by exposing three components. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The scheduler's ability to perform some action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order in which the action or work to be performed is executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A clock that allows the scheduler to have a notion of time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of a clock is important because it allows the developer to use timers
    on remote machines; for example (where there might be a time difference between
    you and them), to tell them to perform an action at a particular time.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to debug lambda expressions has been around since Visual Studio
    2015\. This is a fantastic addition to the features of our favorite IDE. It allows
    us to check the results of a lambda expression on the fly and modify the expression
    to test different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a very basic lambda expression and change it in the Watch window
    to produce a different value.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a console application and add a class called `LambdaExample` to the
    console application. Add a property to this class called `FavThings`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the console application, create a `List<LambdaExample>` object and add a
    few of your favorite things to this list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create an expression to return only the things starting with the string
    `"Sum"`. Here, we would obviously expect to see `Summer Rain` as a result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Place a breakpoint on the expression and run your application. When the code
    stops at the breakpoint, you can copy the lambda expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_10_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Paste the lambda expression `MyFavoriteThings.Where(feature => feature.FavThings.StartsWith("Sum"))` into
    your Watch windows and change the string in the `StartsWith` method from `Sum`
    to `Ice`. You will see that the result has changed and now displays an `Ice-cream` string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_10_15.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that if you are using Visual Studio 2017 RC, debugging lambda expressions
    will probably not work. You will receive anything from Internal error in the expression
    evaluator to a message stating Expression cannot contain lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this way, we're able to change and debug a lambda expression easily. This
    is something that was not possible in the previous versions before Visual Studio
    2015\. It is obviously of great importance to know this tip when working with
    these expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Another point to note is that you can do the same thing from the Immediate window
    in Visual Studio 2017, as well as pinned variables from the lambda expression.
  prefs: []
  type: TYPE_NORMAL

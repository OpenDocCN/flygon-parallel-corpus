- en: Writing Secure Code and Debugging in Visual Studio
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Visual Studio中编写安全代码和调试
- en: 'In this chapter, we will take a look at some examples of being more efficient
    as a developer when it comes to debugging your code. We will also be looking at
    how to write secure code. Writing secure code can be a challenge, but consider
    the following: if part of your code security involves making sure that passwords
    are securely stored, why write that code over and over between projects? Write
    the code once and implement it in every new project you create. The concepts we
    will be looking at are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一些例子，作为开发人员在调试代码时更高效的方式。我们还将看看如何编写安全的代码。编写安全的代码可能是一个挑战，但请考虑以下内容：如果您的代码安全的一部分涉及确保密码安全存储，为什么要在项目之间一遍又一遍地编写代码？只需编写一次代码，然后在创建的每个新项目中实施它。我们将要看的概念如下：
- en: Encrypting and storing passwords correctly
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确加密和存储密码
- en: Using SecureString in code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中使用SecureString
- en: Securing sensitive parts of the App.config/web.config
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护App.config/web.config的敏感部分
- en: Preventing SQL injection attacks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止SQL注入攻击
- en: Using IntelliTrace, diagnostic tools, and historical debugging
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用IntelliTrace、诊断工具和历史调试
- en: Setting conditional breakpoints
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置条件断点
- en: Using PerfTips to identify bottlenecks in code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PerfTips识别代码中的瓶颈
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Something that many developers tend to miss is the need to write secure code.
    Development deadlines and other project-related pressures cause developers to
    put delivering code above doing it the right way. Many of you might not agree
    with me, but believe me when I say that I have heard the excuse of, "We do not
    have the budget for this," one too many times. This is usually when the development
    budget has been determined by other stakeholders and the developer not consulted.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员经常忽视的一点是编写安全的代码。开发期限和其他与项目相关的压力会导致开发人员将交付代码置于正确方式之上。你们中的许多人可能不同意我，但相信我，我已经听到“我们没有预算”这样的借口太多次了。这通常是在开发预算已由其他利益相关者确定且未经开发人员咨询时发生的。
- en: Consider a situation where a consultant tells the developer that they have sold
    a system to a customer. That system now needs to be developed. Furthermore, the
    developer is told that they have *x* amount of hours to complete the development.
    A document outlining the requirements is given to the developer and the developer
    is given the go-ahead to begin, and to complete development in the required time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一种情况，顾问告诉开发人员他们已经向客户出售了一个系统。现在需要开发该系统。此外，开发人员被告知他们有*x*小时来完成开发。给开发人员提供了一份概述需求的文件，并允许开发人员开始，并在规定的时间内完成开发。
- en: This scenario is the reality many developers face. You might think that this
    scenario can't possibly exist, or perhaps you are reading this and relate to the
    scenario as being how the process currently works in your company. Whatever the
    case may be, this is something that happens today in software development.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况是许多开发人员面临的现实。你可能认为这种情况不可能存在，或者你正在阅读这篇文章，并将这种情况视为你公司目前的工作流程。无论情况如何，这是今天软件开发中发生的事情。
- en: So, how do developers combat project suicide (I call these projects this because
    projects approached like this rarely succeed)? Start by creating reusable code.
    Think of processes you repeat often enough to warrant writing a reusable DLL for.
    Did you know that you can create Visual Studio templates? If you have a standard
    project structure you use, create a template from it and reuse it for each new
    project, thereby speeding up delivery and cutting down on bugs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，开发人员如何应对项目自杀（我将这些项目称为这样，因为像这样处理的项目很少成功）？首先要创建可重用的代码。考虑一下你经常重复的流程是否值得编写可重用的DLL。你知道你可以创建Visual
    Studio模板吗？如果你有一个标准的项目结构，可以从中创建一个模板，并在每个新项目中重用它，从而加快交付速度并减少错误。
- en: A few considerations for project templates are database layers, security layers,
    common validation code (does this data table contain any data?), common extension
    methods, and so on.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 项目模板的一些考虑因素是数据库层、安全层、常见验证代码（此数据表是否包含任何数据？）、常见扩展方法等等。
- en: Encrypting and storing passwords correctly
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确加密和存储密码
- en: One thing I have often seen is badly stored passwords. Just because the password
    is stored in a database on your server, does not make it secure. So, what do badly
    stored passwords look like?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常看到的一件事是密码存储不当。仅仅因为密码存储在服务器上的数据库中，并不意味着它是安全的。那么，密码存储不当是什么样子呢？
- en: '![](img/B06434_15_01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_15_01.png)'
- en: Secure passwords stored badly are no longer secure. The passwords in the previous
    screenshot are the actual user passwords. Entering the first password, `^tj_Y4$g1!8LkD`
    at the login screen will give the user access to the system. Passwords should
    be stored securely in the database. In fact, you need to employ salted password
    hashing. You should be able to encrypt the user's password, but never decrypt
    it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 存储不当的安全密码不再安全。上一张截图中的密码是实际用户密码。在登录屏幕上输入第一个密码`^tj_Y4$g1!8LkD`将使用户访问系统。密码应该安全地存储在数据库中。实际上，您需要使用盐加密密码。您应该能够加密用户的密码，但永远不要解密它。
- en: So, how do you decrypt the password to match it to the password the user enters
    on the login screen? Well, you don't. You always hash the password the user enters
    at the login screen. If it matches the hash of their real password stored in the
    database, you give them access to the system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你如何解密密码以匹配用户在登录屏幕上输入的密码？嗯，你不会。你总是对用户在登录屏幕上输入的密码进行哈希处理。如果它与存储在数据库中的他们真实密码的哈希匹配，你就允许他们访问系统。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: The SQL tables in this recipe are for illustration only and are not writtento
    by the code in the recipe. The database can be found in the `_database scripts`
    folder that accompanies the source code for this book.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中的SQL表仅用于说明，不是由食谱中的代码编写的。可以在伴随本书源代码的“_数据库脚本”文件夹中找到数据库。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: The easiest way is to create a console application and then add a new class
    library by right-clicking on your solution, and selecting Add and then New Project
    from the context menu.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最简单的方法是创建一个控制台应用程序，然后通过右键单击解决方案，选择“添加”，然后从上下文菜单中选择“新建项目”来添加一个新的类库。
- en: From the Add New Project dialog screen, select Class Library from the installed
    templates and call your class `Chapter15`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“添加新项目”对话框屏幕中，从已安装的模板中选择“类库”，并将您的类命名为`Chapter15`。
- en: Your new class library will be added to your solution with a default name of
    `Class1.cs`, which we renamed `Recipes.cs` in order to distinguish the code properly.
    You can, however, rename your class whatever you like if that makes more sense
    to you.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的新类库将添加到解决方案中，并具有默认名称`Class1.cs`，我们将其重命名为`Recipes.cs`以正确区分代码。但是，如果您觉得更合理，可以将类重命名为任何您喜欢的名称。
- en: To rename your class, simply click on the class name in the Solution Explorer
    and select Rename from the context menu.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要重命名您的类，只需在“解决方案资源管理器”中单击类名，然后从上下文菜单中选择“重命名”。
- en: Visual Studio will ask you to confirm a rename of all references to the code
    element Class1 in the project. Just click on Yes.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio将要求您确认对项目中代码元素Class1的所有引用的重命名。只需单击“是”。
- en: 'The following class is added to your `Chapter15` library project:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下类将添加到您的`Chapter15`库项目中：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following `using` statement to your class:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的类中添加以下`using`语句：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, you need to add two properties to the class. These properties will store
    the salt and the hash. Usually you will write these values to the database along
    with the username, but, for the purposes of this recipe, we will simply add them
    to the static properties. Also add two methods to the class called `RegisterUser()`
    and `ValidateLogin()`. Both methods take as parameters the `username` and `password`
    variables:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要向类中添加两个属性。这些属性将存储盐和哈希值。通常，您将这些值与用户名一起写入数据库，但是，为了本示例的目的，我们将它们简单地添加到静态属性中。还要向类中添加两个方法，分别称为`RegisterUser()`和`ValidateLogin()`。这两个方法都以`username`和`password`变量作为参数：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Starting with the `RegisterUser()` method, here we do a number of things. To
    list the steps in the method:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`RegisterUser()`方法开始，我们做了一些事情。列出方法中的步骤：
- en: 1\. We generate a truly random, cryptographically strong salt value using `RNGCryptoServiceProvider`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 我们使用`RNGCryptoServiceProvider`生成一个真正随机的、密码学强的盐值。
- en: 2\. Add the salt to the password and hash the salted password using `SHA256`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 将盐添加到密码中，并使用`SHA256`对加盐的密码进行哈希。
- en: It doesn't matter if you add the salt before or after the password. Just remember
    to be consistent each time you do it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码之前或之后添加盐都无所谓。只需记住每次都要保持一致。
- en: 3\. Store the salt value and the hash value along with the username in the database.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 将盐值和哈希值与用户名一起存储在数据库中。
- en: In order to cut down on code, I have not actually added code to write the hash
    and salt values to the database. I simply added them to the properties created
    earlier. In a real-world situation, you would always write these to the database.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少代码量，我实际上没有添加代码将哈希和盐值写入数据库。我只是将它们添加到之前创建的属性中。在实际情况下，您应该始终将这些值写入数据库。
- en: 'This is a very secure way to handle user passwords in your application:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在应用程序中处理用户密码的一种非常安全的方式：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next method we need to create is the `ValidateLogin()` method. Here, we
    take the username and validate that first. If the user entered the username incorrectly,
    do not tell them so. This would alert someone trying to compromise the system
    that they have the wrong username and that as soon as they get a wrong password
    notification, they know that the username is correct. The steps in this method
    are as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建的下一个方法是`ValidateLogin()`方法。在这里，我们首先获取用户名并验证。如果用户输入的用户名不正确，请不要告诉他们。这会提醒试图破坏系统的人，他们输入了错误的用户名，并且一旦他们收到错误的密码通知，他们就知道用户名是正确的。此方法中的步骤如下：
- en: Get the salt and hash values for the entered username from the database.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库中获取输入的用户名的盐和哈希值。
- en: Salt the password the user entered at the login screen with the salt read from
    the database.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用从数据库中读取的盐对用户在登录屏幕上输入的密码进行加盐。
- en: Hash the salted password using the same hashing algorithm when the user registered.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用用户注册时相同的哈希算法对加盐的密码进行哈希。
- en: Compare the hash value read from the database to the hash value generated in
    the method. If the two hashes match, then the password is correctly entered and
    the user validated.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将从数据库中读取的哈希值与方法中生成的哈希值进行比较。如果两个哈希值匹配，则密码被正确输入并且用户被验证。
- en: Note that we never decrypt the password from the database. If you have code
    decrypting user passwords and matching the password entered, you need to reconsider
    and rewrite your password logic. A system should never be able to decrypt user
    passwords.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们从未从数据库中解密密码。如果您的代码解密用户密码并匹配输入的密码，您需要重新考虑并重写密码逻辑。系统永远不应该能够解密用户密码。
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To test the code, add a reference to the `Chapter15` class in your `CodeSamples`
    project.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试代码，请在`CodeSamples`项目中添加对`Chapter15`类的引用。
- en: 'Because we created a static class, you can add the new `using static` to your
    `Program.cs` file:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们创建了一个静态类，您可以将新的`using static`添加到您的`Program.cs`文件中：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Test the code by calling the `RegisterUser()` method and pass it the `username`
    and `password` variable. After that, call the `ValidateLogin()` method and see
    whether the password matches the hash. This would obviously not happen at the
    same time in a real production system:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`RegisterUser()`方法并传递`username`和`password`变量来测试代码。之后，调用`ValidateLogin()`方法并查看密码是否与哈希值匹配。这在真实的生产系统中显然不会同时发生：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you debug the code, you will see the user has been validated:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您调试代码时，您将看到用户已被验证：
- en: '![](img/image_15_007.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_007.png)'
- en: 'Lastly, modify the code slightly and set the `password` variable to something
    else. This will mimic a user entering an incorrect password:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，稍微修改代码，并将`password`变量设置为其他内容。这将模仿用户输入错误的密码：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When you debug the application, you will see that the user is not validated:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您调试应用程序时，您会发现用户未经过验证：
- en: '![](img/image_15_008.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_008.png)'
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Nowhere in the code did we decrypt the password. In fact, the password is never
    stored anywhere. We always worked with the hash of the password. Here are the
    important points to take away from this recipe:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中我们从未解密密码。事实上，密码从未存储在任何地方。我们总是使用密码的哈希值。以下是从这个示例中得出的重要要点：
- en: Never use the `Random` class in C# to generate your salt. Always use the `RNGCryptoServiceProvider`
    class.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要使用`Random`类来生成您的盐。始终使用`RNGCryptoServiceProvider`类。
- en: Never reuse the same salt in your code. So don't create a constant with your
    salt and use it to salt all the passwords in your system.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要在代码中重复使用相同的盐。因此，不要创建一个包含您的盐的常量，并将其用于为系统中的所有密码加盐。
- en: Never tell the user that the password is incorrect if the password didn't match.
    Also, never tell the user that they entered an incorrect username. This prevents
    someone trying to compromise the system after discovering that they got one of
    the two login credentials correct. Rather, if either the username or password
    has been entered incorrectly, notify the user that their login credentials are
    incorrect. This could mean that either the username or password (or both) has
    been entered incorrectly.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果密码不匹配，永远不要告诉用户密码不正确。同样，永远不要告诉用户他们输入了错误的用户名。这可以防止发现其中一个登录凭据正确后，有人试图破坏系统。相反，如果用户名或密码输入不正确，请通知用户他们的登录凭据不正确。这可能意味着用户名或密码（或两者）输入不正确。
- en: You can't get the passwords from the hash or salt stored in the database. Therefore,
    if the database was compromised, the password data stored within it would not
    be at risk. The encryption of the user's password is a one-way operation, meaning
    that it can never be decrypted. Also important to note is that, even if the source
    code was compromised and stolen by someone with malicious intent, you would not
    be able to use the code to decipher the encrypted data in the database.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您无法从数据库中存储的哈希或盐中获取密码。因此，如果数据库遭到破坏，其中存储的密码数据不会受到威胁。用户密码的加密是一个单向操作，意味着它永远无法被解密。同样重要的是，即使源代码被人恶意窃取，您也无法使用该代码来解密数据库中的加密数据。
- en: Combine the previous methods with a strong password policy (because even in
    2016, there are still users that think using `'l3tm31n'` for a password is good
    enough), and you have a very good password encryption routine.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将上述方法与强密码策略结合起来（因为即使在2016年，仍然有用户认为使用`'l3tm31n'`作为密码就足够了），您将得到一个非常好的密码加密例程。
- en: 'When we look at the user access table, the correct way to store user credentials
    would look something like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看用户访问表时，存储用户凭据的正确方式应该是这样的：
- en: '![](img/image_15_009.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_009.png)'
- en: The salt and hash are stored alongside the username, and are secure because
    they can't be decrypted to expose the actual password.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 盐和哈希存储在用户名旁边，并且是安全的，因为它们无法被解密以暴露实际密码。
- en: If you sign up for a service on the Internet and they send you a confirmation
    either via e-mail or text message and display your password in this message in
    plain text, then you should seriously consider closing your account. If a system
    can read your password and send it to you in plain text, so can anybody else.
    Never use the same password for all your logins.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在互联网上注册服务，并且他们通过电子邮件或短信向您发送确认并以纯文本显示您的密码，那么您应该认真考虑关闭您的帐户。如果系统可以读取您的密码并以纯文本形式发送给您，其他人也可以。永远不要在所有登录中使用相同的密码。
- en: Using SecureString in code
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在代码中使用SecureString
- en: 'Securing your application against malicious attacks is not an easy task. It
    is the constant struggle between writing secure code while minimizing bugs (which
    hackers usually exploit) and black hats writing more and more sophisticated methods
    to compromise systems and networks. I personally believe that higher learning
    institutions need to teach IT students two things:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 保护应用程序免受恶意攻击并不是一件容易的事。这是在编写安全代码和最小化错误（黑客通常利用的）之间不断斗争，以及黑客编写越来越复杂的方法来破坏系统和网络。我个人认为高等学府需要教授IT学生两件事：
- en: How to use and integrate with a popular ERP system
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用和集成流行的ERP系统
- en: Proper software security principles
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当的软件安全原则
- en: In fact, I believe that secure programming 101 must not simply be a module or
    topic in a given IT course, but a whole course on its own. It needs to be handled
    with the seriousness and respect it deserves and needs to preferably be taught
    by someone who can actually hack a system or network.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我认为安全编程101不应该只是给定IT课程中的一个模块或主题，而应该是一个完整的课程。它需要以应有的严肃和尊重对待，并且最好由一个真正可以黑客系统或网络的人来教授。
- en: White hats teaching students how to compromise systems, exploit vulnerable code,
    and infiltrate networks will make a big difference in changing the way future
    software developers approach programming. It comes down to developers knowing
    what not to do when programming defensively. It is quite possible that some of
    those students might go on to become black hats themselves, but they would have
    done that irrespective of whether they took a class on hacking secure programming
    or not.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 白帽黑客教授学生如何破坏系统，利用易受攻击的代码，并渗透网络，将对未来软件开发人员的编程方式产生重大影响。开发人员需要知道在进行防御性编程时不应该做什么。有可能其中一些学生最终会成为黑帽黑客，但无论他们是否参加了关于黑客安全编程的课程，他们都会这样做。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The code might look a little funny in some places. This is because `SecureString`
    is using unmanaged memory to store the sensitive information. Rest assured that
    `SecureString` is well supported and used within the .NET Framework, as can be
    seen from the instantiation of the `SqlCredential` object used in creating connections
    to a database:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能在某些地方看起来有点奇怪。这是因为`SecureString`正在使用非托管内存存储敏感信息。请放心，`SecureString`在.NET Framework中得到了很好的支持和使用，可以从创建连接到数据库时使用的`SqlCredential`对象的实例化中看出：
- en: '![](img/image_15_010.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_010.png)'
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Start by adding a new Windows forms project to your solution.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，向解决方案添加一个新的Windows表单项目。
- en: Call the project `winformSecure` and click on the OK button.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为`winformSecure`并点击“确定”按钮。
- en: In the Toolbox, search for the TextBox control and add it to your form.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具箱中，搜索文本框控件并将其添加到您的表单中。
- en: 'Lastly, add a button control to your form. You can resize this form, however
    you like to look more like a login form:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，向您的表单添加一个按钮控件。您可以调整此表单的大小，使其看起来更像登录表单：
- en: '![](img/image_15_014.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_014.png)'
- en: 'With the textbox control selected on the Windows forms, open up the Properties
    panel and click on the Events button (it looks like a lightning bolt). In the
    Key group, double-click on the KeyPress event to create the handler in the code
    behind:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Windows表单上的文本框控件，在属性面板中打开并点击事件按钮（看起来像闪电）。在键组中，双击KeyPress事件以在代码后台创建处理程序：
- en: '![](img/image_15_015.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_015.png)'
- en: 'The code that is created for you is the KeyPress event handler for the textbox
    control. This will fire whenever a user presses a key on the keyboard:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为您创建的代码是文本框控件的KeyPress事件处理程序。每当用户在键盘上按键时，这将触发。
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Back in the Properties panel, expand the Behavior group and change the value
    of UseSystemPasswordChar to `True`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到属性面板，展开行为组，并将UseSystemPasswordChar的值更改为`True`：
- en: '![](img/image_15_016.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_016.png)'
- en: 'In the code behind, add the following`using` statement:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码后台，添加以下`using`语句：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the `SecureString` variable as a global variable to your Windows forms:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SecureString`变量作为全局变量添加到您的Windows表单中：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, in the `KeyPress` event, append the `KeyChar` value to the `SecureString`
    variable every time the user presses a key. You might want to add code to ignore
    certain key presses, but this is beyond the scope of this recipe:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`KeyPress`事件中，每次用户按键时将`KeyChar`值附加到`SecureString`变量中。您可能希望添加代码来忽略某些按键，但这超出了本教程的范围：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, in the Login button''s event handler, add the following code to read
    the value from the `SecureString` object. Here, we are working with unmanaged
    memory and unmanaged code:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在登录按钮的事件处理程序中，添加以下代码以从`SecureString`对象中读取值。在这里，我们正在处理非托管内存和非托管代码：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run your Windows forms application and type in a password:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的Windows表单应用程序并输入密码：
- en: '![](img/image_15_017.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_017.png)'
- en: 'Then click on the Login button. You will then see the password you typed in
    displayed in the message box:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击登录按钮。然后您将看到您输入的密码显示在消息框中：
- en: '![](img/image_15_018.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_018.png)'
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It has become almost a habit for many developers to use `System.String` to store
    sensitive information such as passwords. The problem with this approach is that
    `System.String` is immutable. This means that the object created in memory by
    `System.String` can't be changed. If you modify the variable, a new object is
    created in memory. You also cannot determine when the object created by `System.String`
    will be removed from memory during garbage collection. Conversely, using the `SecureString`
    object, you will encrypt sensitive information and, when that object is no longer
    needed, it is deleted from memory. `SecureString` encrypts and decrypts your sensitive
    data in unmanaged memory.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对许多开发人员来说，使用`System.String`存储密码等敏感信息几乎成了一种习惯。这种方法的问题在于`System.String`是不可变的。这意味着`System.String`在内存中创建的对象无法更改。如果修改变量，内存中将创建一个新对象。您也无法确定`System.String`创建的对象在垃圾回收期间何时从内存中删除。相反，使用`SecureString`对象，您将加密敏感信息，并在不再需要该对象时将其从内存中删除。`SecureString`在非托管内存中加密和解密您的敏感数据。
- en: Now, I need to be clear regarding one thing here. `SecureString` is by no means
    foolproof. If your system contains a virus with the sole purpose of compromising
    the `SecureString` operations, using it doesn't help much (be sure to use proper
    anti-virus software anyway). At some point during the code execution, the string
    representation of your password (or sensitive information) is visible. Secondly,
    if a hacker somehow found a way to inspect your heap or log your key strokes,
    the password might be visible. The use of `SecureString`, however, makes this
    window of opportunity for a hacker much smaller. The window of opportunity reduces
    because there are less attack vectors (points of entry for a hacker) thereby reducing
    your attack surface (sum of all points of attack by a hacker).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我需要明确一件事。`SecureString`绝不是绝对安全的。如果您的系统中存在一个旨在破坏`SecureString`操作的病毒，使用它并没有太大帮助（无论如何，请务必使用适当的防病毒软件）。在代码执行过程中，您的密码（或敏感信息）的字符串表示可能是可见的。其次，如果黑客以某种方式找到了检查您的堆或记录您的按键的方法，密码可能是可见的。然而，使用`SecureString`可以使黑客的这个窗口机会变得更小。机会窗口变小是因为攻击向量（黑客的入口点）减少了，从而减少了攻击面（黑客的所有攻击点的总和）。
- en: 'The bottom line is this: `SecureString` is there for a reason. As a software
    developer concerned about security, you should be using `SecureString`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 底线是：`SecureString`是有其存在的理由的。作为一个关心安全的软件开发人员，您应该使用`SecureString`。
- en: Securing sensitive parts of the App.config/web.config
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护App.config/web.config的敏感部分
- en: As a developer, you will undoubtedly work with sensitive information such as
    passwords. How you handle this information during development is very important.
    In the past, I have received copies of a client's live database to use for testing.
    This does pose a very real security risk for your client.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，你无疑会处理诸如密码之类的敏感信息。在开发过程中如何处理这些信息非常重要。在过去，我曾收到客户的实时数据库副本用于测试。这确实对你的客户构成了非常真实的安全风险。
- en: Often, we keep settings in a `web.config` file (when working with web applications).
    For this example, though, I will be demonstrating a console application that uses
    an `App.config` file. The same logic can be applied to a `web.config` file too.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会将设置保存在`web.config`文件中（在使用Web应用程序时）。但是，在这个例子中，我将演示一个使用`App.config`文件的控制台应用程序。相同的逻辑也可以应用于`web.config`文件。
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Creating a console application is the quickest way to demonstrate this recipe.
    If, however, you want to follow along using a web application (and securing a
    `web.config` file), you can do so.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 创建控制台应用程序是演示这个方法的最快方式。然而，如果你想使用Web应用程序（并保护`web.config`文件）进行跟随，你也可以这样做。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In the console application, locate the `App.config` file. This is the file that
    contains the sensitive data.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，找到`App.config`文件。这个文件包含了敏感数据。
- en: If you open the `App.config` file, you will see that, within the `appSettings`
    tag, there is a key added called `Secret`. This information should probably not
    be in the `App.config` to start off with. The problem here is that it might be
    checked into your source control. Imagine that on GitHub?
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你打开`App.config`文件，你会看到，在`appSettings`标签中，添加了一个名为`Secret`的键。这些信息可能本来就不应该在`App.config`中。问题在于它可能被提交到你的源代码控制中。想象一下在GitHub上？
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To overcome this vulnerability, we need to move the sensitive data out of the
    `App.config` file into another file. To do this, we specify a path to a file that
    will contain the sensitive data we want to remove from the `App.config` file.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了克服这个漏洞，我们需要将敏感数据从`App.config`文件中移出到另一个文件中。为此，我们指定一个包含我们想要从`App.config`文件中移除的敏感数据的文件路径。
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You might be wondering why not simply just encrypt the information. Well, that
    is a given really. The reason this value is in plain text is just to demonstrate
    a concept here. You would probably encrypt this value anyway in a real-world situation.
    You would not, however, want this sensitive information sitting on a server in
    a code repository somewhere, even if it is encrypted. Be safe, move it out of
    your solution.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么不简单地加密这些信息。嗯，这是肯定的。这个值以明文形式存在的原因只是为了演示一个概念。在现实世界的情况下，你可能会加密这个值。然而，你不希望这些敏感信息以任何形式存在于服务器的代码库中，即使它被加密了。要保险起见，将其移出你的解决方案。
- en: 'When you have added the path to the secure file, remove the key containing
    the sensitive information:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你添加了安全文件的路径后，删除包含敏感信息的键：
- en: '![](img/image_15_020.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_020.png)'
- en: 'Navigate to the path you specified in the `App.config` file property. Create
    your`secret.config` file and open it up for editing:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你在`App.config`文件属性中指定的路径。创建你的`secret.config`文件并打开它进行编辑：
- en: '![](img/image_15_021.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_021.png)'
- en: 'Inside this file, repeat the `appSettings` section and add the `Secret` key
    to it. What happens now is that, when your console application runs, it reads
    the `appSettings` section in your solution and finds the reference to the secret
    file. It then looks for the secret file and merges it with the `App.config` in
    your solution:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件中，重复`appSettings`部分并添加`Secret`键。现在发生的是，当你的控制台应用程序运行时，它会读取你解决方案中的`appSettings`部分，并找到对秘密文件的引用。然后它会寻找秘密文件，并将其与你解决方案中的`App.config`合并：
- en: '![](img/image_15_022.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_022.png)'
- en: To see that this merge works, add a reference to your console application.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了看到这个合并是如何工作的，添加一个引用到你的控制台应用程序。
- en: 'Search for and add `System.Configuration` to your references:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索并添加`System.Configuration`到你的引用中：
- en: '![](img/image_15_024.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_024.png)'
- en: When you have added the reference, your solution references will list System.Configuration.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你添加了引用后，你的解决方案引用将列出System.Configuration。
- en: 'To the top of your `Program.cs` file, add the following `using` statement:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Program.cs`文件顶部，添加以下`using`语句：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following code to read the `Secret` key setting from your `App.config`
    file. Only this time, it will read the merged file, which is made up of your `App.config`
    and your `secret.config` file:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码来从你的`App.config`文件中读取`Secret`键设置。只是这一次，它将读取合并后的文件，由你的`App.config`和`secret.config`文件组成：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run your console application, and you will see that the sensitive data has
    been read from the `secret.config` file, which was merged with the `App.config`
    file at runtime:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的控制台应用程序，你会看到敏感数据已经从`secret.config`文件中读取，并在运行时与`App.config`文件合并：
- en: '![](img/image_15_026.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_026.png)'
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Something I need to point out here is that this technique will also work for
    `web.config` files. If you need to remove sensitive information from your configuration
    file, move it to another file so that it doesn't get included in your source control
    check-in or deployment.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要在这里指出的是，这种技术也适用于`web.config`文件。如果你需要从配置文件中删除敏感信息，将其移动到另一个文件中，这样就不会被包含在你的源代码控制检入或部署中。
- en: Preventing SQL injection attacks
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止SQL注入攻击
- en: SQL injection attacks are a very real problem. There are too many applications
    that still make themselves vulnerable to this kind of attack. If you develop a
    web application or website, you should be vigilant about bad database operations.
    Vulnerable in-line SQL exposes the database to a SQL injection attack. A SQL injection
    attack is where an attacker modifies SQL statements via a web form input box to
    produce a different result than originally intended. This is usually attempted
    on a form where the web application is supposed to access the database to authenticate
    the user login. By not sanitizing the user input, you are exposing your data to
    exploits such as this.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入攻击是一个非常真实的问题。有太多的应用程序仍然使自己容易受到这种攻击。如果你开发Web应用程序或网站，你应该对不良的数据库操作保持警惕。易受攻击的内联SQL会使数据库容易受到SQL注入攻击。SQL注入攻击是指攻击者通过Web表单输入框修改SQL语句，以产生与最初意图不同的结果。这通常是在Web应用程序应该访问数据库以验证用户登录的表单上尝试的。通过不对用户输入进行消毒，你会使你的数据容易受到这种攻击的利用。
- en: The accepted solution to mitigate SQL injection attacks is to create a parameterized
    stored procedure, and call that from your code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 减轻SQL注入攻击的可接受解决方案是创建一个带参数的存储过程，并从代码中调用它。
- en: Getting ready
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to create the `CookbookDB` database in your SQL Server before continuing
    this recipe. You will find the script in the `_database scripts` folder in the
    accompanying source code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本示例之前，你需要在你的SQL Server中创建`CookbookDB`数据库。你可以在附带源代码的`_database scripts`文件夹中找到脚本。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For this recipe, I am using SQL Server 2012\. The concept is the same if you
    are using an older version of SQL Server. After you have created the `CookbookDB`
    database, you will see that there is a table called `UserDisplayData` under the
    `Tables` folder:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个示例中，我使用的是SQL Server 2012。如果你使用的是较旧版本的SQL Server，概念是一样的。在创建了`CookbookDB`数据库之后，你会看到`Tables`文件夹下有一个名为`UserDisplayData`的表：
- en: '![](img/image_15_027.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_027.png)'
- en: 'The `UserDisplayData` table is simply used to illustrate the concept of querying
    using a parameterized stored procedure. It would not have any real benefit in
    a production database, because it only returns a screen name:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UserDisplayData`表只是用来说明使用带参数的存储过程进行查询的概念。在生产数据库中，它不会有任何真正的好处，因为它只返回一个屏幕名称：'
- en: '![](img/image_15_028.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_028.png)'
- en: 'We need to create a stored procedure to select data from this table for a specific
    ID (user ID). Click on the `Programmability` node to expand it:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个存储过程来选择这个表中特定ID（用户ID）的数据。点击`Programmability`节点以展开它：
- en: '![](img/image_15_029.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_029.png)'
- en: 'Next, right-click on the `Stored Procedures` node and selectNew Stored Procedure...
    from the context menu:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，右键单击`Stored Procedures`节点，从上下文菜单中选择`New Stored Procedure...`：
- en: '![](img/image_15_030.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_030.png)'
- en: 'SQL Server will create the following stored procedure template for you. This
    template consists of a section where you can comment on the particular stored
    procedure, as well as a section to add parameters you might need, and obviously
    a section that you need to add the actual SQL statement to:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SQL Server会为你创建以下存储过程模板。这个模板包括一个你可以对特定存储过程进行注释的部分，以及一个你可能需要添加参数的部分，显然还有一个你需要添加实际SQL语句的部分：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Give the stored procedure a suitable name that will describe the action or
    intent of the stored procedure:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给存储过程取一个合适的名字，描述存储过程的动作或意图：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are many people that do prefix their stored procedures, and I'm one of
    those. I like to keep my stored procedures grouped. I, therefore, name my stored
    procedures in the format *[prefix]_[tablename_or_module]_[stored_procedure_action]*.
    Having said that, I generally avoid using `sp_` as a prefix to my stored procedures.
    There are a lot of opinions on the Internet as to why this is a bad idea. It is
    generally believed that using `sp_` as a stored procedure prefix impacts on performance
    because it is used as the stored procedure prefix in the master database. For
    the purposes of this recipe, I have just kept to a simple name for the stored
    procedure.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多人在他们的存储过程中加入前缀，我就是其中之一。我喜欢把我的存储过程分组。因此，我以*[prefix]_[tablename_or_module]_[stored_procedure_action]*的格式命名我的存储过程。话虽如此，我通常避免使用`sp_`作为存储过程的前缀。关于为什么这样做是一个坏主意，互联网上有很多不同的观点。一般认为，在性能方面，使用`sp_`作为存储过程前缀会有影响，因为它被用作主数据库中的存储过程前缀。对于这个示例，我只是简单地给存储过程取了一个简单的名字。
- en: 'Define a parameter for this stored procedure. By doing this, you are telling
    the database that when this stored procedure is called, it will pass through a
    value of type integer that is stored in a parameter caller `@userID`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个存储过程定义一个参数。通过这样做，你告诉数据库，当调用这个存储过程时，它将传递一个整数类型的值，存储在一个名为`@userID`的参数中：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You now define the SQL statement to be used by this stored procedure. We are
    just going to do a straightforward `SELECT` statement:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在定义要由该存储过程使用的SQL语句。我们将只执行一个简单的`SELECT`语句：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You will notice that my `SELECT` statement contains the specific column names
    instead of a `SELECT * FROM`. Doing a `SELECT *` is considered bad practice. You
    would usually not want to return all the column values from a table. If you want
    all the column values, then it is better to explicitly list the columns by name
    instead of just getting all. Using `SELECT *` returns unnecessary columns and
    increases the overhead on the server. This does make a difference in the bigger
    scheme of things, especially when the database starts getting a lot of traffic.
    The thought of having to type out the column names for a large table is definitely
    not something I would look forward to. You can, however, use the following tricks
    to make it easy for you to add the column names to your SQL `SELECT` statement.
    You can right-click on the database table and select Script Table As to create
    one of several SQL statements. Secondly, you can expand the `Table` node and expand
    the table you wish to write the statement for. You will then see a node called
    `Columns`. Drag the `Columns` node onto the query editor. That will insert all
    the column names into the query editor for you.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我的`SELECT`语句包含特定的列名，而不是`SELECT * FROM`。使用`SELECT *`被认为是不良实践。通常情况下，您不希望从表中返回所有列值。如果您需要所有列值，最好明确列出列名，而不是获取所有列。使用`SELECT
    *`会返回不必要的列，并增加服务器的开销。这在更大的事情中确实会有所不同，特别是当数据库开始有很多流量时。不得不为大表的列名输入而感到期待是绝对不会发生的事情。但是，您可以使用以下技巧来使您轻松地将列名添加到您的SQL
    `SELECT`语句中。您可以右键单击数据库表，然后选择`Script Table As`来创建多个SQL语句之一。其次，您可以展开`Table`节点并展开要为其编写语句的表。然后，您将看到一个名为`Columns`的节点。将`Columns`节点拖放到查询编辑器中。这将为您在查询编辑器中插入所有列名。
- en: 'When you have completed adding the code to your stored procedure, it will look
    like this:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您完成向存储过程添加代码后，它将如下所示：
- en: '![](img/image_15_031.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_031.png)'
- en: 'To create the stored procedure, you need to click on the Execute button. Be
    certain that you have the correct database selected when clicking on the Execute
    button:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建存储过程，您需要单击“执行”按钮。确保在单击“执行”按钮时选择了正确的数据库：
- en: '![](img/B06434_15_18.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_15_18.jpg)'
- en: 'The stored procedure will then be created under the `Stored Procedures` node
    in SQL Server:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后存储过程将在SQL Server的`Stored Procedures`节点下创建：
- en: '![](img/image_15_033.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_033.png)'
- en: We have now come halfway through this task. It is time to construct the code
    that we will use in our application to query the database. We will be adding this
    code directly to the `Program.cs` file of your console application. While this
    code isn't considered best practice (hardcoding the server credentials), it serves
    merely to illustrate the concept of calling a parameterized stored procedure from
    C#.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经完成了这项任务的一半。是时候构建我们将在应用程序中使用来查询数据库的代码了。我们将直接将此代码添加到控制台应用程序的`Program.cs`文件中。虽然这段代码不被认为是最佳实践（硬编码服务器凭据），但它仅仅用来说明从C#调用参数化存储过程的概念。
- en: 'To start, add the following `using` statement to the top of your console application:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在您的控制台应用程序顶部添加以下`using`语句：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We then add the variables to contain the credentials we need to log on to the
    server:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加变量以包含我们登录服务器所需的凭据：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We now use `SecureString` to store the password and add it to a `SqlCredential`
    object:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在使用`SecureString`来存储密码，并将其添加到`SqlCredential`对象中：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For more on `SecureString`, see the *Using SecureString in code* recipe of this
    chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`SecureString`的更多信息，请参阅本章的*在代码中使用SecureString*配方。
- en: 'We now create a `SqlConnection` object inside a `using` statement. This ensures
    that the SQL connection is closed when the `using` statement moves out of scope:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在在`using`语句中创建一个`SqlConnection`对象。这确保了当`using`语句移出范围时，SQL连接将被关闭：
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Inside the `try`, add the following code to open the connection string and
    create a `SqlCommand` object that takes the open connection and name of the stored
    procedure as parameters. You can use the shortcut method of creating the actual
    SQL parameter to pass to the stored procedure:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`try`内，添加以下代码以打开连接字符串并创建一个`SqlCommand`对象，该对象将打开的连接和存储过程的名称作为参数。您可以使用创建实际SQL参数的快捷方法来传递给存储过程：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Because I''m just passing a parameter of type integer to the stored procedure,
    I''m not defining a length for this parameter:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我只是向存储过程传递了一个整数类型的参数，所以我没有为这个参数定义长度：
- en: '![](img/image_15_034.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_034.png)'
- en: 'If, however, you ever need to define a parameter of type `VarChar(MAX)`, you
    would need to define the size of the parameter type by adding `-1`. Let''s say,
    for example, you need to store a student''s essay in the database; the code would
    then look as follows for the `VarChar(MAX)`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您需要定义`VarChar(MAX)`类型的参数，您需要通过添加`-1`来定义参数类型的大小。例如，假设您需要在数据库中存储学生的文章；则代码将如下所示：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After we have added our parameter with its value to the `SqlCommand` object,
    we specify a timeout value, execute the `SqlDataReader`, and load it into a `DataTable`.
    The value is then output to the console application:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将参数及其值添加到`SqlCommand`对象后，我们指定超时值，执行`SqlDataReader`并将其加载到`DataTable`中。然后将该值输出到控制台应用程序：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After you have added all the code to your console application, the correct
    completed code will look as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将所有代码添加到控制台应用程序后，正确的完成代码将如下所示：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run your console application and you will see the display name output to the
    screen:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的控制台应用程序，您将看到显示名称输出到屏幕上：
- en: '![](img/image_15_035.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_035.png)'
- en: How it works...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By creating a parameterized SQL query, the compiler correctly substitutes the
    arguments before running the SQL statement against the database. It will prevent
    malicious data changing your SQL statement in order to exact a malicious result.
    This is because the `SqlCommand` object does not directly insert the parameter
    values into the statement.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: To sum it all up, using parameterized stored procedures means no more Little
    Bobby Tables.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Using IntelliTrace, diagnostic tools, and historical debugging
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The trusty old bug has been the bane of software developers and engineers for
    more than 140 years. Yes, you read that right. It was in fact Thomas Edison that
    coined the term "bug" in the late 1870s. It appeared in many of his notebook entries
    where he describes for example that the incandescent lightbulb still had many
    "bugs left".
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: His efforts to debug his inventions are quite legendary. Consider the true grit
    and determination it took for a man already in his mid-sixties to work 112-hour
    working weeks. He and his seven-person team (it is a common misconception that
    there were only six because the seventh member didn't appear in the group photograph)
    became known as the insomnia squad during a 5-week stint that resulted in very
    little sleep.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'These days, thanks to the advances of technology, software developers have
    a vast array of debugging tools (inside and outside of Visual Studio) at their
    disposal. So does debugging really matter? Of course it does. It is part of what
    we as software developers do. If we don''t debug, well, here are some examples:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: In 2004, the **Electronic Data Systems** (**EDS**) child support system in the
    UK overpaid almost 2 million people, while underpaying almost a million, and resulted
    in billions of dollars in uncollected child support payments. The incompatibility
    between EDS and another system it relied on resulted in taxpayers losing money
    and negatively affecting the lives of so many single parents.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initial release of Apple Maps in 2012\. Enough said. While bemusing for
    many, I still find myself using Google Maps for turn-by-turn directions when in
    an unfamiliar city or area.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Therac-25 radiation therapy machine used electrons to target tumors in patients.
    Unfortunately, a race condition in the software caused the machine to deliver
    lethal overdoses of radiation in several patients.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of software bugs affecting the lives of millions of people can be found
    all over the Internet. We're not simply talking about the run-of-the-mill bugs
    either. Sometimes, we're faced with seemingly insurmountable issues. It is the
    comfort of knowing how to use some of the tools available that makes the difference
    between a stable application and one that is totally unusable.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that IntelliTrace is only available in the Enterprise edition of Visual
    Studio. See the [https://www.visualstudio.com/vs/compare/](https://www.visualstudio.com/vs/compare/)
    link for comparisons between the versions of Visual Studio. IntelliTrace is not
    a new feature in Visual Studio. It has evolved over time (since Visual Studio
    2010) into what we have available today.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start off, go to Tools, Options.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expand the IntelliTrace node and click on General. Ensure that Enable IntelliTrace
    is checked. Also, make sure that the IntelliTrace events and call information
    option is selected. Click on OK:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_15_037.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: 'In the `Recipes.cs` file, you might need to add the following `using` statements:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add a method called `ErrorInception()` to the `Recipes` class. Also, add the
    code to read the base path and assume that there is a folder called `log`. Do
    not create this folder on your hard drive. We want an exception to be thrown.
    Lastly, add another method called `LogException()` that does nothing:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add the following code to your `ErrorInception()` method after the full path
    has been determined. Here, we are trying to open the log file. This is where the
    exception will occur:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When you have added all your code, your code should look like this:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您添加了所有代码后，您的代码应该看起来像这样：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the `Program.cs` file, call the `ErrorInception()` method. Right after that,
    do a `Console.ReadLine()` so that our console application will pause there. Do
    not add any breakpoints anywhere to your code:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，调用`ErrorInception()`方法。在那之后，进行`Console.ReadLine()`，这样我们的控制台应用程序将在那里暂停。不要在代码的任何地方添加断点：
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Start debugging your application. The exception is thrown and the application
    continues running, a condition often experienced with much more complex applications.
    At this point, you would expect a log file to be appended with the fictitious
    data of the app, but nothing happened. It is, at this point, that you stop your
    application and start adding breakpoints all over your code in a hit and miss-type
    exercise. I say hit and miss because you probably won''t know exactly where the
    error is. This is especially true if your code file contains a few thousand lines
    of code. Well now with IntelliTrace and historical debugging, you just need to
    click on the Break All button:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始调试您的应用程序。异常被抛出，应用程序继续运行，这在更复杂的应用程序中经常发生。在这一点上，您期望日志文件被附加上应用程序的虚构数据，但什么也没有发生。就在这时，您停止应用程序，并开始在代码中随意添加断点。我说随意，因为您可能不知道错误的确切位置。如果您的代码文件包含几千行代码，这一点尤其正确。现在有了IntelliTrace和历史调试，您只需点击“全部中断”按钮：
- en: '![](img/image_15_038.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_038.png)'
- en: Your application is now essentially paused. If you don't see the Diagnostic
    Tools window, hold down *Ctrl* + *Alt* + *F2*.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的应用程序现在基本上暂停了。如果您没有看到诊断工具窗口，请按住*Ctrl* + *Alt* + *F2*。
- en: 'Visual Studio now displays the Diagnostic Tools window. Immediately, you can
    see that there is a problem indicated by the red diamond icon on the Events section.
    In the Events tab at the bottom, you can click on the exception:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio现在显示诊断工具窗口。立即，您可以看到在事件部分的红色菱形图标指示了问题。在底部的事件选项卡中，您可以点击异常：
- en: '![](img/image_15_040.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_040.png)'
- en: 'Doing this expands the exception details where you can see that the log file
    was not found. Visual Studio, however, goes one step further with historical debugging:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样做会扩展异常详细信息，您可以看到日志文件未找到。然而，Visual Studio通过历史调试更进一步：
- en: '![](img/image_15_041.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_041.png)'
- en: 'You will see a link at the bottom of the exception details that says Activate
    Historical Debugging. Click on this link. This allows you to see the actual line
    of code that caused this exception in the code editor. It also allows you to view
    the history of the applications state in the Locals window, call stack, and other
    windows. You can now see the specific line of code that caused the exception in
    your code editor. In the Locals window, you can also see what the path was that
    the application used to look for the log file. This kind of debugging experience
    is immensely powerful and allows developers to go straight to the source of the
    error. This leads to increased productivity and better code:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将在异常详细信息底部看到一个名为“激活历史调试”的链接。点击此链接。这允许您在代码编辑器中看到导致此异常的实际代码行。它还允许您查看本地窗口、调用堆栈和其他窗口中应用程序状态的历史记录。现在您可以在代码编辑器中看到导致异常的具体代码行。在本地窗口中，您还可以看到应用程序用于查找日志文件的路径。这种调试体验非常强大，可以让开发人员直接找到错误的源头。这将提高生产力并改善代码：
- en: '![](img/image_15_042.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_042.png)'
- en: How it works...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: So what is the takeaway here? If you only remember one thing, remember this.
    Once the users of your system lose faith in the abilities and potential of that
    system due to bugs, that confidence is almost impossible to regain. Even if you
    resurrect your system from the ashes, after it was laid low by bugs and other
    issues, to produce a flawless product, your users will not be easily swayed. This
    is because in their mind, the system is buggy.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这里的要点是什么？如果您只记住一件事，请记住这一点。一旦您的系统的用户因为错误而失去了对该系统能力和潜力的信心，那种信心几乎不可能重新获得。即使您从错误和其他问题中复活了您的系统，制作出了一个无瑕疵的产品，您的用户也不会轻易改变主意。这是因为在他们的心目中，系统是有错误的。
- en: I once had to take over a system partially developed by a senior developer who
    was leaving the company. She had an excellent specification and a well presented
    prototype shown to the customer. The only problem was that she left the company
    shortly after the system's phase one was implemented. When the bugs came popping
    up, the client naturally asked for her assistance.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经接手过一部分由一位即将离开公司的资深开发人员开发的系统。她有一个出色的规格说明和一个向客户展示的精美原型。唯一的问题是，她在系统的第一阶段实施后不久就离开了公司。当出现错误时，客户自然会要求她的帮助。
- en: Telling the client that the developer (who had been solely responsible for building
    a relationship with the client) had left the company did not bode well to instill
    a sense of confidence. Having a single developer involved was the first mistake
    of this particular project anyway.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉客户，负责与客户建立关系的开发人员已经离开公司，并不能增强信心。在这个特定项目中，只有一个开发人员参与是第一个错误。
- en: Secondly, phase two was about to be developed by yours truly, who was also the
    only developer assigned to this client. This had to be done while building on
    top of the buggy phase one. So, I was fixing bugs while developing new features
    for the system. Luckily this time round, I had a fantastic project manager called
    Rory Shelton as my wingman. Together, we were dumped in the deep end and Rory
    did a fantastic job managing the client's expectations while being totally transparent
    with the client regarding the challenges we were facing.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，第二阶段即将由我来开发，我也是唯一被分配给这个客户的开发人员。这必须在修复第一阶段的错误的同时完成。所以，我在开发系统的新功能的同时修复错误。幸运的是，这一次我有一个名叫罗里·谢尔顿的出色项目经理作为我的搭档。我们一起被抛入深渊，罗里在管理客户期望方面做得非常出色，同时对客户完全透明地表明我们面临的挑战。
- en: The users were unfortunately already disillusioned with the provided system
    and didn't trust the software. This trust was never fully regained. If we had
    IntelliTrace and historical debugging back in 2007, I definitely would have been
    able to track down the issues in a code base that was unfamiliar to me.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，用户已经对提供的系统感到幻灭，并不信任这个软件。这种信任从未完全恢复。如果我们在2007年就有IntelliTrace和历史调试，我肯定能够追踪到对我来说陌生的代码库中的问题。
- en: Always debug your software. When you find no more bugs, debug it again. Then
    give the system to my mom (love you mom). You, as the developer of that system,
    know which buttons to click on and what data to enter, and in which order things
    need to happen. My mom doesn't and I can assure you that a user unfamiliar with
    a system can break it quicker than you can brew a fresh cup of coffee.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 始终调试你的软件。当你找不到更多的错误时，再次调试。然后把系统交给我妈妈（爱你妈妈）。作为系统的开发者，你知道应该点击哪些按钮，输入哪些数据，以及事情需要以什么顺序发生。我妈妈不知道，我可以向你保证，一个对系统不熟悉的用户比你煮一杯新鲜咖啡还要快地破坏它。
- en: Visual Studio provides developers with a very powerful and feature rich set
    of debugging tools. Use them.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio为开发人员提供了非常强大和功能丰富的调试工具。好好利用它们。
- en: Setting conditional breakpoints
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置条件断点
- en: Conditional breakpoints are another hidden gem when it comes to debugging. This
    allows you to specify one or several conditions. When one of these conditions
    is met, the code will stop at the breakpoint. Using conditional breakpoints is
    really easy.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 条件断点是调试时的另一个隐藏宝石。这允许你指定一个或多个条件。当满足其中一个条件时，代码将在断点处停止。使用条件断点非常简单。
- en: Getting ready
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: There is nothing you specifically need to prepare to use this recipe.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要特别准备任何东西来使用这个方法。
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Add the following code to your `Program.cs` file. We are simply creating a
    list of integers and looping through that list:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Program.cs`文件中添加以下代码。我们只是创建了一个整数列表并循环遍历该列表：
- en: '[PRE34]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, place a breakpoint on the `Console.WriteLine(num)` line of code inside
    the loop:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在循环内的`Console.WriteLine(num)`代码上设置一个断点：
- en: '![](img/image_15_043.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_043.png)'
- en: 'Right-click on the breakpoint and select Conditions... from the context menu:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击断点，然后从上下文菜单中选择条件...：
- en: '![](img/image_15_044.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_044.png)'
- en: 'You will now see that Visual Studio opens a Breakpoint Settings window. Here
    we specify that the breakpoint needs to be hit only when the value of `num` is
    `9`. You can add several conditions and specify different conditions. The condition
    logic is really flexible:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你会看到Visual Studio打开了一个断点设置窗口。在这里，我们指定断点只有在`num`的值为`9`时才会被触发。你可以添加多个条件并指定不同的条件。条件逻辑非常灵活：
- en: '![](img/image_15_045.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_045.png)'
- en: 'Debug your console application. You will see that when the breakpoint is hit,
    the value of `num` is `9`:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试你的控制台应用程序。你会看到当断点被触发时，`num`的值是`9`：
- en: '![](img/image_15_046.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_046.png)'
- en: How it works...
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: The condition is evaluated on every loop. When the condition is true, the breakpoint
    will be hit. In the example illustrated in this recipe, the true benefit of a
    conditional breakpoint is somewhat lost because it is a very small list. Consider
    this though. You are binding a data grid. Items on the grid are given specific
    icons based on the status of the item. Your grid contains hundreds of items, because
    this is a hierarchical grid. You identify the primary ID of the item which is
    bound to the grid. This primary ID is then passed to other code logic to determine
    the status, which determines the icon displayed.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 条件在每次循环中都会被评估。当条件为真时，断点将被触发。在这个示例中，条件断点的真正好处有点失去了，因为这是一个非常小的列表。不过请考虑一下。你正在绑定一个数据网格。网格上的项目根据项目的状态给定特定的图标。你的网格包含数百个项目，因为这是一个分层网格。你确定了绑定到网格的项目的主要ID。然后将此主要ID传递给其他代码逻辑来确定状态，从而确定显示的图标。
- en: To debug and pressing *F10* through hundreds of loops is not productive in any
    event. With conditional breakpoints, you can specify a value for the primary ID,
    and only break when the loop hits that value. You can then go straight to the
    item that is being displayed incorrectly.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 通过数百个循环按下*F10*进行调试并不高效。使用条件断点，你可以指定主要ID的值，并且只有在循环达到该值时才会中断。然后你可以直接找到显示不正确的项目。
- en: Using PerfTips to identify bottlenecks in code
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PerfTips来识别代码中的瓶颈
- en: PerfTips are definitely one of my favorite features of Visual Studio. Explaining
    what they do doesn't do them justice. You have to see them in action.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: PerfTips绝对是我最喜欢的Visual Studio功能之一。解释它们的作用并不能充分展现它们的价值。你必须亲眼看到它们的效果。
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Do not confuse PerfTips with CodeLens. It is a separate option from CodeLens
    in Visual Studio.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将PerfTips与CodeLens混淆。它是Visual Studio中与CodeLens分开的一个选项。
- en: How to do it...
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'PerfTips are enabled by default. But just in case you are not seeing any PerfTips,
    go to Tools | Options, and expand the Debugging node. Under General, to the bottom
    of the settings page, you will see an option called Show elapsed time PerfTip
    while debugging. Ensure that this option is checked:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PerfTips默认是启用的。但是以防你没有看到任何PerfTips，转到工具 | 选项，并展开调试节点。在常规下，到设置页面的底部，你会看到一个名为在调试时显示经过时间PerfTip的选项。确保选中此选项：
- en: '![](img/image_15_047.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_047.png)'
- en: 'We will create a few simple methods that mimic long-running tasks. To do this,
    we will just sleep the thread for a couple of seconds. In the `Recipes.cs` file,
    add the following code:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一些模拟长时间运行任务的简单方法。为此，我们将让线程休眠几秒钟。在`Recipes.cs`文件中添加以下代码：
- en: '[PRE35]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In your console application, call the static method `RunFastTask()` and place
    a breakpoint on this line of code:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的控制台应用程序中，调用静态方法`RunFastTask()`并在这行代码上设置一个断点：
- en: '[PRE36]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Start debugging your console application. Your breakpoint will stop on the
    `RunFastTask()` method. Hit *F10* to step over this method:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始调试你的控制台应用程序。你的断点将停在`RunFastTask()`方法上。按*F10*跳过这个方法：
- en: '![](img/image_15_048.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_048.png)'
- en: 'You will notice that 11 seconds later, the next line will be highlighted and
    the PerfTip will be displayed. The PerfTip displays the time it took for the previous
    line of code to execute. So, the debugger that now sits on the `Thread.Sleep`,
    shows that the `RunFastTask()` method took 11 seconds to complete. The task is
    clearly not very fast:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到11秒后，下一行将被突出显示，并显示PerfTip。PerfTip显示了上一行代码执行所花费的时间。因此，现在位于`Thread.Sleep`上的调试器显示`RunFastTask()`方法花费了11秒才完成。该任务显然并不是很快：
- en: '![](img/image_15_049.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_049.png)'
- en: 'Stepping into the `RunFastTask()` method, you can place further breakpoints
    and step over them one by one to find the method that is causing the longest delay.
    As you can see, PerfTips allow developers to quickly and easily identify bottlenecks
    in code:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`RunFastTask()`方法后，您可以设置更多断点，并逐个跳过它们，以找到导致最长延迟的方法。正如您所看到的，PerfTips可以让开发人员快速轻松地识别代码中的瓶颈。
- en: '![](img/image_15_050.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_15_050.png)'
- en: How it works...
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: There are many tools on the market that do this and much more, allowing developers
    to view all sorts of code metrics. PerfTips, however, allow you to see issues
    on the fly while you are stepping through your code as per your normal debugging
    tasks. It is, in my opinion, an indispensable debugging tool.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有许多工具可以做到这一点，甚至更多，允许开发人员查看各种代码指标。然而，PerfTips可以让您在正常调试任务中逐步查看代码时即时查看问题。在我看来，这是一个必不可少的调试工具。

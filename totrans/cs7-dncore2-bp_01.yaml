- en: eBook Manager and Catalogue App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# 7 is a fantastic release and is available in Visual Studio 2017\. It introduces
    developers to a lot of powerful features, some of which were previously only available
    in other languages. The new features introduced in C# 7 allow developers to write
    less code and be more productive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The features available are:'
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Out` variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deconstruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improvements to literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ref returns and locals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generalized async and return types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expression bodies for accessors, constructors, and finalizers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throw expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will take you through some of these features, while the rest of
    the book will introduce you to some of the other features as we go along. In this
    chapter, we will create an `eBookManager` application. If you are like me, you
    have eBooks scattered all over your hard drives and some external drives as well.
    This application will provide a mechanism to bring all these various locations
    together into a Virtual Storage Space. The application is functional, but can
    be further enhanced to suit your needs. The scope for an application such as this
    is vast. You can download the source code from GitHub ([https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints](https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints))
    and follow it to see some of the new features of C# 7 in action.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using Visual Studio 2017, we will create a simple Windows Forms App template
    project. You can call the application anything you like, but I called mine `eBookManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ade7f9fc-3db8-4ea4-b8c7-0e5fe8dc5ddd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The project will be created and will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6f1b4b1-aa41-4d72-be7d-fb8ae2c5d455.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our Solution needs a Class Library project to contain the classes that drive
    the `eBookManager` application. Add a new Class Library project to your Solution
    and call it `eBookManager.Engine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/074b1507-958b-47fc-8f1a-d6c028346f27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A Class Library project is added to the Solution with the default class name.
    Change this class to `Document`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d19a9066-c506-4932-8ffa-17d1b6bfaedc.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Document` class will represent a single eBook. Thinking of a book, we can
    have multiple properties that would represent a single book, but be representative
    of all books. An example of this would be the author. All books must have an author,
    otherwise it would not exist.
  prefs: []
  type: TYPE_NORMAL
- en: I know some of you might be thinking that machines could generate documents
    too, but the information it generates was probably originally written by a person.
    Take code comments for example. A developer writes the comments in code, and a
    tool generates a document from that. The developer is still the author.
  prefs: []
  type: TYPE_NORMAL
- en: The properties I have added to the class are merely my interpretation of what
    might represent a book. Feel free to add additional code to make this your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Document.cs` file and add the following code to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that I have included a property called `Classification` of type
    `DeweyDecimal`. We have not added this class yet, and will do so next.
  prefs: []
  type: TYPE_NORMAL
- en: 'To the `eBookManager.Engine` project, add a class called `DeweyDecimal`. If
    you don''t want to go to this level of classification for your eBooks, you can
    leave this class out. I have included it for the sake of completeness:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/505f9689-7e75-45a1-ac2e-90f997d423bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Your `DeweyDecimal` class must be in the same project as the `Document` class
    added earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d21a2328-fe07-4c99-9207-e7fdb7aee38c.png)'
  prefs: []
  type: TYPE_IMG
- en: The `DeweyDecimal` system is quite big. For this reason, I have not catered
    for every book classification available. I have also only assumed that you would
    want to be working with programming eBooks. In reality, however, you may want
    to add in other classifications, such as literature, the sciences, the arts, and
    so on. It is up to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s create a class to represent the Dewey Decimal system::'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `DeweyDecimal` class and add the following code to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Word nerds may disagree with me here, but I would like to remind them that I'm
    a code nerd. The classifications represented here are just so that I can catalog
    programming and computer science-related eBooks. As mentioned earlier, you can
    change this to suit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to add in the heart of the `eBookManager.Engine` Solution. This
    is a class called `DocumentEngine` and it will be a class that will contain the
    methods you need to work with the documents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d2cacf4e-425d-48ba-8b6e-b54c93db28fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Your `eBookManager.Engine` Solution will now contain the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DeweyDecimal`'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Document`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DocumentEngine`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/1a779efd-e56b-49df-b3d1-b419fdb71258.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We now need to add a reference to `eBookManager.Engine` from the `eBookManager`
    project. I''m sure that you all know how to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0d58c2d1-d2d6-44b1-9003-e98f2910f514.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `eBookManager.Engine` project will be available under the Projects section
    in the Reference Manager screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3077c08c-964a-4df0-a3ff-2e94f13733e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have added the reference, we need a Windows Form that will be responsible
    for importing new books. Add a new form called `ImportBooks` to the `eBookManager`
    Solution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3fb2a00a-dd6b-443e-aea3-f45855b51aec.png)'
  prefs: []
  type: TYPE_IMG
- en: Before we forget, add an `ImageList` control to the `ImportBooks` form and call
    it `tvImages`. This will contain the images for the different types of documents
    we want to catalog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ImageList` is a control you add from the Toolbox on to the `ImportBooks`
    form. You can access the Images Collection Editor from the `ImageList` properties.
  prefs: []
  type: TYPE_NORMAL
- en: The icons can be found in the `img` folder in the source code downloadable from
    GitHub at the following URL—[https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints](https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints).
  prefs: []
  type: TYPE_NORMAL
- en: 'The icons here are catering for PDF, MS Word, and ePub file types. It also
    contains folder images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9767272-01b8-47e1-818b-6c8fb5db1a32.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, to use tuples in C# 7, you need to add the `System.ValueTuple` NuGet package.
    Right-click on your Solution and select Manage NuGet Packages for Solution...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please note that if you are running the .NET Framework 4.7, `System.ValueTuple`
    is included in this version of the framework. You will therefore not need to get
    it from NuGet.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2497780d-23bd-4ad4-8652-5a213b6c65e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Search for `System.ValueTuple` and add it to your Solution projects. Then click
    Install and let the process complete (you will see the progress in the output
    window in Visual Studio):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/70de0865-a9b2-43db-99df-9133fb4459d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I love making use of extension methods in my projects. I usually add a separate
    project and/or class for this purpose. In this application, I added an `eBookManager.Helper`
    class library project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6252e916-0d45-49c9-8058-79975d06054d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This helper class must also be added to the `eBookManager` Solution as a reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0c1750f1-688f-47d9-a836-4c60109dd1df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, I will be using JSON as a simple file store for my eBook catalogue.
    JSON is really flexible and can be consumed by various programming languages.
    What makes JSON so nice is the fact that it is relatively light weight and the
    output it generates is human-readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12a59967-de8b-4831-a04e-d6224481671a.png)'
  prefs: []
  type: TYPE_IMG
- en: Go to Manage the NuGet packages for your Solution and search for `Newtonsoft.Json`.
    Add this then to the projects in your Solution and click the Install button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have now set up the basics needed for your `eBookManager` application. Next,
    we will venture further into the guts of the application by writing some code.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Storage Spaces and extension methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by discussing the logic behind a Virtual Storage Space. This is
    a single virtual representation of several physical spaces on your hard drive
    (or hard drives). A storage space will be seen as a single area where a specific
    group of eBooks are *stored*. I use the term *stored* loosely because the storage
    space doesn''t exist. It represents more of a grouping than a physical space on
    the hard drive:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start creating Virtual Storage Spaces, add a new class called `StorageSpace`
    to the `eBookManager.Engine` project. Open the `StorageSpace.cs` file and add
    the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that you need to include the `System.Collections.Generic` namespace here,
    because the `StorageSpace` class contains a property called `BookList` of type
    `List<Document>` that will contain all the books in that particular storage space.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to focus our attention on the `ExtensionMethods` class in the `eBookManager.Helper`
    project. This will be a static class, because extension methods need to be static
    in nature in order to act on the various objects defined by the extension methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new class to the `eBookManager.Helper` project and modify the `ExtensionMethods`
    class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let's add the first extension method to the class called `ToInt()`. What this
    extension method does is take a `string` value and try to parse it to an `integer`
    value. I am too lazy to type `Convert.ToInt32(stringVariable)` whenever I need
    to convert a `string` to an `integer`. It is for this reason that I use an extension
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following static method to the `ExtensionMethods` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `ToInt()` extension method acts only on `string`. This is defined by the
    code `this string value` in the method signature where `value` is the variable
    name that will contain the `string` you are trying to convert to an `integer`.
    It also has a default parameter called `defaultInteger`, which is set to `0.`
    Unless the developer calling the extension method wants to return a default integer
    value of `0`, they can pass a different integer to this extension method (`-1`,
    for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also here that we find our first feature of C# 7\. The improvement to
    `out` variables. In previous iterations of C#, we had to do the following with
    `out` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There was this predeclared integer variable hanging around and it gets its
    value if the `string` value parsed to an `integer`. C# 7 simplifies the code a
    lot more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'C# 7 allows developers to declare an `out` variable right there where it is
    passed as an `out` argument. Moving along to the other methods of the `ExtensionMethods`
    class, these methods are used to provide the following logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Read` and `write` to the data source'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether a storage space exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert bytes to megabytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert a `string` to an `integer` (as discussed previously)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ToMegabytes` method is quite easy. Not having to write this calculation
    all over the place, defining it inside an extension method makes sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We also need a way to check if a particular storage space already exists.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to add a project reference to `eBookManager.Engine` from the `eBookManager.Helper`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'What this extension method also does is to return the next storage space ID
    to the calling code. If the storage space does not exist, the returned ID will
    be the next ID that can be used when creating a new storage space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to create a method that will `write` the data we have to a file
    after converting it to JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This method is rather self-explanatory. It acts on a `List<StorageSpace>` object
    and will create the JSON data, overwriting a file defined in the `storagePath`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we need to be able to `read` the data back again into a `List<StorageSpace>`
    object and return that to the calling code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The method will return an empty `List<StorageSpace>` object and nothing is contained
    in the file. The `ExtensionMethods` class can contain many more extension methods
    that you might use often. It is a great way to separate often-used code.
  prefs: []
  type: TYPE_NORMAL
- en: The DocumentEngine class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of this class is merely to provide supporting code to a document.
    In the `eBookManager` application, I am going to use a single method called `GetFileProperties()`
    that will (you guessed it) return the properties of a selected file. This class
    also only contains this single method. As the application is modified for your
    specific purposes, you can modify this class and add additional methods specific
    to documents.
  prefs: []
  type: TYPE_NORMAL
- en: The `DocumentEngine` class introduces us to the next feature of C# 7 called
    **tuples**. What do tuples do exactly? It is often a requirement for a developer
    to return more than a single value from a method. Among other Solutions, you can
    of course use `out` parameters, but these do not work in `async` methods. Tuples
    provide a better way to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `DocumentEngine` class, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `GetFileProperties()` method returns a tuple as `(DateTime dateCreated,
    DateTime dateLastAccessed, string fileName, string fileExtension, long fileLength,
    bool error)` and allows us to inspect the values returned from the calling code
    easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before I try to get the properties of the specific file, I initialize the `tuple`
    by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is an exception, I can return default values. Reading the file properties
    is simple enough using the `FileInfo` class. I can then assign the file properties
    to the `tuple` by doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `tuple` is then returned to the calling code where it will be used as required.
    We will have a look at the calling code next.
  prefs: []
  type: TYPE_NORMAL
- en: The ImportBooks form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ImportBooks` form does exactly what the name suggests. It allows us to
    create Virtual Storage Spaces and to import books into those spaces. The form
    design is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/971b4446-fbf5-449f-94d0-7682e834a5ea.png)'
  prefs: []
  type: TYPE_IMG
- en: The `TreeView` controls are prefixed with `tv`, buttons with `btn`, combo boxes
    with `dl`, textboxes with `txt`, and date time pickers with `dt`. When this form
    loads, if there are any storage spaces defined then these will be listed in the
    `dlVirtualStorageSpaces` combo box. Clicking on the Select source folder button
    will allow us to select a source folder to look for eBooks.
  prefs: []
  type: TYPE_NORMAL
- en: If a storage space does not exist, we can add a new Virtual Storage Space by
    clicking the `btnAddNewStorageSpace` button. This will allow us to add a name
    and description for the new storage space and click on the `btnSaveNewStorageSpace`
    button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Selecting an eBook from the `tvFoundBooks` TreeView will populate the **File
    details** group of controls to the right of the form. You can then add additional
    Book details and click on the `btnAddeBookToStorageSpace` button to add the book
    to our space:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to ensure that the following namespaces are added to your `ImportBooks` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s start at the most logical place to begin with, which is the constructor
    `ImportBooks()` and the form variables. Add the following code above the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The usefulness of the enumerator will become evident later on in code. The `_jsonPath`
    variable will contain the path to the file used to store our eBook information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the constructor as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `_jsonPath` is initialized to the executing folder for the application and
    the file hard coded to `bookData.txt`. You could provide a settings screen if
    you wanted to configure these settings, but I just decided to make the application
    use a hard-coded setting.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to add another enumerator that defines the file extensions that
    we will be able to save in our application. It is here that we will see another
    feature of C# 7 called `expression-bodied` properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expression-bodied accessors, constructors, and finalizers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the following expression looks intimidating, it''s because it is using a
    feature introduced in C# 6 and expanded in C# 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example returns a `HashSet` of allowed file extensions for our
    application. These have been around since C# 6, but have been extended in C# 7
    to include *accessors*, *constructors*, and *finalizers*. Let's simplify the examples
    a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that we had to modify the `Document` class to set a field for `_defaultDate`
    inside the class; traditionally, we would need to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In C# 7, we can greatly simplify this code by simply doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is perfectly legal and compiles correctly. Similarly, the same can be done
    with finalizers (or deconstructors). Another nice implementation of this is `expression-bodied`
    properties as seen with the `AllowedExtensions` property. The `expression-bodied`
    properties have actually been around since C# 6, but who's counting?
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we wanted to just return the `string` value of the `Extension`
    enumeration for PDFs, we could do something such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'That property only has a get accessor and will never return anything other
    than the `string` value of `Extension.pdf`. Simplify that by changing the code
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. A single line of code does exactly the same thing as the previous
    seven lines of code. Falling into the same category, `expression-bodied` property
    accessors are also simplified. Consider the following 11 lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With C# 7, we can simplify this to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes our code a lot more readable and quicker to write. Swing back to
    our `AllowedExtensions` property; traditionally, it would be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Since C# 6, we have been able to simplify this, as we saw previously. This gives
    developers a great way to reduce unnecessary code.
  prefs: []
  type: TYPE_NORMAL
- en: Populating the TreeView control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can see the implementation of the `AllowedExtensions` property when we look
    at the `PopulateBookList()` method. All that this method does is populate the
    `TreeView` control with files and folders found at the selected source location.
    Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The first place we need to call this method is obviously from within itself,
    as this is a recursive method. The second place we need to call it is from the
    `btnSelectSourceFolder` button click event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is all quite straightforward code. Select the folder to recurse and populate
    the `TreeView` control with all the files found that match the file extension
    contained in our `AllowedExtensions` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to look at the code when someone selects a book in the `tvFoundBooks`
    `TreeView` control. When a book is selected, we need to read the properties of
    the selected file and return those properties to the file details section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that it is here that we are calling the method `GetFileProperties()`
    on the `DocumentEngine` class that returns the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Local functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is one of those features in C# 7 that I truly wondered where I would ever
    find a use for. As it turns out, local functions are extremely useful indeed.
    Also called *nested functions* by some, these functions are nested within another
    parent function. It is obviously only within scope inside the parent function
    and adds a useful way to call code that otherwise wouldn''t have any real purpose
    outside the parent function. Consider the `PopulateStorageSpacesList()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To see how `PopulateStorageSpacesList()` calls the local function `BindStorageSpaceList()`,
    have a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe2e05bf-ca6a-4d1d-875d-24d09bd593fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will notice that the local function can be called from anywhere within
    the parent function. In this case, the `BindStorageSpaceList()` local function
    does not return anything, but you can return whatever you like from a local function.
    You could just as well have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The local function is accessible from anywhere within the parent function.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Staying with the `PopulateStorageSpacesList()` method, we can see the use of
    another C# 7 feature called **pattern matching**. The `spaces is null` line of
    code is probably the simplest form of pattern matching. In reality, pattern matching
    supports several patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Pattern matching allows developers to use the `is` expression to see whether
    something matches a specific pattern. Bear in mind that the pattern needs to check
    for the most specific to the most general pattern. If you simply started the case
    with `case Document doc:` then all the objects passed to the `switch` statement
    of type `Document` would match. You would never find specific documents where
    the author is `Stephen King` or starts with `Stephen`.
  prefs: []
  type: TYPE_NORMAL
- en: For a construct inherited by C# from the C language, it hasn't changed much
    since the '70s. C# 7 changes all that with pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing up the ImportBooks code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a look at the rest of the code in the `ImportBooks` form. The form
    load just populates the storage spaces list, if any existing storage spaces have
    been previously saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to add the logic for changing the selected storage space. The `SelectedIndexChanged()`
    event of the `dlVirtualStorageSpaces` control is modified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: I will not go into any detailed explanation of the code here as it is relatively
    obvious what it is doing.
  prefs: []
  type: TYPE_NORMAL
- en: Throw expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We also need to add the code to save a new storage space. Add the following
    code to the `Click` event of the `btnSaveNewStorageSpace` button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see another new feature in the C# 7 language called **throw expressions**.
    This gives developers the ability to throw exceptions from expressions. The code
    in question is this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'I always like to remember the structure of the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e4b9f28-daa1-46cb-9216-2f708f101a55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The last few methods deal with saving eBooks in the selected Virtual Storage
    Space. Modify the `Click` event of the `btnAddBookToStorageSpace` button. This
    code also contains a throw expression. If you haven''t selected a storage space
    from the combo box, a new exception is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Developers can now immediately throw exceptions in code right there where they
    occur. This is rather nice and makes code cleaner and its intent clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Saving a selected book to a storage space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code basically updates the book list in the selected storage
    space if it already contains the specific book (after confirming with the user).
    Otherwise, it will add the book to the book list as a new book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, as a matter of housekeeping, the `ImportBooks` form contains the following
    code for displaying and enabling controls based on the button click events of
    `btnCancelNewStorageSpace` and `btnAddNewStorageSpace` buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: All that remains now is for us to complete the code in the `Form1.cs` form,
    which is the start-up form.
  prefs: []
  type: TYPE_NORMAL
- en: Main eBookManager form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start off by renaming `Form1.cs` to `eBookManager.cs`. This is the start-up
    form for the application and it will list all the existing storage spaces previously
    saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14ca97f5-07c7-4913-9561-0dbda876b642.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Design your `eBookManager` form as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ListView` control for existing storage spaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListView` for eBooks contained in selected storage space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Button that opens the file location of the eBook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A menu control to navigate to the `ImportBooks.cs` form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various read-only fields to display the selected eBook information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you have added the controls, your eBook Manager form will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a01fb98a-4c0b-4b4e-8952-19a51e4dfa7c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Looking at the code we used earlier, you need to ensure that the following
    `using` statements are imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor is quite similar to the `ImportBooks.cs` form''s constructor.
    It reads any available storage spaces and populates the storage spaces list view
    control with the previously saved storage spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user clicks on a storage space, we need to be able to read the books
    contained in that selected space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to create the method that will populate the `lstBooks` list view
    with the books contained in the selected storage space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that each `ListViewItem` is populated with the title of the
    eBook and the index of an image in an `ImageList` control that I added to the
    form. To find the images in the GitHub repository, browse to the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/eBookManager/eBookManager/img](https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/eBookManager/eBookManager/img)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the Images Collection Editor, you will see that I have added them
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/547c25ea-5ae0-4e34-954c-b8499f87f77d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We also need to clear the selected book''s details when the selected storage
    space is changed. I have created two group controls around the file and book details.
    This code just loops through all the child controls, and if the child control
    is a textbox, it clears it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MenuStrip` that was added to the form has a click event on the `ImportEBooks`
    menu item. It simply opens up the `ImportBooks` form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The following method wraps up the logic to select a specific eBook and populate
    the file and eBook details on the `eBookManager` form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, when the book selected is the one you wish to read, click on the Read
    eBook button to open the file location of the selected eBook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This completes the code logic contained in the `eBookManager` application.
  prefs: []
  type: TYPE_NORMAL
- en: You can further modify the code to open the required application for the selected
    eBook instead of just the file location. In other words, if you click on a PDF
    document, the application can launch a PDF reader with the document loaded. Lastly,
    note that the classification has not been implemented in this version of the application.
  prefs: []
  type: TYPE_NORMAL
- en: It is time to fire up the application and test it out.
  prefs: []
  type: TYPE_NORMAL
- en: Running the eBookManager application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the application starts for the first time, there will be no Virtual Storage
    Spaces available. To create one, we will need to import some books. Click on the
    Import eBooks menu item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0cd2007-0d91-4246-b9c2-7eae31b6aa48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Import eBooks screen opens where you can add a new storage space and Select
    source folder for eBooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9a81038-8899-4d89-adbe-b83353339422.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have selected an eBook, add the applicable information regarding the
    book and save it to the storage space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/379bc6c2-2c03-493f-85e9-4c4ce9ddf0a1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After you have added all the storage spaces and eBooks, you will see the Virtual
    Storage Spaces listed. As you click on a storage space, the books it contains
    will be listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5603e606-0f2e-406d-88d5-97661ff24a51.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Selecting an eBook and clicking on the Read eBook button will open up the file
    location containing the selected eBook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ba21d09-586c-4186-a98c-f4bc693b9673.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Lastly, let''s have a look at the **JSON** file generated for the `eBook Manager`
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc28c3c6-53d3-45de-9ae2-04ccc777f562.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the JSON file is quite nicely laid out and it is easily readable.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# 7 is a fantastic version of the language. In this chapter, we had a look
    at `out` variables. You will remember that with C# 7 we now have the ability to
    declare the variable right at the point it is passed as an out argument. We then
    looked at tuples, which provide an elegant way to return multiple values from
    a method.
  prefs: []
  type: TYPE_NORMAL
- en: Moving, on we looked at `expression-bodied` properties, which is a more succinct
    way to write your code. Then, we discussed local functions (one of my favorite
    features) and its ability to create a helper function inside another function.
    This makes sense if the function that uses the local function is the only code
    that uses it.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching was up next and are syntactic elements that look to see if
    a specific value has a certain *shape*. This makes `switch` statements (for example)
    nicer to use. Lastly, we looked at throw expressions. This makes it possible to
    add exception throwing to our `expression-bodied` members, conditional and null-coalescing
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: As you continue to use C# 7, you will discover more opportunities to use these
    new features. At first (for me anyway) I had to purposefully condition myself
    to write code using a new feature (out variables being a perfect example).
  prefs: []
  type: TYPE_NORMAL
- en: After a while, the convenience of doing that becomes second nature. You will
    soon start to automatically write code using the new features available to you.
  prefs: []
  type: TYPE_NORMAL

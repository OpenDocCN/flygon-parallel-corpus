- en: ASP.NET SignalR Chat Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine having the ability to have your server-side code push data to your web
    page in real time, without the user needing to refresh the page. As they say,
    there are many ways to skin a cat, but the ASP.NET SignalR library provides developers
    with a simplified method to add real-time web functionality to applications.
  prefs: []
  type: TYPE_NORMAL
- en: To showcase the capabilities of SignalR, we'll build a simple ASP.NET Core SignalR
    chat application. This will include the use of NuGet and **Node Package Manager**
    (**npm**) to add the required package files to the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Overall project layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the SignalR libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solution overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's dive in.
  prefs: []
  type: TYPE_NORMAL
- en: Project layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this project, we''ll need the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chat Server**: This will be our server-side C# code that will process and
    direct the messages sent from the client(s)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chat Client(s)**: A client will consist of JavaScript functions for sending
    messages to and receiving messages from the server, and HTML elements for display'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll start with the server code and move over to the client, building a simple
    bootstrap layout and calling some JavaScript functions from there.
  prefs: []
  type: TYPE_NORMAL
- en: As a bonus, we'll include a method to archive our conversation history to a
    text file.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s set up this project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Visual Studio 2017, we will create an ASP.NET Core Web Application. You
    can call the application anything you like, but I called mine `Chapter5`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3557b025-a04f-4f72-8743-84ab52c8f8e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll go with an empty project template. Be sure to select ASP.NET Core 2.0
    from the dropdown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e4c9d023-7cfa-418b-8c99-d1cbb69f8fb5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The project will be created and will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0cfa0d0f-3d72-4ff5-9cca-bd328d2b6eda.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding the SignalR libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we need to add the SignalR package files to our project.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the package for ASP.NET Core SignalR could not be found
    when browsing in the NuGet Package Manager, so we'll use the Package Manager Console
    to add the packages needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to Tools | NuGet Package Manager | Package Manager Console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/491113b9-d5af-4c63-9948-b5064f3f4b70.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the console window type the following command and hit enter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You should see a few response lines showing the items that were Successfully
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: We also need the SignalR client JavaScript library for our project. For this
    we'll use an `npm` command.
  prefs: []
  type: TYPE_NORMAL
- en: npm is a package manager, like NuGet, but for JavaScript. Feel free to check
    it out at [https://www.npmjs.com](https://www.npmjs.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the console window type the following command and hit *enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will download a host of js files to a `node_modules` folder within your
    project's root directory. The output may show some warnings, but fear not. You
    can confirm that the download was successful if the `node_modules` directory exists.
  prefs: []
  type: TYPE_NORMAL
- en: With our packages in place, we can (finally) start writing some code.
  prefs: []
  type: TYPE_NORMAL
- en: Building the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll need to build a server for our chat program, which will contain the methods
    we want to call from our connected clients. We'll use the SignalR Hubs API, which
    provides the methods needed for connected clients to communicate with our chat
    server.
  prefs: []
  type: TYPE_NORMAL
- en: SignalR Hub subclass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now need to create the SignalR Hub. To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a class to your project to handle the server-side of the chat. We''ll call
    it `Chat`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c2a31c66-7397-4722-b6ce-e727742fd17a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will need to be a subclass of the SignalR `Hub` class. Make sure to add
    the using directive for `Micosoft.AspNetCore.SignalR`. Visual Studio''s *Quick
    Actions* works well for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d53e3e5-5541-47e5-afe1-dd58541b9a74.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now add a `Task` method to the class to handle the sending of the messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This method will be called through any of the connected clients and will invoke
    all connected clients' `Send` function, passing through the sender and message
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add a `Task` method to handle the archive functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this method simply takes the value of the messages string parameter,
    writes it to a new text file named `ChatArchive_[date].txt`, which is saved to
    the given path, and invoke the client(s) `Archived` function.
  prefs: []
  type: TYPE_NORMAL
- en: For these two tasks to actually work we need to do some more scaffolding.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `Startup.cs` file, we need to add the SignalR service to the container
    as well as configure the HTTP request pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ConfigureServices` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Configure` method, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Your code window will now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5021442e-5018-4ccb-ab30-91330c32d075.png)'
  prefs: []
  type: TYPE_IMG
- en: That's our server done.
  prefs: []
  type: TYPE_NORMAL
- en: You will note that I have added the following line of code, `app.UseStaticFiles()`
    to the `Configure` method. Static files are assets that an ASP.NET Core app serves
    directly to clients. Examples of static files are HTML, CSS, JavaScript, and images.
  prefs: []
  type: TYPE_NORMAL
- en: We can (and will) extend our server's functionality a bit later, but, for now,
    let's head over to our client.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in our Project Layout, the client will consist of JavaScript functions
    for sending messages to and receiving message from the server, and HTML elements
    for display.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your project, add a new folder under `wwwroot`, called `scripts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2e8d92dd-0328-41d7-b3f8-2552bd212de3.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember that the `node_modules` directory that was created for us by our `npm`
    command earlier?
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the following path within the `node_modules` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`\@aspnet\signalr-client\dist\browser`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22acf021-0aa0-44fa-b909-b8c6fdf2fa1a.png)'
  prefs: []
  type: TYPE_IMG
- en: Copy the `signalr-client-1.0.0-alpha2-final.min.js` file to the scripts folder
    we just created in our project. We will be referencing this library within our
    HTML file, which we will create now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an HTML page to the `wwwroot` folder. I''ve named mine `index.html`. I''ll
    recommend naming yours the same. I''ll explain later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7fadb9f8-a9fc-4621-ad12-40dacf9fd110.png)'
  prefs: []
  type: TYPE_IMG
- en: We'll keep the client page really simple. I'm using `div` tags as panels to
    show and hide the different sections on the page. I'm also using bootstrap to
    make it look nice, but you can design it whichever way you like. I'm also not
    going to bore you with the basics like where to specify your page title. We'll
    stick to the relevant elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me show you the entire HTML layout code as well as the JavaScript and we''ll
    break it down from there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Included libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add `link` and `script` tags to include the required libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you do not want to use bootstrap for the look and feel, you don't need the
    bootstrap JavaScript library or CSS, but note that we will be using jQuery in
    our scripts, so leave that one in.
  prefs: []
  type: TYPE_NORMAL
- en: Naming section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll need to know who our chatroom attendee is. Add an input element to capture
    the username and a button to call the `enterChat` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<input id="username" type="text" class="form-control" />`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<button class="btn btn-default" onclick="enterChat()">Enter</button>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chat input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the required elements to enable our user to type a message (input) and
    post it to the server (event button for `sendMessage`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`<input id="message" type="text" class="form-control" />`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<button class="btn btn-info" onclick="sendMessage()">Send</button>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversation panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a `div` tag with ID `"chat"`. We will use this as a container for our conversation
    (chat history):'
  prefs: []
  type: TYPE_NORMAL
- en: '`<div id="chat" class="well well-lg"></div>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Archive function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the required elements to enable our user to specify a path where the archive
    file needs to be saved (input) and post the messages to the server (event button
    for `archiveChat`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`<input id="archivePath" type="text" class="form-control" />`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<button class="btn btn-info" onclick="archiveChat()">Archive Chat</button>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our client will need some code to send and consume messages to and from the
    server. I''ve tried to keep the JavaScript as simple as possible, opting for jQuery
    code for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a variable (I''ve named mine `connection`) for our SignalR Hub Server
    and call its start function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `'/chat'` parameter for `signalR.HubConnection` refers to our `Chat.cs`
    class, which inherits the Hub interface from SignalR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `UpdateChat` and `Archived` methods, which will be invoked by the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We simply pass the parameters we get from the server onto our `updateChat` method.
    We'll define that method in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `enterChat` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We set the text of our `user` label from the value of the username input element,
    pass it through to our `sendWelcomeMessage` method (which we'll define in a bit),
    and toggle the display of the relevant panels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `sendMessage` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We set the `message` variable from the message input element, before clearing
    it for the next message, and the `user` variable from the user label. Then we
    call the `Send` method on our server by using the `connection.invoke` method and
    pass through our variables as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `sendWelcomeMessage` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Just like the `sendMessage` function described in step 4, we will use the `connection.invoke`
    function to call the `Send` method on our server. This time though we pass through
    the string `'system'` as the user parameter and a little informational message
    about the user that just joined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `updateChat` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`updateChat` is just our custom function used to update the chat history panel.
    We could have done this inline in the two `connection.on` functions, but that
    means we would have repeated ourselves. As a general rule in any coding you should
    try not to repeat code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we set the `chat` variable to however we want each chat history
    line to look in terms of styling. In this case, we simply style our user (with
    a colon) bold with the message un-styled afterwards and a line-break at the end.
    A few lines of chat will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**John**: Hello people'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sarah**: Hi John'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**server**: Peter joined the chat'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**John**: Hi Sarah, Hello Peter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Peter**: Hello Everyone'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I also check the chat div `innerText` property to determine if the chat history
    and archive panels should be visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `archiveChat` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Like everything else, I've tried to keep this as simple as possible. We take
    the `innerText` of our chat panel (div) and the path specified in the `archivePath`
    input and pass it through to the server's `ArchiveChat` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course we have a small window for error here: if the user does not type
    in a valid path for the file to be saved, the code will throw an exception. I''ll
    leave it to your own creativity to sort that one out. I''m just here for the SignalR
    functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: Solution overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now you should have a complete, buildable solution. Let''s have a quick look
    at the solution in Solution Explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01b3c3b0-90b7-4bc6-b9d5-130e1430940f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Starting at the top, let me list the changes we''ve made to our `Chapter5`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the SignalR Asp.NET Core library we added through NuGet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Dependencies/NuGet/Microsoft.AspNetCore.SignalR (1.0.0-alpha2-final)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We copied this JavaScript library manually from the `node_modules` folder after
    we downloaded it using `npm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`wwwroot/scripts/signalr-client-1.0.0-alpha2-final.min.js`'
  prefs: []
  type: TYPE_NORMAL
- en: Our client page with HTML markup, styling and JavaScript all in one:  `one.wwwroot/index.html`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are going to use this application as a base and extend it, I recommend
    moving the JavaScript code to a separate `.js` file. It is easier to manage and
    is another good coding standard to follow.
  prefs: []
  type: TYPE_NORMAL
- en: '`Chat.cs`: This is our chat server code—or rather any custom Task methods that
    we declared'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Startup.cs`: This file is standard in an Asp.NET Code web application, but
    we changed the configuration to make sure SignalR is added as a service'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s build our project. On the top menu in Visual Studio, click the Build
    menu button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4640cf57-8c48-48e4-905e-c13e61731f40.png)'
  prefs: []
  type: TYPE_IMG
- en: You can choose to either build the entire solution, or in individual project.
    Seeing that we only have one project in our solution, we can choose either. You
    can also use the keyboard shortcut *Ctrl* + *Shift* + *B*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see some (hopefully successful) build messages in the Output window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ea60140-3380-4d22-88ce-b05b988eb1dc.png)'
  prefs: []
  type: TYPE_IMG
- en: If you get any errors, go through the chapter again and see whether you have
    missed something. A small thorn can cause a lot of discomfort.
  prefs: []
  type: TYPE_NORMAL
- en: Showing and telling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time. You've created the project, added the libraries, and wrote the code.
    Now let's see this thing in action.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the app, hit *F5* (or *Ctrl* + *F5* to start without debugging). The
    app will open in your default browser and you should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3c3dad3-aa48-4ecb-931a-b904edf99865.png)'
  prefs: []
  type: TYPE_IMG
- en: Wait. What? We must be missing something here.
  prefs: []
  type: TYPE_NORMAL
- en: Now we could just navigate to the index.html page by changing our URL to `localhost:12709/index.html`
    (just check your port number) and we'll be all good.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, let's specify our `index.html` page as our default launch page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Startup.cs` class, in the `Configure` method, add this line at the
    top:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.UseDefaultFiles();`'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this little gem, any request to the `wwwroot` folder (which at any time
    navigates to your website) will search for one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`default.htm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index.htm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first file found will be the file served as your default page. Great!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s run our app again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1bfe8fc-a929-49ad-95b2-670f290432ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Even though our URL still does not show the `/index.html` part, our web app
    now knows which page to serve. Now we can start chatting. Type a username and
    hit *Enter:*
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d709f6ac-7698-4d04-8c10-bbf889d243f4.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, our name panel is now hidden and our chat and archive panels
    are showing.
  prefs: []
  type: TYPE_NORMAL
- en: Our server was also kind enough to inform us that we joined the chat, thanks
    to our `sendWelcomeMessage(user)` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time we send a message, our Chat History will be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b43327e-ef9d-455d-89bc-b6540065f0ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting the party started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A conversation is only a conversation if multiple parties are involved. So let's
    start a party.
  prefs: []
  type: TYPE_NORMAL
- en: If you publish the app on a network you can use actual network clients to chat
    with, but I'm not on a network (not in that sense), so we use another trick. We
    can use various browsers to represent our different party guests (network clients).
  prefs: []
  type: TYPE_NORMAL
- en: Copy your application URL (once again, check the port number) and paste it into
    a few other browsers.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a22f7279-49d4-4b86-9e0e-ce876ad1c5c8.png)'
  prefs: []
  type: TYPE_IMG
- en: For each new guest (browser) you will need to specify a username. To make it
    easier to follow, I'll call my additional guests the different browser names.
  prefs: []
  type: TYPE_NORMAL
- en: 'As each of them enter the chat and start sending messages, you''ll see our
    Chat History grow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2dbcf2c4-7279-4912-9bbe-6a1fe131277f.png)'
  prefs: []
  type: TYPE_IMG
- en: You can tile the browsers (or move them to other monitors if you have extra)
    to see how many message sent by one, gets delivered to all instantaneously, which
    is the whole point of SignalR.
  prefs: []
  type: TYPE_NORMAL
- en: 'We started with John Doe in Microsoft Edge, so we''ll continue with him there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85bad280-d76b-4bb9-9c8b-312f268c9c5c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Opera was the first to join the party:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/131e397c-c19f-4f7e-ad53-4e7edf88b91e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then Chrome arrived:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/320084a0-9cc5-4017-90ce-6a6053b87f93.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And finally, Firefox joined as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e09e7e15-e27f-4078-a751-a895b7e3b77b.png)'
  prefs: []
  type: TYPE_IMG
- en: You'll also notice that each guest's chat history only starts when they join
    the chat. This is by design. We don't send historical chats to clients when they
    join.
  prefs: []
  type: TYPE_NORMAL
- en: Archiving the chat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To save the chat history to a text file, enter a valid local folder path in
    the `archivePath` input element and hit the Archive Chat button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b97673f-55c3-4f9c-8811-6da042913545.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As mentioned earlier, we haven''t built in proper validation for our path,
    so make sure you test it using a valid path. If successful, you should see a message
    in the chat window like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You will also find the newly created text file in the specified path with the
    `ChatArchive_[date].txt` naming convention.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As shown in this chapter, SignalR is really easy to implement. We created a
    chat application, but there are a number of apps that can benefit from real-time
    experiences. These include stock exchange, social media, multiplayer games, auctions,
    e-commerce, financial reporting, and weather notifications
  prefs: []
  type: TYPE_NORMAL
- en: The list can go on. Even if the need for real-time data is not a requirement,
    SignalR can still be beneficial for any app to make communication between nodes
    seamless.
  prefs: []
  type: TYPE_NORMAL
- en: Glancing at the GitHub page for Asp.NET SignalR ([https://github.com/aspnet/SignalR](https://github.com/aspnet/SignalR)),
    it is obvious that the library is constantly being worked on and improved, which
    is great news.
  prefs: []
  type: TYPE_NORMAL
- en: With the need for quick, relevant, and accurate information becoming more critical,
    SignalR is a great player to have on your team.
  prefs: []
  type: TYPE_NORMAL

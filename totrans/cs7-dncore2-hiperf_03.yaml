- en: Multithreading and Asynchronous Programming in .NET Core
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multithreading and asynchronous programming are two essential techniques that
    facilitate the development of highly scalable and performant applications. If
    the application is not responsive, it affects the user experience and increases
    the level of dissatisfaction. On the other hand, it also increases the resource
    usage on the server side, or where the application is running, and also increases
    the memory size and/or CPU usage. Nowadays, hardware is very cheap, and every
    machine comes with multiple CPU cores. Implementing multithreading and using asynchronous
    programming techniques not only increases the performance of the application,
    but also makes the application more responsive in nature.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: This chapter examines the core concepts of multithreading and the asynchronous
    programming model to help you use them in your projects and increase the overall
    performance of your applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of the topics that we will learn about in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading versus asynchronous programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multithreading in .NET Core
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threads in .NET Core
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread synchronization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task parallel library (TPL)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a task using TPL
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task-based asynchronous pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns for parallel programming
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I/O bound operations are code that is dependent on external resources. Examples
    include accessing a filesystem, accessing a network, and so on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading versus asynchronous programming
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multithreading and asynchronous programming, if properly implemented, improve
    the performance of an application. Multithreading refers to the practice of executing
    multiple threads at the same time to execute multiple operations or tasks in parallel.
    There could be one main thread and several background threads, usually known as
    worker threads, running in parallel at the same time, executing multiple tasks
    concurrently, whereas both synchronous and asynchronous operations can run on
    a single-threaded or a multithreaded environment.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: In a single-threaded synchronous operation, there is only one thread that performs
    all the tasks in a defined sequence, and it executes them one after the other.
    In a single-threaded asynchronous operation, there is only one thread that executes
    the tasks, but it allocates a time slice in which to run each task. When the time
    slice is over, it saves the state of that task and starts executing the next one.
    Internally, the processor performs the context switching between each task and
    allocates a time slice in which to run them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: In a multithreaded synchronous operation, there are multiple threads that run
    the tasks in parallel. There is no context switching between the tasks, like we
    have in an asynchronous operation. One thread is responsible for executing the
    tasks assigned to it and then starting another task, whereas in a multithreaded
    asynchronous operation, multiple threads run multiple tasks and the task can be
    served and executed by single or multiple threads.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the differences between the single and multithreaded
    synchronous and asynchronous operations:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.gif)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows four types of operations. In the single-threaded
    synchronous operation, we have one thread running five tasks sequentially. Once
    **Task 1** is completed, **Task 2** is executed, and so on. In the single-threaded
    asynchronous operation, we have a single thread, but each task will get a time
    slice to execute before the next task is executed and so on. Each task will be
    executed multiple times and resume from where it was paused. In the multi-threaded
    synchronous operation, we have three threads running three tasks **Task 1**, **Task
    2**, and **Task 3** in parallel. Lastly, in the multithreaded asynchronous operation,
    we have three tasks—**Task 1**, **Task 2**, and **Task 3**—running by three threads,
    but each thread performs some context switching based on the time slice allocated
    to each task.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: In asynchronous programming, it is not always the case that each asynchronous
    operation will be running on a new thread. *`Async`/`Await`* is a good example
    of a situation where there is no additional thread created. The `*async*` operation
    is executed in the current synchronization context of the main thread and queues
    the asynchronous operation executed in the allocated time slice.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading in .NET Core
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many benefits in using multithreading in CPU and/or I/O-bound applications.
    It is often used for long-running processes that have a longer or infinite lifetime,
    working as background tasks, keeping the main thread available in order to manage
    or handle user requests. However, unnecessary use may completely degrade the application's
    performance. There are cases where creating too many threads is not a good architecture
    practice.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples where multithreading is a good fit:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: I/O operations
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running long-running background tasks
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database operations
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating over a network
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multithreading caveats
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although there are many benefits to multithreading, there are some caveats
    that need to be thoroughly addressed when writing multithreaded applications.
    If the machine is a single or two-core machine and the application is creating
    lots of threads, the context switching between these threads will slow the performance:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00040.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram depicts the program running on a single-processor machine.
    The first task executes synchronously, and runs comparatively faster than the
    three threads running on the single processor. The system executes the first thread,
    then waits for a while before moving on to execute the second thread, and so on.
    This adds an unnecessary overhead of switching between threads and, thus, delays
    the overall operation. In the field of threading, this is known as context switching.
    The boxes between each thread represent the delay occurring during each context
    switch between threads.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: As far as the developer experience is concerned, debugging and testing are two
    other issues that are challenging for developers when creating a multithreaded
    application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Threads in .NET Core
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every application in .NET starts with a single thread, which is the main thread.
    A thread is the basic unit that the operating system uses to allocate processor
    time. Each thread has a priority, exception handlers, and a data structure saved
    in its own thread context. If the exception is thrown, it is thrown inside the
    context of the thread and other threads are not affected by it. The thread context
    contains some low-level information about, for example, the CPU registers, the
    address space of the thread's host process, and so on.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: If an application is running multiple threads on a single processor, each thread
    will be assigned a period of processor time and will be executed one after the
    other. The time slice is usually small, which makes it seem as if the threads
    are being executed at the same time. Once the allocated time is over, the processor
    moves to the other thread and the previous thread wait for the processor to become
    available again and execute it based on the time slice allocated. On the other
    hand, if the threads are running on multiple CPUs, then they may execute at the
    same time, but if there are other processes and threads running, the time slice
    will be allocated and executed accordingly.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Creating threads in .NET Core
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In .NET Core, the threading API is the same as that used in the full .NET Framework
    version. A new thread can be created by creating a `Thread` class object and passing
    the `ThreadStart` or `ParameterizedThreadStart` delegate as a parameter. `ThreadStart`
    and `ParameterizedThreadStart` wrap a method that is invoked when the new thread
    is started. `ParameterizedThreadStart` is used for method containing parameters.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a basic example that runs the `ExecuteLongRunningOperation `method on
    a separate thread:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can also pass parameters while starting the thread and use the `ParameterizedThreadStart`
    delegate:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动线程时，我们还可以传递参数并使用`ParameterizedThreadStart`委托：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `ParameterizedThreadStart` delegate takes an object as a parameter. So,
    if you want to pass multiple parameters, this can be done by creating a custom
    class and adding the following properties:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParameterizedThreadStart`委托接受一个对象作为参数。因此，如果要传递多个参数，可以通过创建自定义类并添加以下属性来实现：'
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Every thread has a thread priority. When a thread is created, its priority
    is set to normal. The priority affects the execution of the thread. The higher
    the priority, the higher the precedence that will be given to the thread. The
    thread priority can be defined on the thread object, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都有一个线程优先级。当线程被创建时，其优先级被设置为正常。优先级影响线程的执行。优先级越高，线程将被赋予的优先级就越高。线程优先级可以在线程对象上定义，如下所示：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`RunBackgroundService` is the method that executes in a separate thread, and
    the priority can be set by using the `ThreadPriority` enum and referencing the
    current thread object by calling `Thread.CurrentThread`, as shown in the preceding
    code snippet.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`RunBackgroundService`是在单独的线程中执行的方法，可以使用`ThreadPriority`枚举设置优先级，并通过调用`Thread.CurrentThread`引用当前线程对象，如上面的代码片段所示。'
- en: Thread lifetime
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程生命周期
- en: The lifetime of the thread depends on the method executing within that thread.
    Once the method is executed, CLR de-allocates the memory taken by the thread and
    disposes of. On the other hand, the thread can also be disposed of explicitly
    by calling the `Interrupt` or `Abort` methods.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的生命周期取决于在该线程中执行的方法。一旦方法执行完毕，CLR将释放线程占用的内存并进行处理。另一方面，也可以通过调用`Interrupt`或`Abort`方法显式地处理线程。
- en: Another very important factor to consider is exceptions. If the exceptions are
    not properly handled within a thread, they are propagated to the `calling` method
    and so on until they reach the `root` method in the call stack. When it reaches
    this point, CLR will shut down the thread if it is not handled.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常重要的因素是异常。如果异常在线程内部没有得到适当处理，它们将传播到`调用`方法，依此类推，直到它们到达调用堆栈中的`根`方法。当它达到这一点时，如果没有得到处理，CLR将关闭线程。
- en: 'For continuous or long-running threads, the shutdown process should be properly
    defined. One of the best approaches to smoothly shut down the thread is by using
    a `volatile bool` variable:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于持续或长时间运行的线程，关闭过程应该被正确定义。平滑关闭线程的最佳方法之一是使用`volatile bool`变量：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we have used the `volatile bool` variable `isActive`,
    that decides if the `while` loop execute or not.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们使用了`volatile bool`变量`isActive`，它决定了`while`循环是否执行。
- en: 'The `volatile` keyword indicates that a field may be modified by multiple threads
    that are executing at the same time. Fields that are declared volatile are not
    subject to compiler optimizations that assume access by a single thread. This
    ensures that the most up-to-date value is present in the field at all times. To
    learn more about volatile, kindly refer the following URL:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`volatile`关键字表示一个字段可能会被多个同时执行的线程修改。声明为volatile的字段不受编译器优化的影响，假设只有一个线程访问。这确保了字段中始终存在最新的值。要了解更多关于volatile的信息，请参考以下URL：'
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/volatile](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/volatile)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/volatile](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/volatile)'
- en: The thread pool in .NET
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET中的线程池
- en: CLR provides a separate thread pool that contains the list of threads to be
    used to execute tasks asynchronously. Each process has its own specific thread
    pool. CLR adds and removes threads in or from the thread pool.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: CLR提供了一个单独的线程池，其中包含要用于异步执行任务的线程列表。每个进程都有自己特定的线程池。CLR向线程池中添加和移除线程。
- en: 'To run a thread using `ThreadPool`, we can use `ThreadPool.QueueUserWorkItem`,
    as shown in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ThreadPool`来运行线程，我们可以使用`ThreadPool.QueueUserWorkItem`，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`QueueUserWorkItem` queues the task to be executed by the CLR in a thread that
    is available in the thread pool. The task queues are maintained in **First In,
    First Out** (**FIFO**) order. However, depending on the thread''s availability
    and the task job itself, the task completion may be delayed.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueueUserWorkItem`将任务排队，由CLR在线程池中可用的线程中执行。任务队列按照**先进先出**（**FIFO**）的顺序进行维护。但是，根据线程的可用性和任务本身，任务完成可能会延迟。'
- en: Thread synchronization
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程同步
- en: In multithreaded applications, we have shared resources that are accessible
    by multiple threads executing simultaneously. The area where the resources are
    shared across multiple threads is known as the critical section. To protect these
    resources and provide thread-safe access, there are certain techniques that we
    will discuss in this section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程应用程序中，我们有共享资源，可以被多个线程同时访问。资源在多个线程之间共享的区域称为临界区。为了保护这些资源并提供线程安全的访问，有一些技术将在本节中讨论。
- en: 'Let''s take an example where we have a singleton class for logging a message
    into the filesystem. A singleton, by definition, denotes that there should only be one
    instance shared across multiple calls. Here is the basic implementation of a singleton
    pattern that is not thread-safe:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子，我们有一个用于将消息记录到文件系统的单例类。单例，根据定义，表示应该只有一个实例在多次调用之间共享。以下是一个基本的单例模式实现，它不是线程安全的：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code is a lazy initialization singleton that creates an instance
    on the first call on the `GetInstance` method. `GetInstance` is the critical section
    and is not thread-safe. If multiple threads enter into the critical section, multiple
    instances will be created and the race condition will occur.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码是一个懒惰初始化的单例模式，它在第一次调用`GetInstance`方法时创建一个实例。`GetInstance`是临界区，不是线程安全的。如果多个线程进入临界区，将创建多个实例，并发条件将发生。
- en: The race condition is a problem in multithreaded programming that occurs when
    the outcome depends on the timing of events. A race condition arises when two
    or more parallel tasks access a shared object.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争条件是多线程编程中出现的问题，当结果取决于事件的时间时。当两个或多个并行任务访问共享对象时，就会出现竞争条件。
- en: 'To implement the thread-safe singleton, we can use a locking pattern. Locking
    ensures that only one thread can enter into the critical section, and if another
    thread attempts to enter, it will wait until the thread is released. Here is a
    modified version that enables a singleton to be thread-safe:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现线程安全的单例，我们可以使用锁定模式。锁定确保只有一个线程可以进入临界区，如果另一个线程尝试进入，它将等待直到线程被释放。以下是一个修改后的版本，使单例线程安全：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Monitors
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视器
- en: Monitors are used to provide thread-safe access to the resource. It is applicable
    to multithread programming, where there are multiple threads that need access
    to a resource simultaneously. When multiple threads attempt to enter `monitor`
    to access any resource, CLR allows only one thread at a time to enter and the
    other threads are blocked. When the thread exits the monitor, the next waiting
    thread enters, and so on.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 监视器用于提供对资源的线程安全访问。它适用于多线程编程，在那里有多个线程需要同时访问资源。当多个线程尝试进入`monitor`以访问任何资源时，CLR只允许一个线程一次进入，其他线程被阻塞。当线程退出监视器时，下一个等待的线程进入，依此类推。
- en: If we look into the `Monitor` class, all the methods such as `Monitor.Enter`
    and `Monitor.Exit` operate on object references. Similarly to `lock`, `Monitor`
    also provides gated access to the resource; however, a developer will have greater
    control in terms of the API it provides.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`Monitor`类，所有方法如`Monitor.Enter`和`Monitor.Exit`都是在对象引用上操作的。与`lock`类似，`Monitor`也提供对资源的门控访问；但是，开发人员在API方面会有更大的控制。
- en: 'Here is a basic example of using `Monitor` in .NET Core:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在.NET Core中使用`Monitor`的基本示例：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There are certain cases where the critical section has to wait for the resources
    to be available. Once they are available, we want to pulse the waiting block to
    execute.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，关键部分必须等待资源可用。一旦它们可用，我们希望激活等待块以执行。
- en: To help us understand, let's take an example of a running `Job` whose task is
    to run the jobs added by multiple threads. If no job is present, it should wait
    for the threads to push and start executing them immediately.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们理解，让我们举一个运行`Job`的例子，其任务是运行多个线程添加的作业。如果没有作业存在，它应该等待线程推送并立即开始执行它们。
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It's a singleton class, and other threads can access the `JobExecutor` instance
    using the static `Instance` property and call the `AddJobsItems` method to add
    the list of jobs to be executed. The `CheckandExecuteJobBatch` method runs continuously
    and checks for new jobs in the list every 10 minutes. Or, if it is interrupted
    by the `AddJobsItems` method by calling the `Monitor.PulseAll` method, it will
    immediately move to the `while` statement and check for the items count. If the
    items are present, the `CheckandExecuteJobBatch` method calls the `ExecuteJob`
    method that runs that job.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个单例类，其他线程可以使用静态的`Instance`属性访问`JobExecutor`实例，并调用`AddJobsItems`方法将要执行的作业列表添加到其中。`CheckandExecuteJobBatch`方法持续运行并每10分钟检查列表中的新作业。或者，如果通过调用`Monitor.PulseAll`方法中断了`AddJobsItems`方法，它将立即转移到`while`语句并检查项目计数。如果项目存在，`CheckandExecuteJobBatch`方法调用`ExecuteJob`方法来运行该作业。
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, on the main `Program` class, we can invoke three worker threads and
    one thread for `JobExecutor`, as shown in the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在主`Program`类上，我们可以调用三个工作线程和一个`JobExecutor`线程，如下所示：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following is the output of running this code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行此代码的输出：
- en: '![](img/00041.gif)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00041.gif)'
- en: Task parallel library (TPL)
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务并行库（TPL）
- en: So far, we have learned some core concepts about multithreading, and have used
    threads to perform multiple tasks. Compared to the classic threading model in
    .NET, TPL minimizes the complexity of using threads and provides an abstraction
    through a set of APIs that helps developers to focus more on the application program
    instead of focusing on how the threads will be provisioned, as well as other things.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了一些关于多线程的核心概念，并使用线程执行多个任务。与.NET中的经典线程模型相比，TPL最小化了使用线程的复杂性，并通过一组API提供了抽象，帮助开发人员更多地专注于应用程序程序，而不是专注于如何提供线程以及其他事项。
- en: 'There are several benefits of using TPL over threads:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TPL而不是线程有几个好处：
- en: It autoscales the concurrency to a multicore level
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将并发自动扩展到多核级别
- en: It autoscales LINQ queries to a multicore level
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将LINQ查询自动扩展到多核级别
- en: It handles the partitioning of the work and uses `ThreadPool` where required
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它处理工作的分区并在需要时使用`ThreadPool`
- en: It is easy to use and reduces the complexity of working with threads directly
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它易于使用，并减少了直接使用线程的复杂性
- en: Creating a task using TPL
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TPL创建任务
- en: TPL APIs are available in the `System.Threading` and `System.Threading.Tasks`
    namespaces. They work around the task, which is a program or a block of code that
    runs asynchronously. An asynchronous task can be run by calling either the `Task.Run`
    or `TaskFactory.StartNew` methods. When we create a task, we provide a named delegate,
    anonymous method, or a lambda expression that the task executes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: TPL API可在`System.Threading`和`System.Threading.Tasks`命名空间中使用。它们围绕任务工作，任务是异步运行的程序或代码块。可以通过调用`Task.Run`或`TaskFactory.StartNew`方法来运行异步任务。当我们创建一个任务时，我们提供一个命名委托、匿名方法或lambda表达式，任务执行它。
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Alternatively, we can also use the `Task.Factory.StartNew` method, which is
    more advanced and provides more options. While calling the `Task.Factory.StartNew`
    method, we can specify `CancellationToken`, `TaskCreationOptions`, and `TaskScheduler`
    to set the state, specify other options, and schedule tasks.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用`Task.Factory.StartNew`方法，这是更高级的并提供更多选项。在调用`Task.Factory.StartNew`方法时，我们可以指定`CancellationToken`、`TaskCreationOptions`和`TaskScheduler`来设置状态、指定其他选项和安排任务。
- en: TPL uses multiple cores of the CPU out of the box. When the task is executed
    using the TPL API, it automatically splits the task into one or more threads and
    utilizes multiple processors, if they are available. The decision as to how many
    threads will be created is calculated at runtime by CLR. Whereas a thread only has
    an affinity to a single processor, running any task on multiple processors needs
    a proper manual implementation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: TPL默认使用CPU的多个核心。当使用TPL API执行任务时，它会自动将任务分割成一个或多个线程，并利用多个处理器（如果可用）。创建多少个线程的决定是由CLR在运行时计算的。而线程只有一个处理器的亲和性，要在多个处理器上运行任何任务需要适当的手动实现。
- en: Task-based asynchronous pattern (TAP)
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于任务的异步模式（TAP）
- en: When developing any software, it is always good to implement the best practices
    while designing its architecture. The task-based asynchronous pattern is one of
    the recommended patterns that can be used when working with TPL. There are, however,
    a few things to bear in mind while implementing TAP.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发任何软件时，总是要在设计其架构时实现最佳实践。基于任务的异步模式是在使用TPL时可以使用的推荐模式之一。然而，在实现TAP时有一些需要牢记的事情。
- en: Naming convention
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名约定
- en: The method executing asynchronously should have the naming suffix `Async`. For
    example, if the method name starts with `ExecuteLongRunningOperation`, it should
    have the suffix `Async`, with the resulting name of `ExecuteLongRunningOperationAsync`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 异步执行的方法应该以`Async`作为命名后缀。例如，如果方法名以`ExecuteLongRunningOperation`开头，它应该有后缀`Async`，结果名称为`ExecuteLongRunningOperationAsync`。
- en: Return type
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回类型
- en: The method signature should return either a `System.Threading.Tasks.Task` or
    `System.Threading.Tasks.Task<TResult>`. The task's return type is equivalent to
    the method that returns `void`, whereas `TResult` is the data type.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 方法签名应该返回`System.Threading.Tasks.Task`或`System.Threading.Tasks.Task<TResult>`。任务的返回类型等同于返回`void`的方法，而`TResult`是数据类型。
- en: Parameters
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数
- en: The `out` and `ref` parameters are not allowed as parameters in the method signature.
    If multiple values need to be returned, tuples or a custom data structure can
    be used. The method should always return `Task` or `Task<TResult>`, as discussed
    previously.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`out`和`ref`参数不允许作为方法签名中的参数。如果需要返回多个值，可以使用元组或自定义数据结构。方法应该始终返回`Task`或`Task<TResult>`，如前面所讨论的。'
- en: 'Here are a few signatures for both synchronous and asynchronous methods:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是同步和异步方法的一些签名：
- en: '| **Synchronous method** | **Asynchronous method** |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **同步方法** | **异步方法** |'
- en: '| `Void Execute();` | `Task ExecuteAsync();` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `Void Execute();` | `Task ExecuteAsync();` |'
- en: '| `List<string> GetCountries();` | `Task<List<string>> GetCountriesAsync();`
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `List<string> GetCountries();` | `Task<List<string>> GetCountriesAsync();`
    |'
- en: '| `Tuple<int, string> GetState(int stateID);` | `Task<Tuple<int, string>> GetStateAsync(int
    stateID);` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `Tuple<int, string> GetState(int stateID);` | `Task<Tuple<int, string>> GetStateAsync(int
    stateID);` |'
- en: '| `Person GetPerson(int personID);` | `Task<Person> GetPersonAsync(int personID);`
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `Person GetPerson(int personID);` | `Task<Person> GetPersonAsync(int personID);`
    |'
- en: Exceptions
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常
- en: The asynchronous method should always throw exceptions that are assigned to
    the returning task. However, the usage errors, such as passing null parameters
    to the asynchronous method, should be properly handled.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法应该总是抛出分配给返回任务的异常。然而，使用错误，比如将空参数传递给异步方法，应该得到适当处理。
- en: 'Let''s suppose we want to generate several documents dynamically based on a
    predefined templates list, where each template populates the placeholders with
    dynamic values and writes it on the filesystem. We assume that this operation
    will take a sufficient amount of time to generate a document for each template.
    Here is a code snippet showing how the exceptions can be handled:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想根据预定义的模板列表动态生成多个文档，其中每个模板都使用动态值填充占位符并将其写入文件系统。我们假设这个操作将花费足够长的时间来为每个模板生成一个文档。下面是一个代码片段，显示了如何处理异常：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, we have a `GenerateDocumentAsync` method that performs
    a long running operation, such as reading the template from the database, populating
    placeholders, and writing a document to the filesystem. To automate this process,
    we used `Thread.Sleep` to sleep the thread for three seconds and then throw an
    exception that will be propagated to the calling method. The `Main` method loops
    the templates list and calls the `GenerateDocumentAsync` method for each template.
    Each `GenerateDocumentAsync` method returns a task. When calling an asynchronous
    method, the exception is actually hidden until the `Wait`, `WaitAll`, `WhenAll`,
    and other methods are called. In the preceding example, the exception will be
    thrown once the `Task.WaitAll` method is called, and will log the exception on
    the console.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们有一个`GenerateDocumentAsync`方法，执行长时间运行的操作，比如从数据库中读取模板，填充占位符，并将文档写入文件系统。为了自动化这个过程，我们使用`Thread.Sleep`来让线程休眠三秒，然后抛出一个异常，这个异常将传播到调用方法。`Main`方法循环遍历模板列表，并为每个模板调用`GenerateDocumentAsync`方法。每个`GenerateDocumentAsync`方法都返回一个任务。在调用异步方法时，异常实际上是隐藏的，直到调用`Wait`、`WaitAll`、`WhenAll`和其他方法。在上面的例子中，一旦调用`Task.WaitAll`方法，异常将被抛出，并在控制台上记录异常。
- en: Task status
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务状态
- en: The task object provides a `TaskStatus` that is used to know whether the task
    is executing the method running, has completed the method, has encountered a fault,
    or whether some other occurrence has taken place. The task initialized using `Task.Run`
    initially has the status of `Created`, but when the `Start` method is called,
    its status is changed to `Running`. When applying the TAP pattern, all the methods
    return the `Task` object, and whether they are using the `Task.Run` inside, the
    method body should be activated. That means that the status should be anything
    other than `Created`. The TAP pattern ensures the consumer that the task is activated
    and the starting task is not required.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 任务对象提供了`TaskStatus`，用于了解任务是否正在执行方法运行，已完成方法，遇到故障，或者是否发生了其他情况。使用`Task.Run`初始化的任务最初具有`Created`状态，但当调用`Start`方法时，其状态会更改为`Running`。在应用TAP模式时，所有方法都返回`Task`对象，无论它们是否在方法体内使用`Task.Run`，方法体都应该被激活。这意味着状态应该是除了`Created`之外的任何状态。TAP模式确保消费者任务已激活，并且不需要启动任务。
- en: Task cancellation
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务取消
- en: 'Cancellation is an optional thing for TAP-based asynchronous methods. If the
    method accepts the `CancellationToken` as the parameter, it can be used by the
    caller party to cancel a task. However, for a TAP, the cancellation should be
    properly handled. Here is a basic example showing how cancellation can be implemented:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 取消对于基于TAP的异步方法是可选的。如果方法接受`CancellationToken`作为参数，调用方可以使用它来取消任务。但是，对于TAP，取消应该得到适当处理。这是一个基本示例，显示了如何实现取消：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, we have a `SaveFileAsync` method that takes the `byte`
    array and the `CancellationToken` as parameters. In the `Main` method, we initialize
    the `CancellationTokenSource` that can be used to cancel the asynchronous operation
    later in the program. To test the cancellation scenario, we will just call the
    `Cancel` method of the `tokenSource` after the `Task.Factory.StartNew` method
    and the operation will be canceled. Moreover, when the task is canceled, its status
    is set to `Cancelled` and the `IsCompleted` property is set to `true`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个`SaveFileAsync`方法，它接受`byte`数组和`CancellationToken`作为参数。在`Main`方法中，我们初始化了`CancellationTokenSource`，可以在程序后面用于取消异步操作。为了测试取消场景，我们将在`Task.Factory.StartNew`方法之后调用`tokenSource`的`Cancel`方法，操作将被取消。此外，当任务被取消时，其状态设置为`Cancelled`，`IsCompleted`属性设置为`true`。
- en: Task progress reporting
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务进度报告
- en: 'With TPL, we can use the `IProgress<T>` interface to get real-time progress
    notifications from the asynchronous operations. This can be used in scenarios
    where we need to update the user interface or the console app of asynchronous
    operations. When defining the TAP-based asynchronous methods, defining `IProgress<T>`
    in a parameter is optional. We can have overloaded methods that can help consumers
    to use in the case of specific needs. However, they should only be used if the
    asynchronous method supports them.  Here is the modified version of `SaveFileAsync`
    that updates the user about the real progress:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TPL，我们可以使用`IProgress<T>`接口从异步操作中获取实时进度通知。这可以用于需要更新用户界面或控制台应用程序的异步操作的场景。在定义基于TAP的异步方法时，在参数中定义`IProgress<T>`是可选的。我们可以有重载的方法，可以帮助消费者在特定需要的情况下使用。但是，它们只能在异步方法支持它们的情况下使用。这是修改后的`SaveFileAsync`，用于向用户更新实际进度：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Implementing TAP using compilers
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用编译器实现TAP
- en: Any method that is attributed with the `async` keyword (for C#) or `Async` for
    (Visual Basic) is called an asynchronous method. The `async` keyword can be applied
    to a method, anonymous method, or a Lambda expression, and the language compiler
    can execute that task asynchronously.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用`async`关键字（对于C＃）或`Async`（对于Visual Basic）标记的方法都称为异步方法。`async`关键字可以应用于方法、匿名方法或Lambda表达式，语言编译器可以异步执行该任务。
- en: 'Here is a simple implementation of the TAP method using the compiler approach:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用编译器方法的TAP方法的简单实现：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, we have the `ExecuteLongRunningOperationAsync` method,
    which is implemented as per the compiler approach. It calls the `RunLoopAsync`
    that executes a loop for a certain number of milliseconds that is passed in the
    parameter. The `async` keyword on the `ExecuteLongRunningOperationAsync` method
    actually tells the compiler that this method has to be executed asynchronously,
    and, once the `await` statement is reached, the method returns to the `Main` method
    that writes the line on a console and waits for the task to be completed. Once
    the `RunLoopAsync` is executed, the control comes back to `await` and starts executing
    the next statements in the `ExecuteLongRunningOperationAsync` method.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有`ExecuteLongRunningOperationAsync`方法，它是根据编译器方法实现的。它调用`RunLoopAsync`，该方法执行一个传递的毫秒数的循环。`ExecuteLongRunningOperationAsync`方法上的`async`关键字实际上告诉编译器该方法必须异步执行，一旦达到`await`语句，该方法返回到`Main`方法，在控制台上写一行并等待任务完成。一旦`RunLoopAsync`执行，控制权回到`await`，并开始执行`ExecuteLongRunningOperationAsync`方法中的下一个语句。
- en: Implementing TAP with greater control over Task
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现对任务的更大控制的TAP
- en: As we know, that the TPL is centered on the `Task` and `Task<TResult>` objects.
    We can execute an asynchronous task by calling the `Task.Run` method and execute
    a `delegate` method or a block of code asynchronously and use `Wait` or other
    methods on that task. However, this approach is not always adequate, and there
    are scenarios where we may have different approaches to executing asynchronous
    operations, and we may use an **E****vent-based Asynchronous Pattern** (**EAP**)
    or an **A****synchronous Programming Model** (**APM**)*.* To implement TAP principles
    here, and to get the same control over asynchronous operations executing with
    different models, we can use the `TaskCompletionSource<TResult>` object.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，TPL以`Task`和`Task<TResult>`对象为中心。我们可以通过调用`Task.Run`方法执行异步任务，并异步执行`delegate`方法或一段代码，并在该任务上使用`Wait`或其他方法。然而，这种方法并不总是适当，有些情况下我们可能有不同的方法来执行异步操作，我们可能会使用**基于事件的异步模式**（EAP）或**异步编程模型**（APM）。为了在这里实现TAP原则，并以不同的模型执行异步操作，我们可以使用`TaskCompletionSource<TResult>`对象。
- en: '`The TaskCompletionSource<TResult> `object is used to create a task that executes
    an asynchronous operation. When the asynchronous operation completes, we can use
    the `TaskCompletionSource<TResult>` object to set the result, exception, or state
    of the task.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskCompletionSource<TResult>`对象用于创建执行异步操作的任务。异步操作完成后，我们可以使用`TaskCompletionSource<TResult>`对象设置任务的结果、异常或状态。'
- en: 'Here is a basic example that executes the `ExecuteTask` method that returns
    `Task`, where the `ExecuteTask` method uses the `TaskCompletionSource<TResult>`
    object to wrap the response as a `Task` and executes the `ExecuteLongRunningTask`
    through the `Task.StartNew` method:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本示例，执行`ExecuteTask`方法返回`Task`，其中`ExecuteTask`方法使用`TaskCompletionSource<TResult>`对象将响应包装为`Task`，并通过`Task.StartNew`方法执行`ExecuteLongRunningTask`：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Design patterns for parallel programming
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行编程的设计模式
- en: 'There are various ways in which the tasks can be designed to run in parallel.
    In this section, we will learn some top design patterns used in TPL:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 任务可以以各种方式设计并行运行。在本节中，我们将学习TPL中使用的一些顶级设计模式：
- en: Pipeline pattern
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道模式
- en: Dataflow pattern
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据流模式
- en: Producer-consumer pattern
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产者-消费者模式
- en: Parallel.ForEach
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Parallel.ForEach
- en: Parallel LINQ (PLINQ)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行LINQ（PLINQ）
- en: Pipeline pattern
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道模式
- en: 'The pipeline pattern is commonly used in scenarios where we need to execute
    the asynchronous tasks in sequence:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 管道模式通常用于需要按顺序执行异步任务的场景：
- en: '![](img/00042.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00042.jpeg)'
- en: 'Consider a task where we need to create a user record first, then initiate
    a workflow and send an email. To implement this scenario, we can use the `ContinueWith`
    method of TPL. Here is a complete example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个任务，我们需要首先创建一个用户记录，然后启动工作流并发送电子邮件。要实现这种情况，我们可以使用TPL的`ContinueWith`方法。以下是一个完整的示例：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Dataflow pattern
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据流模式
- en: 'The dataflow pattern is a generalized pattern with a one-to-many and a many-to-one
    relationship. For example, the following diagram represents two tasks, **Task
    1** and **Task 2**, that execute in parallel, and a third task, **Task 3**, that
    will only start when both of the first two tasks are completed. Once **Task 3**
    is completed, **Task 4** and **Task 5** will be executed in parallel:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流模式是一种具有一对多和多对一关系的通用模式。例如，以下图表表示两个任务**任务1**和**任务2**并行执行，第三个任务**任务3**只有在前两个任务都完成后才会开始。一旦**任务3**完成，**任务4**和**任务5**将并行执行：
- en: '![](img/00043.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00043.jpeg)'
- en: 'We can implement the preceding example using the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码实现上述示例：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Producer/consumer pattern
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产者/消费者模式
- en: 'One of the best patterns to execute long-running operations is the producer/consumer
    pattern. In this pattern, there are producers and consumers, and one or more producers
    are connected to one or more consumers through a shared data structure known as
    `BlockingCollection`. `BlockingCollection` is a fixed-sized collection used in
    parallel programming. If the collection is full, the producers are blocked, and
    if the collection is empty, no more consumers should be added:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 执行长时间运行操作的最佳模式之一是生产者/消费者模式。在这种模式中，有生产者和消费者，一个或多个生产者通过共享的数据结构`BlockingCollection`连接到一个或多个消费者。`BlockingCollection`是并行编程中使用的固定大小的集合。如果集合已满，生产者将被阻塞，如果集合为空，则不应再添加更多的消费者：
- en: '![](img/00044.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00044.jpeg)'
- en: 'In a real-world example, the producer could be a component reading images from
    a database and the consumer could be a component that processes that image and
    saves it into a filesystem:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的例子中，生产者可以是从数据库中读取图像的组件，消费者可以是处理该图像并将其保存到文件系统的组件：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding example, we initialized the generic `BlockingCollection<int>`
    to store the `imageID` that will be added by the producer and processed through
    the consumer. We set the maximum size of the collection to 10\. Then, we added
    a `Producer` item that reads the image from a database and calls the `Add` method
    to add the `imageID` in the blocking collection, which can be further picked up
    and processed by the consumer. The consumer task just checks any available item
    in the collection and processes it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们初始化了通用的`BlockingCollection<int>`来存储由生产者添加并通过消费者处理的`imageID`。我们将集合的最大大小设置为10。然后，我们添加了一个`Producer`项，它从数据库中读取图像并调用`Add`方法将`imageID`添加到阻塞集合中，消费者可以进一步提取并处理。消费者任务只需检查集合中是否有可用项目并对其进行处理。
- en: To learn more about the data structures available for parallel programming,
    please refer to [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/data-structures-for-parallel-programming](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/data-structures-for-parallel-programming).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关并行编程可用的数据结构，请参阅[https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/data-structures-for-parallel-programming](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/data-structures-for-parallel-programming)。
- en: Parallel.ForEach
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Parallel.ForEach
- en: The `Parallel.ForEach` is a multithreaded version of the classic `foreach` loop.
    The `foreach` loop runs on a single thread, whereas the `Parallel.ForEach` runs
    on multiple threads and utilizes multiple cores of the CPU, if available.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.ForEach`是经典`foreach`循环的多线程版本。`foreach`循环在单个线程上运行，而`Parallel.ForEach`在多个线程上运行，并利用CPU的多个核心（如果可用）。'
- en: 'Here is a basic example using `Parallel.ForEach` on a list of documents that
    needs to be processed, and which contains an I/O-bound operation:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个基本示例，使用`Parallel.ForEach`处理需要处理的文档列表，并包含I/O绑定操作：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To replicate the I/O-bound operation, we just added a delay of 1 second to the
    `ManageDocument` method. If you execute the same method using the `foreach` loop,
    the difference will be obvious.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了复制I/O绑定的操作，我们只是在`ManageDocument`方法中添加了1秒的延迟。如果您使用`foreach`循环执行相同的方法，差异将是明显的。
- en: Parallel LINQ (PLINQ)
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行LINQ（PLINQ）
- en: Parallel LINQ is a version of LINQ that executes queries in parallel on multi-core
    CPUs. It contains the full set of standard LINQ query operators plus some additional
    operators for parallel operations. It is highly advisable that you use this for
    long-running tasks, although incorrect use may slow down the performance of your
    app. Parallel LINQ operates on collections such as `List`, `List<T>`, `IEnumerable`,
    `IEnumerable<T>` and so on. Under the hood, it splits the list into segments and
    runs each segment on a different processor of the CPU.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 并行LINQ是LINQ的一个版本，它在多核CPU上并行执行查询。它包含完整的标准LINQ查询操作符以及一些用于并行操作的附加操作符。强烈建议您在长时间运行的任务中使用此功能，尽管不正确的使用可能会降低应用程序的性能。并行LINQ操作集合，如`List`，`List<T>`，`IEnumerable`，`IEnumerable<T>`等。在底层，它将列表分割成段，并在CPU的不同处理器上运行每个段。
- en: 'Here is a modified version of the previous example, with `Parallel.ForEach` instead
    of the PLINQ operation:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上一个示例的修改版本，使用`Parallel.ForEach`而不是PLINQ操作：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about the core fundamentals of multithreaded
    and asynchronous programming. The chapter starts with the basic differences between
    both and walks you through some core concepts about multithreading, what APIs there are
    available, and how to write multithreading applications. We also looked at how
    the task-programming library can be used to serve asynchronous operations and
    how to implement the task asynchronous pattern. Finally, we explored parallel
    programming techniques and some of the best design patterns that are used for
    these techniques.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了多线程和异步编程的核心基础知识。本章从两者之间的基本区别开始，并介绍了一些关于多线程的核心概念，可用的API以及如何编写多线程应用程序。我们还看了任务编程库如何用于提供异步操作以及如何实现任务异步模式。最后，我们探讨了并行编程技术以及用于这些技术的一些最佳设计模式。
- en: In the next chapter, we will explore the types of data structures and their
    impact on performance, how to write optimized code, and some best practices.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨数据结构的类型及其对性能的影响，如何编写优化的代码以及一些最佳实践。

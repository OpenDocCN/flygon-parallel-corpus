- en: 3\. Managing Your Docker Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look into Docker layers and analyze how caching can
    help to speed up an image build. We will also deep dive into Docker images and
    set up Docker registries to increase the reusability of the images.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to demonstrate how Docker uses
    layers to build images and how image building can be sped up with caching. You
    will work with image tags and set up a tagging policy for Docker images. The chapter
    will enable you to utilize Docker Hub for your projects and differentiate between
    public and private registries. It will also help you to set up your own Docker
    Registry when working on your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our previous chapters have done a lot of work already with Docker images. As
    you've seen, we've been able to take existing images, provided to the general
    public in Docker Hub, and have then been able to run them or reuse them after
    building on top of them for our purposes. The image itself helps us streamline
    our processes and reduce the work we need to do.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to take a more in-depth look at images and how
    to work with them on your system. We'll learn how images can be better organized
    and tagged, understand how different layers of images work, and set up registries
    that are both public and private to further reuse the images we have created.
  prefs: []
  type: TYPE_NORMAL
- en: Docker images are perfect for application development as well. The image itself
    is a self-contained version of the application, which includes everything it needs
    in order to be run. This empowers developers to build an image on their local
    machine and deploy it on a development or test environment to ensure it works
    well with the rest of the application. If all goes well, they can then push the
    same image as a release to the production environment for users to then consume.
    We need to also be consistent when using our images, especially when we start
    to work within a larger group of developers.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will also help you set up policies to have consistent tagging for
    your services to help limit issues and make sure you can track down or roll back
    when issues arise. Understanding how to distribute images for consumption and
    collaboration is also something we will discuss further in the chapter. So, without
    further delay, let's get started with the chapter and understand what layers and
    caching in Docker are.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Layers and Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A registry is a way to store and distribute your Docker images. When you pull
    a Docker image from a registry, you might have noticed that the image is pulled
    in pieces and not as a single image. The same thing happens when you build an
    image on your system.
  prefs: []
  type: TYPE_NORMAL
- en: This is because Docker images consist of layers. When you create a new image
    using a `Dockerfile`, it will create more layers on top of the existing image
    you've built from. Each command you specify in the `Dockerfile` will create a
    new layer, with each containing all of the filesystem changes that occur before
    the command was performed and then after. When you run the image as a container
    from a `Dockerfile`, you're creating readable and writable layers on top of an
    existing group of read-only layers. This writable layer is known as the **container
    layer**.
  prefs: []
  type: TYPE_NORMAL
- en: As you'll see in the following exercises, when you build a container from a
    `Dockerfile`, the output presented shows each command run in the `Dockerfile`.
    It also shows the layers that are created by running each command, which is represented
    by a randomly generated ID. Once the image has completed building, you can then
    view the layers created during the build process using the `docker history` command,
    including the image name or ID.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When setting up your build environment and as you move further along in the
    development process, remember that the more layers you have, the larger your image
    will be. So, this extra storage and space can be expensive in both build times
    and the amount of disk space used in your development and production environments.
  prefs: []
  type: TYPE_NORMAL
- en: When building an image from a `Dockerfile`, layers are created when the `RUN`,
    `ADD`, and `COPY` commands are used. All other commands in the `Dockerfile` create
    intermediate layers. These intermediate layers are 0 B in size; therefore, they
    don't increase the size of the Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: 'When building our Docker images, we can use the `docker history` command and
    the image name or ID to see the layers used to create the image. The output will
    provide details on commands used to generate the layer as well as the size of
    the layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker image inspect` command is useful in providing further details on
    where the layers of our images are located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Later in this part of the chapter, when we look at creating our base images,
    we will use the `docker image` command, which is used in conjunction with a TAR
    file version of the image we are creating. If we are able to access a running
    container or virtual machine, we will be able to take a copy of the running system
    and place it in a TAR archive. The output of the archive is then piped out to
    the `docker import` command as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The next exercise will give you some hands-on experience of what we have learned
    so far and how to work with Docker image layers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Please use `touch` command to create files and `vim` command to work on the
    file using vim editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.01: Working with Docker Image Layers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will work with some basic `Dockerfiles` to see how Docker
    uses layers to build images. You will start by creating a `Dockerfile` and building
    a new image. You will then rebuild the image to see the advantage of using caching
    and how the build time is reduced due to its use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `Dockerfile` with your favorite text editor and add
    in the following details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the `Dockerfile` and then, from the command line, make sure you are in
    the same directory as the `Dockerfile` you have created. Use the `docker build`
    command to create the new image using the `–t` option to name it `basic-app`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If the image has built successfully, you should see an output similar to the
    following. We''ve highlighted each of the build steps in bold. Each step is built
    as an intermediate layer and if it completes successfully, it is then transferred
    to a read-only layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `docker history` command along with the image name of `basic-app` to
    see the different layers of the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The history gives you creation details, including the size of each layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `docker history` command shows the layer of the original image used as part
    of the `Dockerfile` `FROM` command as `<missing>`. It is showing as `missing`
    in our output as it was created on a different system and then pulled onto your
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the build again without making any changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show you the build is done using the layers stored in the Docker
    image cache, thereby speeding up our build. Although this is only a small image,
    a much larger image would show a significant increase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Say you forgot to install the `curl` package as part of your image creation.
    Add the following line to the `Dockerfile` from *Step 1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the image again, and you''ll now see the image created with a mix of
    cached layers and new layers that need to be created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Step three of the output has been highlighted to show the change made in our
    `Dockerfile` now being built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `docker images` command again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You will now notice the image named and tagged as `<none>` to show we have
    now created a dangling image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Dangling images, represented by `<none>` in our image list, are caused when
    a layer has no relationship to any image on our system. These dangling images
    no longer serve a purpose and will consume disk space on your system. Our example
    dangling image is only 7.48 MB, which is small, but this could add up over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `docker image inspect` command using the image ID to see the location
    of where the dangling images are located on our system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output has been reduced from the actual output to only show the
    directories of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: All of our images are located in the same location as the dangling image. As
    they are sharing the same directory, any dangling images would waste space on
    our system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `du` command from the command line to see the total disk space being
    used by our images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The command will return the total disk space used by your images
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you're using Docker Desktop, maybe on a Mac, you'll notice that you won't
    be able to see the images as Docker is run on a virtual image on your system,
    even though the `docker image inspect` command will show the same location as
    we have above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `docker images` command again using the `-a` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It will also show the intermediate layers used when our image is being built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `docker image prune` command to remove all the dangling images. You
    could remove all the dangling images one at a time using the `docker rmi` command
    using the image ID, but the `docker image prune` command is an easier way to do
    that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `docker images` command again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see we no longer have the dangling image in our list of images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `du` command again over the image''s directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You should also observe a small decrease in size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This exercise has shown only smaller image sizes, but this is definitely something
    to keep in mind when running production and development environments. This part
    of the chapter has provided you with the foundations of how Docker uses layers
    and caching as part of its build process.
  prefs: []
  type: TYPE_NORMAL
- en: For our next exercise, we will look further at our layers and caching to see
    how they can be used to speed up the image build process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.02: Increasing Build Speed and Reducing Layers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have been working with smaller builds so far. However, as your applications
    increase in size and functionality, you''ll start to consider both the size and
    number of layers of the Docker images you''re creating and the speed at which
    you''re creating them. The goal of this exercise is to speed up the build times
    and reduce the size of your images, as well as use the `--cache-from` option when
    building your Docker images:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `Dockerfile` to demonstrate the change you are going to make,
    but first, clear up all the images on your system. Run the `docker rmi` command
    with the `-f` option to force any removals needed, and the command in brackets
    will provide a list of all image IDs on your system. Use the `-a` option to show
    all running and stopped containers and the `-q` option to only show the container
    image hash value and nothing else:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The command should return output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be observed that the `hello-world: latest` image is untagged and the
    image with ID `sha256:d74fa92b37b74820ccccea601 de61d45ccb3770255b9c7dd22edf16caabafc1c`
    is removed.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Please note that we can remove the images using both the `rmi` and `prune` commands.
    Here, we have used the `rmi` command because `prune` was not always available
    until recently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your `Dockerfile` (which you created in *Exercise
    3.01*). It will simulate a simple web server, as well as print the output of our
    `Dockerfile` during the build process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice *line 6* of the `Dockerfile` is doing a fairly menial task (downloading
    a 100 MB file, named `100MB.bin`), which would not normally be performed in a
    `Dockerfile`. We have added it in to represent a build task or something similar
    that may be added during your build process, for example, downloading content
    or building software from a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download your base image using the `docker pull` command so that you can start
    with the same image for each test we do:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a TAR file to be added to our image as we have instructed in *line 13*
    of our `Dockerfile`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Build a new image using the same name as `basic-app.` You will use the `time`
    command at the start of the code to allow us to gauge the time it takes to build
    our image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will return the time taken to build the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `docker history` command over the new `basic-app` image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a few extra commands in our `Dockerfile` compared to the previous exercise.
    So, there should be no surprise that we will see 12 layers in our new image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `RUN`, `COPY`, and `ADD` commands in our `Dockerfile` are
    creating layers of a particular size relevant to the commands being run or files
    being added, and all the other commands in the `Dockerfile` are of size 0 B.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reduce the number of layers in the image by combining the `RUN` commands in
    *lines 3 and 4* and combining the `CMD` commands in *lines 8 and 9* of the `Dockerfile`
    created in *step 1* of this exercise. With these changes, our `Dockerfile` should
    now look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Running `docker build` again will reduce the number of layers for our new image
    from 12 to 9 layers, as even though there is the same number of commands being
    run, they are chained together in *lines 3* and *7*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Lines 11*, *12*, and *13* of our `Dockerfile` are using the `COPY` and `RUN`
    commands to `copy` and `unzip` our archived file, and then remove the original
    unzipped file. Replace these lines with the `ADD` command without needing to run
    the lines that unzip and remove the `.tar` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Build the image again to reduce the number of layers in your new image from
    9 to 8\. If you have been watching the builds run, you will probably notice a
    lot of the time the build run as part of *lines 3* and *5* of our `Dockerfile`,
    where we run `apk update`, then install `wget` and `curl`, and then grab content
    from a website. Doing this once or twice will not be an issue, but if we create
    our base image, which the `Dockerfile` can then run on, you will be able to remove
    these lines completely from your `Dockerfile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Move into a new directory and create a new `Dockerfile` that will only pull
    the base image and run the `apk` commands, as listed here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the new base image from the preceding `Dockerfile` and name it `basic-base`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove *line 3* from the original `Dockerfile` as it will no longer be needed.
    Move into the project directory and update the image that is being used in the
    `FROM` command to `basic-base` and remove the `apk` commands in *line 3*. Our
    `Dockerfile` should now look like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the build again for our new `Dockerfile`. Using the `time` command again
    with our build, we now see the build complete in just over 1 second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''ve been watching the build, you''ll notice that compared to our previous
    builds, it runs a lot quicker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You will observe that the layers of the image will remain the same as we are
    building the base image on our system, which performs the `apk` commands. It's
    a great result still to speed up the build even though we are not reducing the
    number of layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a different way we can use the `basic-base` image we used earlier.
    Use the `docker build` command with the `–cache-from` option to specify the cache
    layers that will be used when the image is built. Set out the `FROM` command to
    still use the `alpine` image and use the `–cache-from` option that follows to
    make sure the layers used to build `basic-base` are being used for our current
    image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We still have some more tasks before we complete this exercise. In the following
    steps, we will look at committing changes to our image to see how it affects our
    layers. This is not something we would use often but there are times when we need
    to copy production data over to a development or test environment, and one way
    to do this is by using a Docker image with the `commit` command, which will make
    changes to the top writable layer of our running container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `basic-app` in interactive shell mode to create some production data. To
    do this, run the following `docker run` command with the `-it` option to run in
    interactive mode and use the `sh` shell to access the running container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the vi text editor to create a new text file called `prod_test_data.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following line of text as some test data. The data in the text is not
    important; it is just a sample to show we can then copy these changes to another
    image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is a sample production piece of data. Exit out of the running container
    and then check the container ID using the `docker ps` command with the `-a` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `docker commit` command with the container ID to create a new image
    that will include all those changes. Make sure to add the name of the new image.
    In this example, use `basic-app-test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `docker history` command on the newly created image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This should now show us an extra layer where we added the sample production
    data, showing in our output as 72B in size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the newly created `basic-app-test` image and `cat`, the new file we
    added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This should show us the output we added, showing we can reuse existing images
    if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As of the time of writing, the `docker build` command also allows a new experimental
    feature using the `–squash` option. The option attempts to merge all the layers
    into one layer during build time. We haven't covered this feature as it is still
    in an experimental phase.
  prefs: []
  type: TYPE_NORMAL
- en: This exercise demonstrated how the build cache and image layers work to improve
    the build time. We have started all our builds so far using an image we have pulled
    down from Docker Hub, but there are options to start with an image you have created
    yourself if you wish to control things even further. The next section will help
    you to create your base Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Base Docker Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating your base Docker image is actually straightforward. Just as we used
    the `docker commit` command previously to create an image from a running container,
    we can also create an image from a system or server we have originally been running
    our applications on. We need to remember that creating a base image still needs
    to remain small and lightweight. It is not simply a matter of moving existing
    applications running on existing servers over to Docker.
  prefs: []
  type: TYPE_NORMAL
- en: We could use the system we are specifically working on, but if you are using
    a production server, the image could actually be pretty big. If you have a small
    virtual machine you would think is perfect for a base image, you could use the
    following steps to create a base image from it. Similar to the `docker commit`
    command, this can be used for any system you can access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.03: Creating Your Base Docker Images'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following exercise will use the `basic-app` image we are currently running
    and show how easy it is to create a base image. These same steps would be used
    for larger, more complex environments as well:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the `docker run` command to run the container and log in at the same
    time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `tar` command on the running container to create a backup of the system.
    To limit the information you have in the new image, exclude the `.proc`, `.tmp`,
    `.mnt`, `.dev`, and `.sys` directories, and create everything under the `basebackup.tar.gz`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure that you have data in your `basebackup.tar.gz` file, run the `du`
    command to make sure it is of substantial size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The output returns the size of the `basebackup.tar.gz` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `docker ps` command to find the container ID that is currently holding
    your new backup file, the `.tar` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will return the container ID of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the `.tar` file onto your development system with the `docker cp` command,
    using the container ID of our running container and the location and file you
    want to copy. The following command will do this with your container ID and move
    it into your `/tmp` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new image using the `docker import` command. Simply pipe the output
    of the `basebackup.tar.gz` file into the `docker import` command, naming the new
    image in the process. In our example, call it `mynew-base`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `docker images` command with the name of your new image to verify that
    it has been created in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `docker history` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that we only have one layer in our new image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'To test your new image, run the `docker run` command on the new image, and
    list the files in your `/var/www/html/` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The command should return the similar output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: It can be seen that the image has been successfully created and there are 24
    files in the `/var/www/html/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: This exercise has shown you how to create a base image from a running system
    or environment, but if you're wanting to create a small base image, then the next
    section will show you how to use the **scratch** image.
  prefs: []
  type: TYPE_NORMAL
- en: The Scratch Image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The scratch image is an image created by Docker specifically available for building
    minimal images. If you have a binary application, written in Java, C++, and so
    on, as well as compiled, that can be run by itself without any supporting applications,
    then scratch will help you run that image with one of the smallest images you
    can create.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `FROM scratch` command in our `Dockerfile`, we are specifying
    that we will be using Docker's reserved minimal image, which is named `scratch`
    for building our new container image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.04: Using the Scratch Image'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a small C application to run on the image.
    You don''t really need to know anything about the C language to complete this
    exercise. The application will be installed on your scratch base image to ensure
    the image is as small as possible. The application you create will show you how
    to create one of the most minimal base images available:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pull the scratch image using the `docker pull` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice you won''t be able to pull the image and will receive an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a C program that you will build into the image to use in our `Dockerfile`.
    Create a program file called `test.c`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the file and add in the following code, which will simply count from 1
    to 10 on the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the image from the command line by running the following command to build
    the C program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you want to test it before you build it in your image, you can do so by running
    `./test` on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `Dockerfile`. The `Dockerfile` will be pretty minimal but needs
    to start with `FROM scratch`. The rest of the file will add the C program to your
    image and then run it in *line 4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Build a new image. In this instance, call the image `scratchtest` using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the image from the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the output of the test C file you created and compiled earlier
    in this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `docker images` command for your new image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show you some pretty impressive results as your image is only `913
    kB` in size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'View the layers of the image using the `docker history` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see a similar output to the following one and it has only two layers,
    the original layer from scratch and the layer where we `ADD` the test C program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The scratch image we've created in this exercise goes part of the way to creating
    an image that is both functional and minimal, and also demonstrates that if you
    think a little about what you are trying to achieve, it will be easy to speed
    up your builds and reduce the size of your images.
  prefs: []
  type: TYPE_NORMAL
- en: We will now take a break from working with building images and take a closer
    look at naming and tagging our Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Image Naming and Tagging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've touched on tags, but as we work more closely with Docker images, it's
    probably a good time to look at image tags in more depth. In simple terms, a tag
    is a label on the Docker image and should provide the user of the image with some
    useful information about the image or version of the image they are using.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we've been working with our images as if we're solo developers, but
    when we start to work with a larger development team, a need arises to think a
    little harder about how we'll be naming and tagging our images. The following
    section of the chapter will add to your previous work and allow you to start putting
    together a naming and tagging strategy for your projects and work.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main methods for naming and tagging your Docker images. You can
    use the `docker tag` command, or you can use the `-t` option when you build your
    image from a `Dockerfile`. To use the `docker tag` command, you specify the source
    repository name you will be using as the base and the target name and tag you
    will be creating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'When you name your image using the `docker build` command, the `Dockerfile`
    used will create your source, and then use the `-t` option to name and tag your
    images as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The repository name can sometimes be prefixed with a hostname, but this is
    optional and will be used to let Docker know where the repository is located.
    We''ll demonstrate this later in this chapter when we create our own Docker Registry.
    If you''re pushing your images to Docker Hub, you also need to prefix your repository
    name with your Docker Hub username, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Using more than two prefixes in your image name is only supported in local image
    registries and is generally not used. The next exercise will guide you through
    the process of tagging Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.05: Tagging Docker Images'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following exercise, you will work with a different image, using the
    lightweight `busybox` image to demonstrate the process of tagging and start to
    implement tags in your project. BusyBox is used to combine tiny versions of many
    common UNIX utilities into a single small executable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `docker rmi` command to clear up the images you currently have on your
    system, so you don''t get confused with a large number of images around:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'On the command line, run the `docker pull` command to download the latest `busybox`
    container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `docker images` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the information we need to start putting some tag commands
    together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Name and tag the image using the `tag` command. You can either use the image
    ID or repository name to tag the images. Start by using the image ID, but note
    that on your system you''ll have a different image ID. Name the repository `new_busybox`
    and include the tag `ver_1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the repository name and image tag. Create a new repository using your name
    and tag with a new version of `ver_1.1` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We have used the author's name (`vince`) in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `docker images` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a similar output to the one that follows. Of course, your image
    IDs will be different, but the repository names and tags should be similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a basic image using a `Dockerfile` and the `-t` option of the `docker
    build` command to name and tag the image. You''ve done this a few times already
    in this chapter, so from the command line, run the following command to create
    a basic `Dockerfile`, using the `new_busybox` image you named earlier. Also include
    the tag for the image name, as Docker will try to use the `latest` tag and, as
    this does not exist, it will fail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `docker build` command to create the image while naming and tagging
    it at the same time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `docker images` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now have four images available on your system. All have the same
    container ID but will have different repository names and tagged versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Tagging images with a proper version that is relevant to your organization or
    team does not take too much time, especially with a little practice. This section
    of the chapter has shown you how to tag your images so they are no longer tagged
    with the default tag of the `latest`. You will see in the next section that using
    the `latest` tag and hoping it will work correctly could actually cause you some
    extra issues.
  prefs: []
  type: TYPE_NORMAL
- en: Using the latest Tag in Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've been working with our tags, we've mentioned a few times not to use
    the `latest` tag, which is provided by Docker as a default tag. As you will see
    shortly, using the `latest` tag can cause a lot of issues, especially if you're
    deploying images into production environments.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to realize is that `latest` is simply a tag, just as
    we were using `ver_1` in our previous example. It definitely does not mean the
    latest version of our code either. It simply means the most recent build of our
    image, which did not include a tag.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `latest` will also cause a lot of issues in large teams, deploying
    to environments multiple times a day. It also means you will have no history,
    which makes rolling back bad changes difficult. So, remember that every time you
    build or pull an image if you don't specify a tag, Docker will use the `latest`
    tag and will not do anything to ensure the image is the most up-to-date version.
    In the next exercise, we will check what issues can be caused when using the `latest`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.06: Issues When Using latest'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may still be new to both using Docker and using tags, so you may not have
    experienced any issues using the `latest` tag as yet. This exercise will give
    you some clear ideas on how using the `latest` tag could cause problems with your
    development process and provide you with reasons as to why you should avoid it.
    You created a simple `Dockerfile` in the previous exercise using the `new_busybox:ver_1`
    image. In this exercise, you will extend this file further:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Dockerfile` and amend the file to now look like the following file.
    It is a simple script that will create the `version.sh` script with simple code
    to output the latest version of our service. The new file will be called `Dockerfile_ver1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the image and name it with your name and show the image is just a test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We have used `vince` as the name here, but you can use any desirable name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the image using the `docker run` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the output of the `versions.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `docker tag` command to tag this image as `version1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `Dockerfile` and make the following change to *line 4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Build your amended `Dockerfile` and tag it with `version2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the amended image using the `docker run` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see your latest code changes as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: This isn't the version we were looking for, was it? Without using the correct
    tag, Docker will run what is the most recent version of the image that was tagged
    with the `latest`. This image was created in *step 3*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run both images with the `latest` and `version2` tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now see the difference in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: As you may have already thought, you need to specify the `version2` tag to run
    the amended version of the code. You may have seen this coming but remember this
    is going to make things more difficult to keep track of if you have multiple developers
    pushing images to a shared registry. If your team is using orchestration and using
    the `latest` version, you may end up with mixed versions of your services running
    across your production environment.
  prefs: []
  type: TYPE_NORMAL
- en: These exercises have given you examples on how to use tags as well as showing
    you what the consequences could be if you decide to only use the `latest` tag.
    The following section will introduce tagging policies and how to implement automated
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Image Tagging Policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As development teams increase in size and the projects they work on increase
    in complexity, a standardized tagging policy for your team becomes even more important.
    If your team is not getting its tagging correct, as we've demonstrated in our
    previous sections, this can cause a lot of confusion and actually cause more issues.
    It's a good habit to decide on a tagging policy early to make sure you don't run
    into any of these issues.
  prefs: []
  type: TYPE_NORMAL
- en: In this section of the chapter, we are going to cover some of the different
    tagging policies you could use within your team with some examples on how they
    can also be implemented. There are rarely any right or wrong answers when it comes
    to setting up your tagging policy, but it is necessary to make a decision early
    and ensure everyone in the team is in agreement.
  prefs: []
  type: TYPE_NORMAL
- en: '**Semantic versioning** is a versioning system that can also be used as part
    of your tagging policy. If you''re not familiar with semantic versioning, it is
    a trusted version system that uses a three-component number in the format of `major_version.minor_version.patch`.
    For example, if you saw the semantic version of an application as 2.1.0, it would
    show version 2 as the major release version, 1 as the minor release version, and
    0 as there are no patches. Semantic versioning can be easily automated, especially
    in an automated build environment. Another option is to use a hash value, like
    the `git commit` hash for your code. This means you can match the tag back to
    your repository, so anyone can see specifically the code changes that have been
    made since the code was implemented. You could also use a date value, which can
    once again be easily automated.'
  prefs: []
  type: TYPE_NORMAL
- en: The common theme here is that our tagging policy should be automated to ensure
    it is used, understood, and adhered to. In the following exercise, we are going
    to look at using hash values as part of your tagging policy and we will then create
    a script to build our Docker images and add semantic versioning to our tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.07: Automating Your Image Tagging'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you are going to look at automating your image tagging to
    limit the amount of individual intervention needed in tagging your Docker images.
    This exercise uses the `basic-base` image again:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `basic-base` image again by creating the following `Dockerfile`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the new base image from the preceding `Dockerfile` and name it `basic-base`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `basic-base` image created, set up the `Dockerfile` named `Dockerfile_ver1`
    to build a `basic-app` again. In this instance, return to the previous `Dockerfile`
    as listed here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''ve been using Git to track and commit the changes in your code, you
    can tag your images with the commit hash from Git using the `git log` command.
    So, build your new image, as you normally would, with the `docker build` command,
    but in this instance, add the tag to provide the short commit hash from `git`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are new to using Git, it is a source control application that allows
    you to track your changes and collaborate with other users on different coding
    projects. If you have never used Git before, the following commands will initialize
    your repository, add the `Dockerfile` to the repository, and commit these changes,
    so we have a Git log present:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git init; git add Dockerfile; git commit –m "initial commit"`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your `Dockerfile` to add arguments when your image is being built. Open
    the `Dockerfile` you''ve been using for your `basic-app` and add in the following
    two lines to set variables as unknown, and then set `LABEL` as the value offered
    at build time, using the `git-commit` build argument. Your `Dockerfile` should
    now appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the image again using the `--build-arg` option with the `GIT_COMMIT`
    argument, which is now equal to your `git commit` hash value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `docker inspect` command searching for the `"git-commit"` label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the Git hash label you added at build time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: This is starting to move in the direction you need, but what if you need to
    use semantic versioning as your team has decided this is the best option for your
    development? The rest of this exercise will set up a build script to both build
    and set the tag as the semantic version number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alongside your `Dockerfile`, create a version file simply named `VERSION`.
    Set the new version as `1.0.0` for this build of `basic-app`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Make changes to the `Dockerfile` to remove the `GIT_COMMIT` details added previously
    and add the `VERSION` file as part of your build. Adding it into the image itself
    means users can always refer to the `VERSION` file if ever they need to verify
    the image version number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a build script to both build and tag your image. Call this `build.sh`
    and it will reside in the same directory as your `Dockerfile` and `VERSION` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following details to `build.sh`. *Line 3* will be your Docker Hub username,
    and *line 4* is the name of the image or service you are building (in the following
    example, `basic-app`). The script then grabs the version number from your `VERSION`
    file and brings all your variables together to build your image with a nice name
    and tag relevant to your new semantic version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure the build script is set to run as an executable script using the
    `chmod` command on the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the build script from the command line. `set -xe` in *line 1* of the script
    will make sure all commands are output to the console and ensure that if any of
    the commands cause an error, the script will stop. Run the build script now, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Only the output of the build script is shown here as the rest of the build
    process happens as normal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'View the image using the `docker images` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'It should reflect the name and tags created as part of the build script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: This exercise goes a long way in automating our tagging process, and it allows
    the `build` script to be added to source control and run easily as part of a build
    pipeline. It is just a start though, and you will see in the activities at the
    end of the chapter that we will extend this build script further. For now, we
    have completed this section on the tagging and naming of our images, and it fits
    in nicely with the next section, which covers storing and publishing your Docker
    images.
  prefs: []
  type: TYPE_NORMAL
- en: Storing and Publishing Your Docker Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the early days of Docker's history, one of its main attractions has been
    a central website where users can download images, reuse and improve these images
    for their purposes, and reupload them to grant access to other users. Docker Hub
    has grown and although it has had some security issues, it is still usually the
    first place people will look when they need new images or resources for their
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: As a public repository, Docker Hub is still one of the first places people go
    to research and use images needed to streamline or improve their new development
    project. It is also an important place for companies and developers to host their
    open-source images, available for the public to utilize. However, Docker Hub is
    not the only solution for you to store and distribute your Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: For development teams, a public repository on Docker Hub, although accessible
    and highly available, may not be the best option. These days, your team may look
    to store production images in a cloud-based registry solution such as Amazon Elastic
    Container Registry, Google Container Registry, or, as you'll see later in this
    chapter, another option would be to set up a local registry.
  prefs: []
  type: TYPE_NORMAL
- en: In this part of the chapter, we'll start by seeing how you can actually move
    images from machine to machine and then take a closer look at using Docker Hub.
    We'll see how to start moving our images across to Docker Hub as a publicly stored
    image. We will then look at setting up a locally hosted Docker registry on your
    development system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker save` command will be used to save the images from the command
    line. Here, we use the `-o` option to specify the output file and directory we
    are going to save our image to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then be able to use the `load` command similar to the `import` command
    when we created a new base image earlier in the chapter, specifying the file we
    created previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that not all images on Docker Hub should be treated the same way,
    as it comes with a mixture of both official images that have been created by Docker
    Inc. and community images created by Docker users. Official images are still open
    source images and solutions available for you to add to your projects. Community
    images are offered usually by companies or individuals wanting you to leverage
    their technology.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Use caution when sourcing images, even from Docker Hub. Try to limit pulling
    images from sources that are not reputable and have not been reviewed or downloaded
    by a large number of users as they could pose a potential security risk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.08: Transporting Docker Images Manually'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, whether there are issues with firewalls or other security measures
    on your network, you may need to copy an image directly from one system to another.
    Fortunately, Docker has a way of achieving this and, in this exercise, you will
    move an image from one system to another without using a registry:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `docker save` command with the `-o` option to save the image you created
    in the last part of this chapter. The command needs the user to specify both the
    filename and the directory. In the following example, it is `/tmp/basic-app.tar`.
    Also specify the user, image name, and tag of the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: You should now see the packaged-up image in the `/tmp` directory. You are using
    `.tar` as the extension of your filename as the `save` command creates a TAR file
    of the image. You could actually use any name for the extension of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `du` command to verify that the `basic-app.tar` file has data in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now move the image as you need to, whether it be via `rsync`, `scp`,
    or `cp`. As it is a TAR file, you could also compress the file as a ZIP file if
    you need to save some space during the transfer. In this example, you will simply
    delete the image from your current system. Run the `docker rmi` command with the
    ID of the image you have just saved:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the new image back as a Docker image using the `docker load` command with
    the `-i` option, pointing to where the packaged image is located. In this case,
    it is the `/tmp` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `docker image` command to bring up the image you have just loaded into
    your local environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: This was just a simple exercise, but it hopefully served to show you that if
    there is ever a situation where you are unable to connect to a registry, you are
    still able to transport your Docker images. The next exercises are more focused
    on the usual methods of storing, publishing, and distributing your Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Storing and Deleting Docker Images in Docker Hub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although you can work with Docker Hub without paying any money, you need to
    know you will only get one private repository free of charge on your account.
    If you want more, you'll need to pay for a monthly plan on Docker. If Docker Hub
    is the solution your team has chosen to use, you will rarely need only one private
    repository. If you decide a free account is for you, then you get an unlimited
    number of free repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.09: Storing Docker Images in Docker Hub and Deleting the Repository'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a new repository for the `basic-app` that
    you''ve been working on and store the images in Docker Hub. Once you have pushed
    the images in Docker Hub, you will also look at how you can delete the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The following exercise will need you to have your account on Docker Hub. We
    will only be using free repositories, so you will not need to be on a paid monthly
    plan, but if you haven't signed up for a free account on Docker Hub, go to [https://hub.docker.com/signup](https://hub.docker.com/signup).
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to your Docker Hub account and, under the `Repositories` section, you''ll
    have the option `Create Repository` as a blue button on the right of the screen.
    Click this button so that you can set up a repository for the `basic-app` you
    have been working on:![Figure 3.1: Creating a repository in Docker Hub'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15021_03_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.1: Creating a repository in Docker Hub'
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating a new repository, you''ll be presented with a page like the one
    that follows. Fill in the `Name` of the repository, which is usually the name
    of the image or service you are storing (in this case, `basic-app`). You also
    have the option to set the repository as `Public` or `Private`, and in this instance,
    select `Public`:![Figure 3.2: Repository creation screen of Docker Hub'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15021_03_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.2: Repository creation screen of Docker Hub'
  prefs: []
  type: TYPE_NORMAL
- en: 'Toward the bottom on the screen, there are also options to build your images.
    Click the `Create` button at the bottom of the screen:![Figure 3.3: Repository
    creation screen of Docker Hub'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15021_03_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.3: Repository creation screen of Docker Hub'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your new repository is created, it will provide details on how to start
    pushing your images to your new repository. Tag your image with `<account_name>/<image_name>:tag`
    to let Docker know where it will be pushing the image and which repository Docker
    will be pushing it to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, Docker on your system knows where to push the image. Push the image using
    the `docker push <account_name>/<image_name>:tag` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: You need to make sure you are logged in to Docker Hub from the command line
    as well as the web interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `docker login` command and enter the same credentials you were using
    when you logged in to create the new repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, push your image to your new repository, as you did in *step 5* of this
    exercise, which previously failed. It should give you a successful result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Move back to the Docker Hub web interface and you should now see the image
    version you have pushed, sitting in your newly created repository:![Figure 3.4:
    Your newly created Docker Hub repository with image'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15021_03_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.4: Your newly created Docker Hub repository with image'
  prefs: []
  type: TYPE_NORMAL
- en: You now have a public repository available for anyone wanting to pull your image
    down and reuse it for their purposes. If someone needed to use your image, they
    would simply use the full name of the image, including tags with the `docker pull`
    command or `FROM` command in a `Dockerfile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll notice in the preceding image that, on the right-hand side of the screen,
    there is the `Public View` button. This gives you an option to see specifically
    what the public will see when they search for your image. Click the button and
    you should see a similar screen to the following:![Figure 3.5: The public view
    of your Docker Hub repository'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15021_03_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.5: The public view of your Docker Hub repository'
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly what the public will see of your repository. It's now up to
    you to make sure you have the overview up to date and ensure your image is supported
    to make sure there are no problems with anyone wanting to use your image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, for this exercise, clean up the repository you''ve just created. If
    you are not still in the web interface of your repository, move back onto the
    Docker Hub web page and click the `Settings` tab at the top of the screen:![Figure
    3.6: The Settings screen of the Docker Hub repository'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15021_03_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.6: The Settings screen of the Docker Hub repository'
  prefs: []
  type: TYPE_NORMAL
- en: Here you will have the option to make your repository private, but in this exercise,
    you will delete the repository. Click the `Delete Repository` option and confirm
    you now want to delete it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As demonstrated in this exercise, Docker Hub provides you with an easy way to
    distribute images to allow other users to collaborate or utilize the work you've
    already done. A public repository is not always the best option for an enterprise,
    but just as GitHub has allowed developers to distribute their code and collaborate
    with other developers, Docker Hub can do the same for your Docker Images.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker Registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker Registry is a service that hosts your images. Most of the time, registries
    are private and only available for the team that has access to them. There are
    a lot of great options available and one of those options is the registry image
    made available and maintained by Docker.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few different reasons why you would want to be running your own
    Docker registry. It could be due to security issues, or you don't want your latest
    work publicly available. It could even be the simple convenience of having your
    registry running on the system you're working on. In this part of the chapter,
    we'll set up a registry on your working environment and start storing your images
    on the registry.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker simplifies things for us as they have a registry image available on
    Docker Hub to download and use for your projects. For more information on the
    image we will be using, you can find it at the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://hub.docker.com/_/registry](https://hub.docker.com/_/registry).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.10: Creating a Local Docker Registry'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will set up a Docker registry for your images and run
    them on your system. You are not going to set up a registry available to your
    team, or the outside world. You will set up a nice domain to use on your systems
    that reflect the work you are doing. This will help you decide whether to then
    have this registry available to your team or other users:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up your domain, add a domain for your local registry to your system
    hosts file. On a Windows system, you will need to access the hosts file at `C:\Windows\System32\drivers\etc\hosts`,
    while on a Linux or Max, it will be `/etc/hosts`. Open the `hosts` file and add
    the following line to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: This will allow you to use the `dev.docker.local` domain instead of using localhost
    for your local registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pull the latest `registry` image down from Docker Hub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to run the registry container. Provide the ports
    you can access the registry with; in this case, use port `5000`. You also need
    to use the `--restart=always` option, which will make sure the container restarts
    if Docker or your system needs to restart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following chapters, you will learn how to extend the file capacity of
    your Docker container by mounting a directory from your host system that will
    then run as part of your running container. To do this, you will use the `-v`
    or `--volume` option as part of your `docker run` command, providing the file
    and the mount point on the container. For example, you could run the preceding
    command to mount a directory on your host system as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker run -d -p 5000:5000 --restart=always --volume <directory_name>:/var/lib/registry:rw
    --name registry`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `docker ps` command to show the `registry` container running on your
    system, which is ready to accept and store new images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will return the output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Run the `docker tag` command to tag your existing images with the registry hostname
    and port `dev.docker.local:5000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'This will ensure that your `basic-app` image will be automatically pushed to
    the local registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the original images from the system you are currently working on using
    the `docker image remove` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, pull down the image from your local registry by including the registry
    hostname and port `dev.docker.local:5000` as part of the `pull` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: This brings us to the end of this section where we have created our registry
    to store our Docker images on our local system. The registry itself is simple
    and is not really supported but does go a long way to help you understand how
    a registry will work and how it can work with your team. If you are looking for
    a more robust and supported image, Docker also provides Docker Trusted Registry,
    which is a commercial offering by Docker.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to test the knowledge acquired so far. In the next activity, we will
    modify the build script for the `PostgreSQL` container image to use the Git commit
    hash instead of semantic versioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 3.01: Build Scripts Using Git Hash Versioning'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in the chapter, you created a build script that automated the tagging
    and versioning process of your images being built. In this activity, you will
    work further with the Panoramic Trekking app and will be tasked with setting up
    a build script for the `PostgreSQL` container image. You can use the previous
    build script you created earlier, but you will need to modify the script to no
    longer use semantic versioning and instead use the current Git commit hash. Also,
    make sure that your build script pushed the built image onto your Docker registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps required for completion are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure you have a running `Dockerfile` created for your `PostgreSQL` container
    image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create your build script, which performs the following actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Sets the variables for your Docker registry, the service name being built,
    and the Git hash version
  prefs: []
  type: TYPE_NORMAL
- en: b) Prints the Git hash version to the screen
  prefs: []
  type: TYPE_NORMAL
- en: c) Builds your PostgreSQL Docker images
  prefs: []
  type: TYPE_NORMAL
- en: d) Pushes your Docker image to your registry
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the build script runs and completes successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expected Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15021_Solution_Final_SMP.xhtml#_idTextAnchor323).
  prefs: []
  type: TYPE_NORMAL
- en: In the next activity, you will configure your local Docker registry storage
    by changing the `docker run` command to store it in a directory on your home directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 3.02: Configuring Your Local Docker Registry Storage'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During this chapter, you set up your registry and began using basic options
    to get it running. The registry itself is storing images on the host filesystem.
    In this activity, you want to change the `docker run` command to store it in a
    directory on your home directory. You will create a directory called `test_registry`
    and run the Docker command to store images in this `test_registry` directory in
    your home directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps required for completion are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory within your home directory to mount your local registry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the local registry. This time mount the newly created volume as part of
    the registry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test your changes by pushing a new image to the local registry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hint
  prefs: []
  type: TYPE_NORMAL
- en: Use the `-v` or `–volume` option when you run your registry container.
  prefs: []
  type: TYPE_NORMAL
- en: '**Expected Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'While listing all the files in the local directory, you will be able to see
    the pushed images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15021_Solution_Final_SMP.xhtml#_idTextAnchor324).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter demonstrated how Docker allows users to work with images to package
    their applications together with a working environment to be moved across different
    working environments. You've seen how Docker uses layers and caching to improve
    build speed and ensure you can also work with these layers to reserve resources
    or disk space.
  prefs: []
  type: TYPE_NORMAL
- en: We also spent some time creating a base image with only one layer of our image.
    We've explored tagging and tagging practices you can adopt in order to counter
    issues associated with deploying and publishing your images. We also took a look
    at different ways we can publish our images and share them with other users and
    developers. We are only just getting started and still have a long way to go.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be working further with our `Dockerfiles` to learn
    how multistage `Dockerfiles` work. We'll also find more ways in which we can optimize
    our Docker images for better performance when they're released into a production
    environment.
  prefs: []
  type: TYPE_NORMAL

- en: 11\. Docker Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will give you the information you need to make sure your
    containers are secure and do not pose a security risk to the people using the
    applications running on them. You will work with privileged and non-privileged
    containers and learn why you should not be running your containers under the root
    user. This chapter will help you verify whether images are from a trusted source,
    using a signing key. You will also set up a security scan for your Docker images,
    ensuring your images are safe for use and distribution. You will work with AppArmor
    to further secure your containers by using them and Security Computing Mode (`seccomp`)
    for Linux to create and use `seccomp` profiles with your Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter tries to tackle a subject that could have an entire book dedicated
    to it. We attempt to go part of the way in educating you on how to approach security
    with Docker. Previous chapters have given you a solid foundation in using Docker
    to build your applications, and this chapter hopes to use that information to
    also provide secure and stable containers for them to run on.
  prefs: []
  type: TYPE_NORMAL
- en: Docker and the microservices architecture allow us to start with a more secure
    and robust environment to manage our services, but that doesn't mean we need to
    completely forget about security. This chapter provides details on some of the
    aspects we need to consider when we are creating and maintaining services across
    our environments, as well as the ways in which you can start to implement these
    procedures in your working systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker security should not be separated from your regular IT security process,
    as the concepts will be the same. Docker has a different approach to handle these
    concepts, but in general, a great place to start with Docker security is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access control**: Make sure that running containers cannot be accessed by
    an attacker and that privileges are also limited.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Updated and patched OS**: We need to make sure we are using trusted sources
    for our images. We also need to be able to scan our images to make sure any introduced
    applications are not also introducing extra vulnerabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data sensitivity**: All sensitive information should remain inaccessible.
    This could be passwords, personal information, or any other data you don''t want
    to be made available to anyone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will cover a lot of information that will encompass the
    preceding points and more. We will start by considering the different access your
    Docker containers might have when running and how you can start to limit what
    can be performed by them. We will then look more closely at securing images, using
    signing keys, and how we can verify that they are from a trusted source. We will
    also practice scanning your images against known vulnerabilities to ensure that
    they are safe for use. The last two sections of this chapter will focus on using
    both the AppArmor and `seccomp` security profiles to further limit the capabilities
    and access your running containers can have.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When using secrets and passwords in your Docker images, orchestration methods
    such as Swarm and Kubernetes offer secure ways to store your secrets without needing
    to store them as plaintext configurations for everyone to access. If you are not
    using one of these orchestration methods, we will also provide some ideas on how
    to use secrets in your images in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Privileged and Root User Access in Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One important way to improve the security of your containers is to reduce what
    an attacker can do if they manage to gain access. The types of command the attacker
    can run on the container are limited to the level of access the user who is running
    the processes on the container has. So, if there are no root or elevated privileges
    on the running container, this limits what the attacker can do. Another thing
    to remember is that if a container is compromised and is running as the root user,
    this may also allow the attacker to escape the container and access the host system
    running Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Most processes running on the container are applications that don't need root
    access, and this is the same as running processes on a server, where you would
    not run them as root either. The applications running on the container should
    only have access to what they need. The reason why root access is provided, especially
    in base images, is because applications need to be installed on the container,
    but this should only be a temporary measure, with your complete image running
    as another user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, when creating our image, we can set up a Dockerfile and create
    a user that will run the processes on the container. The following line is the
    same as setting up a user on a Linux command line, where we set up the group first
    and then assign the user to this group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, we are also using the `adduser` option to set the
    `home` directory and disable a login password.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`addgroup` and `adduser` are specific to Alpine-based images, which are Linux-based
    images but use different packages and utilities to Debian-based images. The reason
    why Alpine-based images use these packages is that they opt for more lightweight
    utilities and applications. If you are using Ubuntu-/Debian- or Red Hat-based
    images, you would need to instead use the `useradd` and `groupadd` commands, with
    the relevant options for those commands.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you''ll see in the upcoming exercise, we will then switch to the user we
    have specifically created to create the processes we are going to run. It is optional
    what you name the groups and users, but a lot of users prefer to use a four- or
    five-digit number as this will not highlight any further privileges of this user
    to a potential attacker and is usually standard practice for creating users and
    groups. In our Dockerfile, before we create our processes, we include the `USER`
    directive and include the user ID of the user we previously created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this part of the chapter, we will introduce a new image and show the issues
    that can arise if the processes on the container are being run by the root user.
    We'll also show you how the root user in a container is the same as the root user
    on the underlying host. We'll then change our image to show the benefit of removing
    root access to the processes running on the container.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Please use `touch` command to create files and `vim` command to work on the
    file using vim editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.01: Running Containers as the Root User'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many issues can arise when we are running container processes with the root
    user. This exercise will demonstrate specific security issues, such as changing
    the access rights, killing processes, making changes to DNS, and how your images
    and underlying operating system can be made vulnerable. You will observe that
    as the root user, an attacker would also be able to use tools such as `nmap` to
    scan the network for open ports and network targets.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also correct these issues, therefore limiting what an attacker can
    do on the running container:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Dockerfile named `Dockerfile_original` with your favorite text
    editor and enter the following code into the file. All of the commands are currently
    being run as the root user in this step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will create a basic application that will run a small script called `test_memory.sh`,
    which uses the `meminfo`, `mpstat`, and `pmap` commands to provide details on
    the container's memory status. You'll also notice that on *line 4*, we are installing
    some extra applications to view the network processes with `nmap` and to allow
    us to view the user container capabilities with the `libcap` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the `security-app` image and run the image in the same step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output has been drastically reduced, and you should see the image build
    and then the memory report run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `whoami` command to view the running user on the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It should not be any surprise that the running user is the root user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `capsh –print` command to see the processes that the user is able to
    run on the container. As the root user, you should have a large number of capabilities
    available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice that the user has access to changing the ownership of files
    (`cap_chown`), killing processes (`cap_kill`), and making changes to DNS (`cap_net_bind_service`),
    among other things. These are all high-level processes that can cause a lot of
    issues in a running environment and should not be available to the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As the root user, an attacker would also be able to use tools such as `nmap`,
    which we installed earlier, to scan the network for open ports and network targets.
    Run your container images again by passing the `nmap` command, looking for the
    opened `443` port under `localhost`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `nmap` scan doesn't find any open networks, but it is an elevated
    command that shouldn't be able to be run by any users. We will demonstrate later
    in this exercise that a non-root user is not able to run this command.
  prefs: []
  type: TYPE_NORMAL
- en: 'As previously mentioned, being the root user on your container is the same
    as being the root user on the underlying host. This can be demonstrated by mounting
    a file owned by the root onto the container. To do that, create a secret file.
    Echo your secret password into the `/tmp/secret.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the ownership to make sure the root user owns it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `docker run` command to mount the file on the running container and
    check whether you are able to access it and view the data in the file. The user
    on the container can access the file that the root user on the host system should
    only have access to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The output from the docker run command will be the words "`secret password`"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: However, the Docker container should not be able to expose this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start making some simple changes to your container to stop this access from
    happening again, open the Dockerfile again and add the highlighted code (*lines
    6*, *7*, *8*, and *9*), keeping the previous lines of code as they are. These
    lines of code will create a group, `10001`, and a user, `20002`. The user will
    be set up with a `home` directory, which you will then move into and start working
    with the `USER` directive in *line 9*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a change to *line 15* to make sure the script is being run from the new
    `security_app` directory, and then save the Dockerfile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete Dockerfile should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the image again and run it with the `whoami` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see a new user as `20002` and not the root user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, you were able to run `nmap` from the container. Verify whether
    the new user is stopped from accessing the `nmap` command now to scan for network
    vulnerabilities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'By running your image again with the `nmap -sS` command, you should now be
    stopped from running the command since the `20002` user that the container is
    running as does not have sufficient privileges to run the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You have now drastically limited what can be done with the running container,
    but are files that are owned by the host root user still accessible by the `security-app`
    running container? Mount the file again and see whether you can output the information
    on the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see `Permission denied` in your results, ensuring the container
    no longer has access to the `secret.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As we've been able to demonstrate in this exercise, removing your running containers'
    access to the root user is a good first step in reducing what an attacker can
    achieve if they manage to gain access to your running images. The next section
    will take a quick look at the privileges and capabilities of running containers
    and how they can be manipulated with `docker run` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime Privileges and Linux Capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When running your containers, Docker provides a flag that overrides all the
    security and user options. This is done by running your container with the `––privileged`
    option. Though you have seen what the user can achieve when the container is run
    as the root user, we are running the container in an unprivileged state. Although
    the `––privileged` option is provided, it should be used sparingly, and we should
    be cautious if anyone is requesting to run your containers in this mode. There
    are some specific circumstances—for example, if you needed to run Docker on Raspberry
    Pi and needed to access the underlying architecture—in which you may want to add
    capabilities to your user.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to provide extra privileges to your container to run specific commands
    and functions, Docker provides an easier way to do this, using the `––cap–add`
    and `––cap–drop` options. This means that instead of providing complete control
    with the `––privileged` option, you can use `––cap–add` and `––cap–drop` to limit
    what can be achieved by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Both `––cap–add` and `––cap–drop` can be used simultaneously when running your
    containers. For example, you may want to include `––cap–add=all` and `––cap–drop=chown`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a short list of some of the capabilities available to both `––cap``–add`
    and `––cap–drop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setcap`: Modify the process capabilities of your running system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mknod`: Create special files on your running system using the `mknod` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chown`: Perform file ownership changes to a file''s UID and GID values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kill`: Bypass permissions for sending signals to stop processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setgid/setuid`: Change the process'' UID and GID values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net_bind_service`: Bind a socket to a domain port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sys_chroot`: Change the `root` directory on the running system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setfcap`: Set the capabilities of a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sys_module`: Load and unload kernel modules on the running system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sys_admin`: Perform a range of administration operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sys_time`: Make changes and set the time to the system clock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net_admin`: Perform a range of administration operations related to networking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sys_boot`: Reboot the system and load a new kernel on the system for later execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To add extra capabilities, you simply need to include the capability, and if
    you are adding or dropping the capabilities while performing your `docker run`
    command, your command will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the syntax uses `––cap–add` to add a capability and `––cap–drop`
    to remove the capability.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you're interested in seeing the entire list of capabilities that you can
    add and drop when running your containers, go to [http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html).
  prefs: []
  type: TYPE_NORMAL
- en: We've taken a brief look at using privileges and capabilities. Later in this
    chapter, we will get a chance to use the functionality when testing our security
    profiles. For now, though, we are going to look at using digital signatures with
    our Docker images to verify their authenticity.
  prefs: []
  type: TYPE_NORMAL
- en: Signing and Verifying Docker Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as we can make sure that the applications we purchase and install on our
    systems are from a trusted source, we can do the same with the Docker images we
    use. Running an untrusted Docker image could become a huge risk and could cause
    major issues in our system. This is why we should look to have specific proof
    of the images we are using. An untrusted source could potentially add code to
    the running image, which could expose your entire network to the attacker.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Docker has a way of digitally signing our images to ensure we're
    using images from a verified vendor or provider. This will also ensure the image
    has not been changed or corrupted since it was originally signed, ensuring some
    authenticity. It shouldn't be the only way we trust our images. As you'll see
    later in this chapter, once we have our image, we can then scan it to ensure we
    avoid installing an image that may have security issues.
  prefs: []
  type: TYPE_NORMAL
- en: The way that Docker allows us to sign and verify images is by using **Docker
    Content Trust** (**DCT**). DCT is provided as part of Docker Hub and allows you
    to use digital signatures for all the data sent and received from your registries.
    The DCT is associated with the image tag, so not all images need to be tagged,
    and as a result, not all images will have a DCT associated with it. This will
    mean that anyone wanting to publish an image can do so but is able to ensure the
    image is working correctly before needing to sign it.
  prefs: []
  type: TYPE_NORMAL
- en: 'DCT doesn''t only stop with Docker Hub. If a user has enabled DCT on their
    environment, they will only be able to pull, run, or build with images that are
    trusted, as DCT ensures that a user will only be able to see signed images. DCT
    trust is managed through the use of signing keys, which are created the first
    time you run DCT. When a key set is created, it consists of three different types
    of keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Offline keys**: These are used to create tagging keys. They should be stored
    carefully and are owned by the user creating the images. If these keys are lost
    or compromised, it could cause a lot of issues for the publisher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repository or tagging keys**: These reside with the publisher and are associated
    with the image repository. They are used when you are signing your trusted images
    ready to be pushed to your repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server managed keys**: These are also associated with the image repository
    and are stored on the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you keep your offline keys safe because if you lose your offline key,
    it will cause a lot of problems as Docker Support will most likely need to be
    involved to reset the repository state. It also requires manual intervention from
    all consumers that have used signed images from the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we''ve seen in previous sections, Docker provides easy-to-use command-line
    options to generate, load, and work with signing keys. If you have DCT enabled,
    Docker will set up your keys and sign your images directly with them. If you''d
    like to control things a little further, you can use the `docker trust key generate`
    command to create your offline keys with the name you assign to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Your keys will be stored in your `home` directory in the `.docker/trust` directory.
    If you have a set of offline keys, you can use the `docker trust key load` command
    with the keys and the name you created them with, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have your key, or you load in your original keys, you can then start
    to sign your images. You need to include the full registry name and the tag of
    the image using the `docker trust sign` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you sign your images, or you have an image that you need to verify is
    signed, you can use the `docker trust inspect` command to show the details of
    the signing keys and the issuer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Using DCT as part of your development process prevents users from using container
    images from untrusted and unknown sources. We'll use the security app we've been
    working on in the previous sections of this chapter to create and implement a
    DCT signing key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.02: Signing Docker Images and Utilizing DCT on Your System'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following exercise, you will learn about using DCT and implementing
    processes using signed images in your environment. You will begin by exporting
    the `DOCKER_CONTENT_TRUST` environment variable to enable DCT on your system.
    Moving on, you will learn how to sign the images and verify signed images:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Export the `DOCKER_CONTENT_TRUST` environment variable to your system to enable
    DCT on your system. Also, make sure the variable is set to `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that DCT is enabled, you won''t be able to pull or work with any Docker
    images that do not have a signed key associated with them. We can test this by
    pulling the `security-app` image from our Docker Hub repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the error message, we weren''t able to pull our latest
    image, and that''s good news because we hadn''t pushed it originally using a signing
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Push the image to your image repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You should not be able to do this as there are no signing keys associated with
    this local image either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Tag your new image ready to be pushed to Docker Hub as `trust1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, a signing key will be associated automatically with the
    image when we push it to our repository for the first time. Make sure to tag your
    image, as this will stop DCT from recognizing that it needs to be signed. Push
    the image to the repository again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines will be printed after running the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The following output shows that as the image is being pushed to the registry,
    a new signing key is created as part of the process, requesting the user to create
    a new root key and repository key in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s a lot more secure now. What about running the image on your system, though?
    With DCT now enabled on our system, will there be any issues running on our container
    image? Use the `docker run` command to run the `security-app` image on your system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The command should return the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, we have deliberately not used the `trust1` tag. As
    in earlier chapters, Docker will try to run the image with the `latest` tag. As
    this also doesn't have a signing key associated with it, you are not able to run
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can sign the image directly from your working system, and you can use the
    keys created previously to sign subsequent tagged images. Tag your image with
    the `trust2` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Sign the newly tagged image with the signing key created earlier in this exercise.
    Use the `docker trust sign` command with the image name and tag to sign the image
    and layers of the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will automatically push the signed image to our Docker Hub repository
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'View the signing information using the `docker trust` command with the `inspect`
    option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will give you details of the signer, the tagged image that is signed,
    and other information on the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `docker trust revoke` command to remove the signature of the associated
    key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you're using your own Docker registry, you may need to set up a Notary server
    to allow DCT to work with your Docker registry. Products such as Amazon's Elastic
    Container Registry and Docker Trusted Registry have Notary built into their products.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, signing and verifying your Docker images using DCT makes it
    easy to control the images you are using as part of your applications. Using signed
    images from trusted sources is only part of the equation. In the next section,
    we'll use Anchore and Snyk to start scanning our images for vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Image Security Scans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security scans play an important part in not only ensuring the uptime of your
    applications but also making sure you are not running outdated, unpatched, or
    vulnerable container images. Security scans should be performed on all images
    used by your team and in your environment. It doesn't matter if you have created
    them from scratch and you trust them; it's still an important step in reducing
    the potential risk within your environment. This section of the chapter will go
    through two options for scanning images that can easily be adopted by your development
    teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'By implementing a security scan of our Docker images, we hope to achieve the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to keep a database of known and up-to-date vulnerabilities or use an
    application that will keep this database on our behalf.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We scan our Docker images against this database of vulnerabilities, not only
    verifying that the underlying operating system is safe and patched but also that
    the open-source applications used by the container and the languages used by our
    software implementation are safe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the security scan is complete, we need to be provided with a full report
    of what has been scanned on our image, as well as report and alert any issues
    that may have been highlighted during the scan.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, a security scan can then provide remediation of any issues found and
    alerted on by updating the base image used in the Dockerfile or supporting the
    applications used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a lot of products on the market that can perform security scans for
    you, both paid and open source. We are limited with our space in this chapter,
    so we've chosen two services that we found to be both easy to use and that provide
    good functionality. The first is Anchore, which is an open-source container analysis
    tool that we'll install onto our system and run as a local tool to test our images.
    We will then look at Snyk, which is an online SaaS product. There is a free version
    of Snyk available, which is the version we will be using in this chapter to demonstrate
    how it works. It provides decent functionality without needing to pay a monthly
    fee.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning Images Locally Using Anchore Security Scan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anchore Container Analysis is an open-source static analysis tool that allows
    you to scan your Docker images and provide a pass or fail result against a policy
    defined by the user. The Anchore Engine allows the user to pull an image and without
    running it, analyze the image's content, and evaluate whether the image is suitable
    for use. Anchore uses a PostgreSQL database to store details of known vulnerabilities.
    You can then use the command-line interface to scan images against the database.
    Anchore also makes it very easy to get started, as we will see in the following
    exercise, as it provides an easy-to-use `docker-compose` file to automate installation
    and get you started as quickly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you're interested in learning more about Anchore, there is a large body of
    documentation and information at [https://docs.anchore.com/current/](https://docs.anchore.com/current/).
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming exercise, once our environment is up and running, you will interface
    with Anchore using its API. The `anchore-cli` command comes with a number of easy-to-use
    commands to check the system status and start to assess the vulnerability of our
    images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once our system is up and running, we can use the `system status` command to
    provide a list of all our services and ensure they are up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the first things you''ll need to do once your system is up and running
    is to verify that the feeds list is up to date. This will ensure that your database
    has been populated with vulnerability feeds. This is achieved with the following
    `system feeds list` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `anchore-cli` will use Docker Hub as your image registry. If your
    image is residing on a different registry, you will need to add the registry with
    the `anchore-cli registry add` command and specify the registry name, as well
    as include a username and password that Anchore can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To add an image to Anchore, you can use the `image add` command-line option,
    including the Docker Hub location and the image name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you then wish to scan the image for vulnerabilities, you can do so using
    the `image vuln` option, including the image name you scanned in originally. We
    could also use the `os` option for operating system-specific vulnerabilities and
    `non-os` for language-related vulnerabilities. In the following example, we have
    used `all` to include both the `os` and `non-os` options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to view the completed evaluation of the image and be provided with a
    pass or fail on whether the image is safe for use, you use the `evaluate check`
    option of the `anchore-cli` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: With all that in mind, Anchore does provide a supported and paid version with
    an easy-to-use web interface, but as you'll see in the following exercise, there
    is not a lot of hard work required to get the Anchore application running and
    scanning on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous exercise used DCT as part of the creation and signing of containers.
    In the following exercise, the Anchore image needed for the exercise uses the
    `latest` tag, so if you are still running DCT, you will need to stop it before
    proceeding with the next exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '`export DOCKER_CONTENT_TRUST=0`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.03: Getting Started with Anchore Image Scanning'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following exercise, you will install Anchore onto your local system
    using `docker-compose` and start to analyze the images you have been using as
    part of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create and tag a new version of the `security-app` image that you have been
    working on. Tag the image with the `scan1` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Push it to the Docker Hub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new directory called `aevolume` and move into that directory using
    the following command. This is where we will perform our work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Anchore provides you with everything you need to get started in an easy-to-use
    `docker-compose.yaml` file to set up and run the Anchore API. Pull the latest
    `anchore-engine` Docker Compose file using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Look through the `docker-compose.yml` file. Although it contains over 130 lines,
    there is nothing too complex in the file. The `Compose` file is setting up the
    functionality for Anchore, including the PostgreSQL database, catalog, and analyzer
    to query against; a simple queue and policy engine; and an API to run commands
    and queries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pull the images needed by the `docker-compose.yml` file using the `docker-compose
    pull` command, making sure you are in the same directory as the `Compose` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will start pulling the database, catalog, analyzer, simple queue,
    policy engine, and API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If all our images are now available, as seen in the preceding output, there
    is nothing left to do other than running the `Compose` file using the `docker-compose
    up` command. Use the `-d` option to have all of the containers running in the
    background as daemons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The command should output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `docker ps` command to have the running containers on your system that
    make up Anchore ready to start scanning our images. The `IMAGE`, `COMMAND`, and
    `CREATED` columns are removed from the table for convenience:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'All values in the output should show `healthy` for each of the Anchore Engine containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the environment is deployed onto your system, use the `docker-compose
    exec` command to run the `anchor-cli` commands mentioned earlier. Use the `pip3`
    command to install the `anchorecli` package onto your running system. The `--version`
    command has been used to verify whether `anchore-cli` has installed successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The command returns the version of `anchor-cli`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The version may vary depending on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could now run your `anchore-cli` command, but you would need to specify
    the URL (using `--url`) to your API and the username and password (using `--u`
    and `--p`). Instead, export the values to your environment with the following
    commands so that you don''t need to use the extra command-line options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The preceding variables are the default values for the `Compose` file provided
    by Anchore. If you decide to set up the environment running inside your deployment
    environment, you will most likely change these to be more secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `anchore-cli` now installed and configured, use the `anchore-cli system
    status` command to verify that the analyzer, queue, policy engine, catalog, and
    API are all up and running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'There may be instances where one or two of the services may be down, which
    will mean you will most likely need to restart the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`Engine DB Version` and `Engine Code Version` may vary depending on the system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `anchore-cli system feeds list` command to see all of the vulnerabilities
    in your database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output has been reduced as there is, as you can imagine, a large
    number of vulnerabilities provided to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, you will notice that some of the vulnerability feeds
    are showing `None`. This is because the database was only recently set up and
    has not updated all of the vulnerabilities. Continue to display the feeds list
    as you did in the previous step, and once all of the entries are showing a date
    in the `LastSync` column, you will then be ready to start scanning images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the feed has fully updated, add an image with the `anchore-cli image add`
    command. Remember to use the full path, including the image repository tags, as
    Anchore will use the image located on Docker Hub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The command adds the image to the Anchore database, ready for it to be scanned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: When you add the image, you will notice that we have highlighted that the output
    is showing `not_analyzed`. This will be queued for analysis and for smaller images,
    which will be a quick process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Monitor your image to see whether it has been analyzed using the `anchore-cli
    image list` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This will provide a list of all the images we have currently added and will
    give you a status on whether they have been analyzed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the image is added and analyzed, you can start to look through the
    image and see what is included as part of the base image and what applications
    are installed, including the version and license number. Use the `image content
    os` command for `anchore-cli`. You can also use other content types, including
    `file` for all the files on the image, `npm` for all the Node.js modules, `gem`
    for the Ruby gems, `java` for the Java archives, and `python` for the Python artifacts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will return an output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `anchore-cli image vuln` command and include the image you want to
    scan to check for vulnerabilities. If there are no vulnerabilities present, you
    should not see any output. We have used `all` in the following command line to
    provide a report on both OS and non-OS vulnerabilities. We could also have used
    `os` for operating system-specific vulnerabilities and `non-os` for language-related
    vulnerabilities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform an evaluation check of the image to provide us with a `pass` or `fail`
    result for our image scan. Use the `anchore-cli evaluate check` command to see
    whether the image is safe to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: All of the preceding exercises have gone a long way to establish whether or
    not our image has any vulnerabilities and is safe to use. The following section
    will show you an alternative to Anchore, which although it has a paid component,
    does still provide a large amount of functionality by only accessing the free
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing SaaS Security Scans with Snyk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Snyk is an online SaaS application that provides an easy-to-use interface that
    allows you to scan your Docker images for vulnerabilities. Although Snyk is a
    paid application, it does provide a free tier with a large amount of functionality
    to the user. It provides unlimited tests to open source projects and allows GitHub
    and GitLab integration, with remediation to open source projects and continuous
    monitoring. You are limited to the amount of container vulnerability testing that
    is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: The following exercise will run through using the web interface providing a
    guide on how to register for an account and then add your container to be scanned
    for security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.04: Setting up a Snyk Security Scan'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will use your web browser to work with Snyk to start
    implementing security scans on our `security-app` image:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an account with Snyk if you have not used Snyk before or do not have
    an account. You are not required to give any credit card details unless you want
    to upgrade your account to the paid version, but in this exercise, you will only
    need the free option. So, log in to Snyk or create an account at [https://app.snyk.io/signup](https://app.snyk.io/signup).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will be presented with a web page as in the following screenshot. Choose
    the method by which you wish to create your account and follow the prompts to continue:![Figure
    11.1: Creating an account with Snyk'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15021_11_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.1: Creating an account with Snyk'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once logged in, you will be presented with a page similar to the one in *Figure
    11.2*, asking `Where is the code you want to test?`. Snyk not only scans Docker
    images but also scans your code for vulnerabilities. You already have your `security-app`
    image in Docker Hub, so click on the `Docker Hub` button to start the process:![Figure
    11.2: Starting security scans with Snyk'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15021_11_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.2: Starting security scans with Snyk'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not presented with the preceding web page, you can go to the following
    URL to add a new repository. Remember to change `<your_account_name>` in the following
    URL to the account you were assigned when you created your Snyk account:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://app.snyk.io/org/<your_account_name>/add`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Authenticate with Docker Hub to allow it to view your available repositories.
    When presented with the following page, enter your Docker Hub details and click
    on `Continue`:![Figure 11.3: Authenticating with Docker Hub in Snyk'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15021_11_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.3: Authenticating with Docker Hub in Snyk'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once authenticated, you will then be presented with a list of all your repositories
    on Docker Hub, including the tags that are stored for each repository. In this
    exercise, you only need to select one of your images and use the `scan1` tag created
    in this section. Select the `security-app` image with the `scan1` tag. Once you
    are happy with your selection, click on the `Add selected repositories` button
    in the top-right corner of the screen:![Figure 11.4: Selecting your Docker Hub
    repositories for Snyk to scan'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15021_11_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.4: Selecting your Docker Hub repositories for Snyk to scan'
  prefs: []
  type: TYPE_NORMAL
- en: 'Snyk will run a scan over your image as soon as you have added it, and depending
    on the size of the image, this should complete in a matter of seconds. Click on
    the `Projects` tab at the top of the screen to see the results of your scan, and
    click and select the repository and tag you would like to view:![Figure 11.5:
    Viewing your project reports in Snyk'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15021_11_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.5: Viewing your project reports in Snyk'
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking on the repository name, you will be presented with a report
    of your image scan, outlining details about the image, what base images are being
    used, and whether there were any high, medium, or low issues found during the
    scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6: Image scan report page in Snyk'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15021_11_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.6: Image scan report page in Snyk'
  prefs: []
  type: TYPE_NORMAL
- en: Snyk will scan your image daily and will alert you if it finds any issues. A
    weekly report will be emailed to you unless there are any vulnerabilities found.
    If there are, you will be notified as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: With Snyk, you can scan your images for vulnerabilities with an easy-to-follow
    interface. As an SaaS web-based application, it also means there is no need to
    administer your applications and servers for security scanning. This is the end
    of the section on security scanning our images, and we will now move on to using
    security profiles with our images to help stop attackers from taking advantage
    of any images that they may be able to access.
  prefs: []
  type: TYPE_NORMAL
- en: Using Container Security Profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security profiles allow you to leverage existing security tools in Linux and
    implement them across your Docker images. In the following sections, we will cover
    both AppArmor and `seccomp`. These are the ways by which you can reduce the amount
    of access that processes can gain when running on your Docker environments. They
    are both simple to use and you'll find you will most likely be using them already
    in your images. We will look at both of them separately but note that AppArmor
    and Security Computing for Linux do overlap with their functionality. For the
    time being, all you need to remember is that AppArmor stops applications from
    accessing files that they shouldn't be accessing, while Security Computing for
    Linux will help stop any Linux kernel vulnerabilities from being exploited.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, and especially if you have an up-to-date version of Docker running,
    you may already have both running. You can verify this by running the `docker
    info` command and looking for `Security Options`. The following is the output
    from a system showing both features are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The following sections will cover both AppArmor and Security Computing for Linux
    and give you a clear view of how to implement and work with both on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing AppArmor Security Profiles on Your Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AppArmor stands for Application Armor and is a Linux Security module. The goal
    of AppArmor is to protect the operating system from security threats, and it was
    implemented as part of Docker version 1.13.0\. It allows the user to load a security
    profile to their running container and can be created to lock down the processes
    available to the services on the container. The default included by Docker provides
    moderate protection, while still allowing access to a large number of applications.
  prefs: []
  type: TYPE_NORMAL
- en: To help a user write a security profile, AppArmor provides a **complain mode**,
    which allows almost any task to be run without it being restricted, but any breaches
    will be logged to the audit log as an event. It also has an **unconfined mode**,
    which is the same as complain mode but will not log any events.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details on AppArmor, including documentation, use the following link,
    which will take you to the AppArmor home page on GitLab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://gitlab.com/apparmor/apparmor/wikis/home](https://gitlab.com/apparmor/apparmor/wikis/home).'
  prefs: []
  type: TYPE_NORMAL
- en: AppArmor also comes with a set of commands to help users administer the application,
    including compiling and loading policies into the kernel. The default profile
    can be a little confusing for new users. The main rules you need to remember are
    that a deny rule has precedence over allow and owner rules, which means that allow
    rules will be overridden by a subsequent deny rule if they are both on the same
    application. File operations are clearer with `'r'` as read, `'w'` as write, `'k'`
    as lock, `'l'` as link, and `'x'` as execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start working with AppArmor as it provides some easy-to-use command-line
    tools. The first one you will utilize is the `aa-status` command, which provides
    the status of all the profiles running on your system. These are located in the
    `/etc/apparmor.d` directory of your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have profiles installed on our system, we should at least have the `docker-default`
    profile; it can be applied to our Docker containers with the `--security-opt`
    option of the `docker run` command. In the following example, you can see that
    we are setting the `--security-opt` value to the `apparmor` profile, or you could
    use the `unconfined` profile, which means there is no profile running with the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate our profiles, we can use the `aa-genprof` command to gain further
    insight into what needs to be set up as the profile. AppArmor will scan through
    the logs when you perform some sample commands to then create a profile for you
    on your system and place it in the default profiles directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''re happy with your profiles, they need to be loaded onto your system
    before you can start to use them with your images. You use the `apparmor_parser`
    command with the `-r` (replace, if already set up) and `-W` (write to cache) options.
    The profiles can then be used with your running containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, if you wish to then remove a profile from AppArmor, you can use the
    `apparmor_parser` command with the `-R` option to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: AppArmor seems complicated, but hopefully, with the following exercises, you
    should become comfortable with the application and gain extra confidence in generating
    your custom profiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.05: Getting Started with AppArmor Security Profiles'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following exercise will introduce you to AppAmor security profiles and
    help you implement new rules in your running Docker containers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re running Docker Engine version 19 or greater, AppArmor should already
    be set up as part of the application. Run the `docker info` command to verify
    that it is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously in this chapter, we changed the user the container was running as
    by creating the user `20002`. We will stop this for the time being to demonstrate
    how AppArmor works in this situation. Open the `Dockerfile` with your text editor
    and this time, comment *line 9* out as we have in the code below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the `Dockerfile` again and verify the user the image is once running
    as the root user again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The above commands will build `Dockerfile` and then return the output like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the AppArmor `status` command by running `aa-status` in the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are refused to run the `aa-status` command, use `sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will show a similar output to the following and will provide the profiles
    loaded and the types of profiles loaded. You''ll notice that the output includes
    all the AppArmor profiles running on the Linux system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `security-app` container in the background to help us test AppArmor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'As we didn''t specify a profile to use, AppArmor uses the `docker-default`
    profile. Verify this by running `aa-status` again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see, toward the bottom of the output, that it now shows that two processes
    are in `enforce mode`, one showing `docker-default`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the current containers we have running so that you don''t get confused
    later in this exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Start your container without using an AppArmor profile using the `-–security-opt`
    Docker option, specifying `apparmor=unconfined`. Also, use the `–-cap-add SYS_ADMIN`
    capability to make sure you have full access to the running container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Access the container and see what type of commands you can run. Use the `docker
    exec` command with `CONTAINER ID` to access the container, but please note that
    your `CONTAINER ID` value will be different from the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Test out the permissions you have by creating two directories and mounting
    them as a bind mount with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Being able to mount directories on the container is an elevated privilege,
    so if you are able to do this, it will be clear that there is no profile stopping
    us, and we have access to mount the filesystem like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Exit the container using the `docker kill` command. You should see whether
    the default AppArmor profile will restrict access to these commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new instance of the `security-app` image. In this instance, use the
    `–-cap-add SYS_ADMIN` capability, as well, to allow the default AppArmor profile
    to be loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The command will return the random hash provided to the user when a new container
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test the changes by accessing the new running container using `exec` command,
    and see whether you can perform a bind mount, as in the earlier step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'You should hopefully see `Permission denied`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Exit the container again. Delete the original container using the `docker kill` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: In the next part of this exercise, you will look to see whether you can implement
    our custom profile for our Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use AppArmor tools to gather information about the resource needed to be tracked.
    Use the `aa-genprof` command to track details of the `nmap` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t have `aa-genprof` command installed, install it with the following
    command and then again run the `aa-genprof nmap` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo apt install apparmor - utils`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have reduced the output of the command, but if it''s successful, you should
    see an output showing it is profiling the `/usr/bin/nmap` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If `nmap` is not installed in your system, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo apt-get update`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo apt-get install nmap`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `nmap` command in a separate terminal window to provide `aa-genprof`
    with the details of the application. Use the `-u root` option as part of the `docker
    run` command to run the `security-app` container as the root user so that it will
    be able to run the `nmap` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Move back to the terminal you have been running the `aa-genprof` command from.
    Press *S* to scan the system logs for events. Once the scan finishes, press *F*
    to finish the generation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'All profiles are placed in the `/etc/apparmor.d/` directory. If everything
    has worked correctly, you should now see a file with a similar output to the following
    in the `/etc/apparmor.d/usr.bin.nmap` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `apparmor_parser` command to load the new file onto the system. Use
    the `-r` option to replace the profile if it already exists and the `-W` option
    to write it to the cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `aa-status` command to verify that the profile is now available and
    to see whether there is a new profile that is specifying `nmap`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the profile is listed as the same name as the application, `/usr/bin/nmap`,
    which is what you will need to use when running it with our container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, test your changes. Run the container with the `-u root` user. Also, use
    the `–-security-opt apparmor=/usr/bin/nmap` option to run the container with the
    newly created profile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'You should also see a result of `Permission denied` to show that the AppArmor
    profile we have created is restricting the usage as we would hope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we demonstrated how you can start to work with AppArmor on
    your system and also showed you how you can create your profiles. In the next
    section, we will move on to a similar application, *seccomp for Linux*.
  prefs: []
  type: TYPE_NORMAL
- en: seccomp for Linux Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`seccomp` for Linux was added to the Linux kernel from version 3.17, and it
    provides a way to restrict the system calls that Linux processes can issue. This
    feature can also be used within our running Docker images to help reduce the processes
    available to running containers, ensuring that if a container is ever accessed
    by an attacker or infected with malicious code, the commands and processes available
    to the attacker will be limited.'
  prefs: []
  type: TYPE_NORMAL
- en: '`seccomp` uses profiles to establish a whitelist of system calls that can be
    performed, with the default profile providing a long list of system calls that
    can be performed, and also disables approximately 44 system calls from running
    on your Docker containers. You''ve most likely been using the default `seccomp`
    profile as you have been working through the chapters in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker will be using the `seccomp` configurations from your host system, which
    can be located by searching for the `/boot/config` file and checking that the
    `CONFIG_SECCOMP` option is set to `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'When running our containers, if we ever need to run the container with no `seccomp`
    profile, we can use the `-–security-opt` option, followed by specifying that the
    `seccomp` profile is unconfirmed. The following example provides the syntax for
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create our custom profiles. In these instances, we specify the
    custom profile file location as the value of `seccomp`, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 11.06: Getting Started with seccomp'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will use `seccomp` profiles in your current environment.
    You will also create a custom profile to stop your Docker image from performing
    the change ownership command against files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check whether your running Linux system has s`eccomp` enabled. This will then
    allow you to ensure that it is running for Docker as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'If you search for `CONFIG_SECCOMP` in your boot config directory, it should
    have a value of `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `docker info` command to ensure that Docker is using a profile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'In most instances, you will note that it is running the default profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: We have reduced the output of the `docker info` command, but if you look for
    the `Security Options` heading, you should see `seccomp` on your system. You would
    need to change the value for `CONFIG_SECCOMP` to `n` if you ever wished to turn
    this off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `security-app` to see whether it has also been running with a `seccomp`
    profile. Also, search for the word `Seccomp` in the `/proc/1/status` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'A value of `2` will show that the container has been running with a `Seccomp`
    profile all this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'There may be some situations where you want to run a container without a `seccomp`
    profile. You may need to debug a container or the application running on it. To
    run the container without using any `seccomp` profile, use the `–-security-opt`
    option of the `docker run` command and specify that `seccomp` will be unconfined.
    Do this now with your `security-app` container to see the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'A value of `0` will show that we have successfully switched off `Seccomp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating custom profiles is also not very difficult, but it may require some
    additional troubleshooting to fully understand the syntax. First, test the `security-app`
    container to see whether we can use the `chown` command in the command line. Your
    custom profile will then look to stop this command from being available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The current `seccomp` profile running as the default should allow us to run
    the `chown` command, so while you have access to the running container, test to
    see whether you can create a new file and change the ownership using the `chown`
    command. Run the long listing of the directory at the end to verify that the change
    has taken place:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The commands should provide an output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Create your custom profile by modifying the default profile. Use the `wget`
    command to download the custom profile from this book''s official GitHub account
    onto your system. Use the following command to rename the downloaded custom profile
    `new_default.json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `new_default.json` file with your text editor and, although there
    will be a large list of configurations, search for the specific configurations
    that control `chown`. At the time of writing, this was located on *line 59* of
    the default `seccomp` profile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The `SCMP_ACT_ALLOW` action allows the command to be run, but if you remove
    *lines 59* to *63* from the `new_default.json` file, this should now stop our
    profile from allowing this command to be run. Delete the lines and save the file
    ready for us to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in *step 4* of this exercise, use the `–-security-opt` option and specify
    the image to now run using our edited `new_default.json` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform the same test as in *step 6* of this exercise, and if our changes have
    worked, the `seccomp` profile should now stop us from running the `chown` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: With only a minimal amount of work, we've managed to create a policy to stop
    malicious code or an attacker from changing the ownership of files in our container.
    Although this is a very basic example, it gives you an idea of how you can start
    to configure `seccomp` profiles to fine-tune them specifically for your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11.01: Setting up a seccomp Profile for the Panoramic Trekking App'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Panoramic Trekking app is coming along nicely, but this chapter has shown
    that you need to make sure that the actions a user can make on the container are
    limited. If there is a way in which the container can be accessed by an attacker,
    you need to set up some safeguard against that possible attacker. In this activity,
    you will create a `seccomp` profile that you can use with the services in the
    app that will stop a user from being able to make new directories, kill processes
    running on the container, and lastly, find out more details about the running
    container by running the `uname` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps required to complete this activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain a copy of the default `seccomp` profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the specific controls on the profile that will disable the `mkdir`, `kill`,
    and `uname` commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the services of the Panoramic Trekking app and ensure that the new profile
    is applied to the containers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Access the container and verify that you are no longer able to perform the
    `mkdir`, `kill`, and `uname` commands that have been blocked in the `seccomp`
    profile. For example, if we perform the `mkdir` command on our new image with
    the new profile added, we should see a similar output to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15021_Solution_Final_SMP.xhtml#_idTextAnchor347).
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11.02: Scanning Your Panoramic Trekking App Images for Vulnerabilities'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have been using base images for the Panoramic Trekking app that were provided
    by other users or developers. In this activity, you will need to scan the images
    for vulnerabilities and see whether they are safe for use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps you''ll need to take to complete this activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Decide on a service to use to scan your images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load your images into the service ready for scanning.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scan the images and see whether any vulnerabilities are present on the images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify whether the image is safe for use. You should be able to perform an
    evaluation check in Anchore and see a pass status similar to the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15021_Solution_Final_SMP.xhtml#_idTextAnchor348).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has been all about security, limiting risk when we're working with
    Docker and our container images, and how can we take our first steps with Docker
    security. We looked at the potential risks of running container processes as the
    root user and saw how we can make some minor changes to prevent these issues from
    arising if attackers were to access the running container. We then looked closer
    at how we can trust the images we are working with by using signing certificates
    for images and then implementing security scans on our Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, we started working with security profiles. We used
    two of the most common security profiles – AppArmor and `seccomp` – implementing
    both on our Docker images and looking at the result of reducing specific access
    to the containers. The next chapter will look at implementing best practices when
    running and creating our Docker images.
  prefs: []
  type: TYPE_NORMAL

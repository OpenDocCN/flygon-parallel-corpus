- en: '*Chapter 3*: Indirect Addressing: Pointers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will provide a thorough understanding of how to utilize pointers
    in C++. Though it is assumed that you have some prior experience with indirect
    addressing, we will start at the beginning. Pointers are a ground-level and pervasive
    feature of the language – one you must thoroughly understand and be able to utilize
    with ease. Many other languages use indirect addressing through references alone,
    however, in C++ you must roll up your sleeves and understand how to use and return
    heap memory correctly and effectively with pointers. You will see pointers heavily
    used throughout code from other programmers; there is no sensible way to ignore
    their use. Misusing pointers can be the most difficult errors to find in a program.
    A thorough understanding of indirect addressing using pointers is a necessity
    in C++ to create successful and maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter will be to build or enhance your understanding of indirect
    addressing using pointers so that you can easily understand and modify other's
    code, as well as being able to write original, sophisticated, error-free C++ code
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Pointer basics, including access, memory allocation, and release – for standard
    and user defined types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically allocating arrays of `1`, `2`, `N` dimensions, and managing their
    memory release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointers as arguments to functions and as return values from functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the `const` qualifier to pointer variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using void pointers – pointers to objects of unspecified types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand how to allocate memory from
    the heap using `new()` for simple and complex data types, as well as how to mark
    the memory for return to the heap management facility using `delete()`. You will
    be able to dynamically allocate arrays of any data type and of any number of dimensions,
    and well as understanding basic memory management for releasing memory when it
    is no longer needed in your applications to avoid memory leakage. You will be
    able to pass pointers as arguments to functions with any level of indirection
    – that is, pointers to data, pointers to pointers to data, and so on. You will
    understand how and why to combine the `const` qualification with pointers – to
    the data, to the pointer itself, or to both. Lastly, you will understand how to
    declare and utilize generic pointers with no type – void pointers – and understand
    the situations in which they may prove useful. These skills will be necessary
    in order to move forward with the next chapters in the book successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found at the following GitHub
    URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter03](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter03).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter03` in a file named `Chp3-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/2OY41sn](https://bit.ly/2OY41sn)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding pointer basics and memory allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will review pointer basics as well as introducing operators
    applicable to pointers, such as the address-of operator, the deference operator,
    and the operators `new()` and `delete()`. We will employ the address-of operator
    `&` to calculate the address of an existing variable, and conversely, we will
    apply the deference operator `*` to a pointer variable to go to the address contained
    within the variable. We will see examples of memory allocation on the heap, as
    well as how to mark that same memory for potential reuse by returning it to the
    free list when we are done with it.
  prefs: []
  type: TYPE_NORMAL
- en: Using pointer variables allows our applications to have greater flexibility.
    At run time, we can determine the quantity of a certain data type we may desire
    (such as in a dynamically allocated array), organize data in data structures that
    facilitate sorting (such as in a linked list), or gain speed by passing an address
    of a large piece of data to a function (rather than passing a copy of the entire
    piece of data itself). Pointers have many uses, and we will see many examples
    throughout this chapter and throughout the course. Let's start at the beginning
    with pointer basics.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting pointer basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First and foremost, let's review the meaning of a pointer variable. A pointer
    variable is one that may contain an address, and at that address may be relevant
    data. It is typical to say that the pointer variable "*points*" to an address
    containing the relevant data. The value of the pointer variable itself is an address,
    not the data we are after. When we then go to that address, we find the data of
    interest. This is known as indirect addressing. To summarize, the content of a
    pointer variable is an address; if you then go to that address, you find the data.
    This is for a single level of indirection.
  prefs: []
  type: TYPE_NORMAL
- en: A pointer variable may point to the existing memory of a non-pointer variable,
    or it may point to memory that is dynamically allocated on the heap. The latter
    case is the most usual situation. Unless a pointer variable is properly initialized
    or assigned a value, the content of the pointer variable is meaningless and does
    not represent a usable address. A large mistake can be assuming that a pointer
    variable has been properly initialized when it may not have been. Let's look at
    some basic operators that are useful with pointers. We will start with the address-of
    `&` and the dereference operator `*`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the address-of and dereference operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The address-of operator `&` can be applied to a variable to determine its location
    in memory. The dereference operator `*` can be applied to a pointer variable to
    obtain the value of the data at the valid address contained within the pointer
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice in the previous segment of code that we first declare and initialize
    variable `x` to `10`. Next, we declare `int *pointerToX;` to state that variable
    `pointerToX` may someday point to an integer. As of this declaration, this pointer
    variable is uninitialized, and hence does not contain a valid memory address.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward in the code to the line `pointerToX = &x;`, we assign the memory
    location of `x` using the address-of operator (`&`) as the value of `pointerToX`,
    which is waiting to be filled with a valid address of some integer. On the last
    line of this code fragment, we print out both `x` and `*pointerToX`. Here, we
    are using the dereference operator `*` with the variable `pointerToX`. The dereference
    operator tells us to go to the address contained in the variable `pointerToX`.
    At that address, we find the data value of integer `10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output this fragment would generate as a full program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For efficiency, C++ does not neatly initialize all memory with zeros when an
    application starts, nor does C++ ensure that memory is conveniently empty, without
    values, when paired with a variable. The memory simply has in it what was previously
    stored there; C++ memory is not considered *clean*. Because memory is not given
    to a programmer *clean* in C++, the contents of a newly declared pointer variable,
    unless properly initialized or assigned a value, should not be construed to contain
    a valid address.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we used the address-of operator `&` to calculate the
    address of an existing integer in memory, and we set our pointer variable to point
    to that memory. Instead, let's introduce the operators `new()` and `delete()`
    to allow us to utilize dynamically allocated heap memory for use with pointer
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Using the operators new() and delete()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The operator `new()` can be utilized to obtain dynamically allocated memory
    from the heap. A pointer variable may choose to point to memory that is dynamically
    allocated at run time, rather than to point to another variable's existing memory.
    This gives us flexibility as to when we want to allocate the memory, and how many
    pieces of such memory we may choose to have. The operator `delete()` can then
    be applied to a pointer variable to mark memory we no longer require, returning
    the memory to the heap management facility for later reuse in the application.
    It is important to understand that once we `delete()` a pointer variable, we should
    no longer use the address contained within that variable as a valid address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at simple memory allocation and release using a basic data
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the previous program segment, we first declare pointer variable `y` with
    `int *y;`. Here, `y` may someday contain the address of an integer. On the next
    line, we allocate memory from the heap large enough to accommodate an integer
    with `y = new int;`, storing that address in pointer variable `y`. Next, with
    `*y = 17;` we dereference `y` and store the value of `17` in the memory location
    pointed to by `y`. After printing out the value of `*y`, we then decide that we
    are done with the memory `y` points to and return it to the heap management facility
    by using the operator `delete()`. It is important to note that the variable `y`
    still contains the memory address it obtained with its call to `new()`, however,
    `y` should no longer use this relinquished memory.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It is the programmer's responsibility to remember that once memory has been
    deallocated, you should never again dereference that pointer variable; please
    understand that that address may have been reissued to another variable through
    another call to `new()` elsewhere in the program.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand pointer basics with simple data types, let's move onward
    by allocating more complex data types, as well as understanding the notation necessary
    to utilize and access members of user defined data types.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using pointers to user defined types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, let's examine how to declare pointers to user defined types, and how to
    allocate their associated memory on the heap. To dynamically allocate a user defined
    type, the pointer will first be declared of that type. The pointer then must either
    be initialized or assigned a valid memory address – the memory can either be that
    of an existing variable or newly allocated heap memory. Once the address for the
    appropriate memory has been placed within the pointer variable, the `->` operator
    may be utilized to access struct or class members. Alternatively, the `(*ptr).member`
    notation may be used to access struct or class members.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a basic example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter03/Chp3-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter03/Chp3-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First, in the aforementioned program, we have declared a user defined type of
    `collection`, with data members `x` and `y`. Next, we declare `item` as a pointer
    to that type with `collection *item;`. Then we allocate heap memory for `item`
    to point to, using the operator `new()`. Now, we assign values to the `x` and
    `y` members of `item`, respectively, using either the `->` operator or the `(*).member`
    access notation. In either case, the notation means to first dereference the pointer
    and then to choose the appropriate data member. It's pretty straightforward with
    the `(*).` notation – the parentheses show us that the pointer deference happens
    first, and then the choice of the member happens next with the `.` (member selection
    operator). The `->` shorthand notation indicates pointer deference followed by
    member selection. After we use `cout` with the insertion operator `<<` to print
    the appropriate values, we decide that we no longer need the memory associated
    with `item` and issue a `delete item;` to mark this segment of heap memory for
    return to the free list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at this example''s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let's also take a look at the memory layout for this example. The memory address
    (9000) used is arbitrary – just an example address that may be generated by `new()`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Memory model for Chp3-Ex1.cpp](img/B15702_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Memory model for Chp3-Ex1.cpp
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to allocate and release memory for user defined types,
    let's move forward and dynamically allocate arrays of any data type.
  prefs: []
  type: TYPE_NORMAL
- en: Allocating and deallocating arrays at run time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays may be dynamically allocated so that their size may be determined at
    run time. Dynamically allocated arrays may be of any type, including user defined
    types. Determining the size of an array at run time can be a space-saving advantage
    and gives us programming flexibility. Rather than allocating a fixed-sized array
    of the largest possible quantity needed (potentially wasting space), you can instead
    allocate the necessary size determined by various factors at run time. You have
    the additional flexibility to delete and reallocate an array should the need arise
    to change an array's size. Arrays of any number of dimensions can be dynamically
    allocated.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will examine how to dynamically allocate arrays of both
    basic and user defined data types, and of single and multiple dimensions. Let's
    get started.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically allocating single-dimension arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Single-dimension arrays may be dynamically allocated so that their size may
    be determined at run time. We will use a pointer to represent each array and will
    allocate the required memory with the operator `new()`. Once the array is allocated,
    standard array notation can be used to access each array element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple example. We''ll break it into two segments,
    however, the full program example can be found using the link below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter03/Chp3-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter03/Chp3-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the first part of this program, we first declare a user defined type, `collection`,
    using a struct. Next, we declare an integer variable to hold the number of elements
    we would like to prompt the user to enter to select as the size for our two arrays.
    We also declare a pointer to an integer with `int *intArray;` and a pointer to
    a `collection` using `collection *collectionArray;`. These declarations state
    that these pointers may one day each, respectively, point to one or more integers,
    or one or more objects of type `collection`. These variables, once allocated,
    will comprise our two arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'After prompting the user to enter the number of elements desired using `cin`
    and the extraction operator `>>`, we dynamically allocate both an array of integers
    of that size and an array of collections of that size. We use the operator `new()`
    in both cases: `intArray = new int[numElements];` and `collectionArray = new collection[numElements];`.
    The bracketed quantity of `numElements` indicates that the respective chunks of
    memory requested for each data type will be large enough to accommodate that many
    sequential elements of the relevant data type. That is, `intArray` will have memory
    allocated to accommodate `numElements` multiplied by the size needed for an integer.
    Note that an object''s data type is known because the data type of what will be
    pointed to is included in the pointer declaration itself. The appropriate amount
    of memory for `collectionArray` will be similarly provided for with its respective
    call to the operator `new()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue by examining the remaining code in this example program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Next, as we continue this example with the `for` loop, notice that we are using
    a typical array notation of `[]` to access each element of the two arrays, even
    though the arrays have been dynamically allocated. Because `collectionArray` is
    a dynamically allocated array of user defined types, we must use add the `.` notation
    to access individual data members within each array element. Though using standard
    array notation makes accessing dynamic arrays quite simple, you may alternatively
    use pointer notation to access the memory.
  prefs: []
  type: TYPE_NORMAL
- en: Within the loop, notice that we incrementally print both the elements of `intArray`
    and the `y` member of `collectionArray` using pointer notation. In the expression
    `*(intArray +i)`, the identifier `intArray` represents the starting address of
    the array. By adding `i` offsets to this address, you are now at the address of
    the `i`-th element in this array. By dereferencing this composite address with
    `*`, you will now go to the proper address to retrieve the relevant integer data,
    which is then printed using `cout` and the insertion operator `<<`. Likewise,
    with `(*(collectionArray + i)).y`, we first add `i` to the starting address of
    `collectionArray`, then using `()`, we dereference that address with `*`. Since
    this is a user defined type, we must then use `.` to select the appropriate data
    member `y`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in this example, we demonstrate how to deallocate memory that we no
    longer need using `delete()`. A simple statement of `delete intArray;` will suffice
    for the dynamically allocated array of standard types, whereas a more complex
    statement of `delete [] collectionArray;` is necessary for proper deletion of
    the array of user-defined types. In both cases, the memory associated with each
    dynamically allocated array will be returned to the free list, and can then be
    reused when heap memory is allocated with subsequent calls to the operator `new()`.
    It is crucial to remember not to deference a pointer variable once its memory
    has been marked for deletion. Though that address will remain in the pointer variable
    until you assign the pointer a new address (or null pointer), once memory is marked
    for deletion, the memory in question might have been already reused by a subsequent
    call to `new()` elsewhere in the program. This is one of many ways you must be
    diligent when using pointers in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output to accompany the full program example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's additionally take a look at the memory layout for this example. The memory
    addresses (8500 and 9500) used are arbitrary – they are example addresses on the
    heap that may be generated by `new()`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Memory model for Chp3-Ex2.cpp](img/B15702_03_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Memory model for Chp3-Ex2.cpp
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's move forward with our discussion on dynamically allocated arrays
    by allocating arrays of multiple dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamically allocating 2-D arrays: arrays of pointers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two or more dimensioned arrays may also be dynamically allocated. For a 2-D
    array, the column dimension may be dynamically allocated and the row dimension
    may remain fixed, or both dimensions may be dynamically allocated. Allocating
    one or more dimensions dynamically allows the programmer to account for run time
    decisions regarding the array size.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first consider the case where we have a fixed number of rows, and a variable
    amount of entries in each of those rows (which would be the column dimension).
    For simplicity, we will assume that the number of entries in each row is the same
    from row to row, but it need not be. We can model a 2-D array with a fixed number
    of rows and a run time determined amount of entries in each of those rows (the
    column dimension) using an array of pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider an example to illustrate a 2-D array where the column dimension
    is dynamically allocated.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter03/Chp3-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter03/Chp3-Ex3.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, notice that we initially declare an array of pointers to floats
    using `float *TwoDimArray[NUMROWS];`. Sometimes, it is helpful to read pointer
    declarations right to left; that is, we have an array, `NUMROWS`, which contains
    pointers to floating-point numbers. More specifically, we have a fixed-sized array
    of pointers where each pointer entry can point to one or more contiguous floating-point
    numbers. The number of entries pointed to in each row comprise the column dimension.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we prompt the user for the number of column entries. Here, we are assuming
    that each row will have the same number of entries in it (to make the column dimension),
    however, it is possible that each row could have a different total number of entries.
    By assuming each row will have a uniform number of entries, we have a straightforward
    loop using `i` to allocate the column quantity for each row using `TwoDimArray[i]
    = new float [numColumns];`.
  prefs: []
  type: TYPE_NORMAL
- en: In the nested loop that uses `j` as an index, we simply load values for each
    column entry of the row specified by `i` in the outer loop. The arbitrary assignment
    of `TwoDimArray[i][j] = i + j + .05;` loads an interesting value into each element.
    In the nested loop indexed on `j`, we also print out each column entry for row
    `i`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the program illustrates how to deallocate the dynamically allocated
    memory. Since the memory was allocated in a loop over a fixed number of rows –
    one memory allocation to gather memory to comprise each row's column entries –
    the deallocation will work similarly. For each of the rows, we utilize the statement
    `delete TwoDimArray[i];`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for the example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's take a look at the memory layout for this example. As in previous
    memory diagrams, the memory addresses used are arbitrary – they are example addresses
    on the heap as may be generated by `new()`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Memory model for Chp3-Ex3.cpp](img/B15702_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Memory model for Chp3-Ex3.cpp
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to utilize an array of pointers to model a 2-D array,
    let's move onward to see how we can model a 2-D array using a pointer to a pointer
    so that we may choose both dimensions at run time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamically allocating 2-D arrays: pointers to pointers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dynamically allocating both the row and column dimensions for an array can add
    necessary run time flexibility to a program. To achieve this ultimate flexibility,
    a 2-D array can be modeled using a pointer to a pointer of the desired data type.
    Initially, the dimension representing the number of rows will be allocated. Next,
    for each row, the number of elements in each row will be allocated. As with the
    last example using an array of pointers, the number of elements in each row (the
    column entries) need not be uniform in size across rows. However, to accurately
    model the concept of a 2-D array, it is assumed that the column size will be allocated
    uniformly from row to row.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider an example to illustrate a 2-D array where both the row and column
    dimensions are dynamically allocated.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter03/Chp3-Ex4.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter03/Chp3-Ex4.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, notice that we initially declare a pointer to a pointer of
    type `float` using `float **TwoDimArray;`. Reading this declaration right to left,
    we have `TwoDimArray` as a pointer to a pointer to `float`. More specifically,
    we understand `TwoDimArray` will contain the address of one or more contiguous
    pointers, each of which may point to one or more contiguous floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we prompt the user for the number of row entries. We follow this input
    with the allocation to a set of `float` pointers, `TwoDimArray = new float * [numRows];`.
    This allocation creates `numRows` quantity of `float` pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Just as in the previous example, we prompt the user for how many columns in
    each row we would like to have. Just as before, in the outer loop indexed on `i`,
    we allocate the column entries for each row. In the nested loop indexed on `j`,
    we again assign values to our array entries and print them just as before.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the program continues with the memory deallocation. Just as before,
    the column entries for each row are deallocated within a loop. Additionally, however,
    we need to deallocate the dynamically allocated number of row entries. We do this
    with `delete TwoDimArray;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for this program is slightly more flexible, as we can enter at run
    time the number of both the desired rows and columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let's again take a look at the memory model for this program. As a reminder,
    just as in previous memory diagrams, the memory addresses used are arbitrary –
    they are example addresses on the heap as may be generated by `new()`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Memory model for Chp3-Ex4.cpp](img/B15702_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Memory model for Chp3-Ex4.cpp
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to utilize pointers to pointers to model a 2-D array,
    let's move onward to see how we may model arrays of any number of dimensions using
    pointers to pointers to pointers, and so on. In C++, you can model any dimensionality
    of a dynamically allocated array, so long as you can imagine it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamically allocating N-D arrays: pointers to pointers to pointers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++, you can model any dimensionality of a dynamically allocated array. You
    need only be able to imagine it, declare the appropriate levels of pointers, and
    make the required levels of memory allocation (and eventual deallocation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the pattern you will need to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter03/Chp3-Ex5.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter03/Chp3-Ex5.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, notice that we use three levels of indirection to specify the
    variable to represent the 3-D array `int ***ThreeDimArray;`. We subsequently allocate
    the required memory for each level of indirection. The first allocation is `ThreeDimArray
    = new int ** [dim1];`, which allocates dimension 1's set of pointers to pointers.
    Next, in a loop iterating over `i`, and for each element in dimension 1, we allocate
    `ThreeDimArray[i] = new int * [dim2];` to allocate the pointers to integers for
    the second dimension of the array. And in a nested loop iterating over `j`, and
    for each element in dimension 2, we allocate `ThreeDimArray[i][j] = new int [dim3];`
    to allocate the integers themselves in a quantity specified by `dim3`.
  prefs: []
  type: TYPE_NORMAL
- en: As in the last two examples, we initialize the array elements in the inner loops
    and print their values. At this point, you will undoubtedly notice the similarities
    between this program and its predecessor. A pattern for the allocation is emerging.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we will deallocate the three levels of memory in a manner similar –
    yet in reverse – to the levels of allocation. We use a nested loop iterating over
    `j` to release the memory of the innermost level, followed by the memory release
    in the outer loop, which iterates over `i`. Finally, we relinquish the memory
    for the initial dimension with a simple call to `delete ThreeDimArray;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for this example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen how to model a 3-D array using pointers to pointers to
    pointers, a pattern has emerged to show us how to declare the required level and
    number of pointers to model an N-D array. We can also see the pattern for the
    necessary allocations. Multi-dimensional arrays can become quite large, especially
    if you were forced to model them with the largest potentially necessary fixed-sized
    array. The beauty of modeling with pointers to pointers (to pointers and so on)
    for each level of a necessary multi-dimensional array, is that you can allocate
    exactly a size that may be determined at run time. To make usage easy, array notation
    using `[]` can be used as an alternative to pointer notation to access the elements
    in the dynamically allocated array. C++ has a lot of flexibility stemming from
    pointers. Dynamically allocated arrays demonstrate one such flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now move forward with our understanding of pointers and consider their
    usage in functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using pointers with functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions in C++ will undoubtedly take arguments. We have seen many examples
    in the previous chapters illustrating function prototypes and function definitions.
    Now, let's augment our understanding of functions by passing pointers as arguments
    to functions, and using pointers as return values from a function.
  prefs: []
  type: TYPE_NORMAL
- en: Passing pointers as arguments to functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arguments passed from actual to formal parameters in a function call are by
    default copied on the stack. In order to modify the contents of a variable as
    an argument to a function, a pointer to that argument must instead be used as
    a function parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Any time an actual parameter is passed to a function in C++, a copy of something
    is made and passed on the stack to that function. For example, if an integer is
    passed as an actual parameter to a function, a copy of that integer is made and
    then passed on the stack to the function to be received as the formal parameter.
    Changing the formal parameter in the scope of the function would only change the
    copy of the data that was passed into the function.
  prefs: []
  type: TYPE_NORMAL
- en: Should we instead require the ability to modify a function's parameters, it
    is then necessary that we pass a pointer to the desired data as a parameter of
    the function. In C++, passing a pointer as an actual parameter copies this address
    on the stack and the copy of the address is received as the formal parameter in
    the function. However, using the copy of the address, we can still go to that
    address (by dereferencing that pointer) to access the desired data and make changes
    to the desired data.
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate, something is always copied on the stack when you pass a parameter
    in C++. If you pass a non-pointer variable, you get a copy of that data passed
    on the stack to the function. Changes made to that data in the scope of that function
    are local changes only and do not persist when the function returns. The local
    copy is simply popped off the stack at the conclusion of the function. However,
    if you pass a pointer to a function, though the address stored in the pointer
    variable is still copied on the stack and passed to the function, you can still
    dereference the copy of the pointer to access the real data at the desired address.
  prefs: []
  type: TYPE_NORMAL
- en: You always need to be one step back from that which you want to modify. If you
    want to change a standard data type, pass a pointer to that type. If you want
    to change the value of the pointer itself (the address), you must pass a pointer
    to that pointer as a parameter to the function. Remember, a copy of something
    is passed to the function on the stack. You cannot change that copy beyond the
    scope of the function. Pass the address of that which you want to change – you
    are still passing a copy of that address but using it will get you to the real
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a few minutes to understand an example illustrating passing pointers
    as arguments to functions. Here we will begin by examining two functions that
    contribute to the following full program example.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter03/Chp3-Ex6.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter03/Chp3-Ex6.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Examining the functions above, notice that `TryToAddOne()` takes an `int` as
    a formal parameter, whilst `AddOne()` takes an `int *` as a formal parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In `TryToAddOne()`, an integer passed to the function is merely a copy of the
    actual parameter sent to the function. This parameter is referred to as `arg`
    in the formal parameter list. Incrementing the value of `arg` by one in the body
    of the function is a local change only within `TryToAddOne()`. Once the function
    completes, the formal parameter, `arg`, is popped off the stack and the actual
    parameter in the call to this function will not have been modified.
  prefs: []
  type: TYPE_NORMAL
- en: However, notice that `AddOne()` takes an `int *` as a formal parameter. The
    address of the actual integer parameter will be copied on the stack and received
    as the formal parameter, `arg`. Using the copy of that address, we deference the
    pointer `arg` using `*`, then increment the integer value at that address using
    `++` in the line of code `(*arg)++;`. When this function completes, the actual
    parameter will have been modified because we have passed a copy of the pointer
    to that integer, rather than a copy of the integer itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the remainder of this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the function prototypes at the top of this program segment. They will
    match the function definitions in the previous segment of code. Now, in the `main()`
    function, we declare and initialize `int x = 10;` and declare a pointer: `int
    *y;`. We allocate the memory for `y` using `new()` and then assign a value by
    dereferencing the pointer with `*y = 15;`. We print out the respective values
    of `x` and `*y` as a baseline.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call `TryToAddOne(x);` followed by `TryToAddOne(*y);`. In both cases,
    we are passing integers as actual parameters to the function. Variable `x` is
    declared to be an integer and `*y` refers to the integer pointed to by `y`. Neither
    of these function calls will result in the actual parameter being changed, which
    we can verify when their respective values are next printed using `cout` and the
    insertion operator `<<`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call `AddOne(&x);` followed by `AddOne(y);`. In both cases, we are
    passing a copy of an address as the actual parameter to the function. Of course,
    `&x` is the address of variable `x`, so this works. Likewise, `y` itself is an
    address – it is declared as a pointer variable. Recall, inside the `AddOne()`
    function, the formal parameter is first dereferenced and then incremented in the
    body of the function `(*arg)++;`. We can use a copy of a pointer to access actual
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output for the full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's add to our discussion of using pointers with functions by using
    pointers as return values from functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using pointers as return values from functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions may return pointers to data via their return statements. When returning
    a pointer via the return statement of a function, be sure that the memory that
    is pointed to will persist after the function call is completed. Do not return
    a pointer to stack memory that is local to the function. That is, do not return
    a pointer to local variables defined on the stack within the function. However,
    returning a pointer to memory allocated using `new()` within the function is sometimes
    acceptable. As the allocated memory will be on the heap, it will exist past the
    function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example to illustrate these concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter03/Chp3-Ex7.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter03/Chp3-Ex7.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `const int MAX = 20;` is defined and then `char *createName();`
    is prototyped, indicating that this function takes no arguments, yet returns a
    pointer to one or more characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main()` function, a local variable: `char *name;` is defined but not
    initialized. Next, `createName()` is called and its return value is used to assign
    a value to `name`. Notice both `name` and the function''s return type are of type
    `char *`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the call to `createName()`, notice that a local variable, `char *temp = new
    char[MAX];`, is both defined and allocated to point to a fixed amount of memory
    on the heap using the operator `new()`. The user is then prompted to enter a name
    and that name is stored in `temp`. The local variable `temp` is then returned
    from `createName()`.
  prefs: []
  type: TYPE_NORMAL
- en: In `createName()`, it is important that the memory for `temp` be comprised of
    heap memory so that it will persist beyond the scope of this function. Here, a
    copy of the address stored in `temp` will be copied onto the stack in the area
    reserved for a return value from the function. Fortunately, that address refers
    to heap memory. The assignment `name = createName();` in `main()` will capture
    this address and copy it to be stored into the `name` variable, which is local
    to `main()`. Since the memory allocated in `createName()` is on the heap, this
    memory will exist once the function completes.
  prefs: []
  type: TYPE_NORMAL
- en: Just as important to note, had `temp` been defined as `char temp[MAX];` in `createName()`,
    the memory comprising `temp` would have existed on the stack and would have been
    local to `createName()`. Once `createName()` returns to `main`, the memory for
    this variable will have been popped off the stack and will be unavailable for
    proper use – even if that address has been captured in a pointer variable within
    `main()`. This is another potential pointer trap in C++. When returning a pointer
    from a function, always ensure that the memory that the pointer points to exists
    beyond the extent of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for this example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now that we understand how pointers can be used within parameters to functions
    and as return values from functions, let's move forward by examining further pointer
    nuances.
  prefs: []
  type: TYPE_NORMAL
- en: Using the const qualifier with pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `const` qualifier can be used to qualify pointers in several different ways.
    The keyword `const` can be applied to the data pointed to, to the pointer itself,
    or to both. By using the `const` qualifier in this variety of ways, C++ offers
    the means to protect values in a program that may be mean to be initialized but
    never again modified. Let's examine each of these various scenarios. We will also
    be combining `const` qualified pointers with return values from functions to understand
    which of these various scenarios are reasonable to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Using pointers to constant objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A pointer to a constant object may be specified so that the object that is pointed
    to may not be directly modified. A dereferenced pointer to this object may not
    be used as an l-value in any assignment. An l-value means a value that can be
    modified, and that occurs on the left-hand side of an assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s introduce a simple example to understand the situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've introduced `const char *constData = "constant";`. The pointer points
    to data, which is initialized, and which may never again be modified through this
    identifier. For example, should we try to alter this value using a `strcpy` where
    `constData` is the destination string, the compiler will issue an error.
  prefs: []
  type: TYPE_NORMAL
- en: Also, trying to circumvent the situation by trying to store `constData` in a
    pointer of the same (but not `const`) type, will also generate a compiler error,
    such as in the line of code `regularString = constData;`. Of course, in C++ you
    can do anything if you try hard enough, so an explicit typecast here will work,
    but is purposely not shown. An explicit typecast will still generate a compiler
    warning to allow you to question whether this is truly something you intend to
    do. When we move forward with OO concepts, we will introduce ways to further protect
    data so that this type of circumvention can be eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: On the last line of the previous code, notice that we store the address of a
    regular string in `const char *moreConstData`. This is allowed – you can always
    treat something with more respect than it was defined to have (just not less).
    This means that using the identifier `moreConstData`, this string may not be modified.
    However, using its own identifier, which is defined as `char *anotherRegularString;`,
    this string may be changed. This seems inconsistent, but it is not. The `const
    char *` variable chose to point to a `char *` – elevating its protection for a
    particular situation. If the `const char *` truly wanted to point to an immutable
    object, it would have chosen to instead point to another `const char *` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's see a variation on this theme.
  prefs: []
  type: TYPE_NORMAL
- en: Using constant pointers to objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A constant pointer to an object is a pointer that is initialized to point to
    a specific object. This pointer may never be assigned to point to another object.
    This pointer itself may not be used as an l-value in an assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, two regular `char *` variables (`regularString` and `anotherRegularString`)
    are defined and loaded with string literals. Next, `char *const constPtrString
    = regularString;` is defined and initialized to point to a modifiable string.
    Because the `const` qualification is on the pointer itself and not the data pointed
    to, the pointer itself must be initialized with a value at declaration. Notice
    that the line of code `constPtrString = anotherRegularString;` would generate
    a compiler error because a `const` pointer cannot be on the left-hand side of
    an assignment. However, because the `const` qualification is not applicable to
    the data pointed to, a `strcpy` may be used to modify the value of the data as
    is seen in `strcpy(constPtrString, "I can change the value");`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's combine the `const` qualifier on both the pointer and the data that
    is pointed to.
  prefs: []
  type: TYPE_NORMAL
- en: Using constant pointers to constant objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A constant pointer to a constant object is a pointer that is established to
    point to a specific object and to unmodifiable data. The pointer itself must be
    initialized to a given object, which is (hopefully) initialized with appropriate
    values. Neither the object or the pointer may be modified or used as l-values
    in assignments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this example, two regular `char *` variables are declared, `regularString`
    and `anotherRegularString`. Each is initialized with a string literal. Next, we
    introduce `const char *const constStringandPtr = regularString;`, which is a `const`
    qualified pointer to data that is also treated as `const`. Notice that this variable
    must be initialized because the pointer itself cannot be an l-value in a later
    assignment. You will also want to ensure that this pointer is initialized with
    a meaningful value, as the data that is pointed to also cannot be changed (as
    illustrated by the `strcpy` statement, which would generate a compiler error).
    Combining `const` on the pointer as well as the data pointed to is a strict way
    to safeguard data.
  prefs: []
  type: TYPE_NORMAL
- en: Tip – deciphering pointer declarations
  prefs: []
  type: TYPE_NORMAL
- en: To read complex pointer declarations, it often helps to read the declaration
    backwards – from right to left. For example, the pointer declaration `const char
    *p1 = "hi!";` would be interpreted as `p1` is a pointer to (one or more) characters
    that are constant. The declaration `const char *const p2 = p1;` would be read
    as `p2` is a constant pointer to (one or more) characters that are constant.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's move forward to understand the implications of `const` qualifying
    pointers that serve as function parameters or as return values from functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using pointers to constant objects as function arguments and as return types
    from functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copying arguments on the stack that are user defined types can be time-consuming.
    Passing a pointer as a function argument is speedier, yet permits the dereferenced
    object to possibly be modified in the scope of the function. Passing a pointer
    to a constant object as a function argument provides both speed and safety for
    the argument in question. The dereferenced pointer simply may not be an l-value
    in the scope of the function in question. The same principle holds true for the
    return value from a function. Const qualifying the data pointed to insists that
    the caller of the function must also store the return value in a pointer to a
    constant object, ensuring the object's long-term immutability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example to examine these ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter03/Chp3-Ex8.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter03/Chp3-Ex8.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we begin with a global variable to store an initial suffix:
    `char *suffix = ''A'';` and the prototype for the function `const char *genId(const
    char *base);`. In `main()`, we declare but do not initialize `const char* newId1,
    *newId2;`, which will eventually hold the IDs generated by `genId()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we call `genId()` twice, passing a string literal, `"Group"`, to this
    function as the actual parameter. This parameter is received as a formal parameter:
    `const char *base`. The return value of this function will be used to assign values
    to `newId1` and `newId2`, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Looking more closely, we see that the call to `genId("Group")` passes the string
    literal `"Group"` as the actual parameter, which is received as `const char *base`
    in the formal parameter list of the function definition. This means that using
    the identifier `base`, this string may not be modified.
  prefs: []
  type: TYPE_NORMAL
- en: Next, within `genId()`, we declare local pointer variable `temp` on the stack
    and allocate enough heap memory for `temp` to point to, to accommodate the string
    pointed to by `base` plus an extra character for the suffix to be added, plus
    one for the null character to terminate the new string. Note that `strlen()` counts
    the number of characters in a string, excluding the null character. Now, using
    `strcpy()`, `base` is copied into `temp`. Then, using the assignment `temp[strlen(base)]
    = suffix++;`, the letter stored in `suffix` is added to the string pointed to
    by `temp` (and `suffix` is incremented to the next letter for the next time we
    call this function). Remember that arrays are zero-based in C++ when adding characters
    to the end of a given string. For example, if `"Group"` comprises 5 characters
    in array `temp`'s positions 0 through 4, then the next character (from `suffix`)
    will be added at position 5 in `temp` (overwriting the current null character).
    In the next line of code, the null character is re-added to the end of the new
    string pointed to by `temp`, as all strings need to be null-terminated. Note that
    whereas `strcpy()` will automatically null terminate a string, that once you resort
    to single-character replacement, such as by adding the suffix to the string, you
    then need to re-add the null character to the new overall string yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in this function, `temp` is returned. Notice that though `temp` is declared
    as a `char *`, it is returned as a `const char *`. This means that the string
    will be treated in a more restrictive fashion upon its return to `main()` than
    it was treated in the body of the function. In essence, it has been up-cast to
    a `const char *`. The implication is that since the return value of this function
    is a `const char *`, that only a pointer of type `const char *` can capture the
    return value of this function. This is required so that the string cannot be treated
    in a less restrictive fashion than intended by the creator of function `genId()`.
    Had `newId1` and `newId2` been declared of type `char *` rather than `const char
    *`, they would not have been allowed to serve as l-values to capture the return
    value of `genId()`.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of `main()`, we delete the memory associated with `newId1` and `newId2`.
    Notice that the memory for these pointer variables was allocated and released
    in different scopes within the program. The programmer must always be diligent
    to keep track of memory allocation and release in C++. Forgetting to deallocate
    memory can lead to memory leakage within an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output to accompany our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have an understanding of how and why to `const` qualify pointers,
    let's take a look at how and why we might choose a generic pointer type by considering
    void pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Using pointers to objects of unspecified types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes programmers ask why they cannot simply have a generic pointer. That
    is, why must we always declare the type of data that the pointer will eventually
    point to, such as `int *ptr;`? C++ certainly does allow us to create pointers
    without associated types, but C++ then requires the programmer to keep track of
    things that would normally be done on their behalf. Nonetheless, we will see why
    void pointers are useful and what the programmer must undertake when using more
    generic, `void` pointers in this section.
  prefs: []
  type: TYPE_NORMAL
- en: To understand a `void` pointer, let's first consider why a type is typically
    associated with a pointer variable. Typically, declaring the type with the pointer
    gives C++ information about how to conduct pointer arithmetic or index into a
    dynamic array of that pointer type. That is, if we have allocated `int *ptr =
    new int [10];`, we have 10 consecutive integers. Using either array notation of
    `ptr[3] = 5;` or pointer arithmetic of `*(ptr + 3) = 5;` to access one such element
    in this dynamically allocated set relies on the size of the data type `int` to
    internally allow C++ to understand how large each element is and how to move from
    one such item to the next. The data type also tells C++, once it has arrived at
    an appropriate memory address, how to interpret the memory. For example, an `int`
    and a `float` may have the same storage size on a given machine, however, the
    two's complement memory layout of an `int` versus the mantissa, exponent layout
    of a `float` is quite different. C++'s knowledge of how to interpret the given
    memory is crucial and the data type of the pointer does just that.
  prefs: []
  type: TYPE_NORMAL
- en: Still, however, the need exists to have a more generic pointer. For example,
    you may want a pointer that might point to an integer in one situation, yet to
    a set of user defined types in another situation. Using a `void` pointer allows
    just this to happen. But what about type? What happens when you dereference a
    `void` pointer? If C++ does not know how many bytes to go from one element in
    a set to another, how can it index into a dynamically allocated array of `void`
    pointers? How will it interpret the bytes once at an address? What is the type?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that you, the programmer, must personally remember what you are
    pointing to at all times. Without the type associated with the pointer, the compiler
    cannot do this for you. And when it is time to dereference the `void` pointer,
    you will be in charge of correctly remembering the ultimate type involved and
    performing the appropriate type cast on that pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the mechanics and logistics of what is involved.
  prefs: []
  type: TYPE_NORMAL
- en: Creating void pointers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pointers to objects of unspecified types may be specified by using `void *`.
    The `void` pointer may then point to an object of any type. Explicit casting must
    be used in order to dereference actual memory pointed to by the `void *`. Explicit
    casting must also be used in C++ to assign memory pointed to by a `void *` to
    a pointer variable of a known type. It is the programmer's responsibility to ensure
    that the dereferenced data types are the same before making the assignment. Should
    the programmer be incorrect, there will be an elusive pointer mistake to find
    elsewhere in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter03/Chp3-Ex9.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter03/Chp3-Ex9.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the declaration `void *unspecified;` creates an uninitialized
    pointer that may one day point to the memory of any data type. The declaration
    `int *x;` declares a pointer that may someday point to one or more consecutive
    integers.
  prefs: []
  type: TYPE_NORMAL
- en: The assignment `*((int *) unspecified = 89;` first uses an explicit typecast
    to cast `unspecified` to an `(int *)` and then dereferences the `int *` to place
    the value of `89` in memory. It is important to note that this typecast must be
    done before `unspecified` may be dereferenced – otherwise C++ does not understand
    how to interpret the memory `unspecified` points to. Also note, if you accidentally
    typecast `unspecified` to the wrong type, the compiler will let you proceed as
    typecasts are seen as a "*just do it*" command to the compiler. It is your job,
    as the programmer, to remember what type of data your `void *` points to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we would like `x` to point to where `unspecified` points. The variable
    `x` is an integer and needs to point to one or more integers. The variable `unspecified`
    truly points to an integer, but since the data type of unspecified is `void *`,
    we must use an explicit typecast to make the following assignment work: `x = (int
    *) unspecified;`. Also, programmatically, we hope that we are correct that we
    have remembered that `unspecified` truly points to an `int`; knowing the correct
    memory layout is important should the `int *` ever be dereferenced. Otherwise,
    we have just forced an assignment between pointers of different types, leaving
    a lurking error in our program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output to accompany our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There are many creative uses of `void` pointers in C++. There are techniques
    that use `void *` for generic pointer manipulations and pair this inner processing
    with a thin layer on top to cast the data into a known data type. The thin top
    layers can be further genericized with the C++ feature of templates. Using templates,
    only one version of the explicit type casts are maintained by the programmer,
    yet many versions are truly made available on your behalf – one per actual concrete
    data type needed. These ideas encompass advanced techniques, but we will see several
    of them in the chapters ahead, starting with [*Chapter 13*](B15702_13_Final_NM_ePub.xhtml#_idTextAnchor486),
    *Working with Templates*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned many aspects surrounding pointers in C++. We
    have seen how to allocate memory from the heap using `new()` and how to relinquish
    that memory to the heap management facility using `delete()`. We have seen examples
    using both standard and user defined types. We have also understood why we may
    want to dynamically allocate arrays and have seen how to do so for 1, 2, and N
    dimensions. We have seen how to release the corresponding memory using `delete[]`.
    We have reviewed functions by adding pointers as parameters to functions and as
    return values from functions. We have also learned how to `const` qualify pointers
    as well as the data that they point to (or both) and why you may want to do so.
    Lastly, we have seen one way to genericize pointers by introducing `void` pointers.
  prefs: []
  type: TYPE_NORMAL
- en: All of the skills using pointers from this chapter will be used freely in the
    upcoming chapters. C++ expects programmers to have a great facility for using
    pointers. Pointers allow the language great freedom and efficiency to utilize
    a vast number of data structures and to employ creative programming solutions.
    However, pointers can provide a massive way to introduce errors into a program
    with memory leakage, returning pointers to memory that no longer exists, dereferencing
    pointers that have been deleted, and so on. Not to worry, we will utilize many
    examples going forward using pointers so that you will be able to manipulate pointers
    with great facility.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, you are now ready to move forward to [*Chapter 4*](B15702_04_Final_NM_ePub.xhtml#_idTextAnchor169),
    *Indirect Addressing – References*, in which we will explore indirect addressing
    using references. Once you have understood both types of indirect addressing –
    pointers and references – and can manipulate either with ease, we will take on
    the core Object-Oriented concepts in this book, starting in [*Chapter 5*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199),
    *Exploring Classes in Detail*.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modify and augment your C++ program from [*Chapter 2*](B15702_02_Final_NM_ePub.xhtml#_idTextAnchor066),
    *Adding Language Necessities*, *Exercise 2* as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Create a function, `ReadData()`, which accepts a pointer to a `Student` as
    an argument to allow `firstName`, `lastName`, `gpa`, and `currentCourseEnrolled`
    to be entered from the keyboard within the function and stored as the input parameter's
    data.
  prefs: []
  type: TYPE_NORMAL
- en: b. Modify `firstName`, `lastName`, and `currentCourseEnrolled` to be modeled
    as `char *` in your `Student` class instead of using fixed-sized arrays (as they
    may have been modeled in [*Chapter 2*](B15702_02_Final_NM_ePub.xhtml#_idTextAnchor066),
    *Adding Language Necessities*). You may utilize a `temp` variable, which is a
    fixed size, to initially capture user input for these values, and then allocate
    the proper, respective sizes for each of these data members.
  prefs: []
  type: TYPE_NORMAL
- en: c. Rewrite, if necessary, the `Print()` function from your solution in [*Chapter
    2*](B15702_02_Final_NM_ePub.xhtml#_idTextAnchor066), *Adding Language Necessities*
    to take a `Student` as a parameter for `Print()`.
  prefs: []
  type: TYPE_NORMAL
- en: d. Overload the `Print()` function with one that takes a `const Student *` as
    a parameter. Which one is more efficient? Why?
  prefs: []
  type: TYPE_NORMAL
- en: e. In `main()`, create an array of pointers to `Student` to accommodate 5 students.
    Allocate each `Student`, call `ReadData()` for each `Student`, and then `Print()`
    each `Student` using a selection from your above functions. When done, remember
    to `delete()` the `memory` for each student `allocated`.
  prefs: []
  type: TYPE_NORMAL
- en: 'f. Also in `main()`, create an array of `void` pointers that is the same size
    as the array of pointers to `Student`. Set each element in the array of `void`
    pointers to point to a corresponding `Student` from the array of `Student` pointers.
    Call the version of `Print()` that takes a `const Student *` as a parameter for
    each element in the `void *` array. Hint: you will need to cast `void *` elements
    to type `Student *` prior to making certain assignments and function calls.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following pointer declarations, which include a `const` qualification:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a. Write a declaration for a pointer to a constant object. Assume the object
    is of type `Student`. Hint: read your declaration from right to left to verify
    its correctness.'
  prefs: []
  type: TYPE_NORMAL
- en: b. Write a declaration for a constant pointer to a non-constant object. Again,
    assume the object is of type `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: c. Write a declaration for a constant pointer to a constant object. The object
    will again be of type `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: Why does passing an argument of type `const Student *` to `Print()` in your
    program above make sense, and why would passing a parameter of type `Student *
    const` not make sense?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you think of programming situations that may require a dynamically allocated
    3-D array? What about a dynamically allocated array with more dimensions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

- en: '*Chapter 4*: Indirect Addressing: References'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will examine how to utilize references in C++. References can often,
    but not always, be used as an alternative to pointers for indirect addressing.
    Though you have prior experience with indirect addressing from our last chapter
    using pointers, we will start at the beginning to understand C++ references.
  prefs: []
  type: TYPE_NORMAL
- en: References, like pointers, are a language feature you must be able to utilize
    with ease. Many other languages use references for indirect addressing without
    requiring a thorough understanding that C++ imposes to correctly utilize both
    pointers and references. Just as with pointers, you will see references frequently
    used throughout code from other programmers. You may be pleased that using references
    will provide notational ease when writing applications compared to pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, references cannot be used as a substitute for pointers in all
    situations requiring indirect addressing. Therefore, a thorough understanding
    of indirect addressing using both pointers and references is a necessity in C++
    to create successful and maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter will be to complement your understanding of indirect
    addressing using pointers with knowing how to use C++ references as an alternative.
    Understanding both techniques of indirect addressing will enable you to be a better
    programmer, easily able to understand and modify other's code and write original,
    mature, and competent C++ code yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reference basics – declaring, initializing, accessing, and referencing existing
    objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using references with functions as arguments and as return values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the const qualifier with references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding underlying implementation, and when references cannot be used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand how to declare, initialize,
    and access references; you will understand how to reference existing objects in
    memory. You will be able to use references as arguments to functions, and understand
    how they may be used as return values from functions.
  prefs: []
  type: TYPE_NORMAL
- en: You will also fathom how the const qualifier may apply to references as variables,
    and be utilized with both a function's parameters and return type. You will be
    able to distinguish when references can be used in lieu of pointers, and which
    situations they cannot provide a substitute for pointers. These skills will be
    necessary in order to move forward with the next chapters in the book successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found at the following GitHub
    URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master/Chapter04).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter04` in a file named `Chp4-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/2OM7GJP](https://bit.ly/2OM7GJP)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding reference basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will revisit reference basics as well as introduce operators
    applicable to references, such as the reference operator `&`. We will employ the
    reference operator `&` to establish a reference to the existing variable. Like
    pointer variables, reference variables refer to memory that is defined elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Using reference variables allows us to use a more straightforward notation than
    pointers use when using indirectly accessed memory. Many programmers appreciate
    the clarity in the notation of a reference versus a pointer variable. But, behind
    the scenes, memory must always be properly allocated and released; some portion
    of memory that is referenced may come from the heap. The programmer will undoubtedly
    need to deal with pointers for some portion of their overall code.
  prefs: []
  type: TYPE_NORMAL
- en: We will discern when references and pointers are interchangeable, and when they
    are not. Let's get started with the basic notation for declaring and using reference
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring, initializing, and accessing references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's begin with the meaning of a reference variable. A C++ `&`. A reference
    must be initialized (at declaration) and may never be assigned to reference another
    object. The reference and the initializer must be of the same type. Since the
    reference and the object being referenced share the same memory, either variable
    may be used to modify the contents of the shared memory location.
  prefs: []
  type: TYPE_NORMAL
- en: A reference variable, behind the scenes, can be compared to a pointer variable—in
    that it holds the address of the variable that it is referencing. Unlike a pointer
    variable, any usage of the reference variable automatically dereferences the variable
    to go to the address that it contains; the dereference operator `*` is simply
    not needed with references. Dereferencing is automatic and implied with each use
    of a reference variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example illustrating reference basics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we first declare and initialize `int x = 10;` and
    then declare and allocate `int *p = new int;`. We then assign the integer value
    20 to `*p`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare and initialize two reference variables, `refInt1` and `refInt2`.
    In the first reference declaration and initialization, `int &refInt1 = x;`, we
    establish `refInt1` to refer to variable `x`. It helps to read the reference declaration
    from right to left. Here, we are saying to use `x` to initialize `refInt1`, which
    is a reference (`&`) to an integer. Notice that both the initializer, `x`, is
    an integer, and that `refInt1` is declared to be a reference to an integer; their
    types match. This is important. The code will not compile if the types differ.
    Likewise, the declaration and initialization `int &refInt2 = *p;` also establishes
    `refInt2` as a reference to an integer. Which one? The one pointed to by `p`.
    This is why `p` is dereferenced using `*` to go to the integer itself.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we print out `x`, `*p`, `refInt1`, and `refInt2`; we can verify that `x`
    and `refInt1` have the same value of `10`, and `*p` and `refInt2` also have the
    same value of `20`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, using the original variables, we increment both `x` and `*p` by one. Not
    only does this increment the values of `x` and `*p`, but the values of `refInt1`
    and `refInt2`. Repeating the printing of these four values, we again notice that
    `x` and `refInt1` have the value of `11`, while `*p` and `refInt2` have the value
    of `21`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use the reference variables to increment the shared memory. We increment
    both `refInt1` and `*refint2` by one and this also increments the values of the
    original variables `x` and `*p`. This is because the memory is one and the same
    between the original variable and the reference to that variable. That is, the
    reference can be thought of as an alias to the original variable. We conclude
    the program by again printing out the four variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Remember, a reference variable must be initialized to the variable it will refer
    to. The reference may never be assigned to another variable. The reference and
    its initializer must be the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a handle on how to declare simple references, let's take a
    more complete look at referencing existing objects, such as those to user defined
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing existing objects of user defined types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Should a reference to an object of a `struct` or `class` type be defined, the
    object being referenced is simply accessed using the `.` (member selection operator).
    Again, it is not necessary (as it is with pointers) to first use the dereference
    operator to go to the object being referenced before choosing the desired member.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example in which we reference a user defined type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the first part of this program, we define a user defined type, `Student`,
    using a `class`. Next, we declare a variable `s1` of type `Student` using `Student
    s1;`. Now, we declare and initialize a reference to a `Student` using `Student
    &sRef = s1;`. Here, we declare `sRef` to reference a specific `Student`, namely,
    `s1`. Notice that both `s1` is of type `Student` and the reference type of `sRef`
    is also that of type `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we load some initial data into `s1` using `strcpy()`, followed by a simple
    assignment. Consequently, this alters the value of `sRef` since `s1` and `sRef`
    refer to the same memory. That is, `sRef` is an alias for `s1`.
  prefs: []
  type: TYPE_NORMAL
- en: We print out various data members for `s1` and `sRef` and notice that they contain
    the same values.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we load new values into `sRef`, also using `strcpy()`, and a simple assignment.
    Similarly, we print out various data members for `s1` and `sRef` and notice that
    again, the values for both have changed. Again, we can see that they reference
    the same memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output to accompany this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let's now move forward with our understanding of references by considering their
    usage in functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using references with functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have minimally demonstrated references by using them to establish
    an alias for an existing variable. Instead, let's put forth a meaningful use of
    references, such as when they are used in function calls. We know most functions
    in C++ will take arguments, and we have seen many examples in the previous chapters
    illustrating function prototypes and function definitions. Now, let's augment
    our understanding of functions by passing references as arguments to functions,
    and using references as return values from functions.
  prefs: []
  type: TYPE_NORMAL
- en: Passing references as arguments to functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: References may be used as arguments to functions to achieve call-by-reference,
    rather than call-by-value parameter passing. References can alleviate the need
    for pointer notation in the scope of the function in question as well as in the
    call to that function. Object or `.` (member selection) notation is used to access
    `struct` or `class` members for formal parameters that are references.
  prefs: []
  type: TYPE_NORMAL
- en: In order to modify the contents of a variable passed as an argument to a function,
    a reference (or pointer) to that argument must be used as a function parameter.
    Just as with a pointer, when a reference is passed to a function, a copy of the
    address representing the reference is passed to the function. However, within
    the function, any usage of a formal parameter that is a reference will automatically
    and implicitly be dereferenced, allowing the user to use object rather than pointer
    notation. As with passing a pointer variable, passing a reference variable to
    a function will allow the memory referenced by that parameter to be modified.
  prefs: []
  type: TYPE_NORMAL
- en: When examining a function call (apart from its prototype), it will not be obvious
    if an object passed to that function is passed by value or by reference. That
    is, whether the entire object will be copied on the stack or if a reference to
    that object will instead be passed on the stack. This is because object notation
    is used when manipulating references and the function calls for these two scenarios
    will use the same syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Diligent use of function prototypes will solve the mystery of what a function
    definition looks like and whether its arguments are objects or references to objects.
    Remember, a function definition may be defined in a separate file from any calls
    to that function, and not be easily available to view. Note that this ambiguity
    does not come up with pointers specified in a function call; it is immediately
    obvious that an address is being sent to a function based on how the variable
    is declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a few minutes to understand an example illustrating passing references
    as arguments to functions. Here, we will begin by examining three functions that
    contribute to the following full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master/Chapter04/Chp4-Ex3.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Examining the functions above, notice that `AddOne(int &arg)` takes a reference
    to an `int` as a formal parameter, while `AddOne(int *arg)` takes a pointer to
    an `int` as a formal parameter. These functions are overloaded. The types of their
    actual parameters will determine which version is called.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's consider `Display(int &arg)`. This function takes a reference to an
    integer. Notice that object (not pointer) notation is used to print `arg` within
    this function's definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s examine the remainder of this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice the function prototypes at the top of this program segment. They will
    match the function definitions in the previous segment of code. Now, in the `main()`
    function, we declare and initialize `int x = 10;` and declare a pointer `int *y;`.
    We allocate the memory for `y` using `new()` and then assign a value by dereferencing
    the pointer with `*y = 15;`. We print out the respective values of `x` and `*y`
    as a baseline using successive calls to `Display()`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call `AddOne(x)` followed by `AddOne(*y)`. Variable `x` is declared
    to be an integer and `*y` refers to the integer pointed to by `y`. In both cases,
    we are passing integers as actual parameters to the version of the overloaded
    function with the signature `void AddOne(int &);`. In both cases, the formal parameters
    will be changed in the function, as we are passing by reference. We can verify
    this when their respective values are next printed using successive calls to `Display()`.
    Note that in the function call `AddOne(x);`, the reference to the actual parameter
    `x` is established by the formal parameter `arg` (in the function's parameter
    list) at the time of the function call.
  prefs: []
  type: TYPE_NORMAL
- en: In comparison, we then call `AddOne(&x);` followed by `AddOne(y);`. In both
    cases, we are calling the overloaded version of this function with the signature
    `void AddOne(int *);`. In each case, we are passing a copy of an address as the
    actual parameter to the function. Naturally, `&x` is the address of variable `x`,
    so this works. Likewise, `y` itself is an address – it is declared as a pointer
    variable. We again verify that their respective values are again changed with
    two calls to `Display()`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice, in each call to `Display()`, we pass an object of type `int`. Looking
    at the function call alone, we cannot determine whether this function will take
    an `int` as an actual parameter (which would imply the value could not be changed),
    or an `int &` as an actual parameter (which would imply that the value could be
    modified). Either of these are possibilities. However, by looking at the function
    prototype, we can clearly see that this function takes an `int &` as a parameter,
    and from this, we understand that the parameter may likely be modified. This is
    one of the many reasons function prototypes are helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output for the full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's add to our discussion of using references with functions by using
    references as return values from functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using references as return values from functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions may return references to data via their return statements. We will
    see a requirement to return data by reference when we overload operators for user
    defined types in [*Chapter 12*](B15702_12_Final_NM_ePub.xhtml#_idTextAnchor453),
    *Friends and Operator Overloading*. With operator overloading, returning a value
    from a function using a pointer will not be an option to preserve the operator's
    original syntax; we must return a reference (or a reference qualified with const).
    Additionally, understanding how to return objects by reference will be useful
    as we explore the C++ Standard Template Library in [*Chapter 14*](B15702_14_Final_NM_ePub.xhtml#_idTextAnchor518),
    *Understanding STL Basics*.
  prefs: []
  type: TYPE_NORMAL
- en: When returning a reference via the return statement of a function, be sure that
    the memory that is referred to will persist after the function call is completed.
    Do **not** return a reference to a local variable defined on the stack within
    the function; this memory will be popped off the stack the moment the function
    completes.
  prefs: []
  type: TYPE_NORMAL
- en: Since we cannot return a reference to a local variable within the function,
    and since returning a reference to an external variable is pointless, you may
    ask where will the data that we return a reference to reside? This data will inevitably
    be on the heap. Heap memory will exist past the extent of the function call. In
    most circumstances, the heap memory will have been allocated elsewhere; however,
    on rare occasions, the memory may have been allocated within this function. In
    this situation, you must remember to relinquish the allocated heap memory when
    it is no longer required.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting heap memory through a reference (versus pointer) variable will require
    you to use the address-of operator `&` to pass the required address to operator
    `delete()`. Even though reference variables contain the address of the object
    they are referencing, the use of a reference identifier is always in its dereferenced
    state. It is rare that the need may arise to delete memory using a reference variable;
    we will discuss a meaningful (yet rare) example in [*Chapter 10*](B15702_10_Final_NM_ePub.xhtml#_idTextAnchor386),
    *Implementing Association, Aggregation, and Composition*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example to illustrate the mechanics of using a reference as a
    return value from a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex4.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master/Chapter04/Chp4-Ex4.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we see `int &CreateId();` prototyped towards the top of the
    program. This tells us that `CreateId()` will return a reference to an integer.
    The return value must be used to initialize a variable of type `int &`.
  prefs: []
  type: TYPE_NORMAL
- en: Towards the bottom of the program, we see the function definition for `CreateId()`.
    Notice that this function first declares a `static` counter, which is initialized
    exactly once to `100`. Because this local variable is `static`, it will preserve
    its value from function call to function call. We then increment this counter
    by one a few lines later. The static variable, `count`, will be used as a basis
    to generate a unique ID.
  prefs: []
  type: TYPE_NORMAL
- en: Next in `CreateId()`, we allocate space for an integer on the heap and point
    to it using the local variable `memory`. We then load `*memory` with the value
    of `count` and then increase `count` for the next time we enter this function.
    We then use `*memory` as the return value of this function. Notice that `*memory`
    is an integer (the one pointed to on the heap by the variable `memory`). When
    we return it from the function, it is returned as a reference to that integer.
    When returning a reference from a function, always ensure that the memory that
    is referenced exists beyond the extent of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at our `main()` function. Here, we initialize a reference
    variable `id1` with the return value of our first call to `CreateId()` in the
    following function call and initialization: `int &id1 = CreateId();`. Note that
    the reference `id1` must be initialized when it is declared, and we have met that
    requirement with the aforementioned line of code.'
  prefs: []
  type: TYPE_NORMAL
- en: We repeat this process with `id2`, initializing this reference with the return
    value of `CreateId()`. We then print both `id1` and `id2`. By printing both `id1`
    and `id2`, you can see that each id variable has its own memory and maintains
    its own data values.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we must remember to deallocate the memory that `CreateId()` allocated
    on our behalf. We must use operator `delete()`. Wait, operator `delete()` expects
    a pointer to the memory that will be deleted. Variables `id1` and `id2` are both
    references, not pointers. True, they each contain an address because each is inherently
    implemented as a pointer, but any use of their respective identifiers is always
    in a dereferenced state. To circumvent this dilemma, we simply take the address
    of reference variables `id1` and `id2` prior to calling `delete()`, such as `delete
    &id1;`. It is *rare* that you would need to delete memory via a reference variable,
    but now you know how to do so should the need arise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for this example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that we understand how references can be used within parameters to functions
    and as return values from functions, let's move forward by examining further reference
    nuances.
  prefs: []
  type: TYPE_NORMAL
- en: Using the const qualifier with references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `const` qualifier can be used to qualify the data in which references are
    initialized or *refer to*. We can also use `const` qualified references as arguments
    to functions and as return values from functions.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that a reference is implemented as a constant
    pointer in C++. That is, the address contained within the reference variable is
    a fixed address. This explains why a reference variable must be initialized to
    the object that it will refer to, and may not later be updated using an assignment.
    This also explains why constant qualifying the reference itself (and not just
    the data that it refers to) does not make sense. This variety of `const` qualification
    is already implied with its underlying implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at these various scenarios using `const` with references.
  prefs: []
  type: TYPE_NORMAL
- en: Using references to constant objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `const` qualifier can be used to indicate that the data in which references
    are initialized to are unmodifiable. In this fashion, the alias always refers
    to a fixed piece of memory, and the value of that variable may not be changed
    using the alias itself. The reference, once specified as constant, implies neither
    the reference nor its value may be changed. Again, the reference itself may not
    be changed due to its underlying implementation as a constant qualified pointer.
    A `const` qualified reference may not be used as an *l-value* in any assignment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Recall, an l-value means a value that can be modified, and that occurs on the
    left-hand side of an assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s introduce a simple example to understand the situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex5.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master/Chapter04/Chp4-Ex5.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, notice that we declare `int x = 5;` and then we establish
    a constant reference to that integer with the declaration `const int &refInt =
    x;`. Next, we print out both values for a baseline and notice that they are identical.
    This makes sense, they reference the same integer memory.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the commented-out piece of code, `//refInt = 6;`, we try to modify
    the data that the reference refers to. Because `refInt` is qualified as `const`,
    this is illegal; hence this is the reason why we commented out this line of code.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the following line of code, we assign `x` a value of `7`. Since
    `refInt` refers to this same memory, its value will also be modified. Wait, isn't
    `refInt` constant? Yes, by qualifying `refInt` as `const`, we are indicating that
    its value will not be modified using the identifier `refInt`. This memory can
    still be modified using `x`.
  prefs: []
  type: TYPE_NORMAL
- en: But wait, isn't this a problem? No, if `refInt` truly wants to refer to something
    unmodifiable, it can instead initialize itself with a `const int`, not an `int`.
    This subtle point is something to remember in C++ so you can write code for exactly
    the scenario you intend to have, understanding the significance and consequences
    of each choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for this example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's see a variation on the `const` qualification theme.
  prefs: []
  type: TYPE_NORMAL
- en: Using pointers to constant objects as function arguments and as return types
    from functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using `const` qualification with function parameters can allow the speed of
    passing an argument by reference, but the safety of passing an argument by value.
    It is a useful feature in C++.
  prefs: []
  type: TYPE_NORMAL
- en: A function that takes a reference to an object as a parameter often has less
    overhead than a comparable version of the function that takes a copy of an object
    as a parameter. This most notably occurs when the object type that would be otherwise
    copied on the stack is large. Passing a reference as a formal parameter is speedier,
    yet permits the actual parameter to be potentially modified in the scope of the
    function. Passing a reference to a constant object as a function argument provides
    both speed and safety for the argument in question. The reference qualified as
    `const` in the parameter list simply may not be an l-value in the scope of the
    function in question.
  prefs: []
  type: TYPE_NORMAL
- en: The same benefit of `const` qualified references exists for the return value
    from a function. Constant qualifying the data referenced insists that the caller
    of the function must also store the return value in a reference to a constant
    object, ensuring the object may not be modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex6.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master/Chapter04/Chp4-Ex6.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first define a simple `class Collection` with data members
    `x` and `y`. Next, we prototype `Update(Collection &);` and `Print(const Collection
    &);`. Notice that `Print()` constant qualifies the data being referenced as the
    input parameter. This means that this function will enjoy the speed of passing
    this parameter by reference, but the safety of passing the parameter by value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice, towards the end of the program, we see the definitions for both `Update()`
    and `Print()`. Both take references as arguments, however, the parameter to `Print()`
    is constant qualified: `void Print(const Collection &);`. Notice that both functions
    use `.` (member selection) notation within each function body to access the relevant
    data members.'
  prefs: []
  type: TYPE_NORMAL
- en: In `main()`, we declare two variables, `collect1` of type `Collection`, and
    `collect2`, which is a pointer to a `Collection` (and whose memory is subsequently
    allocated). We call `Update()` for both `collect1` and `*collect2`, and in each
    case, a reference to the applicable object is passed to the `Update()` function.
    In the case of `collect2`, which is a pointer variable, the actual parameter must
    first dereference `*collect2` to go to the object being referenced, before calling
    this function.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in `main()`, we call `Print()` successively for both `collect1` and
    `*collect2`. Here, `Print()` will reference each object serving as a formal parameter
    as constant qualified referenced data, ensuring that no modifications of either
    input parameter are possible within the scope of the `Print()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output to accompany our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have an understanding of when `const` qualified references are useful,
    let's take a look at when we can use references in lieu of pointers, and when
    we may not.
  prefs: []
  type: TYPE_NORMAL
- en: Realizing underlying implementation and restrictions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: References can ease the notation required for indirect referencing. However,
    there are situations in which references simply cannot take the place of pointers.
    To understand these situations, it is useful to review the underlying implementation
    of a reference in C++.
  prefs: []
  type: TYPE_NORMAL
- en: References are implemented as constant pointers, hence they must be initialized.
    Once initialized, references may not refer to a different object (though the value
    of the object being referenced can be changed).
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the implementation, let''s consider a sample reference declaration:
    `int &intVar = x;`. From an implementation aspect, it is as though the former
    variable declaration is instead declared as `int *const intVar = &x;`. Note that
    the `&` symbol shown on the left-hand side of an initialization takes on the meaning
    of reference, whereas the `&` symbol shown on the right-hand side of an initialization
    or assignment implies address-of. These two declarations illustrate how a reference
    is defined versus its underlying implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's understand in which situations we cannot use references.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding when we must use pointers instead of references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Based on the underlying implementation of references (as `const` pointers),
    most of the restrictions for reference usage make sense. For example, references
    to references are not allowed; each level of indirection would need to be initialized
    upfront and that often takes multiple steps, such as when using pointers. Arrays
    of references are also not permitted (each element would need to be initialized
    immediately); nonetheless, arrays of pointers are always an option. Also, pointers
    to references are not permitted; however, references to pointers are permitted
    (as are pointers to pointers).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the mechanics of an interesting allowable reference case
    that we have not yet explored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter04/Chp4-Ex7.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master/Chapter04/Chp4-Ex7.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we declare `int *ptr;` and then allocate the memory for `ptr`
    (consolidated on one line). We then assign a value of `20` to `*p`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we declare `int *&refPtr = ptr;`, which is a reference to a pointer of
    type `int`. It helps to read the declaration right to left. As such, we use `ptr`
    to initialize `refPtr`, which is a reference to a pointer to an `int`. In this
    case, the two types match: `ptr` is a pointer to an `int`, so that `refPtr` must
    also then reference a pointer to an `int`. We then print out both the value of
    `*ptr` and `*refPtr` and can see that they are the same.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output to accompany our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With this example, we have seen yet another interesting use of references. We
    also understand the restrictions placed upon using references, all of which are
    driven by their underlying implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned numerous aspects of C++ references. We have
    taken the time to understand reference basics, such as declaring and initializing
    reference variables to existing objects, as well as how to access reference components
    for basic and user defined types.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to utilize references in a meaningful fashion with functions,
    both as input parameters and as a return value. We have also seen when it is reasonable
    to apply the `const` qualifier to references, as well as see how this concept
    can be combined with parameters and return values from functions. Lastly, we have
    seen the underlying implementation of references. This has helped explain some
    of the restrictions references encompass, as well as helping us to understand
    which cases of indirect addressing will require the use of pointers instead of
    references.
  prefs: []
  type: TYPE_NORMAL
- en: As with pointers, all of the skills using references from this chapter will
    be used freely in the upcoming chapters. C++ allows programmers to have a more
    convenient notation for indirect addressing using references; however, programmers
    are expected to utilize either for indirect addressing with relative ease.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you are now ready to move forward to [*Chapter 5*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199),
    *Exploring Classes in Detail*, in which we begin the object-oriented features
    of C++. This is what we have been waiting for; let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modify and augment your C++ program from [*Chapter 3*](B15702_03_Final_NM_ePub.xhtml#_idTextAnchor112),
    *Indirect Addressing – Pointers*, *Exercise 1*, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Overload your `ReadData()` function with a version that accepts a `Student
    &` parameter to allow `firstName`, `lastName`, `currentCourseEnrolled`, and `gpa`
    to be entered from the keyboard within the function.
  prefs: []
  type: TYPE_NORMAL
- en: b. Replace the `Print()` function, which takes a `Student` from your previous
    solution, to instead take a `const` `Student &` as a parameter for `Print()`.
  prefs: []
  type: TYPE_NORMAL
- en: c. Create variables of type `Student` and of type `Student *` in `main()`. Now,
    call the various versions of `ReadData()` and `Print()`. Do the pointer variables
    necessarily need to call the versions of these functions that accept pointers,
    and do the non-pointer variables necessarily need to call the versions of these
    functions that accept references? Why or why not?
  prefs: []
  type: TYPE_NORMAL

- en: '*Chapter 5*: Exploring Classes in Detail'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will begin our pursuit of **object-oriented programming** (**OOP**)
    in C++. We will begin by introducing **object-oriented** (**OO**) concepts, and
    then progress to understanding how these concepts can be implemented in C++. Many
    times, implementing OOP ideas will be done through *direct language support*,
    such as the features in this chapter. Sometimes, however, we will utilize various
    programming techniques to implement object-oriented concepts. These techniques
    will be seen in later chapters. In all cases, it is important to understand the
    object-oriented concepts and how these concepts relate to well-thought-out designs,
    and then have a clear understanding of how to implement these designs with robust
    code.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will detail C++ class usage in extreme detail. Subtle features
    and nuances are detailed beyond the basics. The goal of this chapter will be to
    get you to understand OO concepts, and for you to begin to think in terms of object-oriented
    programming. Embracing core OO ideals, such as encapsulation and information hiding,
    will allow you to write code that is easier to maintain, and will allow you to
    modify others' code more easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining object-oriented terminology and concepts – object, class, instance,
    encapsulation, and information hiding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying class and member function basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining member function internals; the "this" pointer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using access labels and access regions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding constructors – default, overloaded, copy, and conversion constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding destructors and their proper usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying qualifiers to data members and member functions – inline, const, and
    static
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand core object-oriented terminology
    applicable to classes, and how key OO ideas, such as encapsulation and information
    hiding, will lead to software that is easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: You will also appreciate how C++ provides built-in language features to support
    object-oriented programming. You will become well versed in the use of member
    functions, and will understand their underlying implementation through the `this`
    pointer. You will understand how to correctly use access labels and access regions
    to promote encapsulation and information hiding.
  prefs: []
  type: TYPE_NORMAL
- en: You will understand how constructors can be used to initialize objects, and
    the many varieties of constructors from basic to typical (overloaded) to the copy
    constructor, and even conversion constructors. Similarly, you will understand
    how to make proper use of the destructor prior to an object's end of existence.
  prefs: []
  type: TYPE_NORMAL
- en: You will also understand how qualifiers, such as const, static, and inline,
    may be applied to member functions to support either object-oriented concepts
    or efficiency. Likewise, you will understand how to apply qualifiers, such as
    const and static, to data members to additionally support OO ideals.
  prefs: []
  type: TYPE_NORMAL
- en: C++ can be used as an object-oriented programming language, but it is not automatic.
    To do so, you must understand OO concepts, ideology, and language features that
    will allow you to support this endeavor. Let us begin our pursuit of writing code
    that is easier to modify and maintain by understanding the core and essential
    building block and language feature found in object-oriented C++ OO programs,
    the C++ class.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for the full program examples can be found at the following GitHub
    URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master/Chapter05).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter05` in a file named `Chp5-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/2OQgiz9](https://bit.ly/2OQgiz9).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing object-oriented terminology and concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will introduce core object-oriented concepts as well as
    applicable terminology that will accompany these key ideas. Though new terms will
    come up throughout this chapter, we will begin with the terms necessary to understand
    to begin our journey in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented systems are inherently more easily maintained because upgrades
    and modifications to user defined types can be made quickly, and without impact
    to the entire system, due to encapsulation and information hiding.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started with basic object-oriented terminology.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding object-oriented terminology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will begin with basic object-oriented terminology, and then as we introduce
    new concepts, we will extend the terminology to include C++ specific terminology.
  prefs: []
  type: TYPE_NORMAL
- en: The terms object, class, and instance are all important and related terms with
    which we can start our definitions. An **object** embodies a meaningful grouping
    of characteristics and behaviors. An object can be manipulated and can receive
    the action or consequences of a behavior. Objects may undergo transformations
    and can change repeatedly over time. Objects can interact with other objects.
  prefs: []
  type: TYPE_NORMAL
- en: The term object, at times, may be used to describe the blueprint for groupings
    of like items. The term **class** may be used interchangeably with this usage
    of an object. The term object may also (and more often) be used to describe a
    specific item in such a grouping. The term **instance** may be used interchangeably
    with this meaning of an object. The context of usage will often make clear which
    meaning of the term *object* is being applied. To avoid potential confusion, the
    terms *class* and *instance* can preferably be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider some examples, using the aforementioned terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_5.1_B15930.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Objects also have components. The characteristics of a class are referred to
    as **attributes**. Behaviors of a class are referred to as **operations**. The
    specific implementation of a behavior or operation is referred to as its **method**.
    In other words, the method is how an operation is implemented, or the body of
    code defining the function, whereas the operation is the function's prototype
    or protocol for usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider some high-level examples, using the aforementioned terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_5.2_B15930.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each instance of a class will most likely have distinct values for its attributes.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_5.3_B15930.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have the basic OO terms under our belt, let's move on to important
    object-oriented concepts that are relevant to this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding object-oriented concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key object-oriented concepts relating to this chapter are *encapsulation*
    and *information hiding*. Incorporating these interrelated ideas into your design
    will provide the basis for writing more easily modifiable and maintainable programs.
  prefs: []
  type: TYPE_NORMAL
- en: The grouping of meaningful characteristics (attributes) and behaviors (operations)
    that operate on those attributes, bundled together in a single unit, is known
    as **encapsulation**. In C++, we typically group these items together in a class.
    The interface to each class instance is made through operations that model the
    behaviors relevant to each class. These operations may additionally modify the
    internal state of the object by changing the values of its attributes. Concealing
    attributes within a class and providing an interface for operating on those details
    leads us to explore the supportive concept of information hiding.
  prefs: []
  type: TYPE_NORMAL
- en: '**Information hiding** refers to the process of *abstracting* the details of
    performing an operation into a class method. That is, the user needs only to understand
    which operation to utilize and its overall purpose; the implementation details
    are hidden within the method (the function''s body). In this fashion, changing
    the underlying implementation (method) will not change the operation''s interface.
    Information hiding can additionally refer to keeping the underlying implementation
    of a class'' attributes hidden. We will explore this further when we introduce
    access regions. Information hiding is a means to achieve proper encapsulation
    of a class. A properly encapsulated class will enable proper class abstraction
    and thus the support of OO designs.'
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented systems are inherently more easily maintained because classes
    allow upgrades and modifications to be made quickly and without impact to the
    entire system due to encapsulation and information hiding.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding class and member function basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A C++ **class** is a fundamental building block in C++ that allows a programmer
    to specify a user defined type, encapsulating related data and behaviors. A C++
    class definition will contain attributes, operations, and sometimes methods. C++
    classes support encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a variable of a class type is known as **instantiation**. The attributes
    in a class are known as **data members** in C++. Operations in a class are known
    as **member functions** in C++, and are used to model behaviors. In OO terms,
    an operation implies the signature of a function, or its prototype (declaration),
    and the method implies its underlying implementation or the body of the function
    (definition). In some OO languages, the term *method* is used more loosely to
    imply either the operation or its method, based on the context of usage. In C++,
    the terms *data member* and *member function* are most often used.
  prefs: []
  type: TYPE_NORMAL
- en: The prototype for a member function must be placed in a class definition. Most
    often, the member function definition is placed outside of the class definition.
    The scope resolution operator `::` is then used to associate a given member function
    definition to the class of which it is a member. Dot `.` or arrow `->` notation
    is used to access all class members, including member functions, depending on
    whether we are accessing members through an instance or through a pointer to an
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: C++ structures may also be used to encapsulate data and their related behaviors.
    A C++ `struct` can do anything a C++ `class` can do; in fact, `class` is implemented
    in terms of `struct` in C++. Though structures and classes may behave identically
    (other than default visibility), classes are more often used to model objects,
    model relationships between object types, and implement object-oriented systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple example in which we instantiate a `class` and
    a `struct`, each with member functions, for comparison with one another. We will
    break this example into several segments. The full program example can be found
    in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we first define a `student` type using a `struct`,
    and a `University` type using a `class`. Notice, by convention, that user defined
    types created using structures are not capitalized, yet user defined types created
    using classes begin with a capital letter. Also notice that the `class` definition
    requires the label `public:` toward the beginning of its definition. We will explore
    the use of this label later in this chapter; however, for now the `public` label
    is present so that this `class` will have the same default visibility of its members
    as does the `struct`.
  prefs: []
  type: TYPE_NORMAL
- en: In both the `class` and `struct` definitions, notice the function prototypes
    for `Initialize()` and `Print()`. We will tie these prototypes to member function
    definitions in the next program segment using `::`, the scope resolution operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the various member function definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's review the various member function definitions for each user defined
    type. The definitions for `void student::Initialize(const char *, float)`, `void
    student::Print()`, `void University::Initialize(const char *, int)`, and `void
    University::Print()` appear consecutively in the above fragment. Notice how the
    scope resolution operator `::` allows us to tie the relevant function definition
    back to the `class` or `struct` of which it is a member.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, notice that in each `Initialize()` member function, the input
    parameters are used as values to load the relevant data members for a specific
    instance of a specific class type. For example, in the function definition of
    `void University::Initialize(const char *n, int num)`, the input parameter `num`
    is used to initialize `numStudents` for a particular `University` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The scope resolution operator `::` associates member function definitions with
    the class (or struct) of which they are a member.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how member functions are called by considering `main()` in this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, in `main()`, we simply define a variable, `s1`, of type `student` and
    a variable, `u1`, of type `University`. In object-oriented terms, it is preferable
    to say that `s1` is an instance of `student`, and `u1` is an instance of `University`.
    The instantiation occurs when the memory for an object is made available. For
    this reason, declaring the pointer variable `u2` using `University *u2;` does
    not instantiate a `University`; it merely declares a pointer to a possible future
    instance. Rather, on the following line, `u2 = new University();`, we instantiate
    a `University` when the memory is allocated.
  prefs: []
  type: TYPE_NORMAL
- en: For each of the instances, we initialize their data members by calling their
    respective `Initialize()` member functions, such as `s1.Initialize("Gabby Doone",
    4.0);` or `u1.Initialize("UMD", 4500);`. We then call `Print()` through each respective
    instance, such as `u2->Print();`. Recall that `u2->Print();` may also be written
    as `(*u2).Print();`, which more easily allows us to remember that the instance
    here is `*u2`, whereas `u2` is a pointer to that instance.
  prefs: []
  type: TYPE_NORMAL
- en: Notice, when we call `Initialize()` through `s1`, we call `student::Initialize()`
    because `s1` is of type `student`, and we initialize `s1`'s data members in the
    body of this function. Similarly, when we call `Print()` through `u1` or `*u2`,
    we call `University::Print()` because `u1` and `*u2` are of type `University`
    and we subsequently print out a particular university's data members.
  prefs: []
  type: TYPE_NORMAL
- en: Since the instance `u1` was dynamically allocated on the heap, we are responsible
    for releasing its memory using `delete()` toward the end of `main()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output to accompany this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are creating class definitions with their associated member function
    definitions, it is important to know how developers typically organize their code
    in files. Most often, a class will be broken into a header (`.h`) file, which
    will contain the class definition, and a source code (`.cpp`) file, which will
    `#include` the header file, and then follow with the member function definitions
    themselves. For example, a class named `University` would have a `University.h`
    header file and a `University.cpp` source code file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move forward with our understanding of the details of how member
    functions work by examining the `this` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Examining member function internals; the "this" pointer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have noticed that member functions are invoked through objects. We
    have noticed that in the scope of a member function, it is the data members (and
    other member functions) of the particular object that invoked the function that
    may be utilized (in addition to any input parameters). Alas, how and why does
    this work?
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that most often, member functions are invoked through objects.
    Whenever a member function is invoked in this fashion, that member function receives
    a pointer to the instance that invoked the function. A pointer to the object calling
    the function is then passed as an implicit first argument to the function. The
    name of this pointer is **this**.
  prefs: []
  type: TYPE_NORMAL
- en: Though the `this` pointer may be referred to explicitly in the definition of
    each such member function, it usually is not. Even without its explicit use, the
    data members utilized in the scope of the function belong to `this`, a pointer
    to the object that invoked the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at a full program example. Though the example is broken
    into segments, the full program can be found in the following GitHub location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the first segment of the program, we define the class `Student` with a variety
    of data members, and two member function prototypes. For now, we will place everything
    in the `public` access region.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s examine the member function definitions for `void Student::Initialize()`
    and `void Student::Print()`. We will also examine what each of these functions
    looks like internally, to C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, we see the member function definition for `void Student::Initialize()`,
    which takes a variety of parameters. Notice that in the body of this function,
    we allocate memory for the data member `firstName` to be enough characters to
    hold what the input parameter `fn` requires (plus one for the terminating null
    character). We then `strcpy()` the string from the input parameter, `fn`, to the
    data member `firstName`. We do the same for the data member `lastName` using the
    input parameter `ln`. We proceed similarly, using the various input parameters,
    to initialize the various data members for the specific object that will invoke
    this function.
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice in `void Student::Initialize()` the assignment `this->middleInitial
    = mi;`. Here, we have an optional, explicit use of the `this` pointer. It is not
    necessary or customary in this situation to qualify `middleInitial` with `this`,
    but we may choose to do so. However, in the assignment `this->gpa = gpa;`, the
    use of `this` is required. Why? Notice that the input parameter is named `gpa`
    and the data member is also `gpa`. Simply assigning `gpa = gpa;` would set the
    most local version of `gpa` (the input parameter) to itself and would not affect
    the data member. Here, disambiguating `gpa` with `this` on the left-hand side
    of the assignment indicates to set the data member, `gpa`, which is pointed to
    by `this`, to the value of the input parameter, `gpa`. Another solution is to
    use distinct names for data members versus input parameters, such as renaming
    `gpa` in the formal parameter list to `avg` (which we will do in later versions
    of this code).
  prefs: []
  type: TYPE_NORMAL
- en: Now, notice the commented-out version of `void Student::Initialize()`, which
    is below the utilized version of `void Student::Initialize()`. Here, we can see
    how most member functions are internally represented. First, notice that the name
    of the function is *name mangled* to include the data types of its parameters.
    This is internally how functions are represented, and consequentially, allows
    function overloading (that is, two functions with seemingly the same name; internally,
    each has a unique name). Next, notice that among the input parameters, there is
    an additional, first input parameter. The name of this additional (hidden) input
    parameter is `this`, and it is defined as `Student *const this`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the body of the internalized function view of `void Student::Initialize()`,
    notice that each data member's name is preceded with `this`. We are, in fact,
    accessing the data member of an object that is pointed to by `this`. Where is
    `this` defined? Recall, `this` is the implicit first input parameter to this function,
    and is a constant pointer to the object that invoked this function.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can review the member function definition for `void Student::Print()`.
    In this function, each data member is neatly printed out using `cout` and the
    insertion operator `<<`. However, notice below this function definition the commented-out
    internal version of `void Student::Print()`. Again, `this` is actually an implicit
    input parameter of type `Student *const`. Also, each data member usage is preceded
    with access through the `this` pointer, such as `this->gpa`. Again, we can clearly
    see that a specific instance's members are accessed in the scope of a member function;
    these members are implicitly accessed through the `this` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, note that explicit use of `this` is permitted in the body of a member
    function. We can almost always precede usage of a data member or member function,
    accessed in the body of a member function, with explicit use of `this`. Later
    in this chapter, we will see the one contrary case (using a static method). Also,
    later in this book, we will see situations in which explicit usage of `this` will
    be necessary to implement more intermediate-level OO concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nonetheless, let''s move forward by examining `main()` to complete this program
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the last segment of this program, we instantiate `Student` twice in `main()`.
    `Student` `s1` is an instance, whereas `s2` is a pointer to a `Student`. Next,
    we utilize either the `.` or `->` notation to invoke the various member functions
    through each relevant instance.
  prefs: []
  type: TYPE_NORMAL
- en: Note, when `s1` invokes `Initialize()`, the `this` pointer (in the scope of
    the member function) will point to `s1`. It will be as if `&s1` is passed as the
    first argument to this function. Likewise, when `*s2` invokes `Initialize`, the
    `this` pointer will point to `s2`; it will be as if `s2` (which is already a pointer)
    is passed as an implicit first argument to this function.
  prefs: []
  type: TYPE_NORMAL
- en: After each instance invokes `Print()` to display the data members for each `Student`,
    notice that we release various levels of dynamically allocated memory. We start
    with the dynamically allocated data members for each instance, releasing each
    such member using `delete()`. Then, because `s2` is a pointer to an instance that
    we have dynamically allocated, we must also remember to release the heap memory
    comprising the instance itself. We again do so with `delete s2;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output for the full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's add to our understanding of classes and information hiding by examining
    access labels and regions.
  prefs: []
  type: TYPE_NORMAL
- en: Using access labels and access regions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Labels may be introduced into a class (or structure) definition to control the
    access or visibility of class (or structure) members. By controlling the direct
    access of members from various scopes in our application, we can support encapsulation
    and information hiding. That is, we can insist that users of our classes use the
    functions that we select, with the protocols we select, to manipulate data and
    other member functions within the class in ways we, the programmer, find reasonable
    and acceptable. Furthermore, we can hide the implementation details of the class
    by advertising to the user only the desired public interface for a given class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data members or member functions, collectively referred to as **members**,
    can be individually labeled, or grouped together into access regions. The three
    labels or **access regions** that may be specified are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**private**: Data members and member functions in this access region are only
    accessible within the scope of the class. The scope of a class includes member
    functions of that class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private` until we introduce inheritance. When inheritance is introduced, `protected`
    will provide a mechanism for allowing access within the derived class scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public**: Data members and member functions in this access region are accessible
    from any scope in the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reminder
  prefs: []
  type: TYPE_NORMAL
- en: Data members and member functions are almost always accessed via instances.
    You will ask, *in what scope is my instance?* and *may I access a particular member
    from this particular scope?*
  prefs: []
  type: TYPE_NORMAL
- en: As many members as required by the programmer may be grouped under a given label
    or `private`. If access labels are omitted in a structure definition, default
    member access is `public`. When access labels are explicitly introduced, rather
    than relying on default visibility, a `class` and a `struct` are identical. Nonetheless,
    in object-oriented programming, we tend to utilize classes for user defined types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine an example to illustrate access regions. Though this example
    will be broken into several segments, the full example will be shown and can also
    be found in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex3.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first define the `Student` class. Notice that we add a `private`
    access region near the top of the class definition and place all of the data members
    within this region. This placement will ensure that these data members will only
    be able to be directly accessed and modified within the scope of this class, which
    means by member functions of this class (and friends, which we will much later
    see). By limiting the access of data members only to member functions of their
    own class, safe handling of those data members is ensured; only access through
    intended and safe functions, which the class designer has introduced themself,
    will be allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, notice that the label `public` has been added in the class definition
    prior to the prototypes of the member functions. The implication is that these
    functions will be accessible in any scope of our program. Of course, we will generally
    need to access these functions each via an instance. But the instance can be in
    the scope of `main()` or any other function (even in the scope of another class's
    member functions) when the instance accesses these public member functions. This
    is known as a class' `public` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Access regions support encapsulation and information hiding
  prefs: []
  type: TYPE_NORMAL
- en: A good rule of thumb is to place your data members in the private access region,
    and then specify a safe, appropriate public interface to them using public member
    functions. By doing so, the only access to data members is in manners that the
    class designer has intended, through member functions the class designer has written,
    which have been well tested. With this strategy, the underlying implementation
    of the class may also be changed without causing any calls to the public interface
    to change. This practice supports encapsulation and information hiding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue by taking a look at the various member function definitions
    in our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined the various member functions that were prototyped in our
    class definition. Notice the use of the scope resolution operator `::` to tie
    the class name to the member function name. Internally, these two identifiers
    are *name mangled* together to provide a unique, internal function name. Notice
    that the `void Student::Initialize()` function has been overloaded; one version
    simply initializes all data members to some form of null or zero, whereas the
    overloaded version uses input parameters to initialize the various data members.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s continue by examining our `main()` function in the following segment
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned `main()` function, we first instantiate a `Student` with
    the declaration `Student s1;`. Next, `s1` invokes the `Initialize()` function
    with the signature matching the parameters provided. Since this member function
    is in the `public` access region, it can be accessed in any scope of our program,
    including `main()`. Similarly, `s1` invokes `Print()`, which is also `public`.
    These functions are in the `Student` class's public interface, and represent some
    of the core functionality for manipulating any given `Student` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the commented-out line of code, notice that `s1` tries to access `firstName`
    directly using `s1.firstName`. Because `firstName` is `private`, this data member
    can only be accessed in the scope of its own class, which means member functions
    (and later friends) of its class. The `main()` function is not a member function
    of `Student`, hence `s1` may not access `firstName` in the scope of `main()`,
    that is, a scope outside its own class.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we invoke `s1.CleanUp();`, which also works because `CleanUp()` is `public`
    and is hence accessible from any scope (including `main()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for this complete example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we understand how access regions work, let's move forward by examining
    a concept known as a constructor, and the various types of constructors available
    within C++.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Did you notice how convenient it has been for the program examples in this chapter
    to have an `Initialize()` member function for each `class` or `struct`? Certainly,
    it is desirable to initialize all data members for a given instance. More so,
    it is crucial to ensure that data members for any instance have bonified values,
    as we know that memory is not provided *clean* or *zeroed-out* by C++. Accessing
    an uninitialized data member, and utilizing its value as if it were bonified,
    is a potential pitfall awaiting the careless programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing each data member individually each time a class is instantiated
    can be tedious work. What if we simply overlook setting a value? What if the values
    are `private`, and are therefore not directly accessible? We have seen that an
    `Initialize()` function is beneficial because once written, it provides a means
    to set all data members for a given instance. The only drawback is that the programmer
    must now remember to call `Initialize()` on each instance in the application.
    Instead, what if there is a way to ensure that an `Initialize()` function is called
    every time a class is instantiated? What if we could overload a variety of versions
    to initialize an instance, and the appropriate version could be called based on
    data available at the time? This premise is the basis for a constructor in C++.
    The language provides for an overloaded series of initialization functions, which
    will be automatically called once the memory for an instance becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at this family of initialization member functions by examining
    the C++ constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Applying constructor basics and overloading constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `class` (or `struct`) to define multiple means by which to initialize an object.
    The return type of a constructor may not be specified.
  prefs: []
  type: TYPE_NORMAL
- en: Should your `class` or `struct` not contain a constructor, one will be made
    for you, in the `public` access region, with no arguments. This is known as a
    default constructor. Behind the scenes, every time an object is instantiated,
    a constructor call is patched in by the compiler. When a class without a constructor
    is instantiated, the default constructor is patched in as a function call immediately
    following the instantiation. This system-supplied member function will have an
    empty body (method) and it will be linked into your program so that any compiler
    added, implicit, calls to this function upon instantiation can occur without a
    linker error. Typically, a programmer will write their own default (no-argument)
    constructor; that is, one that is used for the default means of instantiation
    with no arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Most programmers provide at least one constructor, in addition to their own
    no-argument default constructor. Recall, constructors can be overloaded. It is
    important to note that if you provide any constructor yourself, you will not then
    receive the system supplied, no-argument default constructor, and that subsequently
    using such an interface for instantiation will cause a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  prefs: []
  type: TYPE_NORMAL
- en: Constructors have the same name as the class. You may not specify their return
    type. They can be overloaded. The compiler only creates a public, default (no-argument)
    constructor if you have not provided any constructors (or means for instantiation)
    in your class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s introduce a simple example to understand constructor basics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex4.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex4.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the previous program segment, we first define `class University`; the data
    members are `private`, and the three member functions are `public`. Notice that
    the first two member functions prototyped are constructors. Both have the same
    name as the class; neither has its return type specified. The two constructors
    are overloaded, in that each has a different signature.
  prefs: []
  type: TYPE_NORMAL
- en: Next, notice that the three member functions are defined. Notice the use of
    the scope resolution operator `::` preceding each member function name, in each
    of their definitions. Each constructor provides a different means for initializing
    an instance. The `void University::Print()` member function merely provides a
    means to provide simple output for our example.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in `main()`, let's create two instances of `University`. The first line
    of code, `University u1;`, instantiates a `University` and then implicitly invokes
    the default constructor to initialize the data members. On the next line of code,
    `University u2("University of Delaware", 23800);`, we instantiate a second `University`.
    Once the memory for that instance has been made available on the stack in `main()`,
    the constructor matching the signature of the arguments provided, namely `University::University(const
    char *, int)`, will be implicitly invoked to initialize the instance.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that based upon how we instantiate an object, we can specify which
    constructor we would like to be called on our behalf to perform the initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for this example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's add to our knowledge of constructors by examining a copy constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Creating copy constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **copy constructor** is a specialized constructor that is invoked whenever
    a copy of an object may need to be made. Copy constructors may be invoked during
    the construction of another object. They may also be invoked when an object is
    passed by value to a function via an input parameter, or returned by value from
    a function.
  prefs: []
  type: TYPE_NORMAL
- en: Often, it is easier to make a copy of an object and modify the copy slightly
    than to construct a new object with its individual attributes from scratch. This
    is especially true if a programmer requires a copy of an object that has undergone
    many changes during the life of the application. It may be impossible to recall
    the order of various transformations that may have been applied to the object
    in question in order to create a duplicate. Instead, having the means to copy
    an object is desirable, and possibly crucial.
  prefs: []
  type: TYPE_NORMAL
- en: The signature of a copy constructor is `ClassName::ClassName(const ClassName
    &);`. Notice that a single object is explicitly passed as a parameter, and that
    parameter will be a reference to a constant object. The copy constructor, as do
    most member functions, will receive an implicit argument to the function, the
    `this` pointer. The purpose of the copy constructor's definition will be to make
    a copy of the explicit parameter to initialize the object pointed to by `this`.
  prefs: []
  type: TYPE_NORMAL
- en: If no copy constructor is implemented by the `class` (or `struct`) designer,
    one will be provided for you (in the `public` access region) that performs a shallow,
    member-wise copy. This is likely not what you want if you have data members in
    your class that are pointers. Instead, the best thing to do is to write a copy
    constructor yourself, and write it to perform a deep copy (allocating memory as
    necessary) for data members that are pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Should the programmer wish to disallow copying during construction, the keyword
    `delete` can be used in the prototype of the copy constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, if the programmer wishes to prohibit object copying, a copy constructor
    may be prototyped in the `private` access region. In this case, the compiler will
    link in the default copy constructor (which performs a shallow copy), but it will
    be considered private. Therefore, instantiations that would utilize the copy constructor
    outside the scope of the class will be prohibited. This technique is used less
    frequently since the advent of `=delete`; however, it may be seen in existing
    code, so it is useful to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine a copy constructor, starting with the class definition. Though
    the program is presented in several fragments, the full program example may be
    found in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex5.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex5.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this program segment, we start by defining `class Student`. Notice the usual
    assortment of `private` data members and `public` member function prototypes,
    including the default constructor and an overloaded constructor. Also notice the
    prototype for the copy constructor `Student(const Student &);`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at the member function definitions with the following
    continuation of our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned code fragment, we have various member function definitions.
    Most notably, let's consider the copy constructor definition, which is the member
    function with the signature of `Student::Student(const Student &s)`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the input parameter, `s`, is a reference to a `Student` that is
    `const`. This means that the source object, which we will be copying from, may
    not be modified. The destination object, which we will be copying into, will be
    the object pointed to by the `this` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: As we carefully navigate the copy constructor, notice that we successively allocate
    space, as necessary, for any pointer data members that belong to the object pointed
    to by `this`. The space allocated is the same size as required by the data members
    referred to by `s`. We then carefully copy from the source data member to the
    destination data member. We meticulously ensure that we make an exact copy in
    the destination object of the source object.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are making a *deep copy* in the destination object. That is,
    rather than simply copying the pointers contained in `s.firstName` to `this->firstName`,
    for example, we instead allocate space for `this->firstName` and then copy over
    the source data. The result of a shallow copy would instead be that the pointer
    data members in each object would share the same dereferenced memory (that is,
    the memory to which each pointer points). This is most likely not what you would
    want in a copy. Also recall, the default behavior of a system-supplied copy constructor
    would be to provide a shallow copy from the source to the destination object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at our `main()` function to see the various ways in
    which the copy constructor could be invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In `main()`, we declare two instances of `Student`, `s1` and `s2`, and each
    is initialized with the constructor that matches the signature of `Student::Student(const
    char *, const char *, char, float, const char *);`. Notice that the signature
    used in instantiation is how we select which constructor should be implicitly
    called.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we instantiate `s3` and pass as an argument to its constructor the object
    `s1` with `Student s3(s1);`. Here, `s1` is of type `Student`, so this instantiation
    will match the constructor that accepts a reference to a `Student`, the copy constructor.
    Once in the copy constructor, we know that we will make a deep copy of `s1` to
    initialize the newly instantiated object, `s3`, which will be pointed to by the
    `this` pointer in the scope of the copy constructor method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we instantiate `s4` with the following line of code: `Student
    s4 = s2;`. Here, because this line of code is an initialization (that is, `s4`
    is both declared and given a value in the same statement), the copy constructor
    will also be invoked. The source object of the copy will be `s2` and the destination
    object will be `s4`. Notice that we then modify each of the copies (`s3` and `s4`)
    slightly by modifying their `firstName` data members.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the commented-out section of code, we instantiate two objects of type
    `Student`, `s5` and `s6`. We then try to assign one to the other with `s5 = s6;`.
    Though this looks similar to the initialization between `s4` and `s2`, it is not.
    The line `s5 = s6;` is an assignment. Each of the objects existed previously.
    As such, the copy constructor is not called for this segment of code. Nonetheless,
    this code is legal and has similar implications as with the assignment operator.
    We will examine these details later in the book when we discuss operator overloading
    in [*Chapter 12*](B15702_12_Final_NM_ePub.xhtml#_idTextAnchor453), *Operator Overloading
    and Friends*.
  prefs: []
  type: TYPE_NORMAL
- en: We then print out objects `s1`, `s2`, `s3`, and `s4`. Then we call `Cleanup()`
    on each of these four objects. Why? Each object contained data members that were
    pointers, so it is appropriate to delete the heap memory contained within each
    instance (that is, selected pointer data members) prior to these outer stack objects
    going out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output to accompany the full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The output for this example shows each original `Student` instance, paired with
    its copy. Notice that each copy has been modified slightly from the original (`firstName`
    differs).
  prefs: []
  type: TYPE_NORMAL
- en: Related topic
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to note that the assignment operator shares many similarities
    with the copy constructor, in that it can allow data to be copied from a source
    to a destination instance. However, the copy constructor is implicitly invoked
    for the initialization of a new object, whereas the assignment operator will be
    invoked when performing an assignment between two existing objects. Nonetheless,
    the methods of each will look strikingly similar! We will examine overloading
    the assignment operator to customize its behavior to perform a deep assignment
    (much like a deep copy) in [*Chapter 12*](B15702_12_Final_NM_ePub.xhtml#_idTextAnchor453),
    *Friends and Operator Overloading*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a deep understanding of copy constructors, let's look at one
    last variety of constructor, the conversion constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Creating conversion constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type conversions can be performed from one user defined type to another, or
    from a standard type to a user defined type. A conversion constructor is a language
    mechanism that allows such conversions to occur.
  prefs: []
  type: TYPE_NORMAL
- en: A **conversion constructor** is a constructor that accepts one explicit argument
    of a standard or user defined type, and applies a reasonable conversion or transformation
    on that object to initialize the object being instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example illustrating this idea. Though the example
    will be broken into several segments and also abbreviated, the full program can
    be found in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex6.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex6.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the previous program segment, we first include a forward declaration to `class
    Student;`—this declaration allows us to refer to the `Student` type prior to its
    definition. We then define `class Employee`. Notice that this class includes several
    `public` data members and three constructor prototypes – a default, alternative,
    and conversion constructor. As a side note, notice that a copy constructor has
    not been programmer-specified. This means that a default (shallow) copy constructor
    will be provided by the compiler. In this case, since there are no pointer data
    members, the shallow copy is acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, let us continue by examining the conversion constructor prototype.
    Notice that in the prototype, this constructor takes a single argument. The argument
    is a `Student &`, which is why we needed the forward declaration for `Student`.
    Preferably, we might use a `const Student &` as the parameter type, but we will
    need to understand const member functions (later in this chapter) in order to
    do so. The type conversion that will take place will be to convert a `Student`
    into a newly constructed `Employee`. It will be our job to provide a meaningful
    conversion to accomplish this in the definition for the conversion constructor,
    which we will see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define our `Student` class, which is much the same as we have seen
    in previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us continue with the example to see the member function definitions
    for `Employee` and `Student`, and our `main()` function, in the following code
    segment. To conserve space, selected member function definitions will be omitted;
    however, the online code will show the program in its entirety.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving onward, our member functions for `Employee` and `Student` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the previous segment of code, we notice several constructor definitions for
    `Employee`. We have a default, alternate, and conversion constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the definition of the `Employee` conversion constructor, notice that
    the formal parameter for the source object is `s`, which is of type `Student`.
    The destination object will be the `Employee` that is being constructed, which
    will be pointed to by the `this` pointer. In the body of this function, we carefully
    copy the `firstName` and `lastName` from `Student &s` to the newly instantiated
    `Employee`. Note that we used the access functions `const char *Student::GetFirstName()`
    and `const char *Student::GetLastName()` to do so (via an instance of `Student`)
    as these data members were `private`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with the conversion constructor. It is our job to provide a meaningful
    conversion from one type to another. In that endeavor, we try to establish an
    initial salary for the `Employee` based on the `gpa` of the source `Student` object.
    Because `gpa` is `private`, an access function, `Student::GetGpa()`, is used to
    retrieve this value (via the source `Student`). Notice that because `Employee`
    did not have any dynamically allocated data members, we did not need to allocate
    memory to assist in a deep copy in the body of this function.
  prefs: []
  type: TYPE_NORMAL
- en: To conserve space, the member function definitions for the `Student` default,
    alternate, and copy constructor have been omitted, as have the definitions for
    the `void Student::Print()` and `void Student::CleanUp()` member functions. However,
    they are the same as in the previous full program example illustrating the `Student`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that access functions for `private` data members in `Student`, such as
    `float Student::GetGpa()`, have been added to provide safe access to those data
    members. Note that the value returned from `float Student::GetGpa()` on the stack
    is a copy of the `gpa` data member. The original `gpa` is in no worry of being
    breached by the use of this function. The same applies for the member functions
    `const char *Student::GetFirstName()` and `const char *Student::GetLastName()`,
    which each returns a `const char *`, ensuring that the data that will be returned
    will not be breached.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s complete our program by examining our `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In our `main()` function, we instantiate a `Student`, namely `s1`, which is
    implicitly initialized with the matching constructor. Then we instantiate an `Employee`,
    `e1`, using the conversion constructor in the call `Employee e1(s1);`. At a quick
    glance, it may seem that we are utilizing the `Employee` copy constructor. But,
    at a closer look, we notice that the actual parameter `s1` is of type `Student`,
    not `Employee`. Hence, we are using `Student s1` as a basis to initialize `Employee
    e1`. Note that in no manner is the `Student`, `s1`, harmed or altered in this
    conversion. For this reason, it would be preferable to define the source object
    as a `const Student &` in the formal parameter list; once we understand const
    member functions, which will then be required for usage in the body of the conversion
    constructor, we can do so.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude this program, we print out the `Employee` using `Employee::Print()`,
    which enables us to visualize the conversion we applied for a `Student` to an
    `Employee`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output to accompany our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Before we move forward, there's one final, subtle detail about conversion constructors
    that is very important to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Any constructor that takes a single argument is considered a conversion constructor,
    which can potentially be used to convert the parameter type to the object type
    of the class to which it belongs. For example, if you have a constructor in the
    `Student` class that takes only a float, this constructor could be employed not
    only in the manner shown in the example above, but also in places where an argument
    of type `Student` is expected (such as a function call) when an argument of type
    float is instead supplied. This may not be what you intend, which is why this
    interesting feature is being called out. If you don't want implicit conversions
    to take place, you can disable this behavior by declaring the constructor with
    the `explicit` keyword at the beginning of its prototype.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand basic, alternative, copy, and conversion constructors
    in C++, let's move forward and explore the constructor's complementary member
    function, the C++ destructor.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding destructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can you recall how conveniently a class constructor provides us with a way to
    initialize a newly instantiated object? Rather than having to remember to call
    an `Initialize()` method for each instance of a given type, the constructor allows
    initialization automatically. The signature used in construction helps specify
    which of a series of constructors should be used.
  prefs: []
  type: TYPE_NORMAL
- en: What about object clean-up? Many classes contain dynamically allocated data
    members that are often allocated in a constructor. Shouldn't the memory comprising
    these data members be released when the programmer is done with an instance? Certainly.
    We have written a `CleanUp()` member function for several of our example programs.
    And we have remembered to call `CleanUp()`. Conveniently, similar to a constructor,
    C++ has an automatically built-in feature to serve as a clean-up function. This
    function is known as the destructor.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the destructor to understand its proper usage.
  prefs: []
  type: TYPE_NORMAL
- en: Applying destructor basics and proper usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **destructor** is a member function whose purpose is to relinquish the resources
    an object may have acquired during its existence. A destructor is automatically
    invoked when a class or struct instance either:'
  prefs: []
  type: TYPE_NORMAL
- en: Goes out of scope (this applies to non-pointer variables)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is explicitly deallocated using delete (for pointers to objects)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A destructor should (most often) clean up any memory that may have been allocated
    by the constructor. The destructor's name is a `~` character followed by the `class`
    name. A destructor will have no arguments; therefore, it cannot be overloaded.
    Lastly, the return type for a destructor may not be specified. Both classes and
    structures may have destructors.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to deallocating memory a constructor may have allocated, a destructor
    may be used to perform other end-of-life tasks for an instance, such as logging
    a value to a database. More complex tasks may include informing objects pointed
    to by class data members (whose memory is not being released) that the object
    at hand will be concluding. This may be important if the linked object contains
    a pointer back to the terminating object. We will see examples of this later in
    the book, in [*Chapter 10*](B15702_10_Final_NM_ePub.xhtml#_idTextAnchor386), *Implementing
    Association, Aggregation, and Composition*.
  prefs: []
  type: TYPE_NORMAL
- en: If you have not provided a destructor, the compiler will create and link in
    a `public` destructor with an empty body. This is necessary because a destructor
    call is automatically patched in just prior to the point when local instances
    are popped off the stack, and just prior to `delete()` being applied to dynamically
    allocated instances. It is easier for the compiler to always patch in this call,
    rather than constantly look to see if your class has a destructor or not. A good
    rule of thumb is to always provide a class destructor yourself.
  prefs: []
  type: TYPE_NORMAL
- en: There are some potential pitfalls. For example, if you forget to delete a dynamically
    allocated instance, the destructor call will not be patched in for you. C++ is
    a language that gives you the flexibility and power to do (or not do) anything.
    If you do not delete memory using a given identifier (perhaps two pointers refer
    to the same memory), please remember to delete it through the other identifier
    at a later date.
  prefs: []
  type: TYPE_NORMAL
- en: There's one last item worth mentioning. Though you may call a destructor explicitly,
    you will rarely ever need to do so. Destructor calls are implicitly patched in
    by the compiler on your behalf in the aforementioned scenarios. Only in very few
    advanced programming situations will you need to explicitly call a destructor
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple example illustrating a class destructor, which
    will be broken into three segments. Its full example can be seen in the GitHub
    repository listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex7.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex7.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the previous segment of code, we first define `class University`. Notice
    the `private` access region filled with data members, and the `public` interface,
    which includes prototypes for a default, alternate, and copy constructor, as well
    as for the destructor and a `Print()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at the various member function definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned code fragment, we see the various overloaded constructors
    we are now accustomed to seeing, plus `void University::Print()`. The new addition
    is the destructor definition.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the destructor `University::~University()` takes no arguments; it may
    not be overloaded. The destructor simply deallocates memory that may have been
    allocated in any of the constructors. Note that we simply `delete name;`, which
    will work whether `name` points to a valid address or contains a null pointer
    (yes, applying delete to a null pointer is OK). We additionally print the `this`
    pointer in the destructor, just for fun, so that we can see the address of the
    instance that is approaching non-existence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at `main()` to see when the destructor may be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, we instantiate two `University` instances; `u1` is an instance and `u2`
    points to an instance. We know that `u2` is instantiated when its memory becomes
    available with `new()`, and that once the memory has become available, the appliable
    constructor is called. Next, we call `University::Print()` for both instances
    to have some output.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, toward the end of `main()`, we delete `u2` to return this memory to
    the heap management facility. Just prior to the call to `delete()`, C++ will patch
    in a call to the destructor for the object pointed to by `u2`. It is as if a secret
    function call, `u2->~University();`, has been patched in prior to `delete u2;`
    (note, this is done automatically; no need for you to do so as well). The implicit
    call to the destructor will delete the memory that may have been allocated for
    any data members within the class. The memory release is now complete for `u2`.
  prefs: []
  type: TYPE_NORMAL
- en: What about instance `u1`? Will its destructor be called? Yes; `u1` is a stack
    instance. Just prior to its memory being popped off the stack in `main()`, the
    compiler will have patched in a call to its destructor, as if the call `u1.~University();`
    was added on your behalf (again, no need to do so yourself). For instance `u1`,
    the destructor will also deallocate any memory for data members that may have
    been allocated. Likewise, the memory release is now complete for `u1`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in each destructor call, we have printed a message to illustrate
    when the destructor is called, and have also printed out the memory address for
    `this` to allow you to visualize each specific instance as it is destructed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output to accompany our full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With this example, we have now examined the destructor, the complement to the
    series of class constructors. Let us move on to another set of useful topics relating
    to classes: various keyword qualifications of data members and member functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying qualifiers to data members and member functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will investigate qualifiers that can be added to both data
    members and member functions. The various qualifiers – `inline`, `const`, and
    `static` – can support program efficiency, aid in keeping private data members
    safe, support encapsulation and information hiding, and additionally be used to
    implement various object-oriented concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started with the various types of member qualifications.
  prefs: []
  type: TYPE_NORMAL
- en: Adding inline functions for potential efficiency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a set of short member functions in your program that are repeatedly
    called by various instances. As an object-oriented programmer, you appreciate
    using a `public` member function to provide safe and controlled access to `private`
    data. However, for very short functions, you worry about efficiency, that is,
    the overhead of calling a small function repeatedly. Certainly, it would be more
    efficient to just paste in the two or three lines of code comprising the function.
    Yet, you resist because that may mean providing `public` access to otherwise hidden
    class information, such as data members, which you are hesitant to do. An `inline`
    function can solve this dilemma, allowing you to have the safety of a member function
    to access and manipulate your private data, yet the efficiency of executing several
    lines of code without the overhead of a function call.
  prefs: []
  type: TYPE_NORMAL
- en: An **inline** function is a function whose invocation is substituted with the
    body of the function itself. Inline functions can help eliminate the overhead
    associated with calling very small functions.
  prefs: []
  type: TYPE_NORMAL
- en: Why would calling a function have overhead? When a function is called, input
    parameters (including `this`) are pushed onto the stack, space is reserved for
    a return value of the function (though sometimes registers are used), moving to
    another section of code requires storing information in registers to jump to that
    section of code, and so on. Replacing very small function bodies with inline functions
    can add to the program efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'An inline function may be specified by either:'
  prefs: []
  type: TYPE_NORMAL
- en: Placing the function definition inside the class definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing the keyword `inline` prior to the return type in the (typical) function
    definition, found outside the class definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying a function as `inline` in one of the aforementioned two fashions
    is merely a request to the compiler to consider the substitution of the function
    body for its function call. This substitution is not guaranteed. When might the
    compiler not actually inline a given function? If a function is recursive, it
    cannot be made `inline`. Likewise, if a function is lengthy, the compiler will
    not inline the function. Also, if the function call is dynamically bound with
    the specific implementation determined at runtime (virtual functions), it cannot
    be made `inline`.
  prefs: []
  type: TYPE_NORMAL
- en: An `inline` function definition should be declared in the header file with the
    corresponding class definition. This will allow any revisions to the function
    to be re-expanded correctly should the need arise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example using `inline` functions. The program will be broken
    into two segments, with some well-known functions removed. However, the full program
    may be seen in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex8.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex8.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the previous program fragment, let's start with the class definition. Notice
    that several access function definitions have been added in the class definition
    itself, namely, functions such as `GetFirstName()`, `GetLastName()`, and so on.
    Look closely; these functions are actually defined within the class definition.
    For example, `float GetGpa() { return gpa; }` is not just the prototype, but the
    full function definition. By virtue of the function placement within the class
    definition, functions such as these are considered `inline`.
  prefs: []
  type: TYPE_NORMAL
- en: These small functions provide safe access to private data members. Notice `const
    char *GetFirstName()`, for example. This function returns a pointer to `firstName`,
    which is stored in the class as a `char *`. But because the return value of this
    function is a `const char *`, this means that anyone calling this function must
    treat the return value as a `const char *`, which means treating it as unmodifiable.
    Should this function's return value be stored in a variable, that variable must
    also be defined as `const char *`. By upcasting this pointer to an unmodifiable
    version of itself with the return value, we are adding the provision that no one
    can get their hands on a `private` data member (which is a pointer) and then change
    its value.
  prefs: []
  type: TYPE_NORMAL
- en: Now notice toward the end of the class definition, we have a prototype for `void
    SetCurrentCourse(const char *);`. Then, outside of this class definition, we will
    see the definition for this member function. Notice the keyword `inline` prior
    to the `void` return type of this function definition. The keyword must be explicitly
    used here since the function is defined outside of the class definition. Remember,
    with either style of `inline` designation for a method, the `inline` specification
    is merely a request to the compiler to make the substitution of function body
    for function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue this example by examining the remainder of our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the remainder of our program example, several member function
    definitions have been omitted. The bodies of these functions are identical to
    the previous example illustrating a `Student` class in full, and can also be viewed
    online.
  prefs: []
  type: TYPE_NORMAL
- en: Let's focus instead on our `main()` function. Here, we instantiate a `Student`,
    namely `s1`. We then invoke several `inline` function calls via `s1`, such as
    `s1.GetFirstName();`. Because `Student::GetFirstName()` is inline, it is as if
    we are accessing the data member `firstName` directly, as the body of this function
    merely has a `return firstName;` statement. We have the safety of using a function
    to access a `private` data member (meaning that no one can modify this data member
    outside the scope of the class), but the speed of an `inline` function's code
    expansion to eliminate the overhead of a function call.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout `main()`, we make several other calls to `inline` functions in this
    same manner, including `s1.SetCurrentCourse();`. We now have the safety of encapsulated
    access with the speed of direct access to data members using small `inline` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output to accompany our full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let's now move onward by investigating another qualifier we can add to class
    members, the `const` qualifier.
  prefs: []
  type: TYPE_NORMAL
- en: Adding const data members and the member initialization list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already seen earlier in this book how to constant-qualify variables
    and the implications of doing so. To briefly recap, the implication of adding
    a `const` qualifier to a variable is that the variable must be initialized when
    it is declared, and that its value may never again be modified. We previously
    also saw how to add `const` qualification to pointers, such that we could qualify
    the data being pointed to, the pointer itself, or both. Let us now examine what
    it means to add a `const` qualifier to data members within a class, and learn
    about specific language mechanisms that must be employed to initialize those data
    members.
  prefs: []
  type: TYPE_NORMAL
- en: Data members that should never be modified should be qualified as `const`. A
    `const` variables, *never modified* means that the data member may not be modified
    using its own identifier. It will then be our job to ensure that we do not initialize
    our data members that are pointers to `const` objects, with objects that are not
    labeled as `const` (lest we provide a backdoor to change our private data).
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that in C++, a programmer can always cast the const-ness away from
    a pointer variable. Not that they should. Nonetheless, we will employ safety measures
    to ensure that by using access regions and appropriate return values from access
    functions, we do not easily provide modifiable access to our `private` data members.
  prefs: []
  type: TYPE_NORMAL
- en: The **member initialization list** must be used in a constructor to initialize
    any data members that are constant, or that are references. A member initialization
    list offers a mechanism to initialize data members that may never be l-values
    in an assignment. A member initialization list may also be used to initialize
    non-const data members. For performance reasons, the member initialization list
    is most often the preferred way to initialize any data member (const or non-const).
  prefs: []
  type: TYPE_NORMAL
- en: 'A member initialization list may appear in any constructor, and to indicate
    this list, simply place a `:` after the formal parameter list, followed by a comma-separated
    list of data members, paired with the initial value for each data member in parentheses.
    For example, here we use the member initialization list to set two data members,
    `studentId` and `gpa`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: It is interesting to note that a reference must use the member initialization
    list because references are implemented as constant pointers. That is, the pointer
    itself points to a specific other object and may not point elsewhere. The values
    of that object may change, but the reference always references a specific object,
    the one in which it was initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Using `const` qualification with pointers can be tricky to determine which scenarios
    require initialization with this list, and which do not. For example, a pointer
    to a constant object does not need to be initialized with the member initialization
    list. The pointer could point to any object, but once it does, it may not change
    the referenced value. However, a constant pointer must be initialized with the
    member initialization list because the pointer itself is fixed to a specific address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a `const` data member and how to use the member initialization
    list to initialize its value in a full program example. We will also see how to
    use this list to initialize non-const data members. Though this example is segmented
    and not shown in its entirety, the full program can be found in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex9.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex9.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the aforesaid `Student` class, notice that we have added a data member, `const
    int studentId;`, to the class definition. This data member will require the use
    of the member initialization list to initialize this constant data member in each
    of the constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how the use of the member initialization list will work
    with constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the above code fragment, we see three `Student` constructors. Notice the
    various member initialization lists, designated by a `:` after the formal parameter
    list for each of the three constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each constructor will make use of the member initialization list to set the
    values of data members that are `const`, such as `studentId`. Additionally, the
    member initialization list can be used as a simple way to initialize any other
    data member. We can see examples of the member initialization list being used
    to simply set non-const data members by viewing the member initialization list
    in either default or alternate constructor, for example, `Student::Student() :
    studentId(0), gpa(0.0)`. In this example, `gpa` is not `const`, so its use in
    the member initialization list is optional.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output to accompany our full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's now move forward by adding the `const` qualifier to member functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using const member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen the constant qualifier used quite exhaustively now with data. It
    can also be used in conjunction with member functions. C++ provides a language
    mechanism to ensure that selected functions may not modify data; this mechanism
    is the `const` qualifier as applied to member functions.
  prefs: []
  type: TYPE_NORMAL
- en: A **const member function** is a member function that specifies (and enforces)
    that the method can only perform read-only activities on the object invoking the
    function.
  prefs: []
  type: TYPE_NORMAL
- en: A constant member function means that no portion of `this` may be modified.
    However, because C++ allows typecasting, it is possible to cast `this` to its
    non-const counterpart and then change data members. However, if the class designer
    truly meant to be able to modify data members, they simply would not label a member
    function as `const`.
  prefs: []
  type: TYPE_NORMAL
- en: Constant instances declared in your program may only invoke `const` member functions.
    Otherwise these objects could be directly modified.
  prefs: []
  type: TYPE_NORMAL
- en: To label a member function as `const`, the keyword `const` should be specified
    after the argument list in the function prototype and in the function definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example. It will be divided into two sections with some portions
    omitted; however, the full example can be seen in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex10.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex10.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the previous program fragment, we see a class definition for `Student`, which
    is becoming very familiar to us. Notice, however, that we have added the `const`
    qualifier to most of the access member functions, that is, to those methods that
    are only providing read-only access to data.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let us consider `float GetGpa() const { return gpa; }`. The `const`
    keyword after the argument list indicates that this is a constant member function.
    Notice that this function does not modify any data member pointed to by `this`.
    It cannot do so, as it is marked as a `const` member function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s move on to the remainder of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the remainder of this program, notice that we have again chosen not to include
    the definitions for member functions with which we are already familiar, such
    as the constructors, the destructor, and `void Student::SetCurrentCourse()`.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, let's focus our attention on the member function with the signature
    `void Student::Print() const`. Here, the `const` keyword after the argument list
    indicates that no data members pointed to by `this` can be altered in the scope
    of this function. And none are. Likewise, any member functions called on this
    within `void Student::Print()` must also be `const` member functions. Otherwise,
    they could modify `this`.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward to examine our `main()` function, we instantiate a `Student`,
    namely `s1`. This `Student` calls several member functions, including some that
    are `const`. `Student s1` then changes their current course using `Student::SetCurrentCourse()`,
    and then the new value of this course is printed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we instantiate another `Student`, `s2`, which is qualified as `const`.
    Notice that once this student is instantiated, the only member functions that
    may be applied to `s2` are those that are labeled as `const`. Otherwise, the instance
    may be modified. We then print out data for `s2` using `Student::Print();`, which
    is a `const` member function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice the commented-out line of code: `s2.SetCurrentCourse("Advanced
    C++ Programming");`? This line is illegal and would not compile, because `SetCurrentCourse()`
    is not a constant member function and is hence illegal to be called via a constant
    instance, such as `s2`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the output for the full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have fully explored `const` member functions, let's continue to
    the final section of this chapter to delve into `static` data members and `static`
    member functions.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing static data members and static member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have been using C++ classes to define and instantiate objects, let's
    add to our knowledge of object-oriented concepts by exploring the idea of a class
    attribute. A data member that is intended to be shared by all instances of a particular
    class is known as a **class attribute**.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, each instance of a given class has distinct values for each of its
    data members. However, on occasion, it may be useful for all instances of a given
    class to share one data member, containing a single value. The object-oriented
    concept of a class attribute can be modeled in C++ using a **static data member**.
  prefs: []
  type: TYPE_NORMAL
- en: The `static` data members themselves are modeled as external (global) variables
    whose scope is tied back to the class in question using *name mangling*. Hence,
    each static data member can have its scope limited to the class in question.
  prefs: []
  type: TYPE_NORMAL
- en: To model a `static` data member, an external variable definition, outside the
    class, must follow the `static` data member specification in the class definition.
    Storage for this *class member* is obtained by the external variable, its underlying
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '`static` data members within a class or structure. A `static` member function
    does not receive a `this` pointer; hence, it may only manipulate `static` data
    members and other external (global) variables.'
  prefs: []
  type: TYPE_NORMAL
- en: To indicate a `static` member function, the keyword `static` must be specified
    in front of the function's return type in the member function prototype only.
    The keyword `static` must not appear in the member function definition. If the
    keyword `static` appears in the function definition, the function will additionally
    be `static` in the C programming sense; that is, the function will be limited
    in scope to the file in which it is defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of `static` data member and member function
    usage. The following example will be broken into segments; however, it will appear
    without any functions omitted or abbreviated, as it is the final example in this
    chapter. It can also be found in full in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex11.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex11.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the first segment of code comprising our full example, we have our `Student`
    class definition. In the `private` access region, we have added a data member,
    `static int numStudents;`, to model the object-oriented concept of a class attribute,
    a data member that will be shared by all instances of this class.
  prefs: []
  type: TYPE_NORMAL
- en: Next, notice toward the end of this class definition that we have added a `static`
    member function, `static int GetNumberStudents();`, to provide encapsulated access
    to the `private` data member `numStudents`. Note the keyword `static` is added
    in the prototype only. If we glance outside of the class definition to find the
    member function definition of `int Student::GetNumberStudents()`, we notice that
    there is no usage of the `static` keyword within the definition of this function
    itself. The body of this member function simply returns the shared `numStudents`,
    the static data member.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also notice just below the class definition is the external variable definition
    to support the implementation of the static data member: `int Student::numStudents
    = 0;`. Notice with this declaration the use of `::` (the scope resolution operator)
    to associate the class name to the identifier `numStudents`. Though this data
    member is implemented as an external variable, and because the data member is
    labeled as `private`, it may only be accessed by member functions within the `Student`
    class. The implementation of a `static` data member as an external variable helps
    us understand where the memory for this shared data comes from; it is not part
    of any instance of the class, but stored as a separate entity in the global namespace.
    Also notice that the declaration `int Student::numStudents = 0;` initializes this
    shared variable to a value of zero.'
  prefs: []
  type: TYPE_NORMAL
- en: As an interesting aside, notice that the data member `studentId` has been changed
    from a `const int` to `const char *studentId;` in this new version of our `Student`
    class. Keep in mind that this means `studentId` is a pointer to a constant string,
    not a constant pointer. Because the memory for the pointer itself is not `const`,
    this data member will not need to be initialized using the member initialization
    list, but it will require some special handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue onward to review additional member functions comprising this
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the previous program segment of member functions, most member functions look
    as we've grown accustomed to seeing, but there are some subtle differences.
  prefs: []
  type: TYPE_NORMAL
- en: One difference, which relates to our `static` data member, is that `numStudents`
    is incremented in each of the constructors, and decremented in the destructor.
    Since this `static` data member is shared by all instances of `class Student`,
    each time a new `Student` is instantiated, the counter will increase, and when
    an instance of a `Student` ceases to exist and its destructor is implicitly called,
    the counter will be decremented to reflect the removal of such an instance. In
    this way, `numStudents` will accurately reflect how many `Student` instances exist
    in our application.
  prefs: []
  type: TYPE_NORMAL
- en: This section of code has a few other interesting details to notice, unrelated
    to `static` data members and member functions. For example, in our class definition,
    we changed `studentId` from a `const int` to a `const char *`. This means that
    the data pointed to is constant, not the pointer itself, so that we are not required
    to use the member initialization list to initialize this data member.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, in the default constructor, we choose to use the member initialization
    list to initialize `studentId` to `0`, meaning a null pointer. Recall that we
    may use the member initialization list for any data member, but we must use it
    to initialize `const` data members. That is, if the `const` part equates to memory
    that is allocated with an instance. Since the memory allocated within the instance
    for the data member `studentId` is a pointer and the pointer part of this data
    member is not `const` (just the data pointed to), we do not need to use the member
    initialization list for this data member. We just choose to.
  prefs: []
  type: TYPE_NORMAL
- en: However, because `studentId` is a `const char *`, this means that the identifier
    `studentId` may not serve as an l-value, or be on the left-hand side of an assignment.
    In the alternate and copy constructors, we wish to initialize `studentId`, and
    need the ability to use `studentId` as an l-value. But we cannot. We circumvent
    this dilemma by instead declaring a helper variable, `char *temp;`, and allocating
    it to contain the amount of memory we need to load the desired data. Then we load
    the desired data into `temp`, and finally we have `studentId` point to `temp`
    to establish a value for `studentId`. When we leave each constructor, the local
    pointer `temp` is popped off the stack; however, the memory is now captured by
    `studentId` and treated as `const`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in the destructor, notice that in order to delete the memory associated
    with `const char *studentid`, we will need to typecast `studentId` to a non-constant
    `char *`, as the operator `delete()` expects pointers that are not constant-qualified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have completed reviewing the new details in the member functions,
    let us continue by examining the final portion of this program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main()` function of our program, we start by instantiating two `Students`,
    `s1` and `s2`. As each instance is initialized with a constructor, the shared
    data member value of `numStudents` is incremented to reflect the number of students
    in our application. Note that the external variable `Student::numStudents`, which
    holds the memory for this shared data member, was initialized to `0` when the
    program started with the statement earlier in our code: `int Student::numStudents
    = 0;`.'
  prefs: []
  type: TYPE_NORMAL
- en: After we print out some details for each `Student`, we then print out the `static`
    data member `numStudents` using a `static` access function, `Student::GetNumStudents()`.
    The preferred way to call this function is `Student::GetNumStudents();`. Because
    `numStudents` is `private`, only a method of the `Student` class may access this
    data member. We have now provided safe, encapsulated access to a `static` data
    member using a `static` member function.
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to remember that `static` member functions do not receive
    a `this` pointer, therefore the only data they may manipulate will be `static`
    data in the class (or other external variables). Likewise, the only other functions
    they may call will be other `static` member functions in the same class, or external
    non-member functions.
  prefs: []
  type: TYPE_NORMAL
- en: It is also interesting to note that we can seemingly call `Student::GetNumStudents()`
    via any instance, such as `s1.GetNumStudents();`, as we see in the commented-out
    section of code. Though it seems as though we are calling the member function
    through an instance, the function will not receive a `this` pointer. Instead,
    the compiler reinterprets the call, which is seemingly through an instance, and
    replaces the invocation with a call to the internal, *name-mangled* function.
    It is clearer from a programming point of view to call `static` member functions
    using the first calling method, and not seemingly through an instance that would
    never be passed along to the function itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here is the output for our full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have reviewed our final example of this chapter, it is time to recap
    everything that we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have begun our journey with object-oriented programming.
    We have learned many object-oriented concepts and terms, and have seen how C++
    has direct language support to implement these concepts. We have seen how C++
    classes support encapsulation and information hiding, and how implementing designs
    supporting these ideals can lead to code that is easier to modify and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: We have detailed class basics, including member functions. We've moved deeper
    into member functions by examining member function internals, including understanding
    what the `this` pointer is, and how it works – including the underlying implementation
    of member functions that implicitly receive a `this` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: We have explored access labels and access regions. By grouping our data members
    in the `private` access region, and providing a suite of `public` member functions
    to manipulate these data members, we have found that we can provide a safe, well-controlled,
    and well-tested means to manipulate data from the confines of each class. We have
    seen that making changes to a class can be limited to the member functions themselves.
    The user of the class need not know the underlying representation of data members
    – these details are hidden and can be changed as needed without causing a wave
    of changes elsewhere in an application.
  prefs: []
  type: TYPE_NORMAL
- en: We have deeply explored the many facets of constructors, by examining default,
    typical (overloaded) constructors, copy constructors and even conversion constructors.
    We have been introduced to the destructor, and understand its proper usage.
  prefs: []
  type: TYPE_NORMAL
- en: We've added additional flavor to our classes by using various qualifiers to
    both data members and member functions, such as `inline` for efficiency, `const`
    to safeguard data and to ensure functions will as well, `static` data members
    to model the OO concept of class attributes, and `static` methods to provide safe
    interfaces to these `static` data members.
  prefs: []
  type: TYPE_NORMAL
- en: By immersing ourselves in object-oriented programming, we have gained a comprehensive
    set of skills relating to classes in C++. With a well-rounded set of skills and
    experience with using classes under our respective belts, and an appreciation
    for object-oriented programming, we can now move forward with [*Chapter 6*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262),
    *Implementing Hierarchies with Single Inheritance*, to learn how to grow a hierarchy
    of related classes. Let's move forward!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a C++ program to encapsulate a `Student`. You may use portions of your
    previous exercises. Try to do this yourself, rather than relying on any online
    code. You will need this class as a basis to move forward with future examples;
    now is a good time to try each feature on your own. Specifically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Create or modify your previous `Student` class to fully encapsulate a student.
    Be sure to include several data members that are dynamically allocated. Provide
    several overloaded constructors to provide a means to initialize your class. Be
    sure to include a copy constructor. Also, include a destructor to release any
    dynamically allocated data members.
  prefs: []
  type: TYPE_NORMAL
- en: b. Add an assortment of access functions to your class to provide safe access
    to data members within your class. Decide for which data members you will offer
    a `GetDataMember()` interface, and if any of these data members should have the
    ability to be reset after construction with a `SetDataMember()` interface. Apply
    the `const` and `inline` qualifiers to these methods as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: c. Be sure to utilize appropriate access regions – `private` for data members,
    and possibly for some helper member functions to break up a larger task. Add `public`
    member functions as necessary above and beyond your access functions above.
  prefs: []
  type: TYPE_NORMAL
- en: d. Include at least one `const` data member in your class and utilize the member
    initialization list to set this member. Add at least one `static` data member
    and one `static` member function.
  prefs: []
  type: TYPE_NORMAL
- en: e. Instantiate a `Student` using each constructor signature, including the copy
    constructor. Make several instances dynamically allocated using `new()`. Be sure
    to `delete()` each of these instances when you are done with them (so that their
    destructor will be called).
  prefs: []
  type: TYPE_NORMAL

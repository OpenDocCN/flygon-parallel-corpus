- en: '*Chapter 6*: Implementing Hierarchies with Single Inheritance'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will extend our pursuit of object-oriented programming in C++.
    We will begin by introducing additional OO concepts, such as **generalization**
    and **specialization**, and then understand how these concepts are implemented
    in C++ through *direct language support*. We will begin building hierarchies of
    related classes, and understand how each class can become an easier to maintain,
    potentially reusable building block in our applications. We will understand how
    the new OO concepts presented in this chapter will support well-planned designs,
    and we will have a clear understanding of how to implement these designs with
    robust code in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented concepts of generalization and specialization, and Is-A relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single inheritance basics – defining derived classes, accessing inherited members,
    understanding inherited access labels and regions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Construction and destruction sequences in a single inheritance hierarchy; selecting
    base class constructors with the member initialization list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying access labels in the base class list – public versus private and protected
    base classes – to change the OO purpose of inheritance to Implementation Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the object-oriented concepts
    of generalization and specialization, and will know how to use inheritance in
    C++ as a mechanism to realize these ideals. You will understand terms such as
    base and derived classes, as well as OO motivations for building hierarchies,
    such as supporting Is-A relationships or supporting implementation inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, you will understand how to grow inheritance hierarchies using
    single inheritance, and how to access inherited data members and member functions.
    You will also understand which inherited members you may directly access, based
    upon their defined access regions.
  prefs: []
  type: TYPE_NORMAL
- en: You will understand the order of constructor and destructor invocations when
    instances of derived class types are instantiated and destroyed. You will know
    how to make use of the member initialization list to select which, from a potential
    group, of inherited constructors a derived class object may need to utilize as
    part of its own construction.
  prefs: []
  type: TYPE_NORMAL
- en: You will also understand how changing access labels in a base class list changes
    the OO meaning for the type of inheritance hierarchy you are growing. By examining
    public versus private and protected base classes, you will understand different
    types of hierarchies, such as those built to support Is-A relationships, versus
    those built to support implementation inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding the direct language support of single inheritance in C++, you
    will be able to implement the OO concepts of generalization and specialization.
    Each class within your hierarchy will be a more easily maintained component, and
    can serve as a potential building block for creating new, more specialized components.
    Let's further our understanding of C++ as an OOP language by detailing single
    inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found at the following GitHub
    URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter06](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter06).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds with the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter06` in a file named `Chp6-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3tJJJBK](https://bit.ly/3tJJJBK).'
  prefs: []
  type: TYPE_NORMAL
- en: Expanding object-oriented concepts and terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will introduce essential object-oriented concepts, as well
    as applicable terminology that will accompany these key ideas.
  prefs: []
  type: TYPE_NORMAL
- en: From [*Chapter 5*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199), *Exploring
    Classes in Detail*, you now understand the key OO ideas of encapsulation and information
    hiding, and how C++ supports these ideals through the C++ class. Now, we will
    look at how we can grow a hierarchy of related classes, using a very general class
    as a building block, and then extending that class by creating a more specific
    class. Through growing a hierarchy of related classes in this repeated fashion,
    OO systems provide building blocks of potential reuse. Each class within the hierarchy
    is encapsulated, so maintenance and upgrades to a specific class can be done more
    easily and without impacts on the entire system. By incrementally refining each
    class with a more specific and more detailed class to build a hierarchy of related
    classes, specific maintenance for each component is in a focused area for maintenance
    and changes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by extending our basic OO terminology.
  prefs: []
  type: TYPE_NORMAL
- en: Deciphering generalization and specialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main object-oriented concepts extending through this chapter are *generalization*
    and *specialization*. Incorporating these principles into your design will provide
    the basis for writing more easily modifiable and maintainable code, and for code
    that could potentially be reused in related applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Generalization** describes the process of abstracting commonalities from
    a grouping of classes and creating a more generalized class for that grouping
    to house the common properties and behaviors. The more generalized class can be
    known as a **base** (or **parent**) class. Generalization can also be used to
    collect more general properties and behaviors of a single class into a base class
    with the expectation that the new, generalized class can later serve as a building
    block or basis for additional, more specific (derived) classes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Specialization** describes the process of deriving a new class from an existing,
    generalized base class, for the purpose of adding specific, distinguishable properties
    and behaviors to adequately represent the new class. The specialized class can
    also be referred to as a **derived** (or **child**) class. A hierarchy of classes
    can incrementally refine their respective properties and behaviors through specialization.'
  prefs: []
  type: TYPE_NORMAL
- en: Though reuse is difficult to achieve, the OOP concepts such as generalization
    and specialization make reuse more easily obtainable. Reuse can potentially be
    realized in applications that are similar in nature or in the same project domain,
    in continuations of existing projects, or potentially in related domains where
    minimally the most generalized classes and associated components can be reused.
  prefs: []
  type: TYPE_NORMAL
- en: Building a hierarchy is a fundamental language feature of C++. Let's move forward
    by exploring single inheritance to put this idea into action.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding single inheritance basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Inheritance** is the C++ language mechanism that allows the concepts of generalization
    and specialization to be realized. **Single inheritance** is when a given class
    has exactly one immediate base class. Both single inheritance and multiple inheritance
    are supported in C++, however, we will focus on single inheritance in this chapter
    and will cover multiple inheritance in a later chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance hierarchies can be built using both classes and structures in C++.
    Classes, however, are most often utilized rather than structures to support inheritance
    and OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Growing an inheritance hierarchy for the purpose of generalization and specialization
    supports an `Person` and a derived class of `Student`, we can say *a Student Is-A
    Person*. That is, a `Student` is a specialization of a `Person`, adding additional
    data members and member functions above and beyond those provided by its base
    class, `Person`. Specifying an Is-A relationship through generalization and specialization
    is the most typical reason inheritance is used to create base and derived classes.
    Later in this chapter, we will look at another reason to utilize inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started by looking at the language mechanics in C++ to specify base
    and derived classes and to define an inheritance hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Defining base and derived classes, and accessing inherited members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With single inheritance, the derived class specifies who its immediate ancestor
    or base class is. The base class does not specify that it has any derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: The derived class simply creates a base class list by adding a `:` after its
    class name, followed by the keyword `public` (for now), and then the specific
    base class name. Whenever you see a `public` keyword in the base class list, it
    means that we are using inheritance to specify an Is-A relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example to illustrate the basic syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Student` Is A derived class of `Person`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Simple access of inherited members can be seen using the aforementioned classes
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code fragment, the derived class instance of `Student`, pointed
    to by `s1`, can access both base and derived class members, such as `Person::GetTitle()`
    and `Student::GetGpa()`. The base class instance of `Person`, `p1`, can only access
    its own members, such as `Person::GetTitle()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at a memory model for the above example, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Memory model for current example](img/Figure_6.1_B15702.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Memory model for current example
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in the preceding memory model, a `Student` instance is comprised
    of a `Person` sub-object. That is, at the memory address indicating the beginning
    of `*s1`, a `Student`, we first see the memory layout of its `Person` data members.
    Then, we see the memory layout of its additional `Student` data members. Of course,
    `p1`, which is a `Person`, only contains `Person` data members.
  prefs: []
  type: TYPE_NORMAL
- en: Access of base and derived class members will be subject to the access regions
    specified by each class. Let's take a look to see how inherited access regions
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Examining inherited access regions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Access regions, including inherited access regions, define from which scope
    members, including inherited members, are directly accessible.
  prefs: []
  type: TYPE_NORMAL
- en: The derived class inherits all members specified in its base class. However,
    direct access to those members is subject to the access regions specified in the
    base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Members (both data and function) inherited from the *base class* are accessible
    to the *derived class* as specified by the access regions that are imposed by
    the base class. The inherited access regions and how they relate to derived class
    access are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**private** members defined in the base class are inaccessible outside the
    scope of the base class. The scope of a class includes member functions of that
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**protected** members defined in the base class are accessible in the scope
    of the base class and within the scope of the derived class, or its descendants.
    This means member functions of these classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public** members defined in the base class are accessible from any scope,
    including the scope of the derived class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous, simple example, we noticed that both a `Person` and a `Student`
    instance accessed `public` member function `Person::GetTitle()` from the scope
    of `main()`. Also, we noticed that the `Student` instance accessed its `public`
    member `Student::GetGpa()` from `main()`. Generally, outside the scope of a given
    class, the only members that are accessible are those that are in the public interface,
    such as in this example.
  prefs: []
  type: TYPE_NORMAL
- en: We will soon see a larger, full program example in this chapter showcasing the
    `protected` access region. But first, let's review inherited constructors and
    destructors so that our full program example can provide greater overall utility.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding inherited constructors and destructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through single inheritance, we can build a hierarchy of related classes. We
    have seen that when we instantiate a derived class object, memory for its base
    class data members is then followed by the additional memory required for the
    additional derived class data members. Each of these sub-objects will need to
    be constructed. Luckily, each class will have defined a suite of constructors
    for just that purpose. We then need to understand how the language can be utilized
    to allow us to specify the appropriate base class constructor for the base class
    sub-object when instantiating and constructing a derived class object.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when an object of a derived class type is no longer needed and will
    be destructed, it is important to note that a destructor for each sub-object comprising
    the derived class instance will be implicitly called on our behalf.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the constructor and destructor sequence in a single inheritance
    hierarchy, and how we can make choices when more than one constructor is available
    for a base class sub-object found in a derived class instance.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit constructor and destructor invocations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Constructors and destructors are two types of member functions that are not
    explicitly inherited by the derived class. This means that the signature of a
    base class constructor may not be used to instantiate a derived class object.
    However, we will see that when a derived class object is instantiated, the memory
    for both the base and derived class portions of the overall object will be separately
    initialized using each class' respective constructors.
  prefs: []
  type: TYPE_NORMAL
- en: When an object of a derived class type is instantiated, not only will one of
    its constructors be invoked, but so will one in each of its preceding base classes.
    The most generalized base class constructor will first be executed, followed by
    the constructors all the way down the hierarchy until we arrive at the derived
    class constructor that is the same type as the instance at hand.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when a derived class instance goes out of scope (or is explicitly
    deallocated for pointers to instances), all the relevant destructors will be invoked,
    but in the opposite order of construction. First, the derived class destructor
    will be executed, then all the destructors in an upward fashion for each preceding
    base class will be invoked and executed until we reach the most generalized base
    class.
  prefs: []
  type: TYPE_NORMAL
- en: You may now ask, how may I choose from a set of potential base class constructors
    for my base class sub-object when instantiating a derived class? Let's take a
    more detailed look at the member initialization list to discover the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Usage of the member initialization list to select a base class constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The member initialization list may be used to specify which base class constructor
    should be invoked when instantiating a derived class object. Each derived class
    constructor may specify that a different base class constructor is used to initialize
    the given base class portion of the derived class object.
  prefs: []
  type: TYPE_NORMAL
- en: If the derived class constructor's member initialization list does not specify
    which base class constructor should be utilized, the default base class constructor
    will be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: The member initialization list is specified using a `:` after the parameter
    list in the derived class constructor. To specify which base class constructor
    should be used, the name of the base class constructor, followed by parentheses
    including any values to be passed to that base class constructor, can be indicated.
    Based upon the signature of the parameters in the base class list following the
    base class name, the appropriate base class constructor will be selected to initialize
    the base class portion of the derived class object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example to illustrate the basic syntax for base class constructor
    selection:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the basic class definitions (note that many member functions
    are omitted):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructors for the previous class definitions would be as follows (notice
    two of the derived class constructors use the member initialization list):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we understand how to utilize the member initialization list to specify
    a base class constructor, let's move forward with a complete program example.
  prefs: []
  type: TYPE_NORMAL
- en: Putting all the pieces together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, in this chapter, we have seen many pieces contributing to a full program
    example. It is important to see our code in action, with all its various components.
    We need to see the basic mechanics of inheritance, how the member initialization
    list is used to specify which base class constructor should implicitly be invoked,
    and the significance of the `protected` access region.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a more complex, full program example to fully illustrate
    single inheritance. This example will be broken into segments; the full program
    can be found in the following GitHub location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter06/Chp6-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter06/Chp6-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the previous class definition, we now have a fully-fledged class definition
    for `Person`, with many more details than our simple syntax examples formerly
    used in this section. Notice that we have introduced a `protected` access region
    and placed the member function `void ModifyTitle(const char *);` in this access
    region.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving onward, let''s examine the non-line member function definitions for
    `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation for the aforesaid `Person` member functions is as expected.
    Now, let''s add the class definition for the derived class, `Student`, along with
    its inline function definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding definition of `Student`, `class Student` is derived from `Person`
    using `public` inheritance (that is, a public base class), which supports an Is-A
    relationship. Notice the `public` access label after the base class list following
    the `:` in the derived class definition (that is, `class Student: public Person`).
    Notice that our `Student` class has added data members and member functions above
    and beyond those that it automatically inherits from `Person`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, adding in the non-inline `Student` member functions, we continue growing
    our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned segment of code, we define the non-inline member functions
    of `Student`. Notice that the default constructor merely uses the member initialization
    list to initialize a data member, as we did in the last chapter. Since no `Person`
    constructor has been specified in the member initialization list of the default
    `Student` constructor, the default `Person` constructor will be used to initialize
    the `Person` sub-object when instantiating a `Student` with its default constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the alternate constructor for `Student` uses the member initialization
    list to specify that the alternate constructor of `Person` should be utilized
    to construct the `Person` sub-object contained within a given `Student` instance.
    Notice that the selected constructor will match the signature `Person::Person(char
    *, char *, char, char *)`, and that selected input parameters from the `Student`
    constructor (namely `fn`, `ln`, `mi`, and `t`) will be passed as parameters to
    the `Person` alternate constructor.
  prefs: []
  type: TYPE_NORMAL
- en: In the copy constructor for `Student`, the member initialization list is used
    to specify that the `Person` copy constructor should be called to initialize the
    `Person` sub-object of the `Student` instance that is being constructed. The `Student
    &` will be implicitly up-cast to a `Person &` as the `Person` copy constructor
    is called. Recall, the top part of a `Student` object *Is-A* `Person`, so this
    is fine. Next, in the body of the copy constructor for `Student`, we initialize
    any remaining data members the `Student` class has defined.
  prefs: []
  type: TYPE_NORMAL
- en: Moving onward, we see the `Student` destructor. Implicitly, as the *last* line
    of code in this method, a call to the `Person` destructor is patched in for us
    by the compiler. This is how the destructor sequence is automated for us. Consequently,
    the most specialized portion of the object, the `Student` pieces, will first be
    destructed, followed by the implicit call to the `Person` destructor to destruct
    the base class sub-object.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the `Print()` method for `Student`, notice that we would like to print
    out various data members that are inherited from `Person`. Alas, these data members
    are `private`. We may not access them outside the scope of the `Person` class.
    Nevertheless, the `Person` class has left us with a public interface, such as
    `Person::GetTitle()` and `Person::GetFirstName()` so that we may access these
    data members from any scope of our application, including from `Student::Print()`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we come to the `Student::EarnPhD()` method. Notice that all this method
    does is invoke the `protected` member function `Person::ModifyTitle("Dr.");`.
    Recall, `protected` members defined by the base class are accessible within the
    scope of the derived class. `Student::EarnPhD()` is a member function of the derived
    class. `EarnPhD()` provides a public interface to modify the title of a `Person`,
    perhaps after checking if the student has met graduation requirements. Because
    `Person::ModifyTitle()` is not `public`, instances of `Person` or `Student` must
    go through a controlled `public` interface to change their respective titles.
    Such interfaces might include methods such as `Student::EarnPhD()` or `Person::GetMarried()`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nonetheless, let''s complete our full program example by examining `main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the last segment of this program, in `main()`, we simply instantiate a `Student`,
    namely `s1`. The `Student` utilizes `Student::Print()` to print its current data.
    The `Student` then sets her current course set to `"Doctoral Thesis"` and then
    invokes `Student::EarnPhD();`. Note that any `public` members of `Student` or
    `Person` are available for `s1` to utilize outside the scope of their class, such
    as in `main()`. To complete the example, `s1` reprints her details using `Student::Print()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output for the full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have competency with the basic mechanics of single inheritance,
    and have used single inheritance to model an Is-A relationship, let's move onward
    to see how inheritance can be used to model a different concept by exploring protected
    and private base classes.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation inheritance – changing the purpose of inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have demonstrated using a public base class, known also as *public
    inheritance*. Public base classes are used to model Is-A relationships and provide
    the primary motivation behind building an inheritance hierarchy. This usage supports
    the concepts of generalization and specialization.
  prefs: []
  type: TYPE_NORMAL
- en: Occasionally, inheritance may use used as a tool to implement one class in terms
    of another, that is, by one class using another as its underlying implementation.
    This is known as **implementation inheritance** and it does not support the ideals
    of generalization and specialization. Yet, implementation inheritance can provide
    a quick and easily reusable way to implement one class based upon another. It
    is fast and relatively error-free. Many class libraries use this tool without
    the knowledge of their class users. It is important to distinguish implementation
    inheritance from traditional hierarchy building for the motivation of specifying
    Is-A relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation inheritance, supported in C++ with private and protected bases
    classes, is exclusive to C++. Other OOP languages choose to only embrace inheritance
    for the purpose of modeling Is-A relationships, which is supported in C++ through
    public base classes. An OO purist would endeavor to use inheritance only to support
    generalization and specialization (*Is-A*). However, using C++, we will understand
    appropriate uses of implementation inheritance so that we may use this language
    feature wisely.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move onward to understand how and why we might utilize this type of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying access labels in the base class list by using protected or private
    base classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To reiterate, the usual type of inheritance is `public` inheritance. The `public`
    label is used in the base class list for a given derived class. However, in the
    base class list, the keywords `protected` and `private` are also options.
  prefs: []
  type: TYPE_NORMAL
- en: That is, in addition to labeling access regions within a class or structure
    definition, an access label can be used in the base class list of a derived class
    definition to designate how members defined in a base class are inherited by derived
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Inherited members can only be made more restrictive than they were designated
    to be in the base class. When the derived class specifies that inherited members
    should be treated in a more restrictive fashion, any descendants of that derived
    class will also be subject to these specifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a quick example of the *base class list*:'
  prefs: []
  type: TYPE_NORMAL
- en: Recall, most often, a `public` access label will be specified in the base class
    list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, a `public` access label is used to specify that a `Person`
    is a `public` base class of `Student`. That is, a `Student` *Is-A* `Person`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Access labels specified in the *base class list* modify inherited access regions
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**public**: Public members in the base class are accessible from any scope;
    protected members in the base class are accessible from the scope of the base
    and derived classes. We are familiar with using a public base class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**protected**: Public and protected members in the base class act as though
    they are defined as protected by the derived class (that is, accessible from the
    scope of the base and derived classes, and any descendants of the derived class).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**private**: Public and protected members in the base class act as though they
    are defined as private by the derived class, allowing these members to be accessible
    within the scope of the derived class, but not within the scope of any of the
    derived class descendants.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In all cases, class members labeled as private within a class definition, are
    accessible only within the scope of the defining class. Modifying the access labels
    in the base class list can only treat inherited members more restrictively, never
    less restrictively.
  prefs: []
  type: TYPE_NORMAL
- en: In the absence of an access label specified in conjunction with the base class,
    `private` will be assumed if the user defined type is a `class`, and `public`
    will be the default if the user defined type is a `struct`. A good rule of thumb
    is to always include the access label in the base class list for a derived class
    (or structure) definition.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a base class to illustrate implementation inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand implementation inheritance, let''s review a base class that may
    serve as a basis to implement other classes. We will examine a typical pair of
    classes to implement an encapsulated `LinkList`. Though this example will be broken
    into several segments, the full example will be shown, and can also be found in
    GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter06/Chp6-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter06/Chp6-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We begin the previous segment of code with class definitions for both `LinkListElement`
    and `LinkList`. The `LinkList` class will contain data members that are pointers
    to the `head`, `tail`, and `current` element in `LinkList`. Each of these pointers
    is of type `LinkListElement`. A variety of typical `LinkList` processing methods
    are included, such as `InsertAtFront()`, `RemoveAtFront()`, `DeleteAtFront()`,
    `IsEmpty()`, and `Print()`. Let''s take a quick peek at the implementation of
    these methods with the next segment of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the previously mentioned member function definitions, we note that a `LinkList`
    can be constructed either empty or with one element (note the two available constructors).
    `LinkList::InsertAtFront()` adds an item to the front of the list for efficiency.
    `LinkList::RemoveAtFront()` removes an item and returns it to the user, whereas
    `LinkList::DeleteAtFront()` removes and deletes the front item. The `LinkList::Print()`
    function allows us to view the `LinkList` whenever necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s see a typical `main()` function to illustrate how a `LinkList`
    can be instantiated and manipulated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In `main()`, we create a few items, of type `Item`, which will later be data
    for `LinkListElement`. We then instantiate a `LinkListElement`, namely `element1`,
    and add it to a newly constructed `LinkList`, using `LinkList list1(element1);`.
    We then add several items to the list using `LinkList::InsertAtFront()`, and call
    `LinkList::Print()` to print out `list1` for a baseline. Next, we delete elements
    from `list1`, one by one, printing as we go, using `LinkList::DeleteAtFront()`
    and `LinkList::Print()`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we instantiate a second `LinkList`, namely `list2`, which starts out empty.
    We gradually insert several items using `LinkList::InsertAtFront()`, then print
    the list, and then delete each element, one by one, using `LinkList::DeleteAtFront()`,
    printing the revised list with each step.
  prefs: []
  type: TYPE_NORMAL
- en: The point of this example is not to exhaustively review the inner workings of
    this code. You are undoubtedly familiar with the concept of a `LinkList`. More
    so, the point is to establish this set of classes, `LinkListElement` and `LinkList`,
    as a set of building blocks in which several Abstract Data Types can be built.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nonetheless, the output for the preceding example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's see how `LinkList` can be used as a private base class.
  prefs: []
  type: TYPE_NORMAL
- en: Using a private base class to implement one class in terms of another
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just created a `LinkList` class to support the basic handling of an
    encapsulated linked list data structure. Now, let's imagine that we would like
    to implement an `Push()`, `Pop()`, `IsEmpty()`, and perhaps `Print()`.
  prefs: []
  type: TYPE_NORMAL
- en: You may ask how a stack is implemented. The answer is that the implementation
    does not matter, so long as it supports the expected interface of the ADT being
    modeled. Perhaps a stack is implemented using an array, or perhaps it is implemented
    in a file. Perhaps it is implemented using a `LinkedList`. Each implementation
    has pros and cons. In fact, the underlying implementation of the ADT might change,
    yet users of the ADT should not be affected by such a change. This is the basis
    of *implementation inheritance*. A derived class is implemented in terms of a
    base class, yet the underlying details of the base class from which the new class
    is derived are effectively hidden. These details cannot be directly used by instances
    of the derived class (in this case, the ADT). Nonetheless, the base class silently
    provides the implementation for the derived class.
  prefs: []
  type: TYPE_NORMAL
- en: We will use this approach to implement a `Stack` using a `LinkedList` as its
    underlying implementation. To do this, we will have `class Stack` extend `LinkedList`
    using a `private` base class. `Stack` will define a public interface for its users
    to establish the interface for this ADT, such as `Push()`, `Pop()`, `IsEmpty()`,
    and `Print()`. The implementation of these member functions will make use of selected
    `LinkedList` member functions, but `Stack` users will not see this, nor will `Stack`
    instances be able to use any `LinkList` members directly themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are not saying a `Stack` *Is-A* `LinkList`, but rather, a `Stack` is
    implemented in terms of a `LinkedList` at the moment—and that underlying implementation
    could change!
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to implement `Stack` is simple. Assume we are using the `LinkList`
    and `LinkListElement` classes from the previous example. Let''s add the `Stack`
    class here. The full program example can be found in our GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter06/Chp6-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter06/Chp6-Ex3.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice how compact the aforementioned code is for our `Stack` class! We begin
    by specifying that `Stack` has a `private` base class of `LinkList`. Recall, a
    `private` base class means that the `protected` and `public` members inherited
    from `LinkList` act as though they were defined by `Stack` as `private` (and are
    only accessible within the scope of `Stack`, that is, member functions of `Stack`).
    This means that instances of `Stack` may not use the *former* public interface
    of `LinkList`. This also means that the underlying implementation of `Stack` as
    a `LinkList` is effectively hidden. Of course, `LinkList` instances are not affected
    in any way and may use their `public` interface as usual.
  prefs: []
  type: TYPE_NORMAL
- en: We easily define `Stack::Push()` to simply call `LinkList::InsertAtFront()`,
    just as `Stack::Pop()` does little more than call `LinkList::RemoveAtFront()`.
    Even though `Stack` would love to simply use the inherited implementations of
    `LinkList::IsEmpty()` and `LinkList::Print()`, due to `LinkList` being a `private`
    base class, these functions are not part of the public interface of `Stack`. Accordingly,
    `Stack` adds an `IsEmpty()` method, which simply calls `LinkList::IsEmpty();`.
    Notice the use of the scope resolution operator to specify the `LinkList::IsEmpty()`
    method; without the base class qualification, we would be adding a recursive function
    call! This call to the base class method is allowed because `Stack` member functions
    can call the *once public* methods of `LinkList` (they are now treated as `private`
    within `Stack`). Similarly, `Stack::Print()` merely calls `LinkList::Print()`.
  prefs: []
  type: TYPE_NORMAL
- en: In the scope of `main()`, we instantiate a `Stack`, namely `stack1`. Using the
    public interface of `Stack`, we easily manipulate `stack1` using `Stack::Push()`,
    `Stack::Pop()`, `Stack::IsEmpty()`, and `Stack::Print()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for this example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that a pointer to a `Stack` instance cannot be up-cast
    to be stored as a pointer to a `LinkList`. Up-casting is not allowed across a
    `private` base class boundary. This would allow a `Stack` to reveal its underlying
    implementation; C++ does not allow this to happen. Here, we see that a `Stack`
    is merely implemented in terms of a `LinkList`; we are not saying that a `Stack`
    *Is-A* `LinkedList`. This is the concept of implementation inheritance in its
    best light; this example illustrates implementation inheritance favorably.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's move forward to see how we can use a `protected` base class, and
    how that differs from a `private` base class using implementation inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Using a protected base class to implement one class in terms of another
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just implemented a `Stack` in terms of a `LinkList` using a `private`
    base class. Now, let's implement a `Queue` and a `PriorityQueue`. We will implement
    a `Queue` using `LinkList` as a `protected` base class, and a `PriorityQueue`
    using `Queue` as a `public` base class.
  prefs: []
  type: TYPE_NORMAL
- en: Again, `Queue` and `PriorityQueue` are ADTs. It is (relatively) unimportant
    how a `Queue` is implemented. The underlying implementation may change. Implementation
    inheritance allows us to implement our `Queue` using a `LinkedList` without revealing
    the underlying implementation to users of the `Queue` class.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our class `Queue` will use `LinkedList` as a `protected` base class. `Queue`
    will define a public interface for its users to establish the expected interface
    for this ADT, such as `Enqueue()`, `Dequeue()`, `IsEmpty()`, and `Print()`. The
    implementation of these member functions will make use of selected `LinkedList`
    member functions, but `Queue` users will not see this, nor will `Queue` instances
    be able to use any `LinkList` members directly themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, our class `PriorityQueue` will extend `Queue` using `public` inheritance.
    That's right, we're back to Is-A. We are saying that a `PriorityQueue` *Is-A*
    `Queue`, and a `Queue` is implemented using a `LinkedList`.
  prefs: []
  type: TYPE_NORMAL
- en: We will just add a priority enqueuing method to our `PriorityQueue` class; this
    class will be glad to inherit the `public` interface from `Queue` (but obviously
    not from `LinkList`, which luckily is hidden behind a `protected` base class at
    its parent's level).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to implement `Queue` and `PriorityQueue` is again straightforward.
    The `LinkList` base class needs to be augmented to be more fully functional in
    order to proceed. The `LinkListElement` class can remain the same. We will show
    the basics of the revised `LinkList` class with only its class definition. The
    full code for both `Queue` and `PriorityQueue` will be shown in a separate segment.
    The full program example can be found in our GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter06/Chp6-Ex4.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter06/Chp6-Ex4.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `LinkList` has been expanded to have a fuller set of features, such
    as being able to add, remove, and delete elements at various positions within
    the `LinkList`. To save example space, we will not show the implementation of
    these methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add the class definitions for `Queue` and `PriorityQueue` in the
    next code segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the previous segment of code, we define the `Queue` and `PriorityQueue` classes.
    Notice that `Queue` has a `protected` base class of `LinkList`. With a `protected`
    base class, the `protected` and `public` members inherited from `LinkList` act
    as though they are defined by `Queue` as `protected`, which means that these inherited
    members are not only accessible within the scope of `Queue`, but also within any
    potential descendants of `Queue`. As before, these restrictions only apply to
    the `Queue` class, its descendants, and their instances; the `LinkList` class
    and its instances are unaffected.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Queue` class, no new data members are necessary. The internal implementation
    is handled by `LinkList`. With a `protected` base class, we are saying that the
    `Queue` is implemented using a `LinkList`. Nonetheless, we must provide the `public`
    interface for `Queue` and we do so by adding methods such as `Queue::Enqueue()`,
    `Queue::Dequeue()`, `Queue::IsEmpty()`, and `Queue::Print()`. Notice that in their
    implementations, these methods merely call `LinkList` methods to perform the necessary
    operations. Users of `Queue` must use the `Queue` public interface; the *once
    public* `LinkList` interface is hidden to `Queue` instances.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define `PriorityQueue`, another ADT. Notice that `PriorityQueue` defines
    `Queue` as a `public` base class. We are back to inheritance to support an Is-A
    relationship. A `PriorityQueue` *Is-A* `Queue` and can do everything a `Queue`
    can do, and just a little more. As such, `PriorityQueue` inherits as usual from
    `Queue`, including the `Queue` public interface. `PriorityQueue` needs only add
    an additional method for priority enqueuing, namely `PriorityQueue::PriorityEnqueue()`.
  prefs: []
  type: TYPE_NORMAL
- en: Since `Queue` has a protected base class of `LinkList`, the `public` interface
    from `LinkList` is considered `protected` to `Queue` and its descendants, including
    `PriorityQueue`, so that `LinkList`'s *once public* methods are considered `protected`
    to both `Queue` and `PriorityQueue`. Notice that `PriorityQueue::PriorityEnqueue()`
    makes use of `LinkList::InsertBeforeItem()`. This would not be possible if `LinkList`
    were a `private`, versus a `protected`, base class of `Queue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the class definitions and implementation in place, let''s continue with
    our `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, in `main()`, we instantiate a `Queue`, namely `q1`, which utilizes the
    public interface of `Queue`. Note that `q1` may not use the *once public* interface
    of `LinkList`. The `Queue` may only behave like a `Queue`, not a `LinkList`. The
    ADT of `Queue` is preserved.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we instantiate a `PriorityQueue`, namely `q2`, which utilizes the public
    interface of both `Queue` and `PriorityQueue`, such as `Queue::Enqueue()`, and
    `PriorityQueue::PriorityEnqueue()`. Because a `Queue` *Is-A* `PriorityQueue` (`Queue`
    is the `public` base class), the typical mechanics of inheritance are in place,
    allowing `PriorityQueue` to utilize the public interface of its ancestors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for this example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we have seen two examples of using implementation inheritance; it is
    not an often-used feature of C++. However, you now understand `protected` or `private`
    base classes should you run across them in library code, application code that
    you are maintaining, or the rare opportunity in which this technique may prove
    useful for a programming task you may encounter.
  prefs: []
  type: TYPE_NORMAL
- en: We have now covered the basic features of single inheritance in C++. Let's quickly
    review what we've covered before moving to the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have moved further along our journey with object-oriented
    programming. We have added additional OO concepts and terms, and have seen how
    C++ has direct language support for these concepts. We have seen how inheritance
    in C++ supports generalization and specialization. We have seen how to incrementally
    build a hierarchy of related classes.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to grow inheritance hierarchies using single inheritance, and
    how to access inherited data members and member functions. We have reviewed access
    regions to understand which inherited members may directly accessed, based upon
    the access regions in which the members are defined in the base class. We know
    that having a `public` base class equates to defining an Is-A relationship, which
    supports the ideals of generalization and specialization, which is the most commonly
    used reason for inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: We have detailed the order of constructor and destructor invocations when instances
    of derived class types are instantiated and destroyed. We have seen the member
    initialization list to select which inherited constructor a derived class object
    may choose to utilize as part of its own construction (for its base class sub-object).
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how changing access labels in a base class list changes the OO
    meaning for the type of inheritance being used. By comparing `public` versus `private`
    and `protected` base classes, we now understand different types of hierarchies,
    such as those built to support Is-A relationships, versus those built to support
    implementation inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that base classes in our hierarchies may serve as potential building
    blocks for more specialized components, leading to potential reuse. Any potential
    reuse of existing code saves development time and cuts down on the maintenance
    of otherwise duplicated code.
  prefs: []
  type: TYPE_NORMAL
- en: Through extending our OOP knowledge, we gained a preliminary set of skills relating
    to inheritance and hierarchy building in C++. With the basic mechanics of single
    inheritance under our belts, we can now move forward to learn many more interesting
    object-oriented concepts and details relating to inheritance. Continuing to [*Chapter
    7*](B15702_07_Final_NM_ePub.xhtml#_idTextAnchor298), *Utilizing Dynamic Binding
    through Polymorphism*, we will next learn how to dynamically bind methods to their
    respective operations in a hierarchy of related classes.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using your [*Chapter 5*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199) solution,
    create a C++ program to build an inheritance hierarchy, generalizing `Person`
    as a base class from the derived class of `Student`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Decide which data members and member functions of your `Student` class are
    more generic and would be better positioned in a `Person` class. Build your `Person`
    class with these members, including appropriate constructors (default, alternate,
    and copy), a destructor, access member functions, and a suitable public interface.
    Be sure to place your data members in the private access region.
  prefs: []
  type: TYPE_NORMAL
- en: b. Using a `public` base class, derive `Student` from `Person`. Remove members
    from `Student` that are now represented in `Person`. Adjust constructors and the
    destructor accordingly. Use the member initialization list to specify base class
    constructors as needed.
  prefs: []
  type: TYPE_NORMAL
- en: c. Instantiate both `Student` and `Person` several times and utilize the appropriate
    `public` interfaces on each. Be sure to dynamically allocate several instances.
  prefs: []
  type: TYPE_NORMAL
- en: d. Add a message using `cout` as the first line in each of your constructors
    and as the first line in your destructors so that you can see the construction
    and destruction order of each instance.
  prefs: []
  type: TYPE_NORMAL
- en: (Optional) Complete the class hierarchy that includes `LinkList`, `Queue`, and
    `PriorityQueue`, using the online code as a basis. Complete the remaining operations
    in the `LinkList` class, and call them as appropriate in the public interface
    of `Queue` and `PriorityQueue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Be sure to add copy constructors for each class (or prototype them in the
    private access region or use `= delete` in the prototype to suppress copying).
  prefs: []
  type: TYPE_NORMAL
- en: b. Instantiate `LinkList` using either constructor, then demonstrate how each
    of your operations works. Be sure to invoke `Print()` after adding or deleting
    an element.
  prefs: []
  type: TYPE_NORMAL
- en: c. Instantiate `Queue` and `PriorityQueue`, and demonstrate that each of the
    operations in their `public` interfaces works correctly. Remember to demonstrate
    the inherited operations in the `public` interface of `Queue` for instances of
    `PriorityQueue`.
  prefs: []
  type: TYPE_NORMAL

- en: '*Chapter 7*: Utilizing Dynamic Binding through Polymorphism'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will further extend our knowledge of object-oriented programming
    in C++. We will begin by introducing a powerful OO concept, **polymorphism**,
    and then understand how this idea is implemented in C++ through *direct language
    support*. We will implement polymorphism using virtual functions in hierarchies
    of related classes, and understand how we can achieve runtime binding of a specific
    derived class method to a more generic, base class operation. We will understand
    how the OO concept of polymorphism presented in this chapter will support versatile
    and robust designs and easily extensible code in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the OO concept of polymorphism and why it is important to OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining virtual functions, understanding how virtual functions override base
    class methods, generalizing derived class objects, the need for virtual destructors,
    and function hiding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding dynamic (runtime) binding of methods to operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A detailed understanding of the **virtual function table** (**v-table**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the OO concept of polymorphism,
    and how to implement this idea in C++ through virtual functions. You will understand
    how virtual functions enable runtime binding of methods to operations in C++.
    You will see how an operation can be specified in a base class and overridden
    with a preferred implementation in a derived class. You will understand when and
    why it is important to utilize a virtual destructor.
  prefs: []
  type: TYPE_NORMAL
- en: You will see how instances of derived classes are often stored using base class
    pointers and why this is significant. We will discover that regardless of how
    an instance is stored (as its own type or as that of a base class), the correct
    version of a virtual function will always be applied through dynamic binding.
    Specifically, you will see how runtime binding works under the hood as we examine
    virtual function pointers and virtual function tables in C++.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding the direct language support of polymorphism in C++ using virtual
    functions, you will be on your way to creating an extensible hierarchy of related
    classes, featuring dynamic binding of methods to operations. Let's augment our
    understanding of C++ as an OOP language by detailing these ideals.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found at the following GitHub
    URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter07](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter07).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds with the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter07` in a file named `Chp7-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/317dxf3](https://bit.ly/317dxf3).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the OO concept of polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will introduce an essential object-oriented concept, polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: From [*Chapter 5*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199), *Exploring
    Classes in Detail*, and [*Chapter 6*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262),
    *Implementing Hierarchies with Single Inheritance*, you now understand the key
    OO ideas of encapsulation, information hiding, generalization, and specialization.
    You know how to encapsulate a class, build inheritance hierarchies using single
    inheritance, and various reasons to build hierarchies (such as supporting Is-A
    relationships or for the lesser-used reason of supporting implementation inheritance).
    Let's begin by extending our basic OO terminology by exploring **polymorphism**.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a base class specifies an operation such that a derived class may redefine
    the operation in its class with a more suitable method, the operation is said
    to be **polymorphic**. Let''s revisit our definitions of operation and method,
    as well as their implications, to understand how these concepts lay the groundwork
    for polymorphism:'
  prefs: []
  type: TYPE_NORMAL
- en: In C++, an **operation** maps to the complete signature of the member function
    (name plus type and number of arguments – no return type).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, in C++, a **method** maps to the definition or body of the operation
    (that is, the implementation or body of the member function).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recall, in OO terms, an **operation** implements a behavior of a class. The
    implementation of a base class operation may be via several distinct derived class
    **methods**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Student` Is-A `Person`. Yet, a polymorphic operation will allow `Student`
    behaviors to be revealed on `Student` objects, even when they have *taken on the
    form* of a `Person`.'
  prefs: []
  type: TYPE_NORMAL
- en: As we progress through this chapter, we will see derived class objects taking
    on the form of their public base classes, that is, taking on *many forms* (**polymorphism**).
    We will see how a polymorphic operation can be specified in a base class and overridden
    with a preferred implementation in a derived class.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at the C++ language feature that allows us to implement
    polymorphism, namely, virtual functions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing polymorphism with virtual functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism allows dynamic binding of a method to an operation. Dynamic, or
    runtime, binding of a method to an operation is important because derived class
    instances may be pointed to by base class objects (that is, by pointers of a base
    class type). In these situations, the pointer type does not provide adequate information
    regarding the correct method that should be applied to the referenced instance.
    We need another way – one done at runtime – to determine which method applies
    to each instance.
  prefs: []
  type: TYPE_NORMAL
- en: Often, it is the case that a pointer to an instance of a derived class type
    will be generalized as a pointer to the base class type. When an operation is
    applied to the pointer, the correct method for what the object truly is should
    be applied, rather than the method that *seems* appropriate for the generalized
    pointer type.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin with the relevant keywords and logistics necessary to define virtual
    functions so that we may implement polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Defining virtual functions and overriding base class methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Virtual functions** in C++ directly support polymorphism. A **virtual function**
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: A member function that correctly allows methods for a given operation to be
    overridden successively in a hierarchy to provide more suitable definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A member function that allows dynamic, rather than the usual static binding
    for methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A virtual function is specified using the keyword **virtual**. More specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: The keyword `virtual` should precede the return type of the function in its
    prototype.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions in the derived class with the same name and signature as a virtual
    function in any ancestor class redefine the virtual function in those base classes.
    Here, the keyword `virtual` is optional but recommended in the derived class prototype.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with the same name, yet a different signature in a derived class,
    do not redefine a virtual function in their base class; rather they hide the methods
    found in their base classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, the keyword `override` can be added as part of the extended signature
    in the derived class prototype. This recommended practice will allow the compiler
    to flag an error if the signature of the intended overridden method does not match
    the signature as specified in the base class. The `override` keyword can eliminate
    un-intended function hiding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The derived class need not redefine virtual functions specified in its base
    class if the inherited methods are suitable. However, should a derived class redefine
    an operation with a new method, the same signature (as specified by the base class)
    must be used for the overridden method. Furthermore, derived classes should only
    redefine virtual functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example to illustrate the basic syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Print()` is a virtual function defined in the base class `Person`. It will
    be overridden with a more appropriate implementation in the `Student` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The virtual function defined in the base class `Person` is, in fact, overridden
    with a more appropriate implementation in the `Student` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Remember, polymorphic functions are meant to have the ability to override or
    replace base class versions of a given function. Function overriding differs from
    function overloading.
  prefs: []
  type: TYPE_NORMAL
- en: Important distinction
  prefs: []
  type: TYPE_NORMAL
- en: '**Function overriding** is defined by introducing the same function name with
    the same signature, in a hierarchy of related classes (via virtual functions),
    whereas the derived class version is meant to replace the base class version.
    In contrast, **function overloading** is defined when two or more functions with
    the same name, but with different signatures, exist in the same scope of the program
    (such as in the same class).'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, operations not initially specified as virtual when introduced
    in a base class definition are not polymorphic and therefore should not be overridden
    in any derived class. This means that if a base class does not use the keyword
    `virtual` when defining an operation, the base class does not intend for the derived
    class to redefine this operation with a more suitable derived class method. The
    base class instead is insisting that the implementation it has provided is suitable
    for *any* of its descendants. Should the derived class attempt to redefine a non-virtual
    base class operation, a subtle bug will be introduced into the application. The
    error will be that derived class instances stored using derived class pointers
    will use the derived class method, yet derived class instances stored using base
    class pointers will use the base class definition. Instances should always use
    their own behavior irrespective of how they are stored – this is the point of
    polymorphism. Never redefine a non-virtual function.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Operations not specified in a base class as virtual in C++ are not polymorphic,
    and should never be overridden by a derived class.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move forward and discover scenarios when we may desire to collect derived
    class objects by a base class type, and when we may then need to qualify our destructors
    as virtual.
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing derived class objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we view an inheritance hierarchy, it is typically one that employs public
    base classes; that is, it is a hierarchy that utilizes public inheritance to express
    Is-A relationships. When using inheritance in this manner, we may be motivated
    to collect groups of related instances together. For example, a hierarchy of `Student`
    specializations might include `GraduateStudent`, `UnderGraduateStudent`, and `NonDegreeStudent`.
    Assuming each of these derived classes has a public base class of `Student`, it
    would be appropriate to say a `GraduateStudent` *Is-A* `Student`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We may find a reason in our application to group these somewhat like instances
    together into one common set. For example, imagine that we are implementing a
    billing system for a university. The university may wish for us to collect all
    students, regardless of their derived class types, into one set to process them
    uniformly, such as to calculate their semester bills.
  prefs: []
  type: TYPE_NORMAL
- en: The `Student` class may have a polymorphic operation to `CalculateSemesterBill()`,
    which is implemented as a virtual function in `Student` with a default method.
    However, selected derived classes, such as `GraduateStudent`, may have preferred
    implementations that they wish to provide by overriding the operation in their
    own class with a more appropriate method. A `GraduateStudent`, for example, may
    have a different method to compute their total bill versus `NonDegreeStudent`.
    Hence, each derived class may override the default implementation of `CalculateSemesterBill()`
    in each of their classes.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, in our bursar application, we can create a set of pointers of type
    `Student`, though each pointer will inevitably point to instances of the derived
    class types, such as `GraduateStudent`, `UnderGraduateStudent`, and `NonDegreeStudent`.
    When instances of derived class types have been generalized in this fashion, it
    is appropriate to apply functions (often virtual) to the set as are defined in
    the base class level corresponding to the pointer type of the collection. Virtual
    functions allow these generalized instances to invoke a polymorphic operation
    to yield their individual, derived class methods or implementations of these functions.
    This is exactly what we want. But, there are still more details to understand.
  prefs: []
  type: TYPE_NORMAL
- en: This basic premise of generalizing derived class instances will allow us to
    understand why we may need virtual destructors within many of our class definitions.
    Let's take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing virtual destructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now conceptualize situations when grouping derived class instances into
    a somewhat alike set, stored by their common base class type, may be useful. It
    is actually very powerful to collect sibling-type derived class instances by their
    base class type and employ virtual functions to allow their distinct behaviors
    to shine through.
  prefs: []
  type: TYPE_NORMAL
- en: But let's consider what happens when the memory for a derived class instance,
    stored by a base class pointer, goes away. We know its destructor is called, but
    which one? We actually know that a chain of destructors is called, starting with
    the destructor of the object type in question. But how do we know the actual derived
    class object type if the instance has been genericized by being stored using a
    base class pointer? A **virtual destructor** solves this issue.
  prefs: []
  type: TYPE_NORMAL
- en: By labeling a destructor as `virtual`, we are allowing it to be overridden as
    the *starting point* in the destruction sequence for a class and any of its descendants.
    The choice as to which destructor to use as the entry point of destruction will
    be deferred to runtime, using dynamic binding, based on the object's actual type,
    not what pointer type may be which references it. We will soon see how this process
    is automated by examining C++'s underlying virtual function table.
  prefs: []
  type: TYPE_NORMAL
- en: A virtual destructor, unlike all other virtual functions, actually specifies
    the starting point for a full sequence of functions to be executed. Recall, as
    the last line of code in a destructor, the compiler automatically patches in a
    call to call the immediate base class destructor, and so on, until we reach the
    initial base class in the hierarchy. The destruction chain exists to provide a
    forum to release dynamically allocated data members in all sub-objects of a given
    instance. Contrasting this behavior to other virtual functions, those merely allow
    the single, correct version of the function to be executed (unless the programmer
    chooses to call a base class version of the same function as a helper function
    during the derived method implementation).
  prefs: []
  type: TYPE_NORMAL
- en: You may ask why is it important to start the destruction sequence at the proper
    level? That is, at the level that matches the object's actual type (versus a generalized
    pointer type, which may point to the object). Recall, each class may have dynamically
    allocated data members. The destructor will deallocate these data members. Starting
    with the correct level destructor will ensure that you do not introduce any memory
    leaks into your application by forgoing appropriate destructors and their corresponding
    memory deallocations.
  prefs: []
  type: TYPE_NORMAL
- en: Are virtual destructors always necessary? That is a good question! Virtual destructors
    are always necessary when using a public base class hierarchy, that is, when using
    public inheritance. Recall, public base classes support Is-A relationships, which
    easily leads to allowing a derived class instance to be stored using a pointer
    of its base class type. For example, a `GraduateStudent` *Is-A* `Student`, so
    we can store a `GraduateStudent` as a `Student` at times when we require more
    generic processing along with its sibling types. We can always upcast in this
    fashion across a public inheritance boundary. However, when we use implementation
    inheritance (that is, private or protected base classes), upcasting is not allowed.
    So, for hierarchies employing private or protected inheritance, virtual destructors
    are not necessary because upcasting is simply disallowed; hence, it would never
    be ambiguous as to which destructor should be the entry point for classes in private
    and protected base class hierarchies. As a second example, we did not include
    a virtual destructor in our `LinkedList` class in [*Chapter 6*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262),
    *Implementing Hierarchies with Single Inheritance*; therefore, `LinkedList` should
    only be extended as a protected or private base class. We did, however, include
    a virtual destructor in our `Queue` and `PriorityQueue` classes because `PriorityQueue`
    uses `Queue` as a public base class. A `PriorityQueue` may be upcast to a `Queue`
    (but not to a `LinkedList`), necessitating the virtual destructor introduction
    at the `Queue` and its descendent levels in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Are the optional keywords `virtual` and `override` recommended when overriding
    a virtual destructor? That's also a good question. We know that an overridden
    destructor is only the starting point in the destruction sequence. We also know
    that unlike other virtual functions, the derived class destructor will have a
    unique name from the base class destructor. Even though a derived class destructor
    automatically overrides a base class destructor that has been declared as `virtual`,
    the usage of the *optional* keyword `virtual` is recommended in the derived class
    destructor prototype for documentation. However, the usage of the *optional* keyword
    `override` in the derived class destructor is generally not used. The reasoning
    is that the `override` keyword is meant to provide a safety net to catch spelling
    mistakes between originally defined and overridden functions. With destructors,
    the function names are not the same, hence this safety net is not an error-checking
    advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue by putting all the necessary pieces together so we can see virtual
    functions of all varieties, including destructors, in action.
  prefs: []
  type: TYPE_NORMAL
- en: Putting all the pieces together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, in this chapter, we have understood the nuances of virtual functions,
    including virtual destructors. It is important to see our code in action, with
    all its various components and details. We need to see in one cohesive program
    the basic syntax to specify virtual functions, including how we may collect derived
    class instances by base class types, and see how virtual destructors play a role.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a more complex, full program example to fully illustrate
    polymorphism, implemented using virtual functions in C++. This example will be
    broken into many segments; the full program can be found at the following GitHub
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter07/Chp7-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter07/Chp7-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned class definition, we have augmented our familiar class
    for `Person`, adding four virtual functions, namely, the destructor (`~Person()`),
    `Print()`, `IsA()`, and `Greeting(const char *)`. Notice that we have simply placed
    the keyword `virtual` in front of the return type (if any) of each member function.
    The remainder of the class definition is as we have explored in depth in the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s examine the non-inline member function definitions for `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previous segment of code, we have specified all of the non-inline member
    functions of `Person`. Notice that the four virtual functions—the destructor,
    `Print()`, `IsA()`, and `Greeting()`—do not include the `virtual` keyword in the
    methods (that is, member function definitions) themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s examine the `Student` class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the previous class definition for `Student`, we again have all of the assorted
    components we are accustomed to seeing to comprise this class. Additionally, notice
    that we have defined three virtual functions—the destructor, `Print()`, and `IsA()`.
    These preferred definitions essentially replace or override the default methods
    specified for these operations in the base class. Notice, however, that we choose
    not to redefine `void Person::Greeting(const char *)`, which was introduced as
    a virtual function in the `Person` class. Simply inheriting this method is fine
    if we find the inherited definition acceptable for instances of the `Student`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Recall, the meaning of `virtual` when paired with a destructor is unique, in
    that it does not imply that the derived class destructor replaces the base class
    destructor. Instead, it means that the derived class destructor is the correct
    beginning point for the *chain of destruction* sequence when initiated by derived
    class instances (irrespective of how they are stored).
  prefs: []
  type: TYPE_NORMAL
- en: Also, remember, the derived class of `Student` is not required to override a
    virtual function that is defined in `Person`. Should the `Student` class find
    the base class method acceptable, it is automatically inherited. Virtual functions
    merely allow the derived class to redefine an operation with a more appropriate
    method when so needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s examine the non-inline `Student` class member functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the previously listed section of code, we list the non-inline member function
    definitions for `Student`. Again, notice that the keyword `virtual` will not appear
    in any of the non-inline member function definitions themselves, only in their
    respective prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let''s examine the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, in `main()`, we declare an array of pointers to `Person`. Doing so allows
    us to collect both `Person` and `Student` instances in this set. Of course, the
    only operations we may apply to instances stored in this generalized fashion are
    those found in the base class, `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we allocate several `Person` and several `Student` instances, storing
    each instance via an element in the generalized set of pointers. When a `Student`
    is stored in this fashion, an up-cast to the base class type is performed (but
    the instance is not altered in any fashion). Recall, when we looked at memory
    layout for derived class instances in [*Chapter 6*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262),
    *Implementing Hierarchies with Single Inheritance*, we noticed that a `Student`
    instance first includes the memory layout of a `Person`, followed by the additional
    memory required for `Student` data members. This up-cast merely points to the
    starting point of this collective memory.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we proceed through a loop to apply operations as found in the `Person`
    class to all instances in this generalized collection. These operations happen
    to be polymorphic. That is, the virtual functions allow the specific implementation
    for methods to be called through runtime binding to match the actual object type
    (irrespective of the fact that the object may be stored in a generalized pointer).
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we loop through deleting the dynamically allocated instances of `Person`
    and `Student`, again using the generalized `Person` pointers. Because we know
    `delete()` will patch in a call to the destructor, we wisely have made the destructors
    `virtual`, enabling dynamic binding to choose the appropriate starting destructor
    (in the destruction chain) for each object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we look at the output for the aforementioned program, we can see that
    the specific method for each object is appropriately called for each virtual function,
    including the destruction sequence. Here is the output for the full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have competency utilizing the concept of polymorphism and the mechanics
    of virtual functions, let's take a look at a less usual situation relating to
    virtual functions, that of function hiding.
  prefs: []
  type: TYPE_NORMAL
- en: Considering function hiding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Function hiding** is not an often-used feature of C++. In fact, it is often
    employed quite by accident! Let''s review a key point we know about inherited
    member functions to get started. When an operation is specified by a base class,
    it is intended to provide a protocol for usage and redefinition (in the case of
    virtual functions) for all derived class methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, a derived class will alter the signature of a method that is intended
    to redefine an operation specified by a base class (let's think of virtual functions).
    In this case, the new function, which differs in signature from the operation
    specified in its ancestor class, will not be considered a virtual redefinition
    of the inherited operation. In fact, it will *hide* inherited methods for the
    virtual function that have the same name specified in ancestor classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When programs are compiled, the signature of each function is compared against
    the class definition for correct usage. Typically, when a member function is not
    found in the class that *seemingly* matches the instance type, the hierarchy is
    traversed in an upward fashion until such a match is found or until the hierarchy
    is exhausted. Let us take a closer look at what the compiler contemplates:'
  prefs: []
  type: TYPE_NORMAL
- en: When a function is found with the same name as the function being sought out,
    the signature is examined to see if it matches the function call exactly, or if
    type conversion can be applied. When the function is found, yet type conversion
    cannot be applied, the normal traversal sequence is ended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions that hide virtual functions normally halt this upward search sequence,
    thus hiding a virtual function that otherwise may have been invoked. Recall, at
    compile time, we are just checking syntax (not deciding which version of a virtual
    function to call). But if we can't find a match, an error is flagged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function hiding is actually considered helpful and was intended by the language.
    If the class designer provided a specific function with a given signature and
    interface, that function should be used for instances of that type. Hidden or
    unsuspected functions mentioned previously in the hierarchy should not be used
    in this specific scenario.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following modification to our previous full program example to
    first illustrate function hiding, and to then provide a more flexible solution
    managing function hiding:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that the `Person` class introduces `virtual void Print()` with no parameters.
    Imagine that `Student`, instead of overriding `Print()` with the same signature,
    changes the signature to `virtual void Print(const char *)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at some of the cumbersome code that might ensue:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicit down casting or use of the scope resolution operator may be required
    to reveal an otherwise hidden function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned example, we have a generalized set of two `Person` pointers.
    One entry points to a `Person` and one entry points to a `Student`. Once the `Student`
    is generalized, the only applicable operations are those found in the `Person`
    base class. Therefore, a call to `people[1]->Print();` works and a call to `people[1]->Print("Go
    Team!");` does not work. The latter call to `Print(const char *)` is an error
    at the generalized base class level, even though the object truly is a `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: If, from a generalized pointer, we wish to call specific functions found at
    the `Student` level in the hierarchy, we will then need to downcast the instance
    back to its own type (`Student`). We add a downcast with the call `((Student *)
    people[1])->Print("I have to study");`. Here, we are taking a risk – if `people[1]`
    was actually a `Person` and not a `Student`, this would generate a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we instantiate `Student s1;`. Should we try to call `s1.Print()`, we'll
    get a compiler error – `Student::Print(const char *)` hides the base class presence
    of `Person::Print()`. Remember, `s1` is stored in its own type, `Student`, and
    since `Student::Print(const char *)` is found, the traversal upward to otherwise
    uncover `Person::Print()` is halted.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, our call to `s1.Print("I got an A!");` is successful because `Print(const
    char *)` is found at the `Student` class level. Lastly, notice that the call to
    `s1.Person::Print();` works, but requires knowledge of the otherwise hidden function.
    By using the scope resolution operator (`::`), we can find the base class version
    of `Print()`. Even though `Print()` is virtual in the base class (implying dynamic
    binding), using the scope resolution operation reverts this call to a statically
    bound function call.
  prefs: []
  type: TYPE_NORMAL
- en: Let's propose that we would like to add a new interface to a derived class with
    a function that would otherwise hide a base class function. Knowing about function
    hiding, what should we ideally do? We could simply override the virtual function
    as found in the base class with a new method in the derived class, and then we
    could overload that function to add the additional interface. Yes, we're now both
    overriding and overloading. That is, we are overriding the base class function,
    and overloading the overridden function in the derived class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what we would now have:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the more flexible interface to add the new member function while keeping
    the existing interface that would otherwise be hidden:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Overall, function hiding does not surface often. But when it does, it is often
    an unwelcome surprise. Now you understand what may happen and why, making you
    a better programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at all the uses surrounding virtual functions, let's
    look under the hood to see why virtual functions are able to support the dynamic
    binding of a specific method to an operation. To thoroughly understand runtime
    binding, we will need to look at the v-table. Let's move forward!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding dynamic binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how polymorphism is implemented with virtual functions
    to allow for dynamic binding of an operation to a specific implementation or method,
    let's understand why virtual functions allow for runtime binding.
  prefs: []
  type: TYPE_NORMAL
- en: Non-virtual functions are statically bound at compile time. That is, the address
    of the function in question is determined at compile time, based on the assumed
    type of the object at hand. For example, if an object is instantiated of type
    `Student`, a function call would have its prototype verified starting with the
    `Student` class, and if not found, the hierarchy would be traversed upward to
    each base class, such as `Person`, to look for the matching prototype. When found,
    the correct function call would be patched in. This is how static binding works.
  prefs: []
  type: TYPE_NORMAL
- en: However, a virtual function is a type of function in C++ that employs a dynamic
    binding at runtime. At compile time, any virtual function call is merely replaced
    with a lookup mechanism to delay binding until runtime. Certainly, each compiler
    vendor may differ in their implementation of automating virtual functions. However,
    there is a widely utilized implementation that involves virtual function pointers,
    a virtual function table, and virtual function table entries for each object type
    containing virtual functions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move forward to investigate how dynamic binding is commonly implemented
    in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Comprehending runtime binding of methods to operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know that virtual functions allow for the dynamic binding of an operation
    (specified in a base class) to a specific implementation or method (often specified
    in a derived class). How does this work?
  prefs: []
  type: TYPE_NORMAL
- en: When a base class specifies one or more new virtual functions (not just redefinitions
    of an ancestor's virtual functions), a **virtual function pointer** (**vptr**)
    is created below the memory comprising a given instance of that type. This happens
    at runtime when the memory for an instance is created (on the stack, heap, or
    static/extern area). When the instance in question is constructed, not only will
    the appropriate constructor be called to initialize the instance, but this VPTR
    will be initialized to point to the **virtual function pointer table** (**v-table**)
    entry for that class type.
  prefs: []
  type: TYPE_NORMAL
- en: The v-table entry for a given class type will consist of a set of function pointers.
    These function pointers are often organized into an array of function pointers.
    A **function pointer** is a pointer to an actual function. By dereferencing this
    pointer, you will actually invoke the function to which the pointer points. There
    is an opportunity to pass arguments to the function, however, in order for this
    call to be generic through a function pointer, the arguments must be uniform for
    any version of this function that the pointer in question may point to. The premise
    of a function pointer gives us the ability to point to different versions of a
    particular function. That is, we could point to different methods for a given
    operation. This is the basis for which we can automate dynamic binding in C++
    for virtual functions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider the particular v-table entry for a specific object type. We know
    that this table entry will consist of a set of function pointers, such as an array
    of function pointers. The order in which these function pointers are arranged
    will be consistent with the order in which the virtual functions are newly introduced
    by a given class. Functions overriding existing virtual functions that were newly
    introduced at a higher level in the hierarchy will simply replace table entries
    with preferred versions of functions to be called, but will not cause an additional
    entry to be allocated in the array of function pointers.
  prefs: []
  type: TYPE_NORMAL
- en: So, when the program begins running, first in global memory (as a hidden external
    variable), a v-table will be set up. This table will contain entries for each
    object type that contains virtual functions. The entry for a given object type
    will contain a set of function pointers (such as an array of function pointers),
    which organizes and initializes the dynamically bound functions for that class.
    The specific order of the function pointers will correspond to the order in which
    the virtual functions were introduced (possibly by their ancestor class), and
    the specific function pointers will be initialized to the preferred versions of
    these functions for the specific class type in question. That is, the function
    pointers may point to overridden methods as specified at their own class level.
  prefs: []
  type: TYPE_NORMAL
- en: Then, when an object of a given type is instantiated, the vptr within that object
    (there will be one per sub-object level of newly introduced – not redefined –
    virtual functions) will be set to point to the corresponding v-table entry for
    that instance.
  prefs: []
  type: TYPE_NORMAL
- en: It will be useful to see this detail with code and a memory diagram. Let's look
    under the hood to see the code in action!
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting the virtual function table (v-table) in detail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to detail the memory model and see the underlying C++ mechanics that
    will be set up at runtime, let''s consider our detailed, full program example
    from this section with base class `Person` and derived class `Student`. As a reminder,
    we will show the key elements of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Abbreviated definitions of the `Person` and `Student` classes (we''ll omit
    the data members and most member function definitions to save space):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Revisiting key elements of our `main()` function, in abbreviated form:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice in our `main()` function that we instantiate one `Person` instance and
    two `Student` instances. All are stored in a generic array of pointers of the
    base class type `Person`. We then iterate through the set, calling virtual functions
    on each instance, namely `IsA()`, `Print()`, `Greeting()`, and the destructor
    (which is implicitly called when we delete each instance).
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering the memory model for the previous example, we have the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Memory model for the current example](img/Figure_7.1_B15702.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Memory model for the current example
  prefs: []
  type: TYPE_NORMAL
- en: In the aforementioned memory diagram (which follows the preceding program),
    notice that we have an array of pointers to the genericized instances of `Person`.
    The first instance is, in fact, a `Person`, and the second two instances are of
    type `Student`. But, as a `Student` *Is-A* `Person`, it is acceptable to up-cast
    a `Student` to a `Person`. The top part of the memory layout is in fact, a `Person`
    for each of the `Student` instances. For instances that are in fact of type `Student`,
    the additional data members for `Student` will follow all the memory required
    for the `Person` sub-object.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `vptr` entries immediately follow the data members for the `Person`
    object (or sub-object) for each of the three instances. The location for the `vptr`
    is the same offset from the top of each object. This is because the virtual functions
    in question are all introduced at the `Person` level in the hierarchy. Some may
    be overridden in the `Student` class with more appropriate definitions for `Student`,
    but the level at which each is introduced is the `Person` level, hence the `vptr`
    below the `Person` object (or sub-object) will reflect a pointer to the list of
    operations introduced at the `Person` level.
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, let's say that `Student` introduced wholly new virtual functions
    (and not merely redefinitions of existing virtual functions), as we saw in the
    previous function-hiding scenario. There would then be a second `vptr` entry below
    the `Student` sub-object with those additional (new virtual) operations added.
  prefs: []
  type: TYPE_NORMAL
- en: When each object is instantiated, first the appropriate constructors (proceeding
    up the hierarchy) will be called for each instance. Additionally, the compiler
    will patch in a pointer assignment for each instance's `vptr` to be set to the
    `v-table` entry corresponding to the object's type. That is, when a `Person` is
    instantiated, its `vptr` will point to the `v-table` entry for `Person`. When
    a `Student` is instantiated, its `vptr` will point to the `v-table` entry for
    `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that the `v-table` entry for `Person` or `Student` contains an
    array of function pointers to the appropriate virtual functions for that type.
    The `v-table` entry for each type actually has more information embedded, such
    as the size of an instance of that type, and so on. To simplify, we will just
    look at the portion of the `v-table` entries that automate the dynamic binding
    for each class type.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `v-table` entry for `Person` is an array of four function pointers.
    Each function pointer will point to the most suitable version of the destructor,
    `Print()`, `IsA()`, and `Greeting()` for a `Person`. The order in which these
    function pointers are laid corresponds to the order in which these virtual functions
    were introduced by this class. That is, `vptr[0]` will point to the `Person` destructor,
    `vptr[1]` will point to `Person::Print()`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the v-table entry for `Student`. The order in which the virtual
    functions (as function pointers) are laid in the array is the same order as for
    the `Person` class. This is because the base class introduced these functions
    and the ordering in this array of pointers is set by that level. But notice that
    the actual functions that are pointed to have been overridden for `Student` instances
    to mostly be methods that were redefined by the derived class, `Student`. That
    is, the `Student` destructor is specified (as the starting point for destruction),
    followed by `Student::Print()`, then `Student::IsA()`, and then `Person::Greeting()`.
    Notice that `vptr[3]` points to `Person::Greeting()`. This is because `Student`
    did not redefine this function in its class definition; `Student` found the `Person`
    definition, which is inherited, to be acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Pairing this memory diagram with the code in our `main()` function, notice that
    after we instantiate a `Person` and two `Student` instances, storing each in the
    genericized `Person` array of pointers, we iterate through a loop containing several
    operations. We uniformly call `people[i]->Print();`, then `people[i]->IsA();`,
    then `people[i]->Greeting();`, and then `delete people[i];` (which patches in
    a destructor call).
  prefs: []
  type: TYPE_NORMAL
- en: Because each of these functions is virtual, the decision as to which function
    should be called is deferred to be looked up at runtime. This is done by accessing
    each instance's hidden `vptr` member, indexing into the appropriate `v-table`
    entry based on the operation at hand, and then dereferencing the function pointer
    found at that entry to call the appropriate method. The compiler knows, for example,
    that `vptr[0]` will be the destructor, `vptr[1]` will be the next virtual function
    introduced in the base class definition, and so on, so that which element position
    in the v-table should be activated is easily determined by the name of the polymorphic
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that a call in `main()` to `people[i]->Print();` was replaced with `*(people[i]->vptr[1])();`,
    which is the syntax for dereferencing a function pointer to call the function
    at hand. Notice that we are first accessing which function using `people[i]->vptr[1]`,
    then dereferencing the function pointer using `*`. Notice the parentheses, `()`,
    at the end of the statement, which is where any parameters would be passed to
    the function. Because the code to dereference the function pointer needs to be
    uniform, the parameters to any such function must also be uniform. That is why
    any virtual functions overridden in a derived class must use the same signature
    as specified by the base class. It all makes sense when you look under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: We have now thoroughly examined the OO idea of polymorphism and how it is implemented
    in C++ using virtual functions. Let's briefly recap what we've covered in this
    chapter before moving onward to our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have moved even further along our journey with object-oriented
    programming by understanding how virtual functions in C++ provide direct language
    support for the OO idea of polymorphism. We have seen how virtual functions provide
    the dynamic binding of a specific method to an operation in our inheritance hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how, using virtual functions, an operation specified by a base
    class can be overridden by a derived class, providing a more suitable implementation.
    We have seen that the correct method for each object can be selected using runtime
    binding, regardless of whether the object is stored in its own type or in a generalized
    type.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that objects are often generalized using base class pointers and
    how this can allow uniform processing of related derived class types. We have
    seen that regardless of how an instance is stored (as its own type or as that
    of a base class using a pointer), that the correct version of a virtual function
    will always be applied through dynamic binding. We have seen that in public inheritance
    hierarchies, where upcasting may be routinely done, having a virtual destructor
    is essential.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen how dynamic binding works through examining a typical compiler
    implementation of embedding a vptr into instances, and how these pointers reference
    v-table entries (containing sets of member function pointers) relevant to each
    object type.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that virtual functions allow us to take advantage of dynamic binding
    of operations to the most appropriate methods, enabling us to use C++ as an OOP
    language to implement robust designs featuring polymorphism, which promotes easily
    extensible code.
  prefs: []
  type: TYPE_NORMAL
- en: Through extending our OOP knowledge with the utilization of virtual functions,
    we can now move forward to include additional object-oriented concepts and details
    relating to inheritance and polymorphism. Continuing to [*Chapter 8*](B15702_08_Final_NM_ePub.xhtml#_idTextAnchor335),
    *Mastering Abstract Classes*, we will next learn how to employ the OO ideal of
    abstract classes, along with all the assorted OOP considerations surrounding this
    next object-oriented concept. Let's continue!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using your [*Chapter 6*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262), *Implementing
    Hierarchies with Single Inheritance*, solution, augment your inheritance hierarchy
    to further specialize `Student` with `GraduateStudent` and `NonDegreeStudent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Add necessary data members to your `GraduateStudent` class. Data members
    to consider might be dissertation topic or graduate advisor. Include appropriate
    constructors (default, alternate, and copy), a destructor, access member functions,
    and a suitable public interface. Be sure to place your data members in the private
    access region. Do the same for `NonDegreeStudent`.
  prefs: []
  type: TYPE_NORMAL
- en: b. Add polymorphic operations to `Person`, `Student`, `GraduateStudent`, and
    `NonDegreeStudent` as necessary. Introduce, at the `Person` level, virtual functions
    `IsA()` and `Print()`. Override `IsA()` and `Print()` in your derived classes,
    as necessary. It may be that you override `IsA()` in `Student` and `GraduateStudent`,
    but choose to override `Print()` only in the `Student()` class. Be sure to include
    virtual destructors in each of your classes.
  prefs: []
  type: TYPE_NORMAL
- en: c. Instantiate `Student`, `GraduateStudent`, `NonDegreeStudent`, and `Person`
    several times and utilize the appropriate `public` interfaces on each. Be sure
    to dynamically allocate several instances.
  prefs: []
  type: TYPE_NORMAL
- en: d. Create an array of pointers to `Person` and allocate instances of `Person`,
    `Student`, `GraduateStudent`, and `NonDegreeStudent` to be members of this array.
    Once generalized, only call polymorphic operations that are found at the `Person`
    level (and other public methods of `Person`). Be sure to delete any dynamically
    allocated instances.
  prefs: []
  type: TYPE_NORMAL
- en: e. Now, create an array of pointers to `Student` and allocate only instances
    of `GraduateStudent` and `NonDegreeStudent` to be members of this array. Now,
    call operations that are found at the `Student` level to be applied to these generalized
    instances. Additionally, utilize operations found at the `Person` level – they
    are inherited and additionally available for generalized `Student` instances.
    Be sure to delete any dynamically allocated instances pointed to in your array.
  prefs: []
  type: TYPE_NORMAL

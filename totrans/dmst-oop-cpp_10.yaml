- en: '*Chapter 8*: Mastering Abstract Classes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will continue expanding our knowledge of object-oriented programming
    in C++. We will begin by exploring a powerful OO concept, **abstract classes**,
    and then progress to understanding how this idea is implemented in C++ through
    *direct language support*.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement abstract classes using pure virtual functions to ultimately
    support refinements in a hierarchy of related classes. We will understand how
    abstract classes augment and pair with our understanding of polymorphism. We will
    also recognize how the OO concept of abstract classes presented in this chapter
    will support powerful and adaptable designs, allowing us to create easily extensible
    C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the OO concept of an abstract class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing abstract classes with pure virtual functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating interfaces using abstract classes and pure virtual functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generalizing derived class objects using abstract classes; upcasting and downcasting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the OO concept of an abstract
    class, and how to implement this idea in C++ through pure virtual functions. You
    will learn how abstract classes containing only pure virtual functions can define
    an OOP concept of an interface. You will understand why abstract classes and interfaces
    contribute to powerful OO designs.
  prefs: []
  type: TYPE_NORMAL
- en: You will see how we can very easily generalize groups of related, specialized
    objects using sets of abstract types. We will further explore upcasting and downcasting
    within the hierarchy to understand what is allowed and when such typecasting is
    reasonable to employ.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding the direct language support of abstract classes in C++ using
    pure virtual functions, as well as why creating interfaces is useful, you will
    have more tools available to create an extensible hierarchy of related classes.
    Let's expand our understanding of C++ as an OOP language by understanding how
    these concepts are implemented in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found at the following GitHub
    URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter08](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter08).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the `Chapter08`
    subdirectory in a file named `Chp8-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/2Pa6XBT](https://bit.ly/2Pa6XBT).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the OO concept of an abstract class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will introduce an essential object-oriented concept, that
    of an abstract class. Considering your growing knowledge base of key OO ideas,
    including encapsulation, information hiding, generalization, specialization, and
    polymorphism, you know how to encapsulate a class. You also know how to build
    inheritance hierarchies using single inheritance (and various reasons to build
    hierarchies, such as supporting **Is-A** relationships or for the lesser-used
    reason of supporting implementation inheritance). Furthermore, you know how to
    employ runtime binding of methods to operations using the concept of polymorphism,
    implemented by virtual functions. Let's extend our growing OO terminology by exploring
    **abstract classes**.
  prefs: []
  type: TYPE_NORMAL
- en: An **abstract class** is a base class that is intended to collect commonalities
    that may exist in derived classes for the purpose of asserting a common interface
    (that is, a set of operations) on the derived class. An abstract class does not
    represent a class that is intended for instantiation. Only objects of the derived
    class types may be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at the C++ language feature that allows us to implement
    abstract classes, that is, pure virtual functions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing abstract classes with pure virtual functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An abstract class is specified by introducing at least one abstract method (that
    is, a pure virtual function prototype) in the class definition. The OO concept
    of an **abstract method** is the specification of an operation with only its protocol
    for usage (that is, with only the *name* and *signature* of the member function),
    but with no definition for the function. An abstract method will be polymorphic,
    in that, having no definition, it is expected to be redefined by derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `=0` after the arguments to the function. Additionally, it is important to
    understand the following nuances regarding pure virtual functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, definitions for pure virtual functions are not provided. This equates
    to the operation (prototype only) being specified at the base class level and
    all methods (member function definitions) being supplied at the derived class
    level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Derived classes that do not provide methods for all pure virtual functions introduced
    by their base classes are also considered abstract and are hence not instantiable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `=0` in the prototype is merely an indication to the linker that a definition
    for this function need not be linked in (or resolved) when creating an executable
    program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: An abstract class is designated by including one or more pure virtual function
    prototypes in the class definition. The optional definitions for these methods
    are not typically provided.
  prefs: []
  type: TYPE_NORMAL
- en: The reason that pure virtual functions will most often not have a definition
    is they are meant to provide a protocol of usage for polymorphic operations to
    be implemented in descendent classes. A pure virtual function designates a class
    to be abstract; an abstract class cannot be instantiated. Therefore, a definition
    provided in a pure virtual function will never be selected as the appropriate
    method for a polymorphic operation because instances of the abstract type will
    never exist. That being said, a pure virtual function can still provide a definition
    that could be explicitly called using the scope resolution operator (`::`) and
    base class name. Perhaps, this default behavior might be meaningful as a helper
    function used by derived class implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with a brief overview of the syntax required to specify an abstract
    class. Remember, a potential keyword of *abstract* is not used to specify an abstract
    class. Rather, by merely introducing one or more pure virtual functions, we have
    indicated the class to be an abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice, in the abstract class definition, we have introduced four virtual functions,
    three of which are pure virtual functions. The virtual destructor has no memory
    to release but is indicated as `virtual` so that it will be polymorphic, and so
    that the correct destruction sequence can be applied to derived class instances
    stored as pointers to base class types.
  prefs: []
  type: TYPE_NORMAL
- en: The three pure virtual functions, `Print()`, `IsA()`, and `Speak()`, are indicated
    with `=0` in their prototype. There are no definitions for these operations (though
    there optionally can be). A pure virtual function can have a default implementation,
    but not as an inline function. It will be the derived class's responsibility to
    provide methods for these operations using the interface (that is, signature)
    specified by this base class definition. Here, the pure virtual functions provide
    the *interface* for the polymorphic operations, which will be defined in derived
    class definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes will certainly have derived classes (since we cannot instantiate
    an abstract class itself). In order to allow the virtual destructor mechanism
    to work appropriately in the eventual hierarchy, be sure to include a *virtual
    destructor* in the abstract class definition. This will ensure that all derived
    class destructors are `virtual`, and can be overridden to provide the correct
    entry point in an object's destruction sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a deeper look at what it means to have an interface, from an
    OO perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Creating interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **interface class** is an OO concept of a class that is a further refinement
    of an abstract class. Whereas an abstract class can contain generalized attributes
    and default behaviors (through including data members and default definitions
    for pure virtual functions or through providing non-virtual member functions),
    an interface class will only contain abstract methods. An abstract class in C++
    containing only abstract methods (that is, pure virtual functions with no optional
    definitions) can be thought of as an **interface** class.
  prefs: []
  type: TYPE_NORMAL
- en: 'When considering interface classes as implemented in C++, it is useful to remember
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes are not instantiable; they provide (via inheritance) the interfaces
    (that is, operations) that a derived class must offer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although a pure virtual function may contain an optional implementation (that
    is, method body) in the abstract class, this implementation should not be provided
    if the class wishes to be considered an interface class in pure OO terms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although an abstract class may have data members, it should not if the class
    wishes to be considered an interface class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An abstract method, in OO terms, is an operation without a method; it is the
    interface only and is implemented in C++ as a pure virtual function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a reminder, be sure to include a virtual destructor prototype in the interface
    class definition; this will ensure that derived class destructors will be virtual.
    The destructor definition should be empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's consider various motivations for having interface classes within our OOP
    arsenal of implementation techniques. Some OOP languages follow very strict OO
    concepts and only allow for the implementation of very pure OO designs. Other
    OOP languages, such as C++, offer more flexibility, by allowing more radical OOP
    ideas to be implemented by the language directly.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in pure object-oriented terms, inheritance should be reserved for
    Is-A relationships. We've seen implementation inheritance, which C++ supports
    through private and protected base classes. We've seen some acceptable uses of
    implementation inheritance, that is, to implement a new class in terms of another
    (with the ability to hide the underlying implementation with the use of protected
    and public base classes).
  prefs: []
  type: TYPE_NORMAL
- en: Another example of a fringe OOP feature is that of multiple inheritance. We'll
    see in an upcoming chapter, [*Chapter 9*](B15702_09_Final_NM_ePub.xhtml#_idTextAnchor361),
    *Exploring Multiple Inheritance*, that C++ allows a class to be derived from more
    than one base class. In some cases, we are truly saying that the derived class
    has an Is-A relationship with potentially many base classes, but not always.
  prefs: []
  type: TYPE_NORMAL
- en: Some OOP languages do not allow multiple inheritance, and those that do not
    rely more on interface classes to mix in the functionality of (otherwise) multiple
    base classes. In these situations, the OOP language can allow a derived class
    to implement the functionality as specified in multiple interface classes without
    actually using multiple-inheritance. Ideally, interfaces are used to mix in functionality
    from multiple classes. These classes, not surprisingly, are sometimes referred
    to as **mix-in** classes. In these situations, we are not saying that the Is-A
    relationship necessarily applies between derived and base classes.
  prefs: []
  type: TYPE_NORMAL
- en: In C++, when we introduce an abstract class with only pure virtual functions,
    we can think of creating an interface class. When a new class mixes in functionality
    from multiple interfaces, we can think of this in OO terms as using the interface
    classes each as a way to mix in the desired interfaces for behaviors. Note that
    the derived classes must override each of the pure virtual functions with their
    own implementation; we're mixing in only the required API.
  prefs: []
  type: TYPE_NORMAL
- en: C++'s implementation of the OO concept of an interface is merely that of an
    abstract class containing only pure virtual functions. Here, we're using public
    inheritance from an abstract class, paired with polymorphism to simulate the OO
    concept of an interface class. Note that other languages (such as Java) implement
    this idea directly in the language (but then those languages do not support multiple
    inheritance). In C++, we can do almost anything, yet it remains important to understand
    how to implement OO ideals (even those not offered with direct language support)
    in reasonable and meaningful ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example to illustrate an abstract class used to implement an
    interface class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned class definitions, we first notice a simple interface
    class, `Charitable`, implemented using a restricted abstract class. We include
    no data members, a pure virtual function to define the `virtual void Give(float)
    = 0;` interface, and a virtual destructor.
  prefs: []
  type: TYPE_NORMAL
- en: Next, `Person` is derived from `Charitable` using public inheritance to implement
    the `Charitable` interface. We simply override `virtual void Give(float);` to
    provide a default definition for *giving*. We then derive `Student` from `Person`;
    note that a *Student Is-A Person that mixes-in (or implements) the Charitable
    interface*. In our `Student` class, we choose to redefine `virtual void Give(float);`
    to provide a more suitable `Give()` definition for `Student` instances. Perhaps
    `Student` instances have limited finances and opt to donate an amount of their
    time that is equivalent to a predetermined monetary amount.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have used an abstract class in C++ to model the OO concept of an interface
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with our discussion relating to abstract classes overall by examining
    how derived class objects may be collected by abstract class types.
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing derived class objects as abstract types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen in [*Chapter 7*](B15702_07_Final_NM_ePub.xhtml#_idTextAnchor298),
    *Utilizing Dynamic Binding through Polymorphism*, that it is reasonable at times
    to group related derived class instances in a collection that is stored using
    base class pointers. Doing so allows uniform processing of related derived class
    types using polymorphic operations as specified by the base class. We also know
    that when a polymorphic base class operation is invoked, the correct derived class
    method will be invoked at runtime by virtue of the virtual functions and internal
    v-table that implement polymorphism in C++.
  prefs: []
  type: TYPE_NORMAL
- en: You may contemplate, however, whether it is possible to collect a group of related
    derived class types by a base class type that is an abstract class? Remember,
    an abstract class is not instantiable, so how might we store a derived class object
    as an object that cannot be instantiated? The solution is to use *pointers*. Whereas
    we cannot collect derived class instances in a set of abstract base class instances
    (those types cannot be instantiated), we can collect derived class instances in
    a set of pointers of the abstract class type. We've been doing this type of grouping
    (with base class pointers) since we learned about polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Generalized groups of specialized objects employ implicit upcasting. Undoing
    such an upcast must be done using an explicit downcast, and the programmer will
    need to be correct as to the derived type that was previously generalized. An
    incorrect downcast to the wrong type will cause a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: When is it necessary to collect derived class objects by base class types, including
    abstract base class types? The answer is when it makes sense in your application
    to process related derived class types in a more generic way, that is, when the
    operations specified in the base class type account for all of the operations
    you'd like to utilize. Undeniably, you may find just as many situations where
    keeping derived class instances in their own type (to utilize specialized operations
    introduced at the derived class level) is reasonable. Now you understand what
    is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue by examining a comprehensive example showing abstract classes
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: Putting all the pieces together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, in this chapter, we have understood the subtleties of abstract classes,
    including pure virtual functions, and how to create interface classes using abstract
    classes and pure virtual functions. It is always important to see our code in
    action, with all its various components and their various nuances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a more complex, full program example to fully illustrate
    abstract classes, implemented using pure virtual functions in C++. In this example,
    we will not further designate an abstract class as an interface class, but we
    will take the opportunity to collect related derived class types using a set of
    pointers of their abstract base class type. This example will be broken down into
    many segments; the full program can be found at the following GitHub location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter08/Chp8-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter08/Chp8-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned class definition, we notice that `LifeForm` is an abstract
    class. It is an abstract class because it contains at least one pure virtual function
    definition. In fact, it contains three pure virtual function definitions, namely,
    `Print()`, `IsA()`, and `Speak()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s extend `LifeForm` with a concrete derived class, `Cat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previous segment of code, we see the class definition for `Cat`. Notice
    that `Cat` has redefined the `LifeForm` pure virtual functions, `Print()`, `IsA()`,
    and `Speak()`, by providing definitions for each of these methods in the `Cat`
    class. With the existing methods in place for these functions, any derived class
    of `Cat` may optionally choose to redefine these methods with more suitable versions
    (but they are no longer obligated to do so).
  prefs: []
  type: TYPE_NORMAL
- en: Note that if `Cat` had failed to redefine even one of the pure virtual functions
    of `LifeForm`, then `Cat` would also be considered an abstract class and hence
    not instantiable.
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, even though the virtual functions `IsA()` and `Speak()` are written
    inline to abbreviate the code, virtual functions will never be inlined by the
    compiler, as their correct method must be determined at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in the `Cat` constructors, the member initialization list is used
    to select the `LifeForm` constructor, which takes an integer argument (that is,
    `:LifeForm(15)`). A value of `15` is passed up to the `LifeForm` constructor to
    initialize `lifeExpectancy`, defined in `LifeForm`, to the value of `15`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s move forward to the class definition for `Person`, along with its
    inline functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `Person` now extends `LifeForm` using public inheritance. In previous
    chapters, `Person` was a base class at the top of the inheritance hierarchy. `Person`
    redefines the pure virtual functions from `LifeForm`, namely, `Print()`, `IsA()`,
    and `Speak()`. As such, `Person` is now a concrete class and can be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s review the member function definition for `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the `Person` member functions, notice that we have implementations for `Print()`,
    `IsA()`, and `Speak()`. Additionally, notice that in two of the `Person` constructors,
    we select `:LifeForm(80)` in their member initialization lists to call the `LifeForm(int)`
    constructor. This call will set the private inherited data member `LifeExpectancy`
    to `80` in the `LifeForm` sub-object of a given `Person` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s review the `Student` class definition, along with its inline function
    definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The aforementioned class definition for `Student` looks much as we've seen in
    the past. `Student` extends `Person` using public inheritance because a `Student`
    *Is-A* `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving forward, we''ll recall the non-inline `Student` class member functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the previously listed section of code, we see the non-inline member function
    definitions for `Student`. The complete class definition is, at this point, largely
    familiar to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, let''s examine the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, in `main()`, we declare an array of pointers to `LifeForm`. Recall, `LifeForm`
    is an abstract class. We could not create an array of `LifeForm` objects, because
    that would require us to be able to instantiate a `LifeForm`; we can't – `LifeForm`
    is an abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can create a set of pointers to an abstract type and this allows
    us to collect related types – the `Person`, `Student`, and `Cat` instances in
    this set. Of course, the only operations we may apply to instances stored in this
    generalized fashion are those found in the abstract base class, `LifeForm`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we allocate a variety of `Person`, `Student`, and `Cat` instances, storing
    each instance via an element in the generalized set of pointers of type `LifeForm`.
    When any of these derived class instances is stored in this fashion, an implicit
    upcast to the abstract base class type is performed (but the instance is not altered
    in any fashion – we're just pointing to the most base class sub-object comprising
    the entire memory layout).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we proceed through a loop to apply operations as found in the abstract
    class `LifeForm` to all instances in this generalized collection, such as `Speak()`,
    `Print()`, and `IsA()`. These operations happen to be polymorphic, allowing each
    instance's most appropriate implementation to be utilized via dynamic binding.
    We additionally invoke `GetLifeExpectancy()` on each of these instances, which
    is a non-virtual function found at the `LifeForm` level. This function merely
    returns the life expectancy of the `LifeForm` in question.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we loop through deleting the dynamically allocated instances of `Person`,
    `Student`, and `Cat` again using the generalized `LifeForm` pointers. We know
    that `delete()` will patch in a call to the destructor, and because the destructor
    is virtual, the appropriate starting level of the destructor and proper destruction
    sequence will commence.
  prefs: []
  type: TYPE_NORMAL
- en: The utility of the `LifeForm` abstract class in this example is that its use
    allows us to generalize common aspects and behaviors of all `LifeForm` objects
    together in one base class (such as `lifeExpectancy` and `GetLifeExpectancy()`).
    The common behaviors also extend to a set of pure virtual functions with the desired
    interfaces that all `LifeForm` objects should have, namely, `Print()`, `IsA()`,
    and `Speak()`.
  prefs: []
  type: TYPE_NORMAL
- en: Important reminder
  prefs: []
  type: TYPE_NORMAL
- en: An abstract class is one that collects common traits of derived classes, yet
    does not itself represent a tangible entity or object that should be instantiated.
    In order to specify a class as abstract, it must contain at least one pure virtual
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the output for the aforementioned program, we can see that objects
    of various related derived class types are instantiated and processed uniformly.
    Here, we've collected these objects by their abstract base class type and have
    overridden the pure virtual functions in the base class with meaningful definitions
    in various derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output for the full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have now thoroughly examined the OO idea of an abstract class and how it
    is implemented in C++ using pure virtual functions, as well as how these ideas
    can extend to creating OO interfaces. Let's briefly recap the language features
    and OO concepts we've covered in this chapter before moving onward to our next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have continued our progression with object-oriented programming,
    foremost by understanding how pure virtual functions in C++ provide direct language
    support for the OO concept of an abstract class. We have explored how abstract
    classes without data members, and that do not contain non-virtual functions, can
    support the OO ideal of an interface class. We've talked about how other OOP languages
    utilize interface classes and how C++ may choose to support this paradigm as well,
    by using such restricted abstract classes. We've up cast related derived class
    types to be stored as pointers of the abstract base class type, as it is a typical
    and overall very useful programming technique.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how abstract classes complement polymorphism not only by providing
    a class to specify common attributes and behaviors that derived classes share,
    but most notably to provide the interfaces of polymorphic behaviors for the related
    classes since abstract classes themselves are not instantiable.
  prefs: []
  type: TYPE_NORMAL
- en: By adding abstract classes and potentially the OO concept of interface classes
    to our programming repertoire in C++, we are able to implement designs that promote
    easily extensible code.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to continue to [*Chapter 9*](B15702_09_Final_NM_ePub.xhtml#_idTextAnchor361),
    *Exploring Multiple Inheritance*, to enhance our OOP skills by next learning how
    and when to appropriately utilize the concept of multiple inheritance, while understanding
    trade-offs and potential design alternatives. Let's move forward!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a hierarchy of shapes using the following guidelines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a. Create an abstract base class called `Shape`, which defines an operation
    to compute the area of a `Shape`. Do not include a method for the `Area()` operation.
    Hint: use a pure virtual function.'
  prefs: []
  type: TYPE_NORMAL
- en: b. Derive `Rectangle`, `Circle`, and `Triangle` classes from `Shape` using public
    inheritance. Optionally, derive the `Square` class from `Rectangle`. Redefine
    the `Area()` `operation`, which `Shape` has introduced, in each derived class.
    Be sure to provide the method to support the operation in each derived class so
    that you can later instantiate each type of `Shape`.
  prefs: []
  type: TYPE_NORMAL
- en: c. Add data members and other member functions as necessary to complete the
    newly introduced class definitions. Remember, only common attributes and operations
    should be specified in `Shape` – all others belong in their respective derived
    classes. Don't forget to implement the copy constructor and access functions within
    each class definition.
  prefs: []
  type: TYPE_NORMAL
- en: d. Create an array of pointers of the abstract class type, `Shape`. Assign elements
    in this array point to instances of the `Rectangle`, `Square`, `Circle`, and `Triangle`
    `type`. Since you are now treating derived class objects as generalized `Shape`
    objects, loop through the array of pointers and invoke the `Area()` function for
    each. Be sure to `delete()` any dynamically allocated memory you have allocated.
  prefs: []
  type: TYPE_NORMAL
- en: e. Is your abstract `Shape` class also an interface class in conceptual OO terms?
    Why or why not?
  prefs: []
  type: TYPE_NORMAL

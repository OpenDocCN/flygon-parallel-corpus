- en: '*Chapter 9*: Exploring Multiple Inheritance'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will continue broadening our knowledge of object-oriented programming
    in C++. We will begin by examining a controversial OO concept, **multiple inheritance**
    (**MI**), understanding why it is controversial, how it can reasonably be used
    to support OO designs, as well as when alternative designs may be more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple inheritance can be implemented in C++ with *direct language support*.
    In doing so, we will be faced with several OO design issues. We will be asked
    to critically evaluate an inheritance hierarchy, asking ourselves if we are using
    the best design possible to represent a potential set of object relationships.
    Multiple inheritance can be a powerful OOP tool; using it wisely is paramount.
    We will learn when to use MI to sensibly extend our hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding multiple inheritance mechanics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining reasonable uses for multiple inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating diamond-shaped hierarchies and exploring issues arising from their
    usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using virtual base classes to resolve diamond-shaped hierarchy duplication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying discriminators to evaluate the worthiness of a diamond-shaped hierarchy
    and MI in a design, as well as considering design alternatives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the OO concept of multiple inheritance,
    and how to implement this idea in C++. You will understand not only the simple
    mechanics of MI but also the reasons for its usage (mix-in, Is-A, or controversially,
    Has-A).
  prefs: []
  type: TYPE_NORMAL
- en: You will see why MI is controversial in OOP. Having more than one base class
    can lead to oddly shaped hierarchies, such as diamond-shaped; these types of hierarchies
    come with potential implementation issues. We will see how C++ incorporates a
    language feature (virtual base classes) to solve these conundrums, but the solution
    is not always ideal.
  prefs: []
  type: TYPE_NORMAL
- en: Once we understand the complexities caused by multiple inheritance, we will
    use OO design metrics, such as discriminators, to evaluate whether a design using
    MI is the best solution to represent a set of object relationships. We'll look
    at alternative designs, and you will then be better equipped to understand not
    only what multiple inheritance is, but also when it's best utilized. Let us expand
    our understanding of C++ as a "*you can do anything*" OOP language by moving forward
    with MI.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The online code for the full program examples can be found at the following
    GitHub URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter09` in a file named `Chp9-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3f4qjDo](https://bit.ly/3f4qjDo).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding multiple inheritance mechanics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++, a class can have more than one immediate base class. This is known as
    **multiple inheritance**, and is a very controversial topic in both OO designs
    and OOP. Let's begin with the simple mechanics; we will then move forward to the
    design issues and programming logistics surrounding MI during the progression
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: With multiple inheritance, the derived class specifies what each of its immediate
    ancestors or base classes are, using the base class list in its class definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar fashion to single inheritance, the constructors and destructors
    are invoked all the way up the hierarchy, as objects of the derived class type
    are instantiated and destroyed. Reviewing and expanding for MI the subtleties
    of construction and destruction, we are reminded of the following logistics:'
  prefs: []
  type: TYPE_NORMAL
- en: The calling sequence for a constructor starts with the derived class, but immediately
    passes control to a base constructor, and so on up the hierarchy. Once the calling
    sequence passes control to the top of the hierarchy, the execution sequence begins.
    All the highest-level base class constructors at the same level are first executed,
    and so on down the hierarchy until we arrive at the derived class constructor,
    whose body is executed last in the construction chain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The derived class destructor is invoked and executed first, followed by all
    the immediate base class destructors, and so on, as we progress up the inheritance
    hierarchy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The member initialization list in the derived class constructor may be used
    to specify which constructor for each immediate base class should be invoked.
    In the absence of this specification, the default constructor will be used for
    that base class' constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a typical multiple inheritance example to implement a
    quintessential application of MI from an OO design, as well as to understand basic
    MI syntax in C++. This example will be broken into many segments; the full program
    can be found in the following GitHub location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09/Chp9-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09/Chp9-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code segment, we have an expected class definition for `Person`,
    containing the class elements that we are accustomed to defining.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s see the accompanying member functions for this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the previous segment of code, the member function definitions for `Person`
    are as expected. Nonetheless, it is useful to see the `Person` class defined,
    as this class will serve as a building block, and portions of it will be directly
    accessed in upcoming code segments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define a new class, `BillableEntity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the previous `BillableEntity` class, we define a class containing simple
    functionality to encapsulate a billing structure. That is, we have an invoice
    amount and methods such as `Pay()` and `GetBalance()`. Notice that the copy constructor
    is private; this will prohibit copies, which seems appropriate given the nature
    of this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s combine the two aforementioned base classes, `Person` and `BillableEntity`,
    to serve as base classes for our `Student` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding class definition for `Student`, two public base classes, `Person`
    and `BillableEntity`, are specified in the base class list for `Student`. These
    two base classes are merely comma-separated in the `Student` base class list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s further see what accommodations must be made in the remainder of the
    `Student` class by examining its member functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let's consider the previous code segment. In the default constructor for `Student`,
    due to the lack of base class constructor specification in the member initialization
    list, the default constructors will be called for both the `Person` and `BillableEntity`
    base classes.
  prefs: []
  type: TYPE_NORMAL
- en: However, notice that in the alternate `Student` constructor, we merely comma
    separate our two base class constructor choices in the member initialization list—that
    is, `Person(const char *, const char *, char, const char *)` and `BillableEntity(float)`—and
    then pass various parameters from the `Student` constructor to the base class
    constructors using this list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s take a look at our `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In our `main()` function in the previous code, we instantiate several `Student`
    instances. Notice that `Student` instances can utilize any methods in the public
    interface of `Student`, `Person`, or `BillableEntity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the output for the aforementioned program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have now seen the language mechanics for MI with a typically implemented
    OO design. Now, let's move forward by looking at the typical reasons for employing
    multiple inheritance in OO designs, some of which are more widely accepted than
    others.
  prefs: []
  type: TYPE_NORMAL
- en: Examining reasonable uses for MI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiple inheritance is a controversial concept that arises when creating OO
    designs. Many OO designs avoid MI; other designs embrace it with strict usage.
    Some OOP languages, such as Java, do not explicitly provide direct language support
    of multiple inheritance. Instead, they offer interfaces, such as what we modeled
    in C++ by creating interface classes using abstract classes (restricted to contain
    only pure virtual functions) in [*Chapter 8*](B15702_08_Final_NM_ePub.xhtml#_idTextAnchor335),
    *Mastering Abstract Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in C++, inheriting from two interface classes is still a use of multiple
    inheritance. Though C++ does not include interface classes within the language,
    this concept can be simulated by employing a more restrictive use of MI. For example,
    we can programmatically streamline abstract classes to include only pure virtual
    functions (no data members, and no member functions with definitions) to mimic
    the OO design idea of an interface class.
  prefs: []
  type: TYPE_NORMAL
- en: Typical MI conundrums form the basis as to why MI is contentious in OOP. Classic
    MI quandaries will be detailed in this chapter, and can be avoided by restricting
    MI to the usage of interface classes only, or through redesign. This is why some
    OOP languages only support interface classes versus allowing unrestricted MI.
    In C++ you can carefully consider each OO design, and choose when to utilize MI,
    when to utilize a restrictive form of MI (interface classes), or when to employ
    a redesign eliminating MI.
  prefs: []
  type: TYPE_NORMAL
- en: C++ is a "*you can do anything*" programming language. As such, C++ allows multiple
    inheritance without restrictions or reservations. As an OO programmer, we will
    look more closely at typical reasons to embrace MI. As we move further into this
    chapter, we will evaluate issues that arise by using MI and how C++ solves these
    issues with additional language features. These MI issues will allow us to then
    apply metrics to understand more reasonably when we should use MI and when a redesign
    may be more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin our pursuit of reasonable uses of MI by considering Is-A and mix-in
    relationships, and then move to examine the controversial use of MI to implement
    Has-A relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting Is-A and mix-in relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have learned with single inheritance, an Is-A relationship is most often
    used to describe the relationship between two inherited classes. For example,
    a `Student` *Is-A* `Person`. The same desired ideal continues with MI; Is-A relationships
    are primary motivations to specify inheritance. In pure OO designs and programming,
    inheritance should be used only to support Is-A relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, as we learned when we looked at interface classes (a concept modeled
    in C++ using abstract classes with the restriction of containing only pure virtual
    functions), mix-in relationships often apply when we inherit from an interface.
    Recall, a mix-in relationship is when we use inheritance to mix in the functionality
    of another class, simply because that functionality is useful or meaningful for
    the derived class to have. The base class need not be an abstract or interface
    class, but employing an ideal OO design, it would be as such.
  prefs: []
  type: TYPE_NORMAL
- en: The mix-in base class represents a class in which an Is-A relationship does
    not apply. Mix-ins exist more so with MI, at least as the reason supporting the
    necessity of one of the (many) base classes. Since C++ has direct language support
    for multiple inheritance, MI can be used to support implementing mix-ins (whereas
    languages like Java may only use interface classes). In practice, MI is often
    used to inherit from one class to support an Is-A relationship, and to also inherit
    from another class to support a mix-in relationship. In our last example, we saw
    that a `Student` *Is-A* `Person`, and a `Student` chooses to *mix-in* `BillableEntity`
    capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Reasonable uses of MI in C++ include supporting both Is-A and mix-in relationships;
    however, our discussion would not be complete without next considering an unusual
    use of MI—implementing Has-A relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting Has-A relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Less commonly, and much more controversially, MI can be used to implement a
    Has-A relationship. That is, to model containment, or a whole versus part relationship.
    We will see in [*Chapter 10*](B15702_10_Final_NM_ePub.xhtml#_idTextAnchor386),
    *Implementing Association, Aggregation, and Composition*, a more widely accepted
    implementation for Has-A relationships; however, MI provides a very simple implementation.
    Here, the parts serve as the base classes. The whole inherits from the parts,
    automatically including the parts in its memory layout, also automatically inheriting
    the parts' members and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a `Student` *Is-A* `Person` and a `Student` *Has-A(n)* `Id`; the
    usage of the second base class (`Id`) is for containment. `Id` will serve as a
    base class and `Student` will be derived from `Id` to factor in all that an `Id`
    offers. The `Id` public interface is immediately usable to `Student`. In fact,
    any class that inherits from `Id` will inherit a uniform interface when utilizing
    its `Id` parts. This simplicity is a driving reason why inheritance is sometimes
    used to model containment.
  prefs: []
  type: TYPE_NORMAL
- en: However, using inheritance to implement Has-A relationships can cause unnecessary
    usage of MI, which can then complicate an inheritance hierarchy. Unnecessary usage
    of MI is the primary reason why using inheritance to model Has-A relationships
    is very controversial and is quite frankly frowned upon in pure OO designs. Nonetheless,
    we mention it because you will see some C++ applications using MI for Has-A implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move forward to explore other controversial designs employing MI, namely
    that of a diamond-shaped hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a diamond-shaped hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using multiple inheritance, sometimes it is tempting to utilize sibling
    (or cousin) classes as base classes for a new derived class. When this happens,
    the hierarchy is no longer a tree in shape, but rather, a graph containing a *diamond*.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever an object of the derived class type is instantiated in such a situation,
    two copies of the common base class will be present in the instance of the derived
    class. Duplication of this sort obviously wastes space. Additional time is also
    wasted by calling duplicate constructors and destructors for this repeated sub-object
    and by maintaining two parallel copies of a sub-object (most likely unnecessarily).
    Ambiguities also result when trying to access members from this common base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example detailing this issue, starting with abbreviated class
    definitions of `LifeForm`, `Horse`, and `Person`. Though only portions of the
    full program example are shown, the program in its entirety can be found in our
    GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09/Chp9-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09/Chp9-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The previous fragment of code shows skeleton class definitions for `LifeForm`,
    `Person`, and `Horse`. Each class shows a default constructor, which merely serves
    as an example to show how `lifeExpectancy` is set for each class. In the default
    constructors for `Person` and `Horse`, the member initialization list is used
    to pass a value of `35` or `80` to the `LifeForm` constructor to set this value.
  prefs: []
  type: TYPE_NORMAL
- en: Though the previous class definitions are abbreviated (that is, purposely incomplete)
    to save space, let's assume that each class has appropriate additional constructors
    defined, an appropriate destructor, and other necessary member functions.
  prefs: []
  type: TYPE_NORMAL
- en: We notice that `LifeForm` is an abstract class, in that it offers pure virtual
    functions `Print()`, `IsA()`, and `Speak()`. Both `Horse` and `Person` are concrete
    classes and will be instantiable because they override these pure virtual functions
    with virtual functions. These virtual functions are shown inline, only to make
    the code compact for viewing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at a new derived class that will introduce the graph, or
    diamond shape, in our hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the previous fragment, we define a new class, `Centaur`, using multiple inheritance.
    At a first glance, we truly do mean to assert the Is-A relationship between `Centaur`
    and `Person`, and also between `Centaur` and `Horse`. However, we'll soon challenge
    our assertion to test if it is more of a combination than a true Is-A relationship.
  prefs: []
  type: TYPE_NORMAL
- en: We will assume that all of the necessary constructors, the destructor, and member
    functions exist to make `Centaur` a well-defined class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s move forward to look at a potential `main()` function we may utilize:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, in `main()`, we instantiate a `Centaur`; we name the instance `beast`.
    We easily call two polymorphic operations on `beast`, namely `Speak()` and `IsA()`.
    Then we try to call the public, inherited `GetLifeExpectancy()`, which is defined
    in `LifeForm`. Its implementation is included in `Lifeform` so that `Person`,
    `Horse`, and `Centaur` do not need to provide a definition (nor should they—it's
    not a virtual function meant to be redefined).
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, calls to `GetLifeExpectancy()` via `Centaur` instances are ambiguous.
    This is because there are two `LifeForm` sub-objects in the `beast` instance.
    Remember, a `Centaur` is derived from `Horse`, which is derived from `LifeForm`,
    providing the memory layout for all the aforementioned base class data members
    (`Horse` and `LifeForm`). And a `Centaur` is derived also from `Person`, which
    is derived from `LifeForm`, which contributes the memory layout for `Person` and
    `LifeForm` to `Centaur` as well. The `LifeForm` piece is duplicated.
  prefs: []
  type: TYPE_NORMAL
- en: There are two copies of the inherited data member `lifeExpectancy`. There are
    two sub-objects of `LifeForm` within the `Centaur` instance. Therefore, when we
    try to call `GetLifeExpectancy()` through the `Centaur` instance, the method call
    is ambiguous. Which `lifeExpectancy` are we trying to initialize? Which `LifeForm`
    sub-object will serve as the `this` pointer when `GetLifeExpectancy()` is called?
    It is simply not clear, so the compiler will not choose for us.
  prefs: []
  type: TYPE_NORMAL
- en: To disambiguate the `GetLifeExpectancy()` function call, we must use the scope
    resolution operator. We precede the `::` operator with the intermediate base class
    from which we desire the `LifeForm` sub-object. Notice that we call, for example,
    `beast.Horse::GetLifeExpectancy()` to choose the `lifeExpectancy` from the `Horse`
    sub-object's path which will include `LifeForm`. This is awkward, as neither `Horse`
    nor `Person` includes the ambiguous member; `lifeExpectancy` is found in `LifeForm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the output for the aforementioned program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can see that designing a hierarchy that includes a diamond shape has drawbacks.
    These conundrums include programming ambiguities that need to be resolved in an
    awkward fashion, duplication in memory of repeated sub-objects, plus time to construct
    and destruct these duplicate sub-objects.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, C++ has a language feature to alleviate these hardships with diamond-shaped
    hierarchies. After all, C++ is a language that will allow us to do anything. Knowing
    when and whether we should utilize these features is another concern. Let's first
    take a look at the C++ language solution to deal with diamond-shaped hierarchies
    and their inherent problems, by looking at virtual base classes.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing virtual base classes to eliminate duplication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just seen the MI implementation issues that quickly arise when a diamond
    shape is included in an OO design—duplication in memory for a repeated sub-object,
    ambiguity accessing that sub-object (even through inherited member functions),
    and the duplication of construction and destruction. For these reasons, pure OO
    designs will not include graphs in a hierarchy (that is, no diamond shapes). Yet,
    we know C++ is a powerhouse of a language and anything is possible. As such, C++
    will provide us with a solution to these issues.
  prefs: []
  type: TYPE_NORMAL
- en: '`virtual` is placed in the base class list between the access label and the
    base class name of the sibling or cousin class, which may *later* be used as a
    base class for the same derived class. Note that knowing two sibling classes may
    later be combined as common base classes for a new derived class can be difficult.
    It is important to note that sibling classes that do not specify a virtual base
    class will demand their own copy of the (otherwise) shared base class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Virtual base classes should be used sparingly in implementation because they
    place restrictions and overhead on instances that have such a class as an ancestor
    class. Restrictions to be aware of include:'
  prefs: []
  type: TYPE_NORMAL
- en: An instance having a virtual base class can use more memory than its non-virtual
    counterpart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting from an object of a base class type to a derived class type is prohibited
    when a virtual base class is in the ancestor hierarchy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The member initialization list of the most derived class must be used to specify
    which constructor of the shared object type should be used for initialization.
    If this specification is ignored, the default constructor will be used to initialize
    this sub-object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us now look at a full program example that employs virtual base classes.
    As usual, the full program can be found in our GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09/Chp9-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter09/Chp9-Ex3.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the previous segment of code, we see the full class definition of `LifeForm`.
    Notice that the member functions with bodies are inlined in the class definition.
    Of course, the compiler will not actually make inline substitutions for constructors
    or the destructor; knowing this, it is convenient to write the methods as inline
    to make the class compact for reviewing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s see the class definition for `Horse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the previous segment of code, we have the full class definition for `Horse`.
    Keep in mind that though certain methods are written as inline for compactness,
    the compiler will never actually inline a constructor or destructor. Nor can a
    virtual function be inlined, as its whole point is to have the appropriate method
    determined at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Here, `LifeForm` is a virtual base class of `Horse`. This means that if `Horse`
    ever has a sibling (or cousin) that also inherits from `LifeForm` using a virtual
    base class, and those siblings serve as base classes for a derived class, then
    those siblings will *share* their copy of `LifeForm`. The virtual base class will
    reduce storage and extra constructor and destructor calls, and eliminate ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the `Horse` constructors, which specify a constructor specification of
    `LifeForm(35)` in their member initialization lists. This base class initialization
    will be ignored if `LifeForm` actually is a shared virtual base class, though
    these constructor specifications are certainly valid for instances of `Horse`
    or for instances of descendants of `Horse` in which the diamond-shaped hierarchy
    does not apply. In hierarchies where `Horse` is combined with a sibling class
    to truly serve as a virtual base class, the `LifeForm(35)` specification will
    be ignored and instead either the default `LifeForm` constructor will be called
    or another will be selected at a lower (and unusual) level in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s see more of this program by looking at additional class definitions,
    beginning with `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the prior segment of code, we see that `Person` has a public virtual base
    class of `LifeForm`. Should `Person` and a sibling of `Person` ever be combined
    using multiple inheritance to be base classes for a new derived class, those siblings
    who have indicated a virtual base class of `LifeForm` will agree to share a single
    sub-object of `LifeForm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving onward, let''s review the member functions of `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the above-mentioned methods of `Person`, we see few details that surprise
    us; the methods are largely as expected. However, as a reminder, note that the
    `LifeForm(80)` specifications in the member initialization lists of the `Person`
    constructor will be ignored if `Person` is combined in a diamond-shaped hierarchy
    where the `LifeForm` sub-object becomes shared, rather than duplicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at where MI comes into play, with the definition of
    the `Centaur` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned `Centaur` class definition, we can see that `Centaur`
    has public base classes of `Horse` and `Person`. We are implying that `Centaur`
    *Is-A* `Horse` and `Centaur` *Is-A* `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice, however, the keyword `virtual` is not used in the base class list with
    the `Centaur` class definition. Yet, `Centaur` is the level in the hierarchy where
    the diamond shape is introduced. This means that we had to plan ahead, in our
    design stage, to know to utilize the `virtual` keyword in the base class list
    for our `Horse` and `Person` class definitions. This is an example of why a proper
    design session is critical, versus just jumping into implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Also, quite unusually, notice the base class list of `Person(fn, ln, mi, title),
    Horse(fn), LifeForm(1000)` in the `Centaur` alternate constructor. Here, we not
    only specify the preferred constructor of our immediate base classes of `Person`
    and `Horse`, but also the preferred constructor for *their* common base class
    of `LifeForm`. This is highly unusual. Without `LifeForm` as a virtual base class
    for `Horse` and `Person`, `Centaur` would not be able to specify how to construct
    the shared `LifeForm` piece (that is, by choosing a constructor for anything other
    than its immediate base classes). The virtual base class usage makes the `Person`
    and `Horse` classes less reusable for other applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what our `main()` function entails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Similar to our `main()` function in our non-virtual base class example, we can
    see that `Centaur` is likewise instantiated and that virtual functions such as
    `Speak()`, `IsA()`, and `Print()` are easily called. Now, however, when we call
    `GetLifeExpectancy()` through our `beast` instance, the call is no longer ambiguous.
    There is only one sub-object of `LifeForm`, whose `LifeExpectancy` has been initialized
    to `1000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output for the full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Virtual base classes have solved a difficult MI conundrum. But we have also
    seen that the code required to do so is less flexible for future expansion and
    reuse. As such, virtual base classes should be carefully and sparingly used, only
    when the design truly supports a diamond-shaped hierarchy. With that in mind,
    let's consider the OO concept of a discriminator, and consider when alternate
    designs may be more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Considering discriminators and alternate designs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **discriminator** is an object-oriented concept that helps outline the reasons
    why a given class is derived from its base class. **Discriminators** tend to characterize
    the types of groupings of specializations that exist for a given base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the aforementioned program examples with diamond-shaped hierarchies,
    we have the following discriminators (shown in parentheses), outlining our purpose
    for specializing a new class from a given base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Multiple inheritance diamond-shaped design shown with discriminators](img/Figure_9.1_B15702.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Multiple inheritance diamond-shaped design shown with discriminators
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever temptation leads to the creation of a diamond-shaped hierarchy, examining
    the discriminators can help us decide whether the design is reasonable, or if
    perhaps an alternate design would prove better. Here are some good design metrics
    to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: If the discriminators for the sibling classes that are being brought back together
    are the same, then the diamond-shaped hierarchy is better off redesigned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the sibling classes do not have unique discriminators, the attributes and
    behaviors they will introduce will consist of duplications stemming from having
    a like discriminator. Consider making the discriminator a class to house those
    commonalities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the discriminators for the sibling classes are unique, then the diamond-shaped
    hierarchy may be warranted. In this case, virtual base classes will prove helpful
    and should be added in the appropriate locations in the hierarchy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous example, the discriminator detailing why `Horse` specializes
    `LifeForm` is `Equine`. That is, we are specializing `LifeForm` with equine characteristics
    and behaviors (hooves, galloping, neighing, etcetera). Had we derived classes
    such as `Donkey` or `Zebra` from `LifeForm`, the discriminator for these classes
    would also be `Equine`. Considering the same aforementioned example, the `Person`
    class would have a `Humanoid` discriminator when specializing `LifeForm`. Had
    we derived classes such as `Martian` or `Romulan` from `LifeForm`, these classes
    would also have `Humanoid` as a discriminator.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing `Horse` and `Person` together as base classes for `Centaur` is combining
    two base classes with different discriminators, `Equine` and `Humanoid`. As such,
    wholly different types of characteristics and behaviors are factored in by each
    base class. Though an alternate design may be possible, this design is acceptable
    (except to OO design purists), and virtual base classes may be used in C++ to
    eliminate duplication of the otherwise-replicated `LifeForm` piece. Bringing two
    classes together that share a common base class and specialize the base class
    using distinct discriminators is an example of where MI and virtual base classes
    are reasonable in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, bringing two classes, such as `Horse` and `Donkey` (both derived from
    `LifeForm`), together in a derived class, such as `Mule`, also creates a diamond-shaped
    hierarchy. Examining the discriminators for `Horse` and `Donkey` reveals that
    both have a discriminator of `Equine`. In this case, bringing together these two
    classes using a diamond-shaped design is not the optimal design choice. Another
    design choice is possible and preferred. In this case, a preferred solution would
    be to make the discriminator, `Equine`, its own class, and then derive `Horse`,
    `Donkey`, and `Mule` from `Equine`. This would avoid MI and a diamond-shaped hierarchy.
    Let''s take a look at the two design options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.2 – Diamond-shaped multiple inheritance redesigned without MI](img/Figure_9.2_B15702.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Diamond-shaped multiple inheritance redesigned without MI
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  prefs: []
  type: TYPE_NORMAL
- en: In a diamond-shaped hierarchy, if the discriminators for the *combined* classes
    are the same, a better design is possible (by making the discriminator its own
    class). However, if the discriminators are different, consider keeping the diamond-shaped
    MI hierarchy, and use virtual base classes to avoid duplication of the common
    base class sub-object.
  prefs: []
  type: TYPE_NORMAL
- en: We have now thoroughly examined the OO concept of a discriminator and have seen
    how discriminators can be used to help evaluate the reasonableness of a design.
    In many cases, designs using diamond-shaped hierarchies can be re-designed to
    not only eliminate the diamond shape, but to also eliminate multiple inheritance
    altogether. Let's briefly recap the MI issues and OO concepts we've covered in
    this chapter before moving onward to our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have marched onward with our quest for understanding object-oriented
    programming by exploring a controversial OOP topic, that of multiple inheritance.
    First, in this chapter, we have understood the simple mechanics of multiple inheritance.
    Equally important, we have reviewed reasons for building inheritance hierarchies
    and possible reasons for using MI (that is, specifying Is-A, mix-in, and Has-A
    relationships). We have been reminded that using inheritance to specify Is-A relationships
    supports pure OO designs. We have also seen using MI to implement mix-in relationships.
    We have also taken a look at the controversial use of MI to quickly implement
    a Has-A relationship; we'll see in [*Chapter 10*](B15702_10_Final_NM_ePub.xhtml#_idTextAnchor386),
    *Implementing Association, Aggregation, and Composition*, a preferred implementation
    for Has-A.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how having multiple inheritance in our OO design toolkit can lead
    to diamond-shaped hierarchies. We have seen the inevitable issues arising from
    diamond-shaped hierarchies, such as duplication in memory, duplication in construction/destruction,
    and ambiguity when accessing a replicated sub-object. We have also seen that C++
    provides a language-supported mechanism to correct these issues, using virtual
    base classes. We know that virtual base classes solve a tedious problem, yet they
    themselves are not perfect solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In an effort to critique diamond-shaped hierarchies, we have looked at the OO
    concept of a discriminator to help us weigh the validity of an OO design using
    MI in a diamond shape. This has also led us to understand that alternate designs
    can apply to a set of objects; sometimes a redesign is a more elegant approach
    in which the solution will yield easier, long-term use.
  prefs: []
  type: TYPE_NORMAL
- en: C++ is a "*you can do anything*" OOP language, and multiple inheritance is a
    controversial OO concept. Knowing when certain MI designs may be warranted and
    understanding language features to help with those MI issues will make you a better
    programmer. Knowing when a redesign is in order is also critical.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to continue to [*Chapter 10*](B15702_10_Final_NM_ePub.xhtml#_idTextAnchor386),
    *Implementing Association, Aggregation, and Composition*, to further enhance our
    OOP skills by next learning how to represent association, aggregation, and composition
    with programming techniques. These upcoming concepts will *not* have direct language
    support, but the concepts are instrumental in our OO arsenal of skills. Let's
    move onward!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type in (or use the online code for) the diamond-shaped hierarchy example in
    this chapter that uses virtual base classes. Run it as is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. How many `LifeForm` sub-objects exist for the instance of `Centaur`?
  prefs: []
  type: TYPE_NORMAL
- en: 'b. How many times is the `LifeForm` constructor (and destructor) invoked? Hint:
    you may want to place trace statements using `cout` in each of your constructors
    and destructor.'
  prefs: []
  type: TYPE_NORMAL
- en: c. Which `LifeForm` constructor would be invoked if the constructor selections
    for `LifeForm` in the member initialization list of the `Centaur` constructors
    were omitted?
  prefs: []
  type: TYPE_NORMAL
- en: Now, remove the keyword `virtual` from the base class list of `Person` and `Horse`
    (that is, `LifeForm` will no longer be a virtual base class of `Person` and `Horse`.
    `LifeForm` will just be a typical base class of `Person` and `Horse`). Also remove
    the `LifeForm` constructor selection from the member initialization list of the
    `Centaur` constructors. Now, instantiate `Centaur`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. How many `LifeForm` sub-objects exist for the instance of `Centaur`?
  prefs: []
  type: TYPE_NORMAL
- en: b. Now, how many times is the `LifeForm` constructor (and destructor) invoked?
  prefs: []
  type: TYPE_NORMAL

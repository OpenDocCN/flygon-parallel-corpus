- en: '*Chapter 10*: Implementing Association, Aggregation, and Composition'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will continue advancing our knowledge of object-oriented programming
    in C++. We will augment our understanding of object relationships by exploring
    the object-oriented concepts of association, aggregation, and composition. None
    of these OO concepts have direct language support in C++; we will instead learn
    multiple programming techniques to implement these ideas. We will also understand
    which implementation techniques are preferred for various concepts, as well as
    the advantages and pitfalls of various practices.
  prefs: []
  type: TYPE_NORMAL
- en: Association, aggregation, and composition occur copiously in OO designs. It
    is crucial to understand how to implement these important object relationships.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the OO concepts of aggregation and composition, and various implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the OO concept of association and its implementation, including
    the importance of back-link maintenance and the utility of reference counting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the OO concepts of association,
    aggregation, and composition, and how to implement these relationships in C++.
    You will also understand many housekeeping approaches necessary to keep these
    relationships up to date, such as reference counting and back-link maintenance.
    Though the concepts are relatively straightforward, you will see why there is
    a substantial amount of bookkeeping required to maintain accuracy for these types
    of object relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Let's broaden our understanding of C++ as an OOP language by exploring these
    core object relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The online code for the full program examples can be found at the following
    GitHub URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter10](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter10).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter10` in a file named `Chp10-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3sag0RY](https://bit.ly/3sag0RY).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding aggregation and composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The object-oriented concept of aggregation arises in many OO designs. It comes
    up as frequently as inheritance does to specify object relationships. **Aggregation**
    is used to specify Has-A, whole-part, and in some cases, containment relationships.
    A class may contain aggregates of other objects. Aggregation can be broken into
    two categories – *composition* as well as a less strict and *generalized* form
    of aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: Both **generalized aggregation** and **composition** imply a Has-A or whole-part
    relationship. However, the two differ in the existence requirements between the
    two related objects. With generalized aggregation, the objects can exist independently
    from one another; yet with composition, the objects cannot exist without one another.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at each variety of aggregation, starting with composition.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and implementing composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Composition** is the most specialized form of aggregation and is often what
    most OO designers and programmers think of when they consider aggregation. Composition
    implies containment, and is most often synonymous with a whole-part relationship
    – that is, the whole entity is composed of one or more parts. The whole *contains*
    the parts. The Has-A relationship will also apply to composition.'
  prefs: []
  type: TYPE_NORMAL
- en: The outer object, or *whole*, can be made up of *parts*. With composition, parts
    do not exist without the whole. Implementation is usually an embedded object –
    that is, a data member of the contained object type. On rare occasions, the outer
    object will contain a pointer or reference to the contained object type; however,
    when this occurs, the outer object will be responsible for the creation and destruction
    of the inner object. The contained object has no purpose without its outer layer.
    Likewise, the outer layer is not *ideally* complete without its inner, contained
    pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at a composition example as typically implemented. The example
    will illustrate containment – a `Student` *Has-A(n)* `Id`. More so, we will imply
    that an `Id` is a necessary part of a `Student` and will not exist without a `Student`.
    `Id` objects on their own serve no purpose. `Id` objects simply do not need to
    exist if they are not a part of a primary object that gives them purpose. Likewise,
    you might argue that a `Student` is incomplete without an `Id`, though this is
    a bit subjective! We will implement the *part* using an embedded object within
    the *whole*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The composition example will be broken into many segments. Though only portions
    of the example are shown, the full program can be found in the following GitHub
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter10/Chp10-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter10/Chp10-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code fragment, we have defined an `Id` class. An `Id` will be
    a class that can be contained by other classes needing a fully functional `Id`
    capability. The `Id` will become a *part* of the *whole* objects that may choose
    to contain it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move onward to build a set of classes that will ultimately contain this
    `Id`. We will start with a class we are familiar with, `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the previous segment of code, we have defined the `Person` class, as we are
    accustomed to describing it. To abbreviate this example, let us assume that the
    accompanying member functions exist as prototyped in the aforementioned class
    definition. You can reference these member functions in the earlier-provided GitHub
    link for the online code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define our `Student` class. Though it will contain elements that
    we are accustomed to seeing, `Student` will also contain an `Id`, as an embedded
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `Student` class, we routinely notice that `Student` is derived
    from `Person`. As we already know, this means that a `Student` instance will include
    the memory layout of a `Person`, as a `Person` sub-object.
  prefs: []
  type: TYPE_NORMAL
- en: However, notice the data member, `Id studentId;`, in the `Student` class definition.
    Here, `studentId` is of type `Id`. It is not a pointer, nor is it a reference
    to an `Id`. Data member `studentId` is an embedded object. This means that when
    a `Student` class is instantiated, not only will the memory from inherited classes
    be included, but also the memory for any embedded objects. We will need to provide
    a means to initialize the embedded object, `studentId`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move forward with the `Student` member functions to understand how we
    may initialize, manipulate, and access the embedded object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previously listed member functions of `Student`, let's begin with our
    constructors. Notice in the default constructor we utilize the member initialization
    list (`:`) to specify `studentId("None")`. Because `studentId` is a member object,
    we have the opportunity to select (via the member initialization list) which constructor
    should be used for its initialization. Here, we merely select the one with the
    `Id(const char *)` signature.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, in the alternate constructor for `Student`, we use the member initialization
    list to specify `studentId(id)`, which will also select the `Id(const char *)`
    constructor, passing the parameter `id` to this constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The copy constructor for `Student` additionally specifies how to initialize
    the `studentId` member object with the `studentId(ps.studentId)` specification
    in the member initialization list. Here, we simply call the copy constructor for
    `Id`.
  prefs: []
  type: TYPE_NORMAL
- en: In our destructor for `Student`, we do not need to deallocate `studentId`. As
    this data member is an embedded object, its memory will go away when the memory
    for the outer object goes away. Of course, because `studentId` is an object itself,
    its own destructor will first be called before its memory is released. Under the
    hood, the compiler will (covertly) patch in a call to the `Id` destructor for
    `studentId` as the last line of code in the `Student` destructor.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in the previous segment of code, let's notice the call to `studentId.GetId()`
    that occurs in both `Student::Print()` and `Student::GetStudentId()`. Here, the
    embedded object `studentId` calls its own public function `Id::GetId()` to retrieve
    its private data member in the scope of the `Student` class. Because `studentId`
    is private in `Student`, this embedded object may only be accessed within the
    scope of `Student` (that is, member functions of `Student`). However, the addition
    of `Student::GetStudentId()` provides a public wrapper for `Student` instances
    in other scopes to retrieve this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s take a look at our `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned `main()` function, we instantiate two `Student` instances,
    `s1` and `s2`. When the memory is created (in this case, on the stack) for each
    `Student`, memory for any inherited classes will also be included as sub-objects.
    Additionally, memory for any embedded objects, such as `Id`, will also be laid
    out as a sub-object within `Student`. The memory for the contained object, or
    *part*, will be allocated along with the allocation for the outer object, or *whole*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's notice the access to the contained piece, the embedded `Id` object.
    We start with a call to `s1.GetStudentId()`; `s1` accesses a `Student` member
    function, `GetStudentId()`. That student member function will utilize the member
    object of `studentId` to call `Id::GetId()` on this inner object of type `Id`.
    The member function `Student::GetStudentId()` can implement this desired public
    access by simply returning the value that `Id::GetId()` returns on the embedded
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the output for the aforementioned program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This example details composition with its typical implementation, an embedded
    object. Let's now take a look at a much less used, alternate implementation –
    that of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Considering an alternate implementation for composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is useful to understand that composition can alternatively be implemented
    using inheritance; however, this is extremely controversial. Remember, inheritance
    is most often used to implement *Is-A and not Has-A* relationships. We briefly
    described using inheritance to implement Has-A relationships in [*Chapter 9*](B15702_09_Final_NM_ePub.xhtml#_idTextAnchor361),
    *Exploring Multiple Inheritance*.
  prefs: []
  type: TYPE_NORMAL
- en: To recap, you would simply inherit from the *part*, rather than embed the part
    as a data member. When doing so, you no longer need to provide *wrapper* functions
    to the *part*, as we saw in the previous program, with the `Student::GetStudentId()`
    method calling `studentId.GetId()` to provide access to its embedded part. The
    wrapper function was necessary with the embedded object example, as the part (`Id`)
    was private in the whole (`Student`). Programmers could not have accessed the
    private `studentId` data member of `Student` outside the scope of `Student`. Of
    course, member functions of `Student` (such as `GetStudentId()`) can access their
    own class' private data members and in doing so, can implement the `Student::GetStudentId()`
    wrapper function to provide such (safe) access.
  prefs: []
  type: TYPE_NORMAL
- en: Had inheritance been used, the public interface of `Id::GetId()` would have
    been simply inherited as a public interface in `Student`, providing simple access
    without the need to first go through the embedded object explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, though inheriting a *part* is simple in some ways, it vastly compounds
    multiple inheritance. We know multiple inheritance can provide many potential
    complications. Also, using inheritance, the *whole* can only contain one of each
    *part* – not multiple instances of a *part*.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, implementing a whole-part relationship with inheritance may be
    confusing when one compares the implementation to OO design. Remember, inheritance
    usually means Is-A and not Has-A. For these reasons, the most typical and appreciated
    implementation of an aggregate is through an embedded object.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's move onward to looking at a more general form of aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and implementing a generalized aggregation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have looked at the most commonly used form of aggregation in OO designs,
    that of composition. Most notably, with composition, we have seen that the part
    does not have a reason to exist without the whole. Nonetheless, a more generalized
    (but less common) form of aggregation exists and is sometimes specified in OO
    designs. We will now consider this less-common form of aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: In a **generalized aggregation**, a *part* may exist without the *whole*. A
    part will be created separately and then attached to the whole at a later point
    in time. When the *whole* goes away, a *part* may then remain to be salvaged for
    use with another outer or *whole* object.
  prefs: []
  type: TYPE_NORMAL
- en: In a generalized aggregation, the Has-A relationship certainly applies, as does
    the whole-part designation. The difference is that the *whole* object will not
    create nor destroy a *part* sub-object. Consider the straightforward example that
    a `Car` *Has-A(n)* `Engine`. A `Car` object also Has-A set of 4 `Tire` objects.
    The `Engine` or `Tire` objects can be manufactured separately and then passed
    to the constructor of the `Car` to provide these parts to the whole. Yet should
    an `Engine` be destroyed, a new `Engine` can easily be swapped in (using a member
    function), without requiring the entire `Car` to be destroyed and then re-constructed.
  prefs: []
  type: TYPE_NORMAL
- en: A generalized aggregation is equivalent to a Has-A relationship, yet we think
    of this with more flexibility and permanence of the individual parts than we did
    with composition. We consider this relationship as an aggregation simply because
    we wish to equate the objects with a Has-A meaning. The Has-A relationship in
    the `Car`, `Engine`, `Tire` example is strong; the `Engine` and `Tire`s are necessary
    parts, required to make the whole `Car`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, implementation typically is with the *whole* containing a pointer (or
    set of pointers) to the *part*(s). It is important to note that the parts will
    be passed into a constructor (or another member function) of the outer object
    to establish the relationship. The critical marker is that the whole will not
    create (nor destroy) the parts. And the parts will never destroy the whole.
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, the longevity of the individual pieces (and the basic implementation)
    of a generalized aggregation will be similar to our next topic – association.
    Let's move forward to our next section to understand the similarities as well
    as the OO conceptual differences (sometimes subtle) between generalized aggregation
    and association.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding associations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **association** models a relationship that exists between otherwise-unrelated
    class types. An association can provide ways for objects to interact to fulfill
    these relationships. Associations are not used for Has-A relationships; however,
    in some cases, there are shades of gray as to whether we're describing a *bona
    fide* Has-A relationship, or if we are merely using the phrase Has-A because it
    sounds appropriate linguistically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplicity for associations exists: one-to-one, one-to-many, many-to-one,
    or many-to-many. For example, a `Student` may be associated with a single `University`,
    and that `University` may be associated with many `Student` instances; this is
    a one-to-many association.'
  prefs: []
  type: TYPE_NORMAL
- en: Associated objects have an independent existence. That is, two or more objects
    may be instantiated and exist independently for a portion of the application.
    At some point, one object may wish to assert a dependency or relationship with
    the other object. Later in the application, the associated objects may part ways
    and continue on their own, unrelated paths.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the relationship between a `Course` and an `Instructor`.
    A `Course` is associated with an `Instructor`. A `Course` requires an `Instructor`;
    an `Instructor` is integral to the `Course`. An `Instructor` may be associated
    with many `Course`(s). Yet each part exists independently – one will not create
    nor destroy the other. Instructors may also exist independently without courses;
    perhaps an instructor is taking time to write a book, or is taking a sabbatical,
    or is a professor conducting research.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the association is very similar to a generalized aggregation.
    In both cases, the related objects also exist independently. In this case, whether
    one says that `Course` Has-A(n) `Instructor` or that a `Course` has a dependency
    on an `Instructor` can be a shade of gray. You may ask yourself – is it just spoken
    language that makes me choose the wording of Has-A? Do I instead mean that there
    is a necessary link between the two? Perhaps the relationship is an association,
    and its descriptive adornment (to further describe the nature of the association)
    is *teaches*. You may have arguments supporting either choice. For this reason,
    generalized aggregations can be considered specialized types of associations;
    we will see that their implementations are the same, using independently existing
    objects. Nonetheless, we will distinguish a typical association as being a relationship
    between objects that decisively do not support a true Has-A relationship.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the relationship between `University` and `Instructor`.
    Rather than thinking of this as a Has-A relationship, we may instead consider
    the relationship between the two as that of association; we can think of the adornment
    describing this relationship as *employs*. Likewise, `University` has a relationship
    with many `Student` objects. The association here may be described by the adornment
    *educates*. The distinction can be made that the `University` is made up of `Department`
    objects, `Building` objects, and components of this nature to support any of its
    Has-A relationships through containment, yet its relationships with `Instructor`
    objects, `Student` objects, and so on are made using associations.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have distinguished typical associations from generalized aggregations,
    let's take a look at how we can implement associations and some of the complexities
    involved.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing association
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typically, an association between two or more objects is implemented using pointers
    or sets of pointers. The *one* side is implemented using a pointer to the associated
    object, whereas the *many* side of the relationship is implemented as a set of
    pointers to the associated objects. A set of pointers may be an array of pointers,
    a linked list of pointers, or truly any collection of pointers. Each type of collection
    will have its own set of advantages and drawbacks. For example, arrays of pointers
    are easy to use, have direct access to specific members, yet have a fixed number
    of items. Linked lists of pointers can accommodate any quantity of items, yet
    accessing a specific element requires traversing past others to find the desired
    item.
  prefs: []
  type: TYPE_NORMAL
- en: Occasionally, a reference may be used to implement the *one* side of an association.
    Recall, a reference must be initialized and cannot at a later date be reset to
    reference another object. Using a reference to model an association implies that
    one instance will be associated with a specific other instance for the duration
    of the primary object's existence. This is extremely restrictive; hence, references
    are used very infrequently to implement associations.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the implementation, when the primary object goes away, it will
    not interfere with (that is, delete) the associated object.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see a typical example illustrating the preferred implementation of a one-to-many
    association, utilizing a pointer on the *one* side, and a set of pointers on the
    *many* side. In this example, a `University` will be associated with many `Student`
    instances. And, for simplicity, a `Student` will be associated with a single `University`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To save space, some portions of this program that are the same as in our last
    example will not be shown; however, the program in its entirety can be found in
    our GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter10/Chp10-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter10/Chp10-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding segment, let's first notice the forward declaration of `class
    Student;`. This declaration will allow our code to reference the `Student` type
    prior to the `Student` class definition. In the `University` class definition,
    we see that there is an array of pointers to `Student`. We also see that the `EnrollStudent()`
    method takes a `Student *` as an argument. The forward declaration enables such
    usage of `Student` prior to its definition.
  prefs: []
  type: TYPE_NORMAL
- en: We also notice that the `University` has a simple interface with constructors,
    a destructor, and a few member functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at the `University` member function definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Taking a close look at the preceding `University` methods, we can see that in
    both constructors for `University`, we simply `NULL` out the pointers to the elements
    comprising our `studentBody`. Likewise, in the destructor, we similarly `NULL`
    out our links to the associated `Students`. Shortly, in this section, we will
    see there will be some additional back-link maintenance required, but for now,
    the point is that we will not delete the associated `Student` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Since `University` objects and `Student` objects exist independently, neither
    will create nor destroy instances of the other type.
  prefs: []
  type: TYPE_NORMAL
- en: We also come across an interesting member function, `EnrollStudent(Student *)`.
    In this method, a pointer to a specific `Student` will be passed in as an input
    parameter. We merely index into our array of pointers to `Student` objects, namely
    `studentBody`, and set an unused array element to point to the newly enrolled
    `Student`. We keep track of how many current `Student` objects exist using a `currentNumStudents`
    counter, which is incremented with a post increment after the pointer assignment
    to the array is made.
  prefs: []
  type: TYPE_NORMAL
- en: We also notice that `University` has a `Print()` method that prints the university's
    name, followed by its current student body. It does so by simply accessing each
    associated `Student` object in `studentBody` and asking each `Student` instance
    to invoke the `Student::GetFirstName()` and `Student::GetLastName()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s now take a look at our `Student` class definition, along with
    its inline functions. Recall, we''re assuming that the `Person` class is the same
    as seen earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, in the previous code segment, we see the `Student` class definition. Notice
    that we have an association with a `University` with the pointer data member `University
    *univ;`.
  prefs: []
  type: TYPE_NORMAL
- en: In the class definition for `Student`, we can also see there is a wrapper function
    to encapsulate access to the student's university's name with `Student::GetUniversity()`.
    Here, we allow the associated object, `univ`, to call its public method `University::GetName()`
    and return that value as the result of `Student::GetUniversity()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the non-inline member functions of `Student`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code segment, notice that the default `Student` constructor
    and the destructor both only `NULL` out their link to the `University` object.
    The default constructor has no way to set this link to an existing object, and
    should certainly not create a `University` instance to do so. Likewise, the `Student`
    destructor should not delete the `University` merely because the `Student` object's
    life expectancy is complete.
  prefs: []
  type: TYPE_NORMAL
- en: The most interesting part of the preceding code happens in both the alternate
    constructor and copy constructor of `Student`. Let's examine the alternate constructor.
    Here, we establish the link to the associated `University` as well as the back-link
    from the `University` back to the `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: In the line of code `this->univ = univ;`, we are assigning the data member,
    `univ` (as pointed to by the `this` pointer), by setting it to point to where
    the input parameter, `univ`, points. Look closely at the previous class definition
    – the identifier for the `University *` is named `univ`. Additionally, the input
    parameter for the `University *` in the alternate constructor is named `univ`.
    We cannot simply assign `univ = univ;` in the body of this constructor. The `univ`
    identifier, which is in the most local scope, is the input parameter, `univ`.
    Assigning `univ = univ;` would set this parameter to itself. Instead, we disambiguate
    the `univ` on the left-hand side of this assignment using the `this` pointer.
    The statement `this->univ = univ;` sets the data member `univ` to the input parameter
    `univ`. Could we merely have renamed the input parameter something different,
    such as `u`? Sure, but it is important to understand how to disambiguate an input
    parameter and data member with the same identifier when the need arises to do
    so.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's examine the next line of code, `univ->EnrollStudent(this);`. Now
    that `univ` and `this->univ` point to the same object, it does not matter which
    is used to set the back-link. Here, `univ` calls `EnrollStudent()`, which is a
    public member function in the `University` class. No problem, `univ` is of type
    `University`. `University::EnrollStudent(Student *)` expects to be passed a pointer
    to a `Student` to complete the linkage on the `University` side. Luckily, the
    `this` pointer in our `Student` alternate constructor (the scope of the calling
    function) is a `Student *`. `This` is literally the `Student *` that we need to
    create the back-link. Here is another example where the explicit use of the `this`
    pointer is required to complete the task at hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move forward to our `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in the previous code fragment in our `main()` function, we can create
    several independently existing objects, create an association between them, and
    then view that relationship in action.
  prefs: []
  type: TYPE_NORMAL
- en: First, we instantiate a `University`, namely `u1`. Next, we instantiate three
    `Students`, `s1`, `s2`, and `s3`, and associate each to `University u1`. Note
    that this association can be set when we instantiate a `Student`, or later on,
    for example, if the `Student` class supported a `SelectUniversity(University *)`
    interface to do so.
  prefs: []
  type: TYPE_NORMAL
- en: We then print out each `Student`, along with the name of the `University` each
    `Student` attends. Then we print out the student body for our `University`, `u1`.
    We notice that the link built between the associated objects is complete in both
    directions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the output for the aforementioned program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We've seen how easily associations can be set up and utilized between related
    objects. However, a lot of housekeeping will arise from implementing associations.
    Let's move forward to understanding the necessary and related issues of reference
    counting and back-link maintenance, which will help with these housekeeping endeavors.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing back-link maintenance and reference counting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous sub-section, we have seen how to implement associations using
    pointers. We've seen how to link an object with a pointer to an object in an associated
    instance. And we've seen how to complete the circular, two-sided relationship
    by establishing a back-link.
  prefs: []
  type: TYPE_NORMAL
- en: However, as is typical for associated objects, the relationships are fluid and
    change over time. For example, the given `Student` body will change quite often
    for a given `University`, or the various `Course` set an `Instructor` will teach
    will change each semester. It will be typical, then, to remove a particular object's
    association to another object, and perhaps associate instead to a different instance
    of that class. But that also means that the associated object must know to remove
    its link to the first-mentioned object. This becomes complicated.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the `Student` and `Course` relationship. A `Student` is
    enrolled in many `Course` instances. A `Course` contains an association to many
    `Student` instances. This is a many-to-many association. Let's imagine that the
    `Student` wishes to drop a `Course`. It is not enough for a specific `Student`
    instance to remove a pointer to a specific `Course` instance. Additionally, the
    `Student` must let the particular `Course` instance know that the `Student` in
    question should be removed from that `Course`'s roster. This is known as back-link
    maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Consider what would happen in the above scenario if a `Student` were to simply
    `NULL` out its link to the `Course` it was dropping, and do nothing further. The
    `Student` instance in question would be fine. However, the formerly associated
    `Course` instance would still contain a pointer to the `Student` in question.
    Perhaps this would equate to the `Student` receiving a failing grade in the `Course`
    as the `Instructor` still thinks the `Student` in question is enrolled, yet hasn't
    been turning in their homework. In the end, the `Student` has been affected after
    all, with the failing grade.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, with associated objects, one object will not delete the other when
    it is done with the other object. For example, when a `Student` drops a `Course`,
    they will not delete that `Course` – only remove their pointer to the `Course`
    in question (and definitely also handle the required back-link maintenance).
  prefs: []
  type: TYPE_NORMAL
- en: One idea to help us with overall link maintenance is to consider **reference
    counting**. The purpose of reference counting is to keep track of how many pointers
    may be pointing to a given instance. For example, if other objects point to a
    given instance, that instance should not be deleted. Otherwise, the pointers in
    the other object will point to deallocated memory, which will lead to numerous
    run-time errors.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider an association with multiplicity. Such as the relationship between
    a `Student` and a `Course`. A `Student` should keep track of how many `Course`
    pointers are pointing to the `Student`, that is, how many `Courses` the `Student`
    is taking. A `Student` should not be deleted while various `Courses` point to
    that `Student`. Otherwise, `Courses` will point to deleted memory. One way to
    handle this situation is to check within the `Student` destructor if the object
    (`this`) contains any non-`NULL` pointers to `Courses`. If the object does, it
    then needs to call a method through each of the active `Courses` to request links
    to the `Student` be removed from each such `Course`. After each link is removed,
    the reference counter corresponding to the set of `Course` instances can be decremented.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, the link maintenance should occur in the `Course` class in favor of
    `Student` instances. `Course` instances should not be deleted until all `Student`
    instances enrolled in that `Course` have been notified. Keeping a counter of how
    many `Student` instances point to a particular instance of a `Course` through
    reference counting is helpful. In this example, it is as simple as maintaining
    a variable to reflect the current number of `Student` instances enrolled in the
    `Course`.
  prefs: []
  type: TYPE_NORMAL
- en: We can meticulously conduct link maintenance ourselves, or we may choose to
    use smart pointers to manage the lifetime of an associated object. **Smart pointers**
    can be found in the C++ Standard Library. They encapsulate a pointer (that is,
    wrap a pointer within a class) to add smart features, including reference counting
    and memory management. Because smart pointers utilize templates, which we will
    not cover until [*Chapter 13*](B15702_13_Final_NM_ePub.xhtml#_idTextAnchor486),
    *Working with Templates*, we will just mention their potential utility here.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen the importance of back-link maintenance and the utility of
    reference counting to fully support associations and their successful implementation.
    Let's now briefly recap the OO concepts we've covered in this chapter – association,
    aggregation, and composition – before moving onward to our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have pressed forward with our pursuit of object-oriented
    programming by exploring various object relationships – association, aggregation,
    and composition. We have understood the various OO design concepts representing
    these relationships and have seen that C++ does not offer direct language support
    through keywords or specific language features to implement these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, we have learned several techniques for implementing these core
    OO relationships, such as embedded objects for composition and generalized aggregation,
    or using pointers to implement association. We have looked at the typical longevity
    of object existence with these relationships, for example, with aggregation, by
    creating and destroying its inner part (through an embedded object, or more rarely
    by allocating and deallocating a pointer member), or through the independent existence
    of associated objects that neither create nor destroy one another. We have also
    looked under the hood at the housekeeping required to implement association, particularly
    those with multiplicity, by examining back-link maintenance and reference counting.
  prefs: []
  type: TYPE_NORMAL
- en: We have added key features to our OOP skills through understanding how to implement
    association, aggregation, and composition. We have seen examples of how these
    relationships may even be more prolific in OO designs than inheritance. By mastering
    these skills, we have completed our core skillset of implementing essential OO
    concepts in C++.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to continue to [*Chapter 11*](B15702_11_Final_NM_ePub.xhtml#_idTextAnchor417),
    *Handling Exceptions*, which will begin our quest to expand our C++ programming
    repertoire. Let's continue forward!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add an additional `Student` constructor to the `University`-`Student` example
    in this chapter to accept the `University` constructor argument by reference,
    rather than by pointer. For example, in addition to the constructor with signature
    `Student::Student(const char *fn, const char *ln, char mi, const char *t, float
    avg, const char *course, const char *id, University *univ);`, overload this function
    with a similar one, but with `University &univ` as the last parameter. How does
    this change the implicit call to this constructor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hint: within your overloaded constructor, you will now need to take the address-of
    (`&`) the `University` reference parameter to set the association (which is stored
    as a pointer). You may need to switch to object notation (`.`) to set the back-link
    (if you use the parameter `univ`, versus the data member `this->univ`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a C++ program to implement a many-to-many association between objects
    of type `Course` and of type `Student`. You may choose to build on your previous
    programs that encapsulate `Student`. The many-to-many relationship should work
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. A given `Student` may take zero to many `Course`s, and a given `Course` will
    associate to many `Student` instances. Encapsulate the `Course` class to minimally
    contain a course name, a set of pointers to associated `Student` instances, and
    a reference count to keep track of the number of `Student` instances who are in
    the `Course` (this will equate to how many `Student` instances point to a given
    instance of a `Course`). Add the appropriate interface to reasonably encapsulate
    this class.
  prefs: []
  type: TYPE_NORMAL
- en: b. Add to your `Student` class a set of pointers to the `Course` instances in
    which that `Student` is enrolled. Additionally, keep track of how many `Course`
    instances a given `Student` is enrolled in. Add appropriate member functions to
    support this new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: c. Model your many-sided associations either using a linked-list of pointers
    (that is, the data part is a pointer to the associated object), or as an array
    of pointers to the associated objects. Note that an array will enforce a limit
    on the number of associated objects you can have; however, this may be reasonable
    because a given `Course` can only accommodate a maximum number of `Student`s and
    a `Student` may only enroll up to a maximum number of `Course`s per semester.
    If you choose the array of pointers approach, make sure your implementation includes
    error checking to accommodate exceeding the maximum number of associated objects
    in each array.
  prefs: []
  type: TYPE_NORMAL
- en: d. Be sure to check for simple errors, such as trying to add `Student`s in a
    `Course` that is full, or adding too many `Course`s to a `Student`'s schedule
    (assume there is an upper bound of 5 courses per semester).
  prefs: []
  type: TYPE_NORMAL
- en: e. Make sure your destructors do not delete the associated instances.
  prefs: []
  type: TYPE_NORMAL
- en: f. Introduce at least three `Student` objects, each of which takes two or more
    `Course`s. Additionally, make sure each `Course` has multiple `Student`s enrolled.
    Print each `Student`, including each `Course` in which they are enrolled. Likewise,
    print each `Course`, showing each `Student` enrolled in the `Course`.
  prefs: []
  type: TYPE_NORMAL
- en: '(Optional) Enhance your program in *Exercise 2* to gain experience with back-link
    maintenance and reference counting as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a. Implement a `DropCourse()` interface for `Student`. That is, create a `Student::
    DropCourse(Course *)` method in `Student`. Here, find the `Course` the `Student`
    wishes to drop in their course list, but before removing the `Course`, call a
    method on that `Course` to remove the aforementioned `Student` (that is, `this`)
    from the `Course`. Hint: you can make a `Course::RemoveStudent(Student *)` method
    to help with back-link removal.'
  prefs: []
  type: TYPE_NORMAL
- en: b. Now, fully implement proper destructors. When a `Course` is destructed, have
    the `Course` destructor first tell each remaining, associated `Student` to remove
    their link to that `Course`. Likewise, when a `Student` is destructed, loop through
    the `Student`'s course list to ask those `Courses` to remove the aforementioned
    `Student` (that is, `this`) from their student list. You may find reference counting
    in each class (that is, by checking `numStudents` or `numCourses`) helpful to
    see if these tasks must be engaged.
  prefs: []
  type: TYPE_NORMAL

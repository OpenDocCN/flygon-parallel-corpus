- en: '*Chapter 12*: Friends and Operator Overloading'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will continue our pursuit of expanding your C++ programming repertoire
    beyond OOP concepts, with the goal of writing more extensible code. We will next
    explore **friend functions**, **friend classes**, and **operator overloading**
    in C++. We will understand how operator overloading can extend operators beyond
    their usage with standard types to behave uniformly with user-defined types, and
    why this is a powerful OOP tool. We will learn how friend functions and classes
    can be safely used to achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding friend functions and friend classes, appropriate reasons to utilize
    them, and measures to add safety to their usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning operator overloading essentials – how and why to overload operators
    and ensuring operators are polymorphic between standard and user-defined types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing operator functions; knowing when friends may be necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will unlock the proper usage of friends and
    understand their utility in harnessing C++'s ability to overload operators. Though
    the usage of friend functions and classes can be exploited, you will instead learn
    about their contained usage only within two tightly coupled classes. You will
    understand how the proper usage of friends can enhance operator overloading, allowing
    operators to be extended to support user-defined types so they may work associatively
    with their operands.
  prefs: []
  type: TYPE_NORMAL
- en: Let's increase our understanding of C++ by expanding your programming repertoire
    through exploring friend functions, friend classes, and operator overloading.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The online code for the full program examples can be found at the following
    GitHub URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the `Chapter12`
    subdirectory in a file named `Chp12-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3f3tIm4](https://bit.ly/3f3tIm4).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding friend classes and friend functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encapsulation is a valuable OOP feature that C++ offers through the proper usage
    of classes and access regions. Encapsulation offers uniformity in the manner in
    which data and behaviors are manipulated. In general, it is unwise to forfeit
    the encapsulated protection that a class offers.
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, selected programming situations in which breaking encapsulation
    slightly is considered more acceptable than the alternative of providing an *overly
    public* interface to a class, that is, when a class needs to provide methods for
    two classes to cooperate, yet, in general, those methods are inappropriate to
    be publicly accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a scenario that may lead us to consider slightly forfeiting
    (that is, breaking) the sacred OOP concept of encapsulation:'
  prefs: []
  type: TYPE_NORMAL
- en: Two tightly coupled classes may exist that are not otherwise related to one
    another. One class may have one or more associations with the other class and
    needs to manipulate the other class's members. Yet, a public interface to allow
    access to such members would make these internals *overly public* and subject
    to manipulation well beyond the needs of the pair of tightly coupled classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this situation, it is a better choice to allow one class in the tightly coupled
    pair to have access to the other class's members versus providing a public interface
    in the other class, which allows more manipulation of these members than is generally
    safe. We will see, momentarily, how to minimize this prospective loss of encapsulation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selected operator overloading situations, which we will soon see, may require
    an instance to have access to its members while in a function that is outside
    of its class scope. Again, a fully accessible public interface may be considered
    dangerous.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Friend functions** and **friend classes** allow this selective breaking of
    encapsulation to occur. Breaking encapsulation is serious and should not be done
    to simply override access regions. Instead, friends can be used – with added safety
    measures – when the choices are slightly breaking encapsulation between two tightly
    coupled classes or providing an overly public interface, which would yield greater
    and potentially unwanted access to another class''s members from various scopes
    in the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us take a look at how each may be used and then we will add the relevant
    safety measures we should insist on employing. Let's start with friend functions
    and friend classes.
  prefs: []
  type: TYPE_NORMAL
- en: Using friend functions and friend classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Friend functions** are functions that are individually granted *extended
    scope* to include the class with which they are associated. Let''s examine the
    implications and logistics:'
  prefs: []
  type: TYPE_NORMAL
- en: In the scope of friend functions, an instance of the associated type can access
    its own members as if it were in the scope of its own class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A friend function needs to be prototyped as a friend in the class definition
    of the class relinquishing access (that is, extending its scope).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The keyword `friend` is used in front of the prototype that provides access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions overloading friend functions are not considered friends.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Friend classes** are classes in which every member function of the class
    is a friend function of the associated class. Let''s examine the logistics:'
  prefs: []
  type: TYPE_NORMAL
- en: A friend class should have a forward declaration in the class definition of
    the class that is providing it with access to its members (that is, scope).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The keyword `friend` should precede the forward declaration of the class gaining
    access (that is, whose scope has been extended).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Friend classes and friend functions should be utilized sparingly, only when
    breaking encapsulation selectively and slightly is a better choice than offering
    an *overly public* interface (that is, a public interface that would universally
    offer undesired access to selected members within any scope of the application).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by examining the syntax for friend classes and friend function
    declarations. The following classes do not represent complete class definitions;
    however, the complete program can be found in our online GitHub repository as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12/Chp12-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12/Chp12-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code fragment, we first notice a friend class definition within
    the `Id` class. The statement `friend class Student;` indicates that all member
    functions in `Student` are friend functions to `Id`. This all-inclusive statement
    is used in lieu of naming every function of the `Student` class as a friend function
    of `Id`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in the `Student` class, notice the declaration of `friend void Id::SetStudent(Student
    *);`. This friend function declaration indicates that only this specific member
    function of `Id` is a friend function of `Student`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implication of the friend function prototype, `friend void Id::SetStudent(Student
    *);`, is that if a `Student` finds itself in the scope of the `Id::SetStudent()`
    method, that `Student` may manipulate its own members as though it is in its own
    scope, namely, that of `Student`. You may ask: which `Student` may find itself
    in the scope of `Id::SetStudent(Student *)`? That''s easy. It is the one passed
    to the method as an input parameter. The result is that the input parameter of
    type `Student *` in the `Id::SetStudent()` method may access its own private and
    protected members as if the `Student` instance were in its own class scope – it
    is in the scope of a friend function.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the implication of the friend class forward declaration `friend class
    Student;` found in the `Id` class is that if any `Id` instance finds itself in
    a `Student` method, that `Id` instance can access its own private or protected
    methods as if it were in its own class. The `Id` instance may be in any member
    function of its friend class, `Student`; it is as though those methods have been
    augmented to also have the scope of the `Id` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the class giving up access – that is, widening its scope – is the
    one to announce friendship. That is, the `friend class Student;` statement in
    `Id` says: if any `Id` happens to be in any member function of `Student`, allow
    that `Id` to have full access to its members as if it is in its own scope. Likewise,
    the friend function statement in `Student` indicates: if a `Student` instance
    is found (via the input parameter) in this particular method of `Id`, it may have
    access to its elements fully, as though it were in a member function of its own
    class. Think in terms of friendship as a means of augmenting scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen the basic mechanics of friend functions and friend classes,
    let's employ a simple contract to make it a bit more appealing to selectively
    break encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Making access safer when using friends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen that two tightly coupled classes, such as those related through
    an association, may need to extend their scope somewhat to selectively include
    one another through the use of **friend functions** or **friend classes**. The
    alternative is offering a public interface to select elements of each class. However,
    consider that you may not want the public interface to those elements to be uniformly
    accessible to be used in any scope of the application. You are truly facing a
    tough choice: utilize friends or provide an *overly public* interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Though it may make you initially cringe to utilize friends, it may be safer
    than the alternative of providing an undesired public interface to class elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To lessen the panic that you feel toward the selective breaking of encapsulation
    that friends allow, consider adding the following contract to your usage of friends:'
  prefs: []
  type: TYPE_NORMAL
- en: When utilizing friends, to lessen the loss of encapsulation, one class can provide
    private access methods to the other class's data members. Make these methods inline
    wherever possible, for efficiency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instance in question should agree to only utilize the private access methods
    created to appropriately access its desired members while in the scope of the
    friend function (even though it could actually unrestrictedly access any data
    or methods of its own type in the scope of the friend function).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a simple example to illustrate two tightly coupled classes appropriately
    using a `main()` function and several methods are not shown to save space, the
    complete example can be found in our GitHub repository as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12/Chp12-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12/Chp12-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's examine the preceding class definitions for `LinkListElement` and `LinkList`.
    Notice, in the `LinkListElement` class, we have three private member functions,
    that is, `void *GetData();`, `LinkListElement *GetNext();`, and `void SetNext(LinkListElement
    *);`. These three member functions should not be part of the public class interface.
    It is only appropriate for these methods to be used within the scope of `LinkList`,
    a class that is tightly coupled with `LinkListElement`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, notice the `friend class LinkList;` forward declaration in the `LinkListElement`
    class. This declaration means that all member functions of `LinkList` are friend
    functions of `LinkListElement`. As a result, any `LinkListElement` instances that
    find themselves in `LinkList` methods may access their own aforementioned private
    `GetData()`, `GetNext()`, and `SetNext()` methods simply because they will be
    in the scope of a friend class.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's take a look at the `LinkList` class in the preceding code. The class
    definition itself does not have any unique declarations with respect to friendship.
    After all, it is the `LinkListElement` class that has widened its scope to include
    methods of the `LinkedList` class, not the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at two selected member functions of the `LinkList`
    class. The full complement of these methods may be found online, at the previously
    mentioned URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we examine the preceding code, we can see that in a sampling of `LinkList`
    methods, a `LinkListElement` can call private methods on itself because it is
    in the scope of a friend function (which is essentially its own scope, widened).
    For example, in `LinkList::InsertAtFront()`, `LinkListElement *temp` sets its
    `next` member to `head` using `temp->SetNext(head)`. Certainly, we could have
    also directly accessed the private data member here using `temp->next = head;`.
    However, we maintained a modicum of encapsulation by `LinkListElement` providing
    private access functions, such as `SetNext()`, and asking `LinkList` methods (friend
    functions) to have `temp` utilize the private method `SetNext()`, rather than
    just directly manipulating the data member itself.
  prefs: []
  type: TYPE_NORMAL
- en: Because `GetData()`, `GetNext()`, and `SetNext()` in `LinkListElement` are inline
    functions, we do not forfeit performance by providing a sense of encapsulated
    access to the members `data` and `next`.
  prefs: []
  type: TYPE_NORMAL
- en: We can similarly see that other member functions of `LinkList`, such as `RemoveAtFront()`
    (and `Print()`, which appears in the online code), have `LinkListElement` instances
    utilizing its private access methods, rather than allowing the `LinkListElement`
    instances to grab their private `data` and `next` members directly.
  prefs: []
  type: TYPE_NORMAL
- en: '`LinkListElement` and `LinkList` are iconic examples of two tightly coupled
    classes in which it may be better to extend one class to include the other''s
    scope for access, rather than providing an *overly public* interface. After all,
    we wouldn''t want users in `main()` to get their hands on a `LinkListElement`
    and apply `SetNext()`, for example, which could change an entire `LinkedList`
    without the `LinkList` class''s knowledge.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen the mechanics as well as suggested usage for friend functions
    and classes, let's explore another language feature that may need to utilize friends
    – that of operator overloading.
  prefs: []
  type: TYPE_NORMAL
- en: Deciphering operator overloading essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ has a variety of operators in the language. C++ allows most operators to
    be redefined to include usage with user-defined types; this is known as **operator
    overloading**. In this way, user-defined types may utilize the same notation as
    standard types to perform these well-understood operations. We can view an overloaded
    operator as polymorphic in that its same form can be used with a variety of types
    – standard and user-defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all operators may be overloaded in C++. The following operators cannot
    be overloaded: member access (`.`), the ternary conditional operator (`?:`), the
    scope resolution operator (`::`), the pointer to member operator (`.*`), the `sizeof()`
    operator, and the `typeid()` operator. All the rest may be overloaded, provided
    at least one operand is a user defined type.'
  prefs: []
  type: TYPE_NORMAL
- en: When overloading an operator, it is important to promote the same meaning that
    the operator has for standard types. For example, the extraction operator (`<<)`
    is defined when used in conjunction with `cout` to print to standard output. This
    operator can be applied to various standard types, such as integers, floating-point
    numbers, and character strings. Should the extraction operator (`<<`) be overloaded
    for a user-defined type, such as `Student`, it should also mean to print to standard
    output. In this fashion, operator `<<` is polymorphic when used in the context
    of an output buffer, such as `cout`; that is, it has the same meaning, but different
    implementation, for all types.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that when overloading an operator in C++, we may not
    change the predefined precedence of the operators as they occur in the language.
    This makes sense – we are not rewriting the compiler to parse and interpret expressions
    differently. We are merely extending the meaning of an operator from its usage
    with standard types to include usage with user defined types. Operator precedence
    will remain unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: An `operator`, followed by the symbol representing the operator that you wish
    to overload.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the simple syntax of an operator function prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we intend to provide a means to add a floating-point number and a `Student`
    instance using the C++ addition operator (`+`). The meaning of this addition might
    be to average the new floating-point number with the student's existing grade
    point average. Here, the name of the operator function is `operator+()`.
  prefs: []
  type: TYPE_NORMAL
- en: In the aforementioned prototype, the operator function is not a member function
    of any class. The left expected operand will be a `float` and the right operand
    will be a `Student`. The return type of the function (`Student &`) allows us to
    cascade the use of `+` with multiple operands or be paired with multiple operators,
    such as `s1 = 3.45 + s2;`. The overall concept is that we can define how to use
    `+` with multiple types, provided at least one operand is a user defined type.
  prefs: []
  type: TYPE_NORMAL
- en: There's actually a lot more involved than the simple syntax shown above. Before
    we fully examine a detailed example, let's first take a look at more logistics
    relating to implementing operator functions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing operator functions and knowing when friends might be necessary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An **operator function**, the mechanism to overload an operator, may be implemented
    as a member function or as a regular, external function. Let''s summarize the
    mechanics of implementing operator functions with the following key points:'
  prefs: []
  type: TYPE_NORMAL
- en: Operator functions that are implemented as member functions will receive an
    implicit argument (the `this` pointer), plus at most one explicit argument. If
    the left operand in the overloaded operation is a user defined type in which modifications
    to the class can easily be made, implementing the operator function as a member
    function is reasonable and preferred.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator functions that are implemented as external functions will receive one
    or two explicit arguments. If the left operand in the overloaded operation is
    a standard type or a class type that is not modifiable, then an external (non-member)
    function must be used to overload this operator. This external function may need
    to be a `friend` of any object type that is used as the right-hand function argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator functions should most often be implemented reciprocally. That is, when
    overloading a binary operator, ensure that it has been defined to work, no matter
    in which order the data types (should they differ) appear in the operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at a full program example to illustrate the mechanics of
    operator overloading, including member and non-member functions, as well as scenarios
    requiring the usage of friends. Though some well-known portions of the program
    have been excluded to save space, the full program example can be found online
    in our GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12/Chp12-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter12/Chp12-Ex3.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s begin with our code examination by first looking at the preceding class
    definition for `Person`. In addition to the class elements that we are accustomed
    to seeing, we have four operator functions prototyped: `operator=()`, `operator==()`,
    and `operator+()`, which is implemented twice – so that the operands to `+` can
    be reversed.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions for `operator=()`, `operator==()`, and one version of `operator+()`
    will be implemented as member functions of this class, whereas the other `operator+()`,
    with `const char *` and `Person` parameters, will be implemented as a non-member
    function and will additionally necessitate the use of a friend function.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading the assignment operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s move forward to examine the applicable operator function definitions
    for this class, starting by overloading the assignment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let us now review the overloaded assignment operator in the preceding code.
    It is designated by the member function `Person &Person::operator=(const Person
    &p);`. Here, we will be assigning memory from a source object, which will be an
    input parameter `p`, to a destination object, which will be pointed to by `this`.
  prefs: []
  type: TYPE_NORMAL
- en: Our first order of business will be to ensure that we are not assigning an object
    to itself. Should this be the case, there is no work to be done! We make this
    check by testing `if (this != &p)` to see whether both addresses point to the
    same object. If we're not assigning an object to itself, we continue.
  prefs: []
  type: TYPE_NORMAL
- en: Next, within the conditional statement (`if`), we first deallocate the existing
    memory for the dynamically allocated data members pointed to by `this`. After
    all, the object on the left-hand side of the assignment pre-exists and undoubtedly
    has allocations for these data members.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we notice that the core piece of code within the conditional statement
    looks very similar to that of the copy constructor. That is, we carefully allocate
    space for pointer data members to match the sizes needed from their corresponding
    data members of the input parameter `p`. We then copy the applicable data members
    from input parameter `p` to the data members pointed to by `this`. For the `char`
    data member, `middleInitial`, memory allocation is not necessary; we merely use
    an assignment. In this segment of code, we ensure that we have performed a deep
    assignment. A shallow assignment, where the source and destination object would
    otherwise share memory for the data portions of data members that are pointers,
    would be a disaster waiting to happen.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, at the end of our implementation of `operator=()`, we return `*this`.
    Notice that the return type from this function is a reference to a `Person`. Since
    `this` is a pointer, we merely dereference it so that we may return a referenceable
    object. This is done so that assignments between `Person` instances can be cascaded;
    that is, `p1 = p2 = p3;` where `p1`, `p2`, and `p3` are each an instance of `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: An overloaded assignment operator is not inherited by derived classes, therefore
    it must be defined by each class in the hierarchy. Neglecting to overload `operator=`
    for a class will force the compiler to provide you with a default, shallow assignment
    operator for that class; this is dangerous for any classes containing data members
    that are pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Should the programmer wish to disallow assignment between two objects, the
    keyword `delete` can be used in the prototype of the overloaded assignment operator
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is useful to remember that the overloaded assignment operator shares many
    similarities with the copy constructor; the same care and cautions apply to both
    language features. Keep in mind, however, the assignment operator will be invoked
    when conducting an assignment between two pre-existing objects, whereas the copy
    constructor is implicitly invoked for initialization, following the creation of
    a new instance. With the copy constructor, the new instance uses the existing
    instance as its basis for initialization; similarly, the left-hand object of the
    assignment operator uses the right-hand object as its basis for the assignment.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading the comparison operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at our implementation of the overloaded comparison
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Continuing with a segment from our previous program, we overload the comparison
    operator. It is designated by the member function `int Person::operator==(const
    Person &p);`. Here, we will be comparing a `Person` object on the right-hand side
    of the operator, which will be referenced by the input parameter `p`, to a `Person`
    object on the left-hand side of the operator, which will be pointed to by `this`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, our first order of business will be to test whether the object on
    the `if (this != &p)` to see whether both addresses point to the same object.
    If both addresses point to the same object, we return the boolean (`bool`) value
    of `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check whether the two `Person` objects contain identical values. They
    may be separate objects in memory, yet if they contain identical values, we can
    likewise choose to return a `bool` value of `true`. If there is no match, we then
    return a `bool` value of `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading the addition operator as a member function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at how to overload `operator+` for `Person` and `const
    char *`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Moving forward with the preceding program, we overload the addition operator
    (`+`) to be used with a `Person` and a `const char *`. The operator function is
    designated by the member function prototype `Person& Person::operator+(const char
    *t);`. The parameter `t` will represent the right-hand operand of `operator+`,
    which is a character string. The left-hand operand will be pointed to by `this`.
    An example of its use would be `p1 + "Miss"`, where we wish to add a `title` to
    `Person` `p1` using `operator+`.
  prefs: []
  type: TYPE_NORMAL
- en: In the body of this member function, we merely use the input parameter `t` as
    an argument to `ModifyTitle()`, that is, `ModifyTitle(t);`. We then return `*this`
    so that we may cascade the use of this operator (notice the return type is `Person
    &`).
  prefs: []
  type: TYPE_NORMAL
- en: Overloading the addition operator as a non-member function (using friends)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s reverse the order of operands with `operator+` to allow for a `const
    char *` and a `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Continuing forward with the preceding program, we would ideally like `operator+`
    to work not only with a `Person` and a `const char *`, but also with the operands
    reversed; that is, with a `const char *` and a `Person`. There is no reason this
    operator should work one way and not the other.
  prefs: []
  type: TYPE_NORMAL
- en: To implement `operator+` fully, we next overload `operator+()` to be used with
    `const char *` and `Person`. The operator function is designated by the non-member
    function `Person& operator+(const char *t, Person &p);`, which has two explicit
    input parameters. The first parameter, `t`, will represent the left operand of
    `operator+`, which is a character string. The second parameter, `p`, will be a
    reference to the right operand used in `operator+`. An example use might be `"Miss"
    + p1`, where we wish to add a title to `Person p1` using `operator+`.
  prefs: []
  type: TYPE_NORMAL
- en: In the body of this non-member function, we merely take the input parameter
    `p` and apply the protected method `ModifyTitle()` using the string of characters
    specified by parameter `t`. That is, `p.ModifyTitle(t)`. However, because `Person::ModifyTitle()`
    is protected, `Person &p` may not invoke this method outside of member functions
    of `Person`. We are in an external function; we are not in the scope of `Person`.
    Therefore, unless this member function is a `friend` of `Person`, `p` may not
    invoke `ModifyTitle()`. Luckily, `Person &operator+(const char *, Person &);`
    has been prototyped as a friend function in the `Person` class, providing the
    necessary scope to `p` to allow it to invoke its protected method. It is as if
    `p` is in the scope of `Person`; it is in the scope of a friend function of `Person`!
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let us move forward to our `main()` function, tying together our many
    aforementioned code segments, so we may see how to invoke our operator functions
    utilizing our overloaded operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let us examine our `main()` function for the preceding program. We
    begin by instantiating three instances of `Person`, namely, `p1`, `p2`, and `p3`;
    we then print their values using the member function `Print()` for each instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we invoke our overloaded assignment operator with the statement `p1 =
    p2;`. Under the hood, this translates to the following operator function invocation:
    `p1.operator=(p2);`. From this, we can clearly see that we are invoking the previously
    defined `operator=()` method of `Person`, which performs a deep copy from the
    source object `p2` to the destination object `p1`. We apply `p1.Print();` to see
    our resulting copy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we invoke our overloaded `operator+` with `"Ms." + p2`. This portion
    of this line of code translates to the following operator function call: `operator+("Ms.",
    p2);`. Here, we simply invoke our previously described `operator+()` function,
    which is a non-member function and `friend` of the `Person` class. Because this
    function returns a `Person &`, we can cascade this function call to look more
    like the usual context of addition and additionally write `p2 = "Ms." + p2;`.
    In this full line of code, first `operator+()` is invoked for `"Ms." + p2`. The
    return value of this invocation is `p2`, which is then used as the right-hand
    operand of the cascaded call to `operator=`. Notice that the left-hand operand
    to `operator=` also happens to be `p2`. Fortunately, the overloaded assignment
    operator checks for self-assignment.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we see a cascaded assignment of `p1 = p2 = p3;`. Here, we are invoking
    the overloaded assignment operator twice. First, we invoke `operator=` with `p2`
    and `p3`. The translated call would be `p2.operator=(p3);`. Then, using the return
    value of the first function call, we would invoke `operator=` a second time. The
    nested, translated call for `p1 = p2 = p3;` would look like `p1.operator=(p2.operator=(p3));`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in this program, we invoke the overloaded comparison operator twice.
    For example, each comparison of `if (p2 == p2)` or `if (p1 == p3)` merely calls
    the `operator==` member function we have defined above. Recall, we've written
    this function to report `true` both if the objects are the same in memory or simply
    contain the same values, and return `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We have now seen how to specify and utilize friend classes and friend functions,
    how to overload C++ operators, and cases when these two concepts can complement
    each other. Let us now briefly recap the features we have learned about in this
    chapter, before moving forward to our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have furthered our C++ programming endeavors beyond OOP
    language features to include features that will enable us to write more extensible
    programs. We have learned how to utilize friend functions and friend classes and
    we have learned how to overload operators in C++.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that friend functions and classes should be used sparingly and
    with caution. They are not meant to provide a blatant means to go around access
    regions. Instead, they are meant to handle programming situations to allow access
    between two tightly coupled classes without providing the alternative of an *overly
    public* interface in either of those classes, which could be misused on a broader
    scale.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to overload operators in C++ using operator functions, both
    as member and non-member functions. We have learned that overloading operators
    will allow us to extend the meaning of C++ operators to include user defined types
    in the same way they encompass standard types. We have also seen that in some
    cases, friend functions or classes may come in handy to help implement operator
    functions so they may behave associatively.
  prefs: []
  type: TYPE_NORMAL
- en: We have added important features to our C++ repertoire through exploring friends
    and operator overloading, the latter of which will help us to ensure code we will
    soon write using templates can be used for nearly any data type, contributing
    to highly extensible and reusable code. We are now ready to move forward to [*Chapter
    13*](B15702_13_Final_NM_ePub.xhtml#_idTextAnchor486), *Working with Templates*,
    so that we can continue expanding our C++ programming skills with essential language
    features that will make us better programmers. Let's move ahead!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Overload `operator=` in your `Shape` exercise from [*Chapter 8*](B15702_08_Final_NM_ePub.xhtml#_idTextAnchor335),
    *Mastering Abstract Classes*, or alternatively, overload `operator=` in your on-going
    `LifeForm`/`Person`/`Student` classes as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a. Define `operator=` in `Shape` (or `LifeForm`) and override this method in
    all of its derived classes. Hint: the derived implementation of `operator=()`
    will do more work than its ancestor, yet could call its ancestor''s implementation
    to perform the base class part of the work.'
  prefs: []
  type: TYPE_NORMAL
- en: Overload `operator<<` in your `Shape` class (or `LifeForm` class) to print information
    about each `Shape` (or `LifeForm`). The arguments to this function should be `ostream
    &` and `Shape &` (or `LifeForm &`). Note that `ostream` is from the C++ standard
    library (`using namespace std;`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. You may either provide one function, `ostream &operator<<(ostream &, Shape
    &);`, and from it call a polymorphic, `Print()`, which is defined in `Shape` and
    redefined in each derived class), or provide multiple `operator<<` methods to
    implement this functionality (one for each derived class). If using the `Lifeform`
    hierarchy, substitute `LifeForm` for `Shape`, above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `ArrayInt` class to provide safe integer arrays with bounds checking.
    Overload `operator[]` to return an element if it exists in the array, or throw
    an exception if it is `OutOfBounds`. Add other methods to your `ArrayInt`, such
    as `Resize()`, and `RemoveElement()`. Model the data comprising the array using
    a dynamically allocated array (that is, using `int *contents`) so that you can
    easily handle resizing. The code would begin as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE

- en: '*Chapter 14*: Understanding STL Basics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will continue our pursuit of increasing your C++ programming repertoire
    beyond OOP concepts, by delving into a core C++ library that has become thoroughly
    integrated into the common usage of the language. We will explore the **Standard
    Template Library** (**STL**) in C++ by examining a subset of this library, representing
    common utilities that can both simplify our programming and make our code more
    easily understood by others who are undoubtedly familiar with the STL.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Surveying the contents and purpose of the STL in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Understanding how to use essential STL containers: `list`, `iterator`, `vector`,
    `deque`, `stack`, `queue`, `priority_queue`, `map`, and `map` using a functor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing STL containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to utilize core STL classes to
    enhance your programming skills. Because you already understand the essential
    C++ language and OOP features on which libraries are built, you will see that
    you now have the ability to navigate and understand nearly any C++ class library,
    including the STL. By gaining familiarity with the STL, you will be able to enhance
    your programming repertoire significantly and become a more savvy and valuable
    programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Let's increase our C++ toolkit by examining a very heavily utilized class library,
    the STL.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for the full program examples can be found at the following GitHub
    URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter14` in a file named `Chp14-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3ch15A5](https://bit.ly/3ch15A5).'
  prefs: []
  type: TYPE_NORMAL
- en: Surveying the contents and purpose of the STL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Standard Template Library** in C++ is a library of standard classes and
    utilities that extend the C++ language. The use of the STL is so pervasive that
    it is as though the STL is a part of the language itself; it is an essential and
    integral part of C++. The STL in C++ has four key components comprising the library:
    **containers**, **iterators**, **functions**, and **algorithms**.'
  prefs: []
  type: TYPE_NORMAL
- en: The STL has additionally influenced the C++ Standard Library in providing a
    set of programming standards; the two libraries actually share common features
    and components, most notably containers and iterators. We've already utilized
    components from the Standard Library, namely `<iostream>` for iostreams, `<exception>`
    for exception handling, and `<new>` for the operators `new()` and `delete()`.
    In this chapter, we will explore many overlapping components between the STL and
    the Standard Library in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'The STL has a full line of **container** classes. These classes encapsulate
    traditional data structures to allow similar items to be collected together and
    uniformly processed. There are several categories of container classes – sequential,
    associative, and unordered. Let''s summarize these categories and provide a few
    examples of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '`list`, `queue`, or `stack`. It is interesting to note that `queue` and `stack`
    can be thought of as a customized, or an adaptive interface for a more basic container,
    such as a `list`. Nonetheless, a `queue` and `stack` still provide sequential
    access to their elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set` or `map`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unordered_set` or `unordered_map`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order for these container classes to be potentially used for any data type
    (and to preserve strong type checking), templates are utilized to abstract and
    genericize the data types of the collected items. In fact, we have built our own
    container classes using templates in [*Chapter 13*](B15702_13_Final_NM_ePub.xhtml#_idTextAnchor486),
    *Working with Templates*, including `LinkList` and `Array`, so we already have
    a basic understanding of templatized container classes!
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the STL provides a full complement of **iterators** that allow
    us to *walk through* or traverse containers. Iterators keep track of our current
    place without corrupting the content or ordering of the respective collections
    of objects. We will see how iterators allow us to process container classes more
    safely within the STL.
  prefs: []
  type: TYPE_NORMAL
- en: The STL also contains a plentiful supply of useful **algorithms**. Examples
    include sorting, counting the number of elements in a collection that may satisfy
    a condition, searching for particular elements or subsequences within elements,
    or copying elements in a variety of manners. Additional examples of algorithms
    include modifying a sequence of objects (replacing, swapping, and removing values),
    partitioning sets into ranges, or merging sets back together. Moreover, the STL
    contains many other useful algorithms and utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the STL includes functions. Actually, it would be more correct to say
    that the STL includes `operator()` (the function call operator), and by doing
    so, allow us to achieve parameterized flexibility through a function pointer.
    Though this is not an elementary feature of the STL we will immediately (or often)
    use, we will see one small, simple example of a functor in this chapter coupled
    with an STL container class, in the upcoming section *Examining STL map using
    a functor*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the container class section of the STL. Though
    we won't examine every STL container class in the STL, we will review a healthy
    assortment of these classes. We will notice that some of these container classes
    are similar to classes that we have built together in previous chapters of this
    book. Incidentally, during the incremental chapter progressions of this book,
    we have also built up our C++ language and OOP skills, which are necessary to
    decode a C++ class library such as STL.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move forward to take a look at selective STL classes and test our C++
    knowledge as we interpret each class.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to use essential STL containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will put our C++ skills to the test, decoding various STL
    container classes. We will see that the language features we have mastered from
    core C++ syntax to OOP skills have put us in a position to easily interpret the
    various components of STL we will now examine. Most notably, we will put our knowledge
    of templates to use! Our knowledge of encapsulation and inheritance, for example,
    will guide us to understand how to use various methods in STL classes. However,
    we will notice that virtual functions and abstract classes are extremely rare
    in the STL. The best way to gain competence with a new class within the STL will
    be to embrace the documentation detailing each class. With knowledge of C++, we
    can easily navigate through a given class to decode how to use it successfully.
  prefs: []
  type: TYPE_NORMAL
- en: The container classes in the C++ STL implement various `list`, `iterator`, `vector`,
    `deque`, `stack`, `queue`, `priority_queue`, and `map`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by examining how to utilize a very basic STL container, `list`.
  prefs: []
  type: TYPE_NORMAL
- en: Using STL list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The STL `list` class encapsulates the data structures necessary to implement
    a linked list. We can say that `list` implements the Abstract Data Type of a linked
    list. Recall, we have made our own linked list through creating `LinkedListElement`
    and `LinkedList` classes in [*Chapter 6*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262),
    *Implementing Hierarchies with Inheritance*. STL `list` allows the easy insertion,
    deletion, and sorting of elements. Direct access to individual elements (known
    as *random access*) is not supported. Rather, one must iteratively traverse past
    a prior item in the linked list until one reaches the desired item. A `list` is
    a good example of a sequential container.
  prefs: []
  type: TYPE_NORMAL
- en: The STL `list` class has an assortment of member functions; we'll start by taking
    a look at a few popular methods in this example to get familiar with basic STL
    container class usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at how we can utilize the STL `list` class. This example
    can be found, as a full working program with the necessary class definitions,
    in our GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's examine the aforementioned program segment, where we create and utilize
    an STL `list`. First, we `#include <list>` to include the appropriate STL header
    file. Now, in `main()`, we can instantiate a list using `list<Student> studentBody;`.
    Our list will contain `Student` instances. Then we create `Student s1` on the
    stack and `Student *s2` on the heap using an allocation with `new()`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use `list::push_back()` to add both `s1` and `*s2` to the list. Notice
    that we are passing objects to `push_back()`. As we add `Student` instances to
    the `studentBody` list, the list will make copies of the objects internally and
    will properly clean up these objects when they are no longer members of the list.
    We need to keep in mind that if any of our instances have been allocated on the
    heap, such as `*s2`, we must delete our copy of that instance when we are done
    with it at the end of `main()`. Looking ahead to the end of `main()`, we can see
    that we appropriately `delete s2;`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add three more students to the list. These `Student` instances do not
    have local identifiers. These students are instantiated within the call to `push_back()`,
    for example, `studentBody.push_back(Student("Hana", "Sato", 'U', "Dr.", 3.8, "C++",
    "178PSU"));`. Here, we are instantiating an *anonymous (stack) object*, which
    will be properly popped off the stack and destructed once the call to `push_back()`
    concludes. Keep in mind, `push_back()` will also create its own local copy for
    these instances for their life expectancy within the `list`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in a `while` loop, we repeatedly check if the list is `empty()` and if
    not, we examine the `front()` item and call our `Student::Print()` method. We
    then use `pop_front()` to remove that item from the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have deciphered a simple STL `list` class, let us move forward to
    understand the idea of an `iterator`, to complement a container, such as our `list`.
  prefs: []
  type: TYPE_NORMAL
- en: Using STL iterator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quite often, we will need a non-destructive way to iterate through a collection
    of objects. For example, it is important to maintain the first, last, and current
    position in a given container, especially if the set may be accessed by more than
    one method, class, or thread. Using an **iterator**, the STL provides a common
    means to traverse any container class.
  prefs: []
  type: TYPE_NORMAL
- en: Using iterators has definite benefits. A class can create an `iterator` that
    points to the first member in a collection. Iterators can then be moved to successive
    next members of the collection. Iterators can provide access to elements pointed
    to by the `iterator`.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the state information of a container can be maintained by an `iterator`.
    Iterators provide a safe means for interleaved access by abstracting the state
    information away from the container and instead into the iterator class.
  prefs: []
  type: TYPE_NORMAL
- en: We can think of an `iterator`, you may unintentionally modify a container without
    another user's knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we can utilize an STL `iterator`. This example can
    be found, as a complete program, in our GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at our previously defined code segment. Here, we include both
    the `<list>` and `<iterator>` headers from the STL. As in our previous `main()`
    function, we instantiate a `list` that can contain `Student` instances using `list<Student>
    studentbody;`. We then instantiate several `Student` instances and add them to
    the list using `push_back()`. Again, notice that several `Student` instances are
    *anonymous objects*, having no local identifier in `main()`. These instances will
    be popped off the stack when `push_back()` completes. This is no problem, as `push_back()`
    will create local copies for the list.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can sort the list using `studentBody.sort();`. It is important to note
    that this `list` method required us to overload `operator<` to provide a means
    of comparison between two `Student` instances. Luckily, we have! We have chosen
    to implement `operator<` by comparing `gpa`, but it could also have used `studentId`
    for comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a `list`, we can create an `iterator` and establish it to refer
    to the first item of the `list`. We do so by declaring `list <Student>::iterator
    listIter = studentBody.begin();`. With the `iterator` established, we can use
    it to safely loop through the `list` from start (as it is initialized) to `end()`.
    We assign a local reference variable, `temp`, to the loop iteration's current
    first element in the list with `Student &temp = *listIter;`. We then print this
    instance using `temp.Print();`, and then we increment our iterator by one element
    using `listIter++;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the sorted output for this program (sorted by `gpa`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen an `iterator` class in action, let's investigate a variety
    of additional STL container classes, starting with a `vector`.
  prefs: []
  type: TYPE_NORMAL
- en: Using STL vector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The STL `vector` class implements the Abstract Data Type of a dynamic array.
    Recall, we have made our own dynamic array by creating an `Array` class in [*Chapter
    13*](B15702_13_Final_NM_ePub.xhtml#_idTextAnchor486), *Working with Templates*.
    The STL version, however, will be far more extensive.
  prefs: []
  type: TYPE_NORMAL
- en: The `vector` (dynamic or resizable array) will expand as necessary to accommodate
    additional elements beyond its initial size. Class `vector` allows direct (that
    is, *random access*) to elements by overloading `operator[]`. A `vector` allows
    elements to be accessed in constant time through direct access. It is not necessary
    to walk past all prior elements to access an element at a specific index.
  prefs: []
  type: TYPE_NORMAL
- en: However, adding elements in the middle of a `vector` is time-consuming. That
    is, adding to anywhere other than the end of the `vector` requires all elements
    past the insertion point to be internally shuffled; it may also require an internal
    resizing of the `vector`.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, a `list` and a `vector`, by comparison, have different strengths and
    weaknesses. Each is geared to different requirements of a collection of data.
    We can choose the one that best fits our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an assortment of common `vector` member functions. This
    is far from a complete list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_14.1_B15702.jpg)'
  prefs: []
  type: TYPE_IMG
- en: STL `vector` additionally has an overloaded `operator=` (assignment replaces
    destination vector with source vector), `operator==` (comparison of vectors, element
    by element), and `operator[]` (returns a reference to a requested location, that
    is, writable memory).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we can utilize the STL `vector` class with some of
    its basic operations. This example can be found, as a full working program, in
    our GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex3.cpp):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the previously listed code segment, we `#include <vector>` to include the
    appropriate STL header file. Now, in `main()`, we can instantiate two vectors
    using `vector<Student> studentBody1, studentBody2;`. We can then use the `vector::push_back()`
    method to add several `Student` instances in succession to our first `vector`.
    Again, notice that the `Student` instances are *anonymous objects* in `main()`.
    That is, there is no local identifier that references them – they are created
    only to be placed into our `vector`, which makes a local copy of each instance
    upon insertion. Once we have elements in our `vector`, we then loop through our
    first `vector`, printing each `Student` using `studentBody1[i].Print();`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we demonstrate the overloaded assignment operator for `vector` by assigning
    one `vector` to another using `studentBody1 = studentBody2;`. Here, we make a
    deep copy from right to left in the assignment. We can then test whether the two
    vectors are equal using the overloaded comparison operator within a conditional
    statement. That is, `if (studentBody1 == studentBody2)`. We then print out the
    contents of the second vector in a `for` loop using an iterator specified with
    `auto iter = studentBody2.begin();`. The `auto` keyword allows the type of the
    iterator to be determined by its initial usage. Finally, we look through our first
    `vector`, testing if it is `empty()`, and then clear an element one by one using
    `studentBody1.clear();`. We have now seen a sampling of the `vector` methods and
    their capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's investigate the STL `deque` class to further our knowledge of STL
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: Using STL deque
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The STL `deque` class (pronounced *deck*) implements the Abstract Data Type
    of a double-ended queue. This ADT extends the notion that a queue is first in,
    first out. Instead, the `deque` allows greater flexibility. Adding elements at
    either end of the `deque` is quick. Adding elements in the middle of the `deque`
    is time-consuming. A `deque` is a sequential container, though more flexible than
    our `list`.
  prefs: []
  type: TYPE_NORMAL
- en: You might imagine that a `deque` is a specialization of a `queue`; it is not.
    Instead, the flexible `deque` class will serve as a basis to implement other container
    classes, which we will see shortly. In these cases, private inheritance will allow
    us to conceal `deque` as an underlying implementation (with vast functionality)
    for more restrictive, specialized classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an assortment of common `deque` member functions. This
    is far from a complete list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_14.2_B15702.jpg)'
  prefs: []
  type: TYPE_IMG
- en: STL `deque` additionally has an overloaded `operator=` (assignment of the source
    to destination deque) and `operator[]` (returns a reference to requested location
    – writable memory).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we can utilize the STL `deque` class. This example
    can be found, as a full working program, in our GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex4.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex4.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the previously listed code segment, we `#include <deque>` to include the
    appropriate STL header file. Now, in `main()`, we can instantiate a `deque` to
    contain `Student` instances using `deque<Student> studentBody;`. We then call
    either `deque::push_back()` or `deque::push_front()` to add several `Student`
    instances (some anonymous objects) to our `deque`. We are getting the hang of
    this! Now, we insert a `Student` past the front of our deck using `studentBody.insert(studentBody.begin()
    + 1, Student("Anne", "Brennan", 'B', "Ms.", 3.9, "C++", "299CU"));`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we take advantage of the overloaded `operator[]` to insert a `Student`
    into our `deque` using `studentBody[0] = s1;`. Please be warned that `operator[]`
    does not do any bounds checking on our `deque`! In this statement, we insert `Student`
    `s1` into the ![](img/B15702_14_002.png) position in the `deque`, instead of the
    `Student` that once occupied that position. A safer bet is to use the `deque::at()`
    method, which will incorporate bounds checking. Regarding the aforementioned assignment,
    we also want to ensure that `operator=` has been overloaded for both `Person`
    and `Student`, as each class has dynamically allocated data members.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we loop through until our `deque` is `empty()`, extracting and printing
    the front `element` of the deque using `studentBody.front().Print();`. With each
    iteration we also pop the front item from our `deque` using `studentBody.pop_front();`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a feel for a `deque`, let's next investigate the STL `stack`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Using STL stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The STL `stack` class implements the Abstract Data Type of a stack. The stack
    ADT supports the `stack` includes a public interface that does not advertise its
    underlying implementation. After all, a `stack` might change its implementation;
    the ADT's usage should not depend in any manner on its underlying implementation.
    The STL `stack` is considered an adaptive interface of a basic sequential container.
  prefs: []
  type: TYPE_NORMAL
- en: Recall, we have made our own `Stack` class in [*Chapter 6*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262),
    *Implementing Hierarchies with Inheritance*, using a private base class of `LinkedList`.
    The STL version will be more extensive; interestingly, it is implemented using
    `deque` as its underlying private base class. With `deque` as a private base class
    of the STL `stack`, the more versatile underlying capabilities of `deque` are
    hidden; only the applicable methods are used to implement the stack's public interface.
    Also, because the means of implementation is hidden, a `stack` may be implemented
    using another container class at a later date without impacting its usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an assortment of common `stack` member functions. This
    is far from a complete list. It is important to note that the public interface
    for `stack` is far smaller than that of its private base class, `deque`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_14.5_B15702.jpg)'
  prefs: []
  type: TYPE_IMG
- en: STL `stack` additionally has an overloaded `operator=` (assignment of the source
    to destination stack), `operator==` and `operator!=` (equality/inequality of two
    stacks), and `operator<` , `operator>`, `operator<=`, and `operator >=` (comparison
    of stacks).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we can utilize the STL `stack` class. This example
    can be found, as a full working program, in our GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex5.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex5.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned code segment, we `#include <stack>` to include the appropriate
    STL header file. Now, in `main()`, we can instantiate a `stack` to contain `Student`
    instances using `stack<Student> studentBody;`. We then call `stack::push()` to
    add several `Student` instances to our `stack`. Notice that we are using the traditional
    `push()` method, which contributes to the ADT of a stack.
  prefs: []
  type: TYPE_NORMAL
- en: We then loop through our `stack` while it is not `empty()`. Our goal is to access
    and print the top element using `studentBody.top().Print();`. We then neatly pop
    our top element off the stack using `studentBody.pop();`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's investigate the STL `queue` class to further increase our STL container
    repertoire.
  prefs: []
  type: TYPE_NORMAL
- en: Using STL queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The STL `queue` class implements the ADT of a queue. As the stereotypical queue
    class, STL's `queue` supports **FIFO** (**first in, first out**) order of insertion
    and removal of members.
  prefs: []
  type: TYPE_NORMAL
- en: Recall, we made our own `Queue` class in [*Chapter 6*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262)*,
    Implementing Hierarchies with Inheritance*; we derived our `Queue` from our `LinkedList`
    class using private inheritance. The STL version will be more extensive; STL `queue`
    is implemented using `deque` as its underlying implementation (also using private
    inheritance). Remember, because the means of implementation are hidden with private
    inheritance, a `queue` may be implemented using another data type at a later date
    without impacting its public interface. An STL `queue` is another example of an
    adaptive interface for a basic sequential container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an assortment of common `queue` member functions. This
    is far from a complete list. It is important to note that the public interface
    of `queue` is far smaller than that of its private base class, `deque`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_14.6_B15702.jpg)'
  prefs: []
  type: TYPE_IMG
- en: STL `queue` additionally has an overloaded `operator=` (assignment of the source
    to destination queue), `operator==` and `operator!=` (equality/inequality of two
    queues), and `operator<` , `operator>`, `operator<=`, and `operator >=` (comparison
    of queues).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we can utilize the STL `queue` class. This example
    can be found, as a full working program, in our GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex6.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex6.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code segment, we first `#include <queue>` to include the appropriate
    STL header file. Now, in `main()`, we can instantiate a `queue` to contain `Student`
    instances using `queue<Student> studentBody;`. We then call `queue::push()` to
    add several `Student` instances to our `queue`. Recall, with the queue ADT, `push()`
    implies that we are adding an element at the end of the queue; some programmers
    prefer the term *enqueue* to describe this operation; however, the STL has selected
    to name this operation `push()`. With the queue ADT, `pop()` will remove an item
    from the front of the queue. A better term is *dequeue*; however, that is not
    what STL has chosen. We can adapt.
  prefs: []
  type: TYPE_NORMAL
- en: We then loop through our `queue` while it is not `empty()`. Our goal is to access
    and print the front element using `studentBody.front().Print();`. We then neatly
    pop our front element off the `queue` using `studentBody.pop();`. Our work is
    complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have tried a `queue`, let's investigate the STL `priority_queue`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Using STL priority queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The STL `priority_queue` class implements the Abstract Data Type of a priority
    queue. The priority queue ADT supports a modified FIFO order of insertion and
    removal of members, such that elements are *weighted*. The front element is of
    the largest value (determined by the overloaded `operator<`) and the rest of the
    elements follow in sequence from the next greatest to the least. STL `priority_queue`
    is considered an adaptive interface for a sequential container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall, we implemented our own `PriorityQueue` class in [*Chapter 6*](B15702_06_Final_NM_ePub.xhtml#_idTextAnchor262),
    *Implementing Hierarchies with Inheritance*. We used public inheritance to allow
    our `PriorityQueue` to specialize our `Queue` class, adding additional methods
    to support the priority (weighted) enqueuing scheme. The underlying implementation
    of `Queue` (with the private base class `LinkedList`) was hidden. By using public
    inheritance, we allowed our `PriorityQueue` to be able to be generalized as a
    `Queue` through upcasting (which we understood once we learned about polymorphism
    and virtual functions in [*Chapter 7*](B15702_07_Final_NM_ePub.xhtml#_idTextAnchor298),
    *Utilizing Dynamic Binding through Polymorphism*). We made an acceptable design
    choice: *PriorityQueue Is-A* (specialization of) *Queue* and at times may be treated
    in its more general form. We also recall that neither a `Queue` nor a `PriorityQueue`
    could be upcast to their underlying implementation of a `LinkedList`, as `Queue`
    was derived privately from `LinkedList`; we cannot upcast past a non-public inheritance
    boundary.'
  prefs: []
  type: TYPE_NORMAL
- en: Contrastingly, the STL version of `priority_queue` is implemented using the
    STL `vector` as its underlying implementation. Recall, because the means of implementation
    is hidden, a `priority_queue` may be implemented using another data type at a
    later date without impacting its public interface.
  prefs: []
  type: TYPE_NORMAL
- en: The STL `priority_queue` allows inspection, but not a modification, of the top
    element. The STL `priority_queue` does not allow insertion through its elements.
    That is, elements may only be added resulting in an order from greatest to least.
    Accordingly, the top element may be inspected, and the top element may be removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an assortment of common `priority_queue` member functions.
    This is not a complete list. It is important to note that the public interface
    of `priority_queue` is far smaller than that of its private base class, `vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_14.7_B15702.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unlike the previously examined container classes, the STL `priority_queue` does
    not overload operators, including `operator=`, `operator==`, and `operator<`.
  prefs: []
  type: TYPE_NORMAL
- en: The most interesting method of `priority_queue` is that of `void emplace(args);`.
    This is the member function that allows the priority enqueuing mechanism to add
    items to this ADT. We also notice that `top()` must be used to return the top
    element (versus `front()`, which a `queue` utilizes). But then again, an STL `priority_queue`
    is not implemented using a `queue`). To utilize `priority_queue`, we `#include
    <queue>`, just as we would for a `queue`.
  prefs: []
  type: TYPE_NORMAL
- en: Because the usage of `priority_queue` is so similar to `queue`, we will instead
    explore it further, programming-wise, in our question set at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen many examples of sequential container types in STL (including
    adaptive interfaces), let's next investigate the STL `map` class, an associative
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Examining STL map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The STL `map` class implements the Abstract Data Type of a hash table. The class
    `map` allows elements in the hash table or map to be stored and retrieved quickly
    using a `multimap` can be used instead should there be more than one piece of
    data that needs to be associated with a single key.
  prefs: []
  type: TYPE_NORMAL
- en: Hash tables (maps) are fast for the storage and lookup of data. The performance
    is a guaranteed *O(log(n))*. The STL `map` is considered an associative container,
    as it associates a key to a value to quickly retrieve a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an assortment of common `map` member functions. This
    is not a complete list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_14.8_B15702.jpg)'
  prefs: []
  type: TYPE_IMG
- en: STL `map` additionally has the overloaded operator `operator==` (comparison
    of maps, element by element), implemented as a global function. STL `map` also
    has overloaded `operator[]` (returns a reference to the map element associated
    with the key that is used as an index; this is writable memory).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we can utilize the STL `map` class. This example
    can be found, as a full working program, in our GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex7.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex7.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let's examine the preceding code segment. Again, we include the applicable header
    file with `#include <map>`. Next, we instantiate four `Student` instances. We
    will be making a hash table (`map`) of `Student` instances to be indexed by a
    key (which is their `studentId`). Next, we declare a `map` to hold the collection
    of `Student` instances with `map<const char *, Student> studentBody;`. Here, we
    indicate that the association between the key and element will be between a `const
    char *` and a `Student`. We then declare a map iterator with `map<const char *,
    Student>::iterator mapIter;`, using the same data types.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we create three `pair` instances to associate a grouping between each `Student`
    and its key (that is, with their respective `studentId`) using the declaration
    `pair<const char *, Student> studentPair1 (s1.GetStudentId(), s1);`. This may
    seem confusing to read, but let's break this declaration down into its components.
    Here, the instance's data type is `pair<const char *, Student>`, the variable
    name is `studentPair1`, and `(s1.GetStudentId(), s1)` is the arguments passed
    to the specific `pair` instance's constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we simply insert the three `pair` instances into the `map`. An example
    of this insertion is `studentBody.insert(studentPair1);`. We then insert a fourth
    `Student`, `s4`, into the `map` using `map`''s overloaded `operator[]` with the
    following statement: `studentBody[s4.GetStudentId()] = s4;`. Notice that the `studentId`
    is used as the index value in `operator[]`; this value will become the key value
    for the `Student` in the hash table.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we establish the map iterator to the beginning of the `map` and then
    process the `map` while it is not at the `end()`. Within the loop, we set a variable,
    `temp`, to the `pair` at the front of the map, indicated by the map iterator.
    We also set `tempS` as a temporary reference to a `Student` in the `map`, which
    is indicated by `temp.second` (the second value in the current `pair` managed
    by the map iterator). We now can print out each `Student` instance's `studentId`
    (the key) using `temp.first` (the first item in the current `pair`). In the same
    statement, we can then print out each `Student` instance's `firstName` using `temp.second.GetFirstName()`
    (since the `Student` corresponding to the key is the second item in the current
    `pair`). Similarly, we could also use `tempS.GetLastName()` to print a student's
    `lastName`, as `tempS` was previously initialized to the second element in the
    current `pair` at the beginning of each loop iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's take a look at an alternative with an STL `map`, which will introduce
    us to the STL `functor` concept.
  prefs: []
  type: TYPE_NORMAL
- en: Examining STL map using a functor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The STL `map` class has great flexibility, like many STL classes. In our past
    `map` example, we assumed that a means for comparison was present in our `Student`
    class. We had, after all, overloaded `operator<` for two `Student` instances.
    What happens, however, if we cannot revise a class that has not provided this
    overloaded operator and we also choose not to overload `operator<` as an external
    function?
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we may specify a third data type for the template type expansion
    when instantiating a `map` or map iterator. This additional data type will be
    a specific type of class, known as a functor. A `operator()`. It is within the
    overloaded `operator()` that we will provide a means of comparison for the objects
    in question. A functor essentially simulates encapsulating a function pointer
    by overloading `operator()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we might revise our `map` example to utilize a simple
    functor. This example can be found, as a full working program, in our GitHub as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex8.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter14/Chp14-Ex8.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the previously mentioned code fragment, we first introduce a user defined
    type of `comparison`. This can be a `class` or a `struct`. Within this structure
    definition, we have overloaded the function call operator (`operator()`) and provided
    a means of comparison between two `const char *` keys for `Student` instances.
    This comparison will allow `Student` instances to be inserted in an order determined
    by the comparison functor.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we instantiate our `map` and map iterators, we specify as the third
    parameter for the template type expansion our `comparison` type (the functor).
    And neatly embedded within this type is the overloaded function call operator,
    `operator()`, which will provide our needed comparison. The remaining code will
    be similar to our original map program.
  prefs: []
  type: TYPE_NORMAL
- en: Certainly, functors may be used in additional, more advanced ways beyond what
    we have seen here with the container class `map`. Nonetheless, you now have a
    flavor for how a functor can apply to the STL.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to utilize a variety of STL container classes, let's
    consider why we may want to customize an STL class, and how to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing STL containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most classes in C++ can be customized in some fashion, including classes in
    the STL. However, we must be aware of design decisions made within the STL that
    will limit how we may customize these components. Because the STL container classes
    purposely do not include virtual destructors or other virtual functions, we should
    not use specialization via public inheritance to extend these classes. Note that
    C++ will not stop us, but we know from [*Chapter 7*](B15702_07_Final_NM_ePub.xhtml#_idTextAnchor298),
    *Using Dynamic Binding through Polymorphism*, that we should never override non-virtual
    functions. STL's choice to not include virtual destructors and other virtual functions
    to allow further specialization of these classes was a solid design choice made
    long ago when STL containers were crafted.
  prefs: []
  type: TYPE_NORMAL
- en: We could, however, use private or protected inheritance, or the concepts of
    containment or association, to use an STL container class as a building block,
    that is, to hide the underlying implementation of a new class, where the STL provides
    a solid, yet hidden, implementation for the new class. We would simply provide
    our own public interface for the new class and under the hood, delegate the work
    to our underlying implementation (whether that be a private or protected base
    class, or to a contained or associated object).
  prefs: []
  type: TYPE_NORMAL
- en: Extreme care and caution must be taken when extending any template class, including
    those in the STL using private or protected base classes. This caution will also
    apply to containing or associating to other template classes. Template classes
    are generally not compiled (or syntax checked) until an instance of the template
    class with a specific type is created. This means that any derived or wrapper
    classes that are created can only be fully tested when instances of specific types
    are created.
  prefs: []
  type: TYPE_NORMAL
- en: Appropriate overloaded operators will need to be put in place for new classes
    so that these operators will work automatically with customized types. Keep in
    mind that some operator functions, such as `operator=`, are not inherited from
    base to derived class and need to be written with each new class. This is appropriate
    since derived classes will likely have more work to accomplish than found in the
    generalized versions of `operator=`. Remember, if you cannot modify the class
    definition of a class requiring a selected overloaded operator, you must implement
    that operator function as an external function.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to customizing containers, we may also choose to augment an algorithm
    based on an existing algorithm within the STL. In this case, we would use one
    of the many STL functions as part of a new algorithm's underlying implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing classes from existing libraries comes up routinely in programming.
    For example, consider how we extended the Standard Library `exception` class to
    create customized exceptions in [*Chapter 11*](B15702_11_Final_NM_ePub.xhtml#_idTextAnchor417),
    *Handling Exceptions* (though that scenario utilized public inheritance, which
    will not apply to customizing STL classes). Keep in mind that the STL offers a
    very full complement of container classes. Rarely will you find the need to augment
    STL classes – perhaps only with a very domain-specific class need. Nonetheless,
    you now know the caveats involved in customizing STL classes. Remember, care and
    caution must always be used when augmenting a class. We can now see the need to
    employ proper OO component testing for any classes we create.
  prefs: []
  type: TYPE_NORMAL
- en: We have now considered how to potentially customize STL container classes and
    algorithms within our programs. We have also seen quite a few STL container class
    examples in action. Let us now briefly recap these concepts before moving forward
    to our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have furthered our C++ knowledge beyond OOP language features
    to gain familiarity with the C++ Standard Template Library. As this library is
    used so commonly in C++, it is essential that we understand both the scope and
    breadth of the classes it contains. We are now prepared to utilize these useful,
    well-tested classes in our code.
  prefs: []
  type: TYPE_NORMAL
- en: We have looked at quite a few STL examples; by examining selective STL classes,
    we should feel empowered to understand the remainder of the STL (or any C++ library)
    on our own.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to use common and essential STL classes such as `list`, `iterator`,
    `vector`, `deque`, `stack`, `queue`, `priority_queue`, and `map`. We have also
    seen how to utilize a functor in conjunction with a container class. We have been
    reminded that we now have the tools to potentially customize any class, even those
    from class libraries such as STL (through private or protected inheritance) or
    with containment or association.
  prefs: []
  type: TYPE_NORMAL
- en: We have additionally seen through examining selected STL classes that we have
    the skills to understand the remaining depth and breadth of the STL, as well as
    decoding many additional class libraries that are available to us. As we navigate
    the prototypes of each member function, we notice key language concepts such as
    the use of `const`, or that a method returns a reference to an object representing
    writable memory. Each prototype reveals the mechanics for the usage of the new
    class. It is very exciting to have come this far with our programming endeavors!
  prefs: []
  type: TYPE_NORMAL
- en: We have now added additional, useful features to our C++ repertoire through
    browsing the STL in C++. Usage of the STL (to encapsulate traditional data structures)
    will ensure that our code can easily be understood by other programmers who are
    also undoubtedly using the STL. Relying on the well-tested STL for these common
    containers and utilities ensures that our code remains more bug-free.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to continue forward with [*Chapter 15*](B15702_15_Final_NM_ePub.xhtml#_idTextAnchor572),
    *Testing Classes and Components*. We want to complement our C++ programming skills
    with useful OO component testing skills. Testing skills will help us understand
    whether we have created, extended, or augmented classes in a robust fashion. These
    skills will make us better programmers. Let's continue onward!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Replace your template `Array` class from your exercise from [*Chapter 13*](B15702_13_Final_NM_ePub.xhtml#_idTextAnchor486),
    *Working with Templates*, with an STL `vector`. Create a `vector` of `Student`
    instances. Use `vector` operations to insert, retrieve, print, compare, and remove
    objects from the vector. Alternatively, utilize an STL `list`. Use this opportunity
    to utilize the STL documentation to navigate the full set of operations available
    for these classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Consider what operators, if any, you will need to overload. Consider whether
    you will need an `iterator` to provide safe interleaved access to your collection.
  prefs: []
  type: TYPE_NORMAL
- en: b. Create a second `vector` of `Students`. Assign one to another. Print both
    `vectors`.
  prefs: []
  type: TYPE_NORMAL
- en: Modify the `map` from this chapter to index the hash table (map) of `Student`
    instances based on their `lastName`, rather than `studentId`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `queue` example from this chapter to instead utilize `priority_queue`.
    Be sure to make use of the priority enqueueing mechanism `priority_queue::emplace()`
    to add elements into the `priority_queue`. You will also need to utilize `top()`
    instead of `front()`. Note that `priority_queue` can be found in the `<queue>`
    header file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try out an STL algorithm using `sort()`. Be sure to `#include <algorithm>`.
    Sort an array of integers. Keep in mind that many containers have sorting mechanisms
    built in, but native collection types, such as a language-supplied array, will
    not (which is why you should use a basic array of integers).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

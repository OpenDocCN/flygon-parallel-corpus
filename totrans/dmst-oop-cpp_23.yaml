- en: '*Chapter 19*: Using the Singleton Pattern'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will continue our goal to expand your C++ programming skills beyond
    core OOP concepts, with the objective of empowering you to solve recurring types
    of coding conundrums utilizing core design patterns. Utilizing design patterns
    in coding solutions can not only provide refined solutions but contribute to easier
    code maintenance and provide potential opportunities for code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: The next core design pattern that we will learn how to implement effectively
    in C++ is the **Singleton pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Singleton pattern and how it contributes to OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the Singleton pattern in C++ (with a simple versus a paired-class
    approach); using a registry to allow many classes to utilize the Singleton pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the Singleton pattern and how
    it can be used to ensure that only a single instance of a given type can exist.
    Adding an additional core design pattern to your knowledge set will further augment
    your programming skills to help you become a more valuable programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Let's increase our programming skillset by examining another common design pattern,
    the Singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for the full program examples in this chapter can be found at the
    following GitHub URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter19` in a file named `Chp19-Ex1.cpp` in the aforementioned GitHub repo.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3f2dKZb](https://bit.ly/3f2dKZb).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Singleton pattern is a creational design pattern that guarantees only one
    instance will exist for a class embracing this idiom; two or more instances of
    the type can simply not exist simultaneously. A class embracing this pattern is
    known as a **Singleton**.
  prefs: []
  type: TYPE_NORMAL
- en: A Singleton can be implemented using static data members and static methods.
    This means that a Singleton will have a global point of access to the instance
    at hand. This ramification initially seems dangerous; introducing global state
    information into the code is one criticism that has led the Singleton to sometimes
    be considered an anti-pattern. However, with the appropriate use of access regions
    for the static data members defining the Singleton, we can insist that access
    to the Singleton (other than initialization) only use the appropriate static methods
    of the class at hand (and alleviate this potential pattern concern).
  prefs: []
  type: TYPE_NORMAL
- en: Another criticism of the pattern is that it is not thread-safe. There may be
    race conditions to enter the segment of code where the Singleton instance is created.
    Without guaranteeing mutual exclusivity to that critical region of code, the Singleton
    pattern will break, allowing multiple such instances. As such, if multi-threaded
    programming will be employed, so must proper locking mechanisms to protect the
    critical region of code where the Singleton is instantiated. A Singleton (implemented
    using static memory) is stored in shared memory between threads in the same process;
    at times Singletons can be criticized for monopolizing resources.
  prefs: []
  type: TYPE_NORMAL
- en: The Singleton pattern can utilize several techniques for implementation. Each
    manner of implementation will inevitably have benefits and drawbacks. We will
    use a pair of related classes, `Singleton` and `SingletonDestroyer`, to robustly
    fulfill the pattern. Whereas there are more simple, straightforward implementations
    (one of which we will briefly review), the simplest techniques leave the possibility
    that the Singleton will not be adequately destructed. Recall, a destructor may
    include important and necessary activities.
  prefs: []
  type: TYPE_NORMAL
- en: Singletons tend to be long-lived; it is therefore appropriate for a Singleton
    to be destructed just before the application terminates. Many clients may have
    pointers to a Singleton, so that no single client should delete the Singleton.
    We will see that a `Singleton` will be *self-created*, so that it should ideally
    be *self-destructed* (that is, with the help of its `SingletonDestroyer`). As
    such, the paired-class approach, though not as simple, will ensure proper `Singleton`
    destruction. Note that our implementation will also allow the Singleton to be
    directly deleted; this is rare, but our code will also handle this situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Singleton pattern with the paired-class implementation will include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: A **Singleton** class, which represents the core mechanics needed to implement
    the concept of a Singleton.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **SingletonDestroyer** class, which will serve as a helper class to Singleton,
    ensuring that a given Singleton is properly destructed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class derived from the Singleton, representing the class that we want to ensure
    can only create a single instance of its type at a given time. This will be our
    **Target** class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, the Target class may be both derived from Singleton and another
    class, which may represent existing functionality that we would like to specialize
    or simply encompass (that is, *mix-in*). In this case we will multiply inherit
    from an application specific class and the Singleton class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional **Client** classes, which will interact with the Target class(es) to
    fully define the application at hand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, the Singleton may also be implemented within a Target class,
    bundling the class functionalities together in a single class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A true Singleton pattern can be expanded to allow for multiple (discrete), but
    not an undetermined number of instances to be made. This is rare.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will focus on the traditional Singleton pattern that ensures only a single
    instance of a class embracing this pattern will exist at a given time.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move forward to examine first a simple implementation, then our preferred
    paired-class implementation, of the Singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Singleton pattern will be used to ensure that a given class can only instantiate
    a single instance of that class. However, a true Singleton pattern will also have
    expansion capabilities to allow for multiple (but a well-defined number of) instances
    to be made. This unusual and not well-known caveat of the Singleton pattern is
    rare.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with a simple Singleton implementation to understand its limitations.
    We will then progress to the more robust paired-class implementation of the Singleton,
    with the most common pattern goal of only allowing one Target class instantiation
    at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: Using the simple implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To implement a very simple Singleton, we will use a straightforward single-class
    specification for the Singleton itself. We will define a class, known as `Singleton`,
    to encapsulate the pattern. We will ensure that our constructor(s) are private,
    so that they cannot be applied more than once. We will also add a static `instance()`
    method to provide the interface for instantiation of the `Singleton` object. This
    method will ensure that the private construction occurs exactly once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at this straightforward implementation, which can be found
    in our GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19/Chp19-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19/Chp19-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice, in the aforementioned class definition, that we include data member
    `static Singleton *theInstance;` to represent the `Singleton` instance itself.
    Our constructor is private so that it cannot be used multiple times to create
    multiple `Singleton` instances. Instead, we add a `static Singleton *instance()`
    method to create the `Singleton`. Within this method, we check if data member
    `theInstance` is `NULL` and if so, we instantiate the one and only `Singleton`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Outside of the class definition, we see the external variable (and its initialization)
    to support the memory requirements of the static data member with the definition
    of `Singleton *Singleton::theInstance = NULL;`. We also see how, in `main()`,
    we call the static `instance()` method to create a Singleton instance using `Singleton::instance()`.
    The first call to this method will instantiate a `Singleton`, whereas subsequent
    calls to this method will merely return a pointer to the existing `Singleton`
    object. We can verify that the instances are the same by printing the address
    of these objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the output for this simple program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned output, we notice something perhaps unexpected – the destructor
    is not called! What if the destructor had crucial tasks to perform?
  prefs: []
  type: TYPE_NORMAL
- en: Understanding a key deficiency with the simple Singleton implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The destructor is not called for our `Singleton` in the simple implementation
    merely because we have not deleted the dynamically allocated `Singleton` instance
    through either the `s1` or `s2` identifiers. Why not? There clearly may be multiple
    pointers (handles) to a `Singleton` object. Deciding which handle should be responsible
    for removing the `Singleton` is difficult to determine – the handles will minimally
    need to collaborate or employ reference counting.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, a `Singleton` tends to exist for the duration of the application.
    This longevity further suggests that a `Singleton` should be in charge of its
    own destruction. But how? We will soon see an implementation that will allow a
    `Singleton` to control its own destruction with a helper class. With the simple
    implementation, however, we might simply throw our hands in the air and suggest
    that the operating system will reclaim the memory resources when the application
    terminates – including the heap memory for this small `Singleton`. This is true;
    however, what if an important task needs to be completed in the destructor? We
    are running into a limitation within the simple pattern implementation.
  prefs: []
  type: TYPE_NORMAL
- en: If we need the destructor to be called, shall we resort to allowing one of the
    handles to delete the instance using, for example, `delete s1;`? We have previously
    reviewed issues regarding whether to allow any one handle to perform the deletion,
    but let's now additionally examine potential issues within the destructor itself.
    For example, if our destructor hypothetically only includes `delete theInstance;`,
    we will have a recursive function call. That is, calling `delete s1;` will invoke
    the `Singleton` destructor, yet `delete theInstance;` within the destructor body
    will recognize `theInstance` as a `Singleton` type and again call the `Singleton`
    destructor – *recursively*.
  prefs: []
  type: TYPE_NORMAL
- en: Not to worry! Our destructor, as shown, instead manages recursion by first checking
    whether `theInstance` data member is not `NULL`, and then arranges for `temp`
    to point to `theInstance` to save a handle to the instance we need to delete.
    We then make the assignment of `temp->theInstance = NULL;` to prevent recursion
    when we `delete temp;`. Why? Because `delete temp;` will also call the `Singleton`
    destructor. Upon this destructor call, `temp` will bind to `this` and will fail
    the conditional test `if (theInstance != NULL)` on this first recursive function
    call, backing us out of continued recursion. Note that our upcoming implementation
    using a paired-class approach will not have this potential issue.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that in an actual application, we would not create a
    domain-unspecific `Singleton` instance. Rather, we would factor our application
    into the design to employ the pattern. After all, we want to have a `Singleton`
    instance of a meaningful class type. To do so using our simple `Singleton` class
    as a basis, we simply inherit our Target (application-specific) class from `Singleton`.
    The Target class will also have private constructors – ones that accept the arguments
    necessary to adequately instantiate the Target class. We will then move the static
    `instance()` method from `Singleton` to the Target class and ensure that the argument
    list for `instance()` accepts the necessary arguments to pass to a private Target
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, our simple implementation has the inherent design flaw that there
    is no guaranteed proper destruction for the `Singleton` itself. Letting the operating
    system collect the memory when the application terminates does not call the destructor.
    Choosing one of many handles to the `Singleton` to delete the memory, though possible,
    requires coordination and also defeats the usual application of the pattern to
    allow the `Singleton` to live for the duration of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, because we understand the limitation of the simple `Singleton` implementation,
    we will instead move onward to the preferred paired-class implementation of the
    Singleton pattern. The paired-class approach will guarantee proper destruction
    of our `Singleton`, whether the application allows the `Singleton` to be destructed
    just prior to the application's termination through our deliberate class pairing
    (the most frequently encountered situation), or in the rare case that a `Singleton`
    is destroyed prematurely in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Using the more robust paired-class implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To implement the Singleton pattern with a paired-class approach in a nicely
    encapsulated fashion, we will define a Singleton class to purely add the core
    mechanics of creating a single instance. We will name this class `Singleton`.
    We will then add a helper class to `Singleton`, known as `SingletonDestroyer`,
    to ensure that our `Singleton` instance always undergoes proper destruction before
    our application terminates. This pair of classes will be related through aggregation
    and association. More specifically, the `Singleton` class will conceptually contain
    a `SingletonDestroyer` (aggregate), and the `SingletonDestroyer` class will hold
    an association to the (outer) `Singleton` in which it is conceptually embedded.
    Because the implementation of the `Singleton` and `SingletonDestroyer` is through
    static data members, the aggregation is conceptual – static members are stored
    as external variables.
  prefs: []
  type: TYPE_NORMAL
- en: Once these core classes have been defined, we will consider how we may incorporate
    the Singleton pattern into a class hierarchy with which we have familiarity. Let's
    imagine that we would like to implement a class to encapsulate the concept of
    a *president*. Whether it be a president of a nation or the president of a university,
    it is important that there be only one president at a given point in time. `President`
    will be our Target class; `President` is therefore a good candidate to utilize
    our Singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to note that whereas there will only be one president at a
    given point in time, it is possible to replace a president. For example, the term
    of a president in the United States is only four years at a time, with a possible
    re-election for one more term. There may be similar conditions for a university
    president. A president may leave prematurely through resignation, impeachment,
    or death, or may simply leave upon term expiration. Once a sitting president's
    existence is removed, it is then acceptable to instantiate a new, Singleton `President`.
    Hence, our Singleton pattern allows only one Singleton of the Target class at
    a given point in time.
  prefs: []
  type: TYPE_NORMAL
- en: Reflecting on how we may best implement a `President` class, we realize that
    a `President` *Is-A* `Person` and also needs to *mix-in* `Singleton` capabilities.
    With this in mind, we now have our design. `President` will use multiple inheritance
    to extend the concept of `Person` and to mix-in the functionality of a `Singleton`.
  prefs: []
  type: TYPE_NORMAL
- en: Certainly, we could have built a `President` class from scratch, but why do
    so when the `Person` components of the `President` class are represented in a
    well-tested and available class? Also, certainly, we could embed the `Singleton`
    class information into our `President` class, rather than inheriting from a separate
    `Singleton` class. Absolutely, this is also an option. However, our application
    will instead encapsulate each piece of the solution. This will enable easier future
    reuse. Nonetheless, the design choices are many.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the Singleton and the SingletonDestroyer classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a look at the mechanics for our Singleton pattern, starting by
    examining the `Singleton` and `SingletonDestroyer` class definitions. These classes
    work cooperatively to implement the Singleton pattern. This example can be found
    as a complete program in our GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19/Chp19-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19/Chp19-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned code segment, we begin with several forward class declarations,
    such as `class Singleton;`. These declarations allow references to be made to
    these data types before their complete class definitions have been seen by the
    compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's take a look at our `SingletonDestroyer` class definition. This simple
    class contains a private data member, `Singleton *theSingleton;`, which represents
    the association to the `Singleton` that the `SingletonDestroyer` will one day
    be responsible for deallocating (we will examine the destructor definition for
    `SingletonDestroyer` shortly). Notice that our destructor is not virtual as this
    class is not meant to be specialized.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our constructor has a default value of `0` (`NULL`) specified for
    the `Singleton *`, which is an input parameter. `SingletonDestroyer` also contains
    two member functions, `setSingleton()` and `getSingleton()`, which merely provide
    the means to *set* and *get* the associated `Singleton` member.
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that both the use of the copy constructor and the overloaded assignment
    operator in `SingletonDestroyer` have been disallowed using `=delete` in their
    prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we examine the destructor for this class, let''s examine the class definition
    for `Singleton`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The aforementioned `Singleton` class contains protected data member `static
    Singleton *theInstance;`, which will represent a pointer to the one and only instance
    allocated for the class employing the Singleton idiom.
  prefs: []
  type: TYPE_NORMAL
- en: The protected data member `static SingletonDestroyer destroyer`; represents
    a conceptual aggregate or contained member. The containment is truly only conceptual,
    as static data members are not stored within the memory layout for any instance;
    they are instead stored in external memory and *name-mangled* to appear as part
    of the class. This (conceptual) aggregate sub-object, `destroyer`, will be responsible
    for the proper destruction of the `Singleton`. Recall that the `SingletonDestroyer`
    has an association to the one and only `Singleton`, representing the outer object
    in which the `SingletonDestroyer` is conceptually contained. This association
    is how the `SingletonDestroyer` will access the Singleton.
  prefs: []
  type: TYPE_NORMAL
- en: When the memory for the external variable that implements the static data member
    `static SingletonDestroyer destroyer;` goes away at the end of the application,
    the destructor for `SingletonDestroyer` (the static, conceptual, sub-object) will
    be called. This destructor will run `delete theSingleton;`, ensuring that the
    outer `Singleton` object (which was dynamically allocated) will have the appropriate
    destructor sequence run on it. Because the destructor in `Singleton` is protected,
    it is necessary that `SingletonDestructor` is specified as a friend class of `Singleton`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that both uses of the copy constructor and the overloaded assignment
    operator in `Singleton` have been disallowed using `=delete` in their prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: In our implementation, we have assumed that `Singleton` will be mixed-in via
    inheritance to a derived Target class. It will be in the derived class (the one
    that intends to use the Singleton idiom) that we provide the required static `instance()`
    method to create the `Singleton` instance. Note that had `Singleton` been used
    as a standalone class to create Singletons, we would instead add `static Singleton*
    instance()` to the public access region of `Singleton`. We would also then move
    the data members from the protected to the private access region. However, having
    an application-unspecific Singleton is only of use to demonstrate the concept.
    Instead, we will apply the Singleton idiom to an actual type requiring the use
    of this idiom.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our `Singleton` and `SingletonDestroyer` class definitions in place, let''s
    next examine the remaining necessary implementation necessities for these classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned code fragment, let's first notice the two external variable
    definitions that provide the memory to support the two static data members within
    the `Singleton` class – that is, `Singleton *Singleton::theInstance = 0;` and
    `SingletonDestroyer Singleton::destroyer;`. Recall, static data members are not
    stored within any instance of their designated class. Rather, they are stored
    in external variables; these two definitions designate the memory. Notice that
    the data members are both labeled as protected. This means that though we may
    define their outer storage directly in this manner, we may not access these data
    members other than through static member functions of `Singleton`. This will give
    us some peace of mind. Though there is a potential global access point to the
    static data members, their levied protected access region requires appropriate
    static methods of the `Singleton` class to be used to properly manipulate these
    important members.
  prefs: []
  type: TYPE_NORMAL
- en: Next, draw your attention to the destructor for `SingletonDestroyer`. This clever
    destructor first checks whether its association to the `Singleton` for which it
    is responsible is `NULL`. This will be rare and will happen in the very unusual
    situation when a Client released the Singleton object directly with an explicit
    `delete`.
  prefs: []
  type: TYPE_NORMAL
- en: The usual destruction scenario in the `SingletonDestroyer` destructor will be
    the execution of the `else` clause in which the `SingletonDestructor`, as a static
    object, will be responsible for the deletion, and hence destruction, of its paired
    `Singleton`. Remember, there will be a contained `SingletonDestroyer` object within
    the `Singleton`. The memory for this static (conceptual) sub-object will not go
    away until the application is ending. Recall that static memory is not actually
    part of any instance. So, when the `SingletonDestroyer` is destructed, its usual
    case will be to `delete theSingleton;`, which will release its paired Singleton's
    memory, allowing the `Singleton` to be properly destructed.
  prefs: []
  type: TYPE_NORMAL
- en: The driving design decision behind the Singleton pattern is that a Singleton
    is a long-lived object, and its destruction may most often correctly occur near
    the end of the application. The Singleton is responsible for its own inner Target
    object creation such that the Singleton should not be deleted (and hence destructed)
    by a Client. Rather, the preferred mechanism is that the `SingletonDestroyer`,
    when removed as a static object, deletes its paired `Singleton`.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, occasionally there are reasonable scenarios for deleting a `Singleton`
    mid-application. Should a replacement `Singleton` never be created, our `SingletonDestroyer`
    destructor will still work correctly, identifying that its paired `Singleton`
    has already been released. However, it is more likely that our `Singleton` will
    be replaced with another `Singleton` instance somewhere in the application. Recall
    our application example where a president may be impeached, resign, or die, but
    will be replaced by another president. In these cases, it is acceptable for a
    `Singleton` to be deleted directly and a new `Singleton` is then created. In this
    case, the `SingletonDestroyer` will now reference the replacement `Singleton`.
  prefs: []
  type: TYPE_NORMAL
- en: Deriving a Target class from Singleton
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at how we can create our Target class, `President`,
    from `Singleton`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In our aforementioned Target class, `President`, we merely inherit `President`
    from `Person` using public inheritance and then multiply inherit `President` from
    `Singleton` to *mix-in* the `Singleton` mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: We place our constructor in the private access region. Static method `instance()`
    will utilize this constructor internally to create the one and only `Singleton`
    instance permitted, to adhere to the pattern. There is no default constructor
    (unusual) because we do not wish to allow `President` instances to be created
    without their relevant details. Recall, C++ will not link in a default constructor
    if we have provided an alternate constructor interface. As we do not desire copies
    of a `President` or the assignment of a `President` to another potential `President`,
    we have disallowed copies and assignments using the `=delete` specification in
    the prototypes for these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Our destructor for `President` is simple, yet crucial. In the case that our
    `Singleton` object will be deleted explicitly, we prepare by setting `destroyer.setSingleton(NULL);`.
    Recall, `President` inherits the protected `static SingletonDestroyer destroyer;`
    data member. Here, we are setting the destroyer's associated `Singleton` to `NULL`.
    This line of code in our `President` destructor then enables the destructor in
    `SingletonDestroyer` to accurately depend on checking for the unusual case where
    its associated `Singleton` has already been deleted before commencing the usual
    deletion of its `Singleton` counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have defined a static method to provide the creation interface for
    our `President` as a `Singleton` with `static President *instance(const char *,
    const char *, char, const char *);`. In the definition of `instance()`, we first
    check if the inherited, protected data member `Singleton *theInstance` is `NULL`.
    If we have not yet allocated the `Singleton`, we allocate `President` using the
    aforementioned private constructor and assign this newly allocated `President`
    instance to `theInstance`. This is an upcast from `President *` to `Singleton
    *`, which is no problem across a public inheritance boundary. If, however, in
    the `instance()` method, we find that `theInstance` is not `NULL`, we simply return
    a pointer to the previously allocated `Singleton` object. As users will undoubtedly
    want to use this object as a `President` to enjoy the inherited `Person` features,
    we downcast `theInstance` to `President *` for its return value from this method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's consider the logistics of a sample Client in our overall application.
    In its simplest form, our Client will contain a `main()` function to drive the
    application and showcase our Singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing the pattern components together within the Client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s now take a look at our `main()` function to see how our pattern is orchestrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Reviewing our `main()` function in the preceding code, we first allocate a Singleton
    `President` using `President *p1 = President::instance("John", "Adams", 'Q', "President");`.
    We then try to allocate an additional `President` on the next line of code using
    `*p2`. Because we can only have one `Singleton` (a `President` *mixes-in* a `Singleton`),
    a pointer is returned to our existing `President` and stored in `p2`. We verify
    that there is only one `Singleton` by comparing `p1 == p2`; the pointers indeed
    point to the same instance.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we take advantage of using our `President` instance in its intended manner,
    such as by using some of the inherited member functions from `Person`. As an example,
    we invoke `p1->Print();`. Certainly, our `President` class could have added specialized
    functionality that would be appropriate to utilize in our Client as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now, at the end of `main()`, our static object `SingletonDestroyer Singleton::destroyer;`
    will be appropriately destructed before its memory is reclaimed. As we have seen,
    the destructor for `SingletonDestroyer` will (most often) issue a `delete` to
    its associated `Singleton` (which is actually a `President`) using `delete theSingleton;`.
    This will trigger our `President` destructor, `Singleton` destructor, and `Person`
    destructor to each be called and executed (going from most specialized to most
    general sub-objects). As our destructor in `Singleton` is virtual, we are guaranteed
    to start at the proper level for destruction and to include all destructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, we can visualize the creation of the Singleton `President`,
    as well as see that the second `instance()` request for a `President` merely returns
    the existing `President`. We then see the details of the `President` that were
    printed.
  prefs: []
  type: TYPE_NORMAL
- en: Most interestingly, we can see the destruction sequence for the `Singleton`,
    which is driven by the static object reclamation of the `SingletonDestroyer`.
    Through proper deletion of the `Singleton` in the `SingletonDestroyer` destructor,
    we see that `President`, `Singleton`, and `Person` destructors are each invoked
    as they contribute to the complete `President` object.
  prefs: []
  type: TYPE_NORMAL
- en: Examining explicit Singleton deletion and its impact on the SingletonDestroyer
    destructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a look at an alternate version of the Client with an alternate
    `main()` function. Here, we force deletion of our `Singleton`; this is rare. In
    this scenario, our `SingletonDestroyer` will not delete its paired `Singleton`.
    This example can be found as a complete program in our GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19/Chp19-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter19/Chp19-Ex3.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned `main()` function, notice that we explicitly deallocate
    our Singleton `President` using `delete p1;`, versus allowing the instance to
    be reclaimed via static objection deletion as the program ends. Fortunately, we
    have included a test in our `SingletonDestroyer` destructor to let us know if
    the `SingletonDestroyer` must delete its associated `Singleton` or if this deletion
    has already occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the revised output to notice the differences from our
    original `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned output for our revised Client, we can again visualize
    the creation of the Singleton `President`, the *unsuccessful* creation request
    of a second `President`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take note of the destruction sequence and how it differs from our first
    Client. Here, the Singleton `President` is explicitly deallocated. We can see
    the proper deletion of the `President` through the call and execution of the destructors
    in `President`, `Singleton`, and `Person` as each is executed. Now, when the application
    is about to end and the static `SingletonDestroyer` is about to have its memory
    reclaimed, we can visualize the destructor called on the `SingletonDestroyer`.
    However, this destructor no longer will delete its associated `Singleton`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding design advantages and disadvantages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An advantage of the preceding (paired-class) implementation of the Singleton
    pattern (irrespective of which `main()` is employed) is that we have guaranteed
    proper destruction of the `Singleton`. This happens regardless of whether the
    `Singleton` is long-lived and is deleted in its usual fashion by its associated
    `SingletonDestroyer`, or whether it is deleted earlier on in the application directly
    (a rare scenario).
  prefs: []
  type: TYPE_NORMAL
- en: A disadvantage of this implementation is inherited from the concept of the `Singleton`.
    That is, there can only be one derived class of `Singleton` that incorporates
    the specific mechanics of the `Singleton` class. Because we have inherited `President`
    from `Singleton`, we are using the Singleton logistics (namely static data members,
    stored in external variables) for `President` and `President` alone. Should another
    class wish to be derived from `Singleton` to embrace this idiom, the internal
    implementation for the `Singleton` has already been utilized for `President`.
    Ouch! That does not seem fair.
  prefs: []
  type: TYPE_NORMAL
- en: Not to worry! Our design can be easily expanded to accommodate multiple classes
    that wish to use our `Singleton` base class. We will augment our design to accommodate
    multiple `Singleton` objects. We will assume, however, that we still intend to
    have only one `Singleton` instance per class type.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a brief look at how we may expand the Singleton pattern to solve
    this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Using a registry to allow many classes to utilize Singleton
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's more closely examine a shortcoming with our current Singleton pattern
    implementation. Currently, there can only be one derived class of `Singleton`
    that can effectively utilize the `Singleton` class. Why is this? `Singleton` is
    a class that comes with external variable definitions to support the static data
    members within the class. The static data member representing `theInstance` (implemented
    using the external variable `Singleton *Singleton::theInstance`) may only be set
    to one `Singleton` instance. *Not one per class* – there is only one set of external
    variables creating the memory for the crucial `Singleton` data members of `theInstance`
    and `destroyer`. Herein lies the problem.
  prefs: []
  type: TYPE_NORMAL
- en: We can, instead, can specify a `Registry` class to keep track of the classes
    applying the Singleton pattern. There are many implementations for a **Registry**,
    and we will review one such implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In our implementation, `Registry` will be a class that pairs class names (for
    classes employing the Singleton pattern) with `Singleton` pointers to the single
    allowed instance of each registered class. We will still derive each Target class
    from `Singleton` (and from any other class as deemed appropriate by our design).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `instance()` method in each class *derived* from `Singleton` will be revised,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Our first check within `instance()` will be to a call to a `Registry` method
    (with the derived class' name) asking if a `Singleton` had previously been created
    for that class. If the `Registry` method determines a `Singleton` for the requested
    derived type has previously been instantiated, a pointer to the existing instance
    will be returned by `instance()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead, if the `Registry` provides permission to allocate the `Singleton`,
    `instance()` will allocate the `Singleton` much as before, setting the inherited
    protected data member of `theInstance` to the allocated derived `Singleton`. The
    static `instance()` method will also set the backlink through the inherited protected
    destroyer data member using `setSingleton()`. We will then pass the newly instantiated
    derived class instance (which is a `Singleton`) to a `Registry` method to `Store()`
    the newly allocated `Singleton` within the `Registry`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We notice that four pointers to the same `Singleton` will exist. One will be
    the specialized pointer of our derived class type returned from our derived class
    `instance()` method. This pointer will be handed to our Client for application
    usage. The second `Singleton` pointer will be the pointer stored in our inherited,
    protected data member `theInstance`. The third `Singleton` pointer will be the
    pointer stored in the `SingletonDestroyer`. The fourth pointer to the `Singleton`
    will be a pointer that is stored in the `Registry`. No problem, we can have multiple
    pointers to a `Singleton`. This is one reason the `SingletonDestroyer`, used in
    its traditional destruction capacity, is so important – it will destroy our one
    and only `Singleton` for each type at the end of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Registry` will maintain a pair for each class employing the `Singleton`
    pattern, consisting of a class name and the (eventual) pointer to the specific
    `Singleton` for the corresponding class. The pointer to each specific `Singleton`
    instance will be a static data member and will additionally require an external
    variable to garner its underlying memory. The result is one additional external
    variable per class embracing the Singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of the `Registry` can be expanded further still if we choose to additionally
    accommodate the rare use of the Singleton pattern to allow multiple (but a finite
    set of) `Singleton` objects per class type. An example of this extended pattern
    in action might be that we chose to model a high school that has a single principal,
    yet multiple vice-principals. `Principal` would be an expected derived class of
    `Singleton`, yet the multiple vice-principals would represent a fixed number of
    instances of the `Vice-Principal` class (derived from `Singleton`). Our registry
    could be expanded to allow up to `N` registered `Singleton` objects for the `Vice-Principal`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen an implementation of the Singleton pattern using a paired-class
    approach. We have folded the classes and concepts of `Singleton`, `SingetonDestroyer`,
    Target, and Client into the framework of classes we are accustomed to seeing,
    namely `Person`, as well as into a descendant class of our `Singleton` and `Person`
    (`President`). Let's now briefly recap what we have learned relating to patterns
    before moving on to our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have furthered our goal of becoming better C++ programmers
    by expanding our programming repertoire by embracing another design pattern. We
    have explored the Singleton pattern by first employing a simple approach, and
    then a paired-class implementation using `Singleton` and `SingletonDestroyer`.
    Our approach uses inheritance to incorporate our Singleton's implementation into
    our Target class. Optionally, we incorporate a useful, existing base class into
    our Target class using multiple inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Making use of core design patterns, such as the Singleton pattern, will help
    you more easily reuse existing, well-tested portions of code in a manner understood
    by other programmers. By employing familiar design patterns, you will be contributing
    to well-understood and reusable solutions with avant-garde programming techniques.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to continue onward to our final design pattern in [*Chapter
    20*](B15702_20_Final_NM_ePub.xhtml#_idTextAnchor756), *Removing Implementation
    Details Using the pImpl Pattern*. Adding more patterns to our arsenal of programming
    skills makes us more versatile and valued programmers. Let's continue onward!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the Singleton pattern examples found in this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Implement either an interface for a `President` to `Resign()` or implement
    the interface to `Impeach()` a `President`. Your method should delete the current
    Singleton `President` (and remove that link from the `SingletonDestroyer`). `SingletonDestroyer`
    has a `setSingleton()` that may be useful to aid you in removing the backlink.
  prefs: []
  type: TYPE_NORMAL
- en: b. Noting that the former Singleton `President` has been removed, create a new
    `President` using `President::instance()`. Verify that the new `President` has
    been installed.
  prefs: []
  type: TYPE_NORMAL
- en: c. (*Optional*) Create a `Registry` to allow `Singleton` to be used effectively
    in multiple classes (not mutually exclusively, as is the current implementation).
  prefs: []
  type: TYPE_NORMAL
- en: Why can you not label the `static instance()` method as virtual in `Singleton`
    and override it in `President`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What other examples can you imagine that might easily incorporate the Singleton
    pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

- en: Visualizing Metrics and Alerts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is curious how often you humans manage to obtain that which you do not want.
  prefs: []
  type: TYPE_NORMAL
- en: '- *Spock*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dashboards are useless! They are a waste of time. Get Netflix if you want
    to watch something. It''s cheaper than any other option.**'
  prefs: []
  type: TYPE_NORMAL
- en: I repeated those words on many public occasions. I think that companies exaggerate
    the need for dashboards. They spend a lot of effort creating a bunch of graphs
    and put a lot of people in charge of staring at them. As if that's going to help
    anyone. The main advantage of dashboards is that they are colorful and full of
    lines, boxes, and labels. Those properties are always an easy sell to decision
    makers like CTOs and heads of departments. When a software vendor comes to a meeting
    with decision makers with authority to write checks, he knows that there is no
    sale without "pretty colors". It does not matter what that software does, but
    how it looks like. That's why every software company focuses on dashboards.
  prefs: []
  type: TYPE_NORMAL
- en: Think about it. What good is a dashboard for? Are we going to look at graphs
    until a bar reaches a red line indicating that a critical threshold is reached?
    If that's the case, why not create an alert that will trigger under the same conditions
    and stop wasting time staring at screens and waiting until something happens.
    Instead, we can be doing something more useful (like staring Netflix).
  prefs: []
  type: TYPE_NORMAL
- en: Is our "panic criteria" more complex than what can be expressed through alerts?
    I do think that it is more complex. However, that complexity cannot be reflected
    through pre-defined graphs. Sure, unexpected things happen, and we need to dig
    through data. However, the word "unexpected" defies what dashboards provide. They
    are all about the expected outcomes. Otherwise, how are we going to define a graph
    without knowing what to expect? "It can be anything" cannot be translated to a
    graph. Dashboards with graphs are our ways to assume what might go wrong and put
    those assumptions on a screen or, more often than not, on a lot of screens.
  prefs: []
  type: TYPE_NORMAL
- en: However, unexpected can only be explored by querying metrics and going deeper
    and deeper until we find the cause of an issue. That's investigative work that
    does not translate well to dashboards. We use Prometheus queries for that.
  prefs: []
  type: TYPE_NORMAL
- en: And yet, here I am dedicating a chapter to dashboards.
  prefs: []
  type: TYPE_NORMAL
- en: I do admit that dashboards are not (fully) useless. They are useful, sometimes.
    What I truly wanted to convey is that their usefulness is exaggerated and that
    we might require to construct and use dashboards differently than what many are
    used to.
  prefs: []
  type: TYPE_NORMAL
- en: But, I'm jumping ahead of myself. We'll discuss the details of dashboards a
    bit later. For now, we need to create a cluster that will allow us to experiment
    and take this conversation to a more practical level.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `vfarcic/k8s-specs` ([https://github.com/vfarcic/k8s-specs](https://github.com/vfarcic/k8s-specs))
    repository will continue to serve as our source of Kubernetes definitions. We'll
    make sure that it is up-to-date by pulling the latest version.
  prefs: []
  type: TYPE_NORMAL
- en: All the commands from this chapter are available in the `06-grafana.sh` ([https://gist.github.com/vfarcic/b94b3b220aab815946d34af1655733cb](https://gist.github.com/vfarcic/b94b3b220aab815946d34af1655733cb))
    Gist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The requirements are the same as those we had in the previous chapter. For your
    convenience, the Gists are available here as well. Feel free to use them to create
    a new cluster, or to validate that the one you're planning to use meets the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '`gke-instrument.sh`: **GKE** with 3 n1-standard-1 worker nodes, **nginx ****Ingress**,
    **tiller**, **Prometheus** Chart, and environment variables **LB_IP**, **PROM_ADDR**,
    and **AM_ADDR** ([https://gist.github.com/vfarcic/675f4b3ee2c55ee718cf132e71e04c6e](https://gist.github.com/vfarcic/675f4b3ee2c55ee718cf132e71e04c6e)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eks-hpa-custom.sh`: **EKS** with 3 t2.small worker nodes, **nginx Ingress**,
    **tiller**, **Metrics Server**, **Prometheus** Chart, environment variables **LB_IP**,
    **PROM_ADDR**, and **AM_ADDR**, and **Cluster Autoscaler** ([https://gist.github.com/vfarcic/868bf70ac2946458f5485edea1f6fc4c](https://gist.github.com/vfarcic/868bf70ac2946458f5485edea1f6fc4c)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aks-instrument.sh`: **AKS** with 3 Standard_B2s worker nodes, **nginx Ingress**,
    and **tiller**, **Prometheus** Chart, and environment variables **LB_IP**, **PROM_ADDR**,
    and **AM_ADDR** ([https://gist.github.com/vfarcic/65a0d5834c9e20ebf1b99225fba0d339](https://gist.github.com/vfarcic/65a0d5834c9e20ebf1b99225fba0d339)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-instrument.sh`: **Docker for Desktop** with **2 CPUs**, **3 GB RAM**,
    **nginx Ingress**, **tiller**, **Metrics Server**, **Prometheus** Chart, and environment
    variables **LB_IP**, **PROM_ADDR**, and **AM_ADDR** ([https://gist.github.com/vfarcic/1dddcae847e97219ab75f936d93451c2](https://gist.github.com/vfarcic/1dddcae847e97219ab75f936d93451c2)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minikube-instrument.sh`: **minikube** with **2 CPUs**, **3 GB RAM**, **ingress**,
    **storage-provisioner**, **default-storageclass**, and **metrics-server** addons
    enabled, **tiller**, **Prometheus** Chart, and environment variables **LB_IP**,
    **PROM_ADDR**, and **AM_ADDR** ([https://gist.github.com/vfarcic/779fae2ae374cf91a5929070e47bddc8](https://gist.github.com/vfarcic/779fae2ae374cf91a5929070e47bddc8)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which tools should we use for dashboards?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It doesn't take more than a few minutes with Prometheus to discover that it
    is not designed to serve as a dashboard. Sure, you can create graphs in Prometheus
    but they are not permanent, nor do they offer much in terms of presenting data.
    Prometheus' graphs are designed to be used as a way to visualize ad-hoc queries.
    And that's what we need most of the time. When we receive a notification from
    an alert that there is a problem, we usually start our search for the culprit
    by executing the query of the alert and, from there on, we go deeper into data
    depending on the results. That is, if the alert does not reveal the problem immediately,
    in which case there is no need to receive notifications since those types of apparent
    issues can usually be fixed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: But, as I already mentioned, Prometheus' does not have dashboarding features,
    so we'll have to look for a different tool.
  prefs: []
  type: TYPE_NORMAL
- en: These days, the choice of a dashboard is easy. *Grafana* ([https://grafana.com/](https://grafana.com/))
    is the undisputed ruler in the area. Other solutions are too old to bother with,
    or they do not support Prometheus. That is not to say that Grafana is the best
    tool on the market. But the price is right (it's free), and it works with many
    different data sources. We could, for example, argue that *Kibana* ([https://www.elastic.co/products/kibana](https://www.elastic.co/products/kibana))
    is just as good as Grafana, or even better. But, it is limited to data from ElasticSearch.
    While Grafana can also use data from ElasticSearch, it supports many others. Some
    might say that *DataDog* ([https://www.datadoghq.com/](https://www.datadoghq.com/))
    is a better choice. Still, it suffers from the same problem as Kibana. It is tied
    to a specific source of metrics.
  prefs: []
  type: TYPE_NORMAL
- en: There is no flexibility and no option to combine data from other data sources.
    More importantly, neither of the two supports Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: I'll save you from further comparison with other tools. You can try them yourself.
    For now, you'll need to trust me that Grafana is good, if not the best choice.
    If we do not agree on that point, it will be pointless for you to read the rest
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that I enforced Grafana as the choice, we'll move on and install it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and setting up Grafana
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You probably know what's coming next. We Google "Grafana Helm" and hope that
    the community already created a Chart we can use. I'll save you from the search
    by revealing that there is Grafana in Helm's *stable* channel. All we have to
    do is inspect the values and choose which ones we'll use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: I won't go through all the values we could use. I assume that, by now, you are
    a Helm ninja and that you can explore them yourself. Instead, we'll use the values
    I already defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The output is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing special about those values. We enabled Ingress, we set `persistence`,
    and we defined the `resources`. As the name of the file indicates, it's a very
    bare setup without anything fluffy.
  prefs: []
  type: TYPE_NORMAL
- en: All that's left is to install the Chart.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now we can open Grafana in your favorite browser.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You are presented with the login screen. Just as with many other Helm Charts,
    the installation comes with the `admin` user and the password stored as a Secret.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Please go back to the Grafana login screen, type `admin` as the username, and
    paste the output of the previous command as the password.
  prefs: []
  type: TYPE_NORMAL
- en: Grafana does not collect metrics. Instead, it uses other sources of data, so
    our first action is to set Prometheus as the data source.
  prefs: []
  type: TYPE_NORMAL
- en: Please click the Add data source icon.
  prefs: []
  type: TYPE_NORMAL
- en: Type `Prometheus` as the Name and choose it as the Type as well. We'll let Grafana
    connect to it through the Kubernetes Service `prometheus-server`. Since both are
    in the same Namespace, the URL should be set to `http://prometheus-server`. All
    that's left is to Save & Test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The outputs and screenshots in this chapter are taken from Docker for Desktop.
    There might be slight differences between what you see here and what you can observe
    on your screen.![](assets/09055a6f-2b2f-4524-8a89-c197904d9134.png)Figure 6-1:
    Grafana''s new data source screenWe''ll have more screenshots in this chapter
    than usual. I believe that they will help you replicate the steps we''ll discuss.'
  prefs: []
  type: TYPE_NORMAL
- en: Importing and customizing pre-made dashboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data sources are useless by themselves. We need to visualize them somehow. We
    could do that by creating our own dashboard, but that might not be the best (and
    easiest) introduction to Grafana. Instead, we'll import one of the existing community-maintained
    dashboards. We just need to choose one that suits our needs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to spend a bit of time exploring the available dashboards.
  prefs: []
  type: TYPE_NORMAL
- en: I think that *Kubernetes cluster monitoring* ([https://grafana.com/dashboards/3119](https://grafana.com/dashboards/3119))
    dashboard is a good starting point. Let's import it.
  prefs: []
  type: TYPE_NORMAL
- en: Please click the + icon from the left-hand menu, followed with the Import link,
    and you'll be presented with a screen that allows us to import one of the Grafana.com
    dashboards, or to paste JSON that defines it.
  prefs: []
  type: TYPE_NORMAL
- en: We'll go with the former option.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1fc859c6-1c3a-4f74-9196-b1b624a8292f.png)Figure 6-2: Grafana''s
    import dashboard option'
  prefs: []
  type: TYPE_NORMAL
- en: Please type `3119` into the *Grafana.com Dashboard* field, and click the Load
    button. You'll be presented with a few fields. The only important one, in this
    case, is the *prometheus* drop-down list. We must use it to set the data source.
    The choice is easy since we defined only one. Select Prometheus, and click the
    Import button.
  prefs: []
  type: TYPE_NORMAL
- en: What you see in front of you is a dashboard with some of the essential Kubernetes
    metrics.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4059d071-a450-49c1-bf7e-a5ca29798723.png)Figure 6-3: Kubernetes
    cluster monitoring dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: However, some of the graphs might not work. Does that mean that we imported
    a wrong dashboard? A simple answer is quite the opposite. Of all the available
    dashboards, this one probably has the most graphs working. At least, if we count
    only those that are, more or less, useful. Such an outcome is common. Those dashboards
    are maintained by the community, but most of them are made for personal use. They
    are configured to work in specific clusters and to use particular metrics. You
    won't be able to find many dashboards that work without any changes and that,
    at the same time, show the things you truly need. Instead, I consider those dashboards
    a good starting point.
  prefs: []
  type: TYPE_NORMAL
- en: I import them only to get a base that I can modify to serve my specific needs.
    That's what we're going to do next, at least partially.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we'll focus only on the changes aimed at making it fully operational.
    We'll make some of the graphs that are currently without data operational, and
    we'll remove those that are of no use to us.
  prefs: []
  type: TYPE_NORMAL
- en: If we take a closer look at the *Total usage* row, we'll see that *Cluster filesystem
    usage* is *N/A*. There's probably something wrong with the metrics it's using.
    Let's take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: In some clusters (for example, EKS) the hard-coded file system in this dashboard
    is the correct one. If that's the case (if *Cluster filesystem usage* is not *N/A*)
    you do not have to make any changes. However, I suggest you still go through the
    exercise while imagining that your cluster uses a different file system. That
    way you'll learn a few tips that you could apply to other dashboards.
  prefs: []
  type: TYPE_NORMAL
- en: Please press the arrow next to the *Cluster filesystem usage* title, and click
    the Edit link.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b8db47c6-c501-49eb-a072-1fea9b62c391.png)Figure 6-4: Grafana''s
    option to edit a panel'
  prefs: []
  type: TYPE_NORMAL
- en: The query used by that graph (formatted for readability) is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We won't go into the details of that query. You should be familiar with Prometheus
    expressions by now. Instead, we'll focus on the likely cause of the issue. We
    probably do not have filesystem device called `/dev/xvda` (unless you're using
    EKS or, in some cases, GKE). If that's the problem, we can fix the Graph by simply
    changing the value to whatever our device is. But, before we go down that road,
    we might explore Grafana variables. After all, changing one hard-coded value with
    another will do us no good if we do not even know what our device is.
  prefs: []
  type: TYPE_NORMAL
- en: We could go to Prometheus and retrieve the list of all the devices, or we can
    let Grafana do that for us. We'll choose the latter.
  prefs: []
  type: TYPE_NORMAL
- en: Take a closer look at the `kubernetes_io_hostname`. It's set to `^$Node$`. That
    is an example of using Grafana variables. We'll explore them next, in an attempt
    to replace the hard-coded device.
  prefs: []
  type: TYPE_NORMAL
- en: Please click the Back to dashboard button located in the top-right corner of
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Click the *Settings* icon located in the top of the screen. You'll be presented
    with all the dashboard-wide configurations we can change. Feel free to explore
    the options in the left-hand menu.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are interested in creating a new variable that will dynamically populate
    the `device` label of the query, our next action is to click the Variables link
    in the *Settings* section, followed with the + New button.
  prefs: []
  type: TYPE_NORMAL
- en: Please type `device` as the variable Name and `IO Device` as the Label. We will
    retrieve the values from Prometheus (the data source), so we'll leave the Type
    to Query.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to specify the Data source. Select $datasource. That tells Grafana
    that we want to query data from whichever data source we selected when we imported
    the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: So far, everything was probably self-explanatory. What comes next isn't. We
    need to consult the documentation and learn how to write Grafana queries used
    as variable values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let this be an exercise. Find out, through the documentation, how to write a
    query that retrieves all distinct values of the label `device` available in the
    `container_fs_usage_bytes` metric.
  prefs: []
  type: TYPE_NORMAL
- en: Grafana supports only four types of variable queries so I suppose that you did
    not have a hard time finding out that the expression we should add to the Query
    field is `label_values(container_fs_usage_bytes, device)`.
  prefs: []
  type: TYPE_NORMAL
- en: With the query in place, all that's left is to click the Add button.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c8cb3194-277c-4074-8c3e-6d72d9f9476e.png)Figure 6-5: Grafana''s
    screen for creating new dashboard variables'
  prefs: []
  type: TYPE_NORMAL
- en: Now we should go *Back to dashboard* and confirm that the new variable is available.
  prefs: []
  type: TYPE_NORMAL
- en: You should see a new drop-down list with the label *IO Device* at the top-left
    section of the screen. If you expand it, you'll see all the devices used in our
    cluster. Make sure that the correct device is selected. That is likely `/dev/sda1`
    or `/dev/xvda1`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to change the graph to use the variable we just created.
  prefs: []
  type: TYPE_NORMAL
- en: Please click the arrow next to the *Cluster filesystem usage* graph, and select
    edit. The metric (query) contains two hard-coded `^/dev/xvda.$` values. Change
    them to `$device`, and click the Back to dashboard button located in the top-right
    corner of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. The graph now works correctly by showing us the percentage of cluster
    file system usage (`/dev/sda1`).
  prefs: []
  type: TYPE_NORMAL
- en: However, the *Used* and *Total* numbers below it are still *N/A*. I believe
    you know what to do to fix them. Edit those graphs and replace `^/dev/xvda.$`
    with `$device`.
  prefs: []
  type: TYPE_NORMAL
- en: There are still two issues to solve with that dashboard. Or, to be more precise,
    two graphs are useless to us. The purpose of the *System services CPU usage* and
    *System services memory usage* graphs should be deducible from their titles. Yet,
    most Kubernetes clusters do not provide access to system-level services (for example,
    GKE). Even if they do, our Prometheus is not configured to fetch the data. If
    you don't believe me, copy the query of one of those graphs and execute it in
    Prometheus. As it is now, those graphs are only wasting space, so we'll remove
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Please click the *trash* icon next to the title of the *System services CPU
    usage* row. Click Yes to remove both the row and the panel. Repeat the same actions
    for the *System services memory usage* row.
  prefs: []
  type: TYPE_NORMAL
- en: Now we're done with making changes to the dashboard. It is fully operational,
    and we should persist the changes by clicking the *Save dashboard* icon in the
    top-right corner of the screen, or by pressing **CTRL+S**.
  prefs: []
  type: TYPE_NORMAL
- en: We won't go into all the Grafana options and the actions we can do. I'm sure
    that you can figure them out yourself. It is a very intuitive application. Instead,
    we'll try to create our own dashboard. Or, at least, explore a few things that
    will allow you to continue on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom dashboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be great if all our needs could be covered by existing dashboards.
    But, that is probably not the case. Each organization is "special", and our needs
    have to be reflected in our dashboards. Sometimes we can get away with dashboards
    made by others, and sometimes we need to change them. In other cases, we need
    to create our own dashboards. That's what we'll explore next.
  prefs: []
  type: TYPE_NORMAL
- en: Please click the + icon in the left-hand menu and choose to `Create Dashboard`.
    You'll be presented with the choice of a few types of panels. Select `Graph`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we define our first graph, we'll change a few dashboard settings. Please
    click the *Settings* icon in the top-right part of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the *General* section, type the Name of the dashboard. If you are not
    inspired today, you can call it `My Dashboard`. Set the Tags to `Prometheus` and
    `Kubernetes`. You'll have to press the enter key after typing each tag. Finally,
    change the Timezone to Local browser time.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/61df4ee1-02ff-4141-bce7-d38c27e8c7f7.png)Figure 6-6: Grafana''s
    dashboard general settings screen'
  prefs: []
  type: TYPE_NORMAL
- en: That was the boring part. Now let's switch to something more interesting. We
    are about to convert one of the alerts we created in Prometheus into a graph.
    We'll use the one that tells us the percentage of actual vs. reserved CPU. For
    that, we'll need a few variables. To be more precise, we don't really need them
    since we could hard-code the values. But, that would cause problems later on if
    we decide to change them. It is much easier to modify variables than to change
    the queries.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we'll need variables that will tell us what is the minimum CPU
    so that we can ignore the thresholds for the applications that are set to use
    very low reservations. Also, we'll define variables that will act as lower and
    upper boundaries. Our goal is to be notified if reserved CPU is too low or too
    high when compared with the actual usage, just as we did with Prometheus alerts.
  prefs: []
  type: TYPE_NORMAL
- en: Please select the Variables section from the left-hand menu, and click the Add
    Variable button.
  prefs: []
  type: TYPE_NORMAL
- en: You already saw the screen with Grafana variables when we created a new one
    for the dashboard we imported. This time, however, we'll use slightly different
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: Type `minCpu` as the Name and choose Constant as the Type. Unlike the `device`
    variable we created earlier, this time we do not need Grafana to query the values.
    By using that type, we are going to define a constant value. Please set the Value
    *to* `0.005` (five CPU milliseconds). Finally, we do not need to see that variable
    in the dashboard, since the value is not likely to change often. If we do need
    to change it in the future, we can always come back to this screen and update
    it. Therefore, change the Hide value to Variable.
  prefs: []
  type: TYPE_NORMAL
- en: All that's left is to click the Add button, twice.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e0fc3634-99c7-4fb6-9cf9-5b77aa39567f.png)Figure 6-7: Grafana''s
    dashboard new variable screen'
  prefs: []
  type: TYPE_NORMAL
- en: We need two more variables. There's probably no need to repeat the same instructions,
    so please use the following information to create them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now we can go back and define our graph. Please click the *Back to dashboard*
    icon from the top-right part of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: You already know how to edit a panel. Click on the arrow next to *Panel Title*,
    and select Edit.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with the *General* section. Please select it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, write `% of actual vs reserved CPU` as the Title and the text that follows
    as the Description.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Please note the usage of `$minCpu` variable in the description. When we go back
    to the dashboard, it will expand to its value.
  prefs: []
  type: TYPE_NORMAL
- en: Next, please switch to the *Metrics* tab. That's where the real action is happening.
  prefs: []
  type: TYPE_NORMAL
- en: We can define multiple queries but, for our use case, one should be enough.
    Please type the query that follows in the field to the right of *A*.
  prefs: []
  type: TYPE_NORMAL
- en: For your convenience, the query is available in the `grafana-actual-vs-reserved-cpu`
    ([https://gist.github.com/vfarcic/1b027a1e2b2415e1d156687c1cf14012](https://gist.github.com/vfarcic/1b027a1e2b2415e1d156687c1cf14012))
    Gist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: That query is almost the same as one of those we used in the [Chapter 3](13a73b25-73b2-4775-bd32-7945c7a25e46.xhtml),
    *Collecting and Querying Metrics and Sending Alerts*. The only difference is the
    usage of the `$minCpu` variable.
  prefs: []
  type: TYPE_NORMAL
- en: A few moments after entering the query, we should see the graph come alive.
    There is probably only one Pod included since many of our applications are defined
    to use five CPU milliseconds (the value of `$minCpu`), or less.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3a7042c2-ba76-4ad8-904d-ef3d72c99c47.png)Figure 6-8: Grafana''s
    panel based on a graph'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll adjust the units on the left side of the graph. Please click the
    Axes tab.
  prefs: []
  type: TYPE_NORMAL
- en: Expand the *Left Y Unit*, select none, followed with percent (0.0-1.0). Since
    we're not using the *Right Y* axis, please uncheck the *Show* checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: The next section in line is *Legend*. Please select it.
  prefs: []
  type: TYPE_NORMAL
- en: Check the *Options As Table*, *Options To the right*, and *Values > Current*
    checkboxes. The changes are applied to the graph immediately, and you should not
    have trouble deducing what each of those does.
  prefs: []
  type: TYPE_NORMAL
- en: There's only one more thing missing. We should define upper and lower thresholds
    that will provide a clear indication that the results are outside expected boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Please click the Alert tab.
  prefs: []
  type: TYPE_NORMAL
- en: Click the Create Alert button and change the IS ABOVE condition to IS OUTSIDE
    RANGE. Set the values of the next two fields to `0,5` and `1,5`. That should notify
    is if the actual CPU usage is below 50% or above 150% when compared to the reserved
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/460539bf-a465-4596-a883-26a441295b05.png)Figure 6-9: Grafana''s
    graph with alerts'
  prefs: []
  type: TYPE_NORMAL
- en: We're done with the graph, so please go *Back to dashboard* and enjoy "pretty
    colors". You might want to drag the bottom-right corner of the graph to adjust
    its size.
  prefs: []
  type: TYPE_NORMAL
- en: We can see the difference between the requested and the actual CPU usage. We
    also have the thresholds (marked in red) that will tell us whether the usage goes
    outside the established boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Now comes the big question. Is such a graph useful? The answer depends on what
    we're going to use it for.
  prefs: []
  type: TYPE_NORMAL
- en: If the goal is to stare at it waiting for one of the Pods to start using too
    much or too little CPU, I can only say that you're wasting your talent that can
    be used on more productive tasks. After all, we already have a similar alert in
    Prometheus that will send us a Slack notification when the criteria are met. It
    is more advanced than what we have in that graph because it will notify us only
    if the CPU usage spikes for a given period, thus avoiding temporary issues that
    might be resolved a few seconds or a few minutes later. We should discard those
    cases as false alarms.
  prefs: []
  type: TYPE_NORMAL
- en: Another usage of that graph could be more passive. We could ignore it (close
    Grafana) and come back to it only if the above mentioned Prometheus alert is fired.
    That might make more sense. Even though we could run a similar query in Prometheus
    and get the same results, having a predefined graph could save us from writing
    such a query. You can think of it as a way to have a query registry with corresponding
    graphical representations. That is something that does make more sense. Instead
    of staring at the dashboard (choose Netflix instead), we can come back to it in
    time of need. While in some situations that might be a reasonable strategy, it
    will work only in very simple cases. When there is an issue, and a single pre-defined
    graph solves the problem or, to be more precise, provides a clear indication of
    the cause of the issue, graphs do provide significant value. However, more often
    than not, finding the cause of a problem is not that simple and we'll have to
    turn to Prometheus to start digging deeper into metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at dashboards with graphs is a waste of time. Visiting dashboards after
    receiving a notification about an issue makes a bit more sense. Still, all but
    trivial problems require deeper digging through Prometheus metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Never the less, the graph we just made might prove itself useful, so we'll keep
    it. What we might want to do, in such a case, is to change the link of the Prometheus
    alert (the one we're currently receiving in Slack) so that it takes us directly
    to the Graph (not the dashboard). We can get that link by clicking the arrow next
    to the panel name, and choosing the View option.
  prefs: []
  type: TYPE_NORMAL
- en: I believe that we can make our dashboard more useful if we change the type of
    panels from graphs to something less colorful, with fewer lines, fewer axes, and
    without other pretty things.
  prefs: []
  type: TYPE_NORMAL
- en: Creating semaphore dashboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If I'm claiming that the value dashboards bring to the table is lower than we
    think, you might be asking yourself the same question from the beginning of this
    chapter. Why are we talking about dashboards? Well, I already changed my statement
    from "dashboards are useless" to "there is some value in dashboards". They can
    serve as a registry for queries. Through dashboards, we do not need to memorize
    expressions that we would need to write in Prometheus. They might be a good starting
    point of our search for the cause of an issue before we jump into Prometheus for
    some deeper digging into metrics. But, there is another reason I am including
    dashboards into the solution.
  prefs: []
  type: TYPE_NORMAL
- en: I love big displays. It's very satisfying to enter into a room with large screens
    showing stuff that seem to be important. There is usually a room where operators
    sit surrounded with monitors on all four walls. That's usually an impressive sight.
    However, there is a problem with many such situations. A bunch of monitors displaying
    a lot of graphs might not amount to much more than a pretty sight. After the initial
    few days, nobody will stare at graphs. If that's not true, you can just as well
    fire that person knowing that he was faking his work.
  prefs: []
  type: TYPE_NORMAL
- en: Let me repeat it one more time.
  prefs: []
  type: TYPE_NORMAL
- en: Dashboards are not designed for us to stare at them, especially not when they
    are on big screens where everyone can see them.
  prefs: []
  type: TYPE_NORMAL
- en: So, if it's a good idea to have big screens, but graphs are not a good candidate
    to decorate them, what should we do instead? The answer lies in semaphores. They
    are similar to alerts, and they should provide a clear indication of the status
    of the system. If everything on the screen is green, there is no reason for us
    to do anything. One of them turning red is a cue that we should do something to
    correct the problem. Therefore, it is imperative that we try to avoid false positives.
    If something turns red, and that does not require any action, we are likely to
    start ignoring it in the future. When that happens, we are risking the situation
    in which when we ignore a real issue, thinking that it is just another false positive.
    Hence, every appearance of an alarm should be followed by an action.
  prefs: []
  type: TYPE_NORMAL
- en: That can be either a fix that will correct the system or a change in the conditions
    that turned one of the semaphores red. In either case, we should not ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: The main problem with semaphores is that they are not as appealing to CTOs and
    other decision makers. They are not colorful, nor do they show a lot of boxes,
    lines, and numbers. People often confuse usefulness with how pleasing something
    is to look at. Never the less, we are not building something that should be sold
    to CTOs, but something that can be helpful in our day-to-day work.
  prefs: []
  type: TYPE_NORMAL
- en: Semaphores are much more useful than graphs as a way to see the status of the
    system, even though they do not look as colorful and eye-pleasing as graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create our first semaphore.
  prefs: []
  type: TYPE_NORMAL
- en: Please click the *Add panel* icon from the top-right part of the screen, and
    select Singlestat. Click the arrow icon next to the *Panel Title*, and select
    Edit.
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, creating a single stat (a semaphore) is not much different
    from creating a graph. The significant difference is in the metric (query) that
    should produce a single value. We'll get there soon. For now, we'll change some
    general info of the panel.
  prefs: []
  type: TYPE_NORMAL
- en: Please select the General tab.
  prefs: []
  type: TYPE_NORMAL
- en: Type `Pods with <$cpuReqPercentMin%||>$cpuReqPercentMax% actual compared to
    reserved CPU` as the Title and the text that follows as the Description.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This single stat will use a similar query as the graph we made earlier. However,
    while the graph is displaying current usage compared to reserved CPU, this panel
    is supposed to show how many Pods have actual CPU usage outside of the boundaries
    based on reserved CPU. That is reflected in the title and the description we just
    entered. As you can see, this time we're relying on more variables to formulate
    our intentions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's turn our attention to the query. Please click the Metrics tab and
    type the expression that follows into the field next to *A*.
  prefs: []
  type: TYPE_NORMAL
- en: For your convenience, the query is available in the `grafana-single-stat-actual-vs-reserved-cpu`
    ([https://gist.github.com/vfarcic/078674efd3b379c211c4da2c9844f5bd](https://gist.github.com/vfarcic/078674efd3b379c211c4da2c9844f5bd))
    Gist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: That query is similar to one of those we used as the Prometheus alert. To be
    more precise, it is a combination of the two Prometheus alerts. The first half
    returns the number of Pods with more than `$minCpu` (5 CPU milliseconds) of reserved
    CPU and with actual CPU usage lower than `$cpuReqPercentMin` (50%). The second
    half is almost the same as the first, except that it returns Pods with CPU usage
    higher than `$cpuReqPercentMax` (150%).
  prefs: []
  type: TYPE_NORMAL
- en: Since our goal is to return a single stat which, in this case, is the number
    of Pods, you might be surprised that we used `sum` instead of `count`. Counting
    Pods would indeed make more sense, except that would return `N/A` if there are
    no results. To avoid that, we're using a trick with `bool`. By putting it in front
    of an expression, it returns `1` if there is a match, and `0` if there isn't.
    That way, if none of the Pods match the conditions, we won't get an empty result,
    but `0`, which is a better representation of the number of problematic Pods.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, we are retrieving a sum of all the Pods with the actual CPU below
    `$cpuReqPercentMin` (50%) of the reserved CPU, plus the sum of all the Pods with
    the actual CPU above `$cpuReqPercentMax` (150%) of the reserved CPU. In both cases,
    only the Pods with more than `$minCpu` (five CPU milliseconds) are included. The
    query itself is not the simplest one we could write but, considering that we already
    spent a lot of time with Prometheus queries, I thought that I should not "insult"
    you with something trivial.
  prefs: []
  type: TYPE_NORMAL
- en: Next, please click the Options tab. That is where we'll define the conditions
    that should trigger the change of colors.
  prefs: []
  type: TYPE_NORMAL
- en: We do NOT want average value over the specified period, but the current number
    of problematic Pods. We'll accomplish that by changing the value of the Stat drop-down
    list to Current.
  prefs: []
  type: TYPE_NORMAL
- en: We want this panel to be very visible, so we'll change the Stat Font size to
    `200%`. I'd prefer even bigger font, but Grafana does not allow us to go higher
    than that.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to change the background color of the panel, so please check the
    Coloring Background checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: We could use up to three colors, but I believe that we need only two. Either
    one or more of the Pods meet the conditions, or none of them do.
  prefs: []
  type: TYPE_NORMAL
- en: We should be notified as soon as the query returns `1`, or a higher number.
    Please type `1` as the Coloring Thresholds. If we had more, we'd separate them
    with commas.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, since we have only two conditions, green and red, we'll need to change
    the second color from orange to red. Please click the *red* icon in Coloring Colors,
    and replace the value with the word *red*. The third color is not used, so we'll
    leave it intact.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/23e5659a-1dbc-440a-9d53-13f57bb1eeea.png)Figure 6-10: Grafana''s
    single stat panel'
  prefs: []
  type: TYPE_NORMAL
- en: We're finished with our panel, so go *Back to dashboard*.
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed, please click the *Save Dashboard* icon, followed with the
    Save button.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we created a dashboard with a graph and a single stat (semaphore). The
    former shows the deviation of CPU usage compared to reserved CPU over time. It
    has alerts (red areas) that tell us whether one of the vectors is outside predefined
    boundaries. The single stat (semaphore) shows a single number with green or red
    background depending on whether that number reached a threshold which, in our
    case, is set to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: We just started, and we need many other panels before this dashboard becomes
    useful. I'll save you from repetitive instructions for defining the others. I
    feel that you got a grip on how Grafana works. You should, at least, have the
    base knowledge that you can expand on your own.
  prefs: []
  type: TYPE_NORMAL
- en: We'll fast forward. We'll import a dashboard I prepared and discuss the design
    choices.
  prefs: []
  type: TYPE_NORMAL
- en: A better dashboard for big screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We explored how to create a dashboard with a graph and a single stat (semaphore).
    Both are based on similar queries, and the significant difference is in the way
    they display the results. We'll assume that the primary purpose of the dashboard
    we started building is to be available on a big screen, visible to many, and not
    as something we keep open on our laptops. At least, not continuously.
  prefs: []
  type: TYPE_NORMAL
- en: What should be the primary purpose of such a dashboard? Before I answer that
    question, we'll import a dashboard I created for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Please click the + button from the left-hand menu and select Import. Type `9132`
    as the *Grafana.com Dashboard* and press the Load button. Select a *Prometheus
    data source*. Feel free to change any of the values to suit your needs. Never
    the less, you might want to postpone that until you get more familiar with the
    dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, click the Import button once you're finished.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a5120c4e-3ecd-4fb2-8080-840bc9cfa513.png)Figure 6-11: Grafana dashboard
    based on semaphores'
  prefs: []
  type: TYPE_NORMAL
- en: You are likely to see one or more red semaphores. That's normal since some of
    the resources in our cluster are not configured properly. For example, Prometheus
    is likely to have less memory requested than it needs. That's OK because it allows
    us to see the dashboard in action. The definitions used in the Gists are not supposed
    to be production-ready, and you already know that you have to adjust their resources,
    and likely a few other things.
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice that the dashboard we imported consists only of semaphores. At
    least, on the first look. Even though they might not be as appealing as graphs
    and other types of panels, they are much more effective as indicators of the health
    of our system. We do not need to look at that dashboard. It's enough if it's displayed
    on a big screen, while we work on something else. If one of the boxes turns red,
    we'll notice that. It will be a call to action. Or, to be more precise, we'll
    need to do something if a red box continues being red for longer, thus excluding
    the possibility that it's a false positive that will be resolved by itself after
    a few moments.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of this dashboard as a supplement to Prometheus alerts. It does
    not replace them, since there are some subtle, yet significant differences we'll
    discuss later.
  prefs: []
  type: TYPE_NORMAL
- en: I won't describe each of the panels since they are a reflection of the Prometheus
    alerts we created earlier. You should be familiar with them by now. If in doubt,
    please click on the i icon in the top-left corner of a panel. If the description
    is not enough, enter the panel's edit mode and check the query and the coloring
    options.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the dashboard might not be the perfect fit as-is. You might
    need to change some of the variable values or the coloring thresholds. For example,
    the threshold of the *Nodes* panel is set to `4,5`. Judging by the colors, we
    can see that it'll turn orange (warning) if the number of nodes jumps to four,
    and red (panic) if it goes to five. Your values are likely to be different. Ideally,
    we should use variables instead of hard-coded thresholds, but that is currently
    not possible with Grafana. Variables are not supported everywhere. You, as a supporter
    of open source projects, should make a PR. Please let me know if you do.
  prefs: []
  type: TYPE_NORMAL
- en: Does all that mean that all our dashboards should be green and red boxes with
    a single number inside them? I do believe that semaphores should be the "default"
    display. When they are green, there's no need for anything else. If that's not
    the case, we should extend the number of semaphores, instead of cluttering our
    monitors with random graphs. However, that begs the question. What should we do
    when some of the boxes turn red or even orange?
  prefs: []
  type: TYPE_NORMAL
- en: Below the boxes, you'll find the *Graph* row with additional panels. They are
    not visible by default for a reason.
  prefs: []
  type: TYPE_NORMAL
- en: There is no justification for seeing them under normal circumstances. But, if
    one of the semaphores does raise an alert, we can expand *Graphs* and see more
    details about the issue.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c5d02e39-5bfa-48fb-ab27-4f8cdb1b7741.png)Figure 6-12: Grafana dashboard
    based on tables and graphs'
  prefs: []
  type: TYPE_NORMAL
- en: The panels inside the *Graphs* row are a reflection of the panels (semaphores)
    in the *Alerts* row. Each graph shows more detailed data related to the single
    stat from the same location (but a different row). That way, we do not need to
    waste our time trying to figure out which graph corresponds to the "red box".
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can jump straight into the corresponding graph. If the semaphore
    on in the second row on the right turns red, look at the graphs in the second
    row on the right. If multiple boxes turn red, we can take a quick look at related
    graphs and try to find the relation (if there is any). More often than not, we'll
    have to switch from Grafana to Prometheus and dig deeper into metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Dashboards like the one in front of you should give us a quick head start towards
    the resolution of an issue. The semaphores on the top provide alerting mechanism
    that should lead to the graphs below that should give a quick indication of the
    possible causes of the problem. From there on, if the cause is an obvious one,
    we can move to Prometheus and start debugging (if that's the right word).
  prefs: []
  type: TYPE_NORMAL
- en: Dashboards with semaphores should be displayed on big screens around the office.
    They should provide an indication of a problem. Corresponding graphs (and other
    panels) provide a first look at the issue. Prometheus serves as the debugging
    tool we use to dig into metrics until we find the culprit.
  prefs: []
  type: TYPE_NORMAL
- en: We explored a few things that provide similar functionality. Still, it might
    not be clear what the difference between Prometheus alerts, semaphores, graph
    alerts, and Grafana notifications is? Why didn't we create any Grafana notification?
    We'll explore those and a few other questions next.
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus alerts vs. Grafana notifications vs. semaphores vs. graph alerts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The title might be confusing by itself, so let us briefly describe each of the
    elements mentioned in it.
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus alerts and Grafana notifications serve the same purpose, even though
    we did not explore the latter. I'll let you learn how Grafana notifications work
    on your own. Who knows? After the discussion that follows you might not even want
    to spend time with them.
  prefs: []
  type: TYPE_NORMAL
- en: Grafana notifications can be forwarded to different recipients in a similar
    manner as how Prometheus' alerts are forwarded with Alertmanager. However, there
    are a few things that make Grafana notifications less appealing.
  prefs: []
  type: TYPE_NORMAL
- en: If we can accomplish the same result with Prometheus alerts as with Grafana
    alerts, there is a clear advantage with the former. If an alert is fired from
    Prometheus, that means that the rules that caused the alert to fire are also defined
    in Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, evaluations are happening at the data source, and we are avoiding
    unnecessary latency between Grafana and Prometheus. The closer we are to the data
    source, the better. In case of alerts/notifications, closer means inside Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage for defining alerts in Prometheus is the fact that it allows
    us to do more. For example, there is no equivalent to Prometheus' `for` statement
    in Grafana. We cannot define a notification that will fire only if the conditions
    persist for a while. We'd need to resort to non-trivial additions to the queries
    to accomplish the same. Alertmanager, on the other hand, provides more sophisticated
    ways to filter the alerts, to group them, and to forward only those that match
    certain criteria. There are many other advantages to defining alerts in Prometheus
    and Alertmanager instead of notifications in Grafana. But, we won't go into all
    of them. I'll leave it to you to find all the differences unless you are already
    convinced to ditch Grafana notifications in favor of Prometheus alerts and Alertmanager.
  prefs: []
  type: TYPE_NORMAL
- en: There is one important reason why you shouldn't dismiss Grafana notifications
    completely. The data source you're using might not have alerting/notifications
    mechanism, or it might be part of enterprise license you do not possess. Since
    Grafana supports many different data sources, with Prometheus being only one of
    them, Grafana notifications allow us to use any of those data sources, or even
    to combine them.
  prefs: []
  type: TYPE_NORMAL
- en: Stick with Prometheus for alerts/notifications based on metrics stored there.
    For other data sources, Grafana alerts might be a better or even the only option.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we briefly explored the differences between Prometheus alerts and Grafana
    notifications, we'll move into semaphores.
  prefs: []
  type: TYPE_NORMAL
- en: Semaphores (Grafana dashboards based on single stat panels) do not replace Prometheus
    alerts. First of all, it is hard, or even impossible, to create semaphores that
    turn red only if a value reaches a threshold for some time (for example, like
    the `for` statement in Prometheus alerts). That means that a semaphore might turn
    red, only to go back to green a few moments later. That is not a cause for action
    since the problem was resolved automatically short while later. If we would jump
    every time something turns red in Grafana, we'd be in excellent physical shape,
    but we wouldn't do much useful work.
  prefs: []
  type: TYPE_NORMAL
- en: Semaphores are an indication of a possible problem that might not require any
    intervention. While such false positives should be avoided, it's almost impossible
    to get rid of them altogether. That means that we should stare at the screen to
    see whether a red box continues being red for at least a few minutes before we
    act. The primary purpose of semaphores is not to provide a notification to a person
    or a team that should fix the issue. Notifications to Slack, email, and other
    destinations do that. Semaphores provide awareness of the state of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we explored alerts defined on graphs. Those are the red lines and zones
    in the graphs. They are not good indicators that there is something wrong. They
    are not that easy to spot so they cannot raise awareness, and they definitely
    do not replace notifications. Instead, they help us after we discover that there
    is an issue. If a notification or a semaphore alerts us that there is a problem
    that might need to be fixed, graph alerts help us identify the culprit. Which
    Pod is in the red zone? Which ingress received more requests than expected? Those
    are only a few questions that we can answer through graph alerts.
  prefs: []
  type: TYPE_NORMAL
- en: What now?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Grafana is relatively simple to use and intuitive. If you know how to write
    queries for the data source hooked to Grafana (for example, Prometheus), you already
    learned the most challenging part. The rest is mostly about checking boxes, choosing
    panel types, and arranging things on the screen. The main difficulty is to avoid
    being carried away by creating a bunch of flashy dashboards that do not provide
    much value. A common mistake is to create a graph for everything we can imagine.
    That only reduces the value of those that are truly important. Less is often more.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. Destroy the cluster if its dedicated to this book, or keep it if
    it's not or if you're planning to jump to the next chapter right away. If you're
    keeping it, please delete the `grafana` Chart by executing the command that follows.
    If we need it in one of the next chapters, I'll make sure that it's included in
    the Gists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Before you leave, you might want to go over the main points of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at dashboards with graphs is a waste of time. Visiting dashboards after
    receiving a notification about an issue makes a bit more sense. Still, all but
    trivial problems require deeper digging through Prometheus metrics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dashboards are not designed for us to stare at them, especially not when they
    are on big screens where everyone can see them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semaphores are much more useful than graphs as a way to see the status of the
    system, even though they do not look as colorful and eye-pleasing as graphs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dashboards with semaphores should be displayed on big screens around the office.
    They should provide an indication of a problem. Corresponding graphs (and other
    panels) provide a first look at the issue. Prometheus serves as the debugging
    tool we use to dig into metrics until we find the culprit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stick with Prometheus for alerts/notifications based on metrics stored there.
    For other data sources, Grafana alerts might be a better or even the only option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

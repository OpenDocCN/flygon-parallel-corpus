- en: Service Decomposition
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务分解
- en: This chapter will cover how to take the knowledge from the previous chapter
    and use it to create and build an addition of a database and an application server
    container, since real-world services are usually composed in such a way. Once
    we get them all built up, we will see what is needed in order to group them together
    into a more usable service and cover even of more Docker under the hood.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍如何利用上一章的知识来创建和构建数据库和应用服务器容器的附加部分，因为真实世界的服务通常是以这种方式组成的。一旦我们把它们都建立起来，我们将看到需要什么才能将它们组合成一个更可用的服务，并且深入了解Docker的更多内容。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: A quick review of Docker commands
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker命令的快速回顾
- en: 'Writing a real service with:'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下内容编写一个真实的服务：
- en: A web server service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Web服务器服务
- en: An application service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个应用服务
- en: A database
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数据库
- en: Introducing volumes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍卷
- en: Security considerations for credential passing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凭据传递的安全考虑
- en: A quick review
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速回顾
- en: Before we start, let's review the Docker and Dockerfile commands we covered
    previously in a single section in two lists that you can use as a reference later.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们回顾一下我们之前在一个单独的部分中涵盖的Docker和Dockerfile命令，以便您以后可以作为参考。
- en: Docker commands
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker命令
- en: 'Here are all of the commands we covered for Docker with a few others added,
    which you might use if you build containers frequently:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们为Docker提供的所有命令，还添加了一些其他命令，如果您经常构建容器，可能会用到：
- en: For more in-depth information about parameters required for each, or to see
    commands that we have not covered yet, type `docker help` in the Terminal or the
    command by itself into the Terminal. You can also visit [https://docs.docker.com/](https://docs.docker.com/)
    and explore the documentation if the information provided by the CLI output is
    not good enough, and it may contain more recent data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取每个参数所需的更深入信息，或者查看我们尚未涵盖的命令，请在终端中键入`docker help`，或者单独在终端中键入该命令。您还可以访问[https://docs.docker.com/](https://docs.docker.com/)并查看文档，如果CLI输出提供的信息不够好，它可能包含更新的数据。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Recently, Docker commands have begun to be isolated into their own docker CLI
    sections like `docker container`, to separate them from other cluster management
    commands. To use this newer syntax, just prepend any command with the container
    (that is, `docker stop` turns into `docker container stop`). You can feel free
    to use either version, though keep an eye out as you can probably expect the older
    style to be deprecated at some point even though the new style is overly verbose
    for most Docker usage.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，Docker命令已经开始被隔离到它们自己的docker CLI部分，比如`docker container`，以将它们与其他集群管理命令分开。要使用这种较新的语法，只需在任何命令前加上容器（即`docker
    stop`变成`docker container stop`）。您可以随意使用任何版本，但请注意，尽管新样式对于大多数Docker用法来说过于冗长，但您可能会发现旧样式在某个时候被弃用。
- en: Dockerfile commands
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile命令
- en: 'The following list is a similar one, but this time, we are covering the commands
    you can use in a Dockerfile, and we''ve arranged it in an order similar to the
    one you would use when working within the Dockerfile:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表与之前类似，但这次我们涵盖了在Dockerfile中可以使用的命令，并按照在Dockerfile中工作时的顺序进行了排列：
- en: '`FROM <image_name>[:<tag>]`: Base the current image on `<image_name>`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM <image_name>[:<tag>]`: 将当前镜像基于`<image_name>`'
- en: '`LABEL <key>=<value> [<key>=value>...]`: Add metadata to the image'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`LABEL <key>=<value> [<key>=value>...]`: 向镜像添加元数据'
- en: '`EXPOSE <port>`: Indicate which port should be mapped into the container'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE <port>`: 指示应该映射到容器中的端口'
- en: '`WORKDIR <path>`: Set the current directory for the following commands'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`WORKDIR <path>`: 设置当前目录以便执行后续命令'
- en: '`RUN <command> [ && <command>... ]`: Execute one or more shell commands'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN <command> [ && <command>... ]`: 执行一个或多个shell命令'
- en: '`ENV <name>=<value>`: Set an environment variable to a specific value'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENV <name>=<value>`：将环境变量设置为特定值'
- en: '`VOLUME <path>`: Indicates that the <path> should be externally mounted volume'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`VOLUME <path>`：表示应该外部挂载<路径>的卷'
- en: '`COPY <src> <dest>`: Copy a local file, a group of files, or a folder into
    the container'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY <src> <dest>`：将本地文件、一组文件或文件夹复制到容器中'
- en: '`ADD <src> <dest>`: The same as `COPY` but can handle URIs and local archives'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD <src> <dest>`：与`COPY`相同，但可以处理URI和本地存档'
- en: '`USER <user | uid>`: Set the runtime context to `<user>` or `<uid>` for commands
    after this one'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`USER <user | uid>`：为此命令之后的命令设置运行时上下文为`<user>`或`<uid>`'
- en: '`CMD ["<path>", "<arg1>", ...]`: Define the command to run when the container
    is started'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD ["<path>", "<arg1>", ...]`：定义容器启动时要运行的命令'
- en: Since almost all containers you would want to build can be constructed with
    this set, this list is not the whole superset of Docker commands, and a few of
    them have been intentionally left out. If you get curious about things such as `ENTRYPOINT`,
    `ARG`, `HEALTHCHECK`, or others, you can check out the complete documentation
    at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于几乎所有您想要构建的容器都可以使用这个集合构建，因此这个列表并不是Docker命令的全部超集，其中一些被有意地省略了。如果您对`ENTRYPOINT`、`ARG`、`HEALTHCHECK`或其他内容感到好奇，可以在[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)上查看完整的文档。
- en: Writing a real service
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个真实的服务
- en: 'So far, we have spent time making fake or mock container services that helped
    us build Docker skills, but we have not had a chance to work on something that
    resembles a real-world service. In general, most of the simpler services that
    get utilized out there will look something similar to what is shown in this high-level
    diagram:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经花了时间制作了一些帮助我们建立Docker技能的假或模拟容器服务，但我们还没有机会去做一些类似真实世界服务的工作。一般来说，大多数在外部被使用的简单服务看起来会类似于高级别图表中所示的内容：
- en: '![](assets/477adec9-c7a3-429e-b279-f035913c506d.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/477adec9-c7a3-429e-b279-f035913c506d.png)'
- en: An overview
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Here we will discuss each service in detail.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将详细讨论每个服务。
- en: '**Web servers**:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web服务器**：'
- en: 'The rightmost piece in the image we just looked at is a web server. Web servers
    act as high-speed HTTP request processing handlers and are generally used in this
    context as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到的图像中最右边的部分是一个Web服务器。Web服务器充当高速HTTP请求处理程序，并且通常在这种情况下被使用如下：
- en: Reverse-proxy endpoints for resources within the clusters, **Virtual Private
    Cloud** (**VPC**), and/or **Virtual Private Network** (**VPN**)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于集群内资源、虚拟专用云（VPC）和/或虚拟专用网络（VPN）的反向代理端点
- en: Hardened gatekeepers to limit resource access and/or prevent abuse
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加固的守门人，限制资源访问和/或防止滥用
- en: Analytics collection points
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析收集点
- en: Load balancers
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡器
- en: Static content delivery servers
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态内容交付服务器
- en: Reducers of application server logic utilization
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用服务器逻辑利用的减少器
- en: SSL termination endpoints
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSL终止端点
- en: Caches of remote data
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程数据的缓存
- en: Data diodes (allow either ingress or egress of data but not both)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据二极管（允许数据的入口或出口，但不能同时）
- en: Local or federated account AAA handlers
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地或联合账户AAA处理程序
- en: This particular piece of our imaginary service is not always strictly required
    if the need for security is extremely low, the services are internal, and processing
    power is abundant, but in almost all other cases where any of these conditions
    are not present, the addition of a web server is practically mandatory. A good
    analogy to a web server is your home router. While it is not strictly necessary
    for you to use the Internet, a dedicated router enables better sharing of your
    network and serves as a dedicated security appliance between you and the Internet.
    While we have spent much of the previous chapter using NGINX, many others can
    be used (Apache, Microsoft IIS, lighttpd, and so on) and are generally functionally
    interchangeable, but beware of significantly different configuration setups.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安全需求非常低，服务是内部的，处理能力充足，那么我们想象中的服务的这一部分并不总是严格要求的，但在几乎所有其他情况下，如果这些条件中的任何一个不满足，添加Web服务器几乎是强制性的。Web服务器的一个很好的类比是你的家用路由器。虽然你不一定需要使用互联网，但专用路由器可以更好地共享你的网络，并作为你和互联网之间的专用安全设备。虽然我们在上一章中大部分时间都在使用NGINX，但还有许多其他可以使用的（如Apache、Microsoft
    IIS、lighttpd等），它们通常在功能上是可以互换的，但要注意配置设置可能会有显著不同。
- en: '**Application servers**:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用服务器**：'
- en: 'So if the web server is doing all this for us, what does the application server
    do? The application server is actually your main service logic, generally wrapped
    up in some web-accessible endpoints or a queue-consuming daemon. This piece could
    be used as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果Web服务器为我们做了所有这些，应用服务器又做什么呢？应用服务器实际上是您的主要服务逻辑，通常包装在一些可通过Web访问的端点或队列消费的守护程序中。这一部分可以这样使用：
- en: The main website framework
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要的网站框架
- en: Data manipulation API logic
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据操作API逻辑
- en: Some sort of data transformation layer
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某种数据转换层
- en: Data aggregation framework
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据聚合框架
- en: The main distinction between an application server versus a web server is that
    the web server generally operates on static data and makes generally rigid decisions
    in a flow, while the application server does almost all of the dynamic data processing
    in a non-linear fashion. Things that fall under this category are generally frameworks
    such as Node.js, Ruby on Rails, JBoss, Tornado, and others for running specific
    programming language applications which can process requests. Try not to think
    of needing a big framework as a requirement here since even the right Bash script
    or a C file could do the job just as well and still qualify as an application
    server.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务器与Web服务器的主要区别在于，Web服务器通常在静态数据上运行，并在流程中做出通常是刚性的决定，而应用服务器几乎所有的动态数据处理都是以非线性方式进行的。属于这一类的通常是诸如Node.js、Ruby
    on Rails、JBoss、Tornado等框架，用于运行可以处理请求的特定编程语言应用程序。在这里不要认为需要一个大型框架是必需的，因为即使是正确的Bash脚本或C文件也可以完成同样的工作，并且仍然可以作为应用服务器的资格。
- en: The reason why we defer as much of the work as we can to the web server instead
    of the application server is that due to the framework overhead, an application
    server is generally extremely slow and thus unsuitable to do simple, small, and
    repetitive tasks that a web server could chew through without breaking a sweat.
    For reference, an average specialized web server will be about an order of magnitude
    more efficient at serving up static pages than a full blown application server
    and, by inference, that much faster than most application servers. As mentioned
    earlier, you can probably handle low loads on an application server on its own
    or with some tuning medium ones, but anything above that is something that deserves
    a dedicated reverse proxy.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尽可能多地将工作推迟到Web服务器而不是应用服务器上，原因是由于框架开销，应用服务器通常非常慢，因此不适合执行简单、小型和重复的任务，而这些任务对于Web服务器来说是小菜一碟。作为参考，一个专门的Web服务器在提供静态页面方面的效率大约是一个完全成熟的应用服务器的一个数量级，因此比大多数应用服务器快得多。正如前面提到的，你可能可以单独或通过一些调整在应用服务器上处理低负载，但超过这个范围的任何负载都需要一个专用的反向代理。
- en: '**The database**: Once we have this logic and static file processing down,
    they are sadly mostly useless without the actual data to transform and pass around.
    As with any software that uses data, this is done with a backing database. Since
    we want to be able to scale any piece of the system and isolate discrete components,
    the database gets its own section. In the pre-container world, though, we were
    dependent on big, monolithic databases that provided us with **Atomicity**, **Consistency**,
    **Isolation**, **and Durability** (**ACID**) properties, and they did their job
    well. However, in the container world, we absolutely do not want this type of
    architecture as it is neither as resilient nor as horizontally scalable as databases
    that are shardable and able to be clustered.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库**：一旦我们掌握了这种逻辑和静态文件处理，它们在没有实际数据进行转换和传递时基本上是无用的。与使用数据的任何软件一样，这是通过后备数据库完成的。由于我们希望能够扩展系统的任何部分并隔离离散的组件，数据库有了自己的部分。然而，在容器之前的世界中，我们依赖于提供了**原子性**、**一致性**、**隔离性**和**持久性**（**ACID**）属性的大型单片数据库，并且它们完成了它们的工作。然而，在容器世界中，我们绝对不希望这种类型的架构，因为它既不像可靠性那样强大，也不像可水平扩展的数据库那样可水平扩展。'
- en: With these new-style databases, though, you generally do not get the same assurance
    that your data is treated in the same manner as the old-style ones, and it is
    an important distinction to have. What you get with most container-friendly databases
    instead of ACID is **Basically Available**, **Soft state**, **Eventual consistency** (**BASE)**,which
    pretty much means that data will eventually be correct, but between the update
    initially being sent and the final state, the data may be in various states of
    intermediate values.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用这种新式数据库，通常无法得到与旧式数据库相同的保证，这是一个重要的区别。与ACID相比，大多数容器友好的数据库提供的是**基本可用**、**软状态**、**最终一致性**（**BASE**），这基本上意味着数据最终会正确，但在初始更新发送和最终状态之间，数据可能处于各种中间值的状态。
- en: What we are going to build
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们要构建什么
- en: 'We want to make a service that will be able to serve as a good example but
    not be too complicated, to show what a real-word example of a service might probably
    look like. For this use case, we will make a container grouping that can do two
    things behind basic HTTP authentication:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望制作一个能够作为一个很好的示例但又不会太复杂的服务，以展示一个真实世界的服务可能看起来像什么。对于这个用例，我们将创建一个容器分组，可以在基本的HTTP身份验证后执行两个操作：
- en: Save a string entered in a form on the landing page to a database.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将登陆页面上输入的字符串保存到数据库中。
- en: When we land on the homepage, show the list of all strings saved so far.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们登陆首页时，显示到目前为止保存的所有字符串的列表。
- en: Here, we will try to cover as many things as we can while also building a generally
    realistic prototype of a container-backed web service. Keep in mind that with
    the available tooling, even making a service as simple as this is not very easy
    so we will attempt to reduce the complexity where we can though the difficulty
    of our content does ramp up from here.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将尽量涵盖尽可能多的内容，同时构建一个基本现实的容器支持的网络服务的原型。请记住，即使使用可用的工具，制作一个像这样简单的服务也并不容易，因此我们将尽量减少复杂性，尽管我们的内容的难度从这里开始会逐渐增加。
- en: The implementation
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现部分
- en: As we covered the three major pieces that we need in general service architectures
    already, we will split our project into the same discrete parts with a web server,
    application server, and a database container, and we will outline the steps needed
    to build them here. As mentioned earlier, you can use Git to check out all of
    the code easily from GitHub at [https://github.com/sgnn7/deploying_with_docker](https://github.com/sgnn7/deploying_with_docker)
    if you do not want to retype the code from these examples.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经涵盖了通用服务架构中需要的三个主要部分，我们将把我们的项目分成相同的离散部分，包括一个Web服务器、一个应用服务器和一个数据库容器，并在这里概述构建它们所需的步骤。如前所述，如果你不想从这些示例中重新输入代码，你可以使用Git轻松地从GitHub上检出所有的代码，网址是[https://github.com/sgnn7/deploying_with_docker](https://github.com/sgnn7/deploying_with_docker)。
- en: Web server
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web服务器
- en: 'We can choose any web server software here, but since we have already worked
    with NGINX earlier, it makes sense that we would try to reuse bits and pieces
    of this component--it is practically what the container architecture is all about!
    The web server component will provide some basic authentication, cache data, and
    act as a reverse-proxy for the application server behind it. Our basic setup that
    we worked on earlier can be used here, but we will modify it a bit so that instead
    of serving files directly, it acts as a proxy and then use authentication based
    on a credentials file we will create in our `Dockerfile`. Let''s create a new
    folder named `web_server` and add these files to it:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里选择任何Web服务器软件，但由于我们之前已经使用过NGINX，因此重用这个组件的一些部分是有道理的--这实际上就是容器架构的全部意义！Web服务器组件将提供一些基本的身份验证、缓存数据，并作为其后面的应用服务器的反向代理。我们之前工作过的基本设置可以在这里使用，但我们将对其进行一些修改，使其不再直接提供文件，而是充当代理，然后使用我们将在`Dockerfile`中创建的凭据文件进行身份验证。让我们创建一个名为`web_server`的新文件夹，并将这些文件添加到其中：
- en: '`nginx_main_site.conf`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`nginx_main_site.conf`:'
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are three interesting parts about this configuration here. The first one
    is the inclusion of `auth_basic_` commands that enable HTTP Basic authentication
    on all endpoints provided by this configuration. The second, if you were observant
    enough of the new `.`-prefixed credentials file, is the fact that our denial of
    fetching all files starting with a `.` is needed now since we added `.htpasswd`.
    The third and the final interesting thing here is the use of `proxy_pass`, which
    allows the server to route all traffic that is authenticated to the backend application
    server. Why we use `http://172.17.0.1:8000` as the destination is beginning to
    open the proverbial Pandora's box of Docker networking, so we will explain why
    we used it later as we will derail our service building if we cover it now.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三个有趣的配置部分。第一个是包含`auth_basic_`命令，它们在此配置提供的所有端点上启用HTTP基本身份验证。第二个是，如果你足够留心新的以`.`开头的凭据文件，我们现在需要拒绝获取所有以`.`开头的文件，因为我们添加了`.htpasswd`。第三个也是最有趣的是使用了`proxy_pass`，它允许服务器将所有经过身份验证的流量路由到后端应用服务器。为什么我们使用`http://172.17.0.1:8000`作为目的地，这开始打开Docker网络的潘多拉魔盒，所以我们将在稍后解释为什么我们使用它，如果现在涵盖它，我们将使我们的服务构建偏离轨道。
- en: Warning! In most cases, using basic authentication is a practical joke of security
    without HTTPS as we use it here since anyone on the network can sniff out your
    credentials in plaintext with the simplest of tools. In your services, at the
    very least, mandate the HTTPS protocol is you use basic auth or rely on stronger
    forms of credentials-passing before deploying services to anything with direct
    Internet access.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add our new `Dockerfile` in that same directory, which will look
    like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, we''ve made a couple of changes here from our original work
    in the previous chapter. The initial thing that should stick out is the new way
    to write the `RUN apt-get` line, which we''ve annotated here briefly:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Unlike in previous images, here, we install the `openssl` package since we will
    need it to create NGINX-encrypted passwords for authentication, but the `clean`
    and `autoclean`  lines are here to make sure we remove any cached `apt` packages
    on the system and remove orphaned packages, giving us a smaller image which is
    something we should always strive for. Just like before, we combine all of the
    lines in a similar manner early on so that the filesystem difference between the
    previous and current layer will only be the required changes and nothing else,
    making it a very compact change. When writing your own images, if you find yourself
    needing even more fat trimming, many more things can be removed (such as removing
    documentation files, `/var` directories, unnecessary optional packages, and so
    on), but these two should be the ones to use in most cases as they're simple to
    do and work pretty well on Debian-based systems.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Without proper authentication, our server is wide open to anyone accessing
    it so we add a username/password combo to act as a gatekeeper to our service:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`ARG` acts as a build-time substitute for an `ENV` directive and allows the
    password to be passed in as a build argument with `--build-arg <arg>`. If the
    build is not provided with one, it should default to the argument after the equals
    sign, which is a very insecure `test` in this case. We will use this variable
    a bit lower in the `Dockerfile` to create the `.htpasswd` file with a specific
    password for our user.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The second line uses `openssl`, which we installed earlier, to take this build
    arg and create the `.htpasswd` file with encrypted credentials in a format that
    NGINX and most other web servers can understand (`<username>:<hashed_password>`).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Warning! Keep in mind that the  `-1` algorithm is less secure than the **Salted
    SHA** (SSHA) method of creating `.htpasswd` passwords, but to create them in this
    way would have involved more complicated commands that would have distracted from
    our main purpose here, but you can visit [https://nginx.org/en/docs/http/ngx_http_auth_basic_module.html#auth_basic_user_file](https://nginx.org/en/docs/http/ngx_http_auth_basic_module.html#auth_basic_user_file)
    for more details. Also be aware that you should never use online password generators
    as they can (and often do) steal your entered information.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 警告！请记住，`-1`算法比使用**Salted SHA**（SSHA）方法创建`.htpasswd`密码不够安全，但以这种方式创建它们将涉及更复杂的命令，这将分散我们在这里的主要目的，但您可以访问[https://nginx.org/en/docs/http/ngx_http_auth_basic_module.html#auth_basic_user_file](https://nginx.org/en/docs/http/ngx_http_auth_basic_module.html#auth_basic_user_file)获取更多详细信息。还要注意，您不应该使用在线密码生成器，因为它们可能（并经常）窃取您输入的信息。
- en: If you haven't worked with Bash sub-shells before, `$(openssl ...)` is run in
    a separate shell and the output is substituted as a string variable before the
    rest is evaluated so the `>>` append operation will only see the encrypted password
    after `username:` and nothing related to `openssl`. As it should be somewhat apparent
    from these things, if we don't provide any build arguments, the container will
    have a single username `user` with a password set to `test`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前没有使用过Bash子shell，`$(openssl ...)`将在单独的shell中运行，并且输出将被替换为字符串变量，然后再进行评估，因此`>>`追加操作将只看到`username:`后的加密密码，与`openssl`无关。从这些事情中应该有些明显，如果我们不提供任何构建参数，容器将具有一个用户名`user`，密码设置为`test`。
- en: Warning! This type of credential passing to the image is used here as an example
    and is very nonsecure since anyone can run `docker history` and see what this
    variable was set to or start the image and echo the `PASSWORD` variable. In general,
    preferred ways of passing this type of sensitive data are through environment
    variables when you launch the container, mounting the credentials file as a volume
    onto the container, using `docker secret`, or an external credentials sharing
    service. We may cover some of these in later chapters, but for now, you should
    just keep in mind not to use this particular way of passing credentials in production
    due to security concerns.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 警告！此处使用的将凭据传递给镜像的方式仅用作示例，非常不安全，因为任何人都可以运行`docker history`并查看此变量设置为什么，或者启动镜像并回显`PASSWORD`变量。一般来说，传递此类敏感数据的首选方式是在启动容器时通过环境变量传递，将凭据文件挂载为容器的卷，使用`docker
    secret`或外部凭据共享服务。我们可能会在后面的章节中涵盖其中一些，但现在，您应该记住，出于安全考虑，不要在生产中使用这种特定的凭据传递方式。
- en: 'With the `web_server` piece finished up, we can move to the next piece: the
    database.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`web_server`部分完成后，我们可以转移到下一个部分：数据库。'
- en: The database
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库
- en: While SQL databases have come a long way in their ability to be sharded and
    clustered and generally provide good performance, many of cluster-friendly solutions
    have been based on NoSQL and in most cases use a key/value storage; plus, they
    have been gaining ground versus the entrenched SQL players in the ecosystem with
    each passing year. To get our feet wet quickest and with least amount of effort,
    we'll choose MongoDB here, which is a breeze to get working, and because it is
    NoSQL, we don't have to set up any kind of schema either, massively reducing our
    need for tricky configurations!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: SQL数据库在分片和集群方面已经取得了长足的进步，并且通常能够提供良好的性能，但许多面向集群的解决方案都是基于NoSQL的，并且在大多数情况下使用键/值存储；此外，它们已经在生态系统中与根深蒂固的SQL玩家竞争，逐年获得了越来越多的地位。为了尽快入门并付出最少的努力，我们将选择MongoDB，这是一个轻而易举的工作，因为它是NoSQL，我们也不需要设置任何类型的模式，大大减少了我们对棘手配置的需求！
- en: Warning! The default setup for MongoDB is very easy to do, but it does not enable
    any security by default, so anyone with network access to that container can read
    and write data to any database. In a private cloud, this might be somewhat acceptable,
    but in any other situation, it is not something that should be done, so keep in
    mind that if you plan on deploying MongoDB and make sure it is set up at least
    with some sort of isolation and/or authentication.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 警告！MongoDB的默认设置非常容易做到，但默认情况下不会启用任何安全性，因此任何具有对该容器的网络访问权限的人都可以读取和写入任何数据库中的数据。在私有云中，这可能是可以接受的，但在任何其他情况下，这都不应该做，因此请记住，如果您计划部署MongoDB，请确保至少设置了某种隔离和/或身份验证。
- en: 'Our whole setup for the database here will be really simple, and if we didn''t
    need to harden it with package updates, we wouldn''t even have a custom one:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的整个数据库设置将非常简单，如果我们不需要通过软件包更新来加固它，我们甚至不需要自定义一个：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The only thing we should consider when we run it is to make sure that the database
    storage volume from the container (`/var/lib/mongodb`) is mounted from the host
    into the container so that we preserve it if the container stops, but we can worry
    about that once we start launching the container group.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行它时唯一需要考虑的是确保从主机将容器的数据库存储卷（`/var/lib/mongodb`）挂载到容器中，以便在容器停止时保留它，但是一旦我们开始启动容器组，我们可以担心这一点。
- en: The application server
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序服务器
- en: 'For this component, we will pick a framework with a minimal amount of boilerplate
    needed to get a service up and operational, which most people would say today
    is Node.js with Express. Since Node.js is based on JavaScript, which was originally
    based on a Java-like syntax, most people who worked on HTML should be able to
    figure out what the application code is be doing, but before we get there, we
    need to define our Node package and our dependencies, so create a new `application_server`
    directory on the same level as `web_server` and add the following to a file called
    `package.json`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个组件，我们将选择一个需要最少样板代码就能使服务运行的框架，大多数人今天会说是Node.js和Express。由于Node.js是基于JavaScript的，而JavaScript最初是基于类似Java的语法的，大多数熟悉HTML的人应该能够弄清楚应用程序代码在做什么，但在我们到达那里之前，我们需要定义我们的Node包和我们的依赖项，所以在与`web_server`同级的目录下创建一个新的`application_server`目录，并将以下内容添加到一个名为`package.json`的文件中：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There's nothing really magical here; we're just using a Node package definition
    file to declare that we need Express as a dependency and that our `npm start`
    command should run `node index.js`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里真的没有什么神奇的东西；我们只是使用了一个Node包定义文件来声明我们需要Express作为一个依赖项，并且我们的`npm start`命令应该运行`node
    index.js`。
- en: 'Let''s also make our Dockerfile now:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在也制作我们的Dockerfile：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Many of these things should be very familiar here, especially with people familiar
    with Node. We are starting with the `node:8` image, adding our application code,
    installing the dependencies we defined in `package.json` (with `npm install`),
    and then finally making sure that the app starts when run from the `docker` CLI.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些东西对很多人来说应该非常熟悉，特别是对于熟悉Node的人来说。我们从`node:8`镜像开始，添加我们的应用程序代码，安装我们在`package.json`中定义的依赖项（使用`npm
    install`），然后最后确保应用程序在从`docker` CLI运行时启动。
- en: The order here is pretty important to both avoid cache breaking and ensure proper
    permissions. We place things that we don't expect to change much (`USER`, `WORKDIR`,
    `EXPOSE`, `mkdir`, and `chown`) above `COPY` since they are much less likely to
    change as opposed to the application code and since they're mostly interchangeable,
    we arrange them in the ascending order of what we think are the least likely to
    change in the future in order to prevent rebuilding of layers and wasted computing
    power.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的顺序对于避免缓存破坏和确保适当的权限非常重要。我们将那些我们不指望会经常更改的东西（`USER`，`WORKDIR`，`EXPOSE`，`mkdir`和`chown`）放在`COPY`上面，因为与应用程序代码相比，它们更不可能更改，并且它们大部分是可互换的，我们按照我们认为未来最不可能更改的顺序排列它们，以防止重建层和浪费计算资源。
- en: 'Here is also a Node.js-specific image optimization trick: since `npm install`
    is usually the most time and CPU intensive part of dealing with code changes to
    a Node application, you can even further optimize this Dockerfile by copying only `package.json`,
    running `npm install`, and then copying the rest of the files to the container.
    Creating the container in this manner will only do the pricey `npm install` if
    `package.json` changes and will generally improve build times by a large margin,
    but this was excluded from this example in order to not derail our main conversation
    with framework-specific optimizations.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个特定于Node.js的图像优化技巧：由于`npm install`通常是处理Node应用程序代码更改中最耗时和CPU密集的部分，您甚至可以通过仅复制`package.json`，运行`npm
    install`，然后将其余文件复制到容器中来进一步优化这个Dockerfile。以这种方式创建容器只会在`package.json`更改时执行昂贵的`npm
    install`，并且通常会大幅提高构建时间，但出于不希望通过特定于框架的优化来使我们的主要对话偏离主题的目的，本示例中将其排除在外。
- en: 'So far, we haven''t really defined any application code, so let''s see what
    that looks like too. First, we need an HTML view to be our landing page, and we
    can throw one together pretty quickly using a `pug` (formerly also known as `jade`)
    template. Create a `views/` folder and put this in a file named `index.pug` located
    in that folder:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们实际上还没有定义任何应用程序代码，所以让我们也看看它是什么样子。首先，我们需要一个HTML视图作为我们的登陆页面，我们可以使用`pug`（以前也被称为`jade`）模板很快地创建一个。创建一个`views/`文件夹，并将其放在该文件夹中名为`index.pug`的文件中：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You don't have to know much about this templating style except that it is a
    simple HTML page on which we will display all items from the `words` array passed
    into it during rendering, and if a new word is put in, there will be a form submitted
    as a `POST` request to the `/new` endpoint.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必对这种模板样式了解太多，只需知道它是一个简单的HTML页面，在渲染时我们将显示传递给它的`words`数组中的所有项目，如果输入了一个新单词，将会有一个表单提交为`POST`请求到`/new`端点。
- en: The main application logic
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要应用逻辑
- en: 'There is no easy way around this, but our main application logic file, `index.js`,
    won''t be as simple as the other configuration files have been:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有简单的方法，但我们的主要应用逻辑文件`index.js`不会像其他配置文件那样简单：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This file may seem daunting at first, but this is possibly the smallest API
    service that you can make from scratch that is also fully functional.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件一开始可能看起来令人生畏，但这可能是您可以从头开始制作的最小的完全功能的API服务。
- en: If you would like to learn more about either Node, Express, or the MongoDB driver,
    you can visit [https://nodejs.org/en/](https://nodejs.org/en/), [https://expressjs.com/](https://expressjs.com/),
    and [https://github.com/mongodb/node-mongodb-native](https://github.com/mongodb/node-mongodb-native).
    If you don't feel like typing, you can also copy and paste this file from [https://github.com/sgnn7/deploying_with_docker/](https://github.com/sgnn7/deploying_with_docker/).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于Node、Express或MongoDB驱动程序的信息，您可以访问[https://nodejs.org/en/](https://nodejs.org/en/)，[https://expressjs.com/](https://expressjs.com/)和[https://github.com/mongodb/node-mongodb-native](https://github.com/mongodb/node-mongodb-native)。如果您不想打字，您也可以从[https://github.com/sgnn7/deploying_with_docker/](https://github.com/sgnn7/deploying_with_docker/)复制并粘贴此文件。
- en: 'The basic operation of this app is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用的基本操作如下：
- en: Load any existing words from the `MongoDB` database
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`MongoDB`数据库加载任何现有的单词
- en: Keep a copy of that list in a variable so that we only need to fetch things
    from the database once
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留该列表的副本在一个变量中，这样我们只需要从数据库中获取一次东西
- en: Open a port `8000` and listen for requests
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开端口`8000`并监听请求
- en: If we receive a `GET` request on `/`, return the rendered `index.html` template
    and fill it in with the word list array
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们收到`/`的`GET`请求，返回渲染的`index.html`模板，并用单词列表数组填充它
- en: 'If we receive a `POST` to `/new`:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们收到`/new`的`POST`请求：
- en: Save the value in the database
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值保存在数据库中
- en: Update our word list
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新我们的单词列表
- en: Send us back to `/`
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送我们回到`/`
- en: 'One part here, however, needs special attention:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一部分需要特别注意：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Remember when we previously mentioned that much of image configuration should
    be done through environment variables before? That is exactly what we are doing
    here! If an environment variable `DB_HOST` is set (as we expect it to be when
    running as a container), we will use it as the hostname, but if none is provided
    (as we expect it when running locally), it will assume that the database is running
    locally on the standard MongoDB port. This provides the flexibility of being configurable
    as a container and being able to be tested locally by a developer outside of Docker.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们之前提到过，很多图像配置应该在环境变量中完成吗？这正是我们在这里要做的！如果设置了环境变量`DB_HOST`（正如我们期望在作为容器运行时设置），我们将使用它作为主机名，但如果没有提供（正如我们在本地运行时期望的那样），它将假定数据库在标准的MongoDB端口上本地运行。这提供了作为容器可配置的灵活性，并且可以在Docker之外由开发人员在本地进行测试。
- en: 'With the main logic file in place, our service should now be arranged in a
    similar filesystem layout as this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 主逻辑文件就位后，我们的服务现在应该有一个类似的文件系统布局：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since this is really the only easy part to test out of the three, let''s install
    MongoDB locally and see what the service does. You can visit [https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)
    for information on how to install it for other platforms, but I''ve included the
    following steps to do this manually on Ubuntu 16.04:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这实际上是三个中最容易测试的部分，让我们在本地安装MongoDB并看看服务的表现。您可以访问[https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)获取有关如何在其他平台上手动安装的信息，但我已经包含了以下步骤来在Ubuntu
    16.04上手动执行此操作：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It seems to work: let''s check out the browser by going to `http://localhost:8000`!'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来工作正常：让我们通过访问`http://localhost:8000`来检查浏览器！
- en: '![](assets/9debc5f4-6e14-45e0-8d78-60ed42593f44.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9debc5f4-6e14-45e0-8d78-60ed42593f44.png)'
- en: 'Let''s put a few words in it and see what happens:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在里面放几个词，看看会发生什么：
- en: '![](assets/51dc3024-b575-40c0-89c7-9bde31bd511f.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/51dc3024-b575-40c0-89c7-9bde31bd511f.png)'
- en: So far, so good! The final test is restarting the service and making sure that
    we see the same list. Press *Ctrl* + *C* out of our Node process and run `npm
    start`. You should see the same list again, which means that it is working as
    expected!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很顺利！最后的测试是重新启动服务，并确保我们看到相同的列表。按下*Ctrl* + *C*退出我们的Node进程，然后运行`npm start`。您应该再次看到相同的列表，这意味着它按预期工作！
- en: Running it all together
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一起运行
- en: 'So, we have our `web_server`, `application_server`, and `database` containers
    all figured out. Let''s verify that you have all the files matching these before
    moving on:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经弄清楚了我们的`web_server`，`application_server`和`database`容器。在继续之前，请验证您是否拥有所有与这些匹配的文件：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next step for us is to build all the containers:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是构建所有的容器：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This sequential building is great for showing what needs to be done in each
    step, but always think about automation and how manual processes can be improved.
    In this particular case, this whole block of statements and execution could have
    also been done from the parent directory with this single line: `for dir in *;
    do cd $dir; docker build -t $dir .; cd ..; done`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这种顺序构建非常适合显示每个步骤需要做什么，但始终考虑自动化以及如何改进手动流程。在这种特殊情况下，这整个语句和执行块也可以从父目录中用这一行完成：`for
    dir in *; do cd $dir; docker build -t $dir .; cd ..; done`
- en: Launching
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动
- en: 'With the three relevant containers made, we can now launch them. Some care
    needs to be taken that they are launched in order as our application tries to
    read the data from the database as soon as it is started and we don''t want the
    web server up if the application isn''t there, so we will launch them in this
    order: `database -> application_server -> web_server`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这三个相关的容器，我们现在可以启动它们。需要注意的是，它们需要按照我们的应用程序尝试读取数据库中的数据的顺序启动，如果应用程序不存在，我们不希望Web服务器启动，因此我们将按照这个顺序启动它们：`database
    -> application_server -> web_server`：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A few things to note here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几件事需要注意：
- en: We mapped local port `27000` to database `27017` intentionally so that we wouldn't
    have the conflict with the MongoDB database already running on the host.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们故意将本地端口`27000`映射到数据库`27017`，以避免与主机上已经运行的MongoDB数据库发生冲突。
- en: We passed in the magic `172.17.0.1` IP as the host and port `27000` to our application
    server to use as the database host.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将神奇的`172.17.0.1` IP作为主机和端口`27000`传递给我们的应用服务器，用作数据库主机。
- en: We started the web server on port `8080` instead of `80` for the web server
    in order to make sure that we don't need root permissions*.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将Web服务器启动在端口`8080`上，而不是`80`，以确保我们不需要root权限*。
- en: If you do not see three containers running, check the logs with `docker logs
    <container id>`. The most likely culprit will probably be the mismatch between
    the IP/port on a container and the destination, so just fix and restart the container
    that is failing until you have all three running. If you have a lot of problems,
    do not hesitate to start the containers in the non-daemon mode by removing the
    `-d` flag from the commands we used.* - On *nix systems, ports below `1024` are
    called registered or privileged ports that govern many important aspects of communications
    for a system. To prevent malicious use of these system ports, root-level access
    is required on almost all such platforms. Since we don't really care which port
    we will be using for this testing, we will avoid this issue altogether by selecting
    port 8080.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有看到三个正在运行的容器，请使用`docker logs <container id>`检查日志。最有可能的罪魁祸首可能是容器上的IP/端口与目的地之间的不匹配，因此只需修复并重新启动失败的容器，直到您有三个正在运行的容器。如果您遇到很多问题，请毫不犹豫地通过从我们使用的命令中删除`-d`标志来以非守护程序模式启动容器。*
    - 在*nix系统上，低于`1024`的端口称为注册或特权端口，它们管理系统通信的许多重要方面。为了防止对这些系统端口的恶意使用，几乎所有这些平台都需要root级别的访问权限。由于我们并不真的关心我们将用于测试的端口，我们将通过选择端口8080来完全避免这个问题。
- en: 'The flow of information in this setup is approximated to this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置中的信息流大致如下：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Testing
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: We have all the pieces running, so let's give it a whirl at `http://localhost:8080`!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的部件都在运行，所以让我们在`http://localhost:8080`上试试看！
- en: '![](assets/3b3eba36-e8bd-4025-9078-7805e300de88.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3b3eba36-e8bd-4025-9078-7805e300de88.png)'
- en: 'Nice; our authentication is working! Let''s put in our super-secret credentials
    (User: `user`, Password: `test`).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们的身份验证正在工作！让我们输入我们超级秘密的凭据（用户：`user`，密码：`test`）。
- en: '![](assets/47647778-1bdf-471c-af06-81f1446c17a1.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/47647778-1bdf-471c-af06-81f1446c17a1.png)'
- en: 'Once we log in, we should be able to see our application server take the processing
    of the request over and give us the form to enter the words we want to save:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们登录，我们应该能够看到我们的应用服务器接管请求的处理，并给我们一个表单来输入我们想要保存的单词：
- en: '![](assets/bb732e1c-5439-45ea-9bd8-45534cfdac3c.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bb732e1c-5439-45ea-9bd8-45534cfdac3c.png)'
- en: 'Just as we wanted, the application server is handling requests once we authenticate!
    Enter a few words and see what happens:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所希望的，一旦我们进行身份验证，应用服务器就会处理请求！输入一些单词，看看会发生什么：
- en: '![](assets/0dd93630-4a99-4c86-bcc5-bf6f42fa0c98.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0dd93630-4a99-4c86-bcc5-bf6f42fa0c98.png)'
- en: Congratulations! You have made your first containerized service!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经创建了您的第一个容器化服务！
- en: Limitations and issues with our implementation
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们实现的限制和问题
- en: We should take a minute here to consider what parts of our service might need
    improving if you are to use it in a real system and what the most optimal/practical
    mitigations might be. As the critical part of working with containers and the
    cloud is evaluating the pros and cons of larger architectures, this is something
    you should always try to do when developing a new system or changing an existing
    one.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该花一分钟时间考虑如果要在真实系统中使用它，我们服务的哪些部分可能需要改进，以及最优/实际的缓解措施可能是什么。由于处理容器和云的关键部分是评估更大体系结构的利弊，这是您在开发新系统或更改现有系统时应该尝试做的事情。
- en: 'From a cursory look, these are the obvious things that could be improved, what
    the impact is, and what might be the possible mitigations:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从粗略的观察来看，这些是可以改进的明显事项，影响是什么，以及可能的缓解措施是什么：
- en: The database has no authentication
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库没有身份验证
- en: '**Class**: Security, very high impact'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别**：安全性，影响非常大'
- en: '**Mitigation**: Private cloud or use authentication'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓解措施**：私有云或使用身份验证'
- en: Database data is stored within Docker container (data lost if the container
    is lost)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库数据存储在Docker容器中（如果容器丢失，则数据也会丢失）
- en: '**Class**: Stability, critical impact'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别**：稳定性，影响严重'
- en: '**Mitigation**: Mounted volume and/or sharding and clustering'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓解措施**：挂载卷和/或分片和集群'
- en: Hardcoded endpoints
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬编码的端点
- en: '**Class**: Ops, very high impact'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别**：运维，影响非常大'
- en: '**Mitigation**: Service discovery (we will cover this in later chapters)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓解措施**：服务发现（我们将在后面的章节中介绍）'
- en: Application server assumes it is the only one changing the word list
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用服务器假设它是唯一更改单词列表的
- en: '**Class**: Scaling, very high impact'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别**：扩展性，影响非常大'
- en: '**Mitigation**: Refresh data on each page load'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓解措施**：在每次页面加载时刷新数据'
- en: Application server requires database on container start
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用服务器在容器启动时需要数据库
- en: '**Class**: Scaling/Ops, medium impact'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别**：扩展性/运维，中等影响'
- en: '**Mitigation**: Defer loading until the page is hit and/or show message that
    the database is not available'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓解措施**：延迟加载直到页面被点击和/或显示数据库不可用的消息'
- en: Web server authentication is baked into the image
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务器身份验证已经嵌入到镜像中
- en: '**Class**: Security, critical impact'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别**：安全性，影响严重'
- en: '**Mitigation**: Add credentials at runtime'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓解措施**：在运行时添加凭据'
- en: Web server authentication is over HTTP
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务器身份验证是通过HTTP完成的
- en: '**Class**: Security, very high impact'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别**：安全性，影响非常大'
- en: '**Mitigation**: Use HTTPS and/or OAuth'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓解措施**：使用HTTPS和/或OAuth'
- en: Fixing the critical issues
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复关键问题
- en: 'Since we are pretty early in our Docker journey, we will only cover a few workarounds
    for the most critical issues for now, which are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在Docker的旅程中还处于早期阶段，现在我们只会涵盖一些最关键问题的解决方法，这些问题如下：
- en: Database data is stored within the Docker container (data is lost if the container
    is lost).
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库数据存储在Docker容器中（如果容器丢失，数据也会丢失）。
- en: Web server authentication is baked into the image.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务器身份验证已经内置到镜像中。
- en: Using a local volume
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用本地卷
- en: The first issue is a very serious problem because all of our data is currently
    tied to our container, so if the database app stops, you have to restart the same
    container to get your data back. In this situation, if the container is run with
    the `--rm` flag and stops or is otherwise terminated, all the data associated
    with it would disappear, which is definitively not something we want. While large-scale
    solutions for this problem are done with sharding, clustering, and/or persistent
    volumes for our level, we should be fine by just mounting the data volume where
    we want to keep our data into the container directly. This should keep the data
    on the host filesystem if anything happens to the container and can be further
    backed up or moved somewhere else if needed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是一个非常严重的问题，因为我们所有的数据目前都与我们的容器绑定，所以如果数据库应用停止，您必须重新启动相同的容器才能恢复数据。在这种情况下，如果容器使用`--rm`标志运行并停止或以其他方式终止，与其关联的所有数据将消失，这绝对不是我们想要的。虽然针对这个问题的大规模解决方案是通过分片、集群和/或持久卷来完成的，但我们只需直接将数据卷挂载到容器中的所需位置即可。如果容器发生任何问题，这样可以将数据保留在主机文件系统上，并且可以根据需要进一步备份或移动到其他地方。
- en: 'This process of mounting (sometimes called mapping) a directory into the container
    is actually relatively easy to do when we start it if our volume is a named volume
    stored within Docker internals:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将目录挂载到容器中的这个过程实际上相对容易，如果我们的卷是存储在Docker内部的一个命名卷的话：
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What this will do is create a named volume in Docker's local storage called
    `local_storage`, which will be seamlessly mounted on `/data/db` in the container
    (the place where the MongoDB image stores its data in the images from Docker Hub).
    If the container dies or anything happens to it, you can mount this volume onto
    a different container and retain the data.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Docker的本地存储中创建一个名为`local_storage`的命名卷，它将无缝地挂载到容器中的`/data/db`（这是MongoDB镜像在Docker
    Hub中存储数据的地方）。如果容器死掉或发生任何事情，您可以将此卷挂载到另一个容器上并保留数据。
- en: '`-v` , `--volume` , and using a named volume are not the only ways to create
    volumes for Docker containers. We will cover the reasons why we use this syntax
    as opposed to other options (that is, `--mount`) in more detail in [Chapter 5](28ed4c15-7ae9-44fd-9110-2dee6672c13a.xhtml), *Keeping
    the Data Persistent,* which specifically deals with volumes.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`-v`，`--volume`和使用命名卷并不是为Docker容器创建卷的唯一方法。我们将在[第5章](28ed4c15-7ae9-44fd-9110-2dee6672c13a.xhtml)中更详细地讨论为什么我们使用这种语法而不是其他选项（即`--mount`），该章节专门涉及卷的持久性。'
- en: 'Let us see this in action (this may require a MongoDB client CLI on your host
    machine):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这在实际中是如何运作的（这可能需要在您的主机上安装一个MongoDB客户端CLI）：
- en: '[PRE18]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, our record persisted through the original container's destruction,
    which is exactly what we want! We will cover how to handle volumes in other ways
    in later chapters, but this should be enough to get us where we want with this
    critical issue in our little service.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们的记录经过了原始容器的销毁而得以保留，这正是我们想要的！我们将在后面的章节中涵盖如何以其他方式处理卷，但这应该足以让我们解决我们小服务中的这个关键问题。
- en: Generating the credentials at runtime
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时生成凭据
- en: Unlike the database problem, this particular issue is not as easy to deal with,
    mostly because credentials are a tough problem to deal with from a security perspective.
    If you include a build argument or a baked-in environment variable, anyone with
    access to the image can read it. Also, if you pass in the credentials through
    an environment variable during container creation, anyone that has docker CLI
    access can read it so you're mostly left with mounting of volumes with credentials
    to the container.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库问题不同，这个特定问题不那么容易处理，主要是因为从安全角度来看，凭据是一个棘手的问题。如果你包含一个构建参数或内置的环境变量，任何有权访问镜像的人都可以读取它。此外，如果你在容器创建过程中通过环境变量传递凭据，任何具有docker
    CLI访问权限的人都可以读取它，所以你基本上只能将凭据挂载到容器的卷上。
- en: There are a few other ways of passing credentials securely, though they are
    a bit outside of the scope of this exercise such as env variables that contain
    hashed passwords, using a broker secrets-sharing service, using cloud-specific
    roles mechanisms (that is, AWS, IAM Role, `user-data`), and a few others, but
    the important part for this section is to understand which things you should try
    not to do when handling authentication data.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他安全地传递凭据的方法，尽管它们有点超出了本练习的范围，比如包含哈希密码的环境变量，使用代理秘密共享服务，使用特定于云的角色机制（即AWS，IAM角色，“用户数据”）等等，但对于本节来说，重要的是要理解在处理身份验证数据时应该尽量避免做哪些事情。
- en: 'To work around this, we will generate our own credentials file locally on the
    host machine and mount it to the container when it starts. Substitute `user123`
    with whatever username you want and `password123` with an alphanumeric password:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将在主机上生成自己的凭据文件，并在容器启动时将其挂载到容器上。用你想要的任何用户名替换`user123`，用包含字母数字的密码替换`password123`：
- en: '[PRE19]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With this small change, your web server will now be secured with the new username
    and the new password and the configuration won't be available to people able to
    run docker commands either. You can access [http://127.0.0.1:8080](http://127.0.0.1:8080)
    to see that the new username and password are the only credentials that work.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个小改变，你的Web服务器现在将使用新的用户名和新的密码进行安全保护，并且配置也不会被能够运行docker命令的人所获取。你可以访问[http://127.0.0.1:8080](http://127.0.0.1:8080)来查看新的用户名和密码是唯一有效的凭据。
- en: Introducing Docker networking
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入Docker网络
- en: At an earlier point, we have somewhat glanced over our use of IP `172.17.0.1`
    in the `web_server` code, and it is something that is not well covered in other
    materials, but it is a *very* important thing to understand if you want to have
    a solid grasp on Docker. When the Docker service is started on a machine, a number
    of networking `iptables` rules are added to your machine in order to allow the
    container to connect to the world through forwarding and vice versa. Effectively,
    your machine becomes an Internet router for all containers started. On top of
    this, each new container is assigned a virtual address (most likely in the range
    of `172.17.0.2`+) and any communication it does will be normally invisible to
    the other containers unless a software-defined network is created, so connecting
    multiple container on the same machine is actually a really tricky task to do
    manually without helper software that is in the Docker infrastructure called **Service
    Discovery**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在较早的时候，我们已经略微提到了在`web_server`代码中使用IP`172.17.0.1`，这在其他材料中并没有得到很好的涵盖，但如果你想对Docker有一个扎实的理解，这是非常重要的事情。当在一台机器上启动Docker服务时，会向您的机器添加一些网络`iptables`规则，以允许容器通过转发连接到世界，反之亦然。实际上，您的机器变成了所有启动的容器的互联网路由器。除此之外，每个新容器都被分配一个虚拟地址（很可能在`172.17.0.2`+的范围内），它所进行的任何通信通常对其他容器是不可见的，除非创建了一个软件定义的网络，因此在同一台机器上连接多个容器实际上是一个非常棘手的任务，如果没有Docker基础设施中称为**服务发现**的辅助软件。
- en: Since we didn't want the overhead of this Service Discovery for now (which we
    will cover later in more depth), and we couldn't use `localhost`/`127.0.0.1`/`::1`,
    which would not have worked at all, we needed to give it the Docker virtual router
    IP (almost always `172.17.0.1`) so that it would find our actual machine where
    other container ports have been bound.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在不想要这个服务发现的开销（我们稍后会更深入地介绍），并且我们不能使用`localhost`/`127.0.0.1`/`::1`，这根本行不通，我们需要给它Docker虚拟路由器IP（几乎总是`172.17.0.1`），这样它就能找到我们的实际机器，其他容器端口已经绑定在那里。
- en: Please note that large parts of this next section do not work on macOS nor Windows
    machines due to the way their networking stack is implemented for Docker. For
    those systems, I would suggest that you use an Ubuntu virtual machine to follow
    along.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于macOS和Windows机器的网络堆栈实现方式，本节的大部分内容在这些系统上都无法工作。对于这些系统，我建议您使用Ubuntu虚拟机来跟随操作。
- en: 'If you would like to verify this, we can use a few commands outside and inside
    of Docker in order to really see what is happening:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想验证这一点，我们可以使用一些命令在Docker内外来真正看到发生了什么：
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, this system is a bit odd, but it works pretty well. Generally
    when building bigger systems, service discovery is practically mandatory, so you
    wouldn't have to worry about such low-level details in the field.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个系统有点奇怪，但它运行得相当不错。通常在构建更大的系统时，服务发现几乎是强制性的，因此您不必在现场担心这样的低级细节。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered how to build multiple containers to make a basic
    service composed of a web server, application server, and the database, launch
    multiple containers together, and tie them together with networking. We also worked
    through what the most common issues might be when connecting services and what
    the common pitfalls with these basic building blocks are. Some hints about future
    topics were also given (volumes, service discovery, credentials passing, and so
    on), but we will cover those in later chapters in depth. In the next chapter, we
    will be turning our little service into a robust service with horizontally scaled
    components.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何构建多个容器，以构建由Web服务器、应用服务器和数据库组成的基本服务，同时启动多个容器，并通过网络将它们连接在一起。我们还解决了连接服务时可能出现的最常见问题，以及这些基本构建模块的常见陷阱。还提到了一些关于未来主题的提示（卷、服务发现、凭据传递等），但我们将在以后的章节中深入讨论这些内容。在下一章中，我们将把我们的小服务转变成具有水平扩展组件的强大服务。

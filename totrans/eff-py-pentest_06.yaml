- en: Chapter 6. Debugging and Reverse Engineering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debuggers are the main tools used for reverse engineering. With debuggers, we
    can perform analysis at runtime to understand the program. We can identify the
    call chains and track indirect calls. With debuggers, we can analyze and watch
    program runtime to guide our reverse engineering. In this chapter, we'll learn
    how to use debuggers in our scripts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Portable executable analysis
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disassembling with Capstone
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PEfile with Capstone
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging using PyDBG
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse engineering
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three main kinds of reverse engineering analysis:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '**Static analysis**: Analysis of the contents of a binary file. This helps
    to determine the structure of the executable portions and print out readable portions
    to get more details about the purpose of the executable.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic analysis**: This type will execute the binary with or without attaching
    a debugger to discover what the purpose is and how the executable works.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hybrid analysis**: This is a mixture of static and dynamic analysis. Repeating
    between static analyses, followed by a dynamic debugging, will give better intuition
    about the program.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Portable executable analysis
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any UNIX or Windows binary executable file will have a header to describe its
    structure. This includes the base address of its code, data sections, and a list
    of functions that can be exported from the executable. When an executable file
    is executed by the operating system, first of all the operating system reads its
    header information and then loads the binary data from the binary file to populate
    the contents of the code and data sections of the address for the corresponding
    process.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: A **Portable Executable** (**PE**) file is the file type that a Windows operating
    system can execute or run. The files that we run on Windows systems are Windows
    PE files; these can have EXE, DLL (Dynamic Link Library), and SYS (Device Driver)
    extensions. Also, they contain the PE file format.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Binary executable files on Windows have the following structure:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: DOS Header (64 bytes)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PE Header
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sections (code and data)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now examine each of them in detail.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: DOS header
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The DOS Header starts with the magic numbers `4D 5A 50 00` (the first two bytes
    are the letters `MZ`), and the last four bytes (`e_lfanew`) indicates the location
    of the PE header in the binary executable file. All other fields are not relevant.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: PE header
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The PE header contains more interesting information. The following is the structure
    of the PE header:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![PE header](img/image_06_001-2.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: 'The PE header consists of three parts:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 4-byte magic code
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 20-byte file header, whose data type is **IMAGE_FILE_HEADER**
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 224-byte optional header, whose data type is **IMAGE_OPTIONAL_HEADER32**
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, the optional header has two parts. The first 96 bytes contain information
    such as major operating systems and entry point. The second part consists of 16
    entries with 8 bytes in each entry, to form a data directory of 128 bytes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can read more about PE files at: [http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx](http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx) and 
    structures used within the file headers at: [http://msdn2.microsoft.com/en-gb/library/ms680198.aspx](http://msdn2.microsoft.com/en-gb/library/ms680198.aspx).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `pefile` module (a multi-platform full Python module intended
    for handling PE files) to get all the details of these file headers in Python.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Loading PE file
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Loading a file is as simple as creating an instance of the PE class in the module
    with the path to the executable as the argument.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the module `pefile`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Initiate the instance with the executable:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Inspecting headers
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an interactive terminal, we can do a basic inspection of PE file headers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, import the `pefile` and load the executable:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will print the object. To better understand, we can use the `pprint` module
    to print this object in a readable format:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will list all in a readable format, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting headers](img/image_06_002-2.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: 'We can also print the contents of a specific header as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can get the hex value of each header with hex():'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Inspecting sections
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To inspect sections in the executable, we have to iterate `pe.sections`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: PE packers
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Packers** are the tools used to compress PE files. This will reduce the size
    of the file as well as adding another layer of obfuscation to the file being reverse
    engineered statically. Even though packers were created to decrease the overall
    file size of executables, later, the benefits of obfuscation were used by many
    malware authors. Packers wrap the compressed data inside a working PE file structure
    and decompress the PE file data into memory, and run it while executing.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: We can use signature databases to detect the packer used if the executable is
    packed. Signature database files can be found by searching the Internet.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: For this we require another module, `peutils`, which comes with the `pefile`
    module.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'You can load the signature database from a local file or from a URL:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also use the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After loading the signature database, we can run the PE instance with this
    database to identify the signature for the packer used:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will output the possible packer used.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Also, if we check the section names in the packed executable, they will have
    a slight difference. For example, an executable which is packed with UPX, its
    section names will be `UPX0`, `UPX1`, and so on.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Listing all imported and exported symbols
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The imports can be listed as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Likewise, we can''t list the exports:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Disassembling with Capstone
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Disassembling** is the opposite process of assembling. Disassemblers try
    to create the assembly code from the binary machine code. For this, we are using
    a Python module named **Capstone**. Capstone is a free, multiplatform and multi-architecture
    disassembler engine.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: After installation, we can use this module in our Python scripts.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to run a simple test script:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of the script will be as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The first line imports the module, then initiates the `capstone` Python class
    with `Cs`, which takes two arguments: hardware architecture and hardware mode.
    Here we instruct to disassemble 64 bit code for x86 architecture.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The next line iterates the code list and passes the code to the `disasm()` in
    the `capstone` instance `cs`. The second parameter for `disasm()` is the address
    of the first installation. The output of `disasm()` is a list of installations
    of type `Cslnsn`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we print out some of this output. `Cslnsn` exposes all internal information
    about the disassembled installations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of these are as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '**Id**: Instruction ID of the instruction'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Address**: Address of the instruction'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mnemonic**: Mnemonic of the instruction'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**op_str**: Operand of the instruction'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**size**: Size of the instruction'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**byte**: The byte sequence of the instruction'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like this, we can disassemble binary files with Capstone.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: PEfile with Capstone
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we use the `capstone` disassembler to disassemble the code we extracted
    with `pefile` to get the assemble code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we start by importing the required modules. Here, these are `capstone`
    and `pefile`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `AddressofEntryPoint` value within the `IMAGE_OPTIONAL_HEADER` is the pointer
    to the entry point function relative to the image base address. In the case of
    executable files, this is the exact point where the code of the application begins.
    So, we get the starting of the code with the help of `pefile` as `pe.OPTIONAL_HEADER.AddressOfEntryPoint` 
    and pass this to the disassembler.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging is the process of fixing bugs in a program. Debuggers are those programs
    that can run and watchdog the execution of another program. So, the debugger can
    have control over the execution of the target program and can monitor or alter
    the memory and variables of the targeted program.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoints
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Breakpoints help to stop the execution of the target program within the debugger
    at a location where we choose. At that time, execution stops and control is passed
    to the debugger.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 断点有助于在调试器中选择的位置停止目标程序的执行。在那时，执行停止并控制传递给调试器。
- en: 'Breakpoints come in two different forms:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 断点有两种不同的形式：
- en: '**Hardware Breakpoints**: Hardware breakpoints require hardware support from
    the CPU. They use special debug registers. These registers contain the breakpoint
    addresses, control information, and breakpoint type.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件断点**：硬件断点需要CPU的硬件支持。它们使用特殊的调试寄存器。这些寄存器包含断点地址、控制信息和断点类型。'
- en: '**Software Breakpoints**: A software breakpoint replaces the original instruction
    with an instruction that traps the debugger. This can only break on execution.
    The main difference between them is that hardware breakpoints can be set on memory.
    But, software breakpoints cannot be set on memory.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件断点**：软件断点用一个陷阱调试器的指令替换原始指令。这只能在执行时中断。它们之间的主要区别是硬件断点可以设置在内存上。但是，软件断点不能设置在内存上。'
- en: Using PyDBG
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PyDBG
- en: We can use the PyDBG module to debug executables in run time. We can go through
    a basic script with PyDBG to understand how it works.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用PyDBG模块在运行时调试可执行文件。我们可以通过一个基本的PyDBG脚本来了解它的工作原理。
- en: 'First, we import the modules:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入模块：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we define a function to handle the breakpoint. Also, it takes the `pydbg`
    instance as the argument. Inside this function, it prints out the execution context
    of the process and instructs `pydbg` to continue:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义一个处理断点的函数。它也将`pydbg`实例作为参数。在这个函数内部，它打印出进程的执行上下文，并指示`pydbg`继续执行：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then we initialize the `pydbg` instance and set the `handler_breakpoint` function
    to handle the breakpoint exception:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们初始化`pydbg`实例，并设置`handler_breakpoint`函数来处理断点异常：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then attach the process ID of the process which we need to debug using `pydbg`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后附加需要使用`pydbg`调试的进程的进程ID：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next we will set the address at which to trigger the breakpoint. Here, we use
    `bp_set()` function, which accepts three arguments. The first is the address at
    which to set the breakpoint, the second is an optional description, and the third
    argument indicates whether `pydbg` restores this breakpoint:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将设置触发断点的地址。在这里，我们使用`bp_set()`函数，它接受三个参数。第一个是设置断点的地址，第二个是可选的描述，第三个参数指示`pydbg`是否恢复此断点：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, start `pydbg` in the event loop:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在事件循环中启动`pydbg`：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this example, we pass the breakpoint as an argument to this script. So,
    we can run this script as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将断点作为参数传递给这个脚本。所以，我们可以按照以下方式运行这个脚本：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`pydbg` contains many other useful functionalities that can be found in the
    documentation at: [http://pedramamini.com/PaiMei/docs/PyDbg/public/pydbg.pydbg.pydbg-class.html](http://pedramamini.com/PaiMei/docs/PyDbg/public/pydbg.pydbg.pydbg-class.html).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`pydbg`包含许多其他有用的功能，可以在文档中找到：[http://pedramamini.com/PaiMei/docs/PyDbg/public/pydbg.pydbg.pydbg-class.html](http://pedramamini.com/PaiMei/docs/PyDbg/public/pydbg.pydbg.pydbg-class.html)。'
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have discussed the basic tools that can be used to programmatically reverse
    engineer and debug binary files with Python. Now you will be able to write custom
    scripts to debug and reverse engineer the executables, which will help in malware
    analysis. We will discuss some crypto, hash, and conversion functions with Python
    in the next chapter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了可以用Python编程逆向工程和调试二进制文件的基本工具。现在你将能够编写自定义脚本来调试和逆向工程可执行文件，这将有助于恶意软件分析。我们将在下一章讨论一些Python中的加密、哈希和转换函数。

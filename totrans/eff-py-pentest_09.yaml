- en: Chapter 9. Attack Automation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automating tools enable us to explore and exploit more vulnerabilities than
    any manual method possibly could. In my opinion, nothing beats manual security
    testing combined with a set of automated sections performed by an experienced
    security specialist. Sophisticated scripts can split the attack between several
    hosts and avoid being blacklisted.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: SFTP automations with paramiko
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nmap automation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: W3af REST API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metasploit scripting with MSGRPC
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OWASP zap API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking captcha
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing BeEF API with Python
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing Nessus 6 API with Python
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paramiko
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running commands in remote systems via SSH is one of the most common components
    of automation. The Python module paramiko makes this easy by providing a programmatic
    interface to SSH. Paramiko gives you an easy way to use SSH functions in Python
    through an imported library. This allows us to drive SSH tasks, which you would
    normally perform manually.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Establish SSH connection with paramiko
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main class of paramiko is `paramiko.SSHClient`, which provides a basic
    interface to initiate server connections:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![Establish SSH connection with paramiko](img/1-1.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: This will create a new SSHClient instance, and we then call the `connect()`
    method, which connects to the SSH server.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'When we connect to a remote machine with any SSH client, that remote host''s
    key will be automatically stored in the `.ssh/known_hosts` file in our home directory.
    So, the first time we connect to a remote system, we will get a message, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Establish SSH connection with paramiko](img/4323OS_09_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: 'When you type `yes` for this message, it will add an entry in the `known_hosts`
    file. By accepting this message, a level of trust is added for that host. The
    same rule is applicable for paramiko. By default, the SSHClient instance will
    refuse to connect a host that does not have a key saved in our `known_hosts` file.
    This will create problems when creating automation scripts. We can set the host
    key policy to add missing host keys automatically with paramiko as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, the script to connect to `ssh` with auto-add host keys will be as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![Establish SSH connection with paramiko](img/2-1.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: Running commands with paramiko
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now connected to the remote host with paramiko. We can then run commands
    on the remote host using this connection:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The response data will be the tuple (`stdin`, `stdout`, `stderr`), and we could
    read the output and write to input. For example, if we are running a command which
    requires an input, we could use `stdin`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this, we could create an interactive shell that could automate many tasks.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: SFTP with paramiko
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also use paramiko to handle file manipulations on a remote host with
    SFTP.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**SFTP** stands for **SSH File Transfer Protocol**, or **Secure File Transfer
    Protocol**. It is a separate protocol that works almost the same as FTP over a
    secure connection with SSH.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we first instantiate a new `paramiko.SSHClient` instance as before:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![SFTP with paramiko](img/3.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: Then we use `open_sftp()` after connecting to the remote host, which will return
    a `paramiko.SFTPClient` client object. The `paramiko.SFTPClient` will support
    all the SFTP operations. Here, we listed the files in the root of the remote server.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `get()` method to download and the `put()` method to upload files
    with paramiko.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'To download the remote password file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To upload a file to a remote host:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: python-nmap
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Network Mapper** (**Nmap**) is a free and open-source tool used for network
    discovery and security auditing. It runs on all major computer operating systems,
    and official binary packages are available for Linux, Windows, and Mac OS X. The
    `python-nmap` library helps to programmatically manipulate scanned results of
    `nmap` to automate port scanning tasks.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we have to import the module `nmap` after installing `python-nmap`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Instantiate the `nmap` port scanner:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Set `host` and `port` range to scan:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 设置要扫描的`host`和`port`范围：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We could print the `command_line` command used for the scan:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打印用于扫描的`command_line`命令：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also, we could get the `nmap` scan information:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以获取`nmap`扫描信息：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we scan all the hosts:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们扫描所有主机：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also scan all protocols:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还扫描所有协议：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This script will provide an output like the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将提供以下输出：
- en: '![python-nmap](img/image_09_002.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![python-nmap](img/image_09_002.jpg)'
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You could get more options of `python-nmap` from here:  [https://bitbucket.org/xael/python-nmap](https://bitbucket.org/xael/python-nmap).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从这里获取更多关于`python-nmap`的选项：[https://bitbucket.org/xael/python-nmap](https://bitbucket.org/xael/python-nmap)。
- en: W3af REST API
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: W3af REST API
- en: '**Web Application audit and attack framework** (**W3af**) is a powerful and
    flexible environment for web vulnerability assessments and for exploiting web
    application vulnerabilities. It has many plugins that could communicate with each
    other. For instance, the discovery plugin collects different URLs to test and
    pass on to the audit plugin, which uses these URLs to search for vulnerabilities.
    W3af could also exploit the vulnerabilities that it finds.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web应用程序审计和攻击框架**（**W3af**）是一个强大而灵活的环境，用于Web漏洞评估和利用Web应用程序漏洞。它有许多插件可以相互通信。例如，发现插件收集不同的URL进行测试，并传递给审计插件，审计插件使用这些URL来搜索漏洞。W3af还可以利用它发现的漏洞。'
- en: 'W3af has eight different types of plugin:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: W3af有八种不同类型的插件：
- en: '**Discovery plugins**: Crawl the web application to find new URLs, forms, and
    many other interesting parts of the web application. These plugins run in a loop,
    and the output is fed as the input to the next plugin.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发现插件**：爬行Web应用程序以查找新的URL、表单和许多其他有趣的Web应用程序部分。这些插件在循环中运行，输出作为输入提供给下一个插件。'
- en: '**Audit plugins**: These are the main parts of W3af, and they take the output
    of discovery plugins as input and scan for all types of web application vulnerabilities
    like SQL, XSS injections, and others.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审计插件**：这些是W3af的主要部分，它们将发现插件的输出作为输入，并扫描各种Web应用程序漏洞，如SQL、XSS注入等。'
- en: '**Grep plugins**: Like the UNIX grep utility, they search each and every HTTP
    request and response to find unusual and interesting information. It can be anything
    like IPs, Error codes, e-mail IDs, credit card numbers, or even risky JavaScript
    codes.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Grep插件**：像UNIX grep实用程序一样，它们搜索每个HTTP请求和响应，以查找异常和有趣的信息。它可以是IP地址、错误代码、电子邮件ID、信用卡号，甚至是风险的JavaScript代码。'
- en: '**Bruteforce plugins**: These help to brute-force the basic HTTP authentications
    and form login authentications that are found during the discovery phase.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bruteforce插件**：这些插件有助于暴力破解在发现阶段发现的基本HTTP身份验证和表单登录身份验证。'
- en: '**Attack plugins**: This plugin will read the vulnerability objects from the
    knowledge base and try to exploit them.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**攻击插件**：此插件将从知识库中读取漏洞对象并尝试利用它们。'
- en: '**Mangle plugins**: These help to modify requests and responses based on regular
    expressions like sed editor.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mangle插件**：这些插件有助于基于sed编辑器的正则表达式修改请求和响应。'
- en: '**Evasion plugins**: These help to avoid simple **Intrusion Detection Rules**
    (**IDS**).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Evasion插件**：这些插件有助于避免简单的**入侵检测规则**（**IDS**）。'
- en: '**Output plugins**: These help to create output files in different file formats
    as reports.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出插件**：这些插件有助于创建不同文件格式的输出文件，如报告。'
- en: 'We could use the `w3af` API to connect to `w3af` and use these modules. First,
    we have to run the `w3af` API. To do this, get the `w3af` and run `w3af_api`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`w3af` API连接到`w3af`并使用这些模块。首先，我们必须运行`w3af` API。要做到这一点，获取`w3af`并运行`w3af_api`：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `w3af` API already has some configured profiles that can be used for particular
    tasks. For instance, the `OWASP_TOP10` profile includes several discovery, audit,
    and grep plugins to perform OWASP Top 10 security analysis. So, we could make
    use of those profile files, or we could create our own profiles to run the `w3af`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`w3af` API已经配置了一些可用于特定任务的配置文件。例如，`OWASP_TOP10`配置文件包括几个发现、审计和grep插件，用于执行OWASP
    Top 10安全性分析。因此，我们可以使用这些配置文件，或者我们可以创建自己的配置文件来运行`w3af`。'
- en: 'Use the `w3af_api_client` to access `w3af_api` from scripts. Install `w3af_api_client`
    and import it:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`w3af_api_client`从脚本中访问`w3af_api`。安装`w3af_api_client`并导入它：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we can create a connection to the `w3af` API. This will be running at port
    `5000`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建到`w3af` API的连接。这将在端口`5000`上运行：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can make sure the connection is proper by checking its version:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查其版本来确保连接正确：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we can define the profile file and the target URL to scan:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义配置文件和要扫描的目标URL：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we instantiate the scan instance:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实例化扫描实例：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we can start the scan:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始扫描：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After starting the scan we could get the findings, URLs, and logs:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 开始扫描后，我们可以获取发现、URL和日志：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We could get the `fuzzable` URLs with the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下方法获取`fuzzable` URL：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As W3af is a Python tool, we can import `w3af` as a module in our scripts and
    use its functionalities in our script. For that, we have to download `setup.py`
    for `w3af`. We can get the whole module's files from [https://github.com/andresriancho/w3af-module](https://github.com/andresriancho/w3af-module).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于W3af是一个Python工具，我们可以在脚本中将`w3af`作为模块导入并在脚本中使用其功能。为此，我们必须下载`w3af`的`setup.py`。我们可以从[https://github.com/andresriancho/w3af-module](https://github.com/andresriancho/w3af-module)获取整个模块的文件。
- en: Download this module and verify that the sub-module folder `w3af` has all the
    files in it. If not, download the `w3af` folder from [https://github.com/andresriancho/w3af](https://github.com/andresriancho/w3af)
    and replace that folder.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下载此模块并验证子模块文件夹`w3af`中是否包含所有文件。如果没有，请从[https://github.com/andresriancho/w3af](https://github.com/andresriancho/w3af)下载`w3af`文件夹并替换该文件夹。
- en: 'Then, run the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下命令：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will install `w3af` as a Python module. Next, we can import it, as we
    do for other Python modules:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装`w3af`作为Python模块。接下来，我们可以像导入其他Python模块一样导入它：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Alternatively, we could import other `w3af` modules such as:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以导入其他`w3af`模块，例如：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Metasploit scripting with MSGRPC
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MSGRPC的Metasploit脚本
- en: '**Metasploit** is an open-source project that provides public resources for
    developing, testing, and executing exploits. It can also be used to create security
    testing tools, exploit modules, and as a penetration testing framework.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Metasploit is written in Ruby and it does not support modules or scripts written
    in Python.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: However, Metasploit does have a MSGRPC, Bidirectional RPC (Remote Procedure
    Call) interface using MSGPACK. The `pymetasploit` Python module helps to interact
    between Python and Metasploit's `msgrpc`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'So before scripting, we have to load `msfconsole` and start the `msgrpc` service.
    Next, let''s start Metasploit and the MSGRPC interface. We could start MSGRPC
    with `msfrpcd` in Metasploit. Here are the full options for `msfrpcd`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![Metasploit scripting with MSGRPC](img/image_09_007.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: 'To start MSGRPC with the password `123456`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![Metasploit scripting with MSGRPC](img/image_09_008.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: Now that Metasploit's RPC interface is listening on port `55553`. We can proceed
    to write our Python script.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with MSGRPC is almost similar to interacting with `msfconsole`.
    First, we have to create an instance of the `msfrpc` class. Then, log in to the
    `msgrpc` server with the credentials, and create a virtual console.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the PyMetasploit Python module to automate the exploitation tasks
    with Python. Clone the module from [https://github.com/allfro/pymetasploit](https://github.com/allfro/pymetasploit):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Move to the following module folder:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Install the module:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we can import the module in our scripts:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we can create a new instance for `MsfRpcClient`. We have to authenticate
    into the Metasploit to run any commands in it. So, pass the password to authenticate
    to Metasploit:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can navigate through the core Metasploit functionalities with this instance:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will list the core functionalities. Now we can list the auxiliary options:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Similarly, we can list all the core modules of exploits, encoders, payloads,
    and post, using the same syntax. We can activate one of these modules with the
    use method:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then we can set the parameters:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, run the module:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If the execution was successful, then the output will be as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If this fails, the `job_id` will be none.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we can use the sessions method to access the shells and consoles if the
    attack was a success:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will list all current active sessions. If the attack provides shell access
    to the victim, then we can get the available shells and access them with the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can also connect to the console and run the commands as we do in the `msfconsole`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the modules:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create the client:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create console with the client:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we can use this instance to run Metasploit commands as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The output will print in the console itself.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Here we used the PyMetasploit module, but we can also use the msgrpc module
    ([https://github.com/SpiderLabs/msfrpc](https://github.com/SpiderLabs/msfrpc)).
    This will help us to get access to underlying functions and to handle the results
    and console output within the scripts.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: ClamAV antivirus with Python
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use pyClamd, an open-source Python module, to use the ClamAV antivirus
    engine on Linux, MacOSX, and Windows. To use ClamAV programmatically from Python,
    you have to run an instance of the `clamd` daemon.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can install ClamAV in Windows, Linux, and MacOSx. To install it in Windows
    and Linux, refer to the official ClamAV documentation at [http://www.clamav.net/documents/installing-clamav](http://www.clamav.net/documents/installing-clamav).
    To install in MacOSX, use homebrew.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: After installing ClamAV, configure it to work with the network socket or Unix
    socket. To do this, we have to update the `clamd` configurations. You can find
    two configuration files in the `/etc/clamav/` folder for Linux, `c:\clamAV\` for
    Windows, and at `/usr/local/etc/clamav` for MacOSX. The files are as follows: `freshclam.conf` and
    `clamd.conf`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'If you cannot find these configuration files, create them from sample config
    files, and update the database mirror URL in the `freshclam.conf` file. Freshclam
    will fetch the antivirus database updates, so we should immediately run it in
    order to get the initial database:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到这些配置文件，请从示例配置文件创建它们，并在`freshclam.conf`文件中更新数据库镜像URL。Freshclam将获取防病毒数据库更新，因此我们应立即运行它以获取初始数据库：
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After updating the database mirror, download the ClamAV database with the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 更新数据库镜像后，使用以下命令下载ClamAV数据库：
- en: '[PRE44]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Enable the Unix socket or network socket in `clamd.conf`. To enable Unix socket,
    update `clamd.conf` with the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在`clamd.conf`中启用Unix套接字或网络套接字。要启用Unix套接字，请使用以下内容更新`clamd.conf`：
- en: '[PRE45]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now you can run the `clamd` daemon with `clamd` in a terminal window.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在终端窗口中使用`clamd`命令运行`clamd`守护程序。
- en: When installing `clamd` as a service in Windows, run the installer and let it
    install to the default location at `c:\clamav\`. Also, make sure you configure
    the Unix socket properly and that the location you specified in the `config` file
    exists.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中将`clamd`安装为服务时，请运行安装程序，并让其安装到默认位置`c:\clamav\`。还要确保正确配置Unix套接字，并且您在`config`文件中指定的位置存在。
- en: 'Then you can use `clamd` from the Python script. Import the `pyclamd` module:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以从Python脚本中使用`clamd`。导入`pyclamd`模块：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, try to connect to the `clamd` daemon with Unix socket and if it fails,
    try to connect with the network socket:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试使用Unix套接字连接到`clamd`守护程序，如果失败，则尝试使用网络套接字连接：
- en: '[PRE47]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can confirm the code by printing the `clamd` version:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过打印`clamd`版本来确认代码：
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, scan the file or folder for viruses:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，扫描文件或文件夹以查找病毒：
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This will output the details of virus signatures, if any are found.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现病毒签名，这将输出详细信息。
- en: Tip
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can get the full pyclamd documentation here: [http://xael.org/pages/python-module-pyclamd.html](http://xael.org/pages/python-module-pyclamd.html).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处获取完整的pyclamd文档：[http://xael.org/pages/python-module-pyclamd.html](http://xael.org/pages/python-module-pyclamd.html)。
- en: OWASP ZAP from Python
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Python中的OWASP ZAP
- en: '**OWASP ZAP** (**Zed Attack Proxy**) is an open-source, cross-platform web
    application security scanner written in Java, and is available in all the popular
    operating systems: Windows, Linux, and Mac OS X.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**OWASP ZAP**（**Zed Attack Proxy**）是一个开源的跨平台Web应用程序安全扫描器，用Java编写，并在所有流行的操作系统中都可用：Windows、Linux和Mac
    OS X。'
- en: OWASP ZAP provides a REST API, which allows us to write a script to communicate
    with Zap programmatically. We can use the `python-owasp-zap` module to access
    this API. The `python-owasp-zap-v2.4` module can be installed with pip.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP ZAP提供了一个REST API，允许我们编写脚本以编程方式与Zap通信。我们可以使用`python-owasp-zap`模块来访问此API。可以使用pip安装`python-owasp-zap-v2.4`模块。
- en: 'Start by loading the required modules:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先加载所需的模块：
- en: '[PRE50]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Define the target to scan:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 定义要扫描的目标：
- en: '[PRE51]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we can instantiate the `zap` instance, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实例化`zap`实例，如下所示：
- en: '[PRE52]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This will instantiate a new instance with the assumption `zap` listens in the
    default port `8080`. If Zap listens a non-default port, then we have to pass the
    custom proxy settings as the parameters, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用假设`zap`在默认端口`8080`上监听来实例化一个新实例。如果Zap监听非默认端口，则必须将自定义代理设置作为参数传递，如下所示：
- en: '[PRE53]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Set the target and start a session in `zap`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 设置目标并在`zap`中启动会话：
- en: '[PRE54]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It would be better to wait for some time, so that the URL list gets updated
    in `zap`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最好等一段时间，以便URL列表在`zap`中得到更新：
- en: '[PRE55]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we can start the spidering task:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始爬虫任务：
- en: '[PRE56]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can start a passive scan with the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令开始被动扫描：
- en: '[PRE57]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, we can use `pprint` to print the alerts:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`pprint`来打印警报：
- en: '[PRE58]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This gives us the alerts from `zap`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了来自`zap`的警报。
- en: Breaking weak captcha
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 破解弱验证码
- en: A **captcha** (**Completely Automated Public Turing test to tell Computers and
    Humans Apart**) is a type of challenge-response test to ensure that the response
    is generated by a human. It helps to prevent bots from sending spam, fraudulent
    registrations, fake sweepstakes entries, and so on.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**验证码**（**Completely Automated Public Turing test to tell Computers and Humans
    Apart**）是一种挑战-响应测试，用于确保响应是由人类生成的。它有助于防止机器人发送垃圾邮件、欺诈性注册、虚假的抽奖参与等。'
- en: Many sites implement their own captcha, and in such cases we can get the captcha
    image from the source. This can be a link that generates an image with a new random
    digit every time we access the URL. Hence, to bypass the captcha, we need to get
    the random number or word in that image.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网站实施自己的验证码，在这种情况下，我们可以从源获取验证码图像。这可以是一个链接，每次访问URL时都会生成一个带有新随机数字的图像。因此，为了绕过验证码，我们需要获取该图像中的随机数字或单词。
- en: We have already learnt how to send the post requests automatically with Python.
    Here we can learn to get the random code from the image. We can use the `pytesseract`
    Python moduleto read the image with an **optical character reader** (**OCR**)
    engine.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用Python自动发送post请求。在这里，我们可以学习如何从图像中获取随机代码。我们可以使用`pytesseract` Python模块来读取带有**光学字符识别**（**OCR**）引擎的图像。
- en: Tip
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can read more on pytesseract here to install it on your system: [https://github.com/madmaze/pytesseract](https://github.com/madmaze/pytesseract).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处阅读更多关于pytesseract的内容，以在您的系统上安装它：[https://github.com/madmaze/pytesseract](https://github.com/madmaze/pytesseract)。
- en: 'As usual, we can import the required modules:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们可以导入所需的模块：
- en: '[PRE59]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Download the captcha image and save it:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下载验证码图像并保存：
- en: '[PRE60]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Read the image with the OCR engine:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OCR引擎读取图像：
- en: '[PRE61]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This will print out the word in captcha. At times, it requires some image manipulations,
    according to the noise used in the captcha image. We can use `PIL` library features
    for this purpose. Here is an example for making the letters bold:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出验证码中的单词。有时，根据验证码图像中使用的噪音，需要进行一些图像操作。我们可以使用`PIL`库的功能来实现这一目的。以下是一个使字母加粗的示例：
- en: '[PRE62]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Then, use this output image to feed the OCR engine. After getting the word in
    the captcha image, we can post the form with the captcha value filled in.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用此输出图像来输入OCR引擎。在获取验证码图像中的单词后，我们可以填写验证码值并提交表单。
- en: Tip
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For better accuracy, we can train the OCR engine. To read more on training the
    Tesseract: [https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract](https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Automating BeEF with Python
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Browser Exploitation Framework** (**BeEF**) is a security tool that advantages
    browser vulnerabilities to assess the security issues of the target. BeEF is a
    framework which provides client-side attack vectors for the security testers.
    Also, it allows us to select specific modules for each browser and context. This
    section will discuss how to use the REST API that is available with the framework
    to automate the tasks and its features.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: BeEF focuses on the context of customers using a JavaScript hook. It create
    a botnet that can be controlled from a control panel. When a user navigates a
    website which contains a hook, that browser will automatically become part of
    that botnet. Then an attacker can send instructions to a hook to perform tasks
    on the hooked web browser of the victim. This will give access to the basic information
    about the web browser, enable or disable plugins and extensions, or can force
    navigation to another website. As it is a  simple JavaScript file running in the
    context of the web page visited by the victim, closing this website including
    the hook will disconnect the browser from the botnet and thus solve the problems.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Installing BeEF
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: BeEF is developed in Ruby. So, it requires Ruby interpreter installed on your
    system. Usually, it is a bit difficult to work with multiple tools like BeEF and
    Metasploit as both are developed in Ruby  and use different versions of Ruby.
    So, it would be better to use **Ruby Version Manager** (**RVM**) to manage multiple
    versions of Ruby on your system.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: You can have a look at the official website of RVM  here [https://rvm.io](https://rvm.io).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: It will help to make things easier and you'll save a lot of time.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'To install BeEF, download the latest version of the project from GitHub using
    the following command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then install the bundler:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then install the BeEF:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To run the BeEF  use the following command:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output will be as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing BeEF](img/Capture.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: To manage multiple victims from a web interface is inefficient and tedious.
    BeEF has a REST API that helps to automate many tasks. To access this API it requires
    an API key which is generated by BeEF when it starts.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Installing BeEF](img/4323OS_09_06.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: Connecting BeEF with Metasploit
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'BeEF can be integrated with Metasploit and run exploits and payloads in hooked
    victim browsers. To use the Metasploit extension, we have to start the MSGRPC
    with the `msfrpcd` utility in the Metasploit framework as we done before. In addition
    to that, we have to enable the Metasploit extension available in the BeEF, to edit
    the master configuration file in the root of the BeEF folder (`config.yaml`) and
    enable Metasploit extensions in the `"extension"` section by changing:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The main configuration file is ready to support the Metasploit extension and
    the MSGRPC service has started. Now, we have to update the extension settings
    to update connection details to the MSGRPC server. To do this, edit the configuration
    file of the Metasploit extension (`extensions/metasploit/config.xml`):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting BeEF with Metasploit](img/4323OS_09_07.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can start the BeEF. There will be an extra notification which indicates
    the number of  loaded Metasploit exploits if the connection is successful as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting BeEF with Metasploit](img/Capture-2.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: Accessing BeEF API with Python
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Rest API of BeEF has almost everything required to automate activities that
    can be done from the Wed UI. This API is not very complicated as it is only required
    to send HTTP requests with the correct parameters. So, it is possible to use Python
    to automate these HTTP requests using different libraries.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in previous chapters, Python has many libraries for handling
    HTTP requests like  `urllib`, `urllib2`, `httplib`,  and `requests`. Here, we
    will use a simple library called BeEF-API written with the `requests` module.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中讨论的，Python有许多处理HTTP请求的库，如`urllib`、`urllib2`、`httplib`和`requests`。在这里，我们将使用一个简单的库，称为BeEF-API，它是使用`requests`模块编写的。
- en: We can download the BeEF-API Python library from GitHub [https://github.com/byt3bl33d3r/BeEF-API](https://github.com/byt3bl33d3r/BeEF-API).
    To install it you only need to run the `setup.py` script with the parameter `install`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从GitHub [https://github.com/byt3bl33d3r/BeEF-API](https://github.com/byt3bl33d3r/BeEF-API)下载BeEF-API
    Python库。要安装它，只需运行带有参数`install`的`setup.py`脚本。
- en: 'Then, we can import the `BeefAPI` module and login to the BeEF-API:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以导入`BeefAPI`模块并登录到BeEF-API：
- en: '[PRE69]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, we can list all the loaded modules with:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以列出所有加载的模块：
- en: '[PRE70]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We can search the modules for a specific string with:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码搜索特定字符串的模块：
- en: '[PRE71]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This will print all the modules with the string `firefox` in its name.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出所有名称中包含字符串`firefox`的模块。
- en: 'We can run a module against one or more hooked browsers, for that we have to
    obtain the corresponding browser object and then run the module on it by specifying
    the identifier of the module to be used against the browser. Each hooked browse
    object has a method called `run` which receives a numeric value that represents
    the identifier of a module as an argument:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以针对一个或多个挂钩浏览器运行一个模块，为此我们必须获取相应的浏览器对象，然后通过指定要针对浏览器使用的模块的标识符在其上运行该模块。每个挂钩浏览器对象都有一个名为`run`的方法，该方法接收表示模块标识符的数值作为参数：
- en: '[PRE72]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The module with the identifier `231` is the *replace videos* module. This module
    will rewrite all the href attributes of all the matched links. The `run` method
    will execute the specified module and return a structure in the `.json` format
    with an identifier (`command_id`) of the command, which will be subsequently used
    to obtain the results returned by the module.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 具有标识符`231`的模块是*替换视频*模块。该模块将重写所有匹配链接的href属性。`run`方法将执行指定的模块，并以`.json`格式返回一个带有命令标识符(`command_id`)的结构，随后将用于获取模块返回的结果。
- en: Accessing Nessus 6 API with Python
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python访问Nessus 6 API
- en: Nessus is one of the popular vulnerability scanners developed by Tenable Network
    Security, which scans a computer and raises an alert if it discovers any vulnerabilities
    that an attacker could use to access any computer you have connected to a network.
    Nessus provides an API to access it programmatically. We can use any library to
    make HTTP requests, which abound in Python.  Tenable created a `python` library
    nessrest ([https://github.com/tenable/nessrest](https://github.com/tenable/nessrest))
    with the `requests`  module for using the Nessus 6  REST API.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Nessus是由Tenable Network Security开发的流行漏洞扫描器之一，它会扫描计算机，并在发现攻击者可能用来访问您连接到网络的任何计算机的漏洞时发出警报。Nessus提供了API以便以编程方式访问。我们可以使用Python中丰富的HTTP请求库来进行HTTP请求。Tenable创建了一个`python`库nessrest
    ([https://github.com/tenable/nessrest](https://github.com/tenable/nessrest))，其中使用了Nessus
    6的`requests`模块。
- en: 'To use this module in our Python script, import it as we did for other modules
    after installation. We can install the `nessrest` module with `pip`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的Python脚本中使用此模块，请在安装后导入它。我们可以使用`pip`安装`nessrest`模块：
- en: '[PRE73]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then, import it in our script:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的脚本中导入它：
- en: '[PRE74]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now we can initialize the scanner, as we are running Nessus with a self-signed
    certificate, we have to disable SSL certificate checking. For that, pass another
    parameter `insecure=True` to the `Scanner` initializer:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以初始化扫描器，因为我们正在使用自签名证书运行Nessus，所以我们必须禁用SSL证书检查。为此，将另一个参数`insecure=True`传递给`Scanner`初始化程序。
- en: '[PRE75]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'To add and launch a scan, specify the target and run the scan:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加和启动扫描，请指定目标并运行扫描：
- en: '[PRE76]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We can get the scan results with:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码获取扫描结果：
- en: '[PRE77]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Tip
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To know more about services that are available in Nessus 6, you can check the
    documentation included in the Nessus installation `https://localhost:8834/nessus6-api.html`.
    You have to start a Nessus instance to see this documentation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Nessus 6中可用的服务，可以查看Nessus安装中包含的文档`https://localhost:8834/nessus6-api.html`。您必须启动Nessus实例才能查看此文档。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have gone through some of the libraries which can be used for security automation.
    Now we are ready to use these modules in our scripts. This will help us to automate
    many security tasks. We can also use the results from one script or tool to another,
    thus cascading the tools to automate pentesting.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了一些可用于安全自动化的库。现在我们准备在我们的脚本中使用这些模块。这将帮助我们自动化许多安全任务。我们还可以将一个脚本或工具的结果用于另一个，从而级联工具以自动化渗透测试。
- en: This book brings insight into the basic usage of Python and its related modules,
    which helps the reader to attain profound knowledge in Penetration Testing. The
    chapters cover the fundamental ideas of performing security testing with Python,
    in a nutshell. The reader can attain unprecedented heights in security testing
    with the help of the techniques and resources presented in this book. The power
    of Python is yet to be harnessed in its entirety. Its outreach in security testing
    is broad, and we leave the reader at a crossroads, to explore this in more depth.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 本书深入探讨了Python及其相关模块的基本用法，帮助读者在渗透测试方面获得深入的知识。本书的章节概括了使用Python进行安全测试的基本思想。读者可以借助本书中介绍的技术和资源在安全测试方面取得前所未有的成就。Python的潜力尚未完全发挥。它在安全测试中的影响广泛，我们让读者自行探索更深入的内容。

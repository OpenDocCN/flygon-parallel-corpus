- en: Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We cover the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Building your own iterable range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making your own iterators compatible with STL iterator categories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using iterator wrappers to fill generic data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing algorithms in terms of iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating the other way around using reverse iterator adapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminating iterations over ranges with iterator sentinels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically checking iterator code with checked iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your own zip iterator adapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Iterators are an *extremely important concept* in C++. The STL aims to be as
    flexible and generic as possible, and iterators are a great help in that regard.
    Unfortunately, they are sometimes a bit tedious to use, which is why many novices
    *avoid* them and fall back to *C-Style C++*. A programmer who avoids iterators
    basically waives *half* the potential of the STL. This chapter deals with iterators
    and quickly casts some light on how they work. That very quick introduction is
    probably not enough, but the *recipes* are really here to give a good feeling
    for iterator internals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most container classes, but also old-school C-style arrays, in one or the other
    way, contain a *range* of data items. A lot of day-to-day tasks that process a
    lot of data items do not care how to get at that data. However, if we regard,
    for example, an array of integers and a *linked list* of integers and want to
    calculate the *sum* of all the items of both the structures, we would end up with
    two different algorithms, which could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One algorithm, which deals with the array by checking its size and summing
    it up as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Another algorithm, which deals with the linked list by iterating until it reaches
    its end:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Both of them are about *summing up integers*, but how large is the percentage
    of characters that we typed, which is directly related to the *actual* summing
    up task? And does one of them work with a third kind of data structure, let's
    say `std::map`, or do we have to implement another version of it? Without iterators,
    this would lead us into ridiculous directions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Only with the help of iterators is it possible to implement this in a generic
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This pretty and short, so-called, range-based `for` loop has been in existence
    since C++11\. It is just a syntax sugar, which expands to something similar to
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an old hat for everyone who has worked with iterators already and looks
    completely magic for everyone who didn''t. Imagine our vector of integers looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fd26991-6353-4490-b01b-959c754fe5b5.png)'
  prefs: []
  type: TYPE_IMG
- en: The `std::begin(vector)` command is the same as `vector.begin()` and returns
    us an iterator that points to the first item (the **1**). `std::end(vector)` is
    the same as `vector.end()` and returns an iterator that points at one item *past
    the last* item (past the **5**).
  prefs: []
  type: TYPE_NORMAL
- en: In every iteration, the loop checks if the begin iterator is non-equal to the
    end iterator. If so, it will *dereference* the begin iterator and thus access
    the integer value it points to. Then, it *increments* the iterator, repeats the
    comparison against the end iterator, and so on. In that moment, it helps to read
    the loop code again while imagining that the iterators are plain *C*-style pointers.
    In fact, plain C-style pointers are also a valid kind of iterators.
  prefs: []
  type: TYPE_NORMAL
- en: Iterator categories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple categories of iterators, and they have different limitations.
    They are not too hard to memorize, just remember that the capabilities one category
    requires are inherited from the next powerful category. The whole point of iterator
    categories is that if an algorithm knows what kind of iterator it is dealing with,
    it can be implemented in an optimized way. This way, the programmer can lean back
    and express his intent, while the compiler can choose the *optimal implementation*
    for the given task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through them in the right order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9d1c3e9-25b2-45d2-9630-3759bef7cb1d.png)'
  prefs: []
  type: TYPE_IMG
- en: Input iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Input iterators can be dereferenced only for *reading* the values they point
    to. Once they are incremented, the last value they pointed to has been *invalidated*
    during the incrementation. This means that it is not possible to iterate over
    such a range multiple times. The `std::istream_iterator` is an example for this
    category.
  prefs: []
  type: TYPE_NORMAL
- en: Forward iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forward iterators are the same as input iterators, but they differ in that regard
    that the ranges they represent can be iterated over multiple times. The `std::forward_list`
    iterators are an example of that. Such a list can only be iterated over *forward*,
    not backward, but it can be iterated over as often as we like to.
  prefs: []
  type: TYPE_NORMAL
- en: Bidirectional iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bidirectional iterator, as the name suggests, can be incremented and decremented,
    in order to iterate forward or backward. The iterators of `std::list`, `std::set`,
    and `std::map`, for example, support that.
  prefs: []
  type: TYPE_NORMAL
- en: Random access iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Random access iterators allow jumping over multiple values at once, instead
    of single-stepping. This is the case for iterators of `std::vector` and `std::deque`.
  prefs: []
  type: TYPE_NORMAL
- en: Contiguous iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This category specifies all of the aforementioned requirements, plus the requirement
    that the data that is being iterated through lies in contiguous memory, like it
    does in an array, or `std::vector`.
  prefs: []
  type: TYPE_NORMAL
- en: Output iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Output iterators are detached from the other categories. This is because an
    iterator can be a pure output iterator, which can only be incremented and used
    to *write* to the data it points to. If they are being read from, the value will
    be undefined.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If an iterator is an output iterator and one of the other categories at the
    same time, it is a mutable iterator. It can be read from and written to. If we
    obtain an iterator from a non-const container instance, it will usually be of
    this kind.
  prefs: []
  type: TYPE_NORMAL
- en: Building your own iterable range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already realized that iterators are, kind of, the *standard interface* for
    iterations over containers of all kinds. We just need to implement the prefix
    increment operator, `++`, the dereference operator, `*`, and the object comparison
    operator, `==`, and then we already have a primitive iterator that fits into the
    fancy C++11 range-based `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get used to this a bit more, this recipe shows how to implement
    an iterator that just emits a range of numbers when iterating through it. It is
    not backed by any container structure or anything similar. The numbers are generated
    ad hoc while iterating.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will implement our own iterator class, and then, we will
    iterate through it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we include the header, which enables us to print to the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Our iterator class will be called `num_iterator`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Its only data member is an integer. That integer is used for counting. The
    constructor is for initializing it. It is generally a good form to make constructors
    *explicit*, which create a type from another type to avoid *accidental* implicit
    conversion. Note that we also provide a default value for `position`. This makes
    the instances of the `num_iterator` class default-constructible. Although we will
    not use the default constructor in the whole recipe, this is really important
    because some STL algorithms depend on iterators being default-constructible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When dereferencing our iterator (`*it`), it will emit an integer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Incrementing the iterator (`++it`) will just increment its internal counter,
    `i`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A `for` loop will compare the iterator against the end iterator. If they are
    *unequal*, it will continue iterating:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'That was the iterator class. We still need an intermediate object for writing
    `for (int i : intermediate(a, b)) {...}`, which then contains the begin and end
    iterator, which is preprogrammed to iterate from `a` to `b`. We call it `num_range`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It contains two integer members, which denote at which number the iteration
    shall start, and which number is the first number past the last number. This means
    if we want to iterate from `0` to `9`, `a` is set to `0` and `b` to `10`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There are only two member functions that we need to implement: the `begin`
    and `end` functions. Both return iterators that point to the beginning and the
    end of the numeric range:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. We can use it. Let''s write a main function which just iterates
    over a range that goes from `100` to `109` and prints all its values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program yields the following terminal output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider that we write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will evaluate it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'While looking at this code, it becomes obvious that the only requirements for
    the iterators are the following three operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`operator!=`: unequal comparison'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator++`: prefix increment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator*`: dereference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The requirements of the range are that it has a `begin` and an `end` method,
    which return two iterators that denote the beginning and the end of a range.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we're mostly using `std::begin(x)` instead of `x.begin()`. This
    is generally a good style because `std::begin(x)` automatically calls `x.begin()`
    if that member method is available. If `x` is an array that does not have a `begin()`
    method, `std::begin(x)` will automatically find out how to deal with it. The same
    applies to `std::end(x)`. User defined types that do not provide `begin()`/`end()`
    members do not work with `std::begin`/`std::end`.
  prefs: []
  type: TYPE_NORMAL
- en: What we did in this recipe is just fit a simple number counting algorithm into
    the forward iterator interface. Implementing an iterator and a range always involves
    this minimum amount of boilerplate code, which can be a little bit annoying on
    the one hand. A look at the loop that uses `num_range` is, on the other hand,
    very rewarding because it looks so *perfectly simple*!
  prefs: []
  type: TYPE_NORMAL
- en: Scroll back and have a thorough look on which of the methods of the iterator
    and the range class are `const`. Forgetting to make those functions `const` can
    make the compiler *reject* your code in a lot of situations because it is a common
    thing to iterate over `const` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Making your own iterators compatible with STL iterator categories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whatever own container data structure we come up with, in order to effectively
    *mix* it with all the STL goodness, we need to make them provide iterator interfaces.
    In the last section, we learned how to do that, but we do soon realize that *some*
    STL algorithms *do not compile* well with our custom iterators. Why?
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that a lot of STL algorithms try to find out more about the iterators
    they are asked by us to deal with. Different iterator *categories* have different
    capabilities, and hence, there might be different possibilities to implement the
    *same* algorithm. For example, if we copy *plain numbers* from one `std::vector`
    to another, this may be implemented with a fast `memcpy` call. If we copy data
    from or to `std::list`, this is *not* possible any longer and the items have to
    be copied individually one by one. The implementers of the STL algorithms put
    a lot of thought into this kind of automatic optimization. In order to help them,
    we can equip our iterators with some *information* about them. This section shows
    how to achieve the same.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement a primitive iterator that counts numbers
    and use it together with an STL algorithm, which initially does not compile with
    it. Then we do what's necessary to make it STL-compatible.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to include some headers, as always:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we implement a primitive number counting iterator, as in the previous
    section. When iterating over it, it will emit plain increasing integers. The `num_range`
    acts as a handy *begin* and *end* iterator donor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to keep the `std::` namespace prefix out and keep the code readable,
    we declare that we use namespace `std`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now just instantiate a range that goes from `100` to `109`. Note that
    the value `110` is the position of the end iterator. This means that `110` is
    the *first* number that is *outside* the range (which is why it goes from `100`
    to `109`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, we use it with `std::minmax_element`. This algorithm returns us `std::pair`
    with two members: an iterator pointing to the lowest value and another iterator
    pointing to the highest value in the range. These are, of course, `100` and `109`
    because that''s how we constructed the range:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling the code leads to the following error message. It''s some error related
    to `std::iterator_traits`. More on that later. It *might* happen that there are
    *other* errors on other compilers and/or STL library implementations or *no* errors
    at all. This error message occurs with clang version 5.0.0 (trunk 299766):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/52d1b385-6f1a-4731-97a4-4389d0e9047b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to fix this, we need to activate iterator trait functionality for
    our iterator class. Just after the definition of `num_iterator`, we write the
    following template structure specialization of the `std::iterator_traits` type.
    It tells the STL that our `num_iterator` is of the category forward iterator,
    and it iterates over `int` values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile it again; we can see that it works! The output of the min/max
    function is the following, which is just what we expect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some STL algorithms need to know the characteristics of the iterator type they
    are used with. Some others need to know the type of items the iterators iterate
    over. This has different implementation reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, all STL algorithms will access this type information via `std::iterator_traits<my_iterator>`,
    assuming that the iterator type is `my_iterator`. This traits class contains up
    to five different type member definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`difference_type`: What type results from writing `it1 - it2`?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value_type`: Of what type is the item which we access with `*it` (note that
    this is `void` for pure output iterators)?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pointer`: Of what type must a pointer be in order to point to an item?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reference`: Of what type must a reference be in order to reference an item?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iterator_category`: Which category does the iterator belong to?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pointer`, `reference`, and `difference_type` type definitions do not make
    sense for our `num_iterator`, as it doesn't iterate over real *memory* values
    (we just *return* `int` values but they are not persistently available like in
    an array). Therefore it's better to not define them because if an algorithm depends
    on those items being referenceable in memory, it might be *buggy* when combined
    with our iterator.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until C++17, it was encouraged to let iterator types just inherit from `std::iterator<...>`,
    which automatically populates our class with all the type definitions. This still
    works, but it is discouraged since C++17.
  prefs: []
  type: TYPE_NORMAL
- en: Using iterator adapters to fill generic data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a lot of situations, we want to fill any container with masses of data, but
    the data source and the container have *no common interface*. In such a situation,
    we would need to write our own hand-crafted algorithms that just deal with the
    question of how to shove data from the source to the sink. Usually, this distracts
    us from our actual work of *solving* a specific *problem*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tasks where we simply transport data between conceptually different data structures
    can be implemented with a one-liner code, thanks to another abstraction provided
    by the STL: **iterator adapters**. This section demonstrates the use of some of
    them in order to give a feeling how useful they are.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we use some iterator wrappers just for the sake of showing
    that they exist and how they can help us in everyday programming tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to include some headers first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Declaring that we use namespace `std` spares us some typing later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We start with `std::istream_iterator`. We specialize it on `int`. This way,
    it will try to parse the standard input to integers. For example, if we iterate
    over it, it will look as if it was `std::vector<int>`. The end iterator is instantiated
    of the same type but without any constructor arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Next, we instantiate `std::deque<int>` and just copy over all the integers from
    the standard input into the deque. The deque itself is not an iterator, so we
    wrap it into `std::back_insert_iterator` using the `std::back_inserter` helper
    function. This special iterator wrapper will execute `v.push_back(item)` with
    each of the items we get from the standard input. This way the deque is grown
    automatically!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next exercise, we use `std::istringstream` to copy items into the *middle*
    of the deque. So, let''s first define some example numbers in the form of a string
    and instantiate the stream object from it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Then, we need a hint of where to insert into the deque. It will be the middle,
    so we use the begin pointer of the deque and feed it to the `std::next` function.
    The second argument of this function says that it will return an iterator advanced
    by `v.size() / 2` steps, that is, *half* the deque. (We cast `v.size()` to `int`
    because the second parameter of `std::next` is `difference_type` of the iterator
    used as the first parameter. In this case, this is a signed integer type. Depending
    on the compiler flags, the compiler might *warn* at this point if we didn't cast
    explicitly.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can copy parsed integers step by step from the input string stream
    into the deque. Again, the end iterator of a stream iterator wrapper is just an
    empty `std::istream_iterator<int>` without constructor arguments (that is, the
    empty `{}` braces in the code line). The deque is wrapped into an inserter wrapper,
    which is an `std::insert_iterator`, which is pointed to the deque''s middle using
    the `deque_middle` iterator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use `std::front_insert_iterator` to insert some items at the front
    of the deque:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last step, we print the whole content of the deque out to the user shell.
    The `std::ostream_iterator` works like an output iterator which, in our case,
    just forwards all the integers it gets copied from to `std::cout` and then appends
    `", "` after each item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Compiling and running the program yields the following output. Can you identify
    which number was inserted by which code line?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used a lot of different iterator adapters in this section. They all have
    one thing in common, which is they wrap an object into an iterator that is not
    an iterator itself.
  prefs: []
  type: TYPE_NORMAL
- en: std::back_insert_iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `back_insert_iterator` can be wrapped around `std::vector`, `std::deque`,
    `std::list`, and so on. It will call the container's `push_back` method, which
    inserts the new item *past* the existing items. If the container instance is not
    large enough, it will be grown automatically.
  prefs: []
  type: TYPE_NORMAL
- en: std::front_insert_iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `front_insert_iterator` does exactly the same thing as `back_insert_iterator`,
    but it calls the container's `push_front` method, which inserts the new item *before*
    all the existing items. Note that for a container like `std::vector`, this means
    that all the existing items need to be moved one slot further in order to leave
    space for the new item at the front.
  prefs: []
  type: TYPE_NORMAL
- en: std::insert_iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This iterator adapter is similar to the other inserters, but is able to insert
    new items *between* existing ones. The `std::inserter` helper function which constructs
    such a wrapper takes two arguments. The first argument is the container and the
    second argument is an iterator that points to the position where new items shall
    be inserted.
  prefs: []
  type: TYPE_NORMAL
- en: std::istream_iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `istream_iterator` is another very handy adapter. It can be used with any
    `std::istream` object (which can be the standard input or files for example) and
    will try to parse the input from that stream object according to the template
    parameter it was instantiated with. In this section, we used `std::istream_iterator<int>(std::cin)`,
    which pulls integers out of the standard input for us.
  prefs: []
  type: TYPE_NORMAL
- en: The special thing about streams is that we often cannot know in advance how
    long the stream is. That leaves the question, where will the *end* iterator point
    to if we do not know where the stream's end is? The way this works is that the
    iterator *knows* when it reaches the end of the stream. When it is compared to
    the end iterator, it will effectively *not really* compare itself with the end
    iterator but return if the stream has any tokens *left*. That's why the end iterator
    constructor does not take any arguments.
  prefs: []
  type: TYPE_NORMAL
- en: std::ostream_iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ostream_iterator` is the same thing as the `istream_iterator`, but it
    works the other way around: It doesn''t take tokens *from* an *input* stream--it
    pushes tokens *into* an *output* stream. Another difference to `istream_iterator`
    is that its constructor takes a second argument, which is a string that shall
    be pushed into the output stream after each item. That is useful because this
    way we can print a separating `", "` or a new line after each item.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing algorithms in terms of iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Iterators usually iterate by *moving* their *position* from one item of a container
    to another. But they do not necessarily need to iterate over data structures at
    all. Iterators can also be used to implement algorithms, in which case, they would
    calculate the next value when they are incremented (`++it`) and return that value
    when they are dereferenced (`*it`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we demonstrate this by implementing the Fibonacci function
    in form of an iterator. The Fibonacci function is recursively defined like this:
    `F(n) = F(n - 1) + F(n - 2)`. It starts with the beginning values of `F(0) = 0`
    and `F(1) = 1`. This leads to the following number sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '`F(0) = 0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F(1) = 1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F(2) = F(1) + F(0) = 1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F(3) = F(2) + F(1) = 2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F(4) = F(3) + F(2) = 3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F(5) = F(4) + F(3) = 5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F(6) = F(5) + F(4) = 8`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '... and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we implement this in the form of a callable function that returns the Fibonacci
    value for any number, *n*, we will end up with a recursive self-calling function,
    or a loop implementation. This is fine, but what if we write some program where
    have to consume Fibonacci numbers in some pattern, one after the other? We would
    have two possibilities--either we recalculate all the recursive calls for every
    new Fibonacci number, which is a waste of computing time, or we save the last
    two Fibonacci numbers as temporary variables and use them to calculate the next.
    In the latter case, we reimplemented the Fibonacci algorithm loop implementation.
    It seems that we would end up *mixing* Fibonacci code with our actual code, which
    solves a different problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Iterators are an interesting way out of this. How about wrapping the steps that
    we do in the loop-based iterative Fibonacci implementation in the prefix increment
    `++` operator implementation of a Fibonacci value *iterator*? This is pretty easy,
    as this section demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we concentrate on implementing an iterator that generates numbers
    from the Fibonacci number sequence while iterating over it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to be able to print the Fibonacci numbers to the terminal, we need
    to include a header first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the Fibonacci iterator, `fibit`. It will carry a member `i`, which
    saves the index position in the Fibonacci sequence, and `a` and `b` will be the
    variables that hold the last two Fibonacci values. If instantiated with the default
    constructor, a Fibonacci iterator will be initialized to the value `F(0)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the standard constructor and another constructor, which allows
    us to initialize the iterator at any Fibonacci number step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When dereferencing our iterator (`*it`), it will just emit the Fibonacci number
    of the current step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When incrementing the iterator (`++it`), it will move its state to the next
    Fibonacci number. This function contains the same code as the loop-based Fibonacci
    implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When used in a loop, the incremented iterator is compared against an end iterator,
    for which we need to define the `!=` operator. We are only comparing the *step*
    at which the Fibonacci iterators currently reside, which makes it easier to define
    the end iterator for step `1000000`, for example, as we do not need to expensively
    calculate such a high Fibonacci number *in advance*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to be able to use the Fibonacci iterator in the range-based `for`
    loop, we have to implement a range class beforehand. We call it `fib_range`, and
    its constructor will accept one parameter that tells how far in the Fibonacci
    range we want to iterate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Its `begin` and `end` functions return iterators which point to the positions,
    `F(0)` and `F(end_n)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, now let''s forget about all the iterator-related boilerplate code. We
    do not need to touch it again as we have a helper class now which nicely hides
    all the implementation details from us! Let''s print the first 10 Fibonacci numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program yields the following shell output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to use this iterator with the STL, it must support the `std::iterator_traits`
    class. To see how to do that, have a look at the *other* recipe, which deals with
    exactly that matter: *Making your own iterators compatible with STL iterator categories.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to think in terms of iterators. This leads to very elegant code in many
    situations. Don''t worry about performance: compilers find it *trivial* to optimize
    away the iterator-related boilerplate code!'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to keep the example simple, we did not do anything about this, but
    if we do publish the Fibonacci iterator as a library, it would become apparent
    that it has a usability flaw--a `fibit` instance that was created with a constructor
    parameter will only be used as an end iterator because it does not contain valid
    Fibonacci values. Our tiny library does not enforce such usage. There are different
    possibilities to fix it:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the `fibit(size_t i_)` constructor private and declare the `fib_range`
    class as a friend of the `fibit` class. This way, users can only use it the right
    way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use iterator sentinels in order to prevent users to dereference the end iterator.
    Have a look at the recipe in which we introduce those: *Terminating iterations
    over ranges with iterator sentinels*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating the other way around using reverse iterator adapters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it is valuable to iterate over a range the other way around, not
    forward but *backward*. The range-based `for` loop, as well as all STL algorithms
    usually iterate over the given ranges by *incrementing* iterators, although iterating
    backward requires *decrementing* them. Of course, it is possible to *wrap* iterators
    into a layer that transforms an *increment* call effectively into a *decrement*
    call. This sounds like a lot of boilerplate code for every type on which we would
    like to support that.
  prefs: []
  type: TYPE_NORMAL
- en: The STL provides a helpful *reverse-iterator adapter*, which helps us set up
    such iterators.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will use reverse iterators in different ways, just to show
    how they are used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to include some headers first, as always:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we declare that we use namespace `std` in order to spare us some typing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of having something to iterate over, let''s instantiate a list
    of integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s print these integers in the reverse form. In order to do that, we
    iterate over the list by using the `rbegin` and `rend` functions of `std::list`
    and shove those values out via the standard output using the handy `ostream_iterator`
    adapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If a container does not provide handy `rbegin` and `rend` functions but at
    least provides bidirectional iterators, the `std::make_reverse_iterator` function
    helps out. It accepts *normal* iterators and converts them to *reverse* iterators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running our program yields the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to be able to transform a normal iterator into a reverse iterator,
    it must at least have support for bidirectional iteration. This requirement is
    fulfilled by any iterator of the *bidirectional* category or higher.
  prefs: []
  type: TYPE_NORMAL
- en: A reverse iterator kind of *contains* a normal iterator and *mimics* its interface
    completely, but it *rewires* the increment operation to a decrement operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next detail is about the begin and end iterator positions. Let''s have
    a look at the following diagram, which shows a standard numeric sequence kept
    in an iterable range. If the sequence goes from `1` to `5`, then the begin iterator
    has to point to the element `1`, and the end iterator must point one element past
    `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d43dc84-63ca-4492-ad21-1e3278268727.png)'
  prefs: []
  type: TYPE_IMG
- en: When defining reverse iterators, the `rbegin` iterator must point to `5`, and
    the `rend` iterator must point to the element *before* `1`. Turn the book upside
    down, and see that it completely makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: If we want our own custom container classes to support reverse iteration, we
    do not need to implement all these details ourselves; we can just wrap the normal
    iterators into reverse iterators by using the `std::make_reverse_iterator` helper
    function, and it does all the operator rewiring and offset corrections for us.
  prefs: []
  type: TYPE_NORMAL
- en: Terminating iterations over ranges with iterator sentinels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both STL algorithms and the range-based `for` loop assume that the begin and
    end positions of the iteration are known *in advance*. In some situations, however,
    it is hardly possible to know the end position *before reaching* it by iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very simple example for this is iterating over plain C-Style strings, the
    length of which is not known before *runtime*. The code which iterates over such
    strings usually looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The only way to put this into a range-based `for` loop seems to be wrapping
    it into an `std::string`, which has `begin()` and `end()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: However, the constructor of `std::string` will iterate over the whole string
    before our `for` loop can iterate over it. Since C++17, we also have `std::string_view`,
    but its constructor will also iterate through the string once. This is not worth
    the real hassle for *short* strings, but this is also only an example for a problem
    *class,* which can be worth the hassle in *other situations*. The `std::istream_iterator`
    also has to deal with this when it captures input from `std::cin`, as its end
    iterator cannot realistically point to the end of the user input while the user
    is *still typing* keys.
  prefs: []
  type: TYPE_NORMAL
- en: C++17 comes with the great news that it does not constrain begin and end iterators
    to be of the same type. This section demonstrates how to put this *little rule
    change* to *great use*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will build an iterator together with a range class, which
    enables us to iterate over a string with unknown length, without finding the *end*
    position *in advance*.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, as always, we need to include headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The iterator sentinel is a very central element of this section. Surprisingly,
    its class definition can stay completely empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we implement the iterator. It will contain a string pointer, which is the
    *container* we iterate over:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor just initializes the internal string pointer to whatever string
    the user provides. Let''s make the constructor explicit in order to prevent accidental
    implicit conversions from strings to string iterators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'When dereferencing the iterator at some point, it will just return the character
    value at this position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Incrementing the iterator just increments the position in the string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This is the interesting part. We implement the `!=` operator for comparison,
    as it is used by STL algorithms and the range-based `for` loop. However, this
    time, we do not implement it for the comparison of iterators with other *iterators*,
    but for comparing iterators with *sentinels*. When we compare an iterator with
    another iterator we can only check if their internal string pointers both point
    to the same address, which is somewhat limiting. By comparing against an empty
    sentinel object, we can perform a completely different semanticâ€“we check if the
    character our iterator points to is a terminating `''` character because this
    represents the *end* of the string!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to use this in a range-based `for` loop, we need a range class around
    it, which emits the begin and end iterators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing the user needs to provide during instantiation is the string
    that will be iterated over:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We return a normal `cstring_iterator` from the `begin()` function, which points
    to the beginning of the string. From the `end()` function, we just return the
    *sentinel type*. Note that without the sentinel type, we would also return an
    iterator, but from where should we know the end of the string if we didn't search
    for it in advance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. We can immediately use it. Strings that come from the user are
    one example of an input we cannot know the length of in advance. In order to force
    the user to give some input, we will abort the program if the user did not provide
    at least one parameter when launching the program in the shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'If the program is still being executed up to this point, then we know that
    `argv[1]` contains some user string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program yields the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: That the loop prints what we just entered is not a surprise, as this is just
    quite a micro-example for the implementation of a sentinel-based iterator range.
    This iteration termination method will help you in implementing your own iterators
    wherever you run into a situation where the *comparison with an end position*
    approach is not helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically checking iterator code with checked iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter how useful iterators are, and what generic interface they represent,
    iterators can easily be *misused*, just as pointers. When dealing with pointers,
    code must be written in a way that it *never* dereferences them when they point
    to invalid memory locations. Same applies to iterators, but there are *a lot of
    rules* that state when an iterator is valid and when it is invalidated. Those
    can easily be learned by studying the STL documentation a bit, but it will still
    *always* be possible to write buggy code.
  prefs: []
  type: TYPE_NORMAL
- en: In the best case, such buggy code blows up in front of the *developer* while
    it is being *tested*, and *not* on the client's machine. However, in many cases,
    the code just silently seems to work, although it dereferences dangling pointers,
    iterators, and so on. In such cases, we want to be *eagerly alarmed* if we produce
    code showing undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there's help! The GNU STL implementation has a *debug mode*, and
    the GNU C++ compiler as well as the LLVM clang C++ compiler both support *additional
    libraries* that can be used to produce *extra-sensitive* and *verbose* binaries
    for us, which immediately blow up on a large variety of bugs. This is *easy to
    use* and *super useful*, as we will demonstrate in this section. The Microsoft
    Visual C++ standard library also provides a possibility to activate additional
    checks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll write a program that deliberately accesses an invalidated
    iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we include headers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s instantiate a vector of integers and get an iterator to the first
    item, the value `1`. We apply `shrink_to_fit()` on the vector in order to ensure
    that its capacity is *really* `3`, as its implementation *might* allocate more
    memory than necessary as a little reserve to make future item insertions faster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we print the dereferenced iterator, which is completely fine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s append a new number to the vector. As the vector is not large
    enough to take another number, it will automatically increase its size. It does
    this by allocating a new and larger chunk of memory, moving all the existing items
    to that new chunk and then deleting the *old* memory chunk:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s print `1` from the vector through this iterator again. This is
    bad. Why? Well, when the vector moved all its values to the new chunk of memory
    and threw away the old chunk, it did not tell the iterator about this change.
    This means that the iterator is still pointing to the old location, and we cannot
    know what really happened to it since then:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Compiling and running this program leads to a flawless execution. The app doesn't
    crash, but what it prints when dereferencing the invalidated pointer is pretty
    much random. Leaving it like this is pretty dangerous, but at this point, no one
    tells us about that bug if we don't see it ourselves:![](img/a81a4f4e-651a-463e-9a47-9f537f7ef4a6.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Debug flags come to the rescue! The *GNU* STL implementation supports a preprocessor
    macro called `_GLIBCXX_DEBUG`, which activates a lot of sanity checking code in
    the STL. This makes the program slower, but it *finds bugs*. We can activate it
    by adding a `-D_GLIBCXX_DEBUG` flag to our compiler command line, or define it
    in the head of the code file before the `include` lines. As you can see, it kills
    the app in the mactivate different sanitizers. Let's compile the code with clan
    useful (the activation flag for checked iterators with the Microsoft Visual C++
    compiler is `/D_ITERATOR_DEBUG_LEVEL=1`):![](img/abbbeeff-f181-453d-b88f-a5d9477b5b2c.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The LLVM/clang implementation of the STL also has debug flags, but they serve
    the purpose of debugging *the STL* itself, not user code. For user code, you can
    activate different sanitizers. Let's compile the code with clang using the `-fsanitize=address
    -fsanitize=undefined` flags and see what happens:![](img/907bccd5-a08c-449e-b970-98f763f65587.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Wow*, this is a very precise description of what went wrong. The screenshot
    would have spanned *multiple pages* of this book if it had not been truncated.
    Note that this is not a clang-only feature, as it also works with GCC.'
  prefs: []
  type: TYPE_NORMAL
- en: If you get runtime errors because some library is missing, then your compiler
    did not automatically ship with **libasan** and **libubsan**. Try to install them
    via your package manager or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, we did not need to *change* anything in the code in order to
    get this kind of *tripwire* feature for buggy code. It basically came for *free*,
    just by appending some compiler flags to the command line when compiling the program.
  prefs: []
  type: TYPE_NORMAL
- en: This feature is implemented by *sanitizers*. A sanitizer usually consists of
    an additional compiler module and a runtime library. When sanitizers are activated,
    the compiler will add *additional* *information* and *code* to the binary, which
    results from our program. At runtime, the sanitizer libraries that are then linked
    into the program binary can, for example, replace the `malloc` and `free` functions
    in order to *analyze* how the program deals with the memory it acquires.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sanitizers can detect different kinds of bugs. Just to list a few valuable
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Out-of-bounds**: This triggers whenever we access an array, vector, or anything
    similar outside its legitimate memory range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use-after-free**: This triggers if we reference heap memory after it was
    already freed (which we did in this section).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integer overflow**: This triggers if an integer variable overflows by calculating
    with values that do not fit into the variable. For signed integers, the arithmetic
    wraparound is undefined behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pointer alignment**: Some architectures cannot access memory if it has a
    weird alignment in memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more such bugs that sanitizers can detect.
  prefs: []
  type: TYPE_NORMAL
- en: It is *not feasible* to *always* activate all available sanitizers because they
    make the program *slower*. However, it is good style to always activate sanitizers
    in your *unit tests* and *integration tests*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a lot of different sanitizers for different bug categories, and they
    are all still under development. We can and should inform ourselves on the internet
    about how we can improve our test binaries. The GCC and LLVM project homepages
    list their sanitizing capabilities in their online documentation pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html](https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://clang.llvm.org/docs/index.html](http://clang.llvm.org/docs/index.html)
    (look for *sanitizers* in the table of contents)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thorough testing with sanitizers is something that *every* programmer should
    be aware of and should *always* be doing. Unfortunately, this is not the case
    in alarmingly many companies, although buggy code is the most important entry
    point for all the *malware* and *computer viruses* out there.
  prefs: []
  type: TYPE_NORMAL
- en: When you get a new job as a software developer, check if your team really uses
    all the sanitizing possibilities there are. If not, you have the unique chance
    to fix important and sneaky bugs on your first day at work!
  prefs: []
  type: TYPE_NORMAL
- en: Building your own zip iterator adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Different programming languages lead to different programming styles. This is,
    because there are different ways to express things, and they are differing in
    their elegance for each use case. That is no surprise because every language was
    designed with specific objectives.
  prefs: []
  type: TYPE_NORMAL
- en: A very special kind of programming style is *purely* *functional programming*.
    It is magically different from the *imperative* programming which C or C++ programmers
    are used to. While this style is very different, it enables extremely elegant
    code in many situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'One example of this elegance is the implementation of formulas, such as the
    mathematical dot product. Given two mathematical vectors, applying the dot product
    to them means pairwise multiplying of the numbers at the same positions in the
    vector and then summing up all of those multiplied values. The dot product of
    two vectors `(a, b, c) * (d, e, f)` is `(a * e + b * e + c * f)`. Of course, we
    can do that with C and C++, too. It could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: How does it look like in those languages that can be considered *more elegant*?
  prefs: []
  type: TYPE_NORMAL
- en: '*Haskell* is a purely functional language, and this is how you can calculate
    the dot product of two vectors with a magical one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fe01ef4-1b08-4026-b098-566e94367867.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Python* is not a purely functional language, but it supports similar patterns
    to some extent, as seen in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae8dfd8b-886e-4c0f-9226-80d8f1619286.png)'
  prefs: []
  type: TYPE_IMG
- en: The STL provides a specific algorithm called `std::inner_product`, which solves
    this specific problem in one line, too. But the point is that in many other languages,
    such code can be written *on the fly* in only one line *without* specific library
    functions that support that exact purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without delving into the explanations of such foreign syntax, an important
    commonality in both examples is the magical `zip` function. What does it do? It
    takes the two vectors `a` and `b` and transforms them to a *mixed* vector. Example:
    `[a1, a2, a3]` and `[b1, b2, b3]` result in `[ (a1, b1), (a2, b2), (a3, b3) ]`
    when they are zipped together. Have a close look at it; it''s really similar to
    how zip fasteners work!'
  prefs: []
  type: TYPE_NORMAL
- en: The relevant point is that it is now possible to iterate over *one* combined
    range where pairwise multiplications can be done and then summed up to an accumulator
    variable. Exactly the same happens in the Haskell and Python examples, without
    adding any loop or index variable noise.
  prefs: []
  type: TYPE_NORMAL
- en: It will not be possible to make the C++ code exactly as elegant and generic
    as in Haskell or Python, but this section explains how to implement similar magic
    using iterators, by implementing a *zip iterator*. The example problem of calculating
    the dot product of two vectors is solved more elegantly by specific libraries,
    which are beyond the scope of this book. However, this section tries to show how
    much iterator-based libraries can help in writing expressive code by providing
    extremely generic building blocks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will recreate the *zip* function as known from Haskell
    or Python. It will be hardcoded to vectors of `double` variables in order to not
    distract from iterator mechanics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to include some headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the `zip_iterator` class. While iterating over a `zip_iterator`
    range, we will get a pair of values from the two containers at every iteration
    step. This means that we iterate over two containers at the same time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The zip iterator needs to save two iterators, one for each container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor simply saves the iterators from the two containers that we
    would like to iterate over:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Incrementing the zip iterator means incrementing both the member iterators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Two zip iterators are unequal if both the member iterators are unequal to their
    counterparts in the other zip iterator. Usually, one would use logical or (`||`)
    instead of and (`&&`), but imagine that the ranges are not of equal length. In
    such a case, it would not be possible to match *both* the end iterators at the
    same time. This way, we can abort the loop when we reach the *first* end iterator
    of *either* range:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The equality comparison operator is just implemented using the other operator,
    but negating the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Dereferencing the zip iterator gives access to the elements of both the containers
    at the same position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This was the iterator code. We need to make the iterator compatible with STL
    algorithms, so we define the needed type trait boilerplate code for that. It basically
    says that this iterator is just a forward iterator, and it returns pairs of double
    values when dereferenced. Although we do not use `difference_type` in this recipe,
    different implementations of the STL might need it in order to compile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to define a range class that returns us zip iterators from
    its `begin` and `end` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'It needs to reference two existing containers in order to form zip iterators
    from them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The `begin` and `end` functions just feed pairs of begin and end pointers in
    order to construct zip iterator instances from that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as in the Haskell and Python examples, we define two vectors of `double`
    values. We also define that we use namespace `std` within the main function by
    default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The zipper object combines them to one vector-like range where we see pairs
    of `a` and `b` values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use `std::accumulate` in order to sum all the items of the range together.
    We can''t do it directly because that would mean that we sum up the instances
    of `std::pair<double, double>` for which the concept of sum is not defined. Therefore,
    we will define a helper lambda that takes a pair, multiplies its members, and
    adds it to an accumulator. The `std::accumulate` works well with lambdas with
    such a signature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we feed it to `std::accumulate`, together with the begin and end iterator
    pair of the zipped ranges and a start value of `0.0` for the accumulator variable,
    which, in the end, contains the sum of the products:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s print the dot product result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program yields the correct result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OK, that was a *lot* of work for a little bit of syntax sugar, and it's still
    not as elegant as Haskell code can be without any effort. A big flaw is the hardcoded
    nature of our little zip iterator--it only works on the `std::vector` ranges of
    double variables. With a bit of template code and some type traits, the zipper
    can be made more generic. This way, it could combine lists and vectors, or deques
    and maps, even if these are specialized on completely different container item
    types.
  prefs: []
  type: TYPE_NORMAL
- en: The amount of work and thought needed in order to really and correctly make
    such classes generic is not to be underestimated. Luckily, such libraries do already
    exist. One popular non-STL library is the *Boost* `zip_iterator`. It is very generic
    and easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, if you came here to see the most elegant way to do a *dot product*
    in C++, and don''t really care about the concept of zip-iterators, you should
    have a look at `std::valarray`. See for yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Ranges library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a very, very interesting C++ library, which supports zippers and all
    other kinds of magic iterator adapters, filters, and so on: the *ranges* library.
    It is inspired by the Boost ranges library, and for some time, it looked like
    it would find its way into C++17, but unfortunately, we will have to wait for
    the *next* standard. The reason why this is so unfortunate is that it will *vigorously*
    improve the possibilities of writing *expressive* and *fast* code in C++ by composing
    *complex* functionality from *generic* and *simple* blocks of code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some very simple examples in its documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculating the sum of the squares of all numbers from `1` to `10`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Filtering out all uneven numbers from a numeric vector, and transforming the
    rest to strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: If you are interested and can't wait for the next C++ standard, have a look
    at the ranges documentation at [https://ericniebler.github.io/range-v3/](https://ericniebler.github.io/range-v3/).
  prefs: []
  type: TYPE_NORMAL

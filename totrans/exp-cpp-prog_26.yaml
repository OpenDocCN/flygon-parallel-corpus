- en: Advanced Use of STL Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will cover the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a trie class using STL algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a search input suggestion generator with tries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Fourier transform formula with STL numeric algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the error sum of two vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an ASCII Mandelbrot renderer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building our own algorithm - split
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing useful algorithms from standard algorithms - gather
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing consecutive whitespace between words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressing and decompressing strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last chapter, we visited basic STL algorithms and performed simple tasks
    with them in order to get a feeling of the typical STL interface: most STL algorithms
    accept one or more ranges in the form of iterator pairs as input/output parameters.
    They often also accept predicate functions, custom comparison functions, or transformation
    functions. In the end, they mostly return iterators again because these can often
    be fed into some other algorithm afterward.'
  prefs: []
  type: TYPE_NORMAL
- en: While STL algorithms aim to be minimal, their interfaces also try to be as general
    as possible. This enables maximum code reuse potential but does not always look
    too pretty. An experienced C++ coder who knows all algorithms has a better time
    reading other people's code if it tries to express as many ideas using STL algorithms
    as possible. This leads to a maximized common ground of comprehension between
    coder and reader. A programmer's brain can simply parse the name of a well-known
    algorithm more quickly than it can understand a complex loop, which does a mainly
    similar, but in some detail a slightly different, job.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are using STL data structures so intuitively that we can nicely
    avoid pointers, raw arrays, and other crude legacy structures. The next step is
    lifting our comprehension of STL algorithms up to the levels where we can avoid
    the use of handcrafted loop-control-structure complexes by expressing them in
    terms of well-known STL algorithms. Often, this is a real improvement because
    code becomes simply shorter and more readable while at the same time being more
    general and data-structure agnostic. It is practically always possible to avoid
    writing handcrafted loops and taking an algorithm out of the `std` namespace instead,
    but sometimes, it admittedly leads to *awkward code*. We are not going to differentiate
    between what is awkward and what is not; we'll only explore the possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use STL algorithms in creative ways in order to look
    for new horizons and to see how things can be implemented with modern C++. On
    the way, we will implement our own STL-like algorithms, which can easily be combined
    with existing data structures and other algorithms designed in the same way. We
    will also *combine* existing STL algorithms to get *new* algorithms, which were
    not there before. Such combined algorithms allow for more complex algorithms on
    top of the existing ones, while they are themselves extremely short and readable
    this way. While on this little trip, we will also see where exactly STL algorithms
    suffer from reusability or prettiness. Only when we know *all* the ways well can
    we best decide which way is the right one.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a trie class using STL algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The so-called **trie** data structure poses an interesting way to store data
    in an easily searchable manner. When segmenting sentences of text into lists of
    words, it is often possible to combine the first few words that some sentences
    have in common.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following diagram, where the sentences `"hi how are
    you"` and `"hi how do you do"` are saved in a tree-like data structure. The first
    words they have in common are `"hi how"`, and then they differ and split up like
    a tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b42b8317-e512-4bac-bc05-cb4ce62421b7.png)'
  prefs: []
  type: TYPE_IMG
- en: Because the trie data structure combines common prefixes, it is also called
    *prefix tree*. It is very easy to implement such a data structure with what the
    STL gives us already. This section concentrates on implementing our own trie class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement our own prefix tree only made from STL data
    structures and algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will include all the headers from the STL parts we use and declare that
    we use the `std` namespace by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The entire program revolves around a trie for which we have to implement a
    class first. In our implementation, a trie is basically a recursive map of maps.
    Every trie node contains a map, which maps from an instance of the payload type
    `T` to the next trie node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for inserting new item sequences is simple. The user provides a begin/end
    iterator pair and we loop through it recursively. If the user input sequence is
    `{1, 2, 3}`, then we look up `1` in the subtrie and then look up `2` in the next
    subtrie, in order to get the subtrie for `3`. If any of those subtries did not
    exist before, they are implicitly added by the `[]` operator of `std::map`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We also define convenience functions, which enable the user to just provide
    a container of items, which are then automatically queried for iterators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to allow the user to write `my_trie.insert({"a", "b", "c"});`, we
    must help the compiler a bit to correctly deduce all the types from that line,
    so we add a function, which overloads the insert interface with an `initializer_list`
    parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also want to see what''s in a trie, so we need a `print` function.
    In order to print, we can do a depth-first-search through the trie. On the way
    from the root node down to the first leaf, we record all payload items we have
    seen already. This way, we have a complete sequence together once we reach the
    leaf, which is trivially printable. We see that we reached a leaf when `tries.empty()`
    is `true`. After the recursive `print` call, we pop off the last added payload
    item again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The recursive `print` function passes around a reference to a printable list
    of payload items, but the user should call it without any parameters. Therefore,
    we define a parameterless `print` function, which constructs the helper list object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we can construct and print tries, we may want to search for subtries.
    The idea is that if the trie contains sequences such as `{a, b, c}` and `{a, b,
    d, e}`, and we give it a sequence, `{a, b}`, for search, it would return us the
    subtrie that contains the `{c}` and `{d, e}` parts. If we find the subtrie, we
    return a `const` reference to it. The possibility exists that there is no such
    subtrie in case the trie does not contain the sequence we are searching for. In
    such cases, we still need to return *something*. The `std::optional` is a nice
    helper because we can return an *empty* optional object if there is no match:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the `insert` method, we provide a one-parameter version of the `subtrie`
    method, which automatically takes iterators from the input container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s already it. Let''s put the new trie class to use in our main function
    by instantiating a trie specialized on `std::string` objects and fill it with
    some example content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s first print the whole trie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we obtain the subtrie for all the input sentences that start with `"hi"`,
    and print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program shows that it does indeed return us only
    the two sentences that start with `"hi"`, when we query the trie for exactly that
    subtrie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Interestingly, the code for word sequence *insertion* is shorter and simpler
    than the code for *looking up* a given word sequence in a subtrie. So, let''s
    first have a look at the insertion code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The pair of iterators, `it` and `end_it`, represent the word sequence to be
    inserted. The `tries[*it]` element looks up the first word in the sequence in
    the subtrie, and then, `.insert(next(it), end_it)` restarts the same function
    on that lower subtrie, with the iterator one word *further* advanced. The `if
    (it == end_it) { return; }` line just aborts the recursion. The empty `return`
    statement does *nothing*, which is a bit weird at first. All the insertion happens
    in the `tries[*it]` statement. The bracket operator `[]` of `std::map` either
    returns an existing item for the given key or it *creates* one with that key.
    The associated value (the mapped type is a trie in this recipe) is constructed
    from its default constructor. This way, we are *implicitly creating* a new trie
    branch whenever we are looking up unknown words.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking up in a subtrie looks more complicated because we were not able to
    *hide* so much in implicit code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code basically revolves around the `auto found (tries.find(*it));` statement.
    Instead of looking up the next deeper trie node using the bracket operator (`[]`),
    we use `find`. If we use the `[]` operator for lookups, the trie will *create*
    missing items for us, which is *not* what we want when just looking up whether
    an item exists! (By the way, try doing that. The class method is `const`, so this
    will not even be possible. This can be quite a life saver, which helps us in preventing
    bugs.)
  prefs: []
  type: TYPE_NORMAL
- en: Another scary looking detail is the return type, `optional<reference_wrapper<const
    trie>>`. We chose `std::optional` as the wrapper because it is possible that there
    is no such subtrie for the input sequence we are looking for. If we only inserted
    `"hello my friend"`, there will be no `"goodbye my friend"` sequence to look up.
    In such cases, we just return `{}`, which gives the caller an empty optional object.
    This still does not explain why we use `reference_wrapper` instead of just writing
    `optional<const trie &>`. The point here is that an optional instance with a member
    variable of the `trie&` type is not reassignable and hence would not compile.
    Implementing a reference using `reference_wrapper` leads to reassignable objects.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a search input suggestion generator with tries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When entering something into a search engine on the Internet, the interface
    often tries to guess how the full search query will look. This guessing is usually
    based on popular search queries from the past. Sometimes, such search engine guesses
    are quite funny because it appears that people type weird queries into search
    engines.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca1d8fff-6f82-468a-8a56-2b41b86e20f9.png)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we are going to use the trie class that we implemented in the
    previous recipe and build a little search query suggestion engine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will implement a terminal app, which accepts some input
    and then tries to guess what the user might want to look for, based on a cheap
    text file database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, includes come first, and we define that we use the `std` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the trie implementation from the trie recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a little helper function that prints a line that prompts the user
    to enter some text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the main function, we open a text file, which acts as our sentence database.
    We read that text file line by line and feed those lines into a trie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have constructed the trie from the content in the text file, we
    need to implement an interface for the user to query it. We prompt the user to
    enter some text and wait for a whole line of input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With that text input, we query the trie in order to get a subtrie from it.
    If we have such an input sequence in the text file already, then we can print
    how the input can be continued, just as in the search engine suggestion feature.
    If we do not find a matching subtrie, we just tell the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Afterward, we print the prompt text again and wait for the next line of user
    input. That's it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Before thinking about launching the program, we need to fill some content into
    `db.txt`. The input can be really anything, and it does not even need to be sorted.
    Each line of text will be one trie sequence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to create `db.txt` before we can run the program. Its content could
    look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program and entering some input looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How a trie works was explained in the last recipe, but how we fill it and how
    we query it looks a bit strange here. Let''s have a closer look at the code snippet
    that fills the empty trie with the content of the text database file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The loop fills the string `line` with the content of the text file, line by
    line. Then, we copy the string into an `istringstream` object. From such an input
    stream object, we can create an `istream_iterator`, which is useful because our
    trie does not only accept a container instance for looking up subtries but also
    primarily iterators. This way, we do not need to construct a vector or a list
    of words and can directly consume the string. The last piece of unnecessary memory
    allocations could be avoided by *moving* the content of `line` into `iss`. Unfortunately,
    `std::istringstream` does not provide a constructor that accepts `std::string`
    values to be *moved*. It will *copy* its input string, nevertheless.
  prefs: []
  type: TYPE_NORMAL
- en: When reading the user's input to look it up in the trie, we use exactly the
    same strategy but we do not use an input *file* stream. We use `std::cin`, instead.
    This works completely identically for our use case because `trie::subtrie` works
    with iterators just as `trie::insert` does.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to add *counter variables* to each node of the trie. This way,
    it is possible to count *how often* a prefix occurs in some input. From that,
    we could *sort* our suggestions by their occurrence frequency, which is actually
    what search engines do. Word suggestions for smartphone touchscreen text input
    could also be implemented this way.
  prefs: []
  type: TYPE_NORMAL
- en: This modification is left as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Fourier transform formula with STL numeric algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Fourier transformation** is a very important and famous formula in signal
    processing. It was invented nearly 200 years ago, but with computers, the number
    of use cases for it really skyrocketed. It is used in audio/image/video compression,
    audio filters, medical imaging devices, cell phone apps that identify music tracks
    while listening to them on the fly, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of the vastness of general numeric application scenarios (not only
    because of the Fourier transformation of course), the STL also tries to be useful
    in the context of numeric computation. The Fourier transformation is only one
    example among them but a tricky one too. The formula itself looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecd82744-2cc6-4b76-9f93-5f03df78a598.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The transformation it describes is basically a *sum*. Each element of the sum
    is the multiplication of a data point of the input signal vector, and the expression
    *exp(-2 * i * ...)*. The maths behind this is a bit scary for everyone who does
    not know about complex numbers (or who just does not like maths), but it is also
    not really necessary to completely understand the maths in order to *implement*
    it. When having a close look at the formula, it says that the sum symbol loops
    over every data point of the signal (which is `N` elements long) using the loop
    variable `j`. The variable `k` is another loop variable because the Fourier transformation
    is not for calculating a single value, but a vector of values. In this vector,
    every data point represents the intensity and phase of a certain repetitive wave
    frequency, which is or is not a part of the original signal. When implementing
    this with manual loops, we will end up with code similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `csignal` type may be an `std::vector` vector of complex numbers. For complex
    numbers, there is an `std::complex` STL class, which helps represent those. The
    `std::polar` function basically does the *exp(-i * 2 * ...)* part.
  prefs: []
  type: TYPE_NORMAL
- en: This works well already, but we are going to implement it using STL tools.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to implement the Fourier transformation and its
    backward transformation and then play around with it to transform some signals:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we include all the headers and declare that we use the `std` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A data point of a signal is a complex number and shall be represented by `std::complex`,
    specialized on the `double` type. This way, the type alias `cmplx` stands for
    two coupled `double` values, which represent the *real* and the *imaginary* parts
    of a complex number. A whole signal is a vector of such items, which we alias
    to the `csignal` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to iterate over an up-counting numeric sequence, we take the *numeric
    iterator* from the numeric iterator recipe. The variables `k` and `j` in the formula
    shall iterate over such sequences:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The Fourier transformation function shall just take a signal and return a new
    signal. The returned signal represents the Fourier transformation of the input
    signal. As the back transformation from a Fourier transformed signal back to the
    original signal is very similar, we provide an optional `bool` parameter, which
    chooses the transformation direction. Note that `bool` parameters are generally
    bad practice, especially if we use multiple `bool` parameters in a function signature.
    Here we just have one for brevity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first thing we do is allocate a new signal vector with the size of the
    initial signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two factors in the formula, which always look the same. Let''s pack
    them in their own variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `std::accumulate` algorithm is a fitting choice for executing formulas
    that sum up items. We are going to use `accumulate` on a range of up-counting
    numeric values. From these values, we can form the individual summands of each
    step. The `std::accumulate` algorithm calls a binary function on every step. The
    first parameter of this function is the current value of the part of `sum` that
    was already calculated in the previous steps, and its second parameter is the
    next value from the range. We look up the value of signal `s` at the current position
    and multiply it with the complex factor, `pol`. Then, we return the new partly
    sum. The binary function is wrapped into *another* lambda expression because we
    are going to use different values of `j` for every `accumulate` call. Because
    this is a two-dimensional loop algorithm, the inner lambda is for the inner loop
    and the outer lambda is for the outer loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The inner loop part of the Fourier transform is now executed by `std::accumulate`.
    For every `j` position of the algorithm, we calculate the sum of all the summands
    for positions *i = 0...N*. This idea is wrapped into a lambda expression, which
    we will execute for every data point in the resulting Fourier transformation vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'None of the Fourier code has been executed until this point. We only prepared
    a lot of functional code, which we''ll put to action now. An `std::transform`
    call will generate values *j = 0...N*, which is our outer loop. The transformed
    values all go to the vector `t`, which we then return to the caller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to implement some functions that help us set up function objects
    for signal generation. The first one is a cosine signal generator. It returns
    a lambda expression that can generate a cosine signal with the period length that
    was provided as a parameter. The signal itself can be of arbitrary length, but
    it has a fixed period length. A period length of `N` means that the signal will
    repeat itself after `N` steps. The lambda expression does not accept any parameters.
    We can call it repeatedly, and for every call, it returns us the signal data point
    of the next point in time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Another signal we are going to generate is the square wave. It oscillates between
    the values `-1` and `+1` and has no other values than those. The formula looks
    complicated, but it simply transforms the linearly up-counting value `n` to `+1`
    and `-1`, with an oscillating period length of `period_len`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that we initialize `n` to a different value from `0` this time. This way,
    our square wave starts at the phase where its output values begin at `+1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Generating an actual signal from such generators can be achieved by allocating
    a new vector and filling it with the values generated from repeating signal generator
    function calls. The `std::generate` does this job. It accepts a begin/end iterator
    pair and a generator function. For every valid iterator position, it does `*it
    = gen()`. By wrapping this code into a function, we can easily generate signal
    vectors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the end, we need to print the resulting signals. We can simply print a signal
    by copying its values into an output stream iterator, but we need to transform
    the data first because the data points of our signals are complex value pairs.
    At this point, we are only interested in the real value part of every data point;
    hence, we throw it through an `std::transform` call, which extracts only this
    part:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The Fourier formula is now implemented, but we have no signals to transform
    yet. That is what we do in the main function. Let's first define a standard signal
    length to which all the signals comply.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now generate signals, transform them, and print them, which happens
    in the next three steps. The first step is to generate a cosine signal and a square
    wave signal. Both have the same total signal length and period length:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a cosine function and a square wave signal now. In order to generate
    a third one in the middle between them, we take the square wave signal and calculate
    its Fourier transform (saved in the `trans_sqw` vector). The Fourier transform
    of a square wave has a specific form, and we are going to manipulate it a bit.
    All items from index `10` till `(signal_length - 10)` are set to `0.0`. The rest
    remains *untouched*. Transforming this altered Fourier transformation back to
    the signal time representation will give us a different signal. We will see how
    that looks in the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have three signals: `cosine`, `mid`, and `square_wave`. For every signal,
    we print the signal itself and its Fourier transformation. The output of the whole
    program will consist of six very long lines of printed double value lists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program leads to the terminal getting filled with
    lots of numeric values. If we plot the output, we get the following image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e2b5e05b-3c87-44b4-aebd-ada36d752a21.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This program contains two complicated sections. One is the Fourier transformation
    itself, and the other is the generation of signals with mutable lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s concentrate on the Fourier transformation first. The core of the raw
    loop implementation (which we did not use for our implementation but had a look
    at in the introduction) looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'With the STL algorithms, `std::transform` and `std::accumulate`, we wrote code,
    which can be summarized to the following pseudo code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The result is exactly the same compared with the loop variant. This is arguably
    an example situation where the strict use of STL algorithms does *not* lead to
    better code. Nevertheless, this algorithm implementation is agnostic over the
    data structure choice. It would also work on lists (although that would not make
    too much sense in our situation). Another upside is that the C++17 STL algorithms
    are easy to *parallelize* (which we examine in another chapter of this book),
    whereas raw loops have to be restructured to support multiprocessing (unless we
    use external libraries like *OpenMP* for example, but these do actually restructure
    the loops for us).
  prefs: []
  type: TYPE_NORMAL
- en: 'The other complicated part was the signal generation. Let''s have another look
    at `gen_cosine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Each instance of the lambda expression represents a function object that modifies
    its own state on every call. Its state consists of the variables, `period_len`
    and `n`. The `n` variable is the one which is modified on every call. The signal
    has a different value at every time point, and `n++` represents the increasing
    time points. In order to get an actual signal vector out of it, we created the
    helper `signal_from_generator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This helper allocates a signal vector with a length of choice and calls `std::generate`
    to fill it with data points. For every item of the vector `r`, it calls the function
    object `gen` once, which is just the kind of self-modifying function object we
    can create with `gen_cosine`.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the STL way does *not* make this code more elegant. As soon as
    the ranges library joins the STL club (which is hopefully the case with C++20),
    this will most probably change.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the error sum of two vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different possibilities to calculate the numerical *error* between
    a target value and an actual value. Measuring the difference between signals consisting
    of many data points usually involves loops and subtraction of corresponding data
    points, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'One simple formula to calculate this error between a signal `a` and a signal
    `b` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1db597b-9f14-48c2-bd5f-0a24b3019643.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For every *i*, it calculates *a[i] - b[i]*, squares that difference (this way,
    negative and positive differences become comparable), and, finally, sums those
    values up. This is again a situation where one could use a loop, but for fun reasons,
    we will do it with an STL algorithm. The good thing is that we get data-structure
    independence for free this way. Our algorithm will work on vectors and on list-like
    data structures, where no direct indexing is possible.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to create two signals and calculate their error
    sum:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, the include statements come first. Then, we declare that we use
    the `std` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to calculate the error sum of two signals. The two signals will
    be a sine wave and a copy of it, but with a different value type--the original
    sine wave is saved in a vector of `double` variables and its copy is saved in
    a vector of `int` variables. Because copying a value from a `double` variable
    to an `int` variable cuts its decimal part after the point, we have some *loss*.
    Let''s name the vector of `double` values `as`, which stands for *analog signal*
    and the vector of `int` values `ds`, which stands for *digital signal*. The error
    sum will then later tell us how large the loss actually is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to generate a sine wave signal, we implement a little lambda expression
    with a *mutable* counter value `n`. We can call it as often as we want, and for
    every call, it will return us the value for the next point in time of a sine wave.
    The `std::generate` call fills the signal vector with the generated signal, and
    the `std::copy` call copies all the values from the vector of `double` variables
    to the vector of `int` variables afterward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s first print the signals, as this way, they can be plotted later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now to the actual error sum, we use `std::inner_product` because it can easily
    be adapted to calculate the difference between every two corresponding elements
    of our signal vectors. It will iterate through both the ranges, pick items at
    the same corresponding positions in the ranges, calculate the difference between
    them, square it, and accumulate the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program gives us two long lines of signal output
    and a third line, which contains a single output value, which is the error between
    both the signals. The error is `40.889`. If we calculate the error in a continuous
    manner, first for the first pair of items, then for the first two pairs of items,
    then for the first three pairs of items, and so on, then we get the accumulated
    error curve, which is visible on the plotted graph as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/33d6fd3e-c17d-4f36-a4fc-69a3a83d4804.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we stuffed the task of looping through two vectors, getting
    the difference between their corresponding values, squaring them, and finally
    summing them up into one `std::inner_product` call. On the way, the only code
    we crafted ourselves was the lambda expression `[](double a, double b) { return
    pow(a - b, 2); }`, which takes the difference of its arguments and squares it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A glance at a possible implementation of `std::inner_product` shows us why
    and how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The algorithm accepts a pair of begin/end iterators of the first range, and
    another begin iterator of the second range. In our case, they are the vectors
    from which we want to calculate the error sum. The next character is the initial
    value `val`. We have initialized it to `0.0`. Then, the algorithm accepts two
    binary functions, namely `bin_op1` and `bin_op2`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we might realize that this algorithm is really similar to `std::accumulate`.
    The only difference is that `std::accumulate` works on only *one* range. If we
    exchange the `bin_op2(*it1, *it2)` statement with `*it`, then we have basically
    restored the `accumulate` algorithm. We can, therefore, regard `std::inner_product`
    as a version of `std::accumulate` that *zips* a pair of input ranges.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the *zipper* function is `pow(a - b, 2)`, and that's it. For the
    other function, `bin_op1`, we chose `std::plus<double>` because we want all the
    squares to be summed together.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an ASCII Mandelbrot renderer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In 1975, the mathematician Beno√Æt Mandelbrot coined the term **fractal**. A
    fractal is a mathematical figure or set, which has certain interesting mathematical
    properties, but in the end, it just looks like a piece of art. Fractals also look
    *infinitely* *repetitive* when being zoomed in. One of the most popular fractals
    is the *Mandelbrot set*, which can be seen on the following poster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f18ecb5f-e3af-4184-b68c-1c99bd5cd4c5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A picture of the Mandelbrot set can be generated by iterating a specific formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/628bf694-e1cc-48c2-a1dd-d110a7d8fa6d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The variables *z* and *c* are *complex* numbers. The Mandelbrot set consists
    of all such values of *c* for which the formula *converges* if it is applied often
    enough. This is the colored part of the poster. Some values converge earlier,
    some converge later, so they can be visualized with different colors. Some do
    not converge at all--these are painted black.
  prefs: []
  type: TYPE_NORMAL
- en: The STL comes with the useful `std::complex` class, and we will try to implement
    the formula without explicit loops, just for the sake of getting to know the STL
    better.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to print the same image from the wall poster
    as a little piece of ASCII art in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we include all the headers and declare that we use the `std` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The Mandelbrot set and formula operate on complex numbers. So, we define a type
    alias, `cmplx` to be of class `std::complex`, specializing on double values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to hack together all the code for an ASCII Mandelbrot image
    in something around 20 lines of code, but we will implement each logical step
    in a separate form, and then assemble all the steps in the end. The first step
    is implementing a function that scales from integer coordinates to floating point
    coordinates. What we have in the beginning is columns and rows of character positions
    on the terminal. What we want are complex-typed coordinates in the coordinate
    system of the Mandelbrot set. For this, we implement a function that accepts parameters
    that describe the geometry of the user terminal coordinate system, and the system
    we want to transform to. Those values are used to build a lambda expression, which
    is returned. The lambda expression accepts an `int` coordinate and returns a `double`
    coordinate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can transform points on one dimension, but the Mandelbrot set exists
    in a two-dimensional coordinate system. In order to translate from one `(x, y)`
    coordinate system to another, we combine an x-scaler and a y-scaler and construct
    a `cmplx` instance from their output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'After being able to transform coordinates to the right dimensions, we can now
    implement the Mandelbrot formula. The function that we''re implementing now knows
    absolutely nothing about the concept of terminal windows or linear plane transformations,
    so we can concentrate on the Mandelbrot math. We square `z` and add `c` to it
    in a loop until its `abs` value is smaller than `2`. For some coordinates, this
    never happens, so we also break out of the loop if the number of iterations exceeds
    `max_iterations`. In the end, we return the number of iterations we had to do
    until the `abs` value converged:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now begin with the main function, where we define the terminal dimensions
    and instantiate a function object, `scale`, which scales our coordinate values
    for both axes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In order to have a one-dimensional iteration over the whole image, we write
    another transformation function that accepts a one-dimensional `i` coordinate.
    It calculates `(x, y)` coordinates from that, based on our assumed line of characters
    width. After breaking `i` down to the row and column numbers, it transforms them
    with our `scale` function and returns the complex coordinate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'What we can do now is transform from one-dimensional coordinates (the `int`
    type), via two-dimensional coordinates (the `(int, int)` type), to Mandelbrot
    set coordinates (the `cmplx` type), and then calculate the number of iterations
    from there (the `int` type again). Let''s combine all that in one function, which
    sets up this call chain for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can set up all the data. We assume that our resulting ASCII image is
    `w` characters wide and `h` characters high. This can be saved in a one-dimensional
    vector that has `w * h` elements. We fill this vector using `std::iota` with the
    value range, *0 ... (w*h - 1)*. These numbers can be used as an input source for
    our constructed transformation function range, which we just encapsulated in `to_iteration_count`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s basically it. We now have the `v` vector, which we initialized with
    one-dimensional coordinates, but which then got overwritten by Mandelbrot iteration
    counters. From this, we can now print a pretty image. We could just make the terminal
    window `w` characters wide, then we would not need to print line break symbols
    in between. But we can also kind of *creatively misuse* `std::accumulate` to do
    the line breaks for us. The `std::accumulate` uses a binary function to reduce
    a range. We provide it a binary function, which accepts an output iterator (and
    which we will link to the terminal in the next step), and a single value from
    the range. We print this value as a `*` character if the number of iterations
    is higher than 50\. Otherwise, we just print a space character. If we are on a
    *row end* (because the counter variable `n` is evenly divisible by `w`), we print
    a line break symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'By calling `std:accumulate` on the input range, combined with our binary print
    function and an `ostream_iterator`, we can flush the calculated Mandelbrot set
    out to the terminal window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program leads to the following output, which looks
    like the initial detailed Mandelbrot image, but in a simplified form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eb4a8203-0f69-4c38-b98e-213ea3541018.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The whole calculation took part during an `std::transform` call over a one-dimensional
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what exactly happened, and why does it work this way? The `to_iteration_count`
    function is basically a call chain from `i_to_xy`, over `scale` to `mandelbrot_iterations`.
    The following diagram illustrates the transformation steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd9a2b82-10aa-4236-b3bd-a087eb34f71f.png)'
  prefs: []
  type: TYPE_IMG
- en: This way, we can use the index of a one-dimensional array as input, and get
    the number of Mandelbrot formula iterations at the point of the two-dimensional
    plane, which this array point represents. The good thing is that these three transformations
    are completely agnostic about each other. Code with such a separation of concerns
    can be tested very nicely because each component can be tested individually without
    the others. This way, it is easy to find and fix bugs, or just reason about its
    correctness.
  prefs: []
  type: TYPE_NORMAL
- en: Building our own algorithm - split
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some situations, the existing STL algorithms are not enough. But nothing
    hinders us from implementing our own. Before solving a specific problem, we should
    think about it firmly in order to realize that many problems can be solved in
    generic ways. If we regularly pile up some new library code while solving our
    own problems, then we are also helping our fellow programmers when they have similar
    problems to solve. Key is to know when it is generic enough and when not to go
    for more genericity than needed--else we end up with a new general purpose language.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are implementing an algorithm, which we will call `split`.
    It can split any range of items at each occurrence of a specific value, and it
    copies the chunks that result from that into an output range.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to implement our own STL-like algorithm called
    `split`, and then we check it out by splitting an example string:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first, we include some STL library parts and declare that we use
    the `std` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The whole algorithm this section revolves around is `split`. It accepts a begin/end
    pair of input iterators, and an output iterator, which makes it similar to `std::copy`
    or `std::transform` at first. The other parameters are `split_val` and `bin_func`.
    The `split_val` parameter is the value we are searching for in the input range,
    which represents a splitting point at which we cut the input interval. The `bin_func`
    parameter is a function that transforms a pair of iterators that mark the beginning
    and the end of such a split chunk subrange. We iterate through the input range
    using `std::find`, so we jump from occurrence to occurrence of `split_val` values.
    When splitting a long string into its individual words, we would jump from space
    character to space character. On every split value, we stop by to form a chunk
    and feed it into the output range:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the new algorithm. We construct a string that we want to split.
    The item that marks the end of the last chunk, and the beginning of the next chunk,
    shall be the dash character `''-''`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever the algorithm calls its `bin_func` on a pair of iterators, we want
    to construct a new string from it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The output range will be an `std::list` of strings. We can now call the `split`
    algorithm, which has a similar design compared to all the other STL algorithms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to see what we got, let''s print the new chunked list of strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program yields the following output. It contains
    no dashes anymore and shows that it has isolated the individual words (which are,
    of course, only single characters in our example string):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `split` algorithm works in a similar manner to `std::transform` because
    it accepts a pair of begin/end iterators of an input range and an output iterator.
    It does something with the input range, which, in the end, results in assignments
    to the output iterator. Apart from that, it accepts an item value called `split_val`
    and a binary function. Let''s revisit the whole implementation to fully understand
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The loop demands to iterate until the end of the input range. During each iteration,
    an `std::find` call is used to find the next element in the input range, which
    equals to `split_val`. In our case, that element is the dash character (`'-'`)
    because we want to split our input string at all the dash positions. The next
    dash position is now saved in `slice_end`. After the loop iteration, the `it`
    iterator is put on the next item past that split position. This way, the loop
    jumps directly from dash to dash, instead of over every individual item.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this constellation, the iterator `it` points to the beginning of the last
    slice, while `slice_end` points to the end of the last slice. Both these iterators,
    in combination, mark the beginning and end of the subrange that represents exactly
    one slice between two dash symbols. In a string, `"foo-bar-baz"`, this would mean
    that we have three loop iterations and we get a pair of iterators every time,
    which surround one word. But we do not actually want iterators but `substrings`.
    The binary function, `bin_func`, does just that for us. When we called `split`,
    we gave it the following binary function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The `split` function throws every pair of iterators through `bin_func`, before
    feeding it into the output iterator. And we actually get string instances out
    of `bin_func`, which results in `"foo"`, `"bar"`, and `"baz"`:'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interesting alternative to implementing our own algorithm for splitting strings
    would be implementing an *iterator* that does the same. We are not going to implement
    such an iterator at this point, but let's have a brief look at such a scenario.
  prefs: []
  type: TYPE_NORMAL
- en: The iterator would need to jump between delimiters on every increment. Whenever
    it is dereferenced, it needs to create a string object from the iterator positions
    it currently points to, which it could do using a binary function such as `binfunc`,
    which we used before.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had an iterator class called `split_iterator`, instead of an algorithm
    `split`, the user code would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The downside of this approach is that implementing an iterator is usually more
    *complicated* than a single function. Also, there are many subtle edges in iterator
    code that can lead to bugs, so an iterator solution needs more tedious testing.
    On the other hand, it is very simple to combine such an iterator with the other
    STL algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Composing useful algorithms from standard algorithms - gather
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very nice example for the composability of STL algorithms is `gather`. Sean
    Parent, principal scientist at Adobe Systems at the time, popularized this algorithm
    because it is both useful and short. The way it is implemented, it is the ideal
    poster child for the idea of STL algorithm composition.
  prefs: []
  type: TYPE_NORMAL
- en: The `gather` algorithm operates on ranges of arbitrary item types. It modifies
    the order of the items in such a way that specific items are gathered around a
    specific position, chosen by the caller.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will implement the `gather` algorithm and a bonus variation
    of it. Afterward, we see how it can be put to use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add all the STL include statements. Then, we declare that we use
    the `std` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The `gather` algorithm is a nice example of standard algorithm composition.
    `gather` accepts a begin/end iterator pair, and another iterator `gather_pos`,
    which points somewhere in between. The last parameter is a predicate function.
    Using this predicate function, the algorithm will push all that items that *do*
    satisfy the predicate near the `gather_pos` iterator. The implementation of the
    item movement is done by `std::stable_partition`. The return value of the `gather`
    algorithm is a pair of iterators. These iterators are returned from the `stable_partition`
    calls, and this way, they mark the beginning and the end of the now gathered range:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Another variant of gather is `gather_sort`. It basically works the same way
    as `gather`, but it does not accept a unary predicate function; it accepts a binary
    comparison function instead. This way, it is possible to gather the values near
    `gather_pos`, which appear *smallest* or *largest*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s put those algorithms to use. We start with a predicate, which tells
    if a given character argument is the `''a''` character. We construct a string,
    which consists of wildly interleaved `''a''` and `''_''` characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We construct an iterator, which points to the middle of our new string. Let''s
    call `gather` on it and see what happens. The `''a''` characters should be gathered
    around the middle afterward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s call `gather` again, but this time, the `gather_pos` iterator is not
    in the middle but the beginning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'In a third call, we gather items around the end iterator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'With a last call of `gather`, we try to gather all the `''a''` characters around
    the middle again. This will not work as expected, and we will later see why:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We construct another string with underscore characters and some number values.
    On that input sequence, we apply `gather_sort`. The `gather_pos` iterator is the
    middle of the string, and the binary comparison function is `std::less<char>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Compiling and running the program yields the following interesting output. The
    first three lines look like expected, but the fourth line looks like `gather`
    did *nothing* to the string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the last line, we can see the result of the `gather_short` function. The
    numbers appear sorted towards either direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Initially, the `gather` algorithm is hard to grasp because it is very short
    but has a seemingly complex task. Therefore, let''s step through it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fcb79a46-e8cb-4732-aee3-ba7818d713d7.png)'
  prefs: []
  type: TYPE_IMG
- en: The initial state is a range of items, for which we present a predicate function.
    In the diagram, all items for which our predicate function returns `true`, are
    painted in *gray*. The iterators `a` and `c` mark the whole range, and iterator
    `b` points to a *pivot* element. The pivot element is the element around which
    we want to *gather* all the gray items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `gather` algorithm calls `std::stable_partition` on the range `[a, b)` and
    while doing that, it uses a *negated* version of the predicate. It negates the
    predicate because `std::stable_partition` moves all items for which the predicate
    returns `true` to the *front*. We want exactly the *opposite* to happen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another `std::stable_partition` call is done but, this time, on the range, `[b,
    c)`, and *without* negating the predicate. The gray items are moved to the front
    of the input range, which means they are all moved towards the pivot element pointed
    at by `b`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The items are now gathered around `b` and the algorithm returns iterators to
    the beginning and the end of the now consecutive range of gray items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We called `gather` multiple times on the same range. At first, we gathered all
    the items around the middle of the range. Then we gathered the items around `begin()`
    and then around `end()` of the range. These cases are interesting because they
    always lead *one* of the `std::stable_partition` calls to operate on an *empty*
    range, which results in *no action*.
  prefs: []
  type: TYPE_NORMAL
- en: We did the last call to gather again with the parameters `(begin, end, middle)`
    of the range, and that did not work. Why? At first, this looks like a bug, but
    actually, it is not.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine the character range, `"aabb"`, together with a predicate function, `is_character_a`,
    which is only true for the `'a'` items--if we call it with a third iterator pointing
    to the middle of the character range, we would observe the same *bug*. The reason
    is that the first `stable_partition` call would operate on the subrange, `"aa"`,
    and the other `stable_partition` call operates on the range, `"bb"`. This series
    of calls cannot result in `"baab"`, which we initially naively hoped.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get what we want in the last case, we could use `std::rotate(begin,
    begin + 1, end);`
  prefs: []
  type: TYPE_NORMAL
- en: The `gather_sort` modification is basically the same as `gather`. The only difference
    is that it does not accept a unary *predicate* function but a binary *comparison*
    function, just like `std::sort`. And instead of calling `std::stable_partition`
    twice, it calls `std::stable_sort` twice.
  prefs: []
  type: TYPE_NORMAL
- en: The negation of the comparison function cannot be done with `not_fn`, just like
    we did in the `gather` algorithm because `not_fn` does not work on binary functions.
  prefs: []
  type: TYPE_NORMAL
- en: Removing consecutive whitespace between words
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because strings are often read from user input, they may contain wild formatting
    and often need to be sanitized. One example of this is strings containing too
    many whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will implement a slick whitespace filtering algorithm, which
    removes excess whitespace from strings but leaves single whitespace characters
    untouched. We call that algorithm `remove_multi_whitespace`, and its interface
    will look very STL-like.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will implement the `remove_multi_whitespace` algorithm
    and check out how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we do some includes first and then declare that we use the `std`
    namespace by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: We implement a new STL-style algorithm called `remove_multi_whitespace`. This
    algorithm removes clustered occurrences of whitespace, but no single spaces. This
    means that a string line `"a b"` stays unchanged, but a string like
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`"a b"` is shrunk to `"a b"`. In order to accomplish this, we use `std::unique`
    with a custom binary predicate function. The `std::unqiue` walks through an iterable
    range and always looks at consecutive pairs of payload items. Then it asks the
    predicate functions whether two items are equal. If they are, then `std::unique`
    removes one of them. Afterward, the range does not contain subranges with equal
    items sitting next to each other. Predicate functions that are usually applied
    in this context tell whether two items are equal. What we do, is give `std::unique`
    a predicate, which tells if there are two consecutive *spaces* in order to get
    those removed. Just like `std::unique`, we accept a pair of begin/end iterators,
    and then return an iterator pointing to the new end of the range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'That is already it. Let''s construct a string that contains some unnecessary
    whitespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we use the *erase-remove idiom* on the string in order to get rid of the
    excess whitespace characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program yields the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We solved the whole complexity of the problem without any loop or manual comparison
    of items. We only provided a predicate function, which tells if two given characters
    are *whitespace* characters. Then we fed that predicate into `std::unique` and
    *poof*, all the excess whitespace vanished. While this chapter also contains some
    recipes where we had to fight a bit more to express our programs with STL algorithms,
    this algorithm is a *really* nice and short example.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does this interesting combination work in detail? Let''s have a look at
    a possible implementation of `std::unique` first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The loop steps over the range items, while they do not satisfy the predicate
    condition. At the point where an item satisfies the predicate, it moves such an
    item one item past the old position, where the predicate fired the last time.
    The version of `std::unique` that does not accept an additional predicate function
    checks whether two neighbor items are equal. This way, it wipes out *repeated*
    characters as it can , for example, transform `"abbbbbbc"` to `"abc"`.
  prefs: []
  type: TYPE_NORMAL
- en: What we want is not wiping out *all* characters which are repetitive, but repetitive
    *whitespace*. Therefore, our predicate does not say *"both argument characters
    are equal"*, but "*both argument characters are whitespace characters"*.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing to note is that neither `std::unique` nor `remove_multi_whitespace`
    really removes character items from the underlying string. They only move characters
    within the string according to their semantics and tell where its new end is.
    The removal of all now-obsolete characters from the new end till the old end must
    still be done. This is why we wrote the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: This adheres to the *erase-remove* idiom, which we already know from vectors
    and lists.
  prefs: []
  type: TYPE_NORMAL
- en: Compressing and decompressing strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section deals with a relatively popular task in coding interviews. The
    basic idea is a function, which takes a string like `"aaaaabbbbbbbccc"` and transforms
    it to a shorter string `"a5b7c3"`. It is `"a5"` because there are five `'a'` characters.
    And then it is `"b7"` because there are seven `'b'` characters. This is a very
    simple *compression* algorithm. For normal text, it is of reduced utility because
    normal language is usually not so repetitive that its text representation would
    become shorter with this compression scheme. However, it is relatively easy to
    implement even if we have to do it on a whiteboard without a computer. The tricky
    part is that it is easy to write a buggy code if the program is not structured
    very well from the beginning. Dealing with strings is generally not a hard thing,
    but the chances of implementing buffer overflow bugs lurk around *a lot* here
    if legacy C-style formatting functions are used.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try an STL approach to implementing string compression and decompression
    using this simple scheme.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will implement simple `compress` and `decompress` functions
    for strings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We include some STL libraries first, then we declare that we use the `std`
    namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'For our cheap compression algorithm, we try to find chunks of text containing
    ranges of the same characters, and we compress those individually. Whenever we
    start at one string position, we want to find the first position where it contains
    a different character. We use `std::find` to find the first character in the range,
    which is different than the character at the current position. Afterward, we return
    a tuple containing an iterator to that first different item, the character variable
    `c`, which fills the range at hand, and the number of occurrences that this subrange
    contains:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The `compress` algorithm continuously calls the `occurrences` function. This
    way, we jump from one same character group to another. The `r << c << n` line
    pushes the character into the output stream and then the number of occurrences
    it has in this part of the input string. The output is a string stream that automatically
    grows with our output. In the end, we return a string object from it, which contains
    the compressed string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The `decompress` method works similarly, but it is much simpler. It continuously
    tries to get a character value out of the input stream and, then, the following
    number. From those two values, it can construct a string containing the character
    as often as the number says. In the end, we again return a string from the output
    stream. By the way, this `decompress` function is *not safe*. It can be exploited
    easily. Can you guess, how? We will have a look at this problem later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'In our main function, we construct a simple string with a lot of repetition,
    on which the algorithm works very well. Let''s print the compressed version, and
    then the compressed and again decompressed version. In the end, we should get
    the same string as we initially constructed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and running the program yields the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This program basically revolves around two functions: `compress` and `decompress`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The decompress function is really simple because it only consists of variable
    declarations, a line of code, which actually does something, and the following
    return statement. The code line which does something is the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: It continuously reads the character, `c`, and the counter variable, `n`, out
    of the string stream, `ss`. The `stringstream` class hides a lot of string parsing
    magic from us at this point. While that succeeds, it constructs a decompressed
    string chunk into the string stream, from which the final result string can be
    returned back to the caller of `decompress`. If `c = 'a'` and `n = 5`, the expression
    `string(n, c)` will result in a string with the content, `"aaaaa"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compress function is more complex. We also wrote a little helper function
    for it. We called that helper function `occurences`. So, let''s first have a glance
    at `occurrences`. The following diagram shows how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/888717aa-d626-4a9c-a675-414518c45197.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `occurences` function accepts two parameters: an iterator pointing to the
    beginning of a character sequence within a range and the end iterator of that
    range. Using `find_if`, it finds the first character that is different from the
    character initially being pointed at. In the diagram, this is the iterator, `diff`.
    The difference between that new position and the old iterator position is the
    number of equal items (`diff - it` equals **6** in the diagram). After calculating
    this information, the `diff` iterator can be reused in order to execute the next
    search. Therefore, we pack `diff`, the character of the subrange, and the length
    of the subrange into a tuple and return it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the information lined up like this, we can jump from subrange to subrange
    and push the intermediate results into the compressed target string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In step 4, we mentioned that the `decompress` function is not safe. Indeed,
    it can easily be *exploited*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine the following input string: `"a00000"`. Compressing it will result
    in the substring `"a1"` because there is only one character, `''a''`. That is
    followed by five times `''0''`, which will result in `"05"`. Together, this results
    in the compressed string `"a105"`. Unfortunately, this compressed string says
    *"105 times the character `''a''`"*. This has nothing to do with our initial input
    string. Even worse, if we decompress it, we get from a six-character string to
    a 105-character string. Imagine the same with larger numbers--the user can easily
    *blow up* our heap usage because our algorithm is not prepared for such inputs.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to prevent this, the `compress` function could, for example, reject
    input with numbers, or it could mask them in a special way. And the `decompress`
    algorithm could take another conditional, which puts an upper bound on the resulting
    string size. I am leaving this as an exercise for you.
  prefs: []
  type: TYPE_NORMAL

- en: Introducing REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **Application Programming Interface** (**API**), in general, is used to get
    data from one application to another. There are different kinds of APIs that are
    used in different areas, such as hardware and programming, but we will be talking
    only about web APIs. Web APIs are a form of web service that provides an interface
    to communicate between multiple applications. Data from one application is sent
    to another application via an HTTP protocol using such APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will talk about:'
  prefs: []
  type: TYPE_NORMAL
- en: REST architecture and RESTful APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP verbs and status codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing and testing APIs using Postman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web APIs work in a similar way to how the browser interacts with our application
    server. The client requests some data from the server and the server responds
    with the formatted data to the client; APIs do something similar. For example,
    there is a contract set beforehand between the multiple applications. So, if there
    are two applications that need to share data, then one application will submit
    a request to another application, saying it needs this data in this format. When
    another application receives the request, it fetches the data from its server
    and responds with the structured and formatted data to the client or the requester.
  prefs: []
  type: TYPE_NORMAL
- en: Web APIs are classified into **Simple Object Access Protocol** (**SOAP**), **Remote
    Procedure Call** (**RPC**), or **Representational State Transfer** (**REST**)
    categories. The response format for these APIs can be in various forms, such as
    XML, JSON, HTML, images, and videos.
  prefs: []
  type: TYPE_NORMAL
- en: 'APIs also have different models, such as Public APIs and Private APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Private APIs**: Private or internal APIs are only used in internal applications
    within an organization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public APIs**: Public or external APIs are designed in a way such that they
    can be shared with the public parties outside of an organization as well'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is REST?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST is a web service used for exchanging data between multiple applications
    via an HTTP protocol. RESTful Web Services are scalable and easily maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple diagram that explains how the REST Web Service works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82db25c3-9e77-47ae-9a64-81168d222fb9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the diagram, the client requests some data by making a call
    to the Rest Web Service Server. Here, when we send an HTTP Request, we also provide
    some headers, such as what type of data we want as a response. These responses
    could be JSON, XML, HTML, or any other form. When the server receives the request
    and pulls data from storage, it does not simply return the database resources
    as a response. It sends a representation of these resources. That's why it is
    called **representational**. When the server responds to the client with this
    formatted data, the state of our application changes. And that's why it's called
    **state transfer**.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST APIs are designed with a RESTful architecture. The APIs built with the
    principles of RESTful architecture are called RESTful APIs. RESTful architecture
    is also called a **stateless architecture** because the connection between the
    client and server is not preserved. The connection is reset after every transaction
    between the client and the server.
  prefs: []
  type: TYPE_NORMAL
- en: Since there are multiple web services, we have to be able to choose what our
    requirements and needs are in order to build the perfect API for our application.
    The SOAP and REST protocols both have some benefits as well as limitations.
  prefs: []
  type: TYPE_NORMAL
- en: The SOAP protocol was designed in 1998 by Dave Winer. It uses **Extensible Markup
    Language** (**XML**) for data exchange. The choice between whether to use SOAP
    or REST depends on which programming language we choose when we are developing
    and the needs of the application.
  prefs: []
  type: TYPE_NORMAL
- en: REST APIs let us communicate between the applications in a JSON/XML data format.
    JSON/XML is a representation of data that is easy to format and readable for a
    human. With RESTful APIs, we can perform **Create**, **Read**, **Update**, and
    **Delete** (**C****RUD**) operations from one application to another.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'REST API provides a lot of benefits. Here are some of the advantages that we
    can get by using REST APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to make requests and get responses from one application to other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responses can be retrieved in human readable format in the form of JSON or XML.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything is manipulated in the form of URI, which means every request is identified
    by the URI request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The separation between client and server makes it easy to migrate to a different
    server when needed with minimal change. The segregation between client and server
    makes it easy to scale as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is independent of any programming languages. We can implement REST architecture
    irrespective of whether we are using PHP, JAVA, Rails, Node.js, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: it is very easy to get started and the learning curve is short.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP verbs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP verbs are the different methods that are used to define the action that
    we want to execute for the resources. The most used HTTP verbs are GET, POST,
    PUT, PATCH, and DELETE. HTTP verbs are the request methods that make it possible
    to communicate between multiple applications. These HTTP verbs make it possible
    to perform several actions on a resource without needing to alter the URLs entirely.
    Let's look into each of these in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: GET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GET` requests are the idempotent requests. This is used when we want to fetch
    the information about resources. This does not modify or delete the resource.
    The equivalent CRUD operation for `GET` requests is `READ`, which means it only
    fetches the information and that''s it. An example URL for a `GET` request is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To fetch all records:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To fetch information about a single user:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: POST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The equivalent CRUD operation for the `POST` request is `CREATE`. This is used
    with new records to the collection. Since this changes the state of the server,
    this is not an idempotent request. If we request a `POST` method twice with the
    same parameters, that will create two new identical resources in the database. An
    example URL for a `POST` request is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: PUT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `PUT` request is used to create or update a record. It creates a new record
    if the resource does not exist yet and updates the existing record if the resource
    already exists. The equivalent CRUD operation is `update()`. It replaces the existing
    representation of the resource. An example URL for a `PUT` request is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: DELETE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is used to remove resources from a collection. The equivalent CRUD operation
    is `delete()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example URL for a `DELETE` request is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: HTTP status codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Status codes are the part of a response made by the server for a request made
    to that server. It indicates the status of a request, irrespective of whether
    it got successfully executed or not. The status codes have three digits. The first
    digit represents the class or the category of that response. The HTTP status codes
    range from *100-500*.  We will be covering some of the major status codes in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 2XX codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The 200 range status code is the success range for any request in the API.
    Within the 200 range, there is a lot of code that represents different forms of
    success. Explained here are a few of the many status codes that are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**200 OK**: This response is the standard one. It is just a representation
    of the request being successful. This status code also returns the resource on
    which the request was executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**201 Created**: This represents the successful creation of a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**204 No Content**: This status code executes the request successfully, but
    does not return anything.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4XX codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The 400 range status codes appear when there is an error on the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: '**400 Bad Request**:When the request parameters are not well formatted, or
    the syntax is broken, then a 400 status code is returned by the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**401 Unauthorized**:This status code is returned when an unauthorized party
    tries to send the API request. This basically checks the authentication part.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**403 Forbidden**: This is somewhat similar to 401\. This checks the authorization
    of the party performing the API request. This is basically done when there are
    different permission settings for different users performing the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**404 Not Found**: This is returned when the resource that we are trying to
    perform some action on is not found by the server in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5XX codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The 500 range status code informs us that there is something wrong with the
    execution of the action performed in the given resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '**500 Internal Server Error**:This status code is displayed when the action
    is not executed successfully. Like the 200 status code, this is a generic code
    returned by the server when something goes wrong.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**503 Service Unavailable**: This status code is displayed when our server
    is not running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**504 Gateway Timeout**: This indicates that the request was sent to the server,
    but it did not get any response in the given time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Postman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Postman is a tool that lets us develop and test our APIs faster. This tool provides
    a GUI that makes it easy to tweak our APIs faster, which decreases the development
    time of our APIs. We can also maintain a history by creating a collection of all
    the APIs that we have developed.
  prefs: []
  type: TYPE_NORMAL
- en: There are different alternatives for Postman as well, such as Runscope and Paw.
    We will be using Postman for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Postman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different ways to use Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get the Chrome extension as follows: If you visit [https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en),
    we will see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7cf083eb-f22c-4715-be35-a6349a5190cb.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the Add to Chrome button and the extension will be installed.
  prefs: []
  type: TYPE_NORMAL
- en: We can download the right desktop application for our operating system via
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://www.getpostman.com/](https://www.getpostman.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: We have used the desktop application for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Testing APIs with Postman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s have a quick recap of what we have done so far. In the app that
    we are building, the `app.js` file should have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Since this file is auto-generated when we build the application via command
    CLI, it uses typescript syntax. If we want to use the ES 6 syntax, we can replace
    `var` with `const`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `models/User.js`, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, in `controllers/users.js`, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Adding a GET endpoint in the users controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add a route to our `controllers/users.js` that will fetch all the user's
    records from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, with the code we have in our `users` controller, when we visit `http://localhost:3000/users`,
    it only returns a title, `Users`. Let's modify this code to incorporate a `GET`
    request to fetch all user requests.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching all users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, start the server with `$ nodemon app.js`. Now, in `controllers/users.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our code in place, let''s test this endpoint using the Postman
    app. In the Postman app, add the necessary details in the URL. When we hit the
    Send button, we should see the response as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/699d3e88-8a89-4a99-adc1-b1f6787ede61.png)'
  prefs: []
  type: TYPE_IMG
- en: The `_id` is the Mongo ID of the user, which is sent by Mongoose query by default,
    and we are fetching the name and email of the user. If we want the names only,
    we can change our query in the `users` controller to fetch only the name.
  prefs: []
  type: TYPE_NORMAL
- en: Postman lets us edit the endpoints and requests are easy to develop. If we want
    to use our own local browser to test, we can do that as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have used a Chrome plugin called JSONview to format the JSON response. You
    can get the plugin from here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc](https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As I mentioned earlier, if we visit `http://localhost:3000/users`, we should
    be able to see something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30e07339-0247-45ce-8dc0-5eb058c78d6e.png)'
  prefs: []
  type: TYPE_IMG
- en: We can use the `save` query feature given by Postman to run those queries in
    future as well. Just click the Save button, which is in the top right-hand corner
    of the app. And create new queries as we go forward.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching a single user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in the HTTP verbs section, to fetch a single record from the collection,
    we have to pass an `id` of the user in the parameter in order to get the user
    details. From the preceding Postman response example, let''s pick an `id` and
    use it to fetch the record of a user. First, let''s add the endpoint to our controller.
    In `controllers/users.js`, add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new query in Postman with the following parameters. We will create
    a `GET` request with the URL `http://localhost:3000/users/:user_id` where `user_id`
    is the `id` of any user that you have created in your database. With this setting,
    we should be able to view something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dffcc2de-bd58-430f-9737-d443c9e04934.png)'
  prefs: []
  type: TYPE_IMG
- en: The query should return the details of the user with the given ID in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a POST endpoint in the users controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at an example. Let''s create an API that will use the MongoDB `insert()`
    command to save user resources in the database. In the users controller, add a
    new endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In Postman, set the method as `POST`, the URL as `http://localhost:3000/users`,
    set the parameters to raw JSON, and provide the following input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/88888180-6c04-4733-80ab-7c2fb1956557.png)'
  prefs: []
  type: TYPE_IMG
- en: Unlike the `GET` request, we have to pass the name and email of the user we
    want to add in the `body` parameter. Now, if we run a `GET all users` query, we
    should be able to see this new user. If we run the `POST` request twice with the
    same parameters, then it creates two different resources.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a PUT endpoint in the users controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s update a user with ID `5a3153d7ba3a827ecb241779` (change this ID to
    the ID of your document), which we just created. Let''s rename the email: to do
    that, first let''s add the endpoint in our users controller, in other words, `controllers/user.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'What we did here is, we added an endpoint for a `PUT` request, which takes
    the name and email as parameters and saves it to the database. The corresponding
    Postman would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2e262b8-d7e5-43d9-8e8f-b5e4770de526.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that the user's name has been updated. And, if we look at the
    request parameters, we have also added an `age` parameter. But since we haven't
    added `age` to our Schema while defining the User model, it discards the age value
    but updates the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `PATCH` method to update a resource. The difference between
    the `PUT` and `PATCH` methods is: the `PUT` method updates the whole resource,
    whereas `PATCH` is used for a partial update on resources.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a DELETE endpoint in the users controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similarly, for delete, let''s add an endpoint in `controllers/users.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code takes the ID of the user and removes the user with the given
    ID from the database. In Postman, the endpoint would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b749f8ca-090b-4425-baa2-f34541438cb7.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about what a RESTful API is, the different HTTP
    verbs and the status codes, and how to develop RESTful APIs and test them using
    Postman.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be jumping into the Vue.js introduction and will
    be building an application using Vue.js.
  prefs: []
  type: TYPE_NORMAL

- en: Testing an MEVN Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s do a quick recap of what we have done so far in previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: We created different Vue components for different pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We implemented Vuex—centralized state management for Vue.js applications, and
    defined state, getters, mutations, and actions for the components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created controllers and models to interact with the Node.js backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will discuss how to write test code to make sure that everything
    in the application works well. Writing test code is an integral part of any application.
    It helps to ensure that the functionalities that we have written do not break,
    and maintains the quality of the code we write.
  prefs: []
  type: TYPE_NORMAL
- en: Different practices can be followed while writing tests. It's always a good
    practice to write test code first, before writing the actual code. Writing tests
    ensures that our application will not break and everything will work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: This helps us to write better code and also helps to reveal the potential problems
    before they arise.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of writing tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing test code when developing an application has a lot of benefits. Some
    of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ensures code works as expected**: It helps to ensure that each piece of functionality
    that we have written in our application works exactly as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improves the quality of code**: It improves the quality of code. Since writing
    test code helps to  pre-empt defects that may arise, before we write actual code,
    it improves the quality of the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identifies bugs beforehand**: It helps to identify bugs in the early stages.
    Since test code is written for every functionality, bugs and issues can be identified
    early.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serves as documentation for new developers**: Test code is like documentation.
    If we need new developers to start work on the same application, test code helps
    them to understand how the application works instead of going through all the
    application code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application development is faster with test code**: If we write code without
    the test code, we will code faster. However, if we skip the process, we will later
    spending most of our time later fixing the bugs that will start to crawl in, which
    could have been identified earlier with the test code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application doesn''t need to be run**: Writing test code and running it doesn''t
    require the application to be up and running. It also doesn''t require the application
    to be built either. This reduces the development time significantly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, in this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn why and how to write unit tests and end-to-end tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about the technologies for writing test code for a Vue.js and Node.js
    application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify our application's structure to implement unit and end-to-end code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write test code for Vue components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is a software development process in which the smallest functionality
    of the application is tested and examined to check whether it works as expected
    or not. A unit is the smallest part of any application. Every test code written
    for a unit of an application is independent of each other. The goal of unit testing
    itself is to perform an individual tests and make sure that each piece is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Convention for writing unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you follow certain guidelines and principles while writing unit tests, it
    makes your code maintainable and readable. The following are a few techniques
    that we can use while writing unit tests for any application:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing should be carried out in small units—for a single class or a method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing should be carried out in isolation, meaning that a unit test should
    not be dependent on any other classes or methods, which is achieved by mocking
    such dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since unit testing is done in smaller parts, these should be very lightweight,
    which makes the tests run faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unit test should test the behavior of a unit of an application. It should
    expect a certain value and return a certain output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since unit tests are done in isolation, the ordering of tests for different
    units does not create a problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow **Do not Repeat Yourself** (**DRY**); the code should not be repeatable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add comments explaining where you can, which explains the why part of the test
    so that it is understandable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to end-to-end test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: End-to-end testing is the testing of our application from start to finish. Where
    as unit testing tests whether the functionalities of your application work independently
    or not—end-to-end testing checks whether the flow of the application is performing
    as expected or not. Usually, the end-to-end testing makes sure that all the user
    interactions are carried out the way as expected. End-to-end testing ensures that
    the flow of the application is working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Convention for writing end-to-end tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are certain guidelines to be followed when writing the end-to-end tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Test cases should be written considering the end users and considering the real
    scenario
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple test cases should be created for different scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The requirements should be gathered for all the software or applications that
    are involved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each requirement, gather as many conditions or scenarios as possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write separate test cases for each scenario
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technologies we will be using
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some of the packages that we will be working with to write the tests
    for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mocha**: A JavaScript test framework to write unit testing ([https://mochajs.org/](https://mochajs.org/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chai**: An assertion library for the Node.js framework ([http://chaijs.com/](http://chaijs.com/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sinon**: `sinon` is for test spies, stubs, and mocks ([http://sinonjs.org/](http://sinonjs.org/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nightwatch**: A JavaScript library for writing end-to-end tests ([http://nightwatchjs.org/](http://nightwatchjs.org/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Karma**: `karma` is the test runner for JavaScript ([https://karma-runner.github.io/2.0/index.html](https://karma-runner.github.io/2.0/index.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss each of these technologies as we go along.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Mocha
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a separate working directory to learn to write tests. Create
    a folder called `test_js`  and switch to the `test_js` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also create a separate folder for `test` inside the `test_js` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To access `mocha`, you have to install it globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's write a simple test code in `mocha`. We will write a test for a simple
    function, which takes two arguments and returns the sum of the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file called `add.spec.js` inside the `test` folder and add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the following command from the `test_js` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This test will fail, and we will require a utility called `add.js`, which does
    not exist. It displays the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fb7cc82-8cec-40c1-8d5f-584929a7e921.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s go ahead and write just enough code to pass the test. Create a file
    called `add.js` in the root of the `test_js` project and run the code again, which
    should pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fb775f9-cbe4-48e8-bfec-babd34f2c394.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s go ahead and add the logic to the test code to check our `add` function.
    In `add.spec.js`, add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now comes the `assert` library. The `assert` library helps to check whether
    the passed expression is right or wrong. Here, we will use the built-in assertion
    library for Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'To include the `assert` library, let''s add the following lines of code in
    `add.spec.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s rerun `mocha`. This should again fail, because we haven''t added a method
    to our module. So, let''s go ahead and do that.  In `add.js`, let''s add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s rerun `mocha`. The spec should pass now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e2c62a1-ff29-41b8-a5d3-13c0548354fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s add the functional part to the sum method. In `add_spec.js`, add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, take a look at the test; it fails. Then, add the logic to our module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, rerun `mocha` and the test should pass. That''s it!:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/031b7203-8a24-4c76-a0ea-cfa3dcfb0996.png)'
  prefs: []
  type: TYPE_IMG
- en: You can go on adding a few more cases to the test to ensure that nothing breaks.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing chai
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's discuss `chai`. `chai` is an assertion library, used with `mocha`. We
    could also use the native `assertion` library , but `chai` adds a lot of flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: '`chai` makes it a lot easier to write test definitions. Let''s install `chai`
    and modify the preceding test to make it look more simple and easy to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We passed the `-g` option to install it globally, since we do not have a `package.json`
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use `chai` in our previous test. In `add.spec.js`, add the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We have replaced the `assertion` library with, `chai` `expect()` method, which
    makes the code very much simpler and understandable.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing sinon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`sinon` is used to test spies, stubs, and mocks for JavaScript tests. To learn
    about these, let''s move on to the movie rating application we have in our `controller`
    file, `controller/movies.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, each API call needs a request and a response object,
    which we need to mock. For this purpose, we have `sinon`. `sinon` provides us with
    a mechanism to `stub` and `mock` the requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three major methods that `sinon` provides are spies, stubs, and mocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spies**: Spies helps to create fake functions. We can use spies to track
    whether the functions are executed or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stubs**: Stubs helps us to make functions return whatever we want. This is
    useful when we want to test different scenarios for the given function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mocks**: Mocks are used to fake network connections. They help to create
    a dummy class instance, which helps to set the predetermined expectations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s write a test for a `get` call in the `movies` controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a new file, called `movies.spec.js`, inside the `test/units`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This test code simply checks whether the `controller` exists or not, which
    should pass when we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This command runs the tests for our `controller/movies.js` and should pass
    with the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19083b7c-1469-4580-99ad-672027db64f7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s first write a test for a simple method. Let''s create a request that
    responds with just an object with a name. In `movies.js`,  let''s add the following
    code to create a dummy API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have a simple method that returns an object.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to add the functional test part. We will be writing the test for
    the `/dummy_test` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `movies.spec.js`, let''s add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have added a new package called `chai-http`, which
    is used to mock the request. Let''s install this package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now run the test with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command should give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7e5559c-b74b-43cb-ab62-d6998504a05a.png)'
  prefs: []
  type: TYPE_IMG
- en: Writing tests for Node.js server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start writing the tests for the application we built for the backend part
    of the `node` server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the following folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d12847d5-9326-47f1-a4c8-c06f8178230f.png)'
  prefs: []
  type: TYPE_IMG
- en: There are two folders inside the `test` folder. One for unit testing, called
    `unit`, and another for end-to-end testing, called `e2e`. We will start by writing
    the unit tests, which go under the `unit` directory. The naming convention is
    appending the `.spec` part to the filename for every file we will be writing tests
    for.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started with writing tests for the controllers we added. Create
    a folder called `controllers` inside the `test/unit/specs` and create a new file
    inside it called `movies.spec.js`. This will be the naming convention that we
    will follow while creating the test files for any components: controllers, models,
    or Vue components—the actual filename followed by `.spec.js`. This helps to maintain
    the readability of the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first recap what we have in our `movies.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This controller has two methods—one GET request and a POST request. The GET
    request is for fetching all the movies from the database, and the POST request saves
    the movies with the given parameters to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to adding the spec for the GET request first. Add the following
    contents in the `movies.spec.js` file that we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines required the corresponding controller and model for the `Movie`
    component, which we will need later. We will also require the server file.
  prefs: []
  type: TYPE_NORMAL
- en: The other packages, such as `chai`, `sinon`, `expect`, and `should`, are needed
    for the assertions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing that we will need to make requests to the server is a package
    called `chai-http`.  This package will be used for HTTP request assertions. So,
    let''s install this package first with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can get ahead with adding the first test. Replace the contents in `movies.spec.js`
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method describes the `movies` controller. It simply checks whether
    the controller we are describing exists or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure we have the connection of our `node` server, let''s export the
    server from `server.js`. Add the following code into `server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the test using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The test should pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to adding the test for the GET request. In `movies.js`, we have
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this method fetches all the existing movies from the database, we will
    first need to build the mock movies here to actually test it. Let''s replace the
    contents of `movies.spec.js` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s learn step by step what we did here:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a couple of movies with `sinon` mocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created an HTTP GET request using `chai`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We had three expectations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status of the request should be `200`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request response should be an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response should contain the list of movies that we created with the mock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s run the test again with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The tests should pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now move on to add the tests for the POST request for `movies.js`. In
    `movies.js`, here is what we have so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The POST method takes the preceding four attributes of the movie and saves
    them to the database. Let''s add the test for this POST request. Replace the contents
    of `movies.spec.js` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in the preceding code block, what we have done is, for the POST request:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are sending the POST request with movie parameters: `name`, `description`,
    `release_year`, and `genre`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We had three expectations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status of the request should be `200`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request response should be an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response should contain all four attributes, along with the ID of the movie
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now if we run the tests again, they should all pass.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can add tests for other controllers as well.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's move on to adding the tests for the models that we have defined. Let's
    create a folder called `models` inside `test/unit/specs` and create a test file
    for our `Movie.js` model. So, the name of the spec file would be `Movie.spec.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first take a look at what we have in our `Movie.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We just have a `Schema` defined here, which defines the data type for the `Movie`
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the specs for this model. Add the following contents to the `Movie.spec.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We do not need all the components that we added to the controller test here.
    We just have simple assertion tests here, so we will need the `Movie` model and
    the `chai` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the test for the `Movie` existence just like we did for the controller.
    Replace the contents in `Movie.spec.js` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This test checks whether the `Model` we are describing exists or not. Let''s
    run the test using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The test should pass with the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4da3257a-1664-4b20-b273-9196fb3ba7eb.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's move on to add a test when we send the `release_year` attribute of the
    `Movie` a string. Since we have a validation for the `release_year` attribute,
    sending a string value to it should throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the contents in `Movie.spec.js` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have prepared a movie object with `release_year` with an invalid value.
    The expectation we have here is that, when validating the model, it should send
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the test, and it should pass with the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4860ebca-061b-41d0-855f-a41f93c04a9e.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, we can add tests for other models as well.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for Vue.js components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's move on to write the test specs for our Vue.js components. We will start
    with the simplest component, which is the `Contact.vue` page.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we have in our `Contact.vue` page so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s modify the component a little bit to make the tests more understandable.
    Replace the contents in `Contact.vue` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s first create the necessary folder and file to write our tests.
    Create a file called `Contact.spec.js` inside the `test/unit/specs` directory
    and add the following contents to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have added a test to check whether the `vue` component
    `Contact.vue` renders the correct contents or not. We expected to have a `div`
    element with the `contact` class, and inside it, there should be an `h1` tag,
    which should contain the `this is contact` content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to make sure that our tests run, let''s verify that we have the correct
    script set up to run the unit test in `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the test with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The test should pass with the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78d15aee-07a0-4fb6-bea0-efe3af6bb819.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s move on to add specs for the component called `AddMovie.vue.` Create
    a file called `AddMovie.spec.js` inside `test/unit/specs` and add the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This test states that the `years` variable should have the given values, which
    is `['2018', '2017', '2016', '2015']`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another test to check whether the required methods exist in our
    `vue` component, `AddMovie.js`, or not. Replace the contents in `AddMovie.spec.js`
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the tests with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The tests should pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to run all the tests, we can simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Writing e2e testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The vue.js applications created with `vue-cli` command contains the support
    for end-to-end testing which uses `Nightwatch`. `Nightwatch` is a very easy framework
    to write end-to-end test. `Nightwatch` uses `Selenium` commands to run the JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Nightwatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you haven''t set up the application for `e2e`, then let''s first install
    the package needed to run the `e2e` tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Configuring Nightwatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we need a configuration file to run the test. Create a folder called `e2e`
    inside the `test` folder. Add the `nightwatch.conf.js` file and add the following
    contents to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, in the setting inside the `test_settings` attribute,
    we can see the different setups for different browsers. In this case, Chrome,
    Firefox, and the host and port settings for the development environment to run
    on the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, in the preceding code, we have specified two folders: `specs` and `custom-assertions`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `specs` folder contains the main test code for the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`custom-assertion` contains a script, which contains custom messages that get
    displayed when assertion tests are run on the command line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s first set up our `custom-assertions`. Create a file called `elementCount.js`
    inside `custom-assertions` and add the following contents to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If you checked the `e2e` option when creating this application, you should
    also have the `test/e2e/specs/test.js` file. If not, go ahead and create this
    file and add the following contents into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This is the main file, where we will add our test cases for the application.
  prefs: []
  type: TYPE_NORMAL
- en: The end-to-end testing makes sure that all the the flow of our application is
    performing as expected or not. When we run the `e2e` test, we want certain parts
    of our application to be clicked and behave the way it should. This can be described
    as testing the behavior of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to run the `e2e` tests, we will need to start a `selenium-server`.
    If we take a look at the `test/e2e/nightwatch.conf.js` file, we can find a line
    that says:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This means that when we run the `e2e` test, a `selenium-server` is started automatically,
    and we don't have to run a separate server. The port defines which port to use
    for `selenium-server`. You can leave this as it is and run the test, or you can
    change the values and configure it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need a `runner` file for `Nightwatch` to run the test. Create a
    file called `runner.js` inside the `e2e` folder and add the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use a stand-alone Selenium server and port `5555` for this application.
    For that, we will need to install the standalone server first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the package using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `npx` is a command that runs the npm packages.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are using the `5555` port, we will need to update it in the `nightwatch.conf.js`
    file as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the Selenium config in `nightwatch.conf.js` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Since we are using the `8081` port to run the `node` server, make sure that
    you update the `devServerURL` attribute as well, as was done in the preceding
    piece of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are all set to run the tests with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The test should fail with the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61bec658-6b51-44f6-a8dc-a8dba79c76cb.png)'
  prefs: []
  type: TYPE_IMG
- en: The tests are failing because we do not have the element present with the `.hello`
    class in our application. So, to make the tests pass, we first need to add an
    identifier to the elements, which we will be doing as a part the `e2e` tests by
    following the below steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the things that we want to capture with the `e2e` test:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the browser using `http://localhost:8081`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check whether the element with the `#inspire` ID exists. We have defined that
    in `App.vue` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Check that the sidebar consists of the `Home` and `Contact` page links
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `Contact` page
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The contact page should contain the text `this is contact`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the login page to make sure that the login works fine
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a movie to our application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rate the movie
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, add the ability for users to log out of the application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are the important parts of our application. So, we will need to add an
    identifier to all of preceding components. The best practice for adding an identifier
    to the elements is to define a `class` or an `id` while building the application
    itself. However, we will assign an identifier to the now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `App.vue`, update the highlighted parts with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, let''s update the `id` in `AddMovie.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, in `Login.vue`, let''s add corresponding `id` for the form fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Movie.vue`, update the `id` for `Rate this Movie` with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We have added the necessary identifier to all of the components. Now, let's
    add the `e2e` tests for the previously mentioned scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the contents of `test/e2e/specs/test.js` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the `e2e` script, make sure that we have set up the correct command
    in `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the `e2e` script, we should be able to run the test with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all the tests should pass, and the output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4288c176-6724-4551-ae71-395d9b03501b.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to write unit tests and we discussed the different
    technologies you can use to write them, such as `chai`, `mocha`, and `sinon`.
    You also learned to write tests for controllers, models, and Vue component.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about continuous integration and how to
    deploy your apps to Heroku using GitHub.
  prefs: []
  type: TYPE_NORMAL

- en: The Linux Command Line
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux命令行
- en: In this chapter, we will introduce you to the most fundamental concepts when
    starting to work with the Linux command line. It is a very powerful and efficient
    tool with which you can execute the various actions that you'll generally require
    when using Linux. A plethora of shortcuts and tricks will help you to navigate
    the command line more efficiently.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您介绍开始使用Linux命令行时最基本的概念。这是一个非常强大和高效的工具，您可以使用它执行在Linux中通常需要的各种操作。大量的快捷方式和技巧将帮助您更有效地导航命令行。
- en: 'In this chapter, we''ll walk you through the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将带您了解以下内容：
- en: Shell globbing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell通配符
- en: Redirecting and piping
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向和管道
- en: The `grep`, `sed`, and `awk` commands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep`、`sed`和`awk`命令'
- en: Navigating files and folders in a Linux system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux系统中导航文件和文件夹
- en: Introducing the command line
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍命令行
- en: In this section, you'll learn how to run Linux command-line programs and what
    the basic structure of the command line is. You will also learn what program options
    and arguments are and why they are important for customizing your commands.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何运行Linux命令行程序以及命令行的基本结构是什么。您还将了解程序选项和参数以及它们对自定义命令的重要性。
- en: When we say the Linux command line, what we really mean is the **shell**. It's
    important to know that the shell is not the same as a terminal emulator. A Terminal
    is a screen or window that lets you access a Linux server's input and output.
    A shell is just a program that runs on the server as does any other command and
    which awaits, interprets, processes, executes, and responds to commands typed
    in by the user.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说Linux命令行时，我们真正指的是**shell**。重要的是要知道shell不同于终端仿真器。终端是一个屏幕或窗口，让您访问Linux服务器的输入和输出。shell只是在服务器上运行的一个程序，就像任何其他命令一样，它等待、解释、处理、执行和响应用户输入的命令。
- en: 'First, open up a new terminal emulator and log in to your CentOS 7 server by
    using SSH, as we learned in the [Chapter 1](16d0169d-0972-43c0-b5e4-228d9b8956ad.xhtml),
    *Introduction to Linux*. Log in using your normal user account, which you set
    up during installation, because, as we have said before, never work with the root
    user unless you have to. In my example, the username is `olip`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开一个新的终端仿真器，并使用SSH登录到您的CentOS 7服务器，就像我们在[第1章](16d0169d-0972-43c0-b5e4-228d9b8956ad.xhtml)中学到的那样，*Linux简介*。使用您在安装过程中设置的普通用户账户登录，因为正如我们之前所说的，除非必须，永远不要使用root用户。在我的示例中，用户名是`olip`：
- en: '![](img/3973123b-3647-47cd-963a-91fd8ea28937.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3973123b-3647-47cd-963a-91fd8ea28937.png)'
- en: After successfully logging in to your server, an important program has been
    started automatically, which is called the shell, and which have been using this
    whole time. In fact, when we talk about the Linux Terminal, what we are really
    speaking of is the shell. There exist several shell variants; on CentOS 7 we are
    using **Bash**, or the **Bourne Again Shell**, by default. When the shell is started,
    the first thing you will notice is the line ending with the dollar sign ($), which
    is called the shell prompt.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 成功登录到服务器后，一个重要的程序已经自动启动，这个程序叫做shell，我们一直在使用它。事实上，当我们谈论Linux终端时，我们真正说的是shell。存在几种shell变体；在CentOS
    7上，默认使用**Bash**，或者**Bourne Again Shell**。当shell启动时，您会注意到以美元符号($)结尾的行，这被称为shell提示符。
- en: 'In our example, it gives us some useful information: the login username and
    the current directory we''re on. The tilde is a special character and it means
    home directory, which is the default directory when logging in. After the shell
    prompt comes the cursor, which is the underscore character, and this is where
    the user can type in the text that then gets processed and executed by the shell.
    But user input will only get processed and executed by the shell when the input
    has been ended with the *Enter* key. If you make any type of mistake, just hit
    the backspace key to delete the last character. The first useful command we will
    learn in this chapter is how to log out of the system.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，它为我们提供了一些有用的信息：登录用户名和当前所在的目录。波浪号是一个特殊字符，表示家目录，这是登录时的默认目录。在shell提示符之后是光标，即下划线字符，这是用户可以输入文本的地方，然后由shell处理和执行。但是只有当输入以*Enter*键结束时，用户输入才会被shell处理和执行。如果出现任何错误，只需按下退格键删除最后一个字符。我们将在本章学习的第一个有用的命令是如何退出系统。
- en: 'On the Linux Terminal, this command logs out the current user and goes back
    to the login screen:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux终端上，这个命令注销当前用户并返回到登录屏幕：
- en: Open the Linux Terminal and type the `logout` command and after that press the
    *Enter* key.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Linux终端，输入`logout`命令，然后按*Enter*键。
- en: However, if you perform the same operation while using an SSH connection, it
    has the same effect as the `exit` command that we learned about in the previous
    chapter.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，如果您在使用SSH连接时执行相同的操作，它的效果与我们在上一章学到的`exit`命令相同。
- en: Let's try to log in again to the CentOS server.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次尝试登录到CentOS服务器。
- en: 'Let''s try out a simple command; type `date` and press the *Enter* key. This
    is a command that prints out the current date-time value:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试一个简单的命令；输入`date`并按下*Enter*键。这是一个打印当前日期时间值的命令：
- en: '![](img/997fd978-1da6-461b-a240-4087ce52aff9.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/997fd978-1da6-461b-a240-4087ce52aff9.png)'
- en: As you can see, if the shell has finished executing a specific command and is
    ready to accept new input by the user, a new shell prompt will appear in a new
    line marking its readiness. Now, type `cal` and press *Enter*. This command prints
    out a nice table view of the current month.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果shell已经执行完特定命令并准备接受用户的新输入，新的shell提示符将出现在新行中标志着它的准备就绪。现在，输入`cal`并按*Enter*。这个命令打印出当前月份的一个漂亮的表格视图。
- en: If the first character of any command types is prepended in the shell with the
    hash key, the command will not be executed when pressing the *Enter* key.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何命令类型的第一个字符在shell中以井号键前置，当按下*Enter*键时，该命令将不会被执行。
- en: A typical Linux system such as CentOS 7 contains hundreds of different commands
    included in the default installation. If you could only type in the pure commands
    and nothing more, our work in the shell would be very limited and static and you
    would not be able to work properly at all. So, we need a way to customize our
    commands or change the default behavior during execution, feeding them further
    information. But how can we do that?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的Linux系统，比如CentOS 7，包含了默认安装的数百个不同的命令。如果你只能输入纯命令而没有其他东西，我们在shell中的工作将非常有限和静态，你将无法正常工作。因此，我们需要一种方法来自定义我们的命令或在执行过程中改变默认行为，提供更多的信息。但是我们该如何做呢？
- en: 'Enter the power of command-line options and arguments. First, we need to discuss
    the general structure of a command in the shell, which in its most simple form
    is `COMMANDNAME OPTIONS ARGUMENTS`. The command name is the name of the command
    to be started. Be careful, in Linux command names are case sensitive. Type `whoami`
    and then press *Enter*. This command will print out the name of the current user
    working in the shell. As Linux is case sensitive, this command cannot be started
    using uppercase letters, such as each version refers to a different command. Here,
    we will also see why the shell is such a useful program. It not only listens and
    interprets commands, but it also shows you helpful error messages when something
    goes wrong, such as a command cannot be found in the system. Normally, on Linux
    all standard Bash script commands are written in lowercase. To get a list of some
    of the available commands, type `ls /bin`. Now, let''s move on to one of the most
    fundamental commands available in the shell. Type `ls` and press the *Enter* key.
    This command lists files in a directory. If no further information is given, it
    prints out all the visible files in the directory that we are currently in at
    the moment:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 进入命令行选项和参数的力量。首先，我们需要讨论shell中命令的一般结构，它最简单的形式是`COMMANDNAME OPTIONS ARGUMENTS`。命令名称是要启动的命令的名称。注意，在Linux中命令名称是区分大小写的。输入`whoami`然后按*Enter*。这个命令将打印出在shell中工作的当前用户的名称。由于Linux是区分大小写的，这个命令不能使用大写字母启动，比如每个版本都指代不同的命令。在这里，我们也将看到为什么shell是一个如此有用的程序。它不仅听取和解释命令，而且在出现问题时还会显示有用的错误消息，比如系统中找不到一个命令。通常，在Linux上所有标准的Bash脚本命令都是用小写字母编写的。要获取一些可用命令的列表，输入`ls
    /bin`。现在，让我们继续讨论shell中可用的最基本的命令之一。输入`ls`并按*Enter*键。这个命令列出目录中的文件。如果没有提供更多的信息，它将打印出我们当前所在目录中所有可见的文件：
- en: '![](img/df3b85c2-095a-4ffe-97cb-0be15e3cad29.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df3b85c2-095a-4ffe-97cb-0be15e3cad29.png)'
- en: As you can see, a shell command can also contain options and arguments that
    are appended to the command name and separated from it using spaces. This means
    if you want to provide at least one option or argument, then we need at least
    one space after the command name. First, let's talk about command-line options.
    Their aim is to influence the behavior of a command. They are also called **switches**
    or **flags**. There is no obligatory standard, but normally any single-character
    command-line option starts with a single dash, whereas longer option names have
    two dash symbols. Also, if you want to provide multiple single-character command-line
    options, for most standard Linux commands you can just write them in series. It
    is good to know that single-character command-line options are often abbreviations
    describing their meaning: `-d` could stand for directory, `-x` for exclude, and
    so on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，一个shell命令也可以包含附加到命令名称的选项和参数，并且用空格分隔开。这意味着如果你想提供至少一个选项或参数，那么在命令名称后至少需要一个空格。首先，让我们谈谈命令行选项。它们的目的是影响命令的行为。它们也被称为**开关**或**标志**。没有强制性的标准，但通常任何单字符命令行选项以单破折号开头，而较长的选项名称有两个破折号符号。此外，如果你想提供多个单字符命令行选项，对于大多数标准的Linux命令，你可以直接连续写它们。值得知道的是，单字符命令行选项通常是描述它们含义的缩写：`-d`可能代表目录，`-x`代表排除，等等。
- en: 'We already know that the `ls` command without any further options gives us
    a list of all the files in the current directory. If you type `ls -a` and press
    *Enter*, you just run your first command with the command-line option. The `a`
    switch stands for all and this influences the default behavior `ls` by giving
    you a list of all files, including the hidden ones, which in Linux start with
    the leading dash in the current directory. Now, let''s type `ls -alth` and press
    the *Enter* key to see the result:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，`ls`命令没有任何其他选项时会给我们当前目录中所有文件的列表。如果你输入`ls -a`并按*Enter*，你就运行了你的第一个带命令行选项的命令。`a`开关代表所有，这通过给你一个包括隐藏文件在内的所有文件的列表来影响`ls`的默认行为，这些文件在Linux中以当前目录中的前导破折号开头。现在，让我们输入`ls
    -alth`并按*Enter*键来看结果：
- en: '![](img/7794f997-1e4a-49d5-b10a-3d1e7ef60280.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7794f997-1e4a-49d5-b10a-3d1e7ef60280.png)'
- en: This influences the command's default behavior even more by using the `-a` flag
    that we just discussed, and also using the `-l` switch, which stands for **list**,
    and it prints all the files in a list format, including more detailed information,
    such as the creation date. The `-t` switch stands for **time** and it sorts the
    file list by modification date with the newest entries appearing first, and `-h`
    stands for **human readable** and it will print out the file size in a more readable
    form using **MB** instead of bytes for the file size.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过使用我们刚刚讨论的`-a`标志更进一步影响了命令的默认行为，并且还使用了`-l`开关，代表**列表**，它以列表格式打印出所有文件，包括更详细的信息，比如创建日期。`-t`开关代表**时间**，它按修改日期对文件列表进行排序，最新的条目首先出现，`-h`代表**人类可读**，它将以更易读的形式打印出文件大小，使用**MB**而不是字节来表示文件大小。
- en: Often, command-line options can have arguments bound to them. In addition to
    options, we have command-line arguments, which are also called **parameters**.
    This is any dynamic or free-text piece of information that is not an option, and
    which gets fed into the command when it starts. Typical examples are filenames
    or directories that the command wants to process during execution. Arguments are
    also divided by *spaces*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，命令行选项可以有与之绑定的参数。除了选项，我们还有命令行参数，也称为**参数**。这是在命令启动时输入的任何动态或自由文本信息，它不是选项，并在执行期间被传递给命令。典型的例子是命令在执行期间想要处理的文件名或目录。参数也由*空格*分隔。
- en: 'Type `echo Hello` and press *Enter*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 键入`echo Hello`并按*Enter*键：
- en: '![](img/d5263ce5-9a0b-4a9f-b0c1-1a1565fec613.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5263ce5-9a0b-4a9f-b0c1-1a1565fec613.png)'
- en: 'In the previous command, `Hello` is an argument for the `echo` command and
    not an option. The `echo` command is one of the most fundamental shell commands.
    It just prints the arguments given to it back to the command line. As we will
    see, this is ideal for testing shell features such as **globbing**, which we will
    learn more about later in this section. Now let''s type `ls -al /boot /var` in
    the Terminal and press *Enter* to see a result similar to the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个命令中，`Hello`是`echo`命令的参数，而不是选项。`echo`命令是最基本的shell命令之一。它只是将给定的参数打印回命令行。正如我们将看到的，这对于测试shell功能非常理想，比如**通配符**，我们稍后将在本节中学到更多关于它的知识。现在让我们在终端中键入`ls
    -al /boot /var`并按*Enter*键，以查看类似以下的结果：
- en: '![](img/1f8ccccd-1e52-4272-afeb-d3155c28a548.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f8ccccd-1e52-4272-afeb-d3155c28a548.png)'
- en: In this example, for the first time we used command-line options and arguments.
    The command `ls` is executed with the `a` and `l` options, and the arguments are
    `/boot` and `/var`. This will print out all the files, including hidden ones,
    in a detailed list view in the `/boot` and `/var` directories. As mentioned before,
    oftentimes arguments are bound to specific options, for example, the `tar` command,
    which we will discuss later. When you need to process an input file, you have
    to specify directly after the `-f` option and nowhere else or, in short, the input
    file argument is bound to the `-f` option. This approach is incorrect and will
    produce errors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们第一次使用了命令行选项和参数。`ls`命令使用`a`和`l`选项执行，并且参数是`/boot`和`/var`。这将打印出`/boot`和`/var`目录中的所有文件，包括隐藏文件，以详细列表视图显示。如前所述，通常情况下参数与特定选项绑定，例如`tar`命令，我们稍后会讨论。当您需要处理输入文件时，您必须直接在`-f`选项之后指定，而不是其他地方，或者简而言之，输入文件参数与`-f`选项绑定。这种方法是不正确的，会产生错误。
- en: File globbing
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件通配符
- en: In this section, you will learn how shell expansion works and how we can use
    file globbing to make our lives easier when using commands that deal with a lot
    of input files. We will discuss all existing and available shell globbing character
    classes and show you important use cases and examples for each of them. When working
    with commands that use file or directory names as arguments, such as the `ls`
    command, it is very helpful to learn about file and directory globbing. These
    are special characters typed in the shell that behave differently than regular
    characters. All globbing characters are going to be replaced by the shell with
    a list of files matching the characters' pattern right before any command can
    use them as parameters. It's a notation to simplify working with files, especially
    when dealing with a large number of files that you need to type and process. Using
    file globbing can save you a lot of time, by not doing repetitive work, because
    multiple files can be addressed by a single-character. The concept of replacing
    such special characters with a group list of files by the shell is also called
    **shell expansion**. There are several globbing characters available and we can
    use them to create very sophisticated file list selections.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，您将学习shell扩展的工作原理，以及我们如何使用文件通配符来使我们在使用处理大量输入文件的命令时更加轻松。我们将讨论所有现有和可用的shell通配符字符类，并为每个字符类展示重要的用例和示例。在处理将文件或目录名称作为参数的命令时，比如`ls`命令，学习文件和目录通配符非常有帮助。这些是在shell中键入的特殊字符，其行为与普通字符不同。所有通配符字符都将在任何命令使用它们作为参数之前被shell替换为与字符模式匹配的文件列表。这是一种简化处理文件的表示法，特别是在处理大量需要输入和处理的文件时。使用文件通配符可以节省大量时间，因为多个文件可以由一个字符表示。将这些特殊字符替换为文件组列表的概念也称为**shell扩展**。有几个可用的通配符字符，我们可以使用它们来创建非常复杂的文件列表选择。
- en: Globbing characters are the wildcard, the question mark, the exclamation mark,
    the square brackets, and the dash. Although they look and behave very similarly,
    shell globbing and regular expressions are not the same, and both concepts are
    not interchangeable. This means you cannot apply regular expressions for globbing
    files and vice versa. We will learn more about regular expressions in an upcoming
    section in this chapter. The most important globbing character is the wildcard
    character. It will match any number of any character filename available in a specific
    directory, with one exception, it does not match files beginning with a dot, which
    you may have already noticed when looking at hidden files in Linux. What happens
    if you use the wildcard character with a file beginning with a dot and press *Enter*?
    Let's look at an example. As we showed before, we can use the `echo` command to
    print out random text in the Terminal.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符字符是通配符、问号、感叹号、方括号和破折号。尽管它们看起来行为非常相似，但shell通配符和正则表达式并不相同，这两个概念也不可互换。这意味着您不能将正则表达式应用于通配文件，反之亦然。我们将在本章的后续部分中学习更多关于正则表达式的知识。最重要的通配符字符是通配符字符。它将匹配特定目录中任意数量的任何字符文件名，有一个例外，它不匹配以点开头的文件，这一点您可能已经注意到了在Linux中查看隐藏文件时。如果您使用通配符字符与以点开头的文件并按*Enter*键会发生什么？让我们看一个例子。正如我们之前展示的，我们可以使用`echo`命令在终端中打印出随机文本。
- en: 'Let''s first change to a different directory. Type `cd /etc` and press *Enter*.
    Now, type `echo *` and press *Enter*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先切换到另一个目录。输入`cd /etc`并按*Enter*。现在，输入`echo *`并按*Enter*：
- en: '![](img/f1dc0322-b8d6-41ba-8e8c-ae951eb1e8f7.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1dc0322-b8d6-41ba-8e8c-ae951eb1e8f7.png)'
- en: 'In the previous command, in the first step, the shell replaces the wildcard
    character with a list of files in the current directory and prints them separated
    by whitespace that follows the rule, and then shows all files and directories
    that contain any character, but it doesn''t show files that start with a dot.
    Using `echo` is the perfect way to test whether your globbing patterns match exactly
    what you want before applying them as real command-line arguments. You can mix
    the wildcard character with any other static character to make a file filter more
    stringent. Type `echo pa*` and press *Enter*. This will match all files starting
    with a lowercase `p` followed by `a`, followed by any other character. Or type
    `echo *.d` and press *Enter*. This example finds all files that have the `.d` filename
    extension:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个命令中，在第一步中，shell将通配符替换为当前目录中的文件列表，并按照规则用空格分隔打印出来，然后显示包含任何字符的所有文件和目录，但不显示以点开头的文件。使用`echo`是测试您的通配模式是否完全匹配您想要的内容的完美方式，然后将其应用为真实的命令行参数。您可以将通配符与任何其他静态字符混合使用，使文件过滤更严格。输入`echo
    pa*`并按*Enter*。这将匹配所有以小写`p`开头，后跟`a`，后跟任何其他字符的文件。或者输入`echo *.d`并按*Enter*。这个例子找到所有具有`.d`文件扩展名的文件：
- en: '![](img/3edc1a0f-159c-4235-9b08-eb72bf4c4b43.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3edc1a0f-159c-4235-9b08-eb72bf4c4b43.png)'
- en: You can even define a more stringent pattern, for example, by typing `echo li*.conf`
    and pressing *Enter*. This globbing pattern will match all files in your current
    directory starting with a lowercase `l`, followed by `i`, followed by any other
    character, but only those that have a `.conf` filename extension. We can use file
    globbing with any command that accepts an option list of files as arguments, such
    as the `ls` command.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以定义一个更严格的模式，例如，输入`echo li*.conf`并按*Enter*。这个通配模式将匹配当前目录中以小写`l`开头，后跟`i`，后跟任何其他字符的所有文件，但只有那些具有`.conf`文件扩展名的文件。我们可以在接受文件选项列表作为参数的任何命令中使用文件通配，比如`ls`命令。
- en: For example, using the globbing pattern, `li *.conf`, as a command-line argument
    for the `ls` command, gives us a detailed list of all the files matched by this
    pattern. Again, it's important to understand that we are not feeding the globbing
    pattern into the `ls` command and `ls` is not expanding files internally during
    the execution of the program. The truth is that a shell in the first step expands
    the wildcard character to a list of files and then feeds this list as arguments
    to the `ls` command.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用通配模式`li *.conf`作为`ls`命令的命令行参数，会给我们一个详细的列表，列出了这个模式匹配的所有文件。同样，重要的是要理解，我们并没有将通配模式输入`ls`命令，`ls`在程序执行期间也不会内部扩展文件。事实上，shell在第一步中将通配符扩展为文件列表，然后将此列表作为`ls`命令的参数。
- en: We will use the `ls -d` option to not show directory content, which it does
    by default; this is because shell globbing doesn't differentiate between files
    and directories.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`ls -d`选项来不显示目录内容，默认情况下会显示；这是因为shell通配不区分文件和目录。
- en: 'Type `ls -d rc?.d` in the Terminal. This will get you a list of all the files
    that have only a random character as the third character. Next, type in the `ls
    -d krb5.conf??` command, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中输入`ls -d rc?.d`。这将为您列出所有只有一个随机字符作为第三个字符的文件。接下来，按照以下方式输入`ls -d krb5.conf??`命令：
- en: '![](img/c7c97ed5-ae3a-47ee-bf3a-1ec2eb4c6d25.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7c97ed5-ae3a-47ee-bf3a-1ec2eb4c6d25.png)'
- en: 'As you can see, the question mark can also be used multiple times. This will
    get all files that have two random characters at the extension and only these
    files. The final globbing characters that we will learn about are the square brackets,
    which define ranges of allowed characters at a specific position, for example,
    type `ls -l sub[ug]id`. This will expand to a list of all the files starting with
    `sub` and having either `u` or `g` as the fourth character, followed by the word
    `id`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，问号也可以多次使用。这将获取所有具有扩展名的两个随机字符的文件，只有这些文件。我们将要学习的最后一种通配符是方括号，它定义了特定位置上允许字符的范围，例如，输入`ls
    -l sub[ug]id`。这将扩展为以`sub`开头并且第四个字符为`u`或`g`，后跟`id`的所有文件列表：
- en: '![](img/5dce98d6-f011-4606-99a5-9e0e4e1effdf.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5dce98d6-f011-4606-99a5-9e0e4e1effdf.png)'
- en: 'As we will learn next, we can mix the brackets with other globbing characters.
    Type the following `ls` command argument:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下面学到的，我们可以将括号与其他通配符字符混合使用。输入以下`ls`命令参数：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This expands to a list of all the mail programs in the `bin` directory with
    and without capitalization. We will learn more about the `bin` directory later.
    You can also use numbers for ranges; type the `ls -d rc[01234].d` command in the
    Terminal:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将扩展为`bin`目录中所有邮件程序的列表，包括大小写。我们稍后将学习更多关于`bin`目录的知识。您还可以使用数字来表示范围；在终端中输入`ls -d
    rc[01234].d`命令：
- en: '![](img/91788f1c-35a5-43be-9bcb-aaa224664a62.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91788f1c-35a5-43be-9bcb-aaa224664a62.png)'
- en: In our example, this would be expanded to `rc0.d`, `rc1.d`, and so on. If you
    have consecutive ranges of numbers or letters, as in the last example, you can
    also use the minus symbol to shorten your globbing expression even more. For example,
    type `ls /bin/m[a-z] [a-z]`. This would give us all the three-letter command names
    in the `bin` directory starting with `m`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，这将扩展为`rc0.d`，`rc1.d`等。如果您有连续的数字或字母范围，就像在最后一个例子中一样，您还可以使用减号来进一步缩短您的通配表达式。例如，输入`ls
    /bin/m[a-z] [a-z]`。这将给我们`bin`目录中以`m`开头的所有三个字母命令名称。
- en: 'There''s another helpful globbing character, which is the exclamation mark,
    and it can be used in brackets to define something that must not be in expansion
    results, for example, `ls -d rc[!256].d`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个有用的通配符，即感叹号，它可以在括号中使用，定义在扩展结果中不得出现的内容，例如，`ls -d rc[!256].d`：
- en: '![](img/485cd3dd-c149-4cfb-b3fc-1700138933a5.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/485cd3dd-c149-4cfb-b3fc-1700138933a5.png)'
- en: This says that we don't want to expand files that have a `2`, `5`, or `6` as
    the third character. This also works for consecutive ranges within brackets, for
    example, `ls -d rc[!3-6].d`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示我们不希望扩展第三个字符为`2`、`5`或`6`的文件。这也适用于括号内的连续范围，例如，`ls -d rc[!3-6].d`。
- en: 'You have already learned three things about hidden files in Linux. They start
    with a dot in the filename, the wildcard globbing character ignores them, and
    `ls`, by default, doesn''t show them; therefore, they''re named hidden. To show
    all hidden files in your home directory, we use the `-a` option with the `ls`
    command. You see that there are several hidden files in your home directory, for
    example, the `.bashrc` file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学到了关于Linux中隐藏文件的三件事。它们的文件名以点开头，通配符通配字符会忽略它们，`ls`默认情况下不显示它们；因此，它们被称为隐藏。要显示主目录中的所有隐藏文件，我们使用`ls`命令的`-a`选项。您会看到主目录中有几个隐藏文件，例如`.bashrc`文件：
- en: '![](img/873ee66e-2631-4a6b-909f-71cd386f56a8.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/873ee66e-2631-4a6b-909f-71cd386f56a8.png)'
- en: 'But there are also two other special files in your directory with the name
    [`.`] and [`..`], we will learn what these two special files are later on this
    chapter. What do you need to type if you want to display only the hidden files
    in the current directory without those two dot files? With all the knowledge you
    now have, this should be easy to accomplish, and the next line should now make
    sense to you. So, type `ls .[!.]*`. But this will also list directory contents.
    To not list directory contents, use the `ls -d` flag, so the command will be `ls
    -d .[!.]*`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在您的目录中还有两个特殊文件，名为[`.`]和[`..`]，我们将在本章后面学习这两个特殊文件是什么。如果您只想显示当前目录中的隐藏文件而不包括这两个点文件，您需要输入什么？有了您现在拥有的所有知识，这应该很容易实现，下一行现在应该对您有意义。因此，输入`ls
    .[!.]*`。但这也会列出目录内容。为了不列出目录内容，使用`ls -d`标志，因此命令将是`ls -d .[!.]*`：
- en: '![](img/40f6e6de-d304-4168-ba3d-de3df85e21d7.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40f6e6de-d304-4168-ba3d-de3df85e21d7.png)'
- en: 'In this section, we discussed everything there is to know about Linux shell
    globbing. Remember, the wildcard character matches every filename character in
    any position. It''s very important that there is one exception to this rule: it
    does not match filenames starting with a dot, which are called hidden files in
    Linux. The question mark does the same, but only in a single position; it also
    doesn''t match filenames with the leading dot. The brackets match specific characters
    in a single position defined between the brackets. When having consecutive permitted
    characters, you can also use the dash symbol. To match everything except a set
    of characters at a specific position, use the exclamation mark in brackets.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了关于Linux shell通配符的一切。请记住，通配符字符匹配任何位置的每个文件名字符。对于这个规则有一个例外是非常重要的：它不匹配以点开头的文件名，这在Linux中称为隐藏文件。问号也是如此，但只在单个位置上；它也不匹配以点开头的文件名。括号在括号之间定义的单个位置匹配特定字符。当具有连续允许字符时，您还可以使用破折号符号。要匹配特定位置上除了一组字符之外的所有内容，请在括号中使用感叹号。
- en: Quoting commands
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用命令
- en: 'As we learned in the previous section, the shell has a list of special characters
    that have a special meaning in the shell and trigger some functionality, such
    as using the wildcard character as filenames. But there are even more special
    characters than the ones we showed you before. If you want to work with such special
    characters, for example, using filenames that contain question mark symbols, which
    are valid filenames, you have a problem, as the shell always first tries to apply
    special actions to special characters, so they will not work as normal filename
    characters. The solution here is to disable all special meanings of such characters
    using various approaches, such as quoting, so that we can treat them as any other
    normal literal character. As you now know, in the Linux Bash shell, there are
    some special characters, such as `* # [ ] . ~ ! $ { } < > | ? & - / , "` which
    have special meaning to the shell and get treated differently than normal characters.
    But what if you want to use a filename or directory as an argument that has one
    such special character in its name? Also, how do you treat filenames with spaces
    in the name, which can also be seen as special characters?'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们在前一节中学到的，shell有一系列特殊字符，在shell中具有特殊含义并触发某些功能，例如使用通配符字符作为文件名。但是，特殊字符比我们之前向您展示的还要多。如果您想使用包含问号符号的文件名等特殊字符，您将遇到问题，因为shell总是首先尝试对特殊字符应用特殊操作，因此它们不会像正常的文件名字符一样工作。解决方案是使用各种方法禁用这些字符的所有特殊含义，例如引用，以便我们可以将它们视为任何其他普通的文字字符。正如您现在所知，在Linux
    Bash shell中有一些特殊字符，例如`* # [ ] . ~ ! $ { } < > | ? & - / , "`，它们对shell具有特殊含义，并且与普通字符不同。但是，如果您想要使用包含其中一个特殊字符的文件名或目录作为参数，该怎么办？另外，如何处理名称中带有空格的文件名，这也可以被视为特殊字符？'
- en: 'For example, if you have a file in your directory called `My private Documents.txt`,
    how can you use it as a command-line argument? If you use it with the `ls` command,
    since the space is the command-line argument delimiter, the shell is not able
    to see it as one distinct file. Rather, it thinks you provided three different
    files called `My`, `private`, and `Documents.txt`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您的目录中有一个名为`My private Documents.txt`的文件，您如何将其用作命令行参数？如果您将其与`ls`命令一起使用，由于空格是命令行参数分隔符，shell
    无法将其视为一个独立的文件。相反，它认为您提供了三个名为`My`、`private`和`Documents.txt`的不同文件：
- en: '![](img/a27557b4-d315-4bc3-a904-ec2d1f82c080.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a27557b4-d315-4bc3-a904-ec2d1f82c080.png)'
- en: 'Also, what happens if you want to use a file containing special characters
    such as the exclamation mark, for example, if you''ve got a file called `!super!file!.txt`,
    which is a valid filename in Linux? If we try to use this filename as a command-line
    argument parameter, it cannot find the file by this name because it contains special
    characters that are treated in a different way by the shell. Or what happens if
    you want to `echo` some text with more than one whitespace between the words?
    As we have learned, the space is also a special shell character that delimits
    command-line arguments:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d5efe93-75b1-4979-a3a8-c157d1b5f47f.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: In the examples just shown, we need to find a way to disable shell expansion
    and to stop the shell from processing special characters. There are two easy ways
    to disable shell expansion in arguments, and these are quoting and escaping. Putting
    special characters and space into single quotes will prevent shell expansion and
    treat all possible chars, including the special ones, as normal alphanumeric characters.
    In single quotes, nothing ever gets shell expanded; for most special characters,
    this also works in double quotes with a few exceptions to this rule.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, two examples work, but others don''t and they
    get special treatment:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0bbdb7b6-ba43-4bd5-aa7e-292f3ef3694c.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: 'Also, as shown in previous screenshot, the dollar sign stays special as well,
    and this is often used if you need to shell expand environment variables while
    quoting. As said before, single quotes will disable all special characters. You
    can do the same by using the backslash key, which, in the shell, is also called
    the **escape character **and which does almost exactly the same as quotes, but
    will only disable shell expansion and every special meaning for the next, and
    only the next, immediate character after the backslash key:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbb41cd7-c4ec-4108-adc7-56267743bd0e.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: As you can see, it's basically the same. Often, the escape character is used
    to create clear multi-line command-line calls by escaping or disabling the new
    line character in each line. Another use case for the backslash character is to
    use it when working with arguments such as files starting with the dash, as this
    often confuses the shell because it interprets any dash symbol as an option.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we want to create an empty file named `-dashy.txt`, this will
    not work, as the command line is confused and thinks the filename is a list of
    single-character options. Here, we can use the escape character to get rid of
    the special meaning of the dash symbol. For arguments starting with the dash,
    some commands, such as `ls` or `touch`, also have another great feature, the double
    dash, which marks the end of the option list. So, to treat your dashy file as
    an argument instead of an option, we can also type the `nano -dashy.txt` or `touch
    '-dashy.txt'` command.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: As you have learned, there exists a number of special characters in the shell
    that have a special meaning, for example, the shell globbing characters or the
    exclamation mark. What if you want to use these characters, not to shell expand
    the list of files, but in a filename or other literal command argument? You need
    to disable them. Using single quotes will disable all special characters and is
    the preferred way when working in the shell; it works for almost all everyday
    quoting use cases. When using double quotes, most special characters get disabled,
    but not all, such as the shell expansion of environment variables. So, this approach
    is very useful for text creation that contains normal characters and values of
    environment variables. The backslash or escaping character will disable any special
    meaning of the following character only.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Getting help
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can start teaching you how to get help using the various forms of
    documentation available for Linux commands, we first have to learn how to read
    the default command syntax documentation. Most of the provided standard shell
    commands in Linux follow a uniform format describing their usage. Afterward, we
    will show you how to get help.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始教您如何使用Linux命令的各种文档形式获取帮助之前，我们首先必须学习如何阅读默认命令语法文档。Linux中提供的大多数标准shell命令都遵循描述其用法的统一格式。之后，我们将向您展示如何获取帮助。
- en: When working with the Linux command line, getting help and looking up information
    and documentation is very important because the command line can be very complex
    and nobody knows and can remember everything. On every Linux system, there are
    several ways available to get help, depending on the kind of level of information
    you need to know. In this section, we will tap into the different sources of documentation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Linux命令行时，获取帮助并查找信息和文档非常重要，因为命令行可能非常复杂，没有人知道并且能记住一切。在每个Linux系统上，有几种可用的方式可以获取帮助，具体取决于您需要了解的信息级别。在本节中，我们将利用不同的文档来源。
- en: In a previous section, you already learned the general structure of Bash shell
    commands and everything you need to know about command options and parameters
    in general, but oftentimes this is not enough. For a lot of shell commands, the
    specific structure of options and arguments are very complex. A post can be bound
    to a specific position, and some of them can be mandatory or optional. Also, options
    and arguments can be interdependent. In Linux, a description of a command's command-line
    format, including arguments and options, is called **command usage** or **syntax
    of a command**. Learning to read a command's usage is one of the most essential
    skills that a Linux beginner needs to learn when starting. The standard way to
    describe command usage in Linux is the command name, square brackets that contain
    text, dots, and text, for example, `CommandName [XXX]... TEXT`. Square brackets
    mean that the content within is optional. Three dots mean that the expression
    right before the dots can be repeated multiple times or only once. Any word without
    square brackets is mandatory.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，您已经学习了Bash shell命令的一般结构以及您需要了解的关于命令选项和参数的一切，但通常这是不够的。对于许多shell命令，选项和参数的特定结构非常复杂。一个命令可以绑定到特定位置，其中一些可能是强制性的或可选的。此外，选项和参数可以相互依赖。在Linux中，命令的命令行格式描述，包括参数和选项，称为**命令用法**或**命令的语法**。学习阅读命令用法是Linux初学者在开始时需要学习的最基本的技能之一。在Linux中描述命令用法的标准方式是命令名称，包含文本的方括号，点和文本，例如，`CommandName
    [XXX]... TEXT`。方括号表示其中的内容是可选的。三个点表示点之前的表达式可以重复多次或仅一次。没有方括号的任何单词都是强制性的。
- en: 'Take, for example, the general syntax for the `ls` command, which you already
    know how to work with. From the official `ls` manual, it can be read as `ls [OPTION]...
    [FILE]...`; this means that the command to list files has the following usage.
    It starts with the `ls` command name, everything else is in brackets, so all the
    options and arguments are optional, which means you can also execute `ls` without
    providing any further information, just by pressing the *Enter* key. But you can
    also provide multiple options or only one. Also, we can see that the arguments
    are of the `FILE` type, which means a file or directory is needed here at this
    position. You can also provide multiple files or directories, or only one or zero,
    as shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`ls`命令的一般语法，您已经知道如何使用。从官方`ls`手册中，可以读取为`ls [OPTION]... [FILE]...`；这意味着列出文件的命令具有以下用法。它以`ls`命令名称开头，其他所有内容都在括号中，因此所有选项和参数都是可选的，这意味着您也可以只通过按*Enter*键来执行`ls`而不提供任何其他信息。但您也可以提供多个选项或仅一个。此外，我们可以看到参数是`FILE`类型，这意味着在这个位置需要一个文件或目录。您还可以提供多个文件或目录，或者只有一个或零个，如下面的屏幕截图所示：
- en: '![](img/254bdc69-e724-4e5b-a1ce-877a01332fd6.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/254bdc69-e724-4e5b-a1ce-877a01332fd6.png)'
- en: 'As another example, the `copy` command can be run by using the `cp` command
    name followed by zero or multiple options. The syntax of the `cp` command is `cp
    [OPTION]... SOURCE... DEST_DIR`. You can completely skip option, but at least
    one or more source directory and exactly one destination directory are mandatory
    and denoted by the three dots, and you cannot run the command without them. For
    example, running just `cp` without at least two arguments produces the following
    error. Correct usage would be with all options:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是`copy`命令可以通过使用`cp`命令名称后跟零个或多个选项来运行。`cp`命令的语法是`cp [OPTION]... SOURCE...
    DEST_DIR`。您可以完全跳过选项，但至少一个或多个源目录和一个目标目录是强制性的，并由三个点表示，没有它们您无法运行该命令。例如，仅运行`cp`而不提供至少两个参数会产生以下错误。正确的用法应该包括所有选项：
- en: '![](img/1054ecf2-c917-41b4-841b-6e4bfcdb8b17.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1054ecf2-c917-41b4-841b-6e4bfcdb8b17.png)'
- en: Now that we know how to read any standard command syntax or usage, how can we
    actually get help? As we said before, there are several ways available, which
    are command help options, man pages, and full program documentation. Normally,
    all of these three types of help are installed together with the command line
    or program, so it's a very good habit to first try to get help for shell commands
    locally on the same machine where the commands live. This is usually the most
    accurate, reliable, and up-to-date information for every command and should be
    favored before doing internet research or using documentation from another computer
    with a different Linux version or system.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何阅读任何标准命令语法或用法，那么我们如何实际获取帮助呢？正如我们之前所说，有几种可用的方式，即命令帮助选项、man页面和完整的程序文档。通常，所有这三种类型的帮助都与命令行或程序一起安装，因此首先尝试在相同的机器上本地获取shell命令的帮助是一个非常好的习惯。这通常是每个命令的最准确、可靠和最新的信息，并且应该优先于在互联网上进行研究或使用来自具有不同Linux版本或系统的其他计算机的文档。
- en: Often internet solutions found in blogs or forums are too unspecific or plain
    wrong for your specific Linux installation, and should always be used with caution.
    Don't ever blindly copy and paste command snippets from the internet.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在博客或论坛中找到的互联网解决方案对于您特定的Linux安装来说太不具体或纯属错误，应始终谨慎使用。永远不要盲目地从互联网上复制和粘贴命令片段。
- en: Command parameters, options, and features can change over time depending on
    the version and implementation, and they can be very dangerous if applied incorrectly.
    There are hundreds of commands available on Linux and every one of them has a
    different syntax. No one can memorize everything, so first let's start with the
    easiest and fastest way to get quick help for any standard Linux program that
    you already know the name of. In fact, most programs do have a special command-line
    switch that prints out a quick summary of the usage of its options and arguments
    on screen, which in most cases is all you need to know. However, the help or usage
    flag is not standardized on Linux and some commands don't even have this flag
    at all, but most tool developers follow the rule to use the one-character flag
    `-h`, or the long option flag `--help`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 命令参数、选项和功能可能会随着版本和实现的变化而发生变化，如果错误应用，可能会非常危险。Linux上有数百个可用的命令，每个命令都有不同的语法。没有人可以记住所有内容，所以让我们首先从获取任何标准Linux程序的快速帮助的最简单和最快的方法开始。实际上，大多数程序都有一个特殊的命令行开关，可以在屏幕上打印出其选项和参数的快速摘要，这在大多数情况下就是您需要了解的全部内容。但是，在Linux上，帮助或使用标志并不是标准化的，有些命令甚至根本没有这个标志，但大多数工具开发人员遵循使用单字符标志`-h`或长选项标志`--help`的规则。
- en: Not all shell commands have a help option, especially those very easy ones.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有shell命令都有帮助选项，特别是那些非常简单的命令。
- en: Now, if you need more help, you can check out the commands manual, which is
    often called **man pages** by Linux users. Most programs have such documentation.
    For the next few examples, you need to install some additional software using
    your root account's password, which you set up during installation. Man pages
    use lesser navigation, which we will talk about later when we learn how to view
    text files.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您需要更多帮助，您可以查看命令手册，Linux用户通常称之为**man页面**。大多数程序都有这样的文档。对于接下来的几个示例，您需要使用您在安装过程中设置的root帐户密码安装一些额外的软件。man页面使用较少的导航，我们将在学习如何查看文本文件时稍后讨论。
- en: 'The following steps will help you to navigate the manual of any command in
    the Linux Terminal:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您在Linux终端中导航到任何命令的手册：
- en: Open the Terminal and type `man cp` for the `copy` command.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，输入`man cp`以查看`copy`命令的手册。
- en: Use the *Page Up* and *Page Down* keys to scroll the document up and down, and
    slash (*/)* can be used to search text; put any keywords after the slash to search
    for, and then press *Enter*. For example, `/backup`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Page Up*和*Page Down*键向上和向下滚动文档，斜杠（*/*）可用于搜索文本；在斜杠后面放置任何关键字进行搜索，然后按*Enter*。例如，`/backup`。
- en: Press the *End* key to search for the next entry in the man page.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*End*键搜索man页面中的下一个条目。
- en: To quit the search option, use the *Esc* key.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要退出搜索选项，请使用*Esc*键。
- en: Using lowercase *g*, you can scroll to the top of the page, whereas uppercase
    *G* scrolls to the bottom of the page.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用小写字母*g*，您可以滚动到页面顶部，而大写字母*G*则可以滚动到页面底部。
- en: You can press lowercase *q* to quit the man page.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以按小写字母*q*退出man页面。
- en: 'When you go back to the top of the page, the man page of the `cp` command is
    divided into different topics and headings, as shown in the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当您返回页面顶部时，`cp`命令的man页面被分成不同的主题和标题，如下面的截图所示：
- en: '![](img/a16d1618-56c7-43fa-ad49-b81e6ee9cf5f.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a16d1618-56c7-43fa-ad49-b81e6ee9cf5f.png)'
- en: 'Most standard Linux commands follow this type of structure. Also, you can see
    here that some commands can have different usage formats depending on the options
    and arguments given. Now, quit using the *q* key. The `man` command has a very
    useful option, type `man -k` and put any definition of interests as an argument
    afterward. This will search all man pages installed on your system for a certain
    keyword. For example, this is very useful if you forgot a specific command name
    or need general help with the topic or command to use or where to look first.
    If you type the `man -k copy` command, this will print out all the man pages for
    the commands that have something to do with copying:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数标准的Linux命令都遵循这种结构。此外，您可以在这里看到，一些命令可以根据给定的选项和参数具有不同的使用格式。现在，使用*q*键退出。`man`命令有一个非常有用的选项，输入`man
    -k`，然后在参数后面放置任何感兴趣的定义。这将搜索系统上安装的所有man页面，以查找特定关键字。例如，如果您忘记了特定的命令名称，或者需要关于主题或要使用的命令的一般帮助，或者首先查找的位置，这将非常有用。如果您键入`man
    -k copy`命令，这将打印出所有与复制有关的命令的man页面：
- en: '![](img/ad0c03ec-3196-4227-9505-5a66403941ef.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad0c03ec-3196-4227-9505-5a66403941ef.png)'
- en: 'While using the `-k` flag, you also see that the search result writes some
    numbers in the brackets after the man name; these are man page sections, which
    is another very useful concept we need to know. A Linux shell definition, such
    as `printf`, can describe more than only a command-line program, and man pages
    not only describe command-line tools. In our example, `printf` is not only a command-line
    tool that can be started by the shell user, but also the name for a library function
    in the programming language C, which is used by this system. `man` now defines
    a system of section numbers for the type a specific man name is from. Typing `man
    man` will display the manual documentation for the `man` command, and search for
    the keyboard sections, as shown here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`-k`标志时，您还会看到搜索结果在man名称后面写了一些数字；这些是man页面部分，这是另一个非常有用的概念，我们需要了解。Linux shell定义，例如`printf`，可以描述的不仅仅是命令行程序，man页面不仅仅描述命令行工具。在我们的例子中，`printf`不仅是一个可以由shell用户启动的命令行工具，还是C编程语言中使用的库函数的名称。`man`现在为特定man名称的类型定义了一套部分编号系统。键入`man
    man`将显示`man`命令的手册文档，并搜索键盘部分，如下所示：
- en: '![](img/e1609794-341f-41c7-b07b-b02aa13663cb.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1609794-341f-41c7-b07b-b02aa13663cb.png)'
- en: As we can see in the previous screenshot, the man page of the man command has
    nine sections. The first one is the most important one for us in this section,
    as we are most likely the shell command users. But, as you can see, the third
    section is a library call. Type `man printf`, which prints the usage of the `printf`
    command. On the other hand, if you type `man 3 printf`, it will print the Linux
    programmers' manual for the C language.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的截图中看到的，man命令的man页面有九个部分。第一个对我们来说是最重要的，因为我们很可能是shell命令的用户。但是，正如你所看到的，第三部分是一个库调用。输入`man
    printf`，它会打印`printf`命令的用法。另一方面，如果你输入`man 3 printf`，它将打印C语言的Linux程序员手册。
- en: Let's jump to the eighth section, which is the manual for the `xfs_copy` command
    written for the system administrators. Besides manual pages, a lot of commands
    that can be installed on Linux or that come right out of the box with the system,
    do have additional and advanced documentation available in a specific folder location
    in the filesystem on your hard disk. For some programs, additional documentation
    can also be installed using a special installation package, as we will learn later
    in this section. Sometimes, this additional documentation contains precious usage
    examples on how to use the program; information about the internal algorithms
    or approaches used; change log and license information; author contact information;
    history; a list of errors or limitations; or sample configuration files, which
    we will talk about later.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳到第八部分，这是为系统管理员编写的`xfs_copy`命令的手册。除了手册页面外，许多可以在Linux上安装或者与系统一起提供的命令，在文件系统中的特定文件夹位置都有额外和高级的文档。对于一些程序，还可以使用特殊的安装包安装额外的文档，我们将在本节后面学习。有时，这些额外的文档包含了如何使用程序的宝贵用法示例；关于内部算法或方法的信息；更改日志和许可信息；作者联系信息；历史记录；错误或限制列表；或者样本配置文件，我们稍后会谈到。
- en: 'If you get stuck with the manual or it is just not enough for you, try to check
    out if a documentation folder exists for your command of interest in your CentOS
    7 standard documentation path. Type, for example, the `postfix` documentation
    folder lives in. This is a good example. If you go into the directory, you will
    find a lot of additional documentation in text file format. Refer to the following
    screenshot for more information:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在手册中遇到困难，或者手册对你来说不够，尝试查看你的CentOS 7标准文档路径中是否存在你感兴趣的命令的文档文件夹。例如，输入`postfix`文档文件夹所在的位置。这是一个很好的例子。如果你进入该目录，你会发现很多文本文件格式的额外文档。更多信息请参考以下截图：
- en: '![](img/353c36f2-8d79-4fe1-a1d8-8766fee5dd81.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/353c36f2-8d79-4fe1-a1d8-8766fee5dd81.png)'
- en: Use the less program to read the files. Use the same keyboard shortcuts to navigate
    the files as with the man pages, for example, type *q* to exit.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用less程序来阅读文件。使用与man页面相同的键盘快捷键来浏览文件，例如，输入*q*退出。
- en: If you need more or advanced documentation, look into the `/usr/share/doc` folder
    and see if there's something available for you.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多或高级文档，请查看`/usr/share/doc`文件夹，看看是否有适合你的内容。
- en: Working with the Linux shell
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Linux shell
- en: In this section, we will learn how to work in the shell efficiently. We will
    introduce some important practices and techniques that will improve your productivity
    and make you a faster shell command hacker. This can make you a happier person
    because, eventually, you will be able to advance to feeling very comfortable working
    in the shell. Please note, in this section, we will show you a lot of keyboard
    shortcuts. Learning keyboard shortcuts is like learning any other craft, you begin
    slowly and gradually, because learning too many new skills at once can leave you
    overwhelmed and make you forget more quickly than learning in smaller chunks.
    My tip is to start by learning the first three to four command editing shortcuts
    and then incorporate more from day to day or week to week. We will start with
    the command editing shortcuts. Now, if you don't know any command editing shortcuts
    at all, let's recap what you probably know so far on how to type and edit text
    in the command line.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在shell中高效工作。我们将介绍一些重要的实践和技术，这将提高你的生产力，使你成为一个更快的shell命令黑客。这可以让你成为一个更快乐的人，因为最终，你将能够感到非常舒适地在shell中工作。请注意，在本节中，我们将向你展示很多键盘快捷键。学习键盘快捷键就像学习任何其他技能一样，你要慢慢开始，因为一次学习太多新技能会让你感到不知所措，比学习小块的知识更容易忘记。我的建议是从学习前三到四个命令编辑快捷键开始，然后逐日或逐周增加更多。我们将从命令编辑快捷键开始。现在，如果你根本不知道任何命令编辑快捷键，让我们回顾一下你可能已经知道的如何在命令行中输入和编辑文本。
- en: The first shortcut for moving the position of the cursor is that you can use
    the left and the right arrow keys, which are helpful to edit the text you wrote
    to insert or delete characters at a specific position. But if this were all that
    one could do in the shell, working in the shell would be very inefficient, because
    single-character cursor movement is very slow. Also, every time a command gets
    executed with a typo or the command needs to be rerun with a small difference,
    such as changing one option, the complete command needs to be retyped from beginning
    to end.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 移动光标位置的第一个快捷键是使用左右箭头键，这有助于编辑你输入的文本，在特定位置插入或删除字符。但如果这是在shell中所能做的一切，那么在shell中工作将会非常低效，因为单个字符的光标移动非常缓慢。此外，每当使用有错别字的命令或者需要以稍有不同的方式重新运行命令时，例如更改一个选项，就需要从头到尾重新输入完整的命令。
- en: 'To be a lot more efficient, let''s introduce some very important command editing
    shortcuts for your everyday work with Linux:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更高效，让我们介绍一些非常重要的命令编辑快捷键，用于你在Linux中的日常工作：
- en: To move the cursor to the end of the line, use *Ctrl* + *E*.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将光标移动到行尾，使用*Ctrl* + *E*。
- en: To go back to the beginning, press *Ctrl* + *A*, *Ctrl* + *E*, *Ctrl* + *A* respectively.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要返回到开头，分别按下*Ctrl* + *A*，*Ctrl* + *E*，*Ctrl* + *A*。
- en: To move the cursor to the next word, which is defined by a space or special
    characters such as dot, semicolon, or point, use *Ctrl* and the right arrow key
    to move forward.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To move backward one word, use the left arrow key while holding the *Ctrl* key.
    You can also use *meta* + *F* and *meta* + *B* to do the same.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On most systems, like any normal PC keyboard, there is no meta key, so the meta
    key is mapped to the *Esc* or *Alt* key.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the *Alt* key in some terminal emulators such as the Xfce4 Terminal is
    reserved for menu accessibility. So, you first have to disable the *Alt* key as
    a menu shortcut in the preferences before you can use it as a shortcut.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: To toggle between the current position and the beginning of the line, press *Ctrl*
    + *XX* twice.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Press *Ctrl* + *K* to delete the text from the cursor to the end of the command
    line.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To delete the text from the cursor to the start of the command line, press *Ctrl*
    + *U*. Use *Alt* + *D* to delete to the end of the word.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the command editing keyboard shortcuts we just discussed here are only
    the most important and efficient ones for your everyday daily use, and there are
    many, many more.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get a full list of all of the Bash keyboard shortcuts, do the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Type `man bash` and then search for the section commands for moving
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this man page, search for `Killing`
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this man page, the *C* key is the *Ctrl* key, the *M* key is the meta key,
    and the dash means to combine or press and hold two keys, as we have shown you
    using the *Ctrl* + *A* shortcut earlier
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `C-k` stands for **kill-line**, which kills the text from the point
    to the end of the line. *Alt* + *T* is used to swap words, `M-u` to make words
    uppercase, and `M-l` to make words lowercase.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the command completion shortcuts. The most important command
    completion shortcut is the *Tab* key on your keyboard. It tries to guess and autocomplete
    the command you are about to type. It is very useful and speeds up typing commands
    tremendously, but don't overdo it when using this key, it can only print the full
    unique command name if there are no alternatives available. Type `pass` and press
    the *Tab* key; it will autocomplete the name `passwd` as there are no other programs
    with this full name available. Type `pa` and press the *Tab* key; this will give
    you several results as no unique name can be found. Type `yp` and press the *Tab*
    key; this will autocomplete to a long name as this is the only `variant` available.
    The *Tab* short key autocompletes commands by default; to autocomplete other things,
    such as filenames, use the *Alt* + */* key. More can be found in the corresponding
    section in the Bash man page.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at to the command recall shortcuts. The Linux shell has a
    very nice feature available, which is the `history` command. This is a system
    for storing and retrieving all the commands typed into the shell. By default,
    on a CentOS 7 system, the last thousand commands are stored. This number can also
    be changed. The command-line history is a very useful feature to save time, by
    not doing repetitive typing, or to see how a specific command has been executed
    some time ago. To print out the current history, type `history` and press *Enter*.
    If you want to re-execute a command from this list use the exclamation mark and
    the corresponding number. Two exclamation marks run the last command from the
    history. Another exclamation mark notation can be used to extract specific arguments
    from history commands. This will extract the third argument from the `history`
    command, `166`, as shown in the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a19d06c-e425-49dd-8361-beb6320793cd.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: 'Another very useful history feature is to recall the last command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: To go through the previous history commands you executed, press the Up arrow
    key on your keyboard.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To go back to the next history commands, use the Down arrow key.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To search through the history for a command, press *Ctrl* + *R* and then enter
    the search keyword.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在历史记录中搜索命令，请按 *Ctrl* + *R*，然后输入搜索关键字。
- en: To cycle through the results, press *Ctrl* + *R* again.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要循环浏览结果，请再次按下 *Ctrl* + *R*。
- en: To run a specific command that you have found, press the *Enter* key.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要运行找到的特定命令，请按 *Enter* 键。
- en: To quickly insert the last argument of the previous command, use *Alt* + dot.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要快速插入上一个命令的最后一个参数，请使用 *Alt* + 点。
- en: Another very useful feature is to shell expand a line manually without actually
    having to execute the line, which can be useful to find out errors and boxes.
    This can be done using *Ctrl* + *Alt* + *E*.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个非常有用的功能是手动扩展一行而不实际执行该行，这对于查找错误和框很有用。这可以使用 *Ctrl* + *Alt* + *E* 来完成。
- en: Next, we need to know how to work with programs and processes. First, we will
    discuss how to abort any running program. This is important if you need to quit
    a command because it is unresponsive or you've made a mistake and want to stop
    it. For example, let's type the `cat` command, which will just run forever. Let's
    ignore what this command is doing at the moment. This leaves the shell unresponsive
    because `cat` never finishes running in the forefront of our shell and runs forever.
    To get back to the shell prompt so we can type in new commands and work again,
    we need to exit the command while it is running. To do so in the shell, we can
    use a special key combination that exits the current foreground process. Press
    *Ctrl* + *C*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要知道如何使用程序和进程。首先，我们将讨论如何中止任何正在运行的程序。如果需要退出命令，因为它没有响应或者您犯了一个错误并希望停止它，这一点非常重要。例如，让我们输入
    `cat` 命令，它将永远运行。让我们暂时忽略此命令目前正在做什么。这会使shell无响应，因为 `cat` 永远不会在我们的shell前台完成运行并永远运行。为了回到shell提示符，以便我们可以再次输入新命令并继续工作，我们需要在其运行时退出命令。在shell中，我们可以使用一个特殊的组合键来退出当前前台进程。按下
    *Ctrl* + *C*。
- en: This is a very important key shortcut and it should be memorized: *Ctrl* + *C*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常重要的快捷键，应该记住：*Ctrl* + *C*。
- en: 'You can also suspend a program, which is like pausing its processing and putting
    it into the background so you can work in the shell again. This can be done as
    follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以暂停一个程序，就像暂停其处理并将其放入后台，这样您就可以再次在shell中工作。可以按照以下步骤完成：
- en: Press *Ctrl* + *Z*. If you later want to continue the program running in the
    foreground, type `fg` and press *Enter*.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *Ctrl* + *Z*。如果以后想要继续在前台运行程序，输入 `fg` 然后按 *Enter*。
- en: You can also put it in the background using the `bg` command while it is suspended.
    Now the program runs in the background and you can work in the foreground.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以在暂停时使用 `bg` 命令将其放入后台。现在程序在后台运行，您可以在前台工作。
- en: The easiest way to exit this program running in the background is to put it
    into the foreground and then use *Ctrl* + *C* to abort it.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出后台运行的程序的最简单方法是将其放到前台，然后使用 *Ctrl* + *C* 中止它。
- en: The next very useful command is to press *Ctrl* + *L*, which clears the screen
    and has the same effect as the `clear` command.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个非常有用的命令是按下 *Ctrl* + *L*，这将清除屏幕，与 `clear` 命令具有相同的效果。
- en: The very last useful command we will learn here is to press *Ctrl* + *D*, which
    closes the Bash shell. This is similar to typing the `exit` command.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在这里学习的最后一个非常有用的命令是按下 *Ctrl* + *D*，这将关闭Bash shell。这类似于输入 `exit` 命令。
- en: Understanding standard streams
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解标准流
- en: In this section, you will learn why every command can use three standard streams
    for accessing its input and output. Also, you will learn how to work with those
    input and output streams and how to use redirection. Finally, we will learn how
    to use pipes and why they are so important. One philosophy of the Linux operating
    system is that every command has exactly one functionality in the system, nothing
    more, and nothing less. For example, there's one command to list files, another
    to sort text, and one to print the file's content, and so on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解为什么每个命令都可以使用三个标准流来访问其输入和输出。此外，您还将学习如何使用这些输入和输出流以及如何使用重定向。最后，我们将学习如何使用管道以及它们为何如此重要。Linux操作系统的一个理念是，每个命令在系统中都有确切的功能，没有多余的，也没有不足的。例如，有一个命令用于列出文件，另一个用于对文本进行排序，还有一个用于打印文件的内容，等等。
- en: Now, one of the most important features of the shell is to connect different
    commands to create custom tailored solutions and tools for all kinds of problems
    and workflows. But before we can show you how to concatenate different commands
    together to build something powerful, we first need to know how a command uses
    its input and output and what input and output redirection is. Most Linux commands
    follow a similar pattern when processing data. Most of the commands we are using
    do get some kind of input, for example, they read the content of a file and then
    they process this information, and afterward almost all of them do output some
    kind of results on the computer screen. Because every command uses some kind of
    input and returns some kind of output on Linux, three standard channels are defined
    and are available for every command. They are used for communication between the
    operating system and the command during execution. They are called **standard
    input** or `stdin`, **standard output** or `stdout`, and **standard error** or
    `stderr`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，shell的最重要功能之一是连接不同的命令，以创建定制的解决方案和工具来解决各种问题和工作流程。但在我们展示如何将不同的命令连接在一起构建强大的东西之前，我们首先需要知道命令如何使用其输入和输出，以及输入和输出重定向是什么。大多数Linux命令在处理数据时遵循类似的模式。我们使用的大多数命令都会获得某种输入，例如，它们读取文件的内容，然后处理这些信息，之后几乎所有命令都会在计算机屏幕上输出某种结果。因为每个命令在Linux上都会使用某种输入并返回某种输出，所以为每个命令定义了三个标准通道，并且这些通道对于每个命令都是可用的。它们用于在执行期间操作系统和命令之间的通信。它们被称为**标准输入**或
    `stdin`，**标准输出**或 `stdout`，以及**标准错误**或 `stderr`。
- en: Normal program output goes to the `stdout` channel, while `stderr` is also an
    output stream and it can be used for showing and processing any kind of error
    messages occurring while a command is executing. These are also called **standard
    streams**. They are called streams because the data is flowing continuously through
    a specific channel and gets processed or generated consecutively by the command,
    although they have an open end, which means the command working with them cannot
    predict when this flow of data will stop or finish. Now, we can change the `stdin`
    and `stdout` locations using certain files; this is called **redirection**.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正常程序输出进入`stdout`通道，而`stderr`也是一个输出流，可以用于显示和处理在执行命令时发生的任何错误消息。这些也被称为**标准流**。它们被称为流，是因为数据通过特定通道持续流动，并由命令连续处理或生成，尽管它们有一个开放的末端，这意味着使用它们的命令无法预测数据流何时会停止或结束。现在，我们可以使用特定文件更改`stdin`和`stdout`的位置；这称为**重定向**。
- en: Here, in this section, we will also explain the concept of pipes, which is one
    of the most fundamental concepts and major features of the Linux shell, and how
    to work with them. For example, if you type `ls /var/lib/system/`, the result
    random-seed will be printed to the screen because it is defined as an `stdout`
    device by default for every Linux command. But if you type `cat /var/log/messages`,
    an error message is printed to the same screen as both `stdout` and `stderr` are
    connected to the same output device, the screen.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们还将解释管道的概念，这是Linux shell最基本的概念和主要特性之一，以及如何使用它们。例如，如果您键入`ls /var/lib/system/`，结果random-seed将被打印到屏幕上，因为它默认为每个Linux命令的`stdout`设备。但是，如果您键入`cat
    /var/log/messages`，错误消息将打印到同一屏幕上，因为`stdout`和`stderr`都连接到同一输出设备，即屏幕。
- en: On Linux, your physical input and output devices, such as your keyboard or screen,
    like any other hardware devices, are abstracted and represented by special system
    files. All of these special files reside in a system directory called `/dev`,
    which is also called the **system devices directory**. But what can we do with
    a system like that? Its beauty is that we can redirect the input and output of
    a command to another location other than the default keyboard and screen source
    or destinations, which also must be of the filetype. This is also very useful
    to separate `stdout` and `stderr` to two different locations, which especially
    helps to keep the overview of a command running if it produces a lot of output.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，您的物理输入和输出设备，如键盘或屏幕，与其他硬件设备一样，都是通过特殊的系统文件进行抽象和表示的。所有这些特殊文件都驻留在一个名为`/dev`的系统目录中，也称为**系统设备目录**。但是我们可以用这样的系统做什么呢？它的美妙之处在于我们可以将命令的输入和输出重定向到除默认键盘和屏幕源或目的地之外的其他位置，这些位置也必须是文件类型。这对将`stdout`和`stderr`分开到两个不同的位置也非常有用，特别是在命令产生大量输出时有助于保持概览。
- en: For output channel redirection, we use the greater than sign (*>*), for input
    redirection we use the smaller than sign (*<*). To address a specific channel,
    such as `stdin`, `stdout`, and `stderr`, we use the corresponding numbers `0`,
    `1`, and `2`. When using output redirection, the `stdout` channel is expected,
    so we don't have to write it explicitly. For 99% of all cases you only redirect
    `stdout` and `stderr`, so let's focus on those examples.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输出通道重定向，我们使用大于号（*>*），对于输入重定向，我们使用小于号（*<*）。要处理特定通道，如`stdin`、`stdout`和`stderr`，我们使用相应的数字`0`、`1`和`2`。在使用输出重定向时，期望`stdout`通道，因此我们不必明确写出它。在99%的情况下，您只需要重定向`stdout`和`stderr`，因此让我们专注于这些示例。
- en: 'To redirect the `stdout` stream output of a command to a file, use the greater
    than sign. As said before, the `stdout` channel is expected, so the last command
    can also be typed as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要将命令的`stdout`流输出重定向到文件，请使用大于号。如前所述，期望`stdout`通道，因此最后一个命令也可以输入如下：
- en: '[PRE1]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use the `card` command to print out the content of the file that we just created
    with the redirection to `stdout`. To redirect the `stderr` channel, use number
    `2` as the standard stream descriptor. The following screenshot shows the output
    of the previous commands:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`card`命令打印出刚刚通过重定向到`stdout`创建的文件的内容。要重定向`stderr`通道，请使用数字`2`作为标准流描述符。以下截图显示了先前命令的输出：
- en: '![](img/7b04e011-9e42-422d-9fa8-43cc7e64a47e.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b04e011-9e42-422d-9fa8-43cc7e64a47e.png)'
- en: 'As you can see, the error message has been redirected to a file. To redirect
    `stdout` and `stderr` to two different files, type the commands shown in the following
    screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，错误消息已被重定向到一个文件中。要将`stdout`和`stderr`重定向到两个不同的文件中，请输入以下截图中显示的命令：
- en: '![](img/7a3bd9a4-0228-48af-9ca0-c832a49f06f2.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a3bd9a4-0228-48af-9ca0-c832a49f06f2.png)'
- en: 'Another notation, using the *ampersand* char allows the redirecting of one
    channel another one. To redirect `stderr` to the `stdout` channel, type the commands
    shown in the following screenshot:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种表示法，使用*和符号*允许将一个通道重定向到另一个通道。要将`stderr`重定向到`stdout`通道，请输入以下截图中显示的命令：
- en: '![](img/5754adbc-5759-4200-8c37-19fcac394707.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5754adbc-5759-4200-8c37-19fcac394707.png)'
- en: 'Sometimes, you are only interested in one output stream, therefore a special
    device file exists in any Linux system, which is called the `null` device, and
    it consumes and vanishes any kind of streaming data that gets redirected to it
    into the void. If you don''t want any output at all for any command, for example,
    you can use the command shown in the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您只对一个输出流感兴趣，因此在任何Linux系统中都存在一个特殊的设备文件，称为`null`设备，它会消耗并消失任何被重定向到它的流数据。如果您不希望对任何命令输出任何输出，例如，您可以使用以下截图中显示的命令：
- en: '![](img/11f2e005-80c4-41aa-a86b-3a34ca25356a.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11f2e005-80c4-41aa-a86b-3a34ca25356a.png)'
- en: Finally, to redirect `stdin`, you use the smaller than sign [`<`]. For example,
    this can be very useful because some of the available shell commands can directly
    read a file's content as `stdin`, such as the `grep` command, which we will learn
    about later.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's discuss pipes. Besides redirecting a command's default input and
    output streams, `stdin`, `stdout`, and `stderr`, to files, we can also use the
    concept of shell pipes to get one command output as the input for another command.
    There are no limits to this system and it's very easy to build multi-command chains
    to answer very complex questions for you. As mentioned previously, this shell
    feature lets you create very powerful command pipelines and workflows for creating
    custom tailored solutions for all kinds of Linux command-line work, and to answer
    very complex questions for you.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'To chain commands together, which means to use `stdout` from the first command
    as `stdin` to the next command, we use the vertical bar symbol [`|`] on our keyboard,
    which in Linux is called the **pipe** symbol. For example, if you''ve got a very
    long directory content list that you want to read without scrolling through the
    Terminal window forever, you can use the pipe to output the directory content
    from the `ls` command, not on the screen, but directly as input for the file viewer,
    as we learned before. Often, pipes are used to avoid intermediate result files
    and are more efficient without them. The use cases for this are endless, for example,
    if we got a file with unsorted names of people in it, we could sort them using
    `cat names.txt | sort`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06f54597-854a-4347-bc93-2c6b62fa8f2b.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: 'You can also get a list of all the unique names in this file. We will use the
    unique command to do so, which only works on a sorted list. So, we need to sort
    using `cat names.text | sort | uniq`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/729cab59-0336-4c7a-a106-a3cd9c908b25.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: 'You can also count the number of unique lines using the word count command-line
    tool using `cat names.text | sort | uniq | wc`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef883ce1-f0bb-4d18-ba83-41772fec0efe.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: 'There are quite a few unique names in this file. The sky''s the limit when
    it comes to pipe examples, and there are just too many examples. Ideally, this
    should be run with the `root` user account. Please ignore the errors. The following
    screenshot shows the core summary of the filesystem:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72686415-4aae-4ceb-ac5d-9819e377693e.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: 'Also, another useful pipe command is to print out the used files in a directory.
    If you are using a Windows system, you may know of a utility called ZIP, which
    compresses files. On Linux, you can do something very similar, but here we need
    two tools to work together. For compression, we use the `gzip` tool. Because `gzip`
    can only work on single files, we first need to create an archive that will concatenate
    multiple files to a single file. For archiving, we use the `tar` command. So,
    to create a compressed archive of your home directory in the `/tmp` directory,
    first create an archive of your home directory using the `tar` command: `tar -cv
    /home/olip/ | gzip`. The archive will be output to the `stdout` stream, so we
    pipe it into the `gzip` command as `stdin`. As gzip itself outputs the compressed
    file to `stdout`, we will redirect it to a file. The result of the compression
    versus the uncompressed data amount is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fd858d0-e6f0-4260-bf40-0183ec1aa613.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: 'A lot more piping examples will be shown throughout this book. If you redirect
    `stdout` or `stderr` into a file, normally the file will be erased if it already
    exists, or a new file will be created before any content is written to it. So
    as not to delete a file, but append the content instead, use the greater than
    sign. For example, to create a new output file, execute the command shown in the
    following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47b8f3be-2e24-459d-a657-e025a89885db.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: Now, to append the string, `Hello World`, to the output file, we will use the
    greater than sign. This will not delete the file's content when we start to redirect
    content to it. Instead, it will append the content to the end of the file. As
    said before, pipes are one of the most important concepts of the shell and it
    is so much fun working with them.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要将字符串`Hello World`附加到输出文件，我们将使用大于号。这不会在我们开始将内容重定向到文件时删除文件的内容。相反，它将在文件末尾附加内容。如前所述，管道是shell中最重要的概念之一，与它们一起工作非常有趣。
- en: Understanding regular expressions
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解正则表达式
- en: In this section, we will introduce the wonderful art of regular expressions.
    You will learn what they are and why they are so powerful. There are a lot of
    different regular expression characters available, and here we will introduce
    the most important ones. Afterward, you will learn how to apply regular expressions
    with the `grep` command to find, extract, and filter useful information out of
    text files. **Regular expressions**, or **regexps** for short, are a very powerful
    concept used to search through text using special patterns, describing the structure
    of the search term instead of a constant string of characters, which is also called
    **literal text search** in this context. Using regular expressions can save you
    a lot of time, by not doing repetitive work, and Linux system administrators use
    them quite heavily in their everyday work.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍正则表达式的奇妙艺术。您将了解它们是什么，以及它们为何如此强大。有许多不同的正则表达式字符可用，在这里我们将介绍最重要的字符。之后，您将学习如何使用`grep`命令应用正则表达式来查找、提取和过滤文本文件中的有用信息。**正则表达式**，简称**regexps**，是一种非常强大的概念，用于使用特殊模式搜索文本，描述搜索项的结构，而不是在这种情况下称为**文字文本搜索**的常量字符字符串。使用正则表达式可以节省大量时间，不需要重复工作，Linux系统管理员在日常工作中广泛使用它们。
- en: In the *File globbing* section, we learned a very similar concept when we used
    globbing characters to find patterns to address multiple filenames with some special
    characters. Regular expressions are an even more powerful tool; they contain a
    very broad set of all kinds of special characters for matching even the most complex
    text fragments completely or partially. In the Linux shell, we use regular expressions
    not for shell expansion or to group filenames, but rather to work on the content
    of text files or strings of text lines to parse and analyze their content or extract
    text features out of it. As said before, regular expressions are a very complex
    topic and we can only give you an overview here. Please note that there are several
    styles of regular expressions available, such as Perl regular expressions. In
    our examples, we'll use the POSIX, basic, and extended regular expressions, as
    used by most of the shell tools, such as `greb`, `sed`, and `awk`. There are a
    lot of different regular expression characters available, which are also called
    **meta characters**.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在*文件globbing*部分，当我们使用globbing字符查找模式以寻址具有一些特殊字符的多个文件名时，我们学习了一个非常相似的概念。正则表达式是一个更强大的工具；它们包含了一组非常广泛的特殊字符，用于完全或部分匹配甚至最复杂的文本片段。在Linux
    shell中，我们使用正则表达式不是为了shell扩展或对文件名进行分组，而是为了处理文本文件或文本行的内容，以解析和分析其内容或从中提取文本特征。如前所述，正则表达式是一个非常复杂的主题，我们只能在这里给您一个概述。请注意，有几种风格的正则表达式可用，例如Perl正则表达式。在我们的示例中，我们将使用大多数shell工具使用的POSIX、基本和扩展正则表达式。有许多不同的正则表达式字符可用，也称为**元字符**。
- en: As some of these meta characters are extended POSIX characters, we need to start
    our regular expression processing commands in the extended mode.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一些元字符是扩展的POSIX字符，我们需要在扩展模式下启动我们的正则表达式处理命令。
- en: 'Some of the extended expressions are as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一些扩展表达式如下：
- en: '`n` is used to match the end of the line.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n`用于匹配行的末尾。'
- en: '`t` matches space at the top.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t` 匹配顶部的空格。'
- en: The caret `^` symbol matches the beginning of the line.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入符`^`符号匹配行的开头。
- en: The dollar `$` symbol matches the end of the line.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美元符号`$`匹配行的末尾。
- en: '`[x]` is very similar to globbing brackets, which you have learned about before.
    This describes classes of characters to match within the brackets at a specific
    position. You can also define ranges of characters here.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[x]`与globbing括号非常相似，您之前已经学过。这描述了在特定位置的括号内匹配的字符类。您还可以在这里定义字符范围。'
- en: '`[^x]` matches all characters that are not defined in the brackets.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[^x]`匹配在括号中未定义的所有字符。'
- en: Parentheses are used for grouping; this will save the text within the parentheses
    for further referencing afterward.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号用于分组；这将保存括号内的文本以便以后引用。
- en: '`1` for number is used for back referencing. This will get number *n* of the
    reference extracted from the parenthesis, which we showed you before.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字`1`用于反向引用。这将从括号中提取引用的数字*n*。
- en: '`a|b` means that at this position *a* or *b* are allowed.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a|b` 表示在此位置允许*a*或*b*。'
- en: '`x*` means to match zero or multiple occurrences of an *x* character at this
    position.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x*` 表示匹配在此位置的零个或多个*x*字符。'
- en: '`y+` means to match one or more multiple occurrences of an *y* character at
    this position.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y+` 表示匹配在此位置的一个或多个*y*字符的多个出现。'
- en: Dot means to match any character at a specific position.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点表示匹配特定位置的任何字符。
- en: It's also very important to know that a lot of tools working with regular expressions,
    such as `sed` and `awk`, expect that the regular expressions are surrounded by
    slashes. Also, the scripting language Perl has adopted this style. In other tools
    such as `grep`, you don't need to use the slash notation.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 还非常重要的是，许多使用正则表达式的工具，如`sed`和`awk`，期望正则表达式被斜杠包围。另外，脚本语言Perl也采用了这种风格。在`grep`等其他工具中，您不需要使用斜杠表示法。
- en: Let's first experiment with our new regular expression concept using the command
    `grep`. We start grep in the extended mode using the `egrep` command-line tool.
    Instead of running the command `egrep`, you can also run the command `grep` with
    the capital `-E` option, which has the same effect. `grep` is a command that goes
    through a text file or input stream, line by line, and tries to match the search
    pattern argument given to it to every line. If a specific line matches the pattern,
    it will print out the complete line. This is very useful for all kinds of text
    extraction, and `grep` is one of the most important command-line tools available
    on Linux. In fact, I cannot remember a day working in the shell when I did not
    use it at all. Oftentimes, `grep` is used as a filter as part of a greater pipe
    command workflow to reduce huge output text that you want to process further.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先用`grep`命令来实验一下我们的新正则表达式概念。我们使用`egrep`命令行工具启动扩展模式的grep。你也可以用大写的`-E`选项来运行`grep`命令，效果是一样的。`grep`是一个命令，它逐行遍历文本文件或输入流，并尝试将给定的搜索模式参数与每一行进行匹配。如果特定行匹配模式，它将打印出完整的行。这对于各种文本提取非常有用，`grep`是Linux上最重要的命令行工具之一。事实上，我在shell中工作的一天中，几乎没有不使用它的。很多时候，`grep`被用作管道命令工作流的一部分，以减少你想进一步处理的大量输出文本。
- en: First things first, as said before, we will use the POSIX `regex`. There exists
    a lot of different regular expression terms, too many to memorize, so every time
    you need to look up the syntax, type `man 7 regex`. In this manual, you will find
    everything you need to know about regular expressions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，正如前面所说，我们将使用POSIX `regex`。有很多不同的正则表达式术语，太多了，无法记住，所以每次需要查找语法时，输入`man 7 regex`。在这个手册中，你会找到关于正则表达式的所有你需要知道的东西。
- en: Let's start extracting various information out of files. We will start by using
    the `grep` command without a regular expression, but rather searching for simple
    text literals, `grep root /etc/passwd`. This returns all lines in the `passwd`
    file that contain the word `root`. Any line in the output gives us information
    that groups the `root` user it belongs to. As you can see, grep goes through the
    complete file and finds all lines that contain the string `root` at any position.
    A very useful `grep` option is `-i`. This can be used to ignore case sensitiveness
    for the search term. For example, execute `grep -I root /etc/services`. This will
    find all occurrences of the word `root`, while ignoring the case. This will find
    all the other case permutations of the word `root` as well. When working with
    regular expressions as arguments for commands such as `grep`, `sed`, or `awk`,
    it is recommended to quote your meta characters with *single quotes*. This is
    because some of the regular expression characters are the same characters as the
    shell globbing characters, such as the wildcard character, and this would be bad.
    Shell expansion always takes place before any argument gets fed into any command,
    so using the correct command without a disabled wild card character would search
    for a string containing all the filenames in the specific file that you want to
    search for.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始从文件中提取各种信息。我们将首先使用`grep`命令，而不是使用正则表达式，而是搜索简单的文本字面量，`grep root /etc/passwd`。这将返回`passwd`文件中包含单词`root`的所有行。输出中的任何行都会给我们提供属于`root`用户的信息。正如你所看到的，grep会遍历整个文件，并找到包含字符串`root`的所有行。一个非常有用的`grep`选项是`-i`。这可以用于忽略搜索项的大小写敏感性。例如，执行`grep
    -I root /etc/services`。这将找到单词`root`的所有出现，同时忽略大小写。这也将找到单词`root`的所有其他大小写排列。当使用正则表达式作为`grep`、`sed`或`awk`等命令的参数时，建议用*单引号*引用你的元字符。这是因为一些正则表达式字符与shell通配符字符相同，比如通配符字符，这是不好的。在任何参数被输入任何命令之前，shell扩展总是发生的，所以使用正确的命令而没有禁用通配符字符会搜索包含你想要搜索的特定文件中所有文件名的字符串。
- en: 'Instead, always put your regular expression meta characters in single quotes.
    Also, if you want to search for a literal special character in the file that is
    the same as the regular expression meta character, you need to escape the character,
    which is similar to what we learned in the *File globbing* section using the backslash
    key. The following screenshot illustrates one example for every meta character
    mentioned at the start of this section:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，总是将你的正则表达式元字符放在单引号中。另外，如果你想在文件中搜索与正则表达式元字符相同的特殊字符，你需要转义该字符，这与我们在*文件通配符*部分学到的使用反斜杠键类似。以下截图说明了本节开头提到的每个元字符的一个例子：
- en: '![](img/42eee779-0e46-4aed-92b0-61cbec2cfdf6.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42eee779-0e46-4aed-92b0-61cbec2cfdf6.png)'
- en: 'The dollar sign matches at the end of the line, so this will print out all
    the files ending with data in the services file. Similarly, we use the caret `^`
    symbol to match at the beginning of the line. The following command here matches
    all the lines starting with the word `day`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 美元符号匹配行尾，因此这将打印出在services文件中以data结尾的所有文件。类似地，我们使用插入符`^`符号来匹配行首。以下命令在这里匹配所有以单词`day`开头的行：
- en: '![](img/f06d6723-c123-4b1a-9b61-c158f5d503cb.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f06d6723-c123-4b1a-9b61-c158f5d503cb.png)'
- en: A bracket expression is a list of characters enclosed in square brackets. It
    normally matches any single-character from the list at a specific position. You
    can also define ranges in square brackets using the dash symbol similar to the
    ones we have shown in the *File globbing* section. If the list in the brackets
    begins with the caret symbol, it matches any single-character not from the rest
    of this list. Normal brackets can be used to save a reference of the match within
    it. To back reference, we use `/number` of the bracket expression so that the
    regular expression matches all the lines starting with the first letter, for example,
    `egrep 't(ac)1*s' /etc/services`. The pipe symbol stands for *or*, so the next
    expression matches all the lines containing either **domain** or **gopher**. Dot
    matches any character at a specific position. Plus means to match zero or multiple
    occurrences of the character before, so that this regular expression matches all
    the lines containing `at-`, but not at the end of the line. The star meta character
    matches one or more occurrences of the character before, so that the `egrep 'aa+'
    /etc/services` expression here matches all the lines that contain at least two
    `aa` or more. The plus character matches one or multiple occurrences of the character
    before, so that this regular expression here matches all the lines.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'As said before, the dot matches every character at a specific position, so
    that the regular expression matches all the lines containing exactly the number
    of characters corresponding to the number of dots in the expression. `grep` has
    a lot of useful options, for example, `-v` reverses the search match, which means
    print all the lines that do not contain the search pattern at all. I often use
    this option to remove all empty lines and command lines in a lot of configuration
    files that start with the hashtag in shell script files. For example, execute
    the command shown in the following screenshot:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43c20227-c279-46f3-a1f7-9f1422d30d33.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: The manual contains a lot of command lines that start with the hashtag and empty
    lines. To filter out all these un-needed lines, use the `grep -v` option. Another
    useful feature is the `grep -o` option, which only prints the matched pattern
    and not a complete line. So, for example, `egrep 'netbios-...' /etc/services`
    prints out the full line, while the `-o` option only prints the pure NetBIOS name
    from the pattern.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Working with sed
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn about the `sed` command, the powerful stream
    editor. We will give you a brief introduction on how `sed` works and we''ll be
    showing you the substitution mode for automatically replacing text and files,
    which is one of the most important modes available. Next, we will learn about
    the `sed` command. Let''s first examine its syntax:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`sed` stands for **stream editor** and this command can edit files automatically
    without any user interaction. It processes input files on a line-by-line basis.
    Oftentimes, `sed` is used in shell scripts to transform any command''s output
    to a desired form for further processing. Most everyday use cases for `sed` follow
    a similar pattern, which, in its most simple form, is first used with a regular
    expression or other pattern to define which lines to change in an input file or
    stream, and then provide a rule on how to change or transform the matched line.
    Similar to the `grep` command, always use single quotes when working with `sed`,
    unless you need to work with environment variables within the `sed` expressions,
    then you should use double quotes instead. Normally `sed` reads from `stdin`,
    processes the stream internally, and outputs the transformed version of the text
    to `stdout`. So, it''s ideally being used in a `pipe` command, therefore it is
    often part of pipelines. `sed` can be used for a lot of different use cases.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: A very easy example using address ranges would be the `d` option, to delete,
    which also helps you understand how `sed` does its processing on input and output
    streams. So again, `cat /etc/services | sed '20,50 d'` pipes the `etc/services`
    file stream using `cat` into `sed`. `sed` processes the input stream line by line,
    and, here, all the lines that are not between line number 20 to 50 get handled
    directly over to the `stdout` channel, while lines number 20 to 50 get suppressed
    completely. You can also use regular expressions with the `d` option. Remember
    to put any regular expressions in slashes when working with `sed`. The `sed` command
    ignores all the lines starting with the hash symbol, but it prints out all the
    others to `stdout`. There are a lot of different options and modes that can work,
    but there are too many to mention here.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important usage for `sed` is definitely the substitution mode, which
    can be used to automate file or text editing without any user interaction. Its
    general syntax is: `sed ''s/search_for_text/replace_with_text/'' FILENAME`. This
    will search for the pattern between the first slashes, which can be a regular
    or literal expression, in the file filename, and if and only if this pattern matches
    the text somewhere in the line in this file, will it be replaced by the text to
    be found between the other slash. This only works for the first occurrence in
    the file. If you need to replace all occurrences of the search text in the file,
    you have to use the `g` option at the end of the slash expression. For example,
    to replace the word `root` in the `passwd` file with the word `King_of_the_Jungle`,
    for every occurrence, execute the command shown in the following screenshot:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a46e9cd-26af-4ed3-a86b-9dc62120a57c.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: If you are searching for anything that contains slashes, you can escape the
    regular substitution usage using a different pattern delimiter, because otherwise
    you would need to escape the slash character that you want to search for or replace,
    which can look very complicated and unstructured. This can also be written as
    `sed 's:XX:YY:g' FILENAME`, or any other character of your choice. So for example,
    if you want to replace single slashes with double slashes in a file, instead of
    using `sed 's//////g' FILENAME`, it's cleaner to use `sed 's:/://:g' FILENAME`,
    or `sed 's#/#//#g' FILENAME`. Using the substitution mode without any `sed` option
    will always print the transformed text to `stdout`. Sometimes, it is useful to
    directly change the text in the input file. This can be done using the `sed -i`
    option, or inline option.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will work on a copy of the `passwd` file to show
    you how to do in-place editing. In order to do so, perform the following steps:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a copy of the `passwd` file in the `/tmp` directory, as shown in the
    following screenshot:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/140e3682-1a00-4c39-acce-e0199bc574f8.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: Let's first show all the lines containing the word `root`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, replace the word `root` in the file with random text on `stdout` only.
    Execute the following command:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now to in-place edit the file, use the `-i` option:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The file has been permanently changed. Please take care when using this option,
    because if you have not tested your substitution before and you have made a mistake,
    you cannot revert your changes. It is better to create a backup copy of the original
    file before applying in-place editing, which you can do using the `sed -i` option,
    for example, `sed -i.bak ''s/root/RULER_OF_THE_WORLD/g'' /tmp/test-passwd`. If
    you write a new extension such as `.bak` behind the `-i` option, it will create
    a backup copy with the extension `bak` before applying the regular expression
    to the original file. When working with these regular expressions in the substitution
    mode, the grouping and back referencing feature that we showed you before makes
    substitutions very powerful, because this gives you real control of the changes
    needed to be made for your input text, for example, the `passwd` file contains
    colons as field delimiters, one colon to separate one field. Using sed when back
    referencing, we can replace one colon with four:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd6696d5-77cc-4f47-b11a-8b0eb26bafee.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: POSIX extended regular expressions as used by `grep`, `sed`, and `awk` also
    define a number of very useful special character classes in brackets, which can
    be very useful in pattern matching. The general syntax is `grep '[:digit:], [:space:],
    [:blank:]'`. The digit bracket character class matches all digits at a specific
    position. Space matches all the spaces, and blank matches all the whitespaces,
    such as the *Tab* space, and blank matches all the whitespaces. To match all the
    lines containing digits in the `etc/passwd` file, use `grep '[[:digit:]]' /etc/passwd`.
    For a list of all special character classes, use the `man 7 regex` manual.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Working with awk
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will show you what the command `awk` is all about and why
    it can be important for us. We will also show you how to use it for text file
    manipulation and processing. `awk` is another very important tool for text processing
    and manipulation. It can be used as a complete scripting language to work on text
    files or streams. It contains some very powerful programming constructs, including
    variables: *if...else*, *while*, *do while* and *for* loops; arrays; functions;
    and mathematical operations. `awk` also works on a line-by-line basis, as `sed`
    does. One of the key features of `awk` and the main difference to `sed` is that
    it splits input lines into fields automatically. But how does it work and why
    is it so helpful?'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '`awk` enables you to create rule and action pairs, and, for each record that
    matches this rule or condition, the action will fire. The rules are also called
    **patterns** and are fairly powerful and can use **extended regular expressions**.
    The language for the actions is similar to the programming language C. Using the `awk`
    symbol paradigm to find a pattern in the input and then applying some kind of
    action often reduces complex and tedious data manipulation tasks to just a few
    lines of code, or even one-liners. `awk` also lets you create and execute powerful
    `awk` script files for automating challenging text transformation tasks but, in
    this section, we will only focus on using `awk` options and arguments on the command
    line. Please note that, as `awk` is a complete scripting language with a lot of
    features and options, we can only show you the most important use cases and examples
    here.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the basic structure of any `awk` command: `awk [pattern] { action }...INPUTFILE`.
    It''s important to note that the actions must be surrounded by curly brackets.
    This can also be read as: go through the input file line by line and try to apply
    the pattern to each line. If, and only if, the pattern matches or the rule can
    be applied to the line and is true, the action between the curly brackets will
    be performed.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to learn and understand the `awk` tool is to use it without
    any rule or pattern and just define a simple action. Without giving it a pattern,
    the action will be applied to any line of input. As said before, `awk` completely
    splits each input line into fields so we can directly access those fields in the
    action argument using the following notation. As always, actions and patterns
    should be put into single quotes:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will print out field `1` of all the lines of the `etc/networks` file.
    As you can see, the action must be surrounded by curly brackets. `$number` is
    the number of the field and `$0` is the complete line. As you will probably know
    now, `awk` splits on every whitespace position by default. You can use the `-f`
    option to change the field separator. For example, to split the `passwd` file
    correctly, which has colons as field separator, you would specify the field separator
    `-f` using colon. This will print out field one of the `etc/passwd` file and the
    username: `awk -F: ''{ print $1 }'' /etc/passwd`. You can also use the awk `printf`
    function, which prints out the text formatted, as you may know from other programming
    languages: `awk -F: ''{ print "user: %stgroup: %sn", S1, S3 }'' /etc/passwd`.
    The `%s` will be substituted by the field numbers. `t` makes a *Tab* character
    and `n` makes a new line character.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to test some patterns. As we've said before, if you define a
    pattern or rule that can also be an extended regular expression, it will be applied
    through every input line and only for those matching the rule will the action
    be executed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will print out field one of all the lines, and only the
    lines, starting with small `t` in the `etc/services` file. Here we will pipe it
    into the `head` command to reduce the output to only the first 10 lines:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a70171b9-8dff-44d3-af97-5cdd635d5fd9.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: 'Please remember to put any regular expressions into slashes when working with
    the `awk` command. One of the greatest features of awk is that the pattern can
    also be more than a simple regular expression. For example, you can also use string
    and mathematical comparison operators here. This will help you answer very complex
    text manipulation questions with just a few tiny expressions:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc95c7e7-31df-4995-a9b3-17085cc0422c.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: 'In the previous example, `awk` only outputs lines from users in the `etc/passwd`
    file, which have a group ID greater than `500`. The greater than sign is the operator.
    There are lots of other operators available, but there are too many to mention
    here. For example, to match a regular expression, use `awk ''$1 ~ /netrjs/ {print
    $0}'' /etc/services`. The tilde is the regular expression match operator. To match
    string literals, use the equal sign twice instead, `awk ''$1 == "netrjs-4" {print
    $0}'' /etc/services`. To get a list of all the awk operators, search for operators
    in the man page. Also, `awk` has two special patterns, which are called **BEGIN**
    and **END**. As any other pattern, you can define an action for the begin and
    for the end pattern, and this will fire only once, at the beginning or at the
    end of the file. We can use this to print out the total number of bytes in a directory:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fafc9ee2-d1d3-422c-92db-9bf188441ca1.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: 'This `awk` command works this way: first it uses a variable called `SUM` that
    acts like a container for our number counting. The `+=` is a mathematical operator
    that adds field number `5` to our container `SUM`, so that this action counts
    the number of total bytes from the single byte number in field `5` on each line.
    Also, on each line we print out the whole line content, and, once we reach the
    end of the file, the end pattern will fired, which will print out the content
    of our `SUM` variable, which holds the total number of bytes in this directory.
    As you just saw, we can define custom variables to hold values that we want to
    have and work with. There are also a number of predefined variable names available
    in awk, which contain very useful information. For example, the `NR` variable
    name contains the current line number. This can be useful in the following `awk`
    command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will prepend the line number to each line of the output using the `NR`
    variable, which contains the current line number in each line. For a list of all
    the special awk built-in variables, use the manual and search for variables.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: awk contains a number of very useful predefined functions to use, such as the
    `print` or `printf` functions that we already know from the action statements.
    To execute more than one function in one action block you can use the semicolon.
    For example, awk contains a number of very useful string manipulation functions,
    such as the `toupper (argument)` function. Functions in awk work like functions
    in most other programming languages. You call it using the function name and then,
    in brackets, you add the argument or arguments. For example, we use this with
    the `print` and `printf` function in the awk action. For example, in awk there
    exists a string function called `toupper`, which converts every string argument
    to uppercase letters.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a complete `awk` command-line example that uses the `toupper`
    function:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5addac74-524f-4f61-b729-45e5bfd8e3eb.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: 'This prints out the first field in the `passwd` file normally, and then again
    with all letters in uppercase. Our final example will show you how to execute
    more than one expression or function in one action statement using the semicolon
    as an expression delimiter:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91e0abde-a7b5-4de3-be0e-d2bfdbd88dec.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: Also, you can see here that you can assign the return value of any function
    to a variable name, and then reference this variable name later, so that this
    example is very similar to the example before by first printing out the uppercase
    version, and then the normal lowercase version, and then the normal field value
    version. For all the available awk functions, we use the manual and search for
    functions, numeric functions, string functions, time functions, and so on.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the Linux filesystem
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will learn how to navigate the Linux filesystem. You will
    also learn how the Linux filesystem is structured. If we print out the folder
    structure of the top-level directories beneath the root directory by executing
    the `tree -d -L 1 /` command, you will see a list of strange-sounding directory
    names. These directory names are the same on any Linux distribution and they follow
    a standard called the **filesystem hierarchy standard** (**FHS**). Each of these
    standard directories in the Linux filesystem has a specific purpose, and the user
    can expect certain files in certain locations, and it also means that a program
    can predict where the files are located, and it also means that any program working
    with those system directories can predict where the files are located. The following
    are the directories:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The `/` slash is the primary hierarchy root.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/bin` contains essential commands needed for the system, for example, so that
    a user can work in recovery mode of the system when something breaks or, for example,
    executables needed when a user boots into recovery mode.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/boot` contains files needed for booting, such as the kernel files.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dev` contains the device files of the system, for example `/dev/null`, which
    we have used before. This directory is very important and you will use it a lot
    when you are working as a system administrator. It contains the system-wide configuration
    files of all your applications that you have installed on your system.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/home` contains the user''s home directories, as we have learned in this section.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/lib` contains the libraries essential for the binaries in `/bin` and `/sbin`,
    as we will see next. `/lib64` contains alternate format essential libraries for
    the 64-bit architecture.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/media` contains the mount points for removable media such as CD-ROMs.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/mnt` contains temporarily mounted filesystems.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/opt` contains optional application software packages.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc` contains the virtual filesystem providing process and kernel information
    as files, for example, this is where all the environment variables of the current
    sessions are stored.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/root` contains the home directory for the `root` user. The root user''s home
    directory is not in `/home`.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/run` contains runtime variable data; this is information about the running
    system since last boot.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sbin` contains essential system binaries.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/srv` contains all the data that should be served by the system, for example,
    data and scripts for web servers or data offered by FTP servers that are running
    as services on the system.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sys` contains information about the devices connected to the system.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/tmp` contains temporary files. Every user has full access to this directory.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr` contains the majority of all the user utilities and applications, for
    example, all the applications installed by a user go in here. It''s also called
    a **secondary hierarchy** for read-only user data; because it has a similar structure
    as the root directories, top-level directories. For example, you also have a `/usr/bin`
    directory, a /`usr/lib` directory, a `/usr/sbin` directory, and so on.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/var` directory is for all the files that are expected to continually change
    during normal operation of the system, for example, log files, spool files, and
    temporary email files.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let's introduce the concept of Linux home directories. Every user known
    to a Linux system has their own private place in the filesystem, where they can
    manage their own data and have full access to everything, for example, creating
    directories or new files, deleting things, or changing permissions. For security
    reasons, most places in the Linux filesystem, with a few exceptions, such as the
    system `/tmp` directory, are restricted in one way or the other, and normally
    a logged-in user does not have full access to it only the `root` user has full
    access to everything. Every logged in user has the property of a current directory,
    which is the directory you're currently at. When a user logs in to the Linux system,
    their specific home directory will be set as the current directory by default,
    so they will start in this directory.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: To display the name of your current directory, which means where you are at
    the moment, type `pwd`, and then press the *Enter* key. pwd stands for **print
    working directory**. This is a very useful command because when you are browsing
    directories, it is easy to get lost. A directory is a concept to structure data.
    Often, it is used to categorize all files belonging to the same project or of
    the same type, such as all configuration files. As you can see, the output of
    the `pwd` command contains a string containing slash symbols that are used to
    separate directory names, and this is also called the **directory separator symbol**.
    The leftmost slash has a special name and it is also called **root directory**.
    The last directory name of the current directory can also be seen at the shell
    prompt. In a Linux filesystem, every directory can have files in it and can contain
    further directories that are then called subdirectories. These subdirectories
    can also include files and folders and so on. The directory containing a subdirectory
    is also called the parent directory, while the subdirectory is called the **child
    directory**. Here, in our example, the home directory is the parent of the `olip`
    directory, which is also called the child directory. These type of files and folders
    can be visualized using a tree-like structure, and also this can be called a hierarchical
    filesystem because every directory in this structure has a specific position and
    some are higher in the hierarchy and others are lower. The highest directory is
    the `/` directory, or `root` directory. We need to remember to visualize this
    hierarchical tree structure. We can use the `tree` command, which we need to install,
    because it is not available in the standard installation. To install it, use your
    `root` password that you set up during installation.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: After installing, you can use the `tree` command to get a first overview of
    your system. At the top level we have the `/` directory, which is the highest
    directory in the tree. Directly beneath it we have a number of system directories.
    When we customize the `tree` command to show us two levels of directories in the
    tree by executing `tree -d -L 2 / | less`, we can see where the home directory
    in the tree is and how we can get to it from the root directory, which is the
    parent of all the other directories. Now, to create a new directory in your home
    directory, you can use the `mkdir` command. The `mkdir` command takes the name
    of the folder you want to create as an argument. To remove an empty directory,
    use the `mrdir` command. To create a new empty file, use the `touch` command.
    To remove a file, use the `rm` command.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s recreate the folder and the filename again. To change to a directory,
    you can use the `cd` command, which stands for **change directory**. The change
    directory command will change your current directory to the new directory, which
    you used as an argument for the `cd` command. Use `pwd` to test this again. The
    following screenshot illustrates this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a6673ed-e287-4ee1-b983-90c48f5d9f2a.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: 'In Linux, when we say to go to a directory, what we really mean is to make
    another directory our current one by using the `cd` command. As mentioned before,
    every directory contains two special shorthand links that you can''t change and
    you can''t remove, the `.` and the `..`, which is the name of the directory we
    are currently in. Every directory contains the name `..`, which is the name of
    the unique parent directory of the directory in which we are currently in. Also,
    every subdirectory contains exactly one parent directory, while one parent directory
    can contain multiple subdirectories. These dots are very useful for traveling
    through directories fast. To go back to the preceding directory, which in our
    case is the home directory, we can use the `..` notation. To create a subdirectory
    in a subdirectory in a subdirectory, we can use the following approach:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/488b4c86-b24f-4c5d-b8dc-7122f94ed5d0.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: To view the folder structure that we have just created, we can use the `pwd`
    command again. To go up one directory level, we can use `cd..`. To go back down,
    use `cd FolderD`. Now, to go up two levels of directories, you can use the folder
    separator slash symbol-`cd ../ ../`. To go back two levels in our subdirectory
    structure, we can also use the folder separator slash symbol as well. When traversing
    directories there are always many ways to do this. To go back to the home directory
    quickly, we can use several different ways. To go back to the home directory first,
    you can use some shortcuts. As we have mentioned before, the tilde symbol stands
    for the home directory, so we can easily go back to the home directory `cd ~`.
    The tilde symbol works from everywhere, so you can go back to your home directory
    from any directory you are at. Also, a very helpful shortcut is `cd -`, which
    lets you toggle between the current directory and the directory you were at before.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: There even exists a shorter way to go back to your home directory from every
    location, using only the `cd` command without any arguments. Another way to go
    to your home directory from every location is to use the path outputted from the
    `pwd` command directly. In order to delete a directory structure that contains
    subdirectories or files, you cannot use the `rmdir` command. To delete a directory
    subtree that contains files and directories, instead, we need to use the `rm -rf`
    option, but please use it with caution as this will delete everything without
    asking, which is completely irreversible.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: To recreate the same subdirectory structure, as we showed you before in a much
    simpler form we can use the directory separator symbol with the `mkdir -p` option.
    So far, all our operations and actions on files and folders, such as `ls`, `mkdir`,
    or `mrdir`, were always in relation to the current directory, which means the
    description on how to go to the directory or file of choice was always in relation
    to the current directory. For example, we used commands to work with files and
    directories that are within our current directory. For referencing files and folders
    outside of our current directory, we use the `..` and a slash directory separator.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to work on files and directories in the same directory, we just
    need the name of the resource. If we want to access a resource outside of our
    current directory, we can do this using the directory separator and the `..` notation
    to travel to the right file or directory. Now, let''s again execute the `pwd`
    command. The output of the `pwd` command is called **absolute** or **full path**.
    An absolute path is easily recognized from the leading forward slash, which is
    called the root directory, as you now know. The slash symbol means that you start
    at the top-level directory, or root directory, and continue down. An absolute
    path is literally a path of names throughout the hierarchy. A pathname specifies
    and describes how to traverse or navigate the hierarchical directory names in
    the filesystem to reach some destination object starting from the highest root
    directory, which can be a file or directory. The full path always contains complete
    information on how to go from the root directory to any destination in the filesystem.
    In other words, to go to the current directory, which is called `/home/olip/FolderA`,
    you have to traverse, from the `/root` directory, to the `home` directory, to
    the `olip` directory, and to the `FolderA` directory. To visualize this in a tree-like
    structure, use the `tree` command with the subdirectory **L 3**:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e2770f4-c1a2-495b-9fcc-06529fc4a948.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
- en: It's important to remember that the absolute path works from everywhere. A relative
    path doesn't have a preceding slash. Using a relative path, for example, changing
    to `FolderA`, is always dependent on where you are at the moment in the filesystem.
    So, `cd FolderA` only works in your current position. If you re-execute the command
    somewhere else, it doesn't work. When using any Linux command that works with
    files or directories, you always have the option to either use a local path relative
    to your current directory, or to use the full and absolute path relative to the
    root directory. Oftentimes, the relative path is faster to use and often it is
    also convenient to change to the directory of the files you want to work with
    directly. But the absolute path is important for scripts or if a command needs
    to work from every directory.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started off with an introduction to the command line, file
    globbing, and quoting commands. We progressed towards practical execution by working
    with the shell, standard streams, and regular expressions. We also covered functionalities
    of `sed`, `awk`, and the Linux filesystem.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover concepts pertaining to files.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL

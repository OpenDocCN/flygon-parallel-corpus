- en: The Linux Filesystem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux文件系统
- en: In the previous chapter, we introduced you to Linux files and folders by navigating
    the filesystem. In this chapter, we will learn how to work with, find, and change
    permissions and access to reading and editing files. We will expand our knowledge
    on this topic, define what a filesystem is, and show you important commands for
    working with files, such as copying and moving.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过浏览文件系统向您介绍了Linux文件和文件夹。在本章中，我们将学习如何处理、查找和更改文件的权限和访问权限以及读取和编辑文件。我们将扩展我们对这个主题的知识，定义文件系统是什么，并向您展示处理文件的重要命令，如复制和移动。
- en: 'We''ll walk you through the following concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为您介绍以下概念：
- en: Understanding the filesystem
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解文件系统
- en: Working with file links
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文件链接
- en: Searching for files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索文件
- en: Working with users and groups
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与用户和组一起工作
- en: Working with file permissions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文件权限
- en: Working with text files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理文本文件
- en: Working with VIM text editor
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用VIM文本编辑器
- en: Understanding the filesystem
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解文件系统
- en: A filesystem is not only a tree of files and folders exposed to the Linux user,
    but it's also the structure and management to access and save data, and keep everything
    consistent. As already mentioned, you often hear the phrase that in Linux, everything
    is a file, and this is true. This means that a lot of different things in Linux
    get abstracted as files. For example, a directory is a file, hardware devices
    get represented by special system files, or ,useful, such as a random number generator,
    is also a file.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统不仅是向Linux用户公开的文件和文件夹树，还是访问和保存数据以及保持一切一致的结构和管理。如前所述，您经常听到Linux中的一切都是文件，这是真的。这意味着Linux中的许多不同事物都被抽象为文件。例如，目录是一个文件，硬件设备由特殊的系统文件表示，或者，有用的东西，如随机数生成器，也是一个文件。
- en: Let's quickly recap and summarize what we already know about working with files
    from the last two chapters. `ls` lists and displays files, `touch` creates a file,
    files are case sensitive, and `.` files are hidden files and are excluded from
    normal command execution, such as the `ls` command, and also from shell expansion
    using file globbing characters. Next, you should also already know `mkdir` creates
    a directory, `rmdir` deletes an empty directory, `rm` deletes a file, and `mkdir
    -p` creates a full subdirectory structure. `rmdir` cannot be applied on nonempty
    directories; in our example, it contained subfolders. `rm -rf` deletes a directory
    with all the subdirectories, but handle it with caution. When you use the `rm
    -rf` option to delete a whole directory structure, the `r` option stands for recursive,
    `f` for force. The recursive option is an important option you will often encounter
    when working with commands that do something for a whole subdirectory tree.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾和总结我们在过去两章中已经了解的有关处理文件的知识。`ls`列出并显示文件，`touch`创建文件，文件区分大小写，`.`文件是隐藏文件，并且被排除在正常命令执行之外，例如`ls`命令，也被排除在使用文件通配符进行shell扩展时。接下来，您还应该知道`mkdir`创建目录，`rmdir`删除空目录，`rm`删除文件，`mkdir
    -p`创建完整的子目录结构。`rmdir`不能应用于非空目录；在我们的示例中，它包含子文件夹。`rm -rf`删除带有所有子目录的目录，但要小心处理。当您使用`rm
    -rf`选项删除整个目录结构时，`r`选项代表递归，`f`代表强制。递归选项是您在处理对整个子目录树执行某些操作的命令时经常遇到的重要选项。
- en: 'Now, let''s learn some other important new file-based commands. If you need
    to copy a file, you can use the `cp` command. We already saw the general usage
    of `cp`in the previous chapter. If you go to the man page of the `cp` command,
    there are three different usage formats: `cp [option]... [-T] SOURCE DEST`, `cp
    [option]... SOURCE... DIRECTORY`, and `cp [option]... -t DIRECTORY SOURCE...`
    It''s important to remember that there can be multiple source directories, but
    only one target directory. You have to memorize this. To copy one single file
    to one destination file, you can use the first usage form. To copy several files
    to one destination folder, you can use the second usage form. The third usage
    form is like the second usage form, but with mixed source and directory arguments.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习一些其他重要的基于文件的命令。如果您需要复制文件，可以使用`cp`命令。我们已经在上一章中看到了`cp`的一般用法。如果您查看`cp`命令的手册页，有三种不同的用法格式：`cp
    [option]... [-T] SOURCE DEST`，`cp [option]... SOURCE... DIRECTORY`和`cp [option]...
    -t DIRECTORY SOURCE...`。重要的是要记住，可以有多个源目录，但只能有一个目标目录。您必须记住这一点。要将单个文件复制到一个目标文件，可以使用第一种用法形式。要将多个文件复制到一个目标文件夹，可以使用第二种用法形式。第三种用法形式类似于第二种用法形式，但混合了源和目录参数。
- en: 'For example, to create a copy of a file with a different filename, use `cp
    firstfile secondfile`; you can also do the same using local pathnames. As we have
    learned from the manual, you can also copy files to directories leaving the original
    filename. As shown in the manual, you can also do this for multiple source files.
    Note that you cannot copy complete directories out of the box using the `cp` command.
    In order to do so, you need to provide the `-R` option:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要创建具有不同文件名的文件副本，请使用`cp firstfile secondfile`；您也可以使用本地路径名执行相同操作。正如我们从手册中学到的，您还可以将文件复制到目录，保留原始文件名。如手册中所示，您还可以对多个源文件执行此操作。请注意，您不能直接使用`cp`命令复制完整的目录。为了这样做，您需要提供`-R`选项：
- en: '![](img/bebc3942-7fa4-42e9-bcec-02a1bcc83191.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bebc3942-7fa4-42e9-bcec-02a1bcc83191.png)'
- en: As you can see, the complete `olip` home directory has been copied to the `/tmp`
    directory with all subdirectories and files. Please memorize that the `cp -R`
    option stands for recursive, again. To move files and folders on the command line
    you can use the move command, which implicitly copies and deletes the source files.
    The move command `mv` is often used to rename files and folders. Note that you
    can move or rename not only files, but also folders.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，完整的`olip`主目录已被复制到`/tmp`目录中，包括所有子目录和文件。请记住，`cp -R`选项再次代表递归。要在命令行上移动文件和文件夹，可以使用移动命令，它隐式地复制并删除源文件。移动命令`mv`通常用于重命名文件和文件夹。请注意，您不仅可以移动或重命名文件，还可以移动或重命名文件夹。
- en: 'Now, again if you have a look at the `ls -l` option, for example, in the `/etc`
    directory, you will notice some things. You will be presented with a lot of useful
    information. The first character in the `-l` listing here is a `d`, or `-`, or `l`,
    and this represents the type of the file. A `d` stands for directory, a `-` is
    a normal file, and `l` is a link. The first character in the `ls -l` output is
    also called the file type flag. Besides the shown `d`, `-`, and `l` flags, there
    are a number of other available file types. To get a full list of all the available
    file type flags, use `man find`, search for `type`, then search for `type c`.
    You will get a full list of all the available file type flags in Linux:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d307e470-cc66-4be1-8e8f-87c8e340b3a9.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: 'Also, there is another very useful piece of information given in the column
    adjacent to the permissions column. The number presented is the number of links
    a file contains:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d56b799-e748-443f-99d6-ed806ae1302a.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: File links tell us how many references exist on any given file or directory.
    Every normal file by default has one link and every directory has two links. There
    are hard links and soft links, which we'll discuss shortly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Working with file links
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we take a look at what Linux file links are and how to work
    with them. As you already might know, files are stored on the hard disk. In a
    Linux filesystem, the file''s filename and the data are two separate concepts
    and are not stored together. A general structure is shown in the following diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8ee3da0-feea-4027-be6b-0d3a9cba07f9.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: Connecting a filename to the actual data is managed by the filesystem using
    a table or database data structure, which is called a title allocation table.
    In the Linux filesystem, an Inode is the actual entry point or starting point
    to the beginning of a specific file's data on the hard disk. To simplify, we can
    just say that the Inode represents the actual data of a file. The filesystem management
    now takes care that every normal file, upon creation, has one link entry in its
    allocation table to connect the actual filename to the Inode or data on the hard
    disk. Such a link is also called **hard link**. The original filename to Inode
    relationship is also linked using a hard link, that's why in the last section
    the `ls -l` command gave us the number `1` for most of the files in the column
    adjacent to the permissions. Now, the cool thing about the Linux filesystem is
    that you can create additional hard links to an existing Inode, which is like
    having alternative names for a file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: One of the drawbacks of a hard link are that you cannot differentiate a hard
    link from the original filename or the Inode. This can cause problems and side
    effects, because if you change the original file's content the hard link's content
    will be changed as well. Another limitation of hard links is that you can only
    define them for Inodes, which are on the same partition as the hard link should
    go. Also, you cannot create hard links on directories. You can only create them
    on normal files. To solve these limitations of hard links, you can use **soft
    links**, also known as symbolic links. These are the type of links that you will
    use almost all the time in your everyday work as a Linux system administrator.
    Hard links also have their special use cases, for example, for creating backups
    of files, but are only used very rarely by the Linux user.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: A symbolic link is a link to the filename and not to the Inode. Symbolic links
    also don't have the boundary that they must be on the same partition or hard disk
    as the original file. You can also create symbolic links on a directory. The main
    drawback is that if you delete or move the original file, you will have a broken
    symbolic link without further warning, which can also create some bad side effects.
    The main use cases and power of symbolic links are referencing configuration files
    or dynamic library versions in the Linux filesystem. Using links can save a lot
    of disk space because no actual data must be copied and they are very effective
    for quickly testing out such things as alternate configuration files for services.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接是对文件名而不是Inode的链接。符号链接也没有必须在同一分区或硬盘上的原始文件的限制。您还可以在目录上创建符号链接。主要缺点是，如果删除或移动原始文件，您将得到一个中断的符号链接，而不会有进一步的警告，这也可能会产生一些不良副作用。符号链接的主要用途和功能是引用Linux文件系统中的配置文件或动态库版本。使用链接可以节省大量磁盘空间，因为不必复制实际数据，并且对于快速测试诸如服务的备用配置文件等内容非常有效。
- en: 'File links are managed by the `ln` command. The basic syntax is `ln [OPTION]`,
    then the filename you want to create a link on, and finally the link name. To
    create a hard link to a file called `fileX` in your `home` directory, use the
    following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 文件链接由`ln`命令管理。基本语法是`ln [OPTION]`，然后是要在其上创建链接的文件名，最后是链接名。要在您的`home`目录中创建一个名为`fileX`的文件的硬链接，请使用以下代码：
- en: '![](img/b405a283-2d42-4d1b-bcb5-60d5074e96d0.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b405a283-2d42-4d1b-bcb5-60d5074e96d0.png)'
- en: 'As you can see, there''s no way to differentiate the additional hard link from
    the original one. You can also create multiple links on the same file. To delete
    a hard link, use the `rm` command. There''s a maximum number of Inodes on every
    filesystem, or we can just simply say files, which you can display using `df -i`.
    If you use the `mount` command, you will see that the `tmp` filesystem for the
    user is on a different partition than the `home` directory, which is in turn,
    on the root partition as shown in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，无法区分附加的硬链接和原始链接。您还可以在同一文件上创建多个链接。要删除硬链接，请使用`rm`命令。每个文件系统或者我们可以简单地说文件都有最大数量的Inodes，您可以使用`df
    -i`来显示。如果使用`mount`命令，您将看到用户的`tmp`文件系统位于与`home`目录不同的分区上，而`home`目录又位于根分区上，如下面的屏幕截图所示：
- en: '![](img/c09ea1e8-16e4-4157-823d-9592ea0ddb58.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c09ea1e8-16e4-4157-823d-9592ea0ddb58.png)'
- en: 'So the next command `ln ~/folderABC ~/folderABC_link` will fail because it
    is not allowed to create hard links between partitions. Also, you cannot create
    a hard link on a directory, and changing the origin of the file''s content will
    change the hard link''s file content as well. This can create some bad side effects.
    To create a symbolic link, use the `ln -s` option:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，下一个命令`ln ~/folderABC ~/folderABC_link`将失败，因为不允许在分区之间创建硬链接。此外，您不能在目录上创建硬链接，更改文件内容的原始位置也将更改硬链接的文件内容。这可能会产生一些不良副作用。要创建符号链接，请使用`ln
    -s`选项：
- en: '![](img/efebda5f-f05f-4675-8195-fe6bf16637cf.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/efebda5f-f05f-4675-8195-fe6bf16637cf.png)'
- en: 'As you can see, it''s easy to show if a file as a symbolic link marked with
    the arrow. To create a symbolic link of a file in another directory, preserving
    the original file''s name, you can use `ln -s /etc/passwd`. This created a symbolic
    link of the /`etc/passwd` file in the current directory under the same name, `passwd`.
    To delete a symbolic link, use the `rm` command; the original file will not be
    touched. You can also create a symbolic link on a directory. If you delete the
    original file that the symbolic link is pointing to, that is `fileX` here the
    symbolic link will broke. This can get problematic, which is denoted here with
    the blue color:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，很容易显示文件是否为符号链接，标有箭头。要在另一个目录中创建文件的符号链接，保留原始文件的名称，您可以使用`ln -s /etc/passwd`。这在当前目录下创建了`/etc/passwd`文件的符号链接，名称相同为`passwd`。要删除符号链接，请使用`rm`命令；原始文件不会被触及。您还可以在目录上创建符号链接。如果删除符号链接指向的原始文件，即`fileX`，这里符号链接将中断。这可能会变得棘手，这在这里用蓝色表示：
- en: '![](img/35bdba9a-a00c-4743-b09f-2ddac711b66e.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35bdba9a-a00c-4743-b09f-2ddac711b66e.png)'
- en: Searching for files
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索文件
- en: In this section, we will learn how to search for files in Linux. The `man find`
    command, as the name implies, can find files based on versatile criteria. But
    more than that, you can even apply actions on every search result during execution
    of the program, which is a very useful feature. Find can take some options to
    change its default behavior, for example, how to treat files, which are symbolic
    links during execution of the program. The first few arguments are a list of directories
    or starting points to start your search in, all the other arguments are search
    expressions or conditions to find in your search. It's important to discuss what
    search expressions are. A search expression typically is a test and an action.
    Tests are typically separated by logical operators. If no operator is given, the
    end operator is assumed. If the expression contains no action by the user, then
    the `print` action will be performed for all the files in the search result.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在Linux中搜索文件。`man find`命令可以根据多种条件查找文件，正如其名称所示。但更重要的是，您甚至可以在程序执行期间对每个搜索结果应用操作，这是一个非常有用的功能。Find可以采用一些选项来更改其默认行为，例如如何在程序执行期间处理符号链接。前几个参数是要在其中开始搜索的目录或起始点的列表，所有其他参数都是搜索表达式或条件，用于在搜索中查找。讨论搜索表达式的内容很重要。搜索表达式通常是一个测试和一个操作。测试通常由逻辑运算符分隔。如果没有给出运算符，则假定为结束运算符。如果表达式中没有用户指定的操作，则将对搜索结果中的所有文件执行`print`操作。
- en: Before we start using the `man find command`, it's important to know how the
    `man find` command processes the search results. For every file in the list of
    search paths, all the expressions get evaluated from left to right. By default,
    only if all the expressions are correct, the `man find` command marks the file
    as a hit. You can change this logical end behavior if you like using an `OR` expression
    as well, as we will see later in one of our examples. The `man find` command lets
    you create very sophisticated search queries using a broad range of very useful
    file test expressions. If you search for `tests` in the manual page of the `man
    find` command, you will get a full list of all the available test operators. For
    example, you can search for files that have been modified or accessed at specific
    time in the past, or which have a certain size. As mentioned earlier, the default
    action is the `print` action on every file match. Another very useful action is
    the `exec` expression, which lets you execute a specific command for every file
    match. The `man find` command is a very complex command and we cannot show you
    everything here. Thus, for the rest of this section we will show you some very
    useful use cases. You can use the `find` command without any options or arguments.
    This is the same as writing because without any options and arguments the search
    path is the current directory and the default action is the `print` action. This
    command goes through your current directory and prints out all the files and directories,
    including all subdirectories and files beneath the subdirectories, recursively.
    It does so because you have not provided any test expression, so it will just
    match any file or directory in your current directory and apply the `print` action
    to it. As mentioned earlier, what makes the `find` command so powerful is its
    huge list of different test expressions to locate files based on a variety of
    useful conditions. Such file search tests can be anything imaginable, such as
    timestamps, user permissions, users, groups, file type, date, size, or any other
    possible search criteria.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用`man find`命令之前，了解`man find`命令如何处理搜索结果非常重要。对于搜索路径列表中的每个文件，所有表达式都会从左到右进行评估。默认情况下，只有当所有表达式都正确时，`man
    find`命令才会将文件标记为命中。如果需要，您还可以更改此逻辑结束行为，使用`OR`表达式，我们将在其中一个示例中稍后看到。`man find`命令允许您使用广泛的非常有用的文件测试表达式创建非常复杂的搜索查询。如果在`man
    find`命令的手册页中搜索`tests`，您将获得所有可用测试运算符的完整列表。例如，您可以搜索在过去的特定时间修改或访问的文件，或者具有特定大小的文件。如前所述，默认操作是对每个文件匹配执行`print`操作。另一个非常有用的操作是`exec`表达式，它允许您对每个文件匹配执行特定命令。`man
    find`命令是一个非常复杂的命令，我们无法在这里展示所有内容。因此，在本节的其余部分中，我们将展示一些非常有用的用例。您可以使用`find`命令而不带任何选项或参数。这与编写相同，因为没有任何选项和参数，搜索路径是当前目录，而默认操作是`print`操作。此命令遍历您当前的目录，并打印出所有文件和目录，包括所有子目录和子目录下的文件，进行递归处理。这是因为您没有提供任何测试表达式，因此它将匹配当前目录中的任何文件或目录，并对其应用`print`操作。如前所述，`find`命令如此强大的原因在于其巨大的不同测试表达式列表，可以根据各种有用的条件定位文件。这样的文件搜索测试可以是任何想象得到的，例如时间戳、用户权限、用户、组、文件类型、日期、大小或任何其他可能的搜索条件。
- en: 'For the following examples, we will use the root user account set up during
    installation, because in the example shown here, we search a lot in the system
    directories, which need special privileges. To search for only files and not directories
    in the `/etc` directory for the filename `logrotate.conf` use the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用安装过程中设置的根用户帐户，因为在此示例中，我们需要在系统目录中进行大量搜索，这需要特殊权限。要仅在`/etc`目录中搜索文件而不是目录，以查找文件名为`logrotate.conf`，请使用以下命令：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If the file is found, you won''t encounter any errors. What this command does
    in the background is it goes through the `/etc` directory and picks up all the
    files and subdirectories included in the `/etc` directory and it processes them
    recursively one by one. Then, for every file, it checks whether the file is the
    actual file, and whether the name is equal to the filename. You can also use multiple
    directories as search starting points, as well as use the `-type d` to search
    only directories, this will print out all subdirectory names beginning with the
    `/etc` and `/var` directories and starting with the letter `y`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到文件，您将不会遇到任何错误。此命令在后台执行的操作是遍历`/etc`目录，并选择其中包含的所有文件和子目录，并逐个递归处理它们。然后，对于每个文件，它都会检查文件是否为实际文件，以及名称是否等于文件名。您还可以使用多个目录作为搜索起点，以及使用`-type
    d`仅搜索目录，这将打印以`/etc`和`/var`目录开头并以字母`y`开头的所有子目录名称：
- en: '![](img/1be45990-ff19-4f1e-b07a-8571163036bc.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1be45990-ff19-4f1e-b07a-8571163036bc.png)'
- en: 'Here, the name expression takes normal POSIX 5 globbing characters, not regular
    expressions. If you want to use regular expressions for file search use the `-regex`
    expression instead. Note that if you use `-iname` expression instead, it will
    search case-insensitive. You can also search for files using file size as a criteria:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，名称表达式采用正常的 POSIX 5 通配符，而不是正则表达式。如果您想要使用正则表达式进行文件搜索，请改用`-regex`表达式。请注意，如果您使用`-iname`表达式，它将进行不区分大小写的搜索。您还可以按文件大小作为条件搜索文件：
- en: '![](img/94378bbd-41cb-4999-8117-71cebab507ac.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94378bbd-41cb-4999-8117-71cebab507ac.png)'
- en: 'The `find / -type f -size +4M -name ''l*''` searches for all the files equal
    to or larger than 4 MB starting with the name `l` and only files and not directories
    starting in the `root` directory, which means it will recursively search in the
    whole filesystem tree. As you see, only two files match all of these conditions.
    By the way, the `+` stands for greater or equals, if you use a `-` symbol it stands
    for less than. You can also search for specific file permissions. File permissions
    in general are discussed in later sections. To get a list of all the very dangerous
    directories with read, write, execute permissions for everybody searching in the
    whole filesystem, we use the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`find / -type f -size +4M -name ''l*''`搜索以名称`l`开头的大小等于或大于4 MB的所有文件，只有文件而不是以`root`目录开头的目录，这意味着它将递归搜索整个文件系统树。正如您所看到的，只有两个文件符合所有这些条件。顺便说一句，`+`表示大于或等于，如果使用`-`符号，则表示小于。您还可以搜索特定的文件权限。文件权限通常在后面的部分中讨论。要获取具有读、写、执行权限的所有非常危险目录的列表，以便在整个文件系统中搜索，我们使用以下命令：'
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that if the user doesn''t provide any action for the `find` command itself
    the default `print` action is assumed, so the command will print out every matched
    file to the `stdout` command line. We can change that using the `-exec` action
    expression, which will apply a command after the `-exec` expression for every
    matched file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果用户没有为`find`命令本身提供任何操作，则假定默认的`print`操作，因此该命令将将每个匹配的文件打印到`stdout`命令行。我们可以使用`-exec`操作表达式进行更改，该表达式将在`-exec`表达式之后为每个匹配的文件应用一个命令：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our example, the `chmod 755` command will be applied for every matched file
    using the placeholder `{}`, which stands for matched. The `find` command here
    will search for all the files having a very dangerous file permission, `777`,
    and changes it back to a more moderate permission, `755`. So if we search again
    for the dangerous permission, the result will be empty. Why do we have to escape
    the semicolon? This is because normally a semicolon in the Bash shell delimits
    commands, so we have to disable its special meaning here. In all the examples
    shown so far, all the tests and expressions of a single `find` command must be
    true that the file can be counted as match.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`chmod 755`命令将应用于每个匹配的文件，使用占位符`{}`，表示匹配。此处的`find`命令将搜索所有具有非常危险的文件权限`777`的文件，并将其更改回更适度的权限`755`。因此，如果我们再次搜索危险的权限，结果将为空。为什么我们必须转义分号？这是因为在Bash
    shell中，分号通常用于分隔命令，因此我们必须在这里禁用其特殊含义。到目前为止所示的所有示例中，单个`find`命令的所有测试和表达式都必须为true，文件才能被视为匹配。
- en: 'For example command `find / -type f -size +4M -name ''l*''` only files are
    matched and printed out if they are of type file and have a size of `4` MB or
    more and have a name starting with `l`. All of these three test expressions have
    to be `true` and are connected via a logical and. By default, the logical AND
    operator is connecting all the test expressions, which means only if all test
    expressions are true, the file can be matched as a hit. You can easily change
    a logical AND to a logical OR using the `-or` expression, like:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，命令`find / -type f -size +4M -name 'l*'`只有文件匹配并打印出来，如果它们是文件类型并且大小为`4` MB或更大，并且名称以`l`开头。所有这三个测试表达式都必须为`true`，并通过逻辑与连接。默认情况下，逻辑AND运算符连接所有测试表达式，这意味着只有当所有测试表达式都为true时，文件才能匹配为命中。您可以轻松地将逻辑AND更改为逻辑OR，使用`-or`表达式，例如：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will match all files starting with a `p` and having the extension `conf`
    or `.d` in the `/etc` directory, and having the type file. There are also some
    very useful test expressions based on the time of a file. For example, `find /var
    -mtime 10`| head will output all the files, which have been modified in the last
    three days, outputting only the first `10` hits before the last three days or
    longer. Using time-based test expressions is very useful and is often needed in
    your daily work as a system administrator. For example, if you would need to delete
    all the files uploaded by users of a web application running on your server, which
    are older than `30` days, you could do something like the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配所有以`p`开头并在`/etc`目录中具有`conf`或`.d`扩展名的文件，并且类型为文件。还有一些基于文件时间的非常有用的测试表达式。例如，`find
    /var -mtime 10`| head将输出所有在最近三天内修改的文件，仅在最后三天或更长时间之前输出前`10`个命中。使用基于时间的测试表达式非常有用，并且通常在您作为系统管理员的日常工作中需要。例如，如果您需要删除服务器上运行的Web应用程序的用户上传的所有文件，这些文件的年龄超过`30`天，可以执行以下操作：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This command could also be easily put into a script running each day, such
    as in a `Cron` job, to automate deleting of all the files which are older than
    `30` days, so you don''t have to take care of this manually anymore. To search
    for all the files in the entire filesystem, which start with the `l` and `r` and
    has a size between 1 and 4 MB use:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令也可以轻松地放入每天运行的脚本中，例如在`Cron`作业中，以自动删除所有早于`30`天的文件，因此您不必再手动处理此问题。要搜索整个文件系统中以`l`和`r`开头且大小在1到4
    MB之间的所有文件，请使用：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can also quickly search for files using the `locate` command instead of
    using find. You first need to install using the `package` and `locate`. The `locate`
    command does not do a live search in the filesystem, but rather uses a snapshot
    of the filesystem using a specific time point. This database gets updated every
    day at a certain point in time, but you can also regenerate the snapshot database
    by yourself using the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`locate`命令快速搜索文件，而不是使用find。您首先需要使用`package`和`locate`进行安装。`locate`命令不会在文件系统中进行实时搜索，而是使用特定时间点的文件系统快照。该数据库每天在特定时间点进行更新，但您也可以使用以下方法自行重新生成快照数据库：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now if you use the `locate` command, it will search the database you just generated
    for all the files matching the name `logrotate`. This will only search for literal
    text. If you want to use for regular expressions, use the `--regex` option.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您使用`locate`命令，它将搜索您刚刚生成的数据库，查找所有与名称`logrotate`匹配的文件。这只会搜索文字。如果要使用正则表达式，可以使用`--regex`选项。
- en: As we are searching a database, this is usually faster than doing a live search
    using the `find` command, but always remember this is not a live state of the
    current filesystem. Hence, you can run into problems especially when searching
    for files, which are newer than the search database.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在搜索一个数据库，这通常比使用`find`命令进行实时搜索更快，但请记住这不是当前文件系统的实时状态。因此，当搜索比搜索数据库更新的文件时，可能会遇到问题。
- en: Working with users and groups
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与用户和组一起工作
- en: In this section, we will learn how to create and remove users and groups, and
    how to add groups to users. Also, we will see how Linux internally stores user
    information and passwords, and how to retrieve user information programmatically.
    Finally, we will learn how to substitute user accounts while staying logged in.
    Linux is a multiuser system, which means more than one user can work with the
    system simultaneously. Therefore, a system is needed, which guarantees common
    access to Linux objects such as files using measurements of excess protection.
    For example, all files which have been created by one user should not be allowed
    to be erased by another user. Every Linux user is defined and identified by a
    unique user ID, as humans more easily can work with names than numbers. There
    also exists a literal username connected to each user ID, but Linux internally
    works with the **user ID** (**UID**) number when managing control on Linux objects
    such as files. There are two types of users accounts, login users which need a
    password to authenticate, and nonlogin users, which are useful for attaching user
    IDs to running programs or processes, as we will see later. Also there's one special
    account on every Linux system, the root user account, or administrator account,
    which we set up a password for during installation. This account on every system
    has access and is the owner to all objects, such as files presented in the Linux
    system, and this account can do anything to the system. If in Linux we have the
    username to control access files, it will be very limiting and time-consuming
    to grant or revoke permissions. Therefore, Linux also has the concept of groups
    to access control. Using groups can drastically simplify permission management
    by assigning permissions on a shared resource to a group, rather than to individual
    users. Assigning permissions to a group assigns the same access to the resource
    to all members of that group. Linux groups are also represented by a group ID,
    which is a number, but can also be referenced by its name, the group name. Every
    user in Linux has exactly one UID, but can belong to multiple groups or group
    IDs. One group is the primary group, which will be used when new files are created
    by that user.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将学习如何创建和删除用户和组，以及如何将组添加到用户中。此外，我们将了解Linux如何在内部存储用户信息和密码，以及如何以编程方式检索用户信息。最后，我们将学习如何在登录的同时替代用户账户。Linux是一个多用户系统，这意味着多个用户可以同时使用系统。因此，需要一个系统来保证对Linux对象（如文件）的共同访问，使用过度保护的措施。例如，一个用户创建的所有文件不应该被另一个用户删除。每个Linux用户都由唯一的用户ID定义和识别，因为人类更容易使用名称而不是数字。每个用户ID还有一个文字用户名，但在Linux内部处理Linux对象（如文件）的控制时，使用的是用户ID（UID）号码。有两种类型的用户账户，需要密码进行身份验证的登录用户和非登录用户，后者对于将用户ID附加到正在运行的程序或进程非常有用，我们稍后会看到。此外，每个Linux系统都有一个特殊的账户，即根用户账户或管理员账户，在安装过程中我们会为其设置密码。每个系统上的这个账户都可以访问并拥有所有对象，如Linux系统中的文件，并且可以对系统进行任何操作。如果在Linux中我们使用用户名来控制访问文件，那将非常限制和耗时来授予或撤销权限。因此，Linux还有组的概念来进行访问控制。使用组可以通过将权限分配给一个组来大大简化权限管理，而不是分配给单个用户。将权限分配给一个组会将对资源的相同访问权限分配给该组的所有成员。Linux组也由一个组ID表示，这是一个数字，但也可以通过其名称（组名）来引用。Linux中的每个用户都有一个UID，但可以属于多个组或组ID。一个组是主要组，在该用户创建新文件时将使用该组。
- en: Let's start by creating some new user accounts for our tests. Only `root` can
    do this. So first, let's log in as root. The `useradd` command adds a new user
    with the username given as an argument. This command creates a new user in the
    system and also creates the corresponding home directories. To make our new login
    accounts functional, we need to set passwords as well; we can do this with the
    `passwd` command. You can also use this command to change your own password. To
    set or change a password for other users, we type `passwd ` `username`-this can
    only be done using the root user account. To delete a user, use the `userdel`
    command. By default, the `userdel` command will not delete the user's `home` directory,
    so you have to do it yourself. To delete a user, it's better to use the `userdel
    -r` flag, which not only deletes the user but also deletes the associated `home`
    directory and mailbox. Let's recreate the user. Let's log out the root user. You
    can use the `su` command, or substitute user command, to switch the user while
    you are logged in. When you call the `su` command without any argument, the root
    user is assumed to be switched. To switch a substitute to a different user, you
    use the username as the first argument. You can recheck who is logged in using
    the `whoami` command. Using the `su` command, will preserve the original environment
    of the user who has executed the `su` command, and will not switch to the home
    user of the substituted user account.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为我们的测试创建一些新用户帐户开始。只有`root`可以做到这一点。所以首先，让我们以root身份登录。`useradd`命令添加一个以参数给定的用户名的新用户。此命令在系统中创建一个新用户，并创建相应的主目录。为了使我们的新登录帐户可用，我们还需要设置密码；我们可以使用`passwd`命令来做到这一点。您也可以使用此命令来更改自己的密码。要为其他用户设置或更改密码，我们输入`passwd`
    `用户名`-这只能使用root用户帐户来完成。要删除用户，请使用`userdel`命令。默认情况下，`userdel`命令不会删除用户的`home`目录，因此您必须自己执行此操作。要删除用户，最好使用`userdel
    -r`标志，它不仅会删除用户，还会删除相关的`home`目录和邮箱。让我们重新创建用户。让我们退出root用户。您可以使用`su`命令或替代用户命令在登录时切换用户。当您调用`su`命令而没有任何参数时，假定已切换到root用户。要将替代用户切换到不同的用户，您使用用户名作为第一个参数。您可以使用`whoami`命令重新检查谁已登录。使用`su`命令将保留执行`su`命令的用户的原始环境，并且不会切换到替代用户帐户的home用户。
- en: Now, let's exit the substituted user and switch to another user. Using the `su`
    command with a dash symbol as an argument, we create a more login shell-like environment,
    which means it behaves more like a user who would login to the shell for real.
    By executing `pwd`, you can see that the `home` directory has been changed to
    the substituted user's `home` directory. Now, exit the substituted user again.
    You can also directly execute a single command with another user account using
    `su -c` flag; `su` username `-c`. This is useful if you want to quickly start
    a script or a command using a different user account without completely switching
    the user.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们退出替代用户，并切换到另一个用户。使用`su`命令并带有破折号作为参数，我们创建一个更类似登录shell的环境，这意味着它的行为更像一个真正登录到shell的用户。通过执行`pwd`命令，您可以看到`home`目录已经更改为替代用户的`home`目录。现在再次退出替代用户。您还可以使用`su
    -c`标志直接使用另一个用户帐户执行单个命令；`su`用户名`-c`。如果您想要快速使用不同的用户帐户启动脚本或命令，而不完全切换用户，这将非常有用。
- en: Only the root user is allowed to substitute users using the `su` command without
    providing a password. Any other user who wants to use the `su` command needs to
    know the password of the substituted user.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 只有root用户被允许使用`su`命令在不提供密码的情况下替代用户。任何其他想要使用`su`命令的用户都需要知道替代用户的密码。
- en: The `useradd` and `passwd` commands are making changes to the `etc/passwd` and
    `etc/shadow` files, which are the most important files to store authentication
    and user information in the entire Linux system. The `passwd` file stores a list
    of all the user accounts known to the system, all the login users and all the
    system users. Login users are typical physical persons who can log into a shell
    such as the Bash shell using a password for authentication. System users typically
    cannot log into a shell and are often associated to system services and processes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`useradd`和`passwd`命令正在对`etc/passwd`和`etc/shadow`文件进行更改，这些文件是整个Linux系统中存储身份验证和用户信息的最重要的文件。`passwd`文件存储了系统中所有已知的用户帐户列表，所有登录用户和所有系统用户。登录用户通常是可以使用密码进行身份验证登录到shell（如Bash
    shell）的典型物理人员。系统用户通常无法登录到shell，并且通常与系统服务和进程相关联。'
- en: 'For example, to get a list of all the usernames available in the Linux system
    use:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要获取Linux系统中所有可用用户名的列表，请使用：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `passwd` file stores a lot of useful information such as the user's `home`
    directory, the default shell, or the user ID number. Refer to the manual page
    of the `passwd` command to find out more. The `/etc/shadow` file contains all
    the password information for all the users in an encrypted format. You need the
    root user account in order to view this file. To create a new group, use the `groupadd`
    command and to delete a group, use the `groupdel` command. The `groupadd` and
    `groupdel` commands internally work with the `/etc/group` file. This file shows
    you all groups available in the system as well as all the user IDs associated
    to these groups. Instead of reading the `/etc/group` or `/etc/passwd` file for
    getting information about a user, you can also use the `id` command. This will
    tell you the user ID, the group ID, and all the associated groups a user has.
    To add existing groups to a user, you can use the `usermod -G` command. `-G` overrides
    all the secondary groups a user has, leaving the primary group as it is. You can
    also define a comma-separated list of group names to be added to a username. It's
    important to remember that the `-G` always overrides the existing group names
    a user has.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`passwd`文件存储了许多有用的信息，例如用户的`home`目录、默认shell或用户ID号。请参阅`passwd`命令的手册页以获取更多信息。`/etc/shadow`文件以加密格式包含所有用户的密码信息。您需要root用户帐户才能查看此文件。要创建新组，请使用`groupadd`命令，要删除组，请使用`groupdel`命令。`groupadd`和`groupdel`命令在内部使用`/etc/group`文件。此文件显示系统中所有可用的组以及与这些组关联的所有用户ID。除了读取`/etc/group`或`/etc/passwd`文件以获取有关用户的信息外，还可以使用`id`命令。这将告诉您用户ID、组ID以及用户拥有的所有关联组。要将现有组添加到用户，可以使用`usermod
    -G`命令。`-G`会覆盖用户拥有的所有次要组，保留主要组不变。您还可以定义要添加到用户名的逗号分隔的组名称列表。重要的是要记住，`-G`始终会覆盖用户拥有的现有组名称。'
- en: 'Now, let''s examine the `permission string`, which specifies what the file
    owner, group owner, or any other user is allowed to do or not, based on who he
    is:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查`权限字符串`，它指定了文件所有者、组所有者或任何其他用户根据其身份允许或不允许做什么：
- en: '![](img/d1323c58-f325-4612-b11a-40cd1103020b.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1323c58-f325-4612-b11a-40cd1103020b.png)'
- en: '`-l` outputs the file owner in the third column. Here, it is `root`, and for
    this file it is `olip`. In the fourth column, the `ls -l` outputs the group owner
    of the file. Also, here it is `root` and here it is `olip`. You already know that
    the first character in the `ls -l` output is the file type. Now, the nine bits
    afterward `l` and `d` define the file''s permission string. The first three characters
    of the permission string define the permissions for the file owner. The second
    three bits of the permission string define the permissions for the group owner.
    The last three bits in the permission string define the permissions for all the
    other users. In this example, `folderABC` has the file owner `olip`, the group
    owner `olip`. Furthermore, the file owner `olip` has full permissions on the directory,
    the group owner `olip` has full permissions on the directory, and all the other
    users have read and execute permissions on this directory.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`-l`在第三列中输出文件所有者。在这里，它是`root`，对于这个文件是`olip`。在第四列中，`ls -l`输出文件的组所有者。同样，在这里是`root`，在这里是`olip`。您已经知道`ls
    -l`输出中的第一个字符是文件类型。现在，`l`和`d`之后的九位定义了文件的权限字符串。权限字符串的前三个字符定义了文件所有者的权限。权限字符串的第二个三位定义了组所有者的权限。权限字符串中的最后三位定义了所有其他用户的权限。在这个例子中，`folderABC`的文件所有者是`olip`，组所有者是`olip`。此外，文件所有者`olip`对目录有完全权限，组所有者`olip`对目录有完全权限，所有其他用户对此目录有读取和执行权限。'
- en: 'Perform the following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'First, let''s create a directory. We''ll put in some files to work with and
    then change to the directory:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个目录。我们将放入一些文件以便处理，然后切换到该目录：
- en: '![](img/322825a2-110b-4558-a1a9-bd7df470bf33.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/322825a2-110b-4558-a1a9-bd7df470bf33.png)'
- en: Now, let's create some files to play around.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一些文件来玩耍。
- en: Let's look at the file permissions of the files we have just created.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看我们刚刚创建的文件的文件权限。
- en: As you can see in the preceding screenshot, the root user has created all these
    files. Hence, the file ownership and the group ownership are both `root` for all
    the files.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，root用户已创建了所有这些文件。因此，所有文件的文件所有权和组所有权都是`root`。
- en: Now, to change the file ownership and group ownership information you can use
    the `chown` or `chgrp` commands.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要更改文件所有权和组所有权信息，您可以使用`chown`或`chgrp`命令。
- en: Instead of using the `chgrp` command, you can also use the `chown` command using
    a different notation.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以使用不同的表示法使用`chown`命令，而不是使用`chgrp`命令。
- en: For example, to change a file's group, you can modify both the file owner and
    group ownership.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，要更改文件的组，您可以修改文件所有者和组所有权。
- en: Let's also create some subfolders as well for testing directory permissions.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也创建一些子文件夹来测试目录权限。
- en: Put some files into these folders as well.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也将一些文件放入这些文件夹中。
- en: Next, let us use some very dangerous `test` directories so that everyone is
    able to work with the files properly during our tests. This is not meant to be
    for production.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用一些非常危险的`test`目录，以便在我们的测试期间每个人都能正确地使用文件。这不是为了生产。
- en: Next, create some common permissions for our files.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为我们的文件创建一些常见权限。
- en: Create some unusual permissions, also create some permissions for directory
    tests.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一些不寻常的权限，还为目录测试创建一些权限。
- en: Change some file ownership permissions on files and group ownership permissions
    on a directory.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改一些文件的所有权权限和目录的组所有权权限。
- en: 'Now, let''s work with our new files and change permissions. Let''s first review
    the output of the `ls -l` command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们的新文件并更改权限。让我们首先查看`ls -l`命令的输出：
- en: '![](img/89a45fbe-4360-4d1a-9546-ae79655018b2.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89a45fbe-4360-4d1a-9546-ae79655018b2.png)'
- en: 'File one is a file which has full read, write, and execute permissions for
    anyone. For example, any user known to the system can modify this file. The next
    file has the standard permission every file gets upon creation on a CentOS 7 machine.
    File owners have read and write access, whereas the group and all the other users
    only have read access. Let''s find out what this means if different users want
    to modify the file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15ca13bd-6901-464a-a826-322091874ed1.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: 'Here we can see some interesting things. The `root` user has read, write, and
    execute permissions to any file despite what has been set in the permission string
    for the `root` user. `Peter` is the file owner, so he can write to this file.
    `Paul` is neither the file owner nor the group owner, so he has no write permissions
    at all. The next file has a permission often used for confidential files such
    as password files. Often this is done for services running a filesystem user account
    to protect others from reading credentials:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54105fbf-0f46-41c6-84cd-95a6cf81d6d8.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: 'In this example, only the `root` user has the ability to read the file, nobody
    else. The next file has a common permission set used if not only the file owner
    but also members of the group that owns the file''s owning group should have full
    control over the file. As you see, `Peter` and `Paul` don''t have access to write
    to this file because they are neither the file owner nor the group owner. To change
    this, let us add `Peter` to the group that owns this file, and then test again:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5e58430-c579-4a7b-a32b-38791ef28882.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: 'Now, `file5` has some unusual permissions, which are valid. `file5` is a script
    file, which prints something out. As you can see, only the `root` user can execute
    the file. To let `Peter` execute the script, add one of the groups that is associated
    with it to the file. This still does not work because now `Peter` can execute
    this file, but cannot read it. To change this, add read permissions for the group
    ownership of the file as well. Now, `Peter` is finally able to run the script:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c12d9566-17a9-45a4-ad6b-c546448c45c0.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: 'Finally, a common misconception is to delete a file you need to set the file''s
    write permission flag correctly for the user, but this is not true, as we can
    see. Why can''t `Peter` delete this file even though we''ve assigned full permissions
    to everyone here? This is because file deletion is completely dependent on the
    write permission of the directory the file you want to delete is in, and not on
    any file permission. The following screenshot is where the user `Peter` is denied
    permission to delete the file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f4d9349-d4fb-4101-8566-171c1c673dc0.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: 'Finally, let''s discuss directory permissions. The following screenshot is
    an example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57e6ce49-71ac-46a5-bc88-fbccfed423b3.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: '`folderA` has read permissions for the file owner, so he''s the only one who
    is able to see what''s in the folder but cannot change into the directory. `folderB`
    has only read permissions for the group owner, which means only members of the
    `projectA`a group can change into this directory, but `Peter` cannot do anything
    in this folder other than entering it using the `cd` command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f32ce42-c0f1-4e3a-848e-f2fca00ca2f4.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: 'In order to list files in this directory, let''s order the read permissions
    to the group owner:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51269d51-81b5-48f1-aab1-31f17633966b.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: 'As we have learned before, we need to enable the `write` flag on a directory
    in order to create or delete new files in it. But why is this not working here?
    It''s because we also need to enable execute permissions on a directory, which
    makes sense because in order to create or delete a file in the directory, we need
    to have access to this directory. What can we do if we want to change permissions
    on a lot of files, for example, a whole subdirectory tree? Using the `ls -lR`
    flag, we can list all the subdirectories and files included. Now, to change the
    permission string for all the files in a subdirectory, you can use the `chmod
    -R` flag:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前学到的，我们需要在目录上启用“写”标志，以便在其中创建或删除新文件。但为什么这里不起作用呢？这是因为我们还需要在目录上启用执行权限，这是有道理的，因为为了在目录中创建或删除文件，我们需要访问该目录。如果我们想要更改很多文件的权限，例如整个子目录树，我们可以怎么做？使用`ls
    -lR`标志，我们可以列出所有包括的子目录和文件。现在，要更改子目录中所有文件的权限字符串，可以使用`chmod -R`标志：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As always, be careful with the recursive flag as you easily can change the file
    permissions for your whole filesystem to an unsecure permission irreversible.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，要小心递归标志，因为你很容易会将整个文件系统的文件权限更改为不安全的不可逆转的权限。
- en: Working with file permissions
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件权限
- en: In this section, we will learn about the concept of file access control in Linux.
    We will also learn and understand how to read file permissions. Finally, we will
    learn how to change file ownership as well as file permissions and show you practical
    file permission examples. If you print out the file's details using `ls -l`, you
    will see a list of different important file attributes we need to learn about
    so as to understand file permissions. A typical `ls -l` output looks like `-lrwxr-xr-x
    olip administrator my-awsome-file.txt.` Every file in the system is associated
    to exactly one username, which is also called the file owner.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习Linux中文件访问控制的概念。我们还将学习和理解如何读取文件权限。最后，我们将学习如何更改文件所有权以及文件权限，并向您展示实际的文件权限示例。如果使用`ls
    -l`打印文件的详细信息，您将看到一系列不同的重要文件属性，我们需要学习以便理解文件权限。典型的`ls -l`输出看起来像`-lrwxr-xr-x olip
    administrator my-awsome-file.txt.` 系统中的每个文件都与一个用户名关联，也称为文件所有者。
- en: Every file is also associated to exactly one group name, which is also called
    the group owner. The file ownership of a file can be changed by the root user
    only. The group ownership can also be changed by the file owner. When a user creates
    a new file or directory, the file's ownership will be set to the user's UID who
    created the file. We already know that a user can belong to multiple groups, but
    one needs to be set as the primary group. This is why every new user that is created
    has a group with the same name as the username. Now, every Linux user who wants
    to access a file can be categorized into one of these groups. The user is the
    file owner if the user ID matches the ID of the file owner whose file we want
    to access. The user is the group owner if one of the groups he is associated with
    matches the group owner of the file he wants to access. If the user is not the
    file or group owner he falls into the other users category. These three permission
    categories are also called permission groups. Finally, all these permission groups,
    the file owner, the group owner, and the others group, have exactly three permission
    types each, read, write, and execute. These permission types manage the actual
    action a user belonging to one of these groups can or cannot do with the file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件还与一个组名关联，也称为组所有者。文件的所有权只能由root用户更改。文件所有权也可以由文件所有者更改。当用户创建新文件或目录时，文件的所有权将设置为创建文件的用户UID。我们已经知道用户可以属于多个组，但需要设置一个作为主要组。这就是为什么每个新创建的用户都有一个与用户名相同的组。现在，每个想要访问文件的Linux用户都可以被归类为这些组中的一个。如果用户ID与要访问的文件的所有者ID匹配，用户就是文件所有者。如果用户与文件想要访问的组所有者匹配，用户就是组所有者。如果用户既不是文件所有者也不是组所有者，他就属于其他用户类别。这三个权限类别也称为权限组。最后，所有这些权限组，文件所有者、组所有者和其他组，每个都有三种权限类型，读、写和执行。这些权限类型管理着属于这些组之一的用户可以或不能对文件执行的实际操作。
- en: Now, since we are working with a lot of different information for every file,
    the user owner, the group owner, the permission categories, and the permission
    types, some Linux commands such as the `ls` command use a very compact form for
    viewing, which use 9-bits to fully map all permissions for all the permission
    groups. This 9-bit information is also called the permission string. If a permission
    is granted a read/write/execute or `rwx` flag is put at a fixed permission in
    the string. If a permission is revoked, a dash symbol can be found at a specific
    position in the string. From left to right in the permission string the first
    three bits are the read/write/execute permissions for the file owner. The next
    three bits are for the group owner, and the last three bits are for all the other
    users. The 9-bit permission string is a very dense notation to fit the screen
    and coming from a time when space and memory were expensive in computer hardware.
    Changes to permission types or 9-bit permission string can be set or removed by
    the root user only. Read, write, and execute permissions are defined differently
    on files and on directories.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们正在处理每个文件的大量不同信息，用户所有者、组所有者、权限类别和权限类型，一些Linux命令（如`ls`命令）使用了一种非常紧凑的形式来查看，使用了9位来完全映射所有权限组的所有权限。这9位信息也称为权限字符串。如果授予了读/写/执行权限，或者`rwx`标志被放置在字符串中的固定位置。如果权限被撤销，可以在字符串的特定位置找到破折号符号。在权限字符串中，从左到右，前三位是文件所有者的读/写/执行权限。接下来的三位是组所有者的，最后的三位是所有其他用户的。9位权限字符串是一种非常紧凑的表示法，以适应屏幕，并来自计算机硬件中空间和内存昂贵的时代。对权限类型或9位权限字符串的更改只能由root用户设置或移除。文件和目录上的读、写和执行权限的定义是不同的。
- en: Let's first discuss what read, write, and execute means in a file context. If
    the `r`, or read, flag is set on a file, the corresponding permission categories,
    file owner, group owner, or other user can open a file and read its content. The
    `w`, or write, flag is to modify or truncate an existing file, but it's a common
    misconception and important fact to know that the write flag does not allow for
    new file creation or deleting of existing files. This is not a property of a file,
    but rather of the parent directory, as we will soon see. The `x`, or execute flag
    allows files to be executed. This is important for running script files or commands
    on the command line.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先讨论文件上下文中的读取、写入和执行的含义。如果文件上设置了`r`或读取标志，则相应的权限类别，文件所有者、组所有者或其他用户可以打开文件并读取其内容。`w`或写入标志用于修改或截断现有文件，但需要知道的一个常见误解和重要事实是，写入标志不允许创建新文件或删除现有文件。这不是文件的属性，而是父目录的属性，我们很快就会看到。`x`或执行标志允许执行文件。这对于在命令行上运行脚本文件或命令非常重要。
- en: In order to execute a file to run it as a script or command, the read flag needs
    to also be set because the shell needs to read the content of a file in order
    to execute its instructions. In a directory context, read, write, and execute
    permissions mean something completely different than working on files, which every
    Linux user must be aware of.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行文件以将其作为脚本或命令运行，需要同时设置读取标志，因为shell需要读取文件的内容以执行其指令。在目录上下文中，读取、写入和执行权限的含义与在文件上工作时完全不同，这是每个Linux用户都必须意识到的。
- en: Let's first start with the `x`, or execute, permissions, as this is the most
    essential permission for folders. `x`, or execute, permissions in a directory
    context means something completely different than in the file context. If an execute
    flag is set on a folder, it means that the corresponding user group or other is
    allowed to enter that directory or path into a directory, for example, using the
    `cd` command. But the `x` flag is not only important for the `cd` command, it's
    also mandatory if you need to rename, delete, or create new files using the write
    flag. The execute flag has to be set as well here. It's also mandatory if you
    need to rename, delete, or create new files using the write flag. As a rule of
    thumb, if you need to set some standard permissions on the folder, never miss
    the execute permission for the permission group you want to work with or otherwise
    you will run into problems, as you always need to change into a directory if you
    want to perform some actions. `r`, or read, is the permission to read the content
    of a directory, for example, using the `ls` command.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先从目录的`x`或执行权限开始，因为这是文件夹最重要的权限。在目录上下文中，`x`或执行权限的含义与文件上下文中完全不同。如果文件夹上设置了执行标志，这意味着相应的用户组或其他用户被允许进入该目录或路径，例如，使用`cd`命令。但`x`标志不仅对`cd`命令很重要，如果您需要使用写入标志重命名、删除或创建新文件，这也是必需的。在这里，执行标志也是必需的。作为一个经验法则，如果您需要在文件夹上设置一些标准权限，永远不要错过所需工作的权限组的执行权限，否则您将遇到问题，因为如果要执行某些操作，您总是需要进入目录。`r`或读取是读取目录内容的权限，例如，使用`ls`命令。
- en: The `w`, or write, flag creates new files or deletes existing files in a directory.
    As we've seen before, deleting or creating new files is not a property of a file
    permission, but always a property of the directory permission the files you want
    to create or delete are in, so the write flag has to be set if you want to be
    able to create or delete files in it. In order to use the write flag for creating,
    deleting, or removing files, we also need to set the execute flag for commands
    such as `touch` or `rm`, because they need access to a directory in order to perform
    the actions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`w`或写入标志在目录中创建新文件或删除现有文件。正如我们之前所看到的，删除或创建新文件不是文件权限的属性，而是始终是文件所在目录权限的属性，因此如果要能够在其中创建或删除文件，则必须设置写入标志。为了使用写入标志创建、删除或移除文件，我们还需要为诸如`touch`或`rm`的命令设置执行标志，因为它们需要访问目录以执行操作。'
- en: Now, each actual user who wants to perform an action, that is, read, write,
    or execute on a file or directory is now being checked by the operating system
    based on whether the attempt access is legal or not. This is a hierarchical process.
    The first check which is being done is whether the user ID of the user who wants
    to work on a file matches the file's user owner. If this is not the case, all
    the user's group IDs get checked if one matches the file's group ownership. If
    no user group matches at all, the other user is assumed and will be used. Now,
    every user in the system matches one of these three permission categories. If
    the right category has been found, the corresponding three permission types, read,
    write, and execute will be checked to see whether they are allowed or not and
    whether they match the user's attempt read, write, or execute action.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个想要执行操作的实际用户，即读取、写入或执行文件或目录的用户，都将由操作系统检查，检查的依据是尝试访问是否合法。这是一个分层过程。首先进行的检查是用户ID是否与文件的用户所有者匹配。如果不匹配，将检查用户的所有组ID是否与文件的组所有权匹配。如果没有用户组匹配，将使用其他用户。现在，系统中的每个用户都匹配这三个权限类别中的一个。如果找到了正确的类别，将检查相应的三种权限类型，即读取、写入和执行，以查看它们是否被允许，以及它们是否与用户的尝试读取、写入或执行操作匹配。
- en: Changing values in the 9-bit permission string is best done using a shortcut
    method based on the octal numbering system counting. Note that there is also another
    notation available which uses short options such as `-`, `+`, `r`, `w`, and `e`,
    which we will not discuss in this section. You can look it up using `man chmod`.
    Using a number between `0` and `7`, which are eight different states, and therefore
    can be called octal notation, we can define every possible combination of read,
    write, and execute for every permission category, user owner, group owner, or
    other users uniquely.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于八进制计数系统的快捷方法来更改9位权限字符串中的值是最好的。请注意，还有另一种可用的表示法，它使用短选项，如“-”、“+”、“r”、“w”和“e”，我们在本节中不讨论。您可以使用“man
    chmod”查找它。使用0到7之间的数字，这是八种不同的状态，因此可以称为八进制表示法，我们可以为每个权限类别（用户所有者、组所有者或其他用户）定义每种可能的读、写和执行组合。
- en: 'The following are the `chmod` octal notations:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`chmod`的八进制表示法：
- en: '`0`: Using `0`, no read, write, or execute permissions are allowed'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：使用`0`，不允许读、写或执行权限'
- en: '`1`: It means execute permission only'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：它表示只有执行权限'
- en: '`2`: It means write permission only'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：它表示只有写权限'
- en: '`4`: It means read permission only'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4`：它表示只有读权限'
- en: '`3`: It means the combination of execute and write permissions'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`：它表示执行和写权限的组合'
- en: '`5`: It means the combination of execute and read comments only'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5`：它表示只有执行和读权限的组合'
- en: '`6`: It means a combination of write permissions and read permissions only'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`6`：它表示只有写权限和读权限的组合'
- en: '`7`: It means full permission or read, write, and execute permissions'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`7`：它表示完全权限或读、写和执行权限'
- en: So we can easily express the permission types of all three permission categories
    using three numbers only. The first digit represents the read, write, and execute
    permissions for the file's user owner. The second digit represents all the file
    permissions for the group owner, and the third digit represents all the read,
    write, and execute permissions available for all the other users in the system.
    So for example, the octal permission `777` means read, write, and execute permissions
    for all the users available in a system. A permission of `775` means read, write,
    and execute permissions for the user owner of a file, read, write, and execute
    permissions for the group owner of a file, and read and execute permissions only
    for all the other users in the system. A permission of `660` means read and write
    permissions for the user owner of a file, read/write permissions for the group
    owner of a file, and no permissions at all for all the other users in the system,
    meaning that they cannot read, write, or execute this file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以只使用三个数字轻松表示所有三个权限类别的权限类型。第一个数字表示文件的用户所有者的读、写和执行权限。第二个数字表示组所有者的所有文件权限，第三个数字表示系统中所有其他用户可用的所有读、写和执行权限。例如，八进制权限`777`表示系统中所有用户的读、写和执行权限。权限`775`表示文件的用户所有者的读、写和执行权限，文件的组所有者的读、写和执行权限，以及系统中所有其他用户的只读和执行权限。权限`660`表示文件的用户所有者的读和写权限，文件的组所有者的读/写权限，以及系统中所有其他用户根本没有权限，这意味着他们无法读取、写入或执行此文件。
- en: 'Since we have created some new users, `Peter` and `Paul` and associated groups
    `project_a` and `project_b` in the previous section, let''s now work and experiment
    with the actual file permissions:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在上一节中创建了一些新用户“Peter”和“Paul”，并分配了“project_a”和“project_b”组，现在让我们来实际工作和实验实际文件权限：
- en: As we are working on permissions on the time in this chapter first login as
    root user.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在本章中正在处理权限，首先以root用户登录。
- en: 'Now, let''s first create a directory where we put in some files to work with:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们首先创建一个目录，在其中放入一些文件以便使用：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then change to this directory:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后切换到这个目录：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s create some files to play with:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一些文件来玩：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's have a look at the file permissions using `ls-l`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`ls-l`查看文件权限。
- en: As we now know, every file has a file owner, which can be seen in the `ls -l`
    output in the third column. Every file also has a group owner in the fourth column.
    The first character in the `ls -l` output is the file type, followed by the 9-bit
    permission string.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道，每个文件都有一个文件所有者，在`ls -l`输出的第三列中可以看到。每个文件的第四列中也有一个组所有者。`ls -l`输出中的第一个字符是文件类型，后跟9位权限字符串。
- en: 'First, let''s learn how to change the file''s user owner. You can use the `chown`
    command to change the user owner of a file. You can use the `chgrp` command to
    change a file''s user group. Let''s use `ls -l` again to see what has been changed:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们学习如何更改文件的用户所有者。您可以使用`chown`命令更改文件的用户所有者。您可以使用`chgrp`命令更改文件的用户组。让我们再次使用`ls
    -l`查看已更改的内容：
- en: '![](img/baf697f8-c90b-434b-ae88-2fc7d42e0850.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/baf697f8-c90b-434b-ae88-2fc7d42e0850.png)'
- en: 'As you see, `file1` and `file3` have changed the user owner, `file4` has a
    new group owner. Instead of using the `chgrp` command, there is an alternate way
    to define group membership of a file, which system admins often use. It has the
    following notation:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，“file1”和“file3”已更改了用户所有者，“file4”有一个新的组所有者。除了使用`chgrp`命令外，还有一种定义文件组成员资格的替代方法，系统管理员经常使用。它具有以下表示法：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This uses a colon to specify the user owner or group owner of a file. For example,
    to change only the group owner of a file use:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用冒号来指定文件的用户所有者或组所有者。例如，要仅更改文件的组所有者，请使用：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Or to change both the username and group use:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 或者同时更改用户名和组使用：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's also create some subfolders as well for testing directory permissions
    later. Put some files in our newly created subfolders as well. Next, let's use
    some very dangerous permissions for the `test` directory so that everyone is able
    to work with the files properly during our tests. This is not meant to be for
    production.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也创建一些子文件夹，以便稍后测试目录权限。还将一些文件放入我们新创建的子文件夹中。接下来，让我们对“test”目录使用一些非常危险的权限，以便在我们的测试期间每个人都能正确地使用文件。这不是为了生产而设计的。
- en: 'As we have learned before, we will use the `chmod` octal notation for changing
    the 9-bit permission string file permissions. Next, let''s create some common
    permissions for our new test files. Also, for showing things, create some unusual
    permissions. Also, change the permissions of our test directories:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前学到的，我们将使用`chmod`八进制表示法来改变9位权限字符串文件权限。接下来，让我们为我们的新测试文件创建一些常见的权限。同时，为了展示一些东西，创建一些不寻常的权限。还要改变我们测试目录的权限：
- en: '![](img/03ed74fc-1212-4fc1-9f4b-f0249bb081ba.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03ed74fc-1212-4fc1-9f4b-f0249bb081ba.png)'
- en: 'Finally, in order to prepare our tests, we also need to change some user ownership
    permissions and group ownership permissions on some of the directories. Now, let''s
    play around with our new files'' and folders'' permissions. `file1` is a file,
    which has full read, write, and execute permissions for anyone. This is a very
    dangerous permission and is never recommended in any scenario because anyone can
    modify this file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了准备我们的测试，我们还需要改变一些目录的用户所有权权限和组所有权权限。现在，让我们玩弄一下我们新文件和文件夹的权限。`file1`是一个文件，对任何人都有完全的读取、写入和执行权限。这是一个非常危险的权限，在任何情况下都不建议使用，因为任何人都可以修改这个文件：
- en: '![](img/125881e6-8deb-4243-847b-ec5c86a4bcc1.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/125881e6-8deb-4243-847b-ec5c86a4bcc1.png)'
- en: As you can see, `peter` and `paul` can modify this file and have full access
    on it. The next `file1`, `file2`, has a permission, has the standard permission
    every file gets upon creation. The file owner can read and write, the group and
    all the other users can only read and execute, but not modify.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`peter`和`paul`可以修改这个文件并对其拥有完全访问权限。接下来的`file1`，`file2`，具有标准权限，这是每个文件创建时都会得到的权限。文件所有者可以读取和写入，组和所有其他用户只能读取和执行，但不能修改。
- en: 'Let''s see what happens if various users try to write to this file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果各种用户尝试写入这个文件会发生什么：
- en: '![](img/af16701b-2ede-47f0-935e-e857fc9139dc.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af16701b-2ede-47f0-935e-e857fc9139dc.png)'
- en: As you can see, only the file owner can write to this file; all the other users
    have no write access. The next file has a permission often used for protecting
    confidential data, such as password files.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，只有文件所有者可以写入这个文件；所有其他用户都没有写入权限。下一个文件具有经常用于保护机密数据的权限，比如密码文件。
- en: '![](img/772a7ffe-bdbc-454b-97f3-a2cabbcd63e7.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/772a7ffe-bdbc-454b-97f3-a2cabbcd63e7.png)'
- en: As you can see, only the file owner can read the file and no one else can perform
    any other action on the file. The file owner is `paul`. If you try to read this
    file using various usernames, you will learn two things. First, despite which
    permission has been set to a file the root user always has full access to the
    file. Second, other than the root user, who has full access to a file anyways,
    in this example only `paul`, who has read access, can read this file, and no one
    else.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，只有文件所有者可以读取文件，其他人无法对文件执行任何其他操作。文件所有者是`paul`。如果你尝试使用各种用户名读取这个文件，你会学到两件事。首先，无论文件设置了哪种权限，root用户始终可以完全访问文件。其次，除了root用户，谁都无法访问这个文件，除了`paul`，他有读取权限，其他人都不行。
- en: 'The next file has the common permission set used. Not only the file owner,
    but also members of the file''s only group, should have full control over the
    file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个文件具有常用的权限设置。不仅文件所有者，而且文件唯一的组的成员应该对文件有完全控制权：
- en: '![](img/1534fe40-c894-44a8-b86b-8173b62ab4aa.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1534fe40-c894-44a8-b86b-8173b62ab4aa.png)'
- en: As you can see, both `olip` and `peter` have write access to the file, `paul`
    doesn't have access to that file. `olip` has write access to the file because
    he is the file owner. `peter` has access to the file because the group owner also
    has access to the file, and Peter is member of the `project_a` group and also
    of the file's group owner group.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`olip`和`peter`都有对文件的写入权限，`paul`无法访问该文件。`olip`有对文件的写入权限，因为他是文件所有者。`peter`有对文件的访问权限，因为组所有者也有对文件的访问权限，而Peter是`project_a`组的成员，也是文件的组所有者组的成员。
- en: 'Now, `file5` has some unusual permissions, which are valid. `file5` is a script
    file, which prints something out:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`file5`有一些不寻常的权限，这是有效的。`file5`是一个脚本文件，可以打印出一些东西：
- en: '![](img/876d52d0-cc77-40b9-a266-c714ca34c026.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/876d52d0-cc77-40b9-a266-c714ca34c026.png)'
- en: As we can see, only the root user has permissions to execute this file. To execute
    a script, we will use the `./` notation, as we will see later in another section.
    In order to make `peter` available to execute a script, we can just add the `project_a`
    group to `file5` because we know that `peter` is a member of this group. But wait,
    why do we get a permission denied error when `peter` is a member of the `project_a`
    group and `project_a` has permission to execute the script? This is because in
    order for the shell to run a script, it also needs access to read the script file's
    content. So, let's change the file's permission to also include the read flag.
    Now, the user `peter` is able to execute the script. For the `root` user, you
    don't need to set the read permissions because the `root` user has all the permissions
    on every file regardless what is said in the permission string.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，只有root用户有权限执行这个文件。为了执行一个脚本，我们将使用`./`表示法，我们将在另一个部分中看到。为了让`peter`能够执行一个脚本，我们只需将`project_a`组添加到`file5`中，因为我们知道`peter`是这个组的成员。但等等，为什么当`peter`是`project_a`组的成员，而`project_a`有权限执行脚本时，我们会收到权限被拒绝的错误？这是因为为了让shell运行一个脚本，它还需要访问读取脚本文件的内容。所以，让我们改变文件的权限，也包括读取标志。现在，用户`peter`能够执行这个脚本了。对于`root`用户，你不需要设置读取权限，因为`root`用户对每个文件都有所有权限，不管权限字符串中说了什么。
- en: 'Finally, a common misconception is that in order to delete a file, you need
    to set the file''s write permission flag correctly for the user who wants to delete
    the file, but this is not true:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个常见的误解是，为了删除一个文件，你需要为想要删除文件的用户正确设置文件的写入权限标志，但这是不正确的：
- en: '![](img/b1c5895b-d3fa-4274-9411-95e7ec5abcd8.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1c5895b-d3fa-4274-9411-95e7ec5abcd8.png)'
- en: If this would be true, why can't Peter delete this file as we assigned full
    permissions to everyone here? The reason for this is because file deletion is
    completely dependent on the write permissions of the directory the file you want
    to delete is in, and never ever on any file permissions at all. So, in this example,
    the file we want to delete is in the `root` directory, which has no write permissions
    for the user Peter at all. So Peter is not able to delete or create any file in
    the `/root` directory.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s discuss directory permissions. Let''s first review our test
    folder''s directory permissions. In order to do so, let''s change to the `test`
    folder''s directory. Let''s first test out permissions on `folderA`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/550e69f2-8b8c-4eac-8d91-5ad3b3163622.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: As you see, `folderA` has read permissions for the file owner only, so Peter
    is the only one who is able to read all the files and subfolders in `folderA`;
    no one else can do this. You can also see because there is no execute flag set
    on a directory; nobody's able to change into this directory.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s have a look at the `folderB`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4588cbc-c587-4585-92eb-22d5f587855a.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: 'As only execute permissions are set on the `project_a` folder, and only execute
    permissions are set for the group owner `project_a` group, only Peter who is part
    of the `project_a` group can `cd` into this directory, but you cannot list files.
    So, it''s always a good idea to always combine the execute flag on a directory
    with the read flag. The same is true for `folderC`. First, let''s try out if someone
    is able to write a file in this directory:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see no one can. If you review folder permissions, this is because
    none of our users has ownership permissions on that file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: So, let's set user ownership to the user `olip`. Still no luck to create a new
    file in the `folderC` with the user `olip`. This is because in order to create
    a new file in a directory, not only the write permission has to be set on the
    directory, but also the execute permission. This is also true if you want to delete
    a file in a directory. Finally, how can we change file and folder permissions
    for a whole subdirectory tree recursively for all entries? In order to change
    all the files and folders included in `folderA` recursively with only one command,
    use the `chmod -R` flag, which stands for recursive, and changes all the files
    and folder entries in a directory given as an argument. You can also use the `-R`
    flag for the change owner command as well. As always, be very careful with the
    recursive flag as you might change files to a permission. When it comes to understanding
    permissions in Linux, there are three things you need to memorize. Each of these
    three concepts have to be used from left to right. First, every file has a set
    of permission states for the user owner, group owner, and all the other users,
    for short, `u`, `g`, and `o`. For each of these categories, there exists three
    possible permission states, read, write, and execute, or `r`, `w`, and `x`. Read,
    write, and execute can be represented by the octal numbers 4, 2, and 1, for `r`,
    `w`, and `x`, respectively. Every combination of read, write, and execute you
    want to allow can be represented by a sum of the read, write, and execute corresponding
    octal number values.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Working with text files
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn all the important tools to print out text file
    content on the command line. We''ll also learn how to view text files using a
    text file viewer. In Linux, there exists two different basic file types, text
    files and binary files. Text files are configuration files, while binary files
    can be image files or compressed data files. The files'' encoding defines whether
    a file should be treated as a text file or binary file. Text files normally use
    UTFR. On Linux, text files normally are encoded using UTF-8 or ASCII. You can
    use the `file` command to detect the file type, like:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To print out a text file''s content, you can use the `cat` command. `cat` stands
    for concatenate, that''s also the reason where the command has its name from.
    So, let''s concatenate some files and put the results in a new file by redirecting
    `stdout`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印出文本文件的内容，可以使用`cat`命令。`cat`代表连接，这也是命令名称的原因。因此，让我们连接一些文件，并将结果放入新文件中，通过重定向`stdout`：
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This line concatenates the three files `passwd`,`group`, and `services` to
    a new file called `concatenated-files` in the `/tmp` directory. Sometimes using
    `cat` to print out the whole file''s content is pure overkill. If we are only
    interested in some lines at the beginning or end of the file, we can use the `head`
    or `tail` commands instead. The beginning of a file is also sometimes called the
    file header, while the end of a file is also called the file footer. To display
    the first `10` lines of our new concatenated file, use:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行将三个文件`passwd`，`group`和`services`连接到`/tmp`目录中的名为`concatenated-files`的新文件中。有时，使用`cat`打印整个文件的内容纯粹是过度的。如果我们只对文件开头或结尾的一些行感兴趣，可以使用`head`或`tail`命令。文件的开头有时也被称为文件头，而文件的结尾也被称为文件尾。要显示我们的新连接文件的前`10`行，请使用：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Alternatively, if you are only interested in the last 10 lines of our new file,
    use instead:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您只对我们的新文件的最后10行感兴趣，请改用：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To change `head` and `tail` default behavior of printing the first 10 lines
    use the `-n` option. Head and tail have other very useful options, use the manual
    pages to learn more. A more important and often used feature is to use the `tail
    follow` option. For example, using the `follow` option with the `root` account,
    the `-f` flag keeps the `tail` command open and tail will listen for new file
    content constantly and outputs it if new text is appended to the `var/log/messages`
    file. If you need a live view on a file which gets written to permanently and
    in real-time, this command needs to be memorized. To close the tail program, use
    *Ctrl* + *C*:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改`head`和`tail`默认的打印前10行的行为，请使用“-n”选项。Head和tail还有其他非常有用的选项，请使用手册页了解更多。一个更重要且经常使用的功能是使用`tail
    follow`选项。例如，使用`root`帐户的`follow`选项，`-f`标志保持`tail`命令打开，并且tail将不断监听新的文件内容，并在`var/log/messages`文件追加新文本时输出。如果您需要对永久写入的文件进行实时查看，这个命令需要被记住。要关闭tail程序，请使用“Ctrl”+“C”：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, to read a file's content the `cat` command can be used for smaller files.
    For bigger files, it's better to use a real text viewer program such as `less`,
    which has some powerful features such as searching, scrolling, and displaying
    line numbers. It's also very useful to learn how to navigate text files using
    the less command, as a lot of Linux commands are using less, also called lesser
    navigation, to browse text content for the page or settings, as we will see later.
    To open a file using less, you can use less and then the filename as an argument.
    You can also directly use `stdout` unless using pipes, which is very useful so
    we can easily navigate and scroll bigger command output, which does not fit the
    screen. Navigating in less is pretty simple and should be memorized because you
    will use it a lot in your Linux career. There is a lot more to learn. Read the
    manual pages for the less command to view all the available options.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要阅读文件的内容，可以使用`cat`命令来处理较小的文件。对于较大的文件，最好使用真正的文本查看程序，例如`less`，它具有一些强大的功能，如搜索、滚动和显示行号。学习如何使用less命令导航文本文件也非常有用，因为许多Linux命令都使用less，也称为较少导航，以浏览页面或设置的文本内容，我们稍后将看到。要使用less打开文件，可以使用less，然后文件名作为参数。除非使用管道，否则也可以直接使用`stdout`，这非常有用，因此我们可以轻松地导航和滚动较长的命令输出，这些输出无法适应屏幕。在less中导航非常简单，应该被记住，因为您将在Linux职业中经常使用它。还有很多要学习的。阅读less命令的手册页以查看所有可用选项。
- en: 'A lot of movement actions can be done in the following ways:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是执行许多移动操作的方法：
- en: To scroll down a line, you can either use the arrow key or the *J* key. Here,
    we will only show you one of these keyboard options per action.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要向下滚动一行，可以使用箭头键或“J”键。在这里，我们将每个操作只展示一个键盘选项。
- en: To quit out of the less command, use the *Q* key.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要退出less命令，请使用“Q”键。
- en: The uppercase *G* scrolls to the end of the file, while small g scrolls to the
    beginning of the file.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大写的*G*滚动到文件末尾，而小写的g滚动到文件开头。
- en: The *down arrow* key scrolls down line by line.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下箭头键可以逐行向下滚动。
- en: The *up arrow key* scrolls up line by line.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下箭头键可以逐行向上滚动。
- en: Press the *Page Down* key to scroll down a page and press the *Page Up* key
    to scroll up a page.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下“Page Down”键向下滚动一页，按下“Page Up”键向上滚动一页。
- en: Press the right arrow key to scroll to the right for longer lines; to scroll
    back to the left, use the left arrow key.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下右箭头键可以向右滚动更长的行；要向左滚动，请使用左箭头键。
- en: Press *Ctrl* + *G* to display file information at the bottom of the page.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下“Ctrl”+“G”以在页面底部显示文件信息。
- en: Press the *Return* key to quit the file information field.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下“Return”键退出文件信息字段。
- en: Type the slash key followed by search term, for example, `HTTP`, and press the
    *Return* key for searching for a keyword `HTTP` in the file using a forward search.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键入斜杠键，然后输入搜索词，例如`HTTP`，然后按下“Return”键进行前向搜索文件中的关键词`HTTP`。
- en: Pressing the *n* key will jump to the next search result. Pressing the capital
    *N* key will jump back to the last form of search result.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下“n”键将跳转到下一个搜索结果。按下大写的“N”键将跳回到上一个搜索结果。
- en: Note that the search is case insensitive if the search pattern is all lowercase;
    otherwise, it's case sensitive. For example, if you search for the word `HTTP`
    all in capital letters, it will only find patterns, which exactly have the HTTP
    in case-sensitive form.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，如果搜索模式全部为小写，则搜索是不区分大小写的；否则，它是区分大小写的。例如，如果搜索的单词`HTTP`全部为大写字母，它只会找到确切以区分大小写形式的HTTP。
- en: Now, jump to the end of the file by pressing capital *G*.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，按下大写的“G”跳转到文件末尾。
- en: A normal search using the forward slash key searches the file for a keyword
    from top to bottom.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用斜杠键进行正常搜索会从文件顶部到底部搜索关键字。
- en: If you want to search for a keyword the other way around, from bottom to top,
    you can use the question mark operator, the question mark key, and then the keyword.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Press the *n* key to jump to the next higher search result in the file. Press
    capital *N* to jump to the last form of search result.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Less -N` starts less in line number mode, which means that every line is prefixed
    by the corresponding line number.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To go to a specific line number, for example, line 100, type the line number
    followed by a `g`, or to go to line number `20`, type `20g`.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To view text files without editing it, you can also use the VIM editor.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To start VIM in read-only mode, type view space and then the file.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will proceed with VIM editor in the next section.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with VIM text editor
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to install the vi improved, for short VIM,
    text editor. We will also learn all the basics of using VIM. The most simple text
    editor one can imagine is, this creates a new file `my-lorum-file` with the content
    `lorem ipsum dollar sit`, or you can create a new text file with the `cat` command
    interactively as follows
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Use the string `EOF` uppercase to stop writing to that file. Now the `echo`
    and `cat` commands are very useful if you need to create text files with just
    a few words or lines of text. If you need to edit bigger text files or want to
    compose your own files, for example, read-me files for your projects, it's better
    to use a real text editor. One of the available text editors in Linux is VIM,
    or vi improved, which is a very powerful text editor available for every Linux
    distribution. It allows mouse-free text editing, and once you get good with VIM,
    you can really start typing or editing text files at the speed of thought. But
    mastering VIM can take months or even years to get really good, because VIM is
    a very complex editor with a lot of different shortcuts and features Therefore,
    we cannot show you everything in this section, but only the fundamentals to get
    you started quickly with VIM.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'VIM is the improved version of, and fully compatible to, vi, the text editor
    for UNIX developed in the ''70s. On a CentOS 7 Minimal installation, VIM is not
    installed by default. So, let''s start by installing the VIM editor `- su root
    -c ''yum install vim -y''`. You can open VIM with the filename to open as an argument,
    or without, and save a filename later. The most fundamental concept of VIM is
    its modes. There are three different modes. An insert mode, a command or normal
    mode, and an ex mode. The following screenshot shows the different modes:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de5683ce-09ec-46f8-89b4-48320eb698f3.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: When you open VIM, you start in normal or command mode. From every mode, you
    can always go back to normal mode by pressing the *Esc* key. This is very useful
    if you don't know in which mode you are currently at. Just press the *Esc* key
    and you are always in normal mode. From there, you can either switch to insertion
    or ex mode. There are several keys available to start the insertion mode. Pressing
    the *i* or *o* key will bring you from command or normal mode into insertion mode,
    where you can start typing text. If you have finished typing text, or you want
    to execute another normal mode command or `ex` command, press the *Esc* key to
    go back to normal mode. From there, if you press the colon key, you go to ex mode.
    From there, pressing the *Return* or *Esc* key brings you back to normal mode.
    The insert mode is for typing or inserting text. In the insert mode, every keystroke
    will be printed on screen in the editor. If you want to navigate the cursor or
    do things such as copying and pasting, deleting of lines, text search, or undo,
    redo, and so on in the file, you need to change to the normal mode. In the normal
    mode, every keystroke is a command. Ex mode is for executing `ex` commands, for
    example, to jump to a certain line in the file, or make a substitution in the
    whole file, or to make a substitution of text in the whole file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will start working with VIM practically. First things first, to exit
    the editor, press the following sequence in normal mode, press `:q!` and then
    press the *Return* key. If you are not in normal mode, for example, you are in
    insertion mode, then you first have to press the *Esc* key, then the `:q!`, and
    then press the *Return* key to exit VI. Now, let's open VIM again with the `/etc/services`
    file.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始实际使用VIM。首先，要退出编辑器，在正常模式下按以下顺序，按`:q!`，然后按*Return*键。如果你不在正常模式下，例如，你在插入模式下，那么你首先要按*Esc*键，然后`：q!`，然后按*Return*键退出VI。现在，让我们用`/etc/services`文件再次打开VIM。
- en: 'Let''s first discuss basic cursor movement commands. Cursor movement commands
    can only be done in normal mode or command mode, which is the default mode when
    you start VIM. If you''re in another mode, such as insertion mode, press the *Esc*
    key to enter the normal mode. Now, to move the cursor, you can use various keyboard
    shortcuts:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论基本的光标移动命令。光标移动命令只能在正常模式或命令模式下执行，这是启动VIM时的默认模式。如果你在其他模式下，比如插入模式，按*Esc*键进入正常模式。现在，要移动光标，你可以使用各种键盘快捷键：
- en: To move the cursor to the right, use the *l* key
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将光标向右移动，使用*l*键
- en: To move the cursor to the left, use the *h* key
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将光标向左移动，使用*h*键
- en: To move the cursor down, use the *j* key
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要向下移动光标，使用*j*键
- en: To move the cursor up, use the *k* key
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要向上移动光标，使用*k*键
- en: You can also use the arrow keys to do exactly the preceding operations
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以使用箭头键来执行前面的操作
- en: To move the cursor to the end of a line, press the *$* key
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将光标移动到行尾，按*$*键
- en: To move the cursor to the beginning of a line, press the *0* key
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将光标移动到行首，按*0*键
- en: To move the cursor forward one word, use the *w* key
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要向前移动光标一个单词，使用*w*键
- en: To move the cursor backwards one word, use the *b* key
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要向后移动光标一个单词，使用*b*键
- en: To jump to the end of the document, use the capital *G* key, which is the same
    key in the less text file viewer for jumping to the end of the document as well
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要跳转到文档末尾，使用大写*G*键，这也是less文本文件查看器中用于跳转到文档末尾的相同键
- en: To jump to the beginning of the document type `gg`
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要跳转到文档开头，输入`gg`
- en: This is also similar to the less command, where you used the small `g` once
    to jump to the beginning of the document
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这也类似于less命令，其中你使用小写`g`一次跳转到文档开头
- en: To jump to a certain line number, type the line number; for example, line 100,
    followed by a capital *G*
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要跳转到特定行号，请输入行号；例如，第100行，然后跟一个大写*G*
- en: Searching for text patterns in the VI editor is basically the same as searching
    for text in the less text viewer
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在VI编辑器中搜索文本模式基本上与在less文本查看器中搜索文本相同
- en: Use /keyword followed by return to start a forward text search
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用/关键字后跟回车键开始向前搜索
- en: Press small *n* to jump to the next search result
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按小写*n*跳转到下一个搜索结果
- en: Press capital *N* to jump to the last former search result
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按大写*N*跳转到上一个搜索结果
- en: To start a backwards search, first go to the end of the document by pressing
    capital *G*, then use the familiar question mark keyword to search for and press
    the *Return* key to start a text search from bottom to top
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要开始向后搜索，首先按大写*G*到文档末尾，然后使用熟悉的问号关键字进行搜索，按*Return*键从底部到顶部开始文本搜索
- en: Press *n* to jump to the next higher search result and press *N* to jump to
    the next lower search result at the bottom of the text document
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按*n*跳转到下一个更高的搜索结果，按*N*跳转到文档底部的下一个更低的搜索结果
- en: Now, again jump to the beginning of the file
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，再次跳转到文件开头
- en: A very useful feature in the normal mode is to set marks at specific lines for
    referencing. For example, first go to the line domain. To set a marker to the
    specific line, type the character `m` followed by another character from a to
    z. For example, type `ma`. This creates a new mark referenced by the character
    a in the line, which starts with the domain. In the current line starting with
    domain, if we go to a different location in that file, for example, scrolling
    down pagewise and then if we now use the tick character followed by the character
    which represents our mark, for example `'a,` we will jump back to the line where
    we set our reference mark `a`. As said before, you can set multiple marks from
    a to z, so let's add another mark. Just go to another line, for example, the saft
    line. Now, we will use `b` for our mark. Let's create a mark, type `mb`. Now if
    you go to a different location in the file, like in the fido line, just type `'b`
    to scroll back to the saft line. Type `'a` to go back to the domain line. Easy
    as that.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常模式中一个非常有用的功能是在特定行设置标记以供引用。例如，首先转到行域。要在特定行设置标记，输入字符`m`，然后再输入从a到z的另一个字符。例如，输入`ma`。这将在以域开头的行中创建一个新的标记，由字符a引用。在以域开头的当前行，如果我们在文件中的其他位置，例如，按页向下滚动，然后现在使用引号字符后跟表示我们标记的字符，例如`'a`，我们将跳转回到我们设置引用标记`a`的行。如前所述，你可以从a到z设置多个标记，所以让我们添加另一个标记。只需转到另一行，例如saft行。现在，我们将使用`b`作为我们的标记。让我们创建一个标记，输入`mb`。现在，如果你转到文件中的其他位置，比如fido行，只需输入`'b`即可滚动回saft行。输入`'a`返回到域行。就是这么简单。
- en: Now that we have learned all there is to know for basic movement commands in
    the normal or command mode, let's now switch over to learn some deletion commands
    in the normal mode. Pressing the *x* key will delete the character under the cursor,
    while staying in normal mode. Pressing the `dd` key twice deletes a line and puts
    the deleted text into the copy buffer. The d key can be combined with other keys
    too for efficient text deletion. Use `dw` to delete the current word under cursor.
    You can even combine the `dw` command with a number, for example to delete the
    next five words type `5dw`. You already know that in order to jump to the end
    of the line, you use *$*, and to jump to the beginning of the line you use *0*.
    If you want to delete from the current cursor position to the end of the line
    use `d$`. On the other hand, if you want to delete from the current cursor position
    to the beginning of the line use `d0`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了在正常或命令模式下的基本移动命令，让我们现在转而学习一些正常模式下的删除命令。按下*x*键将删除光标下的字符，同时保持在正常模式下。连续按两次`dd`键将删除一行并将已删除的文本放入复制缓冲区。d键也可以与其他键组合以实现高效的文本删除。使用`dw`删除光标下的当前单词。您甚至可以将`dw`命令与数字结合使用，例如要删除接下来的五个单词，请键入`5dw`。您已经知道，为了跳转到行尾，您使用*$*，而要跳转到行首，您使用*0*。如果要从当前光标位置删除到行尾，请使用`d$`。另一方面，如果要从当前光标位置删除到行首，请使用`d0`。
- en: Now, let's look at the undo and redo commands of the deleted text. The u key
    undoes the last change. For every undo step you perform, you can also perform
    a corresponding redo step using *Ctrl* + *R*. Now for copying and pasting commands,
    simply copy and paste the complete line type `yyp`. To copy multiple lines, first
    mark all the lines you want to copy. To do this, press *Shift* + *V* to start
    your mark, then press the down or up arrow key to select all the lines you want
    to copy. Now, press the *y* key to copy your text, and then press capital *P*
    to insert your copied text.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看已删除文本的撤消和重做命令。按下u键可以撤消上次的更改。对于每个撤消步骤，您也可以使用*Ctrl* + *R*执行相应的重做步骤。现在，对于复制和粘贴命令，只需复制和粘贴完整的行类型`yyp`。要复制多行，首先标记要复制的所有行。为此，按下*Shift*
    + *V*开始标记，然后按下向上或向下箭头键选择要复制的所有行。现在，按下*y*键复制您的文本，然后按下大写*P*插入您复制的文本。
- en: You can also cut text. In order to cut text lines, first mark your text using
    capital *V*. Now, instead of using the *y* key to yank or copy the text, press
    the capital *C* key to cut out the text. Note that cutting the text will put you
    into insertion mode. To paste the text, you need to go back to normal mode; so,
    press the *Esc* key now. To paste your text somewhere else, use the capital *P*
    key.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以剪切文本。要剪切文本行，首先使用大写*V*标记您的文本。现在，不要使用*y*键来复制文本，而是按下大写*C*键剪切文本。请注意，剪切文本将使您进入插入模式。要粘贴文本，您需要返回到正常模式；因此，现在按下*Esc*键。要在其他地方粘贴文本，请使用大写*P*键。
- en: Now that we have discussed all the basic commands in normal or command mode,
    let's shift to the insert mode. There are several ways to go from normal mode
    to insertion mode. Normally, to enter insert mode, you can use small *i* and small
    *o* and capital *O* keys. Pressing small *o* inserts a new line while entering
    insert mode after the cursor. Pressing capital *O* inserts a new line while entering
    insert mode before the cursor. Pressing *i* takes you to the insert mode right
    after the cursor without inserting a new line.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了正常或命令模式下的所有基本命令，让我们转到插入模式。有几种方法可以从正常模式切换到插入模式。通常，要进入插入模式，您可以使用小写的*i*和*o*以及大写的*O*键。按下小写的*o*在光标后插入新行并进入插入模式。按下大写的*O*在光标前插入新行并进入插入模式。按下*i*会在光标后立即进入插入模式，而不插入新行。
- en: Finally, let's discuss `ex` commands. Let's first make some changes to our file.
    Now, in order to execute `ex` commands, we first need to go to normal mode, pressing
    the *Esc* key from the insertion mode, and then pressing the colon key to start
    typing `ex` commands. For example, to write to a file, type the `w`. This will
    write and save your changes to the file. You can also use `:` to enter `ex` commands
    and then press `wq` to write and quit the VIM editor.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们讨论`ex`命令。让我们首先对文件进行一些更改。现在，为了执行`ex`命令，我们首先需要进入正常模式，从插入模式按下*Esc*键，然后按下冒号键开始输入`ex`命令。例如，要写入文件，请键入`w`。这将把您的更改写入并保存到文件中。您还可以使用`:`输入`ex`命令，然后按`wq`写入并退出VIM编辑器。
- en: Now, let's open VIM again. To leave the editor, press `:q` and press the *Return*
    key. This will leave the editor if you have not made any changes. Now go back
    to the vi editor. Using the `q ex` command and pressing return will only work
    if you haven't made any changes to the file. Let's change the file. Now, if you
    want to leave the editor while you have made some changes to the file, using the
    ex command `q` will inform you that you are about to leave the editor without
    saving your changes. So if you want to quit the editor without saving changes,
    just type the `:q!`. Now, go back to the services file from the terminal. Another
    very useful ex command is to execute commands on the command line while staying
    in the vi editor. This can be done using the `ex` command exclamation mark and
    then the command you want to execute on the command line, for example, `ls`. This
    will switch over to the command line and present you with the result; then if
    you press the return key, you go back to the editor. Another very useful ex command
    is the `sh` command. Typing in `sh` as an `ex` command will switch to a command
    line while VI is still running in the background. Here, you can execute commands
    as you would normally on a command line. If you are done working on the command
    line, you can go back to the VIM editor by typing `exit`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次打开VIM。要离开编辑器，请按`:q`，然后按*Return*键。如果您没有进行任何更改，这将离开编辑器。现在回到vi编辑器。使用`q
    ex`命令并按回车键只有在您没有对文件进行任何更改时才有效。让我们更改文件。现在，如果您想在对文件进行了一些更改的情况下离开编辑器，使用ex命令`q`将通知您即将离开编辑器而不保存更改。因此，如果您想在不保存更改的情况下退出编辑器，只需键入`:q!`。现在，从终端返回到服务文件。另一个非常有用的ex命令是在vi编辑器中执行命令行上的命令。这可以通过使用`ex`命令感叹号然后是您想要在命令行上执行的命令来完成，例如`ls`。这将切换到命令行并呈现结果；然后如果您按回车键，您将返回到编辑器。另一个非常有用的ex命令是`sh`命令。在`ex`命令中键入`sh`将在后台继续运行VI的情况下切换到命令行。在这里，您可以像在命令行上一样执行命令。如果您完成了命令行上的工作，可以通过键入`exit`返回到VIM编辑器。
- en: 'To search and replace a word, VIM offers us a set-like substitution mode:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索和替换单词，VIM为我们提供了一种类似集合的替换模式：
- en: 'If you want to substitute the word `echo` with the word `hello world` in the
    whole file, use the following command:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想要在整个文件中用单词`echo`替换为单词`hello world`，请使用以下命令：
- en: '[PRE22]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To enable line number mode, type `set number`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启用行号模式，请键入`set number`。
- en: To go to a specific line, type the number line in ex mode.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要转到特定行，请在ex模式下键入行号。
- en: To leave number mode, type `set nonumber`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要离开行号模式，请键入`set nonumber`。
- en: To open a different file in VIM, type `e` and then the filename.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在VIM中打开不同的文件，请键入`e`，然后是文件名。
- en: To save a file under a different name, type `w` and then the different filename,
    for example `my-test-file`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将文件另存为不同的名称，请键入`w`，然后是不同的文件名，例如`my-test-file`。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have extensively covered the Linux filesystem, wherein we
    discussed file links, searching for files, file permissions, user and groups and
    the VIM text editor. We also looked into the functionalities of each concept.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们广泛讨论了Linux文件系统，其中包括文件链接、文件搜索、文件权限、用户和用户组以及VIM文本编辑器。我们还深入研究了每个概念的功能。
- en: In the next chapter, we'll cover how to work with the command line.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何使用命令行。

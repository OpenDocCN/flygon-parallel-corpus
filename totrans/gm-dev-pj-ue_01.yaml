- en: 1\. Unreal Engine Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will be an introduction to the Unreal Engine editor. You will get
    to know about the editor's interface; how to add, remove, and manipulate objects
    in a level; how to use Unreal Engine's Blueprint visual scripting language; and
    how to use materials in combination with meshes.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to navigate the Unreal Engine editor,
    create your own Actors, manipulate them inside the level, and create materials.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to *Game Development Projects with Unreal Engine*. If this is the first
    time you're using **Unreal Engine 4** (**UE4**), this book will support you in
    getting started with one of the most in-demand game engines on the market. You
    will discover how to build up your game development skills and how to express
    yourself through the creation of your own video games. If you've already tried
    using UE4, this book will help you further develop your knowledge and skills,
    so you can build games more easily and effectively.
  prefs: []
  type: TYPE_NORMAL
- en: A game engine is a software application that allows you to produce video games
    from the ground up. Their feature sets vary significantly but usually allow you
    to import multimedia files, such as 3D models, images, audio, and video, and manipulate
    those files through the use of programming, where you can use programming languages
    such as C++, Python, and Lua, among others.
  prefs: []
  type: TYPE_NORMAL
- en: Unreal Engine 4 uses two main programming languages, C++ and Blueprint, the
    latter being a visual scripting language that allows you to do most of what C++
    also allows. Although we will be teaching a bit of Blueprint in this book, we
    will be focusing mostly on C++, and hence expect you to have a basic understanding
    of the language, including topics such as *Variables*, *Functions*, *Classes*,
    *Inheritance*, and *Polymorphism*. We will remind you about these topics throughout
    the book where appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of popular video games made with Unreal Engine 4 include *Fortnite*,
    *Final Fantasy VII Remake*, *Borderlands 3*, *Star Wars: Jedi Fallen Order*, *Gears
    5*, and *Sea of Thieves*, among many others. All of these have a very high level
    of visual fidelity, are well-known, and have or had millions of players.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the following link, you''ll be able to see some of the great games made
    with Unreal Engine 4: [https://www.youtube.com/watch?v=lrPc2L0rfN4](https://www.youtube.com/watch?v=lrPc2L0rfN4).
    This showcase will show you the variety of games that Unreal Engine 4 allows you
    to make, both in visual and gameplay style.'
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like to one day make games such as the ones shown in the video, or
    contribute to them in any way, you've taken the first step in that direction.
  prefs: []
  type: TYPE_NORMAL
- en: We'll now begin with this first step, where we will start learning about the
    Unreal Engine editor. We will learn about its interface, how to manipulate objects
    inside a level, how to create our own objects, how to use the Blueprint scripting
    language, and what the main game events do, as well as how to create materials
    for meshes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start this chapter by learning how to create a new Unreal Engine 4 project
    in this first exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Before you continue this chapter, make sure you have installed all the necessary
    software mentioned in the *Preface*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.01: Creating an Unreal Engine 4 Project'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this first exercise, we will learn how to create a new Unreal Engine 4 project.
    UE4 has predefined project templates which allow you to implement a basic setup
    for your project. We'll be using the `Third Person` template project in this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: After installing Unreal Engine version 4.24, launch the editor by clicking the
    `Launch` button of the version icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you've done so, you'll be greeted with the engine's projects window, which
    will show you the existing projects that you can open and work on and also give
    you the option to create a new project. Because we have no projects yet, the `Recent
    Projects` section will be empty. To create a new project, you'll first have to
    choose `Project Category`, which in our case will be `Games`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you've selected that option, click the `Next` button. After that, you'll
    see the project templates window. This window will show all the available project
    templates in the Unreal Engine. When creating a new project, instead of having
    that project start off empty, you have the option to add some assets and code
    out of the box, which you can then modify to your liking. There are several project
    templates available for different types of games, but we'll want to go with the
    `Third Person` project template in this case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select that template and click the `Next` button, which should take you to the
    `Project Settings` window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this window, you''ll be able to choose a few options related to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Blueprint or C++`: Choose whether you want to be able to add C++ classes.
    The default option may be `Blueprint`, but in our case, we''ll want to select
    the `C++` option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Quality`: Choose whether you want your project to have high-quality graphics
    or high performance. You can set this option to `Maximum Quality`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Raytracing`: Choose whether you want Raytracing enabled or disabled. Raytracing
    is a novel graphics rendering technique which allows you to render objects by
    simulating the path of light (using light rays) over a digital environment. Although
    this technique is rather costly in terms of performance, it also provides much
    more realistic graphics, especially when it comes to lighting. You can set it
    to `disabled`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Target Platforms`: Choose the main platforms you''ll want this project to
    run on. Set this option to `Desktop/Console`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Starter Content`: Choose whether you want this project to come with an additional
    set of basic assets. Set this option to `With Starter Content`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Location and Name`: At the bottom of the window, you''ll be able to choose
    the location where your project will be stored on your computer and its name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After you've made sure that all the options are set to their intended values,
    click the `Create Project` button. This will cause your project to be created
    according to the parameters you set and may take a few minutes until it's ready.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's now start learning about Unreal Engine 4 by performing the steps in the
    next section, where we'll learn some of the basics of using the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to Know Unreal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will now be introduced to the Unreal Engine editor, which is a fundamental
    topic to get familiar with Unreal Engine 4.
  prefs: []
  type: TYPE_NORMAL
- en: When your project has finished generating, you should see the Unreal Engine
    editor open automatically. This screen is likely the one that you will see the
    most when working with Unreal Engine, so it is important that you get accustomed
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break down what we see in the editor window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: The Unreal Engine editor divided in its six main windows'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.1: The Unreal Engine editor divided in its six main windows'
  prefs: []
  type: TYPE_NORMAL
- en: '`Content Browser`: The window that occupies the majority of the bottom of the
    screen is the `Content Browser`. This window will let you browse and manipulate
    all the files and assets located inside your project''s folder. As was mentioned
    at the start of the chapter, Unreal Engine will allow you to import several types
    of multimedia files, and `Content Browser` is the window that will allow you to
    browse and edit them in their respective sub-editors. Whenever you create an Unreal
    Engine project, it will always generate a `Content` folder. This folder will be
    the `Content Browser`, meaning you can only browse files inside that folder. You
    can see the directory you''re currently browsing inside `Content Browser` by looking
    at the top of it, which, in our case, is `Content -> ThirdPersonCPP`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you click the icon to the left of the `Filters` button, at the very left
    of `Content Browser`, you will be able to see the directory hierarchy of the `Content`
    folder. This directory view allows you to select, expand, and collapse individual
    directories in the `Content` folder of your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: Content Browser''s directory view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.2: Content Browser''s directory view'
  prefs: []
  type: TYPE_NORMAL
- en: '`Viewport`: At the very center of the screen, you''ll be able to see the `Viewport`
    window. This will show you the content of the current level and will allow you
    to navigate through your level as well as adding, moving, removing, and editing
    objects inside it. It also contains several different parameters regarding visual
    filters, object filters (which objects you can see), and the lighting in your
    level.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`World Outliner`: At the top-right corner of the screen, you''ll see `World
    Outliner`. This will allow you to quickly list and manipulate the objects that
    are at your level. `Viewport` and `World Outliner` work hand in hand in allowing
    you to manage your level, where the former will show you what it looks like and
    the latter will help you manage and organize it. Similar to `Content Browser`,
    `World Outliner` allows you to organize the objects in your level in directories,
    with the difference being that `Content Browser` shows the *assets* in your project
    and `World Outliner` shows you the *objects* in your level.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Details` panel and `World Settings`: At the far right of the screen, below
    `World Outliner`, you''ll be able to see two windows – the `Details` panel and
    the `World Settings` window. The `Details` window allows you to edit the properties
    of an object that you selected in your level. As there are no objects selected
    in the screenshot, it is empty. However, if you select any object in your level
    by *left-clicking* on it, its properties should appear in this window, as shown
    in the following screenshot:![Figure 1.3: The Details tab'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_01_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.3: The Details tab'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `World Settings` window allows you to set the overall settings of your
    level, instead of those of individual objects. Here, you''ll be able to change
    things such as the Kill Z (the height at which you want your objects to be destroyed)
    and the desired lighting settings, among others:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4: The World Settings window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.4: The World Settings window'
  prefs: []
  type: TYPE_NORMAL
- en: '`Toolbar`: At the top of the screen you''ll see the editor `Toolbar`, where
    you''ll be able to save your current level, access the project and editor settings,
    and play your level, among other things.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will only be using some of the buttons from these toolbars, namely, the `Save
    Current`, `Settings`, `Blueprints`, `Build`, and `Play` buttons.
  prefs: []
  type: TYPE_NORMAL
- en: '`Modes`: At the very left of the screen, you''ll see the `Modes` window. It
    will allow you to drag objects to your levels, such as cubes and spheres, light
    sources, and other types of objects designed for a wide variety of purposes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have learned about the main windows of the Unreal Engine editor,
    let's take a look at how to manage those windows.
  prefs: []
  type: TYPE_NORMAL
- en: Editor Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we''ve seen, the Unreal Engine editor is comprised of many windows, all
    of which are resizable, movable, and have a corresponding tab on top of them.
    You can *click and hold* a window''s tab and drag it in order to move it somewhere
    else. You can hide tab labels by *right-clicking* them and selecting the `Hide`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5: How to hide a tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.5: How to hide a tab'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the tab labels have been hidden, you can get them to reappear by clicking
    the *yellow triangle* at the top-left corner of that window, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6: The yellow triangle that allows you to show a window''s tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.6: The yellow triangle that allows you to show a window''s tab'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that you can browse and open all the windows available in the editor,
    including the ones that were just mentioned, by clicking the `Window` button in
    the top-left corner of the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Another very important thing you should know is how to play your level from
    inside the editor (also known as `Toolbar`, you'll see the `Play` button. If you
    click it, you'll start playing the currently open level inside the editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you hit `Play`, you''ll be able to control the player character in the
    level by using the *W*, *A*, *S*, and *D* keys to move the player character, the
    spacebar to jump, and move the `Mouse` to rotate the camera:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7: The level being played inside the editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.7: The level being played inside the editor'
  prefs: []
  type: TYPE_NORMAL
- en: You can then press the *Esc* key (Escape) in order to stop playing the level.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've gotten accustomed to some of the editor's windows, let's take
    a deeper look at the `Viewport` window.
  prefs: []
  type: TYPE_NORMAL
- en: Viewport Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We mentioned in the previous section that the `Viewport` window will allow you
    to visualize your level, as well as manipulating the objects inside it. Because
    this is a very important window for you to use and has a lot of functionality,
    we're going to learn more about it in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start learning about the `Viewport` window, let's quickly get to know
    about `Viewport` window will always show you the contents of the currently selected
    level, which in this case was already made and was generated alongside the `Third
    Person` template project. In this level, you'll be able to see four wall objects,
    one ground object, a set of stairs, and some other elevated objects, as well as
    the player character represented by the UE4 mannequin. You can create multiple
    levels and switch between them by opening them from `Content Browser`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to manipulate and navigate through the currently selected level, you'll
    have to use the `Viewport` window. If you press and hold the *left mouse button*
    inside the window, you'll be able to rotate the camera horizontally by moving
    the mouse *left* and *right*, and move the camera forward and backward by moving
    the mouse *forward* and *backward*. You can achieve similar results by holding
    the *right mouse button*, except the camera will rotate vertically when moving
    the mouse *forward* and *backward*, which allows you to rotate the camera both
    horizontally and vertically.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you can also move around the level by clicking and holding the
    `Viewport` window with the *right mouse button* (the *left mouse button* works
    too, but using it for movement is not as useful due to there not being as much
    freedom when rotating the camera) and using the *W* and *S* keys to move forward
    and backward, the *A* and *D* keys to move sideways, and the *E* and *Q* keys
    to move up and down.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the top-right corner of the `Viewport` window, you will see a
    small camera icon with a number next to it, which will allow you to change the
    speed at which the camera moves in the `Viewport` window.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing you can do in the `Viewport` window is to change its visualization
    settings. You can change the type of visualization in the `Viewport` window by
    clicking the button that currently says `Lit`, which will show you all the options
    available for different lighting and other types of visualization filters.
  prefs: []
  type: TYPE_NORMAL
- en: If you click the `Perspective` button, you'll have the option to switch between
    seeing your level from a perspective view, as well as from an orthographic view,
    the latter of which may help you build your levels faster.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now move on to the topic of manipulating objects, also known as Actors,
    in your level.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating Actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Unreal Engine, all the objects that can be placed in a level are referred
    to as Actors. In a movie, an actor would be a human playing a character, but in
    UE4, every single object you see in your level, including walls, floors, weapons,
    and characters, is an Actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every Actor must have what''s called a `Transform` property, which is a collection
    of three things:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Vector` property signifying the position of that Actor in the level in the
    *X*, *Y,* and *Z* axis. A vector is simply a tuple with three floating point numbers,
    one for the location of the point in each axis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rotator` property signifying the rotation of that Actor along the *X*, *Y,*
    and *Z* axis. A rotator is also a tuple with three floating point numbers, one
    for the angle of rotation in each axis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Vector` property signifying the scale (meaning size) of that Actor in the
    level in the *X*, *Y,* and *Z* axis. This is also a collection of three floating
    point numbers, one for the scale value in each axis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Actors can be moved, rotated, and scaled in a level, which will modify their
    `Transform` property accordingly. In order to do this, select any object in your
    level by *left-clicking* on it. You should see the **Move** tool appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8: The Move tool, which allows you to move an Actor in the level'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.8: The Move tool, which allows you to move an Actor in the level'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Move tool is a three-axis gizmo that allows you to move an object in any
    of the axes simultaneously. The red arrow of the Move tool (pointing to the left
    in the preceding image) represents the *X* axis, the green arrow (pointing to
    the right in the preceding image) represents the *Y* axis, and the blue arrow
    (pointing up in the preceding image) represents the *Z* axis. If you *click and
    hold* either of these arrows and then drag them around the level, you will move
    your Actor along that axis in the level. If you click the handles that connect
    two arrows together, you will move the Actor along both those axes simultaneously,
    and if you click the white sphere at the intersection of all the arrows, you will
    move the Actor freely along all three axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9: An actor being moved on the Z axis using the Move tool'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.9: An actor being moved on the Z axis using the Move tool'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Move tool will allow you to move an Actor around the level, but if you
    want to rotate or scale an Actor, you''ll need to use the Rotate and Scale tools,
    respectively. You can switch between the Move, Rotate, and Scale tools by pressing
    the *W*, *E*, and *R* keys, respectively. Press *E* in order to switch to the
    Rotate tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10: The Rotate tool, which allows you to rotate an Actor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.10: The Rotate tool, which allows you to rotate an Actor'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Rotate tool will, as expected, allow you to rotate an Actor in your level.
    You can *click and hold* any of the arcs in order to rotate the Actor around its
    associated axis. The red arc (upper left in the previous image) will rotate the
    Actor around the *X* axis, the green arc (upper right in the previous image) will
    rotate the Actor around the *Y* axis, and the blue arc (lower center in the previous
    image) will rotate the Actor around the *Z* axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11: A cube before and after being rotated 30 degrees around the
    X axis'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.11: A cube before and after being rotated 30 degrees around the X
    axis'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that an object's rotation around the *X* axis is usually designated
    as **Roll**, its rotation around the *Y* axis is usually designated as **Pitch**,
    and its rotation around the *Z* axis is usually designated as **Yaw**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we have the Scale tool. Press *R* in order to switch to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12: The Scale tool'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.12: The Scale tool'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Scale tool will allow you to increase and decrease the scale (size) of
    an Actor in the *X*, *Y*, and *Z* axes, where the red handle (left in the previous
    image) will scale the Actor on the *X* axis, the green handle (right in the previous
    image) will scale the Actor on the *Y* axis, and the blue handle (upper in the
    previous image) will scale the Actor on the *Z* axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13: A character Actor before and after being scaled on all three
    axes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.13: A character Actor before and after being scaled on all three axes'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also toggle between the Move, Rotate, and Scale tools by clicking the
    following icons at the top of the `Viewport` window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.14: The Move, Rotate, and Scale tool icons'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.14: The Move, Rotate, and Scale tool icons'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you can change the increments with which you move, rotate, and
    scale your objects through the grid snapping options to the right of the Move,
    Rotate, and Scale tool icons. By pressing the buttons currently in orange, you''ll
    be able to disable snapping altogether, and by pressing the buttons showing the
    current snapping increments, you''ll be able to change those increments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.15: The grid snapping icons for moving, rotating, and scaling'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.15: The grid snapping icons for moving, rotating, and scaling'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to manipulate Actors already present in your level, let's
    learn how to add and remove Actors to and from our level in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.02: Adding and Removing Actors'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be adding and removing Actors from our level.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to adding Actors to your level, there are two main ways in which
    you can do so: by dragging assets from `Content Browser`, or by dragging the default
    assets from the `Modes` window''s Place Mode.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go to the `ThirdPersonCPP -> Blueprints` directory inside `Content Browser`,
    you will see the `ThirdPersonCharacter` Actor. If you drag that asset to your
    level using the *left mouse button*, you will be able to add an instance of that
    Actor to it, and it will be placed wherever you let go of the *left mouse button*:![Figure
    1.16: Dragging an instance of the ThirdPersonCharacter Actor to our level'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_01_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.16: Dragging an instance of the ThirdPersonCharacter Actor to our
    level'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can similarly drag an Actor from the `Modes` window to your level as well:![Figure
    1.17: Dragging a Cylinder Actor to our level'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_01_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.17: Dragging a Cylinder Actor to our level'
  prefs: []
  type: TYPE_NORMAL
- en: In order to delete an Actor, you can simply select the Actor and press the *Delete*
    key. You can also *right-click* on an Actor to take a look at the many other options
    available to you regarding that Actor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we won''t be covering this topic in this book, one of the ways in
    which developers can populate their levels with simple boxes and geometry, for
    prototyping purposes, is BSP Brushes. These can be quickly molded into your desired
    shape as you build your levels. To find more information on BSP Brushes, go to
    this page: [https://docs.unrealengine.com/en-US/Engine/Actors/Brushes](https://docs.unrealengine.com/en-US/Engine/Actors/Brushes).'
  prefs: []
  type: TYPE_NORMAL
- en: And with this, we conclude this exercise and have learned how to add and remove
    Actors to and from our level.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to navigate the `Viewport` window, let's learn about Blueprint
    Actors.
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint Actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In UE4, the word Blueprint can be used to refer to two different things: UE4''s
    visual scripting language or a specific type of asset, also referred to as a Blueprint
    class or Blueprint asset.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''ve mentioned before, an Actor is an object that can be placed in a level.
    This object can either be an instance of a C++ class or an instance of a Blueprint
    class, both of which must inherit from the Actor class (either directly or indirectly).
    So, what is the difference between a C++ class and a Blueprint class, you may
    ask? There are a few:'
  prefs: []
  type: TYPE_NORMAL
- en: If you add programming logic to your C++ class, you'll have access to more advanced
    engine functionality than you would if you were to create a Blueprint class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a Blueprint class, you can easily view and edit visual components of that
    class, such as a 3D mesh or a Trigger Box Collision, as well as modifying properties
    defined in the C++ class that is exposed to the editor, which makes managing those
    properties much easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a Blueprint class, you can easily reference other assets in your project,
    whereas in C++, you can also do so but less simply and less flexibly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming logic that runs on Blueprint visual scripting is slower in terms
    of performance than that of a C++ class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's simple to have more than one person work on a C++ class simultaneously
    without conflicts in a source version platform, whereas with a Blueprint class,
    which is interpreted as a binary file instead of a text file, this will cause
    conflicts in your source version platform if two different people edit the same
    Blueprint class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In case you don't know what a source version platform is, this is how several
    developers can work on the same project and have it updated with the work done
    by other developers. In these platforms, different people can usually edit the
    same file simultaneously, as long as they edit different parts of that file, and
    still receive updates that other programmers did without them affecting your work
    on that same file. One of the most popular source version platforms is GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that Blueprint classes can inherit either from a C++ class or from
    another Blueprint class.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, before we move on to creating our first Blueprint Class, another important
    thing you should know is that you can write programming logic in a C++ class and
    then create a Blueprint class that inherits from that class, but can also access
    its properties and methods if you specify that in the C++ class. You can have
    a Blueprint class edit properties defined in the C++ class as well as calling
    and overriding functions, using the Blueprint scripting language. We will be doing
    some of these things in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know a bit more about Blueprint classes, let's create our own in
    this next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.03: Creating Blueprint Actors'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this short exercise, we will learn how to create a new Blueprint Actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `ThirdPersonCPP -> Blueprints` directory inside `Content Browser`
    and *right-click* inside it. The following window should pop up:![Figure 1.18:
    The options window that appears when you right-click inside content browser'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_01_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.18: The options window that appears when you right-click inside content
    browser'
  prefs: []
  type: TYPE_NORMAL
- en: This options menu contains the types of assets that you can create in UE4 (Blueprints
    are simply a type of asset, along with other types of assets, such as `Level`,
    `Material`, and `Sound`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the `Blueprint Class` icon to create a new Blueprint class. When you
    do, you will be given the option to choose the C++ or Blueprint class that you
    want to inherit from:![Figure 1.19: The Pick Parent Class window that pops up
    when you'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: create a new Blueprint class
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.19: The Pick Parent Class window that pops up when you create a new
    Blueprint class'
  prefs: []
  type: TYPE_NORMAL
- en: Select the first class from this window, the `Actor` class. After this, you
    will automatically select the text of the new Blueprint class to easily name it
    what you want. Name this Blueprint class `TestActor` and press the `Enter` key
    to accept this name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After following these steps, you will have created your Blueprint class and
    so have completed this exercise. After you've created this asset, double-click
    on it with the *left mouse button* to open the Blueprint editor.
  prefs: []
  type: TYPE_NORMAL
- en: The Blueprint Editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Blueprint editor is a sub-editor within the Unreal Engine editor specifically
    for Blueprint classes. Here, you'll be able to edit the properties and logic for
    your Blueprint classes, or those of their parent class, as well as their visual
    appearance.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you open an Actor Blueprint class, you should see the Blueprint editor.
    This is the window that will allow you to edit your Blueprint classes in UE4\.
    Let''s learn about the windows that you''re currently seeing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.20: The Blueprint editor window is broken down into five parts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.20: The Blueprint editor window is broken down into five parts'
  prefs: []
  type: TYPE_NORMAL
- en: '`Viewport`: Front and center in the editor you have the `Viewport` window.
    This window, similar to the `Level Viewport` window that we already learned about,
    will allow you to visualize your Actor and edit its components. Every actor can
    have several Actor Components, some of which have a visual representation, such
    as Mesh Components and Collision Components. We''ll be talking about Actor Components
    in more depth in later chapters.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Technically, this center window contains three tabs, only one of which is the
    `Viewport` window, but we'll be talking about the other important tab, the `Event
    Graph` after we tackle this editor's interface. The third tab is the `Construction
    Script` window, which we will not be covering in this book.
  prefs: []
  type: TYPE_NORMAL
- en: '`Components`: At the top left of the editor, you have the `Components` window.
    As mentioned in the previous description, Actors can have several Actor Components,
    and this window is the one that will allow you to add and remove those Actor Components
    in your Blueprint class, as well as to access Actor Components defined in the
    C++ classes it inherits from.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`My Blueprint`: At the bottom left of the editor, you have the `My Blueprint`
    window. This will allow you to browse, add, and remove variables and functions
    defined in both this Blueprint class and the C++ class it inherits from. Keep
    in mind that Blueprints have a special kind of function, called an `BeginPlay`,
    `ActorBeginOverlap`, and `Tick`. We''ll be talking about these in a few paragraphs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Details`: At the right of the editor, you have the `Details` window. Similar
    to the editor''s `Details` window, this window will show you the properties of
    the currently selected Actor Component, function, variable, event, or any other
    individual element of this Blueprint class. If you currently have no elements
    selected, this window will be empty.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Toolbar`: At the top center of the editor you have the `Toolbar` window. This
    window will allow you to compile the code you wrote in this Blueprint class, save
    it, locate it in `Content Browser`, and access this class''s settings, among other things.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can see the parent class of a Blueprint class by looking at the top-right
    corner of the Blueprint editor. If you click the name of the parent class, you'll
    be taken to either the corresponding Blueprint class, through the Unreal Engine
    editor, or the C++ class, through Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you can change a Blueprint class's parent class by clicking on
    the `File` tab at the top left of the Blueprint editor and selecting the `Reparent
    Blueprint` option, which will allow you to specify the new parent class of this
    Blueprint class.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned about the basics of the Blueprint editor, let's take
    a look at its Event Graph.
  prefs: []
  type: TYPE_NORMAL
- en: Event Graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Event Graph` window is where you'll be writing all of your Blueprint visual
    scripting code, creating your variables and functions, and accessing other variables
    and functions declared in this class's parent class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you select the `Event Graph` tab, which you should be able to see to the
    right of the `Viewport` tab, you will be shown the `Event Graph` window instead
    of the `Viewport` window. On clicking the `Event Graph` tab, you will have the
    following window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.21: The Event Graph window, showing three disabled events'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.21: The Event Graph window, showing three disabled events'
  prefs: []
  type: TYPE_NORMAL
- en: You can navigate the `Event Graph` by holding the *right mouse button* and dragging
    inside the graph, you can zoom in and out by scrolling the *mouse wheel*, and
    you can select nodes from the graph by either clicking with the *left mouse button*
    or by pressing and holding to select an area of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: You can also *right-click* inside the `Event Graph` window to access the Blueprint's
    Actions menu, which allows you to access the actions you can do in the `Event
    Graph`, including getting and setting variables, calling functions or events,
    and many others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way scripting works in Blueprint is by connecting nodes using pins. There
    are several types of nodes, such as variables, functions, and events. You can
    connect these nodes through pins, of which there are two types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Execution pins**: These will dictate the order in which the nodes will be
    executed. If you want node 1 to be executed and then node 2 to be executed, you
    link the output execution pin of node 1 to the input execution pin of node 2,
    as shown in the following screenshot:![Figure 1.22: The output execution pin of
    the Event OnReset node being connected'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: to the input execution pin of the setter node for MyVar
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.22: The output execution pin of the Event OnReset node being connected
    to the input execution pin of the setter node for MyVar'
  prefs: []
  type: TYPE_NORMAL
- en: '**Variable pins**: These work as parameters (also known as input pins), at
    the left of the node, and return values (also known as output pins), at the right
    side of the node, representing a value of a certain type (integer, float, Boolean,
    and others):![Figure 1.23: The Get Scalar Parameter Value function call node,
    which has two input variable pins and one output variable pin'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_01_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.23: The Get Scalar Parameter Value function call node, which has two
    input variable pins and one output variable pin'
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand this better through the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.04: Creating Blueprint Variables'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will see how to create Blueprint variables by creating
    a new variable of the `Boolean` type.
  prefs: []
  type: TYPE_NORMAL
- en: In Blueprint, variables work similarly to the ones you would use in C++. You
    can create them, get their value, and set them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new Blueprint variable, head to the `My Blueprint` window and click
    the `+ Variable` button:![Figure 1.24: The + Variable button being highlighted
    in the My Blueprint window, which allows you to create a new Blueprint variable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_01_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.24: The + Variable button being highlighted in the My Blueprint window,
    which allows you to create a new Blueprint variable'
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you''ll automatically be allowed to name your new variable. Name
    this new variable `MyVar`:![Figure 1.25: Naming the new variable MyVar'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_01_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.25: Naming the new variable MyVar'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile your Blueprint by clicking the `Compile` button on the left side of
    the `Toolbar` window. If you now take a look at the `Details` window, you should
    see the following:![Figure 1.26: The MyVar variable settings in the Details window'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_01_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.26: The MyVar variable settings in the Details window'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you''ll be able to edit all the settings related to this variable, the
    most important ones being `Variable Name`, `Variable Type`, and its `Default Value`
    at the end of the settings. Boolean variables can have their value changed by
    clicking the gray box to their right:![Figure 1.27: The variable types available
    from the Variable Type drop-down menu'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_01_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.27: The variable types available from the Variable Type drop-down
    menu'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also drag a getter or setter for a variable inside the `My Blueprint`
    tab into the `Event Graph` window:![Figure 1.28: Dragging the MyVar into the Event
    Graph window and choosing'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: whether to add a getter or setter
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.28: Dragging the MyVar into the Event Graph window and choosing whether
    to add a getter or setter'
  prefs: []
  type: TYPE_NORMAL
- en: Getters are nodes that contain the current value of a variable while setters
    are nodes that allow you to change the value of a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow a variable to be editable in each of the instances of this Blueprint
    class, you can click the eye icon to the right of that variable inside the `My
    Blueprint` window:![Figure 1.29: Clicking the eye icon to expose a variable and
    allow it to be instance-editable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_01_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.29: Clicking the eye icon to expose a variable and allow it to be
    instance-editable'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then drag an instance of this class to your level, select that instance,
    and see the option to change that variable''s value in the `Details` window of
    the editor:![Figure 1.30: The exposed MyVar variable that can be edited through
    the'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Details panel of that object
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.30: The exposed MyVar variable that can be edited through the Details
    panel of that object'
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we conclude this exercise and now know how to create our own
    Blueprint variables. Let's now take a look at how to create Blueprint Functions
    in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.05: Creating Blueprint Functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create our first Blueprint Function. In Blueprint,
    functions and events are relatively similar, the only difference being that an
    event will only have an output pin, usually because it gets called from outside
    of the Blueprint class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.31: An event (left), a pure function call that doesn''t need execution
    pins (middle), and a normal function call (right)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.31: An event (left), a pure function call that doesn''t need execution
    pins (middle), and a normal function call (right)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the `+ Function` button inside the `My Blueprint` window:![Figure 1.32:
    The + Function button being hovered over, which will create a new function'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_01_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.32: The + Function button being hovered over, which will create a
    new function'
  prefs: []
  type: TYPE_NORMAL
- en: Name the new function `MyFunc`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compile your Blueprint by clicking the `Compile` button in the `Toolbar` window:![Figure
    1.33: The Compile button'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_01_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.33: The Compile button'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you now take a look at the `Details` window, you should see the following:![Figure
    1.34: The Details panel after selecting the MyFunc function and adding'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: an input and output pin
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.34: The Details panel after selecting the MyFunc function and adding
    an input and output pin'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you'll be able to edit all the settings related to this function, the
    most important ones being `Inputs` and `Outputs` at the end of the settings. These
    will allow you to specify the variables that this function must receive and will return.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, you can edit what this function does by *clicking* it from the `My
    Blueprint` window. This will open a new tab in the center window that will allow
    you to specify what this function will do. In this case, this function will simply
    return `false` every time it is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.35: The contents of the MyFunc function, receiving a Boolean parameter,'
  prefs: []
  type: TYPE_NORMAL
- en: and returning a Boolean type
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.35: The contents of the MyFunc function, receiving a Boolean parameter,
    and returning a Boolean type'
  prefs: []
  type: TYPE_NORMAL
- en: To save the modifications we made to this Blueprint class, click the `Save`
    button next to the `Compile` button on the toolbar. Alternatively, you can have
    it so that the Blueprint automatically saves every time you compile it successfully
    by selecting that option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After following these steps, you now know how to create your own Blueprint Functions.
    Let's now take a look at a Blueprint node we'll be making use of later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Float Multiplication Node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Blueprint contains many more nodes that are not related to variables or functions.
    One such example is arithmetic nodes (that is adding, subtracting, multiplying,
    and so on.). If you search for `float * float` on the Blueprint Actions menu,
    you''ll find the *Float Multiplication* node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.36: The Float Multiplication node'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_36.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.36: The Float Multiplication node'
  prefs: []
  type: TYPE_NORMAL
- en: This node allows you to input two or more float parameters (you can add more
    by clicking the `+` icon to the right of the `Add pin` text) and output the result
    of the multiplication of all of them. We will be using this node later, in this
    chapter's activity.
  prefs: []
  type: TYPE_NORMAL
- en: BeginPlay and Tick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now take a look at two of the most important events in UE4: `BeginPlay`
    and `Tick`.'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, events will usually be called from outside the Blueprint
    class. In the case of the `BeginPlay` event, this event gets called either when
    an instance of this Blueprint class is placed in the level and the level starts
    being played, or when an instance of this Blueprint class is spawned dynamically
    while the game is being played. You can think of the `BeginPlay` event as the
    first event that will be called on an instance of this Blueprint, which you can
    use for initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other important event to know about in UE4 is the `Tick` event. As you
    may know, games run at a certain frame rate, the most frequent being either 30
    FPS (frames per second) or 60 FPS: this means that the game will render an updated
    image of the game 30 or 60 times every second. The `Tick` event will get called
    every time the game does this, which means that if the game is running at 30 FPS,
    the `Tick` event will get called 30 times every second.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to your Blueprint class''s `Event Graph` window and delete the three grayed-out
    events by selecting all of them and clicking the `Delete` key, which should cause
    the `Event Graph` window to become empty. After that, *right-click* inside the
    `Event Graph` window, type in `BeginPlay`, and select the `Event BeginPlay` node
    by either clicking the `Enter` key or by clicking on that option in the Blueprint
    Actions menu. This should cause that event to be added to the `Event Graph` window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.37: The BeginPlay event being added to the Event Graph window through
    the Blueprint Actions menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_37.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.37: The BeginPlay event being added to the Event Graph window through
    the Blueprint Actions menu'
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* inside the `Event Graph` window, type in `Tick`, and select the
    `Event Tick` node. This should cause that event to be added to the `Event Graph`
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.38: The Tick event'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_38.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.38: The Tick event'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the `BeginPlay` event, the `Tick` event will be called with a parameter,
    `DeltaTime`. This parameter is a float that indicates the amount of time that
    passed since the last frame was rendered. If your game is running at 30 FPS, this
    means that the interval between each of the frames being rendered (the delta time)
    is going to be, on average, 1/30 seconds, which is around 0.033 seconds (33.33
    milliseconds). If frame 1 is rendered and then frame 2 is rendered 0.2 seconds
    after that, then frame 2's delta time will be 0.2 seconds. If frame 3 gets rendered
    0.1 seconds after frame 2, frame 3's delta time will be 0.1 seconds, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'But why is the `DeltaTime` parameter so important? Let''s take a look at the
    following scenario: you have a Blueprint class that increases its position on
    the *Z* axis by 1 unit every time a frame is rendered using the `Tick` event.
    However, you are faced with a problem: there''s the possibility that players will
    run your game at different frame rates, such as 30 FPS and 60 FPS. The player
    who''s running the game at 60 FPS will cause the `Tick` event to be called twice
    as much as the player who''s running the game at 30 FPS, and the Blueprint class
    will end up moving twice as fast because of that. This is where the delta time
    comes into play: because the game that''s running at 60 FPS will have the `Tick`
    event called with a lower delta time value (the interval between the frames being
    rendered is much smaller), you can use that value to change the position on the
    *Z* axis. Although the `Tick` event is being called twice as much on the game
    running at 60 FPS, its delta time is half the value, so it all balances out. This
    will cause two players playing the game with different frame rates to have the
    same result.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you want a Blueprint that is using the delta time to move, you can make it
    move faster or slower by multiplying the delta time by the number of units you
    want it to move per second (for example, if you want a Blueprint to move 3 units
    per second on the *Z* axis, you can tell it to move `3 * DeltaTime` units every
    frame).
  prefs: []
  type: TYPE_NORMAL
- en: Let's now try another exercise, which will consist of working with Blueprint
    nodes and pins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.06: Offsetting the TestActor Class on the Z Axis'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you'll be using the `BeginPlay` event to offset (move) the
    `TestActor` on the *Z* axis when the game starts being played.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `TestActor` Blueprint class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `Blueprint Actions` menu, add the `Event BeginPlay` node to the graph,
    if it's not already there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `AddActorWorldOffset` function and connect the `BeginPlay` event''s
    output execution pin to this function''s input execution pin. This function is
    responsible for moving an Actor in the intended axes (*X*, *Y*, and *Z*) and it
    receives the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Target`: The Actor that this function should be called on, which will be the
    Actor calling this function. The default behavior is to call this function on
    the Actor calling this function, which is exactly what we want and is shown using
    the `self` property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeltaLocation`: The amount that we want to offset this Actor by in each of
    the three axes: X, Y, and Z.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We won''t be getting into the other two parameters, `Sweep` and `Teleport`,
    so you can leave them as is. They are both Boolean types and should be left as `false`:![Figure
    1.39: The BeginPlay event calling the AddActorWorldOffset function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '](img/B16183_01_39.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.39: The BeginPlay event calling the AddActorWorldOffset function'
  prefs: []
  type: TYPE_NORMAL
- en: 'Split the `Delta Location` input pin, which will cause this `Vector` property
    to be split into three float properties. You can do this to any variable type
    that is comprised of one or more subtypes (you wouldn''t be able to do this to
    the float type because it''s not comprised of any variable subtypes) by *right-clicking*
    on them and selecting `Split Struct Pin`:![Figure 1.40: The Delta Location parameter
    being split from a vector into three floats'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_01_40.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.40: The Delta Location parameter being split from a vector into three
    floats'
  prefs: []
  type: TYPE_NORMAL
- en: Set the `Z` property of `Delta Location` to `100` units by clicking with the
    *left mouse button*, typing that number, and then pressing the *Enter* key. This
    will cause our `TestActor` to move up on the *Z* axis by `100` units when the
    game starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a cube shape to your `TestActor`, using the `Components` window, so that
    we can see our Actor. You can do this by clicking the `+ Add Component` button,
    typing `Cube`, and then selecting the first option under the `Basic Shapes` section:![Figure
    1.41: Adding a cube shape'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_01_41.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.41: Adding a cube shape'
  prefs: []
  type: TYPE_NORMAL
- en: Compile and save your Blueprint class by clicking the `Compile` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go back to the level''s `Viewport` window and place an instance of your `TestActor`
    Blueprint class inside the level, if you haven''t done so already:![Figure 1.42:
    Adding an instance of TestActor to the level'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_01_42.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.42: Adding an instance of TestActor to the level'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you play the level, you should notice that the `TestActor` we added to
    the level is in a more elevated position:![Figure 1.43: The TestActor increasing
    its position on the Z axis when the game starts'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_01_43.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.43: The TestActor increasing its position on the Z axis when the game
    starts'
  prefs: []
  type: TYPE_NORMAL
- en: After making these modifications, save the changes made to our level by either
    pressing *Ctrl + S* or by clicking the `Save Current` button on the editor `Toolbar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, you've learned how to create your first Actor Blueprint class
    with your own Blueprint scripting logic.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the `TestActor` blueprint asset and the `Map` asset with the final result
    of this exercise can be found here: [https://packt.live/3lfYOa9](https://packt.live/3lfYOa9).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've done this, let's learn a bit more about the `ThirdPersonCharacter`
    Blueprint class.
  prefs: []
  type: TYPE_NORMAL
- en: ThirdPersonCharacter Blueprint Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at the `ThirdPersonCharacter` Blueprint class, which is the
    Blueprint representing the character that the player controls, and take a look
    at the Actor Components that it contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `ThirdPersonCPP -> Blueprints` directory inside `Content Browser`
    and open the `ThirdPersonCharacter` asset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.44: The ThirdPersonCharacter Blueprint class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_44.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.44: The ThirdPersonCharacter Blueprint class'
  prefs: []
  type: TYPE_NORMAL
- en: In a previous section, where we introduced the `Components` window inside the
    Blueprint editor, we mentioned **Actor Components**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actor Components are entities that must live inside an Actor and allow you
    to spread the logic of your Actor into several different Actor Components. In
    this Blueprint, we can see that there are four visually represented Actor Components:'
  prefs: []
  type: TYPE_NORMAL
- en: A Skeletal Mesh Component, which shows the UE4 mannequin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Camera Component, which shows where the player will be able to see the game
    from
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Arrow Component, which allows us to see where the character is facing (this
    is mainly used for development purposes, not while the game is being played)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Capsule Component, which specifies the collision range of this character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you look at the `Components` window, you'll see a few more Actor Components
    than the ones we see in the `Viewport` window. This is because some Actor Components
    don't have a visual representation and are purely made up of C++ or Blueprint
    code. We'll be going into more depth on Actor Components in the next chapter and
    *Chapter 9*, *Audio-Visual Elements*.
  prefs: []
  type: TYPE_NORMAL
- en: If you take a look at this Blueprint class's `Event Graph` window, you'll see
    that it's essentially empty, like the one we saw with our `TestActor` Blueprint
    class, despite it having a bit of logic associated with it. That is because that
    logic is defined in the C++ class and not in this Blueprint class. We'll be taking
    a look at how to do this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In order to explain this Blueprint class's Skeletal Mesh Component, we should
    first talk about meshes and materials.
  prefs: []
  type: TYPE_NORMAL
- en: Meshes and Materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a computer to visually represent a 3D object, it needs two things: a 3D
    mesh and a material.'
  prefs: []
  type: TYPE_NORMAL
- en: Meshes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '3D meshes allow you to specify the size and shape of an object, like this mesh
    representing a monkey''s head:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.45: A 3D mesh of a monkey''s head'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_45.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.45: A 3D mesh of a monkey''s head'
  prefs: []
  type: TYPE_NORMAL
- en: Meshes are comprised of several vertices, edges, and faces. Vertices are simply
    a 3D coordinate with an *X*, *Y,* and *Z* position; an edge is a connection (that
    is, a line) between two vertices; and a face is a connection of three or more
    edges. You can see in the previous figure the individual vertices, edges, and
    faces of the mesh, where each face is colored between white and black, depending
    on how much light is reflecting off the face. Nowadays, video games can render
    meshes with thousands of vertices in such a way that you can't tell the individual
    vertices apart because there are so many of them so close together.
  prefs: []
  type: TYPE_NORMAL
- en: Materials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Materials, on the other hand, allow you to specify how a mesh is going to be
    represented. They allow you to specify a mesh's color, draw a texture on its surface,
    or even manipulate its individual vertices.
  prefs: []
  type: TYPE_NORMAL
- en: Creating meshes is something that, as of the time of writing this book, is not
    properly supported inside UE4 and should be done in another piece of software,
    such as Blender or Autodesk Maya, so we won't be going into this in great detail
    here. We will, however, learn how to create materials for existing meshes.
  prefs: []
  type: TYPE_NORMAL
- en: In UE4, you can add meshes through Mesh Components, which inherit from the Actor
    Component class. There are several types of Mesh Components, but the two most
    important ones are Static Mesh Components, for meshes that don't have animations
    (for example, cubes, static level geometry), and Skeletal Mesh Components, for
    meshes that have animations (for example, character meshes that play movement
    animations). As we saw earlier, the `ThirdPersonCharacter` Blueprint class contains
    a Skeletal Mesh Component because it's used to represent a character mesh that
    plays movement animations. In the next chapter, we'll be learning how to import
    assets such as meshes into our UE4 project.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at materials in UE4 in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating Materials in UE4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll be taking a look at how materials work in UE4\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to your `Level Viewport` window and select this `Cube` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.46: The Cube object, next to the text saying Third Person on the
    floor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_46.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.46: The Cube object, next to the text saying Third Person on the floor'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the `Details` window, where you''ll be able to see both the
    mesh and material associated with this object''s `Static Mesh` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.47: The Static Mesh and Materials (Element 0) properties of the
    Cube'
  prefs: []
  type: TYPE_NORMAL
- en: object's Static Mesh component
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_47.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.47: The Static Mesh and Materials (Element 0) properties of the Cube
    object''s Static Mesh component'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that meshes can have more than one material, but must have at least
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *looking glass* icon next to the `Material` property to be taken
    to that material''s location in `Content Browser`. This icon works with any reference
    to any asset inside the editor, so you can do the same thing with the asset referenced
    as the cube object''s `Static Mesh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.48: The looking glass icon (left), which takes you to that'
  prefs: []
  type: TYPE_NORMAL
- en: asset's location in Content Browser (right)
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_48.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.48: The looking glass icon (left), which takes you to that asset''s
    location in Content Browser (right)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Double-click* that asset with the left mouse button to open that asset in
    the `Material` editor. Let''s break down the windows present in `Material editor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.49: The Material editor window broken down into five parts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_49.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.49: The Material editor window broken down into five parts'
  prefs: []
  type: TYPE_NORMAL
- en: '`Graph`: Front and center in the editor, you have the `Graph` window. Similar
    to the Blueprint editor''s `Event Graph` window, the `Material` editor''s graph
    is also node-based, where you''ll also find nodes connected by pins, although
    here you won''t find execution pins, only input and output pins.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Palette`: At the right edge of the screen, you''ll see the `Palette` window,
    where you''ll be able to search all the nodes that you can add to the `Graph`
    window. You can also do this the same way as in the Blueprint editor''s `Event
    Graph` window by *right-clicking* inside the `Graph` window and typing the node
    you wish to add.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Viewport`: At the top-left corner of the screen, you''ll see the `Viewport`
    window. Here, you''ll be able to preview the result of your material and how it
    will appear on some basic shapes such as spheres, cubes, and planes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Details`: At the bottom-left corner of the screen, you''ll see the `Details`
    window where, similar to the Blueprint editor, you''ll be able to see the details
    of either this `Material` asset or those of the currently selected node in the
    `Graph` window.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Toolbar`: At the top edge of the screen, you''ll see the `Toolbar` window,
    where you''ll be able to apply and save the changes made to your material, as
    well as to perform several actions related to the `Graph` window.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In every single Material editor inside UE4, you'll find a node with the name
    of that `Material` asset, where you'll be able to specify several parameters related
    to it by plugging that node's pins to other nodes.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you can see that there's a node called `0.7` being plugged into
    the `Roughness` pin. This node is a `Constant` node, which allows you to specify
    a number associated with it – in this case, `0.7`. You can create constant nodes
    of a single number, a 2 vector (for example, `(1, 0.5)`), a 3 vector (for example,
    `(1, 0.5, 4)`), and a 4 vector (for example, `(1,0.5, 4, 0)`). To create these
    nodes, you can press the `Graph` window with the *left mouse button* while holding
    the `1`, `2`, `3`, or `4` number keys, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Materials have several input parameters, so let''s go through some of the most
    important ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BaseColor`: This parameter is simply the color of the material. Generally,
    constants or texture samples are used to connect to this pin, to either have an
    object be a certain color or to map to a certain texture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Metallic`: This parameter will dictate how much your object will look like
    a metal surface. You can do this by connecting a constant single number node that
    ranges from 0 (not metallic) to 1 (very metallic).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Specular`: This parameter will dictate how much your object will reflect light.
    You can do this by connecting a constant single number node that ranges from 0
    (doesn''t reflect any light) to 1 (reflects all the light). If your object is
    already very metallic, you will see little to no difference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Roughness`: This parameter will dictate how much the light that your object
    reflects will be scattered (the more the light scatters, the less clear this object
    will reflect what''s around it). You can do this by connecting a constant single
    number node that ranges from 0 (the object essentially becomes a mirror) to 1
    (the reflection on this object is blurry and unclear).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about `material` inputs like the ones above, go to [https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/MaterialInputs](https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/MaterialInputs).
  prefs: []
  type: TYPE_NORMAL
- en: 'UE4 also allows you to import images (`.jpeg`, `.png`) as `Texture` assets,
    which can then be referenced in a material using `Texture Sample` nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.50: The Texture Sample node, which allows you to specify a texture
    and use'
  prefs: []
  type: TYPE_NORMAL
- en: it or its individual color channels as pins
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_01_50.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.50: The Texture Sample node, which allows you to specify a texture
    and use it or its individual color channels as pins'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will be taking a look at how to import files into UE4 in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a new `Material` asset, you can do so by *right-clicking*
    on the directory inside `Content Browser` where you want to create the new asset,
    which will allow you to choose which asset to create, and then select `Material`.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know how to create and manipulate materials in UE4.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now jump into this chapter's activity, which will be the first activity
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1.01: Propelling TestActor on the Z Axis Indefinitely'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you will use the `Tick` event of `TestActor` to move it on
    the *Z* axis indefinitely, instead of doing this only once when the game starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `TestActor` Blueprint class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Event Tick` node to the Blueprint's `Event Graph` window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `AddActorWorldOffset` function, split its `DeltaLocation` pin, and connect
    the `Tick` event's output execution pin to this function's input execution pin,
    similar to what we did in *Exercise 1.01*, *Creating an Unreal Engine 4 Project*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a *Float Multiplication* node to `Event Graph` window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the `Tick` event's `Delta Seconds` output pin to the first input pin
    of the *Float Multiplication* node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new variable of the `float` type, call it `VerticalSpeed,` and set
    its default value to `25`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a getter to the `VerticalSpeed` variable to the `Event Graph` window and
    connect its pin to the second input pin of the *Float Multiplication* node. After
    that, connect the *Float Multiplication* node's output pin to the `Delta Location
    Z` pin of the `AddActorWorldOffset` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the `BeginPlay` event and the `AddActorWorldOffset` function connected
    to it, both of which we created in *Exercise 1.01*, *Creating an Unreal Engine
    4 Project*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Play the level and notice our `TestActor` rising from the ground and up into
    the air over time:![Figure 1.51: The TestActor propelling itself vertically'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_01_51.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.51: The TestActor propelling itself vertically'
  prefs: []
  type: TYPE_NORMAL
- en: And with those steps completed, we conclude this activity – the first of many
    in this book. We've now consolidated adding and removing nodes to and from the
    Blueprint editor's `Event Graph` window, as well as using the `Tick` event and
    its `DeltaSeconds` property to create game logic that maintains consistency across
    different frame rates.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TestActor` blueprint asset can be found here: [https://packt.live/2U8pAVZ](https://packt.live/2U8pAVZ).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By completing this chapter, you have taken the first step in your game development
    journey by learning about Unreal Engine 4\. You now know how to navigate the Unreal
    Engine editor, manipulate the Actors inside a level, create your own Actors, use
    the Blueprint scripting language, and how 3D objects are represented in Unreal
    Engine 4.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you realize that there's a whole world of possibilities ahead of
    you and that the sky is the limit in terms of the things you can create using
    this game development tool.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will recreate the project template that was automatically
    generated in this chapter from scratch. You will learn how to create your own
    C++ classes and then create Blueprint classes that can manipulate properties declared
    in their parent class and how to import character meshes and animations into Unreal
    Engine 4, as well as becoming familiar with other animation-related assets such
    as *Animation Blueprints*.
  prefs: []
  type: TYPE_NORMAL

- en: 9\. Audio-Visual Elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will finish the dodgeball-based game that we have been working
    on in the past four chapters. We will conclude this chapter by adding sound effects,
    particle effects, and by creating another level, this time with an actual path
    the player must follow to finish it. By the end of this chapter, you will be able
    to add 2D and 3D sound effects, as well as particle effects, to your UE4 projects.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about game UI and how to create and add
    a user interface (also known as a widget) to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to add audio and particle effects to our
    game. Both of these aspects will increase the quality of our game and produce
    a much more immersive experience for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Sound in video games can come in the form of either sound effects (also known
    as SFX) or music. Sound effects make the world around you more believable and
    alive, while the music helps set the tone for your game. Both these aspects are
    very important to your game.
  prefs: []
  type: TYPE_NORMAL
- en: 'In competitive games such as *Counter-Strike* (*CS: GO*), sound is also extremely
    important because players need to hear the sounds around them, such as gunshots
    and footsteps, and which direction they came from, to gather as much information
    about their surroundings as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Particle effects are important for the same reason that sound effects are important:
    they make your game world more believable and immersive.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start this chapter by learning how audio works in UE4.
  prefs: []
  type: TYPE_NORMAL
- en: Audio in UE4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the essential components of any game is sound. Sounds make your game
    more believable and immersive, which will provide a much better experience for
    your player. Video games usually have two types of sounds:'
  prefs: []
  type: TYPE_NORMAL
- en: 2D sounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3D sounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2D sounds don't have any consideration for the listener's distance and direction,
    while 3D sounds can be higher or lower in volume and pan to the right or left,
    depending on the player's location. 2D sounds are usually used for music, while
    3D sounds are usually used for sound effects. The main sound file types are `.wav`
    and `.mp3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the assets and classes related to audio in UE4:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sound Base`: Represents an asset that contains audio. This class is mainly
    used in C++ and Blueprint to reference an audio file that can be played.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sound Wave`: Represents an audio file that has been imported into UE4\. Inherits
    from `Sound Base`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sound Cue`: An audio asset that can contain logic related to things such as
    attenuation (how the volume changes as the listener''s distance varies), looping,
    sound mixing, and other audio-related functionality. It inherits from `Sound Base`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sound Class`: An asset that allows you to separate your audio files into groups
    and manage some of their settings, such as volume and pitch. An example of this
    would be grouping all your sounds related to sound effects in the `SFX` `Sound
    Class`, all your character dialogue in the `Dialogue` `Sound Class`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sound Attenuation`: An asset that allows you to specify how a 3D sound will
    behave; for example, at which distance it will start to lower the volume, at which
    distance it will become inaudible (can''t be heard), if its volume will change
    linearly or exponentially as the distance increases, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Audio Component`: An actor component that allows you to manage the playback
    of audio files and their properties. Useful for setting up continuous playback
    of sounds, such as background music.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In UE4, we can import existing sounds the same way we would any other asset:
    either by dragging a file from the Windows File Explorer into the `Content Browser`
    or by clicking the `Import` button in the `Content Browser`. We''ll do this in
    the next exercise.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.01: Importing an Audio File'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will import an existing sound file from your computer
    into UE4\. This audio file will be played when the dodgeball bounces off a surface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t have an audio file (either an `.mp3` or `.wav` file) available
    to complete this exercise, you can download the `.mp3` or `.wav` file available
    at this link: [https://www.freesoundeffects.com/free-track/bounce-1-468901/](https://www.freesoundeffects.com/free-track/bounce-1-468901/).'
  prefs: []
  type: TYPE_NORMAL
- en: Save this file as `BOUNCE.wav`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have an audio file, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the `Content` folder inside the `Content Browser` interface and create
    a new folder called `Audio`:![Figure 9.1: The Audio folder in the Content Browser'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_09_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.1: The Audio folder in the Content Browser'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the `Audio` folder you just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import your audio file into this folder. You can do this by *dragging* the audio
    file from `Windows File Explorer` into `Content Browser`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After you''ve done this, a new asset should appear with the name of your audio
    file, which you can listen to when clicking on it:![Figure 9.2: The imported audio
    file'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_09_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.2: The imported audio file'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open this asset. You should see many properties available for editing. However,
    we''ll be focusing solely on some of the properties inside the `Sound` category:![Figure
    9.3: The Sound asset’s settings'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_09_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.3: The Sound asset''s settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following properties are available in the `Sound` category:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Looping`: Whether this sound will loop while being played.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Volume`: The volume of this sound.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pitch`: The pitch of this sound. The higher the pitch, the higher the frequency,
    and the higher in tone this sound will be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Class`: The `Sound Class` of this sound.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only property we'll be changing is the `Class` property. We could use one
    of the existing `Sound` classes that comes with UE4, but let's create our own
    `Sound Class` for the dodgeball in order to create a new group of sounds for our
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the `Audio` folder inside the `Content Browser` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click*, go to the `Sounds` category (the penultimate category), then
    the `Classes` category, and select `Sound Class`. This will create a new `Sound
    Class` asset. Rename this asset `Dodgeball`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your imported sound asset and set its `Class` property to `Dodgeball`:![Figure
    9.4: Changing the Class property to the Dodgeball Sound Class'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_09_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.4: Changing the Class property to the Dodgeball Sound Class'
  prefs: []
  type: TYPE_NORMAL
- en: Now that this imported sound asset belongs to a specific class, you can group
    other sound effects related to the dodgeball in the same `Sound Class` and edit
    their properties through that `Sound Class`, which includes `Volume`, `Pitch`,
    and many others.
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we can conclude our exercise. You have learned how to import
    sounds into your project and how to change their basic properties. Now, let's
    move on to the next exercise, where we'll be playing a sound whenever a dodgeball
    bounces off a surface in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.02: Playing a Sound When the Dodgeball Bounces off a Surface'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will add the necessary functionality to our `DodgeballProjectile`
    class so that a sound will play when the dodgeball bounces off a surface.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Close the editor and open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the header file for the `DodgeballProjectile` class, add a protected `class
    USoundBase*` property called `BounceSound`. This property should be a `UPROPERTY`
    and have the `EditDefaultsOnly` tag so that it can be edited in the Blueprint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After you''ve done this, go to the `DodgeballProjectile` class''s source file
    and add an include for the `GameplayStatics` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Then, at the beginning of the class's implementation of the `OnHit` function,
    before the cast to the `DodgeballCharacter` class, check whether our `BounceSound`
    is a valid property (different than `nullptr`) and whether the magnitude of the
    `NormalImpulse` property is greater than `600` units (we can access the magnitude
    by calling its `Size` function).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we saw in *Chapter 8*, *User Interfaces*, the `NormalImpulse` property indicates
    the direction and magnitude of the force that will change the dodgeball''s trajectory
    after it has been hit. The reason why we want to check if its magnitude is greater
    than a certain amount is that when the dodgeball starts losing momentum and bounces
    off of the floor several times per second, we don''t want to play `BounceSound`
    several times per second; otherwise, it will generate a lot of noise. So, we will
    check whether the impulse that the dodgeball is suffering is greater than that
    amount to make sure this doesn''t happen. If both these things are true, we''ll
    call the `GameplayStatics` object''s `PlaySoundAtLocation`. This function is responsible
    for playing 3D sounds. It receives five parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: A world context object, which we'll pass as the `this` pointer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `SoundBase` property, which will be our `HitSound` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The origin of the sound, which we'll pass using the `GetActorLocation` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VolumeMultiplier`, which we''ll pass with a value of `1`. This value indicates
    how much higher or lower the volume of this sound will be when it''s played. For
    instance, a value of `2` means it will have the volume twice as high.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PitchMultiplier`, which indicates how much higher or lower the pitch of this
    sound will be when it''s played. We''ll be passing this value by using the `FMath`
    object''s `RandRange` function, which receives two numbers as parameters and returns
    a random number between those two. To randomly generate a number between `0.7`
    and `1.3`, we''ll be calling this function with these values as parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Have a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The function responsible for playing 2D sounds is also available from the `GameplayStatics`
    object, and it's called `PlaySound2D`. This function will receive the same parameters
    as the `PlaySoundAtLocation` function, except for the third parameter, which is
    the origin of the sound.
  prefs: []
  type: TYPE_NORMAL
- en: Compile these changes and then open Unreal Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `BP_DodgeballProjectile` Blueprint, go to its `Class Defaults` tab,
    and set the `BounceSound` property to the Sound asset you imported:![Figure 9.5:
    Setting the BounceSound property to our imported sound'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_09_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.5: Setting the BounceSound property to our imported sound'
  prefs: []
  type: TYPE_NORMAL
- en: 'Play the level again and enter the enemy character''s line of sight. You should
    notice a sound playing with different pitch values every time the dodgeball thrown
    by the enemy character hits a wall or the floor (not the player character):![Figure
    9.6: The player character causing the enemy character to throw dodgeballs'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_09_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.6: The player character causing the enemy character to throw dodgeballs'
  prefs: []
  type: TYPE_NORMAL
- en: If this happens, congratulations – you've successfully played a sound using
    UE4! If you can't hear the sound playing, make sure that it is audible (it has
    a level of volume that you can hear).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, another thing you''ll probably notice is that the sound is always
    played at the same volume, regardless of the distance that the character is from
    the dodgeball that is bouncing: the sound isn''t playing in 3D but rather is being
    played in 2D. To play a sound in 3D using UE4, we''ll have to learn about Sound
    Attenuation assets.'
  prefs: []
  type: TYPE_NORMAL
- en: Sound Attenuation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a sound to be played in 3D inside UE4, you'll have to create a Sound Attenuation
    asset, as we mentioned in the first section of this chapter. A Sound Attenuation
    asset will let you specify how you want a specific sound to change volume as its
    distance from the listener increases. Have a look at the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Unreal Editor, go to the `Audio` folder inside the `Content Browser` interface,
    *right-click*, go to the `Sounds` category, and select `Sound Attenuation`. Name
    this new asset `BounceAttenuation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7: Creating the Sound Attenuation asset'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_09_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.7: Creating the Sound Attenuation asset'
  prefs: []
  type: TYPE_NORMAL
- en: Open this `BounceAttenuation` asset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sound Attenuation assets have many settings; however, we''ll want to focus
    mainly on a couple of settings from the `Attenuation Distance` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Inner Radius`: This `float` property allows us to specify at what distance
    the sound will start lowering in volume. If the sound is played at a distance
    less than this value, the volume won''t be affected. Set this property to `200`
    units.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Falloff Distance`: This float property allows us to specify at what distance
    we want the sound to be inaudible. If the sound is played at a distance greater
    than this value, we won''t hear it. The volume of the sound will vary according
    to its distance to the listener and whether it''s closer to `Inner Radius` or
    `Falloff Distance`. Set this property to `1500` units:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.8: The Sound Attenuation asset settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_09_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.8: The Sound Attenuation asset settings'
  prefs: []
  type: TYPE_NORMAL
- en: Think of this as two circles around the player, with the smaller circle being
    the Inner Circle (with a radius value of `Inner Radius`) and the bigger circle
    being the Falloff Circle (with a radius value of `Falloff Distance`). If a sound
    originates from inside the Inner Circle, it is played at full volume, while a
    sound that originates from outside the Falloff Circle is not played at all.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information on Sound Attenuation assets here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unrealengine.com/en-US/Engine/Audio/DistanceModelAttenuation](https://docs.unrealengine.com/en-US/Engine/Audio/DistanceModelAttenuation).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about Sound Attenuation assets, let's move on to the next
    exercise, where we'll turn the sound that plays when the dodgeball bounces off
    the ground into a 3D sound.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.03: Turning the Bounce Sound into a 3D Sound'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we'll be turning the sound that plays when a dodgeball bounces
    off the ground, which we added in the previous exercise, into a 3D sound. This
    means that when the dodgeball bounces off a surface, the sound it plays will vary
    in volume, depending on its distance to the player. We're doing this so that when
    the dodgeball is far away, the sound volume will be low, and when it's close,
    its volume will be high.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `BounceAttenuation` asset we created in the previous section, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the header file for `DodgeballProjectile` and add a `protected` `class
    USoundAttenuation*` property called `BounceSoundAttenuation`. This property should
    be a `UPROPERTY`, and have the `EditDefaultsOnly` tag so that it can be edited
    in the Blueprint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the `DodgeballProjectile` class'' implementation of the `OnHit` function
    in its source file, and add the following parameters to the call to the `PlaySoundAtLocation`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`StartTime`, which we''ll pass with a value of `0`. This value indicates the
    time that the sound will start playing. If the sound lasts 2 seconds, we can have
    this sound start at its 1-second mark by passing a value of `1`. We pass a value
    of `0` to have the sound play from the start.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SoundAttenuation`, to which we''ll pass our `BounceSoundAttenuation` property:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Although we only want to pass the additional `SoundAttenuation` parameter, we
    have to pass all the other parameters that come before it as well.
  prefs: []
  type: TYPE_NORMAL
- en: Compile these changes and then open the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `BP_DodgeballProjectile` Blueprint, go to its `Class Defaults` tab,
    and set the `BounceSoundAttenuation` property to our `BounceAttenuation` asset:![Figure
    9.9: Setting the BoundSoundAttenuation property to the BounceAttenuation asset'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_09_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.9: Setting the BoundSoundAttenuation property to the BounceAttenuation
    asset'
  prefs: []
  type: TYPE_NORMAL
- en: 'Play the level again and enter the enemy character''s line of sight. You should
    now notice that the sound that plays every time the dodgeball thrown by the enemy
    character hits a wall or the floor will be played at different volumes, depending
    on its distance, and that you won''t hear it if the dodgeball is far away:![Figure
    9.10: The player character causing the enemy character to throw dodgeballs'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_09_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.10: The player character causing the enemy character to throw dodgeballs'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we can conclude this exercise. You now know how to play 3D sounds
    using UE4\. We'll add background music to our game in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.04: Adding Background Music to Our Game'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will add background music to our game. We will do this
    by creating a new Actor with an Audio component, which, as we mentioned earlier,
    is appropriate for playing background music. To achieve this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the audio file located at [https://packt.live/3pg21sQ](https://packt.live/3pg21sQ)
    and import it into the `Audio` folder of the `Content Browser` interface, just
    like we did in *Exercise 9.01*, *Importing an Audio File*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* inside the `Content Browser` interface and create a new C++ class
    with the `Actor` class as its parent class. Name this new class `MusicManager`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the files for this class are generated and Visual Studio has opened automatically,
    close the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `MusicManager` class''s header file, add a new `protected` property
    of the `class UAudioComponent*` type called `AudioComponent`. Make this a `UPROPERTY`
    and add the `VisibleAnywhere` and `BlueprintReadOnly` tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `MusicManager` class''s source file, add an `include` for the `AudioComponent`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor for this class, change the `bCanEverTick` property to `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After this line, add a new one that creates the `AudioComponent` class by calling
    the `CreateDefaultSubobject` function and passing the `UAudioComponent` class
    as a template parameter and `"Music Component"` as a normal parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After making these changes, compile your code and open the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `ThirdPersonCPP` -> `Blueprints` folder in the `Content Browser` interface
    and create a new Blueprint class that inherits from the `MusicManager` class.
    Name it `BP_MusicManager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open this asset, select its `Audio` component, and set that component''s `Sound`
    property to your imported sound:![Figure 9.11: The Sound property being updated'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_09_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.11: The Sound property being updated'
  prefs: []
  type: TYPE_NORMAL
- en: Drag an instance of the `BP_MusicManager` class into the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the level. You should notice the music start playing when the game starts
    and it should also loop automatically when it reaches the end (this is done thanks
    to the Audio component).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Audio components will automatically loop whatever sound they're playing, so
    there's no need to change that Sound asset's `Looping` property.
  prefs: []
  type: TYPE_NORMAL
- en: After completing all these steps, we've completed this exercise. You now know
    how to add simple background music to your game.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's jump into the next topic, which is Particle Systems.
  prefs: []
  type: TYPE_NORMAL
- en: Particle Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s talk about another very important element of many video games: Particle Systems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In video game terms, a particle is essentially a position in a 3D space that
    can be represented with an image. A Particle System is a collection of many particles,
    potentially with different images, shapes, colors, and sizes. In the following
    image, you will find an example of two Particle Systems made in UE4:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12: Two different Particle Systems in UE4'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_09_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.12: Two different Particle Systems in UE4'
  prefs: []
  type: TYPE_NORMAL
- en: The Particle System on the left is supposed to be electrical sparks that could
    come from a cable that has been sliced and is now in short-circuit, while the
    one on the right is supposed to be a fire. Although the particle system on the
    left is relatively simple, you can tell that the one on the right has more than
    one type of particle inside it, which can be combined in the same system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'UE4 has two different tools for creating Particle Systems: `Cascade` and `Niagara`.
    Cascade is the tool that has been present since the beginning of UE4, while Niagara
    is a system that is more recent and sophisticated and has only been production-ready
    since May 2020, as of Unreal Engine version 4.25.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Particle Systems in UE4 is outside the scope of this book, but it is
    recommended that you use Niagara over Cascade, given that it is a more recent
    addition to the engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will only be using Particle Systems that are already included
    in UE4, but if you want to create your own, these links will give you more information
    about both Cascade and Niagara:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cascade: [https://docs.unrealengine.com/en-US/Engine/Rendering/ParticleSystems/Cascade](https://docs.unrealengine.com/en-US/Engine/Rendering/ParticleSystems/Cascade)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/playlist?list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t](https://www.youtube.com/playlist?list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Niagara: [https://docs.unrealengine.com/en-US/Engine/Niagara/EmitterEditorReference/index.html](https://docs.unrealengine.com/en-US/Engine/Niagara/EmitterEditorReference/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unrealengine.com/en-US/Engine/Niagara/QuickStart](https://docs.unrealengine.com/en-US/Engine/Niagara/QuickStart)'
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn how to add Particle Systems to our game in the next exercise. In
    this chapter, we will be simply using existing Particle Systems that were already
    made by the UE4 team.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.05: Spawning a Particle System When the Dodgeball Hits the Player'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will get to know how to spawn a Particle System in UE4\.
    In this case, we will be spawning an `explosion` Particle System when a dodgeball
    thrown by the enemy hits the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Close the editor and open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `DodgeballProjectile` class's header file, add a protected `class UParticleSystem*`
    property called `HitParticles`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `UParticleSystem` type is the designation for a Particle System in UE4\.
    Be sure to make this a `UPROPERTY` and give it the `EditDefaultsOnly` tag so that
    it can be edited in the Blueprint class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the `DodgeballProjectile` class's source file, inside its implementation
    of the `OnHit` function. Before the call to the `Destroy` function, check whether
    our `HitParticles` property is valid. If it is, call the `GameplayStatics` object's
    `SpawnEmitterAtLocation` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This function will spawn an actor that will play the Particle System we pass
    as a parameter. It receives the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: A `World` object, which we'll pass using the `GetWorld` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `UParticleSystem*` property, which will be our `HitParticles` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `FTransform` of the actor that will play the Particle System, which we''ll
    pass using the `GetActorTransform` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Although we won't be using it in this project, there is another function related
    to spawning Particle Systems available from the `GameplayStatics` object, which
    is the `SpawnEmitterAttached` function. This function will spawn a Particle System
    and attach it to an actor, which might be useful if you want to, for instance,
    make a moving object light on fire so that the Particle System will always remain
    attached to that object.
  prefs: []
  type: TYPE_NORMAL
- en: Compile these changes and then open the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `BP_DodgeballProjectile` Blueprint, go to its `Class Defaults` tab,
    and set the `HitParticles` property to the `P_Explosion` Particle System asset:![Figure
    9.13: Setting the HitParticles property to P_Explosion'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_09_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.13: Setting the HitParticles property to P_Explosion'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, play the level and let your player character get hit by a dodgeball. You
    should now see the explosion Particle System being played:![Figure 9.14: The explosion
    particle system being played when the dodgeball hits the player'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_09_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.14: The explosion particle system being played when the dodgeball
    hits the player'
  prefs: []
  type: TYPE_NORMAL
- en: And that concludes this exercise. You now know how to play Particle Systems
    in UE4\. Particle Systems will add visual flair to your game and make it more
    visually appealing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next activity, we'll be consolidating our knowledge of playing audio
    in UE4 by playing a sound when the dodgeball hits the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9.01: Playing a Sound When the Dodgeball Hits the Player'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we will be creating the logic responsible for playing a sound
    every time the player character gets hit by a dodgeball. In a video game, it's
    very important to transmit to the player's crucial information in many ways, so
    in addition to changing the player character's Health Bar, we'll also be playing
    a sound when the player gets hit so that the player knows that the character is
    taking damage.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import a sound file that will be played when the player character gets hit into
    the `Audio` folder inside the `Content Browser` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have a sound file, you can use the one available at [https://www.freesoundeffects.com/free-track/punch-426855/](https://www.freesoundeffects.com/free-track/punch-426855/).
  prefs: []
  type: TYPE_NORMAL
- en: Open the `DodgeballProjectile` class's header file. Add a `SoundBase*` property,
    just like we did in *Exercise 9.02*, *Playing a Sound When the Dodgeball Bounces
    off of a Surface*, but this time call it `DamageSound`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `DodgeballProjectile` class's source file. In the `OnHit` function's
    implementation, after you've damaged the player character and before you call
    the `Destroy` function, check whether the `DamageSound` property is valid. If
    it is, call the `GameplayStatics` object's `PlaySound2D` function (mentioned in
    *Exercise 9.02,* *Playing a Sound When the Dodgeball Bounces off of a Surface*),
    passing `this` and `DamageSound` as the parameters to that function call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile your changes and open the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `BP_DodgeballProjectile` Blueprint and set its `DamageSound` property
    to the sound file you imported at the start of this activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you play the level, you should notice that every time the player gets
    hit by a dodgeball, you will hear the sound you imported being played:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15: A sound should play when the player character gets hit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_09_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.15: A sound should play when the player character gets hit'
  prefs: []
  type: TYPE_NORMAL
- en: And with those steps complete, you have finished this activity and consolidated
    the use of playing both 2D and 3D sounds in UE4.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's wrap up this chapter by learning a bit about the concept of Level
    Design.
  prefs: []
  type: TYPE_NORMAL
- en: Level Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since *Chapter 5*, *Line Traces*, related to our dodgeball game, we've added
    quite a few game mechanics and gameplay opportunities, as well as some audio-visual
    elements, all of which were handled in this chapter. Now that we have all these
    game elements, we must bring them together into a level that can be played from
    start to finish by the player. To do that, let's learn a bit about Level Design
    and level blockouts.
  prefs: []
  type: TYPE_NORMAL
- en: Level Design is a specific Game Design discipline that focuses on building levels
    in a game. The goal of a Level Designer is to make a level that is fun to play,
    introduces new gameplay concepts to the player by using the game mechanics built
    for that game, contains good pacing (a good balance of action-packed and relaxed
    gameplay sequences), and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the structure of a level, Level Designers will first build what is
    called a **level blockout**. This is a very simple and boiled down version of
    the level that uses most of the elements that the final level will contain, but
    it is made using only simple shapes and geometry. The reason for this is for it
    to be easier and less time-consuming to modify the level in case parts of it need
    to be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16: An example of a level blockout made in UE4 using BSP Brushes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_09_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.16: An example of a level blockout made in UE4 using BSP Brushes'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that Level Design is its own specific game development skill
    and is worthy of its own book, of which there are quite a few, but diving into
    this topic is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will be building a simple level blockout using the
    mechanics we built in the last few chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.06: Building a Level Blockout'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be creating a new level blockout that will contain
    some structure, where the player will start in a certain place in the level and
    have to go through a series of obstacles to reach the end of the level. We will
    be using all the mechanics and objects that we built in the last few chapters
    to make a level that the player will be able to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Although in this exercise we will be providing you with a solution, you are
    encouraged to let your creativity loose and come up with your solution, given
    that there is no right or wrong answer in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start this exercise, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `ThirdPersonCPP` -> `Maps` folder in your `Content Browser`, duplicate
    the `ThirdPersonExampleMap` asset, and name it `Level1`. You can do this by either
    selecting the asset and pressing *Ctrl* + *W* or by right-clicking on the asset
    and selecting `Duplicate` (the third option).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the newly created `Level1` map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Delete all the objects that have a mesh inside the map, except for the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The player character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The enemy character (note that both characters will look the same)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The floor object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both the Wall objects that we created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Victory Box object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that assets related to lighting and sound should remain untouched.
  prefs: []
  type: TYPE_NORMAL
- en: Build the lighting for `Level1` by pressing the `Build` button. This button
    is to the left of the `Play` button, in the `Toolbar` at the top of the editor
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you''ve followed these steps, you should have an empty floor with just
    the objects you''ll be needing for this level (the ones mentioned in *Step 4*).
    Here''s the `Level1` map before and after you followed *Steps 4 and 5*, respectively:![Figure
    9.17: Before deleting the required objects'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_09_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.17: Before deleting the required objects'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have deleted the objects, your floor should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18: After deleting the required objects'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_09_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.18: After deleting the required objects'
  prefs: []
  type: TYPE_NORMAL
- en: Because building a level, even a simple one, is something that takes a lot of
    steps and instructions, you will simply be shown a few screenshots of a possible
    level and, again, be encouraged to come up with your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we have simply used the existing `EnemyCharacter`, `Wall`, and
    `GhostWall` objects and duplicated them several times to create a simple layout
    that the player can traverse from start to finish. We also moved the `VictoryBox`
    object so that it matches the new level''s end location:![Figure 9.19: The created
    level – isometric view'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_09_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.19: The created level – isometric view'
  prefs: []
  type: TYPE_NORMAL
- en: 'The level can be seen in a top-down view as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20: The created level – top-down view with the player'
  prefs: []
  type: TYPE_NORMAL
- en: character marked with an arrow
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_09_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.20: The created level – top-down view with the player character marked
    with an arrow'
  prefs: []
  type: TYPE_NORMAL
- en: Once you're happy with the result, this means you have finished your Dodgeball
    game, and can now ask for your friends and family to play it and see what they
    think. Great job – you are one step closer to mastering the art of game development!
  prefs: []
  type: TYPE_NORMAL
- en: Extra Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we conclude this chapter, here are some suggestions on what you can
    do next in this dodgeball project:'
  prefs: []
  type: TYPE_NORMAL
- en: Make it so that the normal `Wall` class we created in a previous chapter doesn't
    block the enemy's line of sight. This way, the enemy will always throw dodgeballs
    at the player, which should still be blocked from going through this wall.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new feature that will allow the player to visualize where the dodgeball
    thrown by the enemy character will impact first, using the concept of Sweep Traces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new type of wall that blocks the player character, the enemy character,
    and the dodgeballs, but that also takes damage from dodgeballs and gets destroyed
    when it runs out of health points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a whole world of possibilities for expanding the scope of this project.
    You are encouraged to use the skills you've learned, and to do further research,
    to build new features and add more complexity to your game.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have now completed the dodgeball game project. In this chapter, you learned
    how to add polish to your game by playing audio and using Particle Systems. You
    now know how to add 2D and 3D sounds to your game, as well as some of the tools
    at your disposal in regard to that. Now, you can try to add even more sounds effects
    to your game, such as a special sound effect for when an enemy character sees
    you for the first time (such as in Metal Gear Solid), a footstep sound effect,
    or a victory sound effect.
  prefs: []
  type: TYPE_NORMAL
- en: You also built a level using all the tools that you made throughout the last
    few chapters, thus culminating all the logic we built in this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll be starting a new project: the `SuperSideScroller`
    game. In that project, you''ll be introduced to such topics as power-ups, collectibles,
    enemy **Artificial Intelligence** (**AI**), character animation, and much more.
    You will be creating a side-scrolling platformer game where you control a character
    that must complete a level, collect gems, and use power-ups to avoid the enemies.
    The two most important topics you will learn about are UE4''s behavior trees and
    Blackboards, which fuel the AI system, and Animation Blueprints, which allow you
    to manage your character''s animations.'
  prefs: []
  type: TYPE_NORMAL

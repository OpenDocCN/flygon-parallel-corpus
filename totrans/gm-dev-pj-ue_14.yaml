- en: 15\. Collectibles, Power-Ups, and Pickups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will create collectible coins and potion power-ups for the
    player. Furthermore, we will design the UI for the collectible coins using the
    Unreal Motion Graphics UI Designer, or UMG as it is more commonly known. Lastly,
    we will create bricks that will have these collectibles hidden inside of them.
    By the end of this chapter, you will be able to implement collectibles and power-ups
    for a player character to find within a level environment.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you created the player projectile and used `Anim Notifies`
    to spawn the player projectile during the `Throw` animation. The player projectile
    will serve as the player's main offensive gameplay mechanic to use against the
    enemies throughout the level. Due to the combination of default `Anim Notifies`
    provided by Unreal Engine 4 and your own custom `Anim_ProjectileNotify` class,
    the player projectile mechanic looks and feels great.
  prefs: []
  type: TYPE_NORMAL
- en: The last set of mechanics that we need to develop are the coin collectible and
    potion power-up. Let's briefly break down how collectibles and power-ups have
    influenced other games, and what they will accomplish for our `SuperSideScroller`
    game.
  prefs: []
  type: TYPE_NORMAL
- en: '**Coin Collectible**'
  prefs: []
  type: TYPE_NORMAL
- en: Collectibles give the player an incentive to explore the level thoroughly. In
    many games, such as *Hollow Knight*, collectibles also serve as a form of currency
    that can be used to purchase upgrades for your character and items. In other,
    more classic platformers, such as Super Mario or Sonic, collectibles serve to
    improve the player's score as they traverse the level.
  prefs: []
  type: TYPE_NORMAL
- en: In today's gaming landscape, it is expected that games include achievements.
    Collectibles are a great way to integrate achievements into your game; for example,
    an achievement for collecting all the coins in a level, or the entire game. For
    the `SuperSideScroller` game, the coin collectible will serve as a satisfactory
    means for the player to explore the game's levels to find as many coins as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '**Potion Power-Up**'
  prefs: []
  type: TYPE_NORMAL
- en: Power-ups give the player either permanent or temporary advantages against enemies
    or the environments that the player must navigate through. There are many game
    examples that utilize power-ups, and one of the most famous is the Metroid series.
    Metroid uses power-ups to allow the player to explore new areas and battle against
    stronger enemies.
  prefs: []
  type: TYPE_NORMAL
- en: Power-ups are also another way to integrate achievements into your game. For
    example, you can have an achievement to destroy a certain number of enemies with
    a specific power-up. For the `SuperSideScroller` game, the potion power-up will
    serve as a means to improve the player's ability to navigate the level environment
    by increasing their movement speed and jump height.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to create the coin collectible and potion
    power-up using C++ to add more layers of gameplay to the `SuperSideScroller` game.
    These gameplay elements will derive from the same base `actor` class that you
    will create. You will also be adding visual and audio elements to both the collectible
    and the power-up so that they are more polished.
  prefs: []
  type: TYPE_NORMAL
- en: To make the coin collectible and potion power-up more visually interesting to
    the player, we will add a rotating component to these actors in order to draw
    the player's attention to them. This is where `URotatingMovementComponent` can
    be very useful; it allows us to add rotation to actors in a very optimized and
    straightforward way, as opposed to coding our own logic to handle the constant
    rotation of the actor. Let's begin by learning more about this component.
  prefs: []
  type: TYPE_NORMAL
- en: URotatingMovementComponent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`URotatingMovementComponent` is one of a few movement components that exist
    within Unreal Engine 4\. You are already familiar with `CharacterMovementComponent`
    and `ProjectileMovementComponent` from the `SuperSideScroller` game project alone,
    and `RotatingMovementComponent` is just that – another movement component. As
    a refresher, movement components allow different types of movements to occur on
    actors, or characters, that they belong to.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`CharacterMovementComponent`, which allows you to control the movement parameters
    of your character such as their movement speed and jump height, was covered in
    *Chapter 10*, *Creating a SuperSideScroller Game*, when you created the `SuperSideScroller`
    player character. `ProjectileMovementComponent`, which allows you to add projectile-based
    movement functionality to actors such as speed and gravity, was covered in *Chapter
    14*, *Spawning the Player Projectile*, when you developed the player projectile.'
  prefs: []
  type: TYPE_NORMAL
- en: '`RotatingMovementComponent` is a very simple movement component compared to
    `CharacterMovementComponent` and that''s because it only involves rotating the
    actor that `RotatingMovementComponent` is a part of; nothing more. `RotatingMovementComponent`
    performs the continuous rotation of a component based on the defined `Rotation
    Rate`, pivot translation, and the option to use rotation in local space or world
    space.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, `RotatingMovementComponent` is much more efficient compared to
    other methods of rotating an actor, such as through the `Event Tick` or `Timelines`
    within Blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about movement components can be found here: [https://docs.unrealengine.com/en-US/Engine/Components/Movement/index.html#rotatingmovementcomponent](https://docs.unrealengine.com/en-US/Engine/Components/Movement/index.html#rotatingmovementcomponent).'
  prefs: []
  type: TYPE_NORMAL
- en: We will be using `RotatingMovementComponent` to allow the coin collectible and
    potion power-up to rotate in-place along the Yaw axis. This rotation will draw
    the player's attention to the collectible and give them a visual cue that the
    collectible is important.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a better understanding of `RotatingMovementComponent`, let's
    move on and create the `PickableActor_Base` class, which is what the coin collectible
    and the potion power-up will derive from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.01: Creating the PickableActor_Base Class and Adding URotatingMovementComponent'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will be creating the `PickableActor_Base` actor class,
    which will be used as the base class that both the collectible coin and potion
    power-up will derive from. You will also create a Blueprint class from this C++
    base class to preview how `URotatingMovementComponent` works. Follow these steps
    to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You have performed many of the following steps numerous times throughout the
    `SuperSideScroller` game project, so there will be limited images to help guide
    you. Only when introducing a new concept will there be an accompanying image.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the Unreal Engine 4 editor, *left-click* the `File` option at the top-left
    of the editor and *left-click* the option for `New C++ Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Choose Parent Class` window, select the `Actor` option, and then *left-click*
    on the `Next` button at the bottom of this window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name this class `PickableActor_Base` and leave the default `Path` directory
    as it is. Then, select the `Create Class` button at the bottom of this window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After selecting the `Create Class` button, Unreal Engine 4 will recompile the
    project code and automatically open Visual Studio with both the header and source
    files for the `PickableActor_Base` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, `Actor` classes provide you with the `virtual void Tick(float DeltaTime)
    override;` function declaration inside the header file. For the purposes of the
    `PickableActor_Base` class, we will not require the `Tick` function, so remove
    this function declaration from the `PickableActor_Base.h` header file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, you will also need to remove the function from the `PickableActor_Base.cpp`
    file; otherwise, you will receive a compile error. In this source file, find and
    remove the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'In many cases, the use of the `Tick()` function for movement updates can lead
    to performance issues as the `Tick()` function is called every single frame. Instead,
    try using `Gameplay Timer` functions to perform certain updates at specified intervals,
    rather than on each frame. You can learn more about `Gameplay Timers` here: [https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Timers/index.html](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Timers/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time to add the components that the `PickableActor_Base` class requires.
    Let''s start with `USphereComponent`, which you will use to detect overlap collision
    with the player. Add the following code underneath the `Protected` access modifier
    inside the `PickableActor_Base.h` header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The declaration of `USphereComponent` should be very familiar to you by now;
    we've done this in previous chapters, such as *Chapter 16*, *Multiplayer Basics*,
    when we created the `PlayerProjectile` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following code underneath the declaration of `USphereComponent`
    to create a new `UStaticMeshComponent`. This will be used to visually represent
    either the coin collectible or the potion power-up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the following code underneath the declaration of `UStaticMeshComponent`
    to create a new `URotatingMovementComponent`. This will be used to give the collectible
    coin and potion power-up simple rotational movement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have the components declared inside the `PickableActor_Base.h`
    header file, navigate to the `PickableActor_Base.cpp` source file so that you
    can add the required `#includes` for these added components. Add the following
    lines after the first `#include "PickableActor_Base.h"`, at the top of the source
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have the necessary `include` files for the components, you can
    add the necessary code to initialize these components within the `APickableActor_Base::APickableActor_Base()`
    constructor function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'First, initialize the `USphereComponent` component variable, `CollisionComp`,
    by adding the following code to `APickableActor_Base::APickableActor_Base()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, initialize `USphereComponent` with a default sphere radius of `30.0f`
    by adding the following code underneath the code provided in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the player character needs to overlap with this component, you will need
    to add the following code so that, by default, `USphereComponent` has the collision
    settings for `Overlap All Dynamic`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, `CollisionComp USphereComponent` should be the root component of this
    actor. Add the following code to assign this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that `CollisionComp USphereComponent` has been initialized, let''s do the
    same for `MeshComp UStaticMeshComponent`. Add the following code. After, we''ll
    discuss what the code is doing for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first line initializes `MeshComp UStaticMeshComponent` using the `CreateDefaultSubobject()`
    template function. Next, you are attaching `MeshComp` to the root component, which
    you made for `CollisionComp`, using the `AttachTo()` function. Lastly, `MeshComp
    UStaticMeshComponent` should not have any collision by default, so you are using
    the `SetCollisionEnabled()` function and passing in the `ECollisionEnable::NoCollision`
    enumerator value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we can initialize `URotatingMovementComponent RotationComp` by adding
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With all the components initialized, compile the C++ code and return to the
    Unreal Engine 4 editor. After compilation succeeds, you will move on to creating
    a Blueprint class for `PickableActor_Base`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Content Browser` window, create a new folder called `PickableItems`
    by *right-clicking* on the `Content` folder and selecting the `New Folder` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `PickableItems` folder, *right-click* and select `Blueprint Class`. From
    the `Pick Parent Class` window, search for the `PickableActor_Base` class and
    *left-click* `Select` to create a new Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name this Blueprint `BP_PickableActor_Base` and *double-left-click* the Blueprint
    to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Components` tab, select `MeshComp Static Mesh Component` and assign
    the `Shape_Cone` static mesh to the `Static Mesh` parameter in the `Details` panel.
    Please refer to the following screenshot:![Figure 15.1: The Shape_Cone mesh assigned
    to MeshComp UStaticMeshComponent of the BP_Pickable_Base actor class](img/B16183_15_01.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 15.1: The Shape_Cone mesh assigned to MeshComp UStaticMeshComponent
    of the BP_Pickable_Base actor class'
  prefs: []
  type: TYPE_NORMAL
- en: Next, select `RotationComp` `URotatingMovementComponent` and find the `Rotation
    Rate` parameter under the `Rotating Component` category of the `Details` panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set `Rotation Rate` to the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These values determine how fast the actor will rotate along each axis per second.
    This means that the cone-shaped actor will rotate along each axis at 100 degrees
    per second on each axis.
  prefs: []
  type: TYPE_NORMAL
- en: Compile the `PickableActor_Base` Blueprint and add this actor to your level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, if you use PIE and look at the `PickableActor_Base` actor in the level,
    you will see that it is now rotating. Please refer to the following screenshot:![Figure
    15.2: Now, the Cone mesh rotates along all the axes, as per the values we added
    to the Rotation Rate window of URotatingMovementComponent'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_15_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.2: Now, the Cone mesh rotates along all the axes, as per the values
    we added to the Rotation Rate window of URotatingMovementComponent'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the assets and code for this exercise here: [https://packt.live/3njhwyt](https://packt.live/3njhwyt).'
  prefs: []
  type: TYPE_NORMAL
- en: With this exercise complete, you've created the base components required for
    the `PickableActor_Base` class and learned how to implement and use `URotatingMovementComponent`.
    With the `PickableActor_Base` class ready, and with `URotatingMovementComponent`
    implemented on the Blueprint actor, we can complete the class by adding overlap
    detection functionality, destroying the collectible actor, and spawning audio
    effects when the actor is picked up by the player. In the following activity,
    you will add the remaining functionality required for the `PickableActor_Base`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 15.01: Player Overlap Detection and Spawning Effects in PickableActor_Base'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the `PickableActor_Base` class has all the required components and
    has its constructor initializing the components, it is time to add the remaining
    aspects of its functionality. These will be inherited by the coin collectible
    and potion power-up later in this chapter. This additional functionality includes
    player overlap detection, destroying the collectible actor, and spawning an audio
    effect to give feedback to the player that it has been successfully picked up
    by. Perform the following steps to add functionality that allows a `USoundBase`
    class object to be played when the collectible overlaps with the player:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new function in the `PickableActor_Base` class that takes in a reference
    to the player as an input parameter. Call this function `PlayerPickedUp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `UFUNCTION` called `BeginOverlap()`. Make sure to include all the
    required input parameters for this function before moving on. Refer to *Chapter
    6*, *Collision Objects*, where you used this function inside the `VictoryBox` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new `UPROPERTY()` for the `USoundBase` class and name it `PickupSound`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `PickableActor_Base.cpp` source file, create the definitions for both
    the `BeginOverlap()` and `PlayerPickedUp()` functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, add the required `#include` files for the `SuperSideScroller_Player` class
    and the `GameplayStatics` class at the top of the source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `BeginOverlap()` function, create a reference to the player using the
    `OtherActor` input parameter of the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `PlayerPickedUp()` function, create a variable for the `UWorld*` object
    that's returned by the `GetWorld()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `UGameplayStatics` library to spawn `PickUpSound` at the location of
    the `PickableActor_Base` actor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, call the `Destroy()` function so that the actor gets destroyed and removed
    from the world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in the `APickableActor_Base::APickableActor_Base()` constructor, bind
    the `OnComponentBeginOverlap` event of `CollisionComp` to the `BeginOverlap()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download and install the `Unreal Match 3` project from the `Learn` tab of `Epic
    Games Launcher`. Migrate the `Match_Combo` soundwave asset from this project into
    your `SuperSideScroller` project using the knowledge you gained in *Chapter 14*,
    *Spawning the Player Projectile*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply this sound to the `PickupSound` parameter of the `BP_PickableActor_Base`
    Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the Blueprint, and if one does not exist in your level, add the `BP_PickableActor_Base`
    actor to your level now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `PIE`, have your character overlap with the `BP_PickableActor_Base` actor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3: The BP_PickableActor_Base object can be overlapped'
  prefs: []
  type: TYPE_NORMAL
- en: and picked up by the player
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_15_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.3: The BP_PickableActor_Base object can be overlapped and picked
    up by the player'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: With this activity complete, you have proven your knowledge regarding how to
    add the `OnBeginOverlap()` functionality to your actor classes and how to use
    this function to perform logic for your actor. In the case of `PickableActor_Base`,
    we added logic that will spawn a custom sound and destroy the actor.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the `PickableActor_Base` class is set and ready, it is time to develop
    the collectible coin and power-up potion classes that will derive from it. The
    coin collectible class will inherit from the `PickableActor_Base` class you have
    just created. It will override key functionality, such as the `PlayerPickedUp()`
    function, so that we can implement unique logic for the collectible when it's
    picked up by the player. In addition to overriding functionality from the inherited
    parent `PickableActor_Base` class, the coin collectible class will have its own
    unique set of properties, such as its current coin value and unique pickup sound.
    We'll create the coin collectible class together in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.02: Creating the PickableActor_Collectable Class'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will be creating the `PickableActor_Collectable` class,
    which will be derived from the `PickableActor_Base` class you created in *Exercise
    15.01*, *Creating the PickableActor_Base Class and Adding URotatingMovement Component*
    and finished in *Activity 15.01*, *Player Overlap Detection and Spawning Effects
    in PickableActor_Base*. This class will be used as the main collectible coin that
    the player can collect within the level. Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the Unreal Engine 4 editor, *left-click* the `File` option at the top-left
    of the editor and *left-click* the option for `New C++ Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Choose Parent Class` window, select the `PickableActor_Base` option,
    and then *left-click* on the `Next` button at the bottom of this window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name this class `PickableActor_Collectable` and leave the default `Path` directory
    as it is. Then, select the `Create Class` button at the bottom of this window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After selecting the `Create Class` button, Unreal Engine 4 will recompile the
    project code and will automatically open Visual Studio with both the header and
    source files for the `PickableActor_Collectable` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, the `PickableActor_Collectable.h` header file has no declared functions
    or variables within its class declaration. You will need to add the override for
    the `BeginPlay()` function underneath a new `Protected Access Modifier`. Add the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The reason we are overriding the `BeginPlay()` function is that `URotatingMovementComponent`
    requires the actor to initialize and use `BeginPlay()` to correctly rotate the
    actor. Therefore, we need to create the override declaration of this function
    and create a basic definition inside the source file. First, however, we need
    to override another important function from the `PickableActor_Base` parent class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Override the `PlayerPickedUp()` function from the `PickableActor_Base` parent
    class by adding the following code under `Protected Access Modifier`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With this, we are saying that we are going to use, and override, the functionality
    of the `PlayerPickedUp()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, create a new integer called `UPROPERTY()` that will hold the value
    that the coin collectible will have; in this case, it will have a value of `1`.
    Add the following code to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are creating the integer variable that will be accessible in Blueprints
    and has a default value of `1`. If you so choose, with the `EditAnywhere UPROPERTY()`
    keyword, you can change how much a coin collectible is worth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can move on to the `PickableActor_Collectable.cpp` source file to create
    the definition of the overridden `PlayerPickedUp()` function. Add the following
    code to the source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, we need to make a call to the `PlayerPickedUp()` parent function by
    using the `Super` keyword. Add the following code to the `PlayerPicked()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The call to the parent function using `Super::PlayerPickedUp(Player)` will ensure
    that the functionality you created in the `PickableActor_Base` class is called.
    As you may recall, the `PlayerPickedUp()` function in the parent class makes a
    call to spawn the `PickupSound` sound object and destroys the actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create the definition of the `BeginPlay()` function inside the source
    file by adding the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing to do here in C++ is to once again make the call to the `BeginPlay()`
    parent function using the `Super` keyword. Add the following code to the `BeginPlay()`
    function inside the `PickableActor_Collectable` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Compile the C++ code and return to the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the assets and code for this exercise at the following link: [https://packt.live/35fRN3E](https://packt.live/35fRN3E).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've successfully compiled the `PickableActor_Collectable` class,
    you have created the framework needed for the coin collectible. In the following
    activity, you will create a Blueprint from this class and finalize the coin collectible actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 15.02: Finalizing the PickableActor_Collectable Actor'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the `PickableActor_Collectable` class has all of the necessary inherited
    functionality and unique properties it needs, it is time to create the Blueprint
    from this class and add a `Static Mesh`, update its `URotatingMovementComponent`,
    and apply a sound to the `PickUpSound` property. Perform the following steps to
    finalize the `PickableActor_Collectable` actor:'
  prefs: []
  type: TYPE_NORMAL
- en: From `Epic Games Launcher`, find the `Content Examples` project from the `Learn`
    tab, underneath the `Engine Feature Samples` category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and install a new project from the `Content Examples` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Migrate the `SM_Pickup_Coin` asset and all its referenced assets from the `Content
    Examples` project to your `SuperSideScroller` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder within the `Content/PickableItems` directory in the `Content
    Browser` window and name it `Collectable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this new `Collectable` folder, create a new Blueprint from the `PickableActor_Collectable`
    class that you created in *Exercise 15.02*, *Creating the PickableActor_Collectable
    Class*. Name this new Blueprint `BP_Collectable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this Blueprint, set the `Static Mesh` parameter of the `MeshComp` component
    to the `SM_Pickup_Coin` mesh you imported earlier in this activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add the `Match_Combo` sound asset to the `PickupSound` parameter of the
    collectible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, update the `RotationComp` component so that the actor rotates along
    the Z-axis at 90 degrees per second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the Blueprint, place `BP_Collectable` in your level, and use PIE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overlap the player character with the `BP_Collectable` actor and observe the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4: The coin collectible rotates and can be overlapped by the player'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_15_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.4: The coin collectible rotates and can be overlapped by the player'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: With this activity complete, you have proven that you know how to migrate assets
    into your Unreal project and how to use and update `URotatingMovementComponent`
    to fit the needs of the coin collectible. Now that the coin collectible actor
    is complete, it is time to add functionality to the player so that the player
    can keep track of how many coins they have collected.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create the logic that will count the coins using `UE_LOG` and
    later implement the coin counter using UMG on the game's UI.
  prefs: []
  type: TYPE_NORMAL
- en: Logging Variables Using UE_LOG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 11*, *Blend Spaces 1D, Key Bindings, and State Machines*, we used
    and learned about the `UE_LOG` function in order to log when the player should
    throw the projectile. We then used the `UE_LOG` function in *Chapter 13*, *Enemy
    Artificial Intelligence*, to log when the player projectile hit an object. `UE_LOG`
    is a robust logging tool we can use to output important information from our C++
    functions into the `Output Log` window inside the editor when playing our game.
    Up until this point, we have only logged `FStrings` to display general text in
    the `Output Log` window to know that our functions were being called. Now, it
    is time to learn how to log variables in order to debug how many coins the player
    has collected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another useful debug function available in C++ with Unreal Engine
    4, known as `AddOnScreenDebugMessage`. You can learn more about this function
    here: [https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UEngine/AddOnScreenDebugMessage/1/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UEngine/AddOnScreenDebugMessage/1/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: When creating the `FString` syntax used by the `TEXT()` macro, we can add format
    specifiers to log different types of variables. We will only be discussing how
    to add the format specifier for integer variables.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information on how to specify other variable types by reading
    the following documentation: [https://www.ue4community.wiki/Logging#Logging_an_FString](https://www.ue4community.wiki/Logging#Logging_an_FString).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what `UE_LOG()` looks like when passing in `FString "Example Text"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you have `Log Category`, `Log Verbose Level`, and the actual `FString`,
    `"Example Text"`, to display in the log. To log an integer variable, you need
    to add `%d` to your `FString` within the `TEXT()` macro, followed by the integer
    variable name outside the `TEXT()` macro, separated by a comma. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The format specifier is identified by the `%` symbol, and each variable type
    has a designated letter that corresponds with it. In the case of integers, the
    letter `d` is used. You will be using this method of logging integer variables
    to log the number of coin collectibles the player has in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.03: Tracking the Number of Coins for the Player'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will be creating the necessary properties and functions
    that will allow you to track how many coins the player collects throughout the
    level. You will use this tracking to show the player using UMG later in this chapter.
    Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, find and open the `SuperSideScroller_Player.h` header file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `Private Access Modifier`, create a new `int` variable called `NumberofCollectables`,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This will be a private property that will keep track of the current number of
    coins the player has collected. You will be creating a public function that will
    return this integer value. We do this for safety reasons to ensure that no other
    classes can modify this value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, under the existing `public` access modifier, create a new `UFUNCTION()`
    using the `BlueprintPure` keyword called `GetCurrentNumberOfCollectables()`. This
    function will return an `int`. The following code adds this as an inline function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We are using `UFUNCTION()` and the `BlueprintPure` keyword to expose this function
    to Blueprints so that we can use it later in UMG.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare a new `void` function, under the `public` access modifier, called `IncrementNumberofCollectables()`
    that takes in a single integer parameter called `Value`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is the main function you will use to keep track of how many coins the player
    has collected. We will also add some safety measures to ensure this value is never
    negative.
  prefs: []
  type: TYPE_NORMAL
- en: With the `IncrementNumberofCollectables()` function declared, let's create the
    definition of this function inside the `SuperSideScroller_Player.cpp` source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the following code to create the definition of the `IncrementNumberofCollectables`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The main case to handle here is if the integer value that''s passed into this
    function is less than or equal to `0`. In this case, we do not want to bother
    incrementing the `NumberofCollectables` variable. Add the following code to the
    `IncrementNumberofCollectables()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This `if()` statement says that if the `value` input parameter is less than
    or equal to `0`, the function will end. With the `IncrementNumberofCollectables()`
    function returning `void`, it is perfectly okay to use the `return` keyword in
    this way.
  prefs: []
  type: TYPE_NORMAL
- en: We're adding this check of ensuring the `value` parameter that's passed into
    the `IncrementNumberofCollectables()` function is neither 0 nor negative because
    it is important to establish good coding practices; this guarantees that all possible
    outcomes are handled. In an actual development environment, there could be designers
    or other programmers who attempt to use the `IncrementNumberofCollectables()`
    function and try to pass in a negative value, or a value that equals 0\. If the
    function does not take these possibilities into account, there is potential for
    bugs later on in development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve handled the edge case where `value` is less than or equal to
    `0`, let''s continue with the function using an `else()` statement to increase
    `NumberofCollectables`. Add the following code under the `if()` statement from
    the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s log `NumberofCollectables` using `UE_LOG` and the knowledge we
    learned about logging variables. Add the following code after the `else()` statement
    to properly log `NumberofCollectables`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With this `UE_LOG()`, we are making a more robust log to track the number of
    coins. This lays out the groundwork of how the UI will work. This is because we
    are essentially logging the same information to the player through the use of
    UMG later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: With `UE_LOG()` added, all we need to do is call the `IncrementNumberofCollectables()`
    function inside the `PickableActor_Collectable` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PickableActor_Collectable.cpp` source file, add the following header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, inside the `PlayerPickedUp()` function, add the following function call
    before the `Super::PlayerPickedUp(Player)` line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now that our `PickableActor_Collectable` class is calling our player's `IncrementNumberofCollectables`
    function, recompile the C++ code and return to the Unreal Engine 4 editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the UE4 editor, open the `Output Log` window by *left-clicking* `Window`,
    and then hovering over the `Developer Tools` option. From this additional dropdown,
    select `Output Log`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, add multiple `BP_Collectable` actors to your level and then use PIE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you overlap over each coin collectible, observe the `Output Log` window
    to find that each time you collect a coin, the `Output Log` window will show you
    how many coins you've collected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the assets and code for this exercise here: [https://packt.live/36t6xM5](https://packt.live/36t6xM5).'
  prefs: []
  type: TYPE_NORMAL
- en: With this exercise completed, you have now completed half of the work needed
    to develop the UI element of tracking the number of coins collected by the player.
    The next half will be using the functionality developed in this activity inside
    UMG to show this information to the player on-screen. To do this, we need to learn
    more about UMG inside of Unreal Engine 4.
  prefs: []
  type: TYPE_NORMAL
- en: UMG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UMG, or Unreal Motion Graphics UI Designer, is Unreal Engine 4's main tool for
    creating UI for things such as menus, in-game HUD elements such as health bars,
    and other user interfaces you may want to present to the player.
  prefs: []
  type: TYPE_NORMAL
- en: In the `SuperSideScroller` game, we will only be using the `Text` widget to
    construct our `Coin Collection UI` in *Exercise 15.04,* *Creating the Coin Counter
    UI HUD Element*. We'll learn more about the `Text` widget in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Text Widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Text` widget is one of the simpler widgets that exists. This is because
    it only allows you to display text information to the user and customize the visuals
    of this text. Almost every single game uses text in one way or another to display
    information to its players. Overwatch, for example, uses a text-based UI to display
    crucial match data to its players. Without the use of text, it would be very difficult
    – maybe even impossible – to convey key pieces of statistical data to the player,
    such as total damage dealt, total time playing the game, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Text` widget appears in the `Palette` tab within UMG. When you add a `Text`
    widget to the `Canvas` panel, it will display the text `Text Block` by default.
    You can customize this text by adding your text to the `Text` parameter of the
    widget. Alternatively, you can use `Function Binding` to display more robust text
    that can reference internal or external variables. `Function Binding` should be
    used whenever you need to display information that can change; this could be text
    that represents a player''s score, how much money the player has, or in our case,
    the number of coins the player has collected:'
  prefs: []
  type: TYPE_NORMAL
- en: You will be using the `Function Binding` functionality of the `Text` widget
    to display the number of coins collected by the player using the `GetCurrentNumberofCollectables()`
    function you created in *Exercise 15.03*, *Tracking the Number of Coins for the
    Player*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the `Text` widget in the `Canvas` panel, it is time to position
    this widget where we need it to be. For this, we will take advantage of Anchors.
  prefs: []
  type: TYPE_NORMAL
- en: Anchors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anchors are used to define where a widget's desired location should be on the
    `Canvas` panel. Once defined, the `Anchor` will ensure that the widget will maintain
    this position with varying screen sizes through different platform devices such
    as phones, tablets, and computers. Without an anchor, a widget's position can
    become inconsistent between different screen resolutions, which is never desired.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about Anchors, please refer to the following documentation:
    [https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors/index.html](https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of our `Coin Collection UI` and the `Text` widget you will
    use, the `Anchor` point will be at the top-left corner of the screen. You will
    also add a position offset from this `Anchor` point so that the text is more visible
    and readable to the player. Before moving onto creating our `Coin Collection UI`,
    let's learn about `Text Formatting`, which you will use to display the current
    number of collected coins to the player.
  prefs: []
  type: TYPE_NORMAL
- en: Text Formatting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Much like the `UE_LOG()` macro available to us in C++, Blueprints offers a
    similar solution to display text and format the text to allow custom variables
    to be added to it. The `Format Text` function takes in a single text input labeled
    `Format` and returns the `Result` text out. This can then be used to display information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5: The Format Text function allows us to customize the text using
    formatted arguments that can be passed in'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_15_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.5: The Format Text function allows us to customize the text using
    formatted arguments that can be passed in'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using the `%` symbol like `UE_LOG()` does, the `Format Text` function
    uses the `{}` symbols to denote arguments that can be passed into the string.
    In-between the `{}` symbols, you need to add an argument name; this can be anything
    you want, but it should be representative of what the argument is. Refer to the
    example shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6: Here, we are passing an example integer into the formatted text'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_15_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.6: Here, we are passing an example integer into the formatted text'
  prefs: []
  type: TYPE_NORMAL
- en: The `Format Text` function only supports `Byte`, `Integer`, `Float`, `Text`,
    or `EText Gender` variable types, so if you are attempting to pass any other type
    of variable into the function as an argument, you must convert it into one of
    the supported types.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Format Text` function is also used for `Text Localization`, where you
    can support multiple languages for your game. More information about how this
    can be done in both C++ and Blueprints can be found here: [https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.html](https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: You will be using the `Format Text` function in conjunction with the `Text`
    widget in UMG in the next exercise, where we will be creating the `Coin Counter
    UI` widget to display the number of coins that have been collected by the player.
    You will also be using `Anchors` to position the `Text` widget at the top-left
    corner of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.04: Creating the Coin Counter UI HUD Element'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will be creating the UMG UI asset, which will display
    and update the number of coins collected by the player. You will use the `GetCurrentNumberofCollectables()`
    inline function you created in *Exercise 15.02*, *Creating the PickableActor_Collectable
    Class*, to display this value on the screen using a simple `Text` widget. Follow
    these steps to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a new folder inside the `Content Browser` window called
    `UI`. Do this by *right-clicking* on the `Content` folder at the top of the browser
    directory in the editor and selecting `New Folder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the new `/Content/UI` directory, *right-click* and instead of selecting
    `Blueprint Class`, hover over the `User Interface` option at the bottom of this
    list and *left-click* the `Widget Blueprint` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name this new `Widget Blueprint` `BP_UI_CoinCollection`, and then *double-left-click*
    the asset to open the UMG editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, the `Widget` panel is empty, and you will find an empty hierarchy
    on the left-hand side, as shown in the following screenshot:![Figure 15.7: The
    Widget panel Hierarchy outlines how the different'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: elements of the UI are layered with one another
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_15_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.7: The Widget panel Hierarchy outlines how the different elements
    of the UI are layered with one another'
  prefs: []
  type: TYPE_NORMAL
- en: Above the `Hierarchy` tab is the `Palette` tab, which lists all the available
    widgets you can use inside your UI. We will only focus on the `Text` widget, which
    is listed under the `Common` category. Do not mistake this option with the Rich
    Text Block widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more detailed reference to all the available `Widgets` inside UMG, please
    read the following documentation from Epic Games: [https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/WidgetTypeReference/index.html](https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/WidgetTypeReference/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `Text` widget to the `UI` panel by either *left-clicking* and dragging
    the `Text` widget from the `Palette` tab to the `Hierarchy` tab underneath the
    `Canvas` panel root, or by *left-clicking* and dragging the `Text` widget directly
    into the `Canvas` panel itself in the middle of the UMG editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before changing the text of this widget, we need to update its anchor, position,
    and font size in order to fit the needs we have for displaying the information
    to the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Text` widget selected, you will see many options under its `Details`
    panel to customize this text. The first thing to do here is anchor the `Text`
    widget to the top-left corner of the `Canvas` panel. *Left-click* on the `Anchors`
    dropdown and select the top-left anchoring option, as shown in the following screenshot:![Figure
    15.8: By default, there are options to anchor a widget'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: at different locations of the screen
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_15_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.8: By default, there are options to anchor a widget at different
    locations of the screen'
  prefs: []
  type: TYPE_NORMAL
- en: Anchoring allows the widget to maintain its desired location within the `Canvas`
    panel, regardless of varying screen sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the `Text` widget is anchored to the top-left corner, we need to set
    its relative position to this anchor so that there is an offset for better positioning
    and readability of the text.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Details` panel, underneath the `Anchors` option, are parameters for
    `Position X` and `Position Y`. Set both these parameters to `100.0f`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, enable the `Size To Content` parameter so that the size of the `Text`
    widget will automatically resize itself, depending on the size of the text it
    is displaying, as shown in the following screenshot:![Figure 15.9: The Size To
    Content parameter will ensure that the Text widget'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: will display its full content and not be cut off
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_15_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.9: The Size To Content parameter will ensure that the Text widget
    will display its full content and not be cut off'
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do here is to update the size of the font used for
    the `Text` widget. Underneath the `Appearance` tab of the `Details` panel for
    the `Text` widget, you will find the `Size` parameter. Set this value to `48`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final `Text` widget will look like this:![Figure 15.10: The Text widget
    is now anchored to the top-left of the Canvas panel, with a small relative offset
    and a larger font for better readability for the player'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_15_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.10: The Text widget is now anchored to the top-left of the Canvas
    panel, with a small relative offset and a larger font for better readability for
    the player'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the `Text` widget positioned and sized the way we need it to
    be, let's add a new binding to the text so that it will automatically update and
    match the value of the number of collectibles the player has.
  prefs: []
  type: TYPE_NORMAL
- en: With the `Text` widget selected, find the `Text` parameter in its `Details`
    panel, under the `Content` category. There, you will find the `Bind` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Left-click* the `Bind` option and select `Create Binding`. When doing this,
    the new `Function Binding` will be created automatically and be given the name
    `GetText_0`. Please refer to the following screenshot:![Figure 15.11: It is important
    to always rename the bind functions'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: because their default names are too generic
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_15_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.11: It is important to always rename the bind functions because their
    default names are too generic'
  prefs: []
  type: TYPE_NORMAL
- en: Rename this function `Get Number of Collectables`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before continuing with this function, create a new object reference variable
    called `Player` that''s of the `SuperSideScroller_Player` type. Make this variable
    `Public` and exposable on spawn by enabling both the `Instance Editable` and `Expose
    on Spawn` parameters of the variable, as shown in the following screenshot:![Figure
    15.12: The Player variable should now have the Instance Editable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: and Expose on Spawn parameters enabled
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_15_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.12: The Player variable should now have the Instance Editable and
    Expose on Spawn parameters enabled'
  prefs: []
  type: TYPE_NORMAL
- en: By making the `Player` variable `Public` and exposed on spawn, you will be able
    to assign this variable when creating the widget and adding it to the screen.
    We will do this in *Exercise 15.05*, *Adding the Coin Counter UI to the Player
    Screen*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a reference variable to `SuperSideScroller_Player`, let's continue
    with the `Get Number of Collectables` bind function.
  prefs: []
  type: TYPE_NORMAL
- en: Add a `Getter` of the `Player` variable to the `Get Number of Collectables`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From this variable, *left-click* and drag and from the context-sensitive drop-down
    menu, and find and select the `Get Current Number of Collectables` function. Please
    refer to the following screenshot:![Figure 15.13: The Get Current Numberof Collectables
    C++ function'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: you created in Exercise 15.03
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_15_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.13: The Get Current Numberof Collectables C++ function you created
    in Exercise 15.03'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, *left-click* and drag out the `Return Value` text parameter of the `Get
    Number of Collectables` to `Return Node`. From the context-sensitive drop-down
    menu, search for and select the `Format Text` option, as shown in the following
    screenshot:![Figure 15.14: Now, we can create customized and formatted text'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: to suit the needs of the text
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_15_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.14: Now, we can create customized and formatted text to suit the
    needs of the text'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `Format Text` function, add the following text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Please refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.15: Now, there is a new input argument to the formatted'
  prefs: []
  type: TYPE_NORMAL
- en: text that we can use to display custom information
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_15_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.15: Now, there is a new input argument to the formatted text that
    we can use to display custom information'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that using the `{}` symbols denotes a text argument that allows you
    to pass variables into the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, connect the int `Return Value` of the `GetCurrentNumberofCollectables()`
    function to the wildcard `coins` input pin of the `Format Text` function, as shown
    here:![Figure 15.16: Now, the Text widget will update automatically based on the
    updated value returned from the Get Current Numberof Collectables function'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_15_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.16: Now, the Text widget will update automatically based on the updated
    value returned from the Get Current Numberof Collectables function'
  prefs: []
  type: TYPE_NORMAL
- en: Compile and save the `BP_UI_CoinCollection` widget Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the assets and code for this exercise here: [https://packt.live/3eQJjTU](https://packt.live/3eQJjTU).'
  prefs: []
  type: TYPE_NORMAL
- en: With this exercise completed, you have created the `UI UMG` widget needed to
    display the current number of coins collected by the player. By using the `GetCurrentNumberofCollectables()`
    C++ function and the binding functionality of the `Text` widget, the UI will always
    update its value based on the number of coins collected. In the next exercise,
    we will add this UI to the player's screen, but first, we'll briefly learn about
    how to add and remove UMG from the player screen.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and Creating UMG User Widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created the Coin Collection UI in UMG, it is time to learn
    how to add and remove the UI to and from the player screen. By adding the Coin
    Collection UI to the player screen, the UI becomes visible to the player and can
    be updated as the player collects coins.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Blueprints, there is a function called `Create Widget`, as shown in the
    following screenshot. Without a class assigned, it will be labeled `Construct
    None`, but do not let this confuse you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.17: The Create widget as it is by default, without a class applied'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_15_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.17: The Create widget as it is by default, without a class applied'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function requires the class of the `User` widget to be created and requires
    a `Player Controller` that will be referenced as the owning player of this UI.
    This function then returns the spawned user widget as its `Return Value`, where
    you can then add to the player''s viewport using the `Add to Viewport` function.
    The `Create Widget` function only instantiates the widget object; it does not
    add this widget to the player''s screen. It is the `Add to Viewport` function
    that makes this widget visible on the player''s screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.18: Add to Viewport function with ZOrder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_15_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.18: Add to Viewport function with ZOrder'
  prefs: []
  type: TYPE_NORMAL
- en: 'The viewport is the game screen that overlays your view of the game world,
    and it uses what is called `ZOrder` to determine the overlay depth in cases where
    multiple UI elements need to overlap above or below one another. By default, the
    `Add to Viewport` function will add the `User` widget to the screen and make it
    fill the entire screen; that is, unless the `Set Desired Size In Viewport` function
    is called to set the size that it should fill manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.19: The Size parameter determines the desired size of the passed
    in User widget'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_15_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.19: The Size parameter determines the desired size of the passed
    in User widget'
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++, you also have a function called `CreateWidget()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `CreateWidget()` function is available through the `UserWidget` class, which
    can be found in `/Engine/Source/Runtime/UMG/Public/Blueprint/UserWidget.h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this can be found in *Chapter 8*, *User Interfaces*, where you
    used the `CreateWidget()` function to create `BP_HUDWidget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Refer back to *Chapter 8*, *User Interfaces*, and *Exercise 8.06,* *Creating
    the Health Bar C++ Logic*, for more information regarding the `CreateWidget()`
    function in C++.
  prefs: []
  type: TYPE_NORMAL
- en: This function works almost identically to its Blueprint counterpart because
    it takes in the `Owning Object` parameter, much like the `Owning Player` parameter
    of the Blueprint function, and it requires the `User Widget` class to be created.
    The C++ `CreateWidget()` function also takes in an `FName` parameter to represent
    the widget's name.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about the methods to use to add UI to the player screen,
    let's put this knowledge to the test. In the following exercise, you will be implementing
    the `Create Widget` and `Add to Viewport` Blueprint functions so that we can add
    the coin collection UI that we created in *Exercise 15.04*, *Creating the Coin
    Counter UI HUD Element*, to the player screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.05: Adding the Coin Counter UI to the Player Screen'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will be creating a new `Player Controller` class so that
    you can use the player controller to add the `BP_UI_CoinCollection` widget Blueprint
    to the player''s screen. From there, you will also create a new `Game Mode` class
    and apply this game mode to the `SuperSideScroller` project. Perform the following
    steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Unreal Engine 4 editor, navigate to `File` and then `New C++ Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Choose Parent Class` dialog window, find and select the `Player Controller`
    option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new `Player Controller` class `SuperSideScroller_Controller` and then
    *left-click* the `Create Class` button. Visual Studio will automatically generate
    and open the source and header files for the `SuperSideScroller_Controller` class,
    but for now, we will stay inside the Unreal Engine 4 editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Content Browser` window, under the `MainCharacter` folder directory,
    create a new folder called `PlayerController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `PlayerController` folder, *right-click* and create a new `Blueprint
    Class` using the new `SuperSideScroller_Controller` class. Please refer to the
    following screenshot:![Figure 15.20: Finding the new SuperSideScroller_Controller
    class'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: to create a new Blueprint from
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_15_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.20: Finding the new SuperSideScroller_Controller class to create
    a new Blueprint from'
  prefs: []
  type: TYPE_NORMAL
- en: Name this new Blueprint `BP_SuperSideScroller_PC` and then *double-left-click*
    the asset to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add the `BP_UI_CoinCollection` widget to the screen, we need to use the `Add
    to Viewport` function and the `Create Widget` function. We want the UI to be added
    to the player's screen after the player character has been `Possessed` by the
    player controller.
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* inside the Blueprint graph and from the context-sensitive menu,
    find the `Event On Possess` option and *left-click* to add it to the graph. Please
    refer to the following screenshot:![Figure 15.21: The Event On Possess option
    will be called each time'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: this controller class possesses a new pawn
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_15_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.21: The Event On Possess option will be called each time this controller
    class possesses a new pawn'
  prefs: []
  type: TYPE_NORMAL
- en: The `Event On Possess` event node returns `Possessed Pawn`. We will use this
    pawn to pass into our `BP_UI_CoinCollection UI Widget`, but first, we need to
    `Cast To` the `SuperSideScroller_Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: '*Left-click* and drag from the output the `Possessed Pawn` parameter of the
    `Event On Possess` node. Then, search for and find the `Cast to SuperSideScroller_Player`
    node. Please refer to the following screenshot:![Figure 15.22: We need to Cast
    To SuperSideScroller_Player to ensure we are casting to the right player character
    class'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_15_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.22: We need to Cast To SuperSideScroller_Player to ensure we are
    casting to the right player character class'
  prefs: []
  type: TYPE_NORMAL
- en: Now, *right-click* and search for the `Create Widget` function to add it to
    the Blueprint graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the drop-down class parameter, find and assign the `BP_UI_CoinCollection`
    asset you created in *Exercise 15.04*, *Creating the Coin Counter UI HUD Element*.
    Please refer to the following screenshot:![Figure 15.23: The Create Widget function
    will create a new UI object'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: using the UMG class passed into it
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_15_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.23: The Create Widget function will create a new UI object using
    the UMG class passed into it'
  prefs: []
  type: TYPE_NORMAL
- en: After updating the `Class` parameter to the `BP_UI_CoinCollection` class, you
    will notice that the `Create Widget` function will update to show the `Player`
    variable you created, set to `Exposed on Spawn`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* in the Blueprint graph to search for and find the `Self` reference
    variable from the context-sensitive drop-down menu. Connect the `Self` object
    variable to the `Owning Player` parameter of the `Create Widge`t function, as
    shown in the following screenshot:![Figure 15.24: The Owning Player input parameter
    is of the Player Controller type'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_15_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.24: The Owning Player input parameter is of the Player Controller
    type'
  prefs: []
  type: TYPE_NORMAL
- en: The `Owning Player` parameter refers to the `Player Controller` type that will
    show and own this UI object. Since we are adding this UI to the `SuperSideScroller_Controller`
    Blueprint, we can just use the `Self` reference variable to pass into the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, pass in the returned `SuperSideScroller_Player` variable from the `Cast`
    node to the `Player` input node of the `Create Widget` function. Then, connect
    the execution pins of the `Cast` node and the `Create Widget` function, as shown
    in the following screenshot:![Figure 15.25: If the Cast To SuperSideScroller_Player
    is valid, we can create the BP_UI_CoinCollection widget and pass in the player
    that has been possessed'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_15_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.25: If the Cast To SuperSideScroller_Player is valid, we can create
    the BP_UI_CoinCollection widget and pass in the player that has been possessed'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/3f89m99](https://packt.live/3f89m99).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* inside the Blueprint graph again to search and find the `Add
    to Viewport` function so that you can place it in the graph.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the output `Return Value` parameter of the `Create Widget` function
    to the `Target` input parameter of the `Add to Viewport` function; do not change
    the `ZOrder` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, connect the execution pins of the `Create Widget` and `Add to Viewport`
    functions, as shown here:![Figure 15.26: After creating the BP_UI_CoinCollection
    widget, we can'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: add it to the player viewport
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_15_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.26: After creating the BP_UI_CoinCollection widget, we can add it
    to the player viewport'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/2UwufBd](https://packt.live/2UwufBd).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the player controller adds the `BP_UI_CoinCollection` widget to the
    player's viewport, we need to create a `GameMode` Blueprint and apply both the
    `BP_SuperSideScroller_MainCharacter` and `BP_SuperSideScroller_PC` classes to
    this game mode.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Content Browser` window, create a new folder by *right-clicking* the
    `Content` folder and selecting `New Folder`. Name this folder `GameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, *right-click* and select `Blueprint Class` to begin creating the game
    mode Blueprint. From the `Pick Parent Class` dialog window, search for and find
    `SuperSideScrollerGameMode` under `All Classes`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name this new `GameMode` Blueprint `BP_SuperSideScroller_GameMode`. *Double-left-click*
    this asset to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `GameMode` Blueprint contains a list of classes that you can customize with
    your unique classes. For now, we will only worry about `Player Controller Class`
    and `Default Pawn Class`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Left-click* the `Player Controller Class` dropdown to find and select the
    `BP_SuperSideScroller_PC` Blueprint you created earlier in this exercise.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, *left-click* the `Default Pawn Class` dropdown to find and select the
    `BP_SuperSideScroller_MainCharacter` Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have a custom `GameMode` that utilizes our custom `Player Controller`
    and `Player Character` classes, let's add this game mode to the `Project Settings`
    window so that the game mode is used by default when using PIE and when cooking
    builds of the project.
  prefs: []
  type: TYPE_NORMAL
- en: From the Unreal Engine 4 editor, navigate to the `Edit` option at the top of
    the screen. *Left-click* this option and from the drop-down menu, find and select
    the `Project Settings` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the left-hand side of the `Project Settings` window, you are provided with
    a list of categories divided into sections. Under the `Project` section, *left-click*
    the `Maps & Modes` category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Maps & Modes` section, you have a handful of parameters related to your
    project's default maps and game mode. At the top of this section, you have the
    `Default GameMode` option. *Left-click* this dropdown to find and select the `SuperSideScroller_GameMode`
    Blueprint you created earlier in this exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Changes made to the `Maps & Modes` section are automatically saved and written
    to the `DefaultEngine.ini` file, which can be found in your project's `Config`
    folder. `Default GameMode` can be overwritten per level by updating the `GameMode
    Override` parameter, which can be found in the `World Settings` window of your
    level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Close the `Project Settings` window and return to your level. Use PIE and start
    collecting coins. Observe that the `BP_UI_CoinCollection` widget is shown and
    updated each time you collect a coin, as shown in the following screenshot:![Figure
    15.27: Now, every coin you collect will appear on the player UI'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_15_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.27: Now, every coin you collect will appear on the player UI'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the assets and code for this exercise here: [https://packt.live/2JRfSFz](https://packt.live/2JRfSFz).'
  prefs: []
  type: TYPE_NORMAL
- en: With this exercise complete, you have created the `UI UMG` widget needed to
    display the current number of coins collected by the player. By using the `GetCurrentNumberofCollectables()`
    C++ function and the binding functionality of the `Text` widget, the UI will always
    update its value based on the number of coins collected.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have focused on the collectible coin and allowing players to collect
    these coins and add the total coins collected to the player's UI. Now, we will
    focus on the potion power-up and granting movement speed and jump height increases
    to the player for a short period of time. To implement this functionality, we
    first need to study timers.
  prefs: []
  type: TYPE_NORMAL
- en: Timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Timers in Unreal Engine 4 allow you to perform actions after a delay or every
    X number of seconds. In the case of the `SuperSideScroller` potion power-up, a
    timer will be used to restore the player's movement and jump to their defaults
    after 8 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In Blueprints, you can use a Delay node in addition to Timer Handles to achieve
    the same results. However, in C++, Timers are the best means to achieve delays
    and reoccurring logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Timers are managed by `Timer Manager`, or `FTimerManager`, which exists in
    the `UWorld` object. There are two main functions that you will be using from
    the `FTimerManager` class, called `SetTimer()` and `ClearTimer()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that, in both functions, there is a required `FTimerHandle`.
    This handle is used to control the timer you have set. Using this handle, you
    can pause, resume, clear, and even extend the timer.
  prefs: []
  type: TYPE_NORMAL
- en: The `SetTimer()` function also has other parameters to help you customize this
    `Timer` when initially setting it. The callback function will be called after
    the `Timer` has been completed, and if the `InbLoop` parameter is `True`, it will
    continue to call the callback function indefinitely, until the timer has been
    stopped. The `InRate` parameter is the duration of the timer itself, while `InFirstDelay`
    is an initial delay that's applied to the timer before it begins its timer for
    `InRate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The header file for the `FTimerManager` class can be found here: `/Engine/Source/Runtime/Engine/Public/TimerManager.h`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about timers and `FTimerHandle` by reading the documentation
    here: [https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Timers/index.html](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Timers/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercise, you will create your own `FTimerHandle` in the `SuperSideScroller_Player`
    class and use it to handle to control how long the effects of the potion power-up
    last on the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.06: Adding the Potion Power-Up Behavior to the Player'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will be creating the logic behind the potion power-up
    and how it will affect the player character. You will take advantage of timers
    and timer handles to ensure that the power-up effects only last for a short duration.
    Follow these steps to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, navigate to and open the `SuperSideScroller_Player.h` header
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under `our Private Access Modifier`, add a new variable of the `FTimerHandle`
    type and name it `PowerupHandle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This timer handle will be responsible for keeping track of how much time has
    elapsed since it was initiated. This will allow us to control how long the potion
    power-up's effects will last.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a Boolean variable under our `Private Access Modifier` called `bHasPowerupActive`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We will use this Boolean variable when updating the `Sprint()` and `StopSprinting()`
    functions to ensure we update the player's sprint movement speed appropriately
    based on whether the power-up is active.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, declare a new void function called `IncreaseMovementPowerup()` under
    our `Public Access Modifier`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is the function that will be called from the potion power-up class to enable
    the effects of the power-up for the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to create a function that handles when the power-up effects
    end. Create a function called `EndPowerup()` under `Protected Access Modifier`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: With all the necessary variables and functions declared, it's time to start
    defining these new functions and handling the power-up effects on the player.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `SuperSideScroller_Player.cpp` source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, add the header file `#include "TimerManager.h"` to the top of the source
    file; we will need this class in order to use `Timers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the `IncreaseMovementPowerup()` function by adding the following code
    to the source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When this function is called, the first thing we need to do is set the `bHasPowerupActive`
    variable to `true`. Add the following code to the `IncreaseMovementPowerup()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following code to increase both the `MaxWalkSpeed` and `JumpZVelocity`
    components of the player character movement component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are changing `MaxWalkSpeed` from the default `300.0f` value to `500.0f`.
    As you may recall, the default sprinting speed is also `500.0f`. We will address
    this later in this activity to increase the sprinting speed when the power-up
    is active.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take advantage of timers, we need to get a reference to the `UWorld` object.
    Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As we've done many times before in this project, we're using the `GetWorld()`
    function to get a reference to the `UWorld` object and saving this reference in
    its variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the reference to the `World` object and have performed a validity
    check, it is safe to use the `TimerManager` to set the power-up timer. Add the
    following code within the `if()` statement shown in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, you are using the `TimerManager` class to set a timer. The `SetTimer()`
    function takes in the `FTimerHandle` component to use; in this case, the `PowerupHandle`
    variable you created. Next, we need to pass in a reference to the player class
    by using the `this` keyword. Then, we need to provide the callback function to
    call after the timer has ended, which in this case is the `&ASuperSideScroller_Player::EndPowerup`
    function. `8.0f` represents the duration of the timer; feel free to adjust this
    as you see fit, but for now, 8 seconds is fine. Lastly, there is the parameter
    that determines whether this timer should loop; in this case, it should not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the function definition for the `EndPowerup()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to do when the `EndPowerup()` function is called is set the
    `bHasPowerupActive` variable to `false`. Add the following code within the `EndPowerup()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, change the `MaxWalkSpeed` and `JumpZVelocity` parameters of the character
    movement component back to their default values. Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are changing both the `MaxWalkSpeed` and `JumpZVelocity` parameters
    of the character movement component to their default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, to take advantage of the timers and to clear the timer to handle `PowerupHandle`,
    we need to get a reference to the `UWorld` object. Add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can add the code to clear the timer handle''s `PowerupHandle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: By using the `ClearTimer()` function and passing in `PowerupHandle`, we are
    ensuring that this timer is no longer valid and will no longer affect the player.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created the functions that handle the power-up effects and
    the timer associated with the effects, we need to update both the `Sprint()` and
    `StopSprinting()` functions so that they also take into account the speed of the
    player when the power-up is active.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Sprint()` function to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are updating the `Sprint()` function to take into account whether
    `bHasPowerupActive` is true. If this variable is true, then we increase `MaxWalkSpeed`
    while sprinting from `500.0f` to `900.0f`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If `bHasPowerupActive` is false, then we increase `MaxWalkSpeed` to `500.0f`,
    as we did by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `StopSprinting()` function to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are updating the `StopSprinting()` function to take into account whether
    `bHasPowerupActive` is true. If this variable is true, then we set the `MaxWalkSpeed`
    value to `500.0f` instead of `300.0f`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If `bHasPowerupActive` is false, then we set `MaxWalkSpeed` to `300.0f`, as
    we did by default.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, all we need to do is recompile the C++ code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the assets and code for this exercise here: [https://packt.live/3eP39yL](https://packt.live/3eP39yL).'
  prefs: []
  type: TYPE_NORMAL
- en: With this exercise complete, you have created the potion power-up effects within
    the player character. The power-up increases both the default movement speed of
    the player and increases their jump height. Moreover, the effects of the power-up
    increase the sprinting speed. By using timer handles, you were able to control
    how long the power-up effect would last.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to create the potion power-up actor so that we can have a representation
    of this power-up in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 15.03: Creating the Potion Power-Up Actor'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the `SuperSideScroller_Player` class handles the effects of the potion
    power-up, it''s time to create the potion power-up class and Blueprint. The aim
    of this activity is to create the potion power-up class, inherit from the `PickableActor_Base`
    class, implement the overlap functionality to grant the movement effects that
    you implemented in *Exercise 15.06*, *Adding the Potion Power-Up Behavior to the
    Player*, and to create the Blueprint actor for the potion power-up. Perform these
    steps to create the potion power-up class and to create the potion Blueprint actor:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C++ class that inherits from the `PickableActor_Base` class and
    name this new class `PickableActor_Powerup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the override function declarations for both the `BeginPlay()` and `PlayerPickedUp()`
    functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the function definition for the `BeginPlay()` function. Within the `BeginPlay()`
    function, add the call to the parent class function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the function definition for the `PlayerPickedUp()` function. Within the
    `PlayerPickedUp()` function, add the call to the `PlayerPickedUp()` parent class
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add the necessary `#include` file for the `SuperSideScroller_Player` class
    so that we can reference the player class and its functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `PlayerPickedUp()` function, use the `Player` input parameter of the
    function itself to make the function call to `IncreaseMovementPowerup()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From `Epic Games Launcher`, find the `Action RPG` project from the `Learn` tab,
    under the `Games` category. Use this to create and install a new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Migrate the `A_Character_Heal_Mana_Cue` and `SM_PotionBottle` assets, as well
    as all of their referenced assets, from the `Action RPG` project to your `SuperSideScroller`
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder in the `Content Browser` window within the `PickableItems`
    directory called `Powerup`. Create a new Blueprint within this directory based
    on the `PickableActor_Powerup` class and name this asset `BP_Powerup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `BP_Powerup`, update the `MeshComp` component in order to use the `SM_PotionBottle`
    static mesh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add `A_Character_Heal_Mana_Cue`, which you imported as the `Pickup Sound`
    parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, update the `RotationComp` component so that the actor will rotate 60
    degrees per second around the `Pitch` axis and rotate 180 degrees per second around
    the `Yaw` axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `BP_Powerup` to your level and use PIE to observe the results when overlapping
    with the power-up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.28: The potion power-up now has a nice visual representation and
    can be overlapped by the player to enable its power-up effects'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_15_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.28: The potion power-up now has a nice visual representation and
    can be overlapped by the player to enable its power-up effects'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: With this activity complete, you were able to put your knowledge to the test
    in terms of creating a new C++ class that inherits from the `PickableActor_Base`
    class and overrides the `PlayerPickedUp()` function to add custom logic. By adding
    the call to the `IncreaseMovementPowerup()` function from the player class, you
    were able to add the movement power-up effects to the player when overlapping
    with the actor. Then, by using a custom mesh, material, and audio assets, you
    were able to bring the Blueprint actor to life from the `PickableActor_Powerup`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created the coin collectible and the potion power-up, we need
    to implement a new gameplay feature into the project: the `Brick` class. In games
    such as Super Mario, bricks contain hidden coins and power-ups for the players
    to find. These bricks also serve as a means of reaching elevated platforms and
    areas within the level. In our `SuperSideScroller` project, the `Brick` class
    will serve the purpose of containing hidden coin collectibles for the player,
    and as a means of allowing the player to reach areas of the level by using the
    bricks as paths to access hard-to-reach locations. So, in the next section, we
    will create the `Brick` class that needs to be broken to find the hidden coins.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.07: Creating the Brick Class'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have created the coin collectible and the potion power-up, it is
    time to create the `Brick` class, which will contain hidden coins for the player.
    The brick is the final gameplay element of the `SuperSideScroller` project. In
    this exercise, you will be creating the `Brick` class, which will be used as part
    of the platforming mechanic of the `SuperSideScroller` game project, but also
    as a means to hold collectibles for players to find. Follow these steps to create
    this `Brick` class and its Blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Unreal Engine 4 editor, navigate to `File` and then `New C++ Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Choose Parent Class` dialog window, find and select the `Actor` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name this class `SuperSideScroller_Brick` and *left-click* `Create Class`. Visual
    Studio and Unreal Engine will recompile the code and open this class for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, the `SuperSideScroller_Brick` class comes with the `Tick()` function,
    but we will not need this function for the `Brick` class. Remove the function
    declaration for `Tick()` from the `SuperSideScroller_Brick.h` header file and
    remove the function definition from the `SuperSideScroller_Brick.cpp` source file
    before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the `Private Access Modifier` for the `SuperSideScroller_Brick.h` file,
    add the following code to declare a new `UStaticMeshComponent* UPROPERTY()` function
    to represent the brick in our game world:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create a `UBoxComponent UPROPERTY()` that will handle the
    collision with the player character. Add the following code to add this component
    under our `Private Access Modifier`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `UFUNCTION()` declaration for the `OnHit()` function under our `Private
    Access Modifier`. This will be used to determine when `UBoxComponent` is hit by
    the player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Recall that you used the `OnHit()` function when developing the `PlayerProjectile`
    class in *Chapter 13*, *Enemy Artificial Intelligence*, for this project. Please
    review that chapter for more information about the `OnHit()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new Boolean `UPROPERTY()` under our `Private Access Modifier`
    using the `EditAnywhere` keyword called `bHasCollectable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This Boolean will determine whether the brick contains a coin collectible for
    the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need a variable that holds how many coin collectibles are available
    within this brick for the player. We will do this by creating an integer variable
    called `Collectable Value`. Make this a `UPROPERTY()`, under the `private access
    modifier`, with the `EditAnywhere` keyword, and give it a default value of `1`,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The brick will need to contain a unique sound and particle system so that it
    has a nice layer of polish for when the brick is destroyed by the player. We'll
    add these properties next.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Public Access Modifier` in the `SuperSideScroller_Brick.h` header
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, create a new `UPROPERTY()` using the `EditAnywhere` and `BlueprintReadOnly`
    keywords for a variable of the `USoundBase` class. Name this variable `HitSound`,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a new `UPROPERTY()` using the `EditAnywhere` and `BlueprintReadOnly`
    keywords for a variable of the `UParticleSystem` class. Make sure to put this
    under the `public access modifier`, and name this variable `Explosion`, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have all the necessary properties for the `Brick` class, let's move
    onto the `SuperSideScroller_Brick.cpp` source file, where we will initialize the
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the following `#include` directories for `StaticMeshComponent`
    and `BoxComponent`. Add the following code to the `#include` list of the source
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'First, initialize the `BrickMesh` component by adding the following code to
    the `ASuperSideScroller_Brick::ASuperSideScroller_Brick()` constructor function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `BrickMesh` component should have collision so that the player can
    walk on top of it for platforming gameplay purposes. To ensure this occurs by
    default, add the following code to set the collision to `"BlockAll"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, the `BrickMesh` component will serve as the root component of the `Brick`
    actor. Add the following code to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the following code to the constructor function to initialize our `BrickCollision
    UBoxComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the `BrickMesh` component, the `BrickCollision` component will also
    need to have its collision set to `"BlockAll"` in order to receive the `OnHit()`
    callback events we will be adding later in this exercise. Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `BrickCollision` component needs to be attached to the `BrickMesh`
    component. We can do this by adding the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can finish the initialization of the `BrickCollision` component,
    we need to add the function definition for the `OnHit()` function. Add the following
    definition to the source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the `OnHit()` function defined, we can assign the `OnComponentHit`
    callback to the `BrickCollision` component. Add the following code to the constructor
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Compile the C++ code for the `SuperSideScroller_Brick` class and return to the
    Unreal Engine 4 editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Content Browser` window, *right-click* on the `Content` folder and select
    the `New Folder` option. Name this folder `Brick`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* inside the `Brick` folder and select `Blueprint Class`. From
    the `All Classes` search bar in the `Pick Parent Class` dialog window, search
    for and select the `SuperSideScroller_Brick` class.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name this new Blueprint `BP_Brick`, and then *double-left-click* the asset to
    open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `BrickMesh` component from the `Components` tab and set its `Static
    Mesh` parameter to the `Shape_Cube` mesh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `BrickMesh` component still selected, set the `Element 0` material
    parameter to `M_Brick_Clay_Beveled`. `M_Brick_Clay_Beveled` is a material provided
    by Epic Games by default when creating a new project. It can be found within the
    `StarterContent` directory, in the `Content Browser` window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last thing we need to do with the `BrickMesh` component is to adjust its
    scale so that it fits the needs of the player character, as well as the platforming
    mechanics of the `SuperSideScroller` game project.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `BrickMesh` component selected, make the following change to its `Scale`
    parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Now that the `BrickMesh` component is `75%` of its normal size, the `Brick`
    actor will become more manageable for us as designers when we place the actor
    into the game world, as well as when we're developing interesting platforming
    sections within the level.
  prefs: []
  type: TYPE_NORMAL
- en: The final step here is to update the location of the `BrickCollision` component
    so that it only has some of its collision sticking out from the bottom of the
    `BrickMesh` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the `BrickCollision` component from the `Components` tab and update
    its `Location` parameter to the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BrickCollision` component should now be positioned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.29: Now, the BrickCollision component is just barely outside'
  prefs: []
  type: TYPE_NORMAL
- en: the BrickMesh component
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_15_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.29: Now, the BrickCollision component is just barely outside the
    BrickMesh component'
  prefs: []
  type: TYPE_NORMAL
- en: We are making this adjustment to the position of the `BrickCollision` component
    so that the player can only hit `UBoxComponent` when jumping underneath the brick.
    By making it slightly outside of the `BrickMesh` component, we can control this
    better and ensure that this component cannot be hit by the player in any other
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the assets and code for this exercise here: [https://packt.live/3kr7rh6](https://packt.live/3kr7rh6).'
  prefs: []
  type: TYPE_NORMAL
- en: With this exercise complete, you were able to create the base framework for
    the `SuperSideScroller_Brick` class and put together the Blueprint actor to represent
    the brick in the game world. By adding a cube mesh and brick material, you added
    a nice visual polish to the brick. In the following exercise, you will add the
    remaining C++ logic to the brick. This will allow the player to destroy the brick
    and obtain a collectible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.08: Adding the Brick Class C++ Logic'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous exercise, you created the base framework for the `SuperSideScroller_Brick`
    class by adding the necessary components and creating the `BP_Brick` Blueprint
    actor. In this exercise, you will add on top of the C++ code of *Exercise 15.07*,
    *Creating the Brick Class*, to grant logic to the `Brick` class. This will allow
    the brick to give players coin collectibles. Perform the following steps to accomplish
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we need to create a function that will add the collectible to the
    player. Add the following function declaration to the `SuperSideScroller_Brick.h`
    header file, under our `Private Access Modifier`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: We want to pass in a reference to the `SuperSideScroller_Player` class so that
    we can call the `IncrementNumberofCollectables()` function from that class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a void function declaration called `PlayHitSound()` under our
    `Private Access Modifier`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The `PlayHitSound()` function will be responsible for spawning the `HitSound`
    property you created in *Exercise 15.07*, *Creating the Brick Class*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, create another void function declaration called `PlayHitExplosion()`
    under our `Private Access Modifier`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The `PlayHitExplosion()` function will be responsible for spawning the `Explosion`
    property you created in *Exercise 15.07*, *Creating the Brick Class*.
  prefs: []
  type: TYPE_NORMAL
- en: With the remaining functions needed for the `SuperSideScroller_Brick` class
    declared in the header file, let's move on and define these functions inside the
    source file.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the `SuperSideScroller_Brick.cpp` source file, add the following
    `#includes` to the list of `include` directories that already exist for this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The includes for the `World` and `GameplayStatics` classes are necessary to
    spawn both the `HitSound` and the `Explosion` effects for the brick. Including
    the `SuperSideScroller_Player` class is required to make the call to the `IncrementNumberofCollectables()`
    class function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the function definition for the `AddCollectable()` function.
    Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, make the call to the `IncrementNumberofCollectables()` function by using
    the `Player` function input parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `PlayHitSound()` function, you will need to get a reference to the
    `UWorld*` object and verify whether the `HitSound` property is valid before making
    the function call to `SpawnSoundAtLocation` from the `UGameplayStatics` class.
    This is a process you have done many times, so this is the entire function code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the `PlayHitSound()` function, the `PlayHitExplosion()` function
    will work in an almost similar way, and it''s a process you have done many times
    in this project. Add the following code to create the function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: With these functions defined, let's update the `OnHit()` function so that if
    the player does hit the `BrickCollision` component, we can spawn `HitSound` and
    `Explosion`, and also add a coin collectible to the player's collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in the `OnHit()` function, create a new variable called `Player` of
    the `ASuperSideScroller_Player` type that equals the `Cast` of the `OtherActor`
    input parameter of the function, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we only want to continue with this function if `Player` is valid and
    `bHasCollectable` is `True`. Add the following `if()` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'If the conditions in the `if()` statement are met, that is when we need to
    make the calls to the `AddCollectable()`, `PlayHitSound()`, and `PlayHitExplosion()`
    functions. Make sure to also pass in the `Player` variable inside the `AddCollectable()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the function call to destroy the brick inside of the `if()` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: With the `OnHit()` function defined as we need, recompile the C++ code but do
    not return to the Unreal Engine 4 editor just yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the VFX and SFX of the brick''s explosion, we will need to migrate assets
    from two separate projects available to us from `Epic Games Launcher`: the `Blueprints`
    project and the `Content Examples` project.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using your knowledge from previous exercises, download and install these projects
    using engine version 4.24\. Both projects can be found in the `Learn` tab, under
    the `Engine Feature Samples` category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once installed, open the `Content Examples` project and find the `P_Pixel_Explosion`
    asset in the `Content Browser` window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* this asset, then select `Asset Actions` and then `Migrate`. Migrate
    this asset and all its referenced assets into your `SuperSideScroller` project.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once this asset has been successfully migrated, close the `Content Examples`
    project and open the `Blueprints` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Content Browser` window of the `Blueprints` project, find the `Blueprints_TextPop01`
    asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* this asset, then select `Asset Actions`, and then `Migrate`.
    Migrate this asset and all its referenced assets into your `SuperSideScroller`
    project.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With these assets migrated to your project, return to the Unreal Engine 4 editor
    of your `SuperSideScroller` project.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `Brick` folder in the `Content Browser` window and *double-left-click*
    the `BP_Brick` asset to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Details` panel of the actor, find the `Super Side Scroller Brick` section
    and set the `HitSound` parameter to the `Blueprints_TextPop01` soundwave you imported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add the `P_Pixel_Explosion` particle you imported into the `Explosion`
    parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recompile the `BP_Brick` Blueprint and add two of these actors to your level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set one of the bricks so that the `bHasCollectable` parameter is `True`; set
    the other to `False`. Please refer to the following screenshot:![Figure 15.30:
    This Brick actor is set to have a collectible spawn'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_15_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.30: This Brick actor is set to have a collectible spawn'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using PIE, observe the differences in behavior between the two brick actors
    when you attempt to hit the bottom of the brick with the character''s head when
    jumping, as shown in the following screenshot:![Figure 15.31: Now, the player
    can hit the brick and it will be destroyed'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_15_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.31: Now, the player can hit the brick and it will be destroyed'
  prefs: []
  type: TYPE_NORMAL
- en: When `bHasCollectable` is `True`, `SuperSideScroller_Brick` will play our `HitSound`,
    spawn the `Explosion` particle system, add a coin collectible to the player, and
    be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the assets and code for this exercise here: [https://packt.live/3pjhoAv](https://packt.live/3pjhoAv).'
  prefs: []
  type: TYPE_NORMAL
- en: With this exercise complete, you have now finished developing the gameplay mechanics
    for the `SuperSideScroller` game project. Now, the `SuperSideScroller_Brick` class
    can be used for both the platforming gameplay and the coin collecting mechanic
    that we want for the game.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the brick can be destroyed and hidden coins can be collected, all the
    gameplay elements that we set out to create for the `SuperSideScroller` game project
    are complete.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you put your knowledge to the test to create the remaining
    gameplay mechanics for the `SuperSideScroller` game project. Using a combination
    of C++ and Blueprints, you developed the potion power-up and coins for the player
    to collect in the level. Also, by using your knowledge from *Chapter 14*, *Spawning
    the Player Projectile*, you added unique audio and visual assets to these collectible
    items to add a nice layer of polish to the game.
  prefs: []
  type: TYPE_NORMAL
- en: You learned and took advantage of the `UMG UI` system within Unreal Engine 4
    to create a simple, yet effective, UI feedback system to display the number of
    coins that the player has collected. By using the binding feature of the `Text`
    widget, you were able to keep the UI updated with the number of coins the player
    has currently collected. Lastly, you created a `Brick` class using the knowledge
    you learned from the `SuperSideScroller` project to hide coins for the player
    so that they can collect and find them.
  prefs: []
  type: TYPE_NORMAL
- en: The `SuperSideScroller` project has been an extensive project that expanded
    over many of the tools and practices available within Unreal Engine 4\. In *Chapter
    10*, *Creating a SuperSideScroller Game*, we imported custom skeleton and animation
    assets to use in developing the Animation Blueprint of the player character. In
    *Chapter 11*, *Blend Spaces 1D, Key Bindings, and State Machines*, we used `Blend
    spaces` to allow the player character to blend between idle, walking, and sprinting
    animations, while also using an `Animation State Machine` to handle the jumping
    and movement states of the player character. We then learned how to control the
    player's movement and jump height using the character movement component.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 12*, *Animation Blending and Montages*, we learned more about animation
    blending inside `Animation Blueprints` by using the `Layered Blend per Bone` function
    and `Saved Cached Poses`. By adding a new `AnimSlot` for the upper body animation
    of the player character's throw animation, we were able to have both the player
    movement animations and the throw animation blend together smoothly. In *Chapter
    13*, *Enemy Artificial Intelligence*, we used the robust systems of Behavior Trees
    and Blackboards to develop AI behavior for the enemy. We created our own `Task`
    that will allow the enemy AI to move in-between points from a custom Blueprint
    that we also developed to determine patrol points for the AI.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 14*, *Spawning the Player Projectile*, we learned how to create
    an `Anim Notify` and how to implement this notify in our `Animation Montage` for
    the player character's throw to spawn the player projectile. Then, we learned
    about how to create projectiles and how to use `Projectile Movement Component`
    to have the player projectile move in the game world.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in this chapter, we learned how to create UI using the `UMG` toolset
    for the coin collectible, as well as how to manipulate our `Character Movement
    Component` to create the potion power-up for the player. Lastly, you created a
    `Brick` class that can be used to hide coins for the player to find and collect.
  prefs: []
  type: TYPE_NORMAL
- en: 'This summarization only really scratches the surface of what we learned and
    accomplished in the `SuperSideScroller` project. Before you move on, here are
    some challenges for you to test your knowledge and expand upon the project:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new power-up that lowers the gravity that's applied to the player character.
    Import a custom mesh and audio assets to give this power-up a unique look compared
    to the potion power-up you made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the player character collects 10 coins, grant the player a power-up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the functionality that allows the player to be destroyed when it's
    overlapping with the AI. Include being able to respawn the player when this happens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another power-up that gives immunity to the player so that they cannot be
    destroyed when they're overlapping with an enemy. (In fact, when overlapping an
    enemy with this power-up, it could destroy the enemy.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using all the gameplay elements you've developed for the `SuperSideScroller`
    project, create a new level that takes advantage of these elements to make an
    interesting platforming arena to play in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add multiple enemies with interesting patrol points to challenge the player
    when they're navigating the area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place power-ups in hard-to-reach areas so that players need to improve their
    platforming skills to obtain them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create dangerous pitfalls for the player to navigate across and add functionality
    that will destroy the player if they fall off the map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about the basics of multiplayer, server-client
    architectures, and the gameplay framework classes used for multiplayer inside
    Unreal Engine 4\. You will use this knowledge to expand upon the multiplayer FPS
    project in Unreal Engine 4.
  prefs: []
  type: TYPE_NORMAL

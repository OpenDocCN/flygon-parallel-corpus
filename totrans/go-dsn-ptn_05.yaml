- en: Chapter 5. Behavioral Patterns - Strategy, Chain of Responsibility, and Command
    Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last group of common patterns we are going to see are the behavioral patterns.
    Now, we aren't going to define structures or encapsulate object creation but we
    are going to deal with behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: What's to deal with in behavior patterns? Well, now we will encapsulate behaviors,
    for example, algorithms in the Strategy pattern or executions in the command pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Correct Behavior design is the last step after knowing how to deal with object
    creation and structures. Defining the behavior correctly is the last step of good
    software design because, all in all, good software design lets us improve algorithms
    and fix errors easily while the best algorithm implementation will not save us
    from bad software design.
  prefs: []
  type: TYPE_NORMAL
- en: Strategy design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Strategy pattern is probably the easiest to understand of the Behavioral
    patterns. We have used it a few times while developing the previous patterns but
    without stopping to talk about it. Now we will.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Strategy pattern uses different algorithms to achieve some specific functionality.
    These algorithms are hidden behind an interface and, of course, they must be interchangeable.
    All algorithms achieve the same functionality in a different way. For example,
    we could have a `Sort` interface and few sorting algorithms. The result is the
    same, some list is sorted, but we could have used quick sort, merge sort, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Can you guess when we used a Strategy pattern in the previous chapters? Three,
    two, one... Well, we heavily used the strategy pattern when we used the `io.Writer`
    interface. The `io.Writer` interface defines a strategy to write, and the functionality
    is always the same--to write something. We could write it to the standard out,
    to some file or to a user-defined type, but we do the same thing at the end--to
    write. We just change the strategy to write (in this case, we change the place
    where we write).
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The objectives of the Strategy pattern are really clear. The pattern should
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide a few algorithms to achieve some specific functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All types achieve the same functionality in a different way but the client of
    the strategy isn't affected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem is that this definition covers a huge spectrum of possibilities.
    This is because Strategy pattern is actually used for a variety of scenarios and
    many software engineering solutions come with some kind of strategy within. Therefore
    it's better to see it in action with a real example.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering images or text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to do something different for this example. Instead of printing
    text on the console only, we are also going to paint objects on a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we will have two strategies: console and file. But the user of
    the library won''t have to deal with the complexity behind them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key feature is that the "caller" doesn´t know how the underlying library
    is working and he just knows the information available on the defined strategy.
    This is nicely seen on the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering images or text](img/B05557_05_01-300x136.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this diagram, we have chosen to print to console but we won´t deal with the
    **ConsoleStrategy** type directly, we´ll always use an interface that represents
    it. The **ConsoleStrategy** type will hide the implementation details of printing
    to console to caller in `main` function. **FileStrategy** hides its implementation details
    as well as any future strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A strategy must have a very clear objective and we will have two ways to achieve
    it. Our objectives will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide a way to show to the user an object (a square) in text or image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user must choose between image or text when launching the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The app must be able to add more visualization strategies (audio, for example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user selects text, the word *Square* must be printed in the console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user selects image, an image of a white square on a black background
    will be printed on a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We aren''t going to write tests for this example as it will be quite complicated
    to check that an image has appeared on the screen (although not impossible by
    using **OpenCV**, an impressive library for computer vision). We will start directly
    by defining our strategy interface that each printing strategy must implement
    (in our case, the file and console types):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all. Our strategy defines a simple `Print()` method that returns an
    `error` (the error-returning type is mandatory when dealing with files, for example).
    The types that needs to implement `PrintStrategy` will be called `ConsoleSquare`
    and a `ImageSquare` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ConsoleSquare` struct doesn''t need any inner field because it will always
    print the word `Square` to the console. The `ImageSquare` struct will store a
    field for the destination of the image file where we will print the square. We
    will start with the implementation of the `ConsoleSquare` type as it is the simplest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Very easy, but the image is more complex. We won''t spend too much time in
    explaining in detail how the `image` package works because the code is easily
    understandable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, here is a short explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: We define a size for the image (`width` and `height` variables) of 800 pixels
    of width and 600 pixels of height. Those are going to be the size limits of our
    image and anything that we write outside of that size won't be visible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `origin` variable stores an `image.Point`, a type to represent a position
    in any two-dimensional space. We set the position of this point at *(0, 0)*, the
    upper-left corner of the image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need a bitmap that will represent our background, here we called it `bgImage`.
    We have a very handy function in the image package to create the `image.RGBA`
    types called `image.NewRGBA`. We need to pass a rectangle to this function so
    that it knows the bounds of the image. A rectangle is represented by two `image.Point`
    types--its upper left corner point (the `Min` field) and its lower right corner
    point (the `Max` field). We use `origin` as the upper-left and a new point with
    the values of `width` and `height` as the lower-right point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The image will have a gray background color (`bgColor`). This is done by instancing
    a type of `image.Uniform`, which represents a uniform color (hence the name).
    The `image.Uniform` type needs an instance of a `color.Color` interface. A `color.Color`
    type is any type that implements the `RGBA() (r, g, b, a uint32)`  method to return
    a `uint32` value for red, green, blue, and alpha colors (RGBA). Alpha is a value
    for the transparency of a pixel. The `color` package conveniently provides a type
    called `color.RGBA` for this purpose (in case we don't need to implement our own,
    which is our case).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When storing an image in certain formats, we have to specify the quality of
    the image. It will affect not only the quality but the size of the file, of course.
    Here, it is defined as 75; 100 is the maximum quality possible that we can set.
    As you can see, we are using the `jpeg` package here to set the value of a type
    called `Options` that simply stores the value of the quality, it doesn't have
    more values to apply.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `draw.Print` function writes the pixels on the supplied image (`bgImage`)
    with the characteristics that we have defined on the bounds defined by the same
    image. The first argument of the `draw.Print` method takes the destination image,
    where we used `bgImage`. The second argument is the bounds of the object to draw
    in the destination image, we used the same bounds of the image but we could use
    any other if we wanted a smaller rectangle. The third argument is the color to
    use to colorize the bounds. The `Origin` variable is used to tell where the upper-left
    corner of the bound must be placed. In this case, the bounds are the same size
    as the image so we need to set it to the origin. The last argument specified is
    the operation type; just leave it in the `draw.Src` argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we have to draw the square. The operation is essentially the same as to
    draw the background but, in this case, we are drawing a square over the previously
    drawn `bgImage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The square will be of 200*200 pixels of red color. When using the method `Add`,
    the `Rect` type origin is translated to the supplied point; this is to center
    the square on the image. We create an image with the square `Rect` and call the
    `Print` function on the `bgImage` image again to draw the red square over it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we will create a file to store the contents of the image. The file
    will be stored in the path supplied in the `DestinationFilePath` field of the
    `ImageSquare` struct. To create a file, we use `os.Create` that returns the `*os.File`.
    As with every file, it must be closed after using it so don't forget to use the
    `defer` keyword to ensure that you close it when the method finishes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To defer, or not to defer?
  prefs: []
  type: TYPE_NORMAL
- en: Some people ask why the use of `defer` at all? Wouldn't it be the same to simply
    write it without `defer` at the end of the function? Well, actually not. If any
    error occurs during the method execution and you return this error, the `Close`
    method won't be executed if it's at the end of the function. You can close the
    file before returning but you'll have to do it in every error check. With `defer,`
    you don't have to worry about this because the deferred function is executed always
    (with or without error). This way, we ensure that the file is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To parse the arguments, we''ll use the `flag` package. We have used it before
    but let''s recall its usage. A flag is a command that the user can pass when executing
    our app. We can define a flag by using the `flag.[type]` methods defined in the
    `flag` package. We want to read the output that the user wants to use from the
    console. This flag will be called `output`. A flag can have a default value; in
    this case, it will have the value `console` that will be used when printing to
    console. So, if the user executes the program without arguments, it prints to
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Our final step is to write the main function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that the first thing to do in the main when using flags is to parse
    them using the `flag.Parse()` method! It''s very common to forget this step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We define a variable for the strategy that the user has chosen, called `activeStrategy`.
    But check that the `activeStrategy` variable has the `PrintStrategy` type so it
    can be populated with any implementation of the `PrintStrategy` variable. We will
    set `activeStrategy` to a new instance of `TextSquare` when the user writes the 
    `**--output=console**`  command and an `ImageSquare` when we write the  `**--output=image**`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here is the design pattern execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `activeStrategy` variable is a type implementing `PrintStrategy` and either
    the `TextSquare` or `ImageSquare` classes. The user will choose at runtime which
    strategy he wants to use for each particular case. Also, we could have written
    a factory method pattern to create strategies, so that the strategy creation will
    also be uncoupled from the main function and abstracted in a different independent
    package. Think about it: if we have the strategy creation in a different package,
    it will also allow us to use this project as a library and not only as a standalone
    app.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will execute both strategies; the `TextSquare` instance will give us
    a square by printing the word `Square` on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It has worked as expected. Recalling how flags work, we have to use the `--` (double
    dash) and the defined flag, `output` in our case. Then you have two options--using
    `=` (equals) and immediately writing the value for the flag or writing `<space>`
    and the value for the flag. In this case, we have defined the default value of
    output to the console so the following three executions are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have to try the file strategy. As defined before, the file strategy
    will print a red square to a file as an image with dark gray background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Nothing happened? But everything worked correctly. This is actually bad practice.
    Users must always have some sort of feedback when using your app or your library.
    Also, if they are using your code as a library, maybe they have a specific format
    for output so it won't be nice to directly print to the console. We will solve
    this issue later. Right now, open the folder `/tmp` with your favourite file explorer
    and you will see a file called `image.jpg` with our red square in a dark grey
    background.
  prefs: []
  type: TYPE_NORMAL
- en: Solving small issues in our library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a few issues in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: It cannot be used as a library. We have critical code written in the `main`
    package (strategy creation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Abstract to two different packages the strategy creation from
    the command-line application.'
  prefs: []
  type: TYPE_NORMAL
- en: None of the strategies are doing any logging to file or console. We must provide
    a way to read some logs that an external user can integrate in their logging strategies
    or formats.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Inject an `io.Writer` interface as dependency to act as a logging
    sink.'
  prefs: []
  type: TYPE_NORMAL
- en: Our `TextSquare` class is always writing to the console (an implementer of the `io.Writer`
    interface) and the `ImageSquare` is always writing to file (another implementer
    of the `io.Writer` interface). This is too coupled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Inject an `io.Writer` interface so that the `TextSquare` and
    `ImageSquare` can write to any of the `io.Writer` implementations that are available
    (file and console, but also bytes buffer, binary encoders, `JSON` handlers...
    dozens of packages).'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to use it as a library and solve the first issue, we will follow a common
    approach in Go file structures for apps and libraries. First, we will place our
    main package and function outside of the root package; in this case, in a folder
    called `cli`. It is also common to call this folder `cmd` or even `app`. Then,
    we will place our `PrintStrategy` interface in the root package, which now will
    be called the `strategy` package. Finally, we will create a `shapes` package in
    a folder with the same name where we will put both text and image strategies.
    So, our file structure will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Root package**: strategy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'File: `print_strategy.go`'
  prefs: []
  type: TYPE_NORMAL
- en: '**SubPackage**: shapes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Files: `image.go`, `text.go`, `factory.go`'
  prefs: []
  type: TYPE_NORMAL
- en: '**SubPackage**: cli'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'File: `main.go`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to modify our interface a bit to fit the needs we have written
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added the `SetLog(io.Writer)` method to add a logger strategy to our
    types; this is to provide feedback to users. Also, it has a `SetWriter` method
    to set the `io.Writer` strategy. This interface is going to be located on the
    root package in the `print_strategy.go` file. So the final schema looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving small issues in our library](img/B05557_05_02-300x127.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Both the `TextSquare` and `ImageSquare` strategies have to satisfy the `SetLog`
    and `SetWriter` methods which simply store some object on their fields so, instead
    of implementing the same twice, we can create a struct that implements them and
    embed this struct in the strategies. By the way, this would be the composite pattern
    we have seen previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So now each strategy must have the `PrintOutput` struct embedded if we want
    to modify their `Writer` and `logger` fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to modify our strategy implementation. The `TextSquare` struct now
    needs a field to store the output `io.Writer` (the place where it is going to
    write instead of writing always to the console) and the `log` writer. These two
    fields can be provided by embedding the `PrintOutput` struct. The `TextSquare` struct
    is also stored in the file `text.go` within the shapes package. So, the struct
    is now like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'So now the `Print()` method is slightly different because, instead of writing
    directly to the console by using the `println` function, we have to write whichever
    `io.Writer` is stored in the `Writer` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `bytes.NewReader` is a very useful function that takes an array of bytes
    and converts them to an `io.Reader` interface. We need an `io.Reader` interface
    to use the `io.Copy` function. The `io.Copy` function is also incredibly useful
    as it takes an `io.Reader` (as the second parameter) and pipes it to an `io.Writer`
    (its first parameter). So, we won''t return an error in any case. However, it''s
    easier to do so using directly the `Write` method of `t.Writer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can use whichever method you like more. Usually, you will use the `Write`
    method but it's nice to know the `bytes.NewReader` function too.
  prefs: []
  type: TYPE_NORMAL
- en: Did you realize that when we use `t.Writer`, we are actually accessing `PrintOutput.Writer`?
    The `TextSquare` type has a `Writer` field because the `PrintOutput` struct has
    it and it's embedded on the `TextSquare` struct.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Embedding is not inheritance. We have embedded the `PrintOutput` struct on
    the `TextSquare` struct. Now we can access `PrintOutput` fields as if they were
    in `TextSquare` fields. This feels a bit like inheritance but there is a very
    important difference here: `TextSquare` is not a `PrintOutput` value but it has
    a `PrintOutput` in its composition. What does it mean? That if you have a function
    that expects a `PrintOutput`, you cannot a pass `TextSquare` just because it has
    a `PrintOutput` embedded.'
  prefs: []
  type: TYPE_NORMAL
- en: But, if you have a function that accepts an interface that `PrintOutput` implements,
    you can pass `TextSquare` if it has a `PrintOutput` embedded. This is what we
    are doing in our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ImageSquare` struct is now like the `TextSquare`, with a `PrintOutput`
    embedded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Print` method also needs to be modified. Now, we aren''t creating a file
    from the `Print` method, as it was breaking the single responsibility principle.
    A file implements an `io.Writer` so we will open the file outside of the `ImageSquare`
    struct and inject it on the `Writer` field. So, we just need to modify the end
    of the `Print()` method where we wrote to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you check our previous implementation, after using `draw`, you can see that
    we used the `Print` method, we created a file with `os.Create` and passed it to
    the `jpeg.Encode` function. We have deleted this part about creating the file
    and we have replaced it with a check looking for a `Writer` in the fields (`if
    i.Writer != nil`). Then, on `jpeg.Encode` we can replace the file value we were
    using previously with the content of the `i.Writer` field. Finally, we are using
    `io.Copy` again to log some message to the `LogWriter` if a logging strategy is
    provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have to abstract the knowledge needed from the user to create instances
    of implementors of the `PrintStrategy` for which we are going to use a Factory
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two constants, one of each of our strategies: `TEXT_STRATEGY` and `IMAGE_STRATEGY`.
    Those are the constants that must be provided to the factory to retrieve each
    square drawer strategy. Our factory method receives an argument `s`, which is
    a string with one of the previous constants.'
  prefs: []
  type: TYPE_NORMAL
- en: Each strategy has a `PrintOutput` type embedded with a default logger to `stdout`
    but you can override it later by using the `SetLog(io.Writer)` methods. This approach
    could be considered a Factory of prototypes. If it is not a recognized strategy,
    a proper message error will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we have now is a library. We have all the functionality we need between
    the `strategy` and `shapes` packages. Now we will write the `main` package and
    function in a new folder called `cli`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, like before, the `main` function starts by parsing the input arguments
    on the console to gather the chosen strategy. We can use the variable output now
    to create a strategy without Factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: With this snippet, we have our strategy or we stop program execution in the
    `log.Fatal` method if any error is found (such as an unrecognized strategy).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will implement the business needs by using our library. For the purpose
    of the `TextStrategy`, we want to write, for example, to `stdout`. For the purpose
    of the image, we will write to `/tmp/image.jpg`. Just like before. So, following
    the previous statements, we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of `TEXT_STRATEGY`, we use `SetWriter` to set the `io.Writer` to
    `os.Stdout`. In the case of `IMAGE_STRATEGY`, we create an image in any of our
    folders and pass the file variable to the `SetWriter` method. Remember that `os.File`
    implements the `io.Reader` and `io.Writer` interfaces, so it''s perfectly legal
    to pass it as an `io.Writer` to the `SetWriter` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we call the `Print` method of whichever strategy was chosen by the
    user and check for possible errors. Let''s try the program now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It has worked as expected. What about the image strategy?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If we check in `/tmp/image.jpg`, we can find our red square on the dark background.
  prefs: []
  type: TYPE_NORMAL
- en: Final words on the Strategy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have learned a powerful way to encapsulate algorithms in different structs.
    We have also used embedding instead of inheritance to provide cross-functionality
    between types, which will come in handy very often in our apps. You'll find yourself
    combining strategies here and there as we have seen in the second example, where
    we have strategies for logging and writing by using the `io.Writer` interface,
    a strategy for byte-streaming operations.
  prefs: []
  type: TYPE_NORMAL
- en: Chain of responsibility design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next pattern is called **chain of responsibility**. As its name implies,
    it consists of a chain and, in our case, each link of the chain follows the single
    responsibility principle.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The single responsibility principle implies that a type, function, method, or
    any similar abstraction must have one single responsibility only and it must do
    it quite well. This way, we can apply many functions that achieve one specific
    thing each to some struct, slice, map, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: When we apply many of these abstractions in a logical way very often, we can
    chain them to execute in order such as, for example, a logging chain.
  prefs: []
  type: TYPE_NORMAL
- en: A logging chain is a set of types that logs the output of some program to more
    than one `io.Writer` interface. We could have a type that logs to the console,
    a type that logs to a file, and a type that logs to a remote server. You can make
    three calls every time you want to do some logging, but it's more elegant to make
    only one and provoke a chain reaction.
  prefs: []
  type: TYPE_NORMAL
- en: But also, we could have a chain of checks and, in case one of them fails, break
    the chain and return something. This is the authentication and authorization middleware
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The objective of the chain of responsibility is to provide to the developer
    a way to chain actions at runtime. The actions are chained to each other and each
    link will execute some action and pass the request to the next link (or not).
    The following are the objectives followed by this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically chain the actions at runtime based on some input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass a request through a chain of processors until one of them can process it,
    in which case the chain could be stopped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A multi-logger chain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to develop a multi-logger solution that we can chain in the way
    we want. We will use two different console loggers and one general-purpose logger:'
  prefs: []
  type: TYPE_NORMAL
- en: We need a simple logger that logs the text of a request with a prefix *First
    logger* and passes it to the next link in the chain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A second logger will write on the console if the incoming text has the word
    `hello` and pass the request to a third logger. But, if not, the chain will be
    broken and it will return immediately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A third logger type is a general purpose logger called `WriterLogger` that uses
    an `io.Writer` interface to log.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A concrete implementation of the `WriterLogger` writes to a file and represents
    the third link in the chain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The implementation of these steps is described in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A multi-logger chain](img/B05557_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The very first thing to do for the chain is, as usual, to define the interface.
    A chain of responsibility interface will usually have, at least, a  `Next()` method.
    The `Next()` method is the one that executes the next link in the chain, of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Next` method on our example''s interface takes the message we want to
    log and passes it to the following link in the chain. As written in the acceptance
    criteria, we need three loggers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `FirstLogger` and `SecondLogger` types have exactly the same structure--both
    implement `ChainLogger` and have a `NextChain` field that points to the next `ChainLogger`.
    The `WriterLogger` type is equal to the `FirstLogger` and `SecondLogger` types
    but also has a field to write its data to, so you can pass any `io.Writer` interface
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have done before, we''ll implement an `io.Writer` struct to use in our
    testing. In our test file, we define the following struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We will pass an instance of the `myTestWriter` struct to `WriterLogger` so we
    can track what's being logged on testing. The `myTestWriter` class implements
    the common `Write([]byte) (int, error)` method from the `io.Writer` interface.
    Remember, if it has the `Write` method, it can be used as `io.Writer`. The `Write`
    method simply stored the string argument to the `receivedMessage` field so we
    can check later its value on tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the beginning of the first test function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Let's describe these few lines a bit as they are quite important. We create
    a variable with a default `myTestWriter` type that we'll use as an `io.Writer` interface
    in the last link of our chain. Then we create the last piece of the link chain,
    the `writerLogger` interface. When implementing the chain, you usually start with
    the last piece on the link and, in our case, it is a `WriterLogger`. The `WriterLogger`
    writes to an `io.Writer` so we pass `myWriter` as `io.Writer` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Then we have created a `SecondLogger`, the middle link in our chain, with a
    pointer to the `writerLogger`. As we mentioned before, `SecondLogger` just logs
    and passes the message in case it contains the word `hello`. In a production app,
    it could be an error-only logger.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the first link in the chain has the variable name chain. It points
    to the second logger. So, to resume, our chain looks like this: `FirstLogger`
    | `SecondLogger` | `WriterLogger`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is going to be our default setup for our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing with Go 1.7 or later testing signatures, we define an inner test
    with the following description: *three loggers, two of them write to console,
    the second only if it finds the word ''hello'', the third writes to some variable
    if the second found ''hello''*. It''s quite descriptive and very easy to understand
    if someone else has to maintain this code.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we use a message on the `Next` method that will not reach the third link
    in the chain as it doesn't contain the word `hello`. We check the contents of
    the `receivedMessage` variable, that by default is empty, to see if it has changed
    because it shouldn't.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the chain variable again, our first link in the chain, and pass
    the message `"Hello\n"`. According to the description of the test, it should log
    using `FirstLogger`, then in `SecondLogger` and finally in `WriterLogger` because
    it contains the word `hello` and the `SecondLogger` will let it pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test checks that `myWriter`, the last link in the chain that stored the
    past message in a variable called `receivedMessage`, has the word that we passed
    first in the chain: hello. Let''s run it so it fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The test passed for the first check of the test and didn''t for the second
    check. Well... ideally no check should pass before any implementation is done.
    Remember that in test-driven development, tests must fail on the first launch
    because the code they are testing isn''t implemented yet. Go zero-initialization
    misleads us with this passed check on the test. We can solve this in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Making the signature of the `ChainLogger` to return an error: `Next(string)`
    error. This way, we would break the chain returning an error. This is a much more
    convenient way in general, but it will introduce quite a lot of boilerplate right
    now.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the `receivedMessage` field to a pointer. A default value of a pointer
    is nil, instead of an empty string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use the second option now, as it''s much simpler and quite effective
    too. So let''s change the signature of the `myTestWriter` struct to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Check that the type of `receivedMessage` has the asterisk (`*`) now to indicate
    that it's a pointer to a string. The `Write` function needed to change too. Now
    we have to check the contents of the `receivedMessage` field because, as every
    pointer, it's initialized to nil. Then we have to store the message in a variable
    first, so we can take the address in the next line on the assignment `(m.receivedMessage
    = &tempMessage)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now our test code should change a bit too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are checking that `myWriter.receivedMessage` is actually `nil`, so no
    content has been written for sure on the variable. Also, we have to change the
    second if to check first that the member isn''t nil before checking its contents
    or it can throw a panic on test. Let''s test it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It fails again and, again, the first half of the test passes correctly without
    implemented code. So what should we do now? We have change the signature of the `myWriter`
    type to make the test fail in both checks and, again, just fail in the second.
    Well, in this case we can pass this small issue. When writing tests, we must be
    very careful to not get too crazy about them; unit tests are tools to help us
    write and maintain code, but our target is to write functionality, not tests.
    This is important to keep in mind as you can get really crazy engineering unit
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we have to implement the first, second, and third loggers called `FirstLogger`,
    `SecondLogger`, and `WriterLogger` respectively. The `FirstLogger` logger is the
    easiest one as described in the first acceptance criterion: *We need a simple
    logger that logs the text of a request with a prefix First logger: and passes
    it to the next link in the chain*. So let''s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation is quite easy. Using the `fmt.Printf` method to format and
    print the incoming string, we appended the text `First Logger:` text. Then, we
    check that the `NextChain` type has actually some content and pass the control
    to it by calling its `Next(string)` method. The test shouldn''t pass yet so we''ll
    continue with the `SecondLogger` logger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned in the second acceptance criterion, the `SecondLogger` description
    is: *A second logger will write on the console if the incoming text has the word
    "hello" and pass the request to a third logger*. First of all, it checks whether
    the incoming text contains the text `hello`. If it''s true, it prints the message
    to the console, appending the text `Second logger:` and passes the message to
    the next link in the chain (check previous instance that a third link exists).'
  prefs: []
  type: TYPE_NORMAL
- en: But if it doesn't contain the text `hello`, the chain is broken and it prints
    the message `Finishing in second logging`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll finalize with the `WriterLogger` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `WriterLogger` struct's `Next` method checks that there is an existing `io.Writer`
    interface stored in the `Writer` member and writes there the incoming message
    appending the text `WriterLogger:` to it. Then, like the previous links, check
    that there are more links to pass the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the tests will pass successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The first half of the test prints two messages--the `First logger:` message
    that breaks the chain, which is the expected message for the `FirstLogger`. But
    it halts in the `SecondLogger` because no `hello` word has been found on the incoming
    message; that's why it prints the `Finishing in second logging` string.
  prefs: []
  type: TYPE_NORMAL
- en: The second half of the test receives the message `Hello`. So the `FirstLogger`
    prints and the `SecondLogger` prints too. The third logger doesn't print to console
    at all but to our `myWriter.receivedMessage` line defined in the test.
  prefs: []
  type: TYPE_NORMAL
- en: What about a closure?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes it can be useful to define an even more flexible link in the chain
    for quick debugging. We can use closures for this so that the link functionality
    is defined by the caller. What does a closure link look like? Similar to the `WriterLogger`
    logger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ClosureChain` type has a `NextChain`, as usual, and a `Closure` member.
    Look at the signature of the `Closure: func(string)`. This means it is a function
    that takes a `string` and returns nothing.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Next(string)` method for `ClosureChain` checks that the `Closure` member
    is stored and executes it with the incoming string. As usual, the link checks
    for more links to pass the message as every link in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do we use it now? We''ll define a new test to show its functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of this test makes it clear: `"2 loggers, second uses the closure
    implementation".` We simply use two `ChainLogger` implementations and we use the
    `closureLogger` in the second link. We have created a new `myTestWriter` to store
    the contents of the message. When defining the `ClosureChain`, we defined an anonymous
    function directly on the `Closure` member when creating `closureLogger`. It prints
    `"My closure logger! Message: %s\n" with the incoming message replacing "%s"`.
    Then, we store the incoming message on `myWriter`, to check later.'
  prefs: []
  type: TYPE_NORMAL
- en: After defining this new link, we use the third link from the previous test,
    add the closure as the fourth link, and passed the message `Hello closure logger`.
    We use the word `Hello` at the beginning so that we ensure that the message will
    pass the `SecondLogger`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the contents of `myWriter.receivedMessage` must contain the pased
    text: `Hello closure logger`. This is quite a flexible approach with one drawback:
    when defining a closure like this, we cannot test its contents in a very elegant
    way. Let''s run the tests again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the third `RUN`: the message passes correctly through the first, second,
    and third links to arrive at the closure that prints the expected  `My closure
    logger! Message: Hello closure logger` message.'
  prefs: []
  type: TYPE_NORMAL
- en: It's very useful to add a closure method implementation to some interfaces as
    it provides quite a lot of flexibility when using the library. You can find this
    approach very often in Go code, being the most known the one of package `net/http`.
    The `HandleFunc` function which we used previously in the structural patterns
    to define a handler for an HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned a powerful tool to achieve dynamic processing of actions and state
    handling. The Chain of responsibility pattern is widely used, also to create **Finite
    State Machines** (**FSM**). It is also used interchangeably with the Decorator
    pattern with the difference that when you decorate, you change the structure of
    an object while with the chain you define a behavior for each link in the chain
    that can break it too.
  prefs: []
  type: TYPE_NORMAL
- en: Command design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To finish with this chapter, we will see also the **Command** pattern--a tiny
    design pattern but still frequently used. You need a way to connect types that
    are really unrelated? So design a Command for them.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Command design pattern is quite similar to the Strategy design pattern but
    with key differences. While in the strategy pattern we focus on changing algorithms,
    in the Command pattern, we focus on the invocation of something or on the abstraction
    of some type.
  prefs: []
  type: TYPE_NORMAL
- en: A Command pattern is commonly seen as a container. You put something like the
    info for user interaction on a UI that could be `click on login` and pass it as
    a command. You don't need to have the complexity related to the `click on login`
    action in the command but simply the action itself.
  prefs: []
  type: TYPE_NORMAL
- en: An example for the organic world would be a box for a delivery company. We can
    put anything on it but, as a delivery company, we are interested in managing the
    box instead of its contents directly.
  prefs: []
  type: TYPE_NORMAL
- en: The command pattern will be used heavily when dealing with channels. With channels
    you can send any message through it but, if we need a response from the receiving
    side of the channel, a common approach is to create a command that has a second,
    response channel attached where we are listening.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, a good example would be a multi-player video game, where every stroke
    of each user can be sent as commands to the rest of the users through the network.
  prefs: []
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using the Command design pattern, we are trying to encapsulate some sort
    of action or information in a light package that must be processed somewhere else.
    It''s similar to the Strategy pattern but, in fact, a Command could trigger a
    preconfigured Strategy somewhere else, so they are not the same. The following
    are the objectives for this design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Put some information into a box. Just the receiver will open the box and know
    its contents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegate some action somewhere else.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The behavior is also explained in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Objectives](img/B05557_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There we have a **Command** interface with a **Get() interface{}** method. We
    have a type **A** and a type **B**. The idea is that **A** and **B** implement
    the **Command** interface to return themselves as an `interface{}`. As now they
    implement **Command**, they can be used in a **Command handler** which doesn't
    care very much about the underlying type. Now **A** and **B** can travel through
    functions that handles commands or store Commands freely. But **B** handler can
    take an object from any **Command** handler to "unwrap" it and take its **B**
    content as well as **A** command handler with its `A` content.
  prefs: []
  type: TYPE_NORMAL
- en: We put the information in a box (the **Command**) and delegate what to do with
    it to the handlers of Commands.
  prefs: []
  type: TYPE_NORMAL
- en: A simple queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first example is going to be pretty small. We will put some information
    into a Command implementer and we will have a queue. We will create many instances
    of a type implementing a Command pattern and we will pass them to a queue that
    will store the commands until three of them are in the queue, at which time it
    will process them.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So the ideal acceptance criteria to understand well the implications of the
    Command should reflect somehow the creation of a box that can accept unrelated
    types and the execution of the Command itself:'
  prefs: []
  type: TYPE_NORMAL
- en: We need a constructor of console printing commands. When using this constructor
    with a `string`, it will return a command that will print it. In this case, the
    handler is inside the command that acts as a box and as a handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need a data structure that stores incoming commands in a queue and prints
    them once the queue reaches the length of three.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern is quite simple and we will write a few different examples so
    we''ll implement the library directly to keep things light and short. The classical
    Command design pattern usually has a common type structure with an `Execute` method.
    We are also going to use this structure as it''s quite flexible and simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This is generic enough to fill a lot of unrelated types! Think about it--we
    are going to create a type that prints to console when using the `Execute()` method
    but it could print a number or launch a rocket as well! The key here is to focus
    on invocations because the handlers are also in Command. So we need some type
    implementing this interface and printing to the console some sort of message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `ConsoleOutput` type implements the `Command` interface and prints to the
    console the member called `message`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As defined in the first acceptance criterion, we need a `Command` constructor
    that accepts a message string and returns the `Command` interface. It will have
    the signature `func CreateCommand(s string) Command`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'For the command `queue`, we''ll define a very simple type called `CommandQueue`
    to store in a queue any type implementing the `Command` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `CommandQueue` type stores an array of the `Commands` interface. When the
    queue array reaches three items, it executes all the commands stored in the queue
    field. If it hasn't reached the required length yet, it just stores the command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create five commands, enough to trigger the command queue mechanism,
    and add them to the queue. Each time a command is created, the message `Creating
    command` will be printed to the console. When we create the third command, the
    automatic command executor will be launched, printing the first three messages.
    We create and add two commands more, but because we haven''t reached the third
    command again, they won''t be printed and just the `Creating command` messages
    will be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the `main` program. Our definition said that the commands are processed
    once every three messages and we will create a total of five messages. The first
    three messages must be printed but not the fourth and fifth because we didn''t
    reach a sixth message to trigger the command processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the fourth and fifth messages aren't printed, as expected, but
    we know that the commands were created and stored on the array. They just weren't
    processed because the queue was waiting for one command more to trigger the processor.
  prefs: []
  type: TYPE_NORMAL
- en: More examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous example shows how to use a Command handler that executes the content
    of the command. But a common way to use a Command pattern is to delegate the information,
    instead of the execution, to a different object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, instead of printing to the console, we will create a command that
    extracts information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, our `Command` interface will have a method named `Info` that
    will retrieve some information from its implementor. We will create two implementations;
    one will return the time passed since the creation of the command to its execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `time.Since` function returns the time elapsed since the time stored in
    the provided parameter. We returned the string representation of the passed time
    by calling the `String()` method on the `time.Time` type. The second implementation
    of our new `Command` will return the message `Hello World!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'And our `main` function will simply create an instance of each type, then waits
    for a second and print the info returned from each `Command`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `time.Sleep` function stops the execution of the current goroutine for the
    specified period (a second). So, to recall--the `timeCommand` variable stores
    the time when the program was started and its `Info()` method returns a string
    representation of the time that passed since we give a value to the type to the
    moment were we called the `Info()` method on it. The `helloCommand` variable returns
    the message `Hello World!` when we call its `Info()` method. Here we haven't implemented
    a `Command` handler again to keep things simple but we can consider the console
    as the handler because we can only print ASCII characters on it like the ones
    retrieved by the `Info()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here we are. In this case, we retrieve some information by using the Command
    pattern. One type stores `time` information while the other stores nothing and
    it simply returns the same simple string. Each time we run the `main` function
    will return a different elapsed time, so don't worry if the time doesn't match
    with the one in the example.
  prefs: []
  type: TYPE_NORMAL
- en: Chain of responsibility of commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do you remember the chain of responsibility design pattern? We were passing
    a `string` message between links to print its contents. But we could be using
    the previous Command to retrieve information for logging to the console. We'll
    mainly reuse the code that we have written already.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Command` interface will be from the type interface that returns a `string`
    from the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `Command` implementation of the `TimePassed` type too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that this type returns the elapsed time from the object creation on
    its `Info() string` method. We also need the `ChainLogger` interface from the
    *Chain of responsibility design pattern* section of this chapter but, this time,
    it will pass Commands on its `Next` method instead of `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use just the same type for two links in the chain for simplicity. This
    link is very similar to the `FirstLogger` type from the chain of responsibility
    example, but this time it will append the message `Elapsed time from creation:`
    and it will wait 1 second before printing. We''ll call it `Logger` instead of
    `FirstLogger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need a `main` function to execute the chain that takes `Command`
    pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Line by line, we create a variable called `second` with a pointer to a `Logger`;
    this is going to be the second link in our chain. Then we create a variable called
    `first`, that will be the first link in the chain. The first link points to the
    `second` variable, the second link in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create an instance of `TimePassed` to use it as the `Command` type.
    The start time of this command is the execution time (the `time.Now()` method
    returns the time in the moment of the execution).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we pass the `Command` interface to the chain on the `first.Next(command)`
    statement. The output of this program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output is reflected in the following diagram: The command with
    the time field is pushed to the first link that knows how to execute Commands
    of any type. Then it passes the Command to the second link that also knows how
    to execute Commands:'
  prefs: []
  type: TYPE_NORMAL
- en: This approach hides the complexity behind each `Command` execution from the
    Command handlers on each link. The functionality hidden behind a Command can be
    simple or incredibly complex but the idea here is to reuse the handler to manage
    many types of unrelated implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Rounding-up the Command pattern up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Command is a very tiny design pattern; its functionality is quite easy to understand
    but it's widely used for its simplicity. It looks very similar to the Strategy
    pattern but remember that Strategy is about having many algorithms to achieve
    some specific task, but all of them achieve the same task. In the Command pattern,
    you have many tasks to execute, and not all of them need to be equal.
  prefs: []
  type: TYPE_NORMAL
- en: So, in short, the Command pattern is about execution encapsulation and delegation
    so that just the receiver or receivers trigger that execution.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have taken our first steps in the Behavioral patterns. The objective of this
    chapter was to introduce the reader to the concept of algorithm and execution
    encapsulation using proper interfaces and structures. With the strategy, we have
    encapsulated algorithms, with the chain of responsibility handlers and with the
    Command design pattern executions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with the knowledge we have acquired about the strategy pattern, we can
    uncouple heavily our applications from their algorithms, just for testing, this
    is a very useful feature to inject mocks in different types that would be almost
    impossible to test. But also for anything that could need different approaches
    based on some context (such as shorting a list; some algorithms perform better
    depending on the distribution of the list).
  prefs: []
  type: TYPE_NORMAL
- en: The Chain of Responsibility pattern opens the door of middleware of any type
    and plugin-like libraries to improve the functionality of some part. Many open
    source projects uses a Chain of Responsibility to handler HTTP requests and responses
    to extract information to the end user (such as cookies info) or check authentication
    details (I'll let you pass to the next link only if I have you on my database).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Command pattern is the most common pattern for UI handling but
    also very useful in many other scenarios where we need some type of handling between
    many unrelated types that are travelling through the code (such as a message passed
    through a channel).
  prefs: []
  type: TYPE_NORMAL

- en: Chapter 3. Three Ways to Implement Profile Pictures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our chat application has made use of the OAuth2 protocol to allow users
    to sign in to our application so that we know who is saying what. In this chapter,
    we are going to add profile pictures to make the chatting experience more engaging.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at the following ways to add pictures or avatars alongside the
    messages in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the avatar picture provided by the authentication server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the [Gravatar.com](http://Gravatar.com) web service to look up a picture
    by the user's e-mail address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing the user to upload their own picture and host it themselves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two options allow us to delegate the hosting of pictures to a third
    party—either an authentication service or [Gravatar.com](http://Gravatar.com)
    —which is great because it reduces the cost of hosting our application (in terms
    of storage costs and bandwidth, since the user's browsers will actually download
    the pictures from the servers of the authenticating service, not ours). The third
    option requires us to host pictures ourselves at a location that is web accessible.
  prefs: []
  type: TYPE_NORMAL
- en: These options aren't mutually exclusive; you will most likely use some combination
    of them in a real-world production application. Towards the end of the chapter,
    we will see how the flexible design that emerges allows us to try each implementation
    in turn, until we find an appropriate avatar.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to be agile with our design throughout this chapter, doing the
    minimum work needed to accomplish each milestone. This means that at the end of
    each section, we will have working implementations that are demonstrable in the
    browser. This also means that we will refactor code as and when we need to and
    discuss the rationale behind the decisions we make as we go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What are good practices to get additional information from authentication services,
    even when there are no standards in place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it is appropriate to build abstractions into our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Go's zero-initialization pattern can save time and memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How reusing an interface allows us to work with collections and individual objects
    in the same way as the existing interface did
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the [Gravatar.com](http://Gravatar.com) web service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do MD5 hashing in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to upload files over HTTP and store them on a server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to serve static files through a Go web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use unit tests to guide the refactoring of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How and when to abstract functionality from `struct` types into interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avatars from the authentication server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It turns out that most authentication servers already have images for their
    users, and they make them available through the protected user resource that we
    already know how to access in order to get our users' names. To use this avatar
    picture, we need to get the URL from the provider, store it in the cookie for
    our user, and send it through a web socket so that every client can render the
    picture alongside the corresponding message.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the avatar URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The schema for user or profile resources is not part of the OAuth2 spec, which
    means that each provider is responsible for deciding how to represent that data.
    Indeed, providers do things differently, for example, the avatar URL in a GitHub
    user resource is stored in a field called `avatar_url` , whereas in Google, the
    same field is called `picture` . Facebook goes even further by nesting the avatar
    URL value in a `url` field inside an object called `picture` . Luckily, Gomniauth
    abstracts this for us; its `GetUser` call on a provider standardizes the interface
    to get common fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make use of the avatar URL field, we need to go back and store
    its information in our cookie. In `auth.go` , look inside the `callback` action
    switch case and update the code that creates the `authCookieValue` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `AvatarURL` method called in the preceding code will return the appropriate
    URL value which we then store in the `avatar_url` field which will be stored in
    the cookie.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gomniauth defines a `User` type of interface and each provider implements their
    own version. The generic `map[string]interface{}` data returned from the authentication
    server is stored inside each object, and the method calls access the appropriate
    value using the right field name for that provider. This approach—describing the
    way information is accessed without being strict about implementation details—is
    a great use of interfaces in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Transmitting the avatar URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to update our `message` type so that it can also carry with it the
    avatar URL. In `message.go` , add the `AvatarURL` string field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have not actually assigned a value to `AvatarURL` like we do for
    the `Name` field, so we must update our `read` method in `client.go` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All we have done here is we took the value from the `userData` field that represents
    what we put into the cookie and assigned it to the appropriate field in `message`
    if the value was present in the map. We will now take the additional step of checking
    whether the value is present because we cannot guarantee that the authentication
    service will provide a value for this field. And since it could be `nil` , it
    might cause a panic to assign it to a `string` type if it's actually missing.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the avatar to the user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that our JavaScript client gets an avatar URL value via the socket, we
    can use it to display the image alongside the messages. We do this by updating
    the `socket.onmessage` code in `chat.html` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When we receive a message, we will insert an `img` tag with the source set to
    the `AvatarURL` field from the message. We will use jQuery's `css` method to force
    a width of `50` pixels. This protects us from massive pictures spoiling our interface
    and allows us to align the image to the middle of the surrounding text.
  prefs: []
  type: TYPE_NORMAL
- en: If we build and run our application having logged in with a previous version,
    you will find that the `auth` cookie that doesn't contain the avatar URL is still
    there. We are not asked to sign in again (since we are already logged in), and
    the code that adds the `avatar_url` field never gets a chance to run. We could
    delete our cookie and refresh the page, but we would have to keep doing so whenever
    we make changes during development. Let's solve this problem properly by adding
    a logout feature.
  prefs: []
  type: TYPE_NORMAL
- en: Logging out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest way to log a user out is to get rid of the `auth` cookie and redirect
    the user to the chat page, which will in turn cause a redirect to the login page
    since we just removed the cookie. We do this by adding a new `HandleFunc` call
    to `main.go` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding handler function uses `http.SetCookie` to update the cookie setting
    `MaxAge` to `-1` , which indicates that it should be deleted immediately by the
    browser. Not all browsers are forced to delete the cookie, which is why we also
    provide a new `Value` setting of an empty string, thus removing the user data
    that would previously have been stored.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As an additional assignment, you can bulletproof your app a little by updating
    the first line in `ServeHTTP` for your `authHandler` in `auth.go` to make it cope
    with the empty-value case as well as the missing-cookie case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Instead of ignoring the return of `r.Cookie` , we keep a reference to the returned
    cookie (if there was actually one) and also add an additional check to see whether
    the `Value` string of the cookie is empty or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue, let''s add a `Sign Out` link to make it even easier to
    get rid of the cookie, and also to allow our users to log out. In `chat.html`
    , update the `chatbox` form to insert a simple HTML link to the new `/logout`
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now build and run the application and open a browser to `localhost:8080/chat`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Log out if you need to and log back in. When you click on **Send** , you will
    see your avatar picture appear next to your messages.
  prefs: []
  type: TYPE_NORMAL
- en: '![Logging out](img/Image00007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Making things prettier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our application is starting to look a little ugly, and it''s time to do something
    about it. In the previous chapter, we implemented the Bootstrap library into our
    login page, and we are now going to extend its use to our chat page. We will make
    three changes in `chat.html` : include Bootstrap and tweak the CSS styles for
    our page, change the markup for our form, and tweak how we render messages on
    the page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s update the `style` tag at the top of the page and insert a `link`
    tag above it to include Bootstrap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s replace the markup at the top of the `body` tag (before the `script`
    tags) with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This markup follows Bootstrap standards of applying appropriate classes to various
    items, for example, the `form-control` class neatly formats elements within `form`
    (you can check out the Bootstrap documentation for more information on what these
    classes do).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s update our `socket.onmessage` JavaScript code to put the sender''s
    name as the `title` attribute for our image. This makes our app display the image
    when you hover the mouse over it rather than displaying it next to every message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the application and refresh your browser to see whether a new
    design appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command shows the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making things prettier](img/Image00008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With relatively few changes to the code, we have dramatically improved the look
    and feel of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Gravatar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gravatar is a web service that allows users to upload a single profile picture
    and associate it with their e-mail address to make it available from any website.
    Developers, like us, can access those images for our application, just by performing
    a `GET` operation on a specific API endpoint. In this section, we will see how
    to implement Gravatar rather than use the picture provided by the authentication
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting the avatar URL process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we have three different ways of obtaining the avatar URL in our application,
    we have reached the point where it would be sensible to learn how to abstract
    the functionality in order to cleanly implement the options. Abstraction refers
    to a process in which we separate the idea of something from its specific implementation.
    `http.Handler` is a great example of how a handler will be used along with its
    ins and outs, without being specific about what action is taken by each handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Go, we start to describe our idea of getting an avatar URL by defining an
    interface. Let''s create a new file called `avatar.go` and insert the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Avatar` interface describes the `GetAvatarURL` method that a type must
    satisfy in order to be able to get avatar URLs. We took the client as an argument
    so that we know for which user to return the URL. The method returns two arguments:
    a string (which will be the URL if things go well) and an error in case something
    goes wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the things that could go wrong is simply that one of the specific implementations
    of `Avatar` is unable to get the URL. In that case, `GetAvatarURL` will return
    the `ErrNoAvatarURL` error as the second argument. The `ErrNoAvatarURL` error
    therefore becomes a part of the interface; it's one of the possible returns from
    the method and something that users of our code should probably explicitly handle.
    We mention this in the comments part of the code for the method, which is the
    only way to communicate such design decisions in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because the error is initialized immediately using `errors.New` and stored in
    the `ErrNoAvatarURL` variable, only one of these objects will ever be created;
    passing the pointer of the error as a return is very inexpensive. This is unlike
    Java's checked exceptions—which serve a similar purpose—where expensive exception
    objects are created and used as part of the control flow.
  prefs: []
  type: TYPE_NORMAL
- en: The authentication service and avatar's implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first implementation of `Avatar` we write will replace the existing functionality
    where we hardcoded the avatar URL obtained from the authentication service. Let''s
    use a **Test-driven Development** ( **TDD** ) approach so we can be sure our code
    works without having to manually test it. Let''s create a new file called `avatar_test.go`
    in the `chat` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This test file contains a test for our as-of-yet nonexistent `AuthAvatar` type's
    `GetAvatarURL` method. First, it uses a client with no user data and ensures that
    the `ErrNoAvatarURL` error is returned. After setting a suitable value, our test
    calls the method again—this time to assert that it returns the correct value.
    However, building this code fails because the `AuthAvatar` type doesn't exist,
    so we'll declare `authAvatar` next.
  prefs: []
  type: TYPE_NORMAL
- en: Before we write our implementation, it's worth noticing that we only declare
    the `authAvatar` variable as the `AuthAvatar` type, but never actually assign
    anything to it so its value remains `nil` . This is not a mistake; we are actually
    making use of Go's zero-initialization (or default initialization) capabilities.
    Since there is no state needed for our object (we will pass `client` as an argument),
    there is no need to waste time and memory on initializing an instance of it. In
    Go, it is acceptable to call a method on a `nil` object, provided that the method
    doesn't try to access a field. When we actually come to writing our implementation,
    we will look at a way in which we can ensure this is the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s head back over to `avatar.go` and make our test pass. Add the following
    code to the bottom of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define our `AuthAvatar` type as an empty struct and define the implementation
    of the `GetAvatarURL` method. We also create a handy variable called `UseAuthAvatar`
    that has the `AuthAvatar` type but which remains of `nil` value. We can later
    assign the `UseAuthAvatar` variable to any field looking for an `Avatar` interface
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, the receiver of a method (the type defined in parentheses before the
    name) will be assigned to a variable so that it can be accessed in the body of
    the method. Since, in our case, we assume the object can have `nil` value, we
    can use an underscore to tell Go to throw away the reference. This serves as an
    added reminder to ourselves that we should avoid using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of our implementation is otherwise relatively simple: we are safely
    looking for the value of `avatar_url` and ensuring it is a string before returning
    it. If anything fails along the way, we return the `ErrNoAvatarURL` error as defined
    in the interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the tests by opening a terminal and then navigating to the `chat`
    folder and typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: All being well, our tests will pass and we will have successfully created our
    first `Avatar` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Using an implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we use an implementation, we could refer to either the helper variables
    directly or create our own instance of the interface whenever we need the functionality.
    However, this would defeat the very object of the abstraction. Instead, we use
    the `Avatar` interface type to indicate where we need the capability.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our chat application, we will have a single way to obtain an avatar URL
    per chat room. So let''s update the `room` type so it can hold an `Avatar` object.
    In `room.go` , add the following field definition to the type `room struct` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `newRoom` function so we can pass in an `Avatar` implementation
    for use; we will just assign this implementation to the new field when we create
    our `room` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Building the project now will highlight the fact that the call to `newRoom`
    in `main.go` is broken because we have not provided an `Avatar` argument; let''s
    update it by passing in our handy `UseAuthAvatar` variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We didn't have to create an instance of `AuthAvatar` , so no memory was allocated.
    In our case, this doesn't result in great savings (since we only have one room
    for our whole application), but imagine the size of the potential savings if our
    application has thousands of rooms. The way we named the `UseAuthAvatar` variable
    means that the preceding code is very easy to read and it also makes our intention
    obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Thinking about code readability is important when designing interfaces. Consider
    a method that takes a Boolean input—just passing in true or false hides the real
    meaning if you don''t know the argument names. Consider defining a couple of helper
    constants as in the following short example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Think about which of the following calls to `move` are easier to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'All that is left now is to change `client` to use our new `Avatar` interface.
    In `client.go` , update the `read` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are asking the `avatar` instance on `room` to get the avatar URL for
    us instead of extracting it from `userData` ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: When you build and run the application, you will notice that (although we have
    refactored things a little) the behavior and user experience hasn't changed at
    all. This is because we told our room to use the `AuthAvatar` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's add another implementation to the room.
  prefs: []
  type: TYPE_NORMAL
- en: Gravatar implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Gravatar implementation in `Avitar` will do the same job as the `AuthAvatar`
    implementation, except it will generate a URL for a profile picture hosted on
    [Gravatar.com](http://Gravatar.com) . Let''s start by adding a test to our `avatar_test.go`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Gravatar uses a hash of the e-mail address to generate a unique ID for each
    profile picture, so we set up a client and ensure `userData` contains an e-mail
    address. Next, we call the same `GetAvatarURL` method, but this time on an object
    that has the `GravatarAvatar` type. We then assert that a correct URL was returned.
    We already know this is the appropriate URL for the specified e-mail address because
    it is listed as an example in the Gravatar documentation—a great strategy to ensure
    our code is doing what it should be.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall that all the source code for this book is available on GitHub. You can
    save time on building the preceding core by copying and pasting bits and pieces
    from [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)
    . Hardcoding things such as the base URL is not usually a good idea; we have hardcoded
    throughout the book to make the code snippets easier to read and more obvious,
    but you are welcome to extract them as you go along if you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running these tests (with `go test` ) obviously causes errors because we haven''t
    defined our types yet. Let''s head back to `avatar.go` and add the following code
    while being sure to import the `io` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the same pattern as we did for `AuthAvatar` : we have an empty struct,
    a helpful `UseGravatar` variable, and the `GetAvatarURL` method implementation
    itself. In this method, we follow Gravatar''s guidelines to generate an MD5 hash
    from the e-mail address (after we ensured it was lowercase) and append it to the
    hardcoded base URL.'
  prefs: []
  type: TYPE_NORMAL
- en: It is very easy to achieve hashing in Go, thanks to the hard work put in by
    the writers of the Go standard library. The `crypto` package has an impressive
    array of cryptography and hashing capabilities—all very easy to use. In our case,
    we create a new `md5` hasher; because the hasher implements the `io.Writer` interface,
    we can use `io.WriteString` to write a string of bytes to it. Calling `Sum` returns
    the current hash for the bytes written.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have noticed that we end up hashing the e-mail address every time
    we need the avatar URL. This is pretty inefficient, especially at scale, but we
    should prioritize getting stuff done over optimization. If we need to, we can
    always come back later and change the way this works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the tests now shows us that our code is working, but we haven''t yet
    included an e-mail address in the `auth` cookie. We do this by locating the code
    where we assign to the `authCookieValue` object in `auth.go` and updating it to
    grab the `Email` value from Gomniauth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The final thing we must do is tell our room to use the Gravatar implementation
    instead of the `AuthAvatar` implementation. We do this by calling `newRoom` in
    `main.go` and making the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the chat program once again and head to the browser. Remember,
    since we have changed the information stored in the cookie, we must sign out and
    sign back in again in order to see our changes take effect.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming you have a different image for your Gravatar account, you will notice
    that the system is now pulling the image from Gravatar instead of the authentication
    provider. Using your browser's inspector or debug tool will show you that the
    `src` attribute of the `img` tag has indeed changed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Gravatar implementation](img/Image00009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you don't have a Gravatar account, you'll likely see a default placeholder
    image in place of your profile picture.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading an avatar picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the third and final approach of uploading a picture, we will look at how
    to allow users to upload an image from their local hard drive to use as their
    profile picture when chatting. We will need a way to associate a file with a particular
    user to ensure that we associate the right picture with the corresponding messages.
  prefs: []
  type: TYPE_NORMAL
- en: User identification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to uniquely identify our users, we are going to copy Gravatar's approach
    by hashing their e-mail address and using the resulting string as an identifier.
    We will store the user ID in the cookie along with the rest of the user-specific
    data. This will actually have the added benefit of removing from `GravatarAuth`
    the inefficiency associated with continuous hashing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `auth.go` , replace the code that creates the `authCookieValue` object with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have hashed the e-mail address and stored the resulting value in the
    `userid` field at the point at which the user logs in. Henceforth, we can use
    this value in our Gravatar code instead of hashing the e-mail address for every
    message. To do this, first we update the test by removing the following line from
    `avatar_test.go` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We then replace the preceding line with this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We no longer need to set the `email` field since it is not used; instead, we
    just have to set an appropriate value to the new `userid` field. However, if you
    run `go test` in a terminal, you will see this test fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the test pass, in `avatar.go` , update the `GetAvatarURL` method for
    the `GravatarAuth` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This won't change the behavior, but it allows us to make an unexpected optimization,
    which is a great example of why you shouldn't optimize code too early—the inefficiencies
    that you spot early on may not last long enough to warrant the effort required
    to fix them.
  prefs: []
  type: TYPE_NORMAL
- en: An upload form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If our users are to upload a file as their avatar, they need a way to browse
    their local hard drive and submit the file to the server. We facilitate this by
    adding a new template-driven page. In the `chat/templates` folder, create a file
    called `upload.html` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We used Bootstrap again to make our page look nice and also to make it fit in
    with the other pages. However, the key point to note here is the HTML form that
    will provide the user interface necessary for uploading files. The action points
    to `/uploader` , the handler for which we have yet to implement, and the `enctype`
    attribute must be `multipart/form-data` so the browser can transmit binary data
    over HTTP. Then, there is an `input` element of the type `file` , which will contain
    the reference to the file we want to upload. Notice also that we have included
    the `userid` value from the `UserData` map as a hidden input—this will tell us
    which user is uploading a file. It is important that the `name` attributes are
    correct, as this is how we will refer to the data when we implement our handler
    on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now map the new template to the `/upload` path in `main.go` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Handling the upload
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the user clicks on **Upload** after selecting a file, the browser will
    send the data for the file as well as the user ID to `/uploader` , but right now,
    that data doesn't actually go anywhere. We will implement a new `HandlerFunc`
    that is capable of receiving the file, reading the bytes that are streamed through
    the connection, and saving it as a new file on the server. In the `chat` folder,
    let's create a new folder called `avatars` —this is where we will save the avatar
    image files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new file called `upload.go` and insert the following code—make
    sure to add the appropriate package name and imports (which are `ioutils` , `net/http`
    , `io` , and `path` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, first `uploaderHandler` uses the `FormValue` method on `http.Request`
    to get the user ID that we placed in the hidden input in our HTML form. Then it
    gets an `io.Reader` type capable of reading the uploaded bytes by calling `req.FormFile`
    , which returns three arguments. The first argument represents the file itself
    with the `multipart.File` interface type, which is also an `io.Reader` . The second
    is a `multipart.FileHeader` object that contains metadata about the file, such
    as the filename. And finally, the third argument is an error that we hope will
    have a `nil` value.
  prefs: []
  type: TYPE_NORMAL
- en: What do we mean when we say that the `multipart.File` interface type is also
    an `io.Reader` ? Well, a quick glance at the documentation at [http://golang.org/pkg/mime/multipart/#File](http://golang.org/pkg/mime/multipart/#File)
    makes it clear that the type is actually just a wrapper interface for a few other
    more general interfaces. This means that a `multipart.File` type can be passed
    to methods that require `io.Reader` , since any object that implements `multipart.File`
    must therefore implement `io.Reader` .
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Embedding standard library interfaces to describe new concepts is a great way
    to make sure your code works in as many contexts as possible. Similarly, you should
    try to write code that uses the simplest interface type you can find, ideally
    from the standard library. For example, if you wrote a method that needed to read
    the contents of a file, you could ask the user to provide an argument of the type
    `multipart.File` . However, if you ask for `io.Reader` instead, your code will
    become significantly more flexible because any type that has the appropriate `Read`
    method can be passed in, which includes user-defined types too.
  prefs: []
  type: TYPE_NORMAL
- en: The `ioutil.ReadAll` method will just keep reading from the specified `io.Reader`
    until all of the bytes have been received, so this is where we actually receive
    the stream of bytes from the client. We then use `path.Join` and `path.Ext` to
    build a new filename using `userid` , and copy the extension from the original
    filename that we can get from `multipart.FileHeader` .
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `ioutil.WriteFile` method to create a new file in the `avatars`
    folder. We use `userid` in the filename to associate the image with the correct
    user, much in the same way as Gravatar does. The `0777` value specifies that the
    new file we create has full file permissions, which is a good default setting
    if you're not sure what other permissions should be set.
  prefs: []
  type: TYPE_NORMAL
- en: If an error occurs at any stage, our code will write it out to the response,
    which will help us debug it, or it will write **Successful** if everything went
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to map this new handler function to `/uploader` , we need to head
    back to `main.go` and add the following line to `func main` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now build and run the application and remember to log out and log back in again
    to give our code a chance to upload the `auth` cookie.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Open `http://localhost:8080/upload` and click on **Choose File** , then select
    a file from your hard drive and click on **Upload** . Navigate to your `chat/avatars`
    folder and you will notice that the file was indeed uploaded and renamed to the
    value of your `userid` field.
  prefs: []
  type: TYPE_NORMAL
- en: Serving the images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a place to keep our users'' avatar images on the server, we
    need a way to make them accessible to the browser. We do this by using the `net/http`
    package''s built-in file server. In `main.go` , add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is actually a single line of code that has been broken up to improve readability.
    The `http.Handle` call should feel familiar: we are specifying that we want to
    map the `/avatars/` path with the specified handler—this is where things get interesting.
    Both `http.StripPrefix` and `http.FileServer` return `Handler` , and they make
    use of the decorator pattern we learned about in the previous chapter. The `StripPrefix`
    function takes `Handler` in, modifies the path by removing the specified prefix,
    and passes functionality onto an inner handler. In our case, the inner handler
    is an `http.FileServer` handler that will simply serve static files, provide index
    listings, and generate the `404 Not Found` error if it cannot find the file. The
    `http.Dir` function allows us to specify which folder we want to expose publicly.'
  prefs: []
  type: TYPE_NORMAL
- en: If we didn't strip the `/avatars/` prefix from the requests with `http.StripPrefix`
    , the file server would look for another folder called `avatars` inside the actual
    `avatars` folder, that is, `/avatars/avatars/filename` instead of `/avatars/filename`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Let's build the program and run it before opening `http://localhost:8080/avatars/`
    in a browser. You'll notice that the file server has generated a listing of the
    files inside our `avatars` folder. Clicking on a file will either download the
    file, or in the case of an image, simply display it. If you haven't done so already,
    go to `http://localhost:8080/upload` and upload a picture, then head back to the
    listing page and click on it to see it in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The Avatar implementation for local files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final piece to making filesystem avatars work is to write an implementation
    of our `Avatar` interface that generates URLs that point to the filesystem endpoint
    we created in the last section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a test function to our `avatar_test.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This test is similar to, but slightly more involved than, the `GravatarAvatar`
    test because we are also creating a test file in our `avatars` folder and deleting
    it afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `defer` keyword is a great way to ensure the code runs regardless of what
    happens in the rest of the function. Even if our test code panics, the deferred
    functions will still be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the test is simple: we set a `userid` field in `client.userData`
    and call `GetAvatarURL` to ensure we get back the right value. Of course, running
    this test will fail, so let''s go and add the following code to make it pass in
    `avatar.go` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As we see here, to generate the correct URL, we simply get the `userid` value
    and build the final string by adding the appropriate segments together. You may
    have noticed that we have hardcoded the file extension to `.jpg` , which means
    that the initial version of our chat application will only support JPEGs.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Supporting only JPEGs might seem like a half-baked solution, but following Agile
    methodologies, this is perfectly fine; after all, custom JPEG profile pictures
    are better than no custom profile pictures at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see our new code in action by updating `main.go` to use our new `Avatar`
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now build and run the application as usual and go to `http://localhost:8080/upload`
    and use a web form to upload a JPEG image to use as your profile picture. To make
    sure it's working correctly, choose a unique image that isn't your Gravatar picture
    or the image from the authentication service. Once you see the successful message
    after clicking on **Upload** , go to `http://localhost:8080/chat` and post a message.
    You will notice that the application has indeed used the profile picture that
    you uploaded.
  prefs: []
  type: TYPE_NORMAL
- en: To change your profile picture, go back to the `/upload` page and upload a different
    picture, then jump back to the `/chat` page and post more messages.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting different file types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To support different file types, we have to make our `GetAvatarURL` method for
    the `FileSystemAvatar` type a little smarter.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of just blindly building the string, we will use the very useful `ioutil.ReadDir`
    method to get a listing of the files. The listing also includes directories, so
    we will use the `IsDir` method to determine whether we should skip it or not.
  prefs: []
  type: TYPE_NORMAL
- en: We will then check to see whether each file starts with the `userid` field (remember
    that we named our files in this way) by a call to `path.Match` . If the filename
    matches the `userid` field, then we have found the file for that user and we return
    the path. If anything goes wrong or if we can't find the file, we return the `ErrNoAvatarURL`
    error as usual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the appropriate method in `avatar.go` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Delete all the files in the `avatar` folder to prevent confusion and rebuild
    the program. This time upload an image of a different type and notice that our
    application has no difficulty handling it.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring and optimizing our code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we look back at how our `Avatar` type is used, you will notice that every
    time someone sends a message, the application makes a call to `GetAvatarURL` .
    In our latest implementation, each time the method is called, we iterate over
    all the files in the `avatars` folder. For a particularly chatty user, this could
    mean that we end up iterating over and over again many times a minute. This is
    an obvious waste of resources and would, at some point very soon, become a scaling
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of getting the avatar URL for every message, we will get it only once
    when the user first logs in and cache it in the `auth` cookie. Unfortunately,
    our `Avatar` interface type requires that we pass in a `client` object to the
    `GetAvatarURL` method and we do not have such an object at the point at which
    we are authenticating the user.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So did we make a mistake when we designed our `Avatar` interface? While this
    is a natural conclusion to come to, in fact we did the right thing. We designed
    the solution with the best information we had available at the time and therefore
    had a working chat application much sooner than if we'd tried to design for every
    possible future case. Software evolves and almost always changes during the development
    process and will definitely change throughout the lifetime of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing concrete types with interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have concluded that our `GetAvatarURL` method depends on a type that is not
    available to us at the point we need it, so what would be a good alternative?
    We could pass each required field as a separate argument but this would make our
    interface brittle, since as soon as an `Avatar` implementation needs a new piece
    of information, we'd have to change the method signature. Instead, we will create
    a new type that will encapsulate the information our `Avatar` implementations
    need while conceptually remaining decoupled from our specific case.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `auth.go` , add the following code to the top of the page (underneath the
    `package` keyword of course):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `import` statement imported the `common` package from Gomniauth and
    at the same time gave it a specific name through which it will be accessed: `gomniauthcommon`
    . This isn''t entirely necessary since we have no package name conflicts. However,
    it makes the code easier to understand.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code snippet, we also defined a new interface type called
    `ChatUser` , which exposes the information needed in order for our `Avatar` implementations
    to generate the correct URLs. Then, we defined an actual implementation called
    `chatUser` (notice the lowercase starting letter) that implements the interface.
    It also makes use of a very interesting feature in Go: type embedding. We actually
    embedded the interface type `gomniauth/common.User` , which means that our `struct`
    implements the interface automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we only actually implemented one of the two required
    methods to satisfy our `ChatUser` interface. We got away with this because the
    Gomniauth `User` interface happens to define the same `AvatarURL` method. In practice,
    when we instantiate our `chatUser` struct—provided we set an appropriate value
    for the implied Gomniauth `User` field—our object implements both Gomniauth's
    `User` interface and our own `ChatUser` interface at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Changing interfaces in a test-driven way
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can use our new type, we must update the `Avatar` interface and appropriate
    implementations to make use of it. As we will follow TDD practices, we are going
    to make these changes in our test file, see compiler errors when we try to build
    our code, and see failing tests once we fix those errors before finally making
    the tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `avatar_test.go` and replace `TestAuthAvatar` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will also need to import the `gomniauth/test` package as `gomniauthtest`
    like we did in the last section.
  prefs: []
  type: TYPE_NORMAL
- en: Using our new interface before we have defined it is a good way to check the
    sanity of our thinking, which is another advantage of practicing TDD. In this
    new test, we create `TestUser` provided by Gomniauth and embed it into a `chatUser`
    type. We then pass the new `chatUser` type into our `GetAvatarURL` calls and make
    the same assertions about output as we always have done.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gomniauth's `TestUser` type is interesting as it makes use of the `Testify`
    package's mocking capabilities. See [https://github.com/stretchr/testify](https://github.com/stretchr/testify)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: The `On` and `Return` methods allow us to tell `TestUser` what to do when specific
    methods are called. In the first case, we tell the `AvatarURL` method to return
    the error, and in the second case, we ask it to return the `testUrl` value, which
    simulates the two possible outcomes we are covering in this test.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the `TestGravatarAvatar` and `TestFileSystemAvatar` tests is much simpler
    because they rely only on the `UniqueID` method, the value of which we can control
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the other two tests in `avatar_test.go` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this test code won''t even compile because we are yet to update
    our `Avatar` interface. In `avatar.go` , update the `GetAvatarURL` signature in
    the `Avatar` interface type to take a `ChatUser` type rather than a `client` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we are using the `ChatUser` interface (uppercase starting letter)
    rather than our internal `chatUser` implementation struct—after all, we want to
    be flexible about the types our `GetAvatarURL` methods accept.
  prefs: []
  type: TYPE_NORMAL
- en: Trying to build this will reveal that we now have broken implementations because
    all the `GetAvatarURL` methods are still asking for a `client` object.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing existing implementations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Changing an interface like the one we have is a good way to automatically find
    the parts of our code that have been affected because they will cause compiler
    errors. Of course, if we were writing a package that other people would use, we
    would have to be far stricter towards changing the interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to update the three implementation signatures to satisfy the
    new interface and change the method bodies to make use of the new type. Replace
    the implementation for `FileSystemAvatar` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The key change here is that we no longer access the `userData` field on the
    client, and instead just call `UniqueID` directly on the `ChatUser` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we update the `AuthAvatar` implementation with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Our new design is proving to be much simpler; it's always a good thing if we
    can reduce the amount of code needed. The preceding code makes a call to get the
    `AvatarURL` value, and provided it isn't empty (or `len(url) > 0` ), we return
    it; else, we return the `ErrNoAvatarURL` error instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, update the `GravatarAvatar` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Global variables versus fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we have assigned the `Avatar` implementation to the `room` type, which
    enables us to use different avatars for different rooms. However, this has exposed
    an issue: when our users sign in, there is no concept of which room they are headed
    to so we cannot know which `Avatar` implementation to use. Because our application
    only supports a single room, we are going to look at another approach toward selecting
    implementations: the use of global variables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A global variable is simply a variable that is defined outside any type definition
    and is accessible from every part of the package (and from outside the package
    if it''s exported). For a simple configuration, such as which type of `Avatar`
    implementation to use, they are an easy and simple solution. Underneath the `import`
    statements in `main.go` , add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This defines `avatars` as a global variable that we can use when we need to
    get the avatar URL for a particular user.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our new design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to change the code that calls `GetAvatarURL` for every message to just
    access the value that we put into the `userData` cache (via the `auth` cookie).
    Change the line where `msg.AvatarURL` is assigned, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the code inside `loginHandler` in `auth.go` where we call `provider.GetUser`
    and replace it down to where we set the `authCookieValue` object with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a new `chatUser` variable while setting the `User` field (which
    represents the embedded interface) to the `User` value returned from Gomniauth.
    We then saved the `userid` MD5 hash to the `uniqueID` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The call to `avatars.GetAvatarURL` is where all of our hard work has paid off,
    as we now get the avatar URL for the user far earlier in the process. Update the
    `authCookieValue` line in `auth.go` to cache the avatar URL in the cookie and
    remove the e-mail address since it is no longer needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: However expensive the work that the `Avatar` implementation needs to do, like
    iterating over files on the filesystem, it is mitigated by the fact that the implementation
    only does so when the user first logs in, and not every time they send a message.
  prefs: []
  type: TYPE_NORMAL
- en: Tidying up and testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, we get to snip away some of the fat that has accumulated during our
    refactoring process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we no longer store the `Avatar` implementation in `room` , let''s remove
    the field and all references to it from the type. In `room.go` , delete the `avatar
    Avatar` definition from the `room` struct and update the `newRoom` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to use the compiler as your to-do list where possible, and follow the
    errors to find where you have impacted other code.
  prefs: []
  type: TYPE_NORMAL
- en: In `main.go` , remove the parameter passed into the `newRoom` function call
    since we are using our global variable instead of this one.
  prefs: []
  type: TYPE_NORMAL
- en: After this exercise, the end user experience remains unchanged. Usually, when
    refactoring the code, it is the internals that are modified while the public-facing
    interface remains stable and unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's usually a good idea to run tools such as `golint` and `go vet` against
    your code as well to make sure it follows good practices and doesn't contain any
    Go faux pas such as missing comments or badly named functions.
  prefs: []
  type: TYPE_NORMAL
- en: Combining all three implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To close this chapter off with a bang, we will implement a mechanism in which
    each `Avatar` implementation takes a turn in trying to get the value. If the first
    implementation returns the `ErrNoAvatarURL` error, we will try the next and so
    on until we find a useable value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `avatar.go` , underneath the `Avatar` type, add the following type definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TryAvatars` type is simply a slice of `Avatar` objects; therefore, we
    will add the following `GetAvatarURL` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This means that `TryAvatars` is now a valid `Avatar` implementation and can
    be used in place of any specific implementation. In the preceding method, we iterated
    over the slice of `Avatar` objects in an order, calling `GetAvatarURL` for each
    one. If no error is returned, we return the URL; otherwise, we carry on looking.
    Finally, if we are unable to find a value, we just return `ErrNoAvatarURL` as
    per the interface design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `avatars` global variable in `main.go` to use our new implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here we created a new instance of our `TryAvatars` slice type while putting
    the other `Avatar` implementations inside it. The order matters since it iterates
    over the objects in the order in which they appear in the slice. So, first our
    code will check to see whether the user has uploaded a picture; if they haven't,
    the code will check whether the authentication service has a picture for us to
    use. If both the approaches fail, a Gravatar URL will be generated, which in the
    worst case (for example, if the user hasn't added a Gravatar picture), will render
    a default placeholder image.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see our new functionality in action, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and rerun the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Log out by visiting `http://localhost:8080/logout` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete all the pictures from the `avatars` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log back in by navigating to `http://localhost:8080/chat` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send some messages and take note of your profile picture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit `http://localhost:8080/upload` and upload a new profile picture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log out again and log back in as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send some more messages and notice that your profile picture has updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added three different implementations of profile pictures
    to our chat application. First we asked the authentication service to provide
    a URL for us to use. We did this by using Gomniauth's abstraction of the user
    resource data, which we then included as part of the user interface every time
    a user would send a message. Using Go's zero (or default) initialization pattern,
    we were able to refer to different implementations of our `Avatar` interface without
    actually creating any instances.
  prefs: []
  type: TYPE_NORMAL
- en: We stored data in a cookie for when the user would log in. Therefore, and also
    given the fact that cookies persist between builds of our code, we added a handy
    logout feature to help us validate our changes, which we also exposed to our users
    so that they could log out too. Other small changes to the code and the inclusion
    of Bootstrap on our chat page dramatically improved the look and feel of our application.
  prefs: []
  type: TYPE_NORMAL
- en: We used MD5 hashing in Go to implement the [Gravatar.com](http://Gravatar.com)
    API by hashing the e-mail address that the authentication service provided. If
    the e-mail address is not known to Gravatar, they will deliver a nice default
    placeholder image for us, which means our user interface will never be broken
    due to missing images.
  prefs: []
  type: TYPE_NORMAL
- en: We then built and completed an upload form and associated the server functionality
    that saved uploaded pictures in the `avatars` folder. We saw how to expose the
    saved uploaded pictures to users via the standard library's `http.FileServer`
    handler. As this introduced inefficiencies in our design by causing too much filesystem
    access, we refactored our solution with the help of our unit tests. By moving
    the `GetAvatarURL` call to the point at which users log in, rather than every
    time a message is sent, we made our code significantly more scalable.
  prefs: []
  type: TYPE_NORMAL
- en: Our special `ErrNoAvatarURL` error type was used as part of our interface design
    to allow us to inform the calling code when it was not possible to obtain an appropriate
    URL—this became particularly useful when we created our `Avatars` slice type.
    By implementing the `Avatar` interface on a slice of `Avatar` types, we were able
    to make a new implementation that took turns trying to get a valid URL from each
    of the different options available, starting with the filesystem, then the authentication
    service, and finally Gravatar. We achieved this with zero impact on how the user
    would interact with the interface. If an implementation returned `ErrNoAvatarURL`
    , we tried the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Our chat application is ready to go live so we can invite our friends and have
    a real conversation. But first we need to choose a domain name to host it at,
    something we will look at in the next chapter.
  prefs: []
  type: TYPE_NORMAL

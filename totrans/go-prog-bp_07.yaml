- en: Chapter 7. Random Recommendations Web Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept behind the project that we will build in this chapter is a simple
    one: we want users to be able to generate random recommendations for things to
    do in specific geographical locations based on a predefined set of journey types
    that we will expose through the API. We will give our project the codename Meander.'
  prefs: []
  type: TYPE_NORMAL
- en: Often on projects in the real world, you are responsible for the full stack;
    somebody else builds the website, a different person still might write the iOS
    app, and maybe an outsourced company builds the desktop version. On more successful
    API projects, you might not even know who the consumers of your API are, especially
    if it's a public API.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will simulate this reality by designing and agreeing a minimal
    API design with a fictional partner up front before going on to implement the
    API. Once we have finished our side of the project, we will download a user interface
    built by our teammates to see the two work together to produce the final application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn to express the general goals of a project using short and simple Agile
    user stories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover that you can agree a meeting point in a project by agreeing on the
    design of an API, which allows many people to work in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how early versions of code can actually have data fixtures written in code
    and compiled into the program, allowing us to change the implementation later
    without touching the interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn a strategy that allows structs (and other types) to represent a public
    version of themselves for cases when we want to hide or transform internal representations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to use embedded structs to represent nested data, while keeping the interface
    of our types simple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to use `http.Get` to make external API requests, specifically to the Google
    Places API, with no code bloat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to effectively implement enumerators in Go, even though they aren't really
    a language feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experience a real-world example of TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how the `math/rand` package makes it easy to select an item from a slice
    at random
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn an easy way to grab data from the URL parameters of the `http.Request`
    type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following Agile methodologies, let's write two user stories that describe the
    functionality of our project. User stories shouldn't be comprehensive documents
    describing the entire set of features of an application; rather small cards are
    perfect for not only describing what the user is trying to do, but why. Also,
    we should do this without trying to design the whole system up front or delve
    too deep into implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need a story about seeing the different journey types from which our
    users may select:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **As a** | traveler |'
  prefs: []
  type: TYPE_TB
- en: '| **I want** | to see the different types of journeys I can get recommendations
    for |'
  prefs: []
  type: TYPE_TB
- en: '| **So that** | I can decide what kind of evening to take my partner on |'
  prefs: []
  type: TYPE_TB
- en: 'Secondly, we need a story about providing random recommendations for a selected
    journey type:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **As a** | traveler |'
  prefs: []
  type: TYPE_TB
- en: '| **I want** | to see a random recommendation for my selected journey type
    |'
  prefs: []
  type: TYPE_TB
- en: '| **So that** | I know where to go, and what the evening will entail |'
  prefs: []
  type: TYPE_TB
- en: These two stories represent the two core capabilities that our API needs to
    provide, and actually ends up representing two endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: In order to discover places around specified locations, we are going to make
    use of the Google Places API, which allows us to search for listings of businesses
    with given types, such as `bar` , `café` , or `movie_theater` . We will then use
    Go's `math/rand` package to pick from those places at random, building up a complete
    journey for our users.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Google Places API supports many business types; see [https://developers.google.com/places/documentation/supported_types](https://developers.google.com/places/documentation/supported_types)
    for the complete list.
  prefs: []
  type: TYPE_NORMAL
- en: Project design specifics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to turn our stories into an interactive application, we are going to
    provide two JSON endpoints; one to deliver the kinds of journeys users will be
    able to select in the application, and another to actually generate the random
    recommendations for the selected journey type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The above call should return a list such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `name` field is a human-readable label for the type of recommendations
    the app generates, and the `journey` field is a pipe-separated list of supported
    journey types. It is the journey value that we will pass, as a URL parameter,
    into our other endpoint, which generates the actual recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This endpoint is responsible for querying the Google Places API and generating
    the recommendations before returning an array of place objects. We will use the
    parameters in the URL to control the kind of query to make as per the HTTP specification.
    The `lat` and `lng` parameters, representing latitude and longitude, respectively,
    tell our API where in the world we want recommendations from, and the `radius`
    parameter represents the distance in meters around the point in which we are interested
    in. The `cost` value is a human-readable way of representing the price range for
    places that the API returns. It is made up of two values: a lower and upper range
    separated by three dots. The number of dollar characters represents the price
    level, with `$` being the most affordable and `$$$$$` being the most expensive.
    Using this pattern, a value of `$...$$` would represent very low cost recommendations,
    where `$$$$...$$$$$` would represent a pretty expensive experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some programmers might insist the cost range is represented by numerical values,
    but since our API is going to be consumed by people, why not make things a little
    more interesting?
  prefs: []
  type: TYPE_NORMAL
- en: 'An example payload for this call might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The array returned contains a place object representing a random recommendation
    for each segment in the journey, in the appropriate order. The preceding example
    is a café in London. The data fields are fairly self-explanatory; the `lat` and
    `lng` fields represent the location of the place (they're short for latitude and
    longitude), the `name` and `vicinity` fields tell us what and where the business
    is, and the `photos` array gives us a list of relevant photographs from Google's
    servers. The `vicinity` and `icon` fields will help us deliver a richer experience
    to our users.
  prefs: []
  type: TYPE_NORMAL
- en: Representing data in code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are first going to expose the journeys that users can select from, so create
    a new folder called `meander` in `GOPATH` , and add the following `journeys.go`
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here we define an internal type called `j` inside the `meander` package, which
    we then use to describe the journeys by creating instances of them inside the
    `Journeys` slice. This approach is an ultra-simple way of representing data in
    the code, without building in a dependency on an external data store.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an additional assignment, why not see if you can keep `golint` happy throughout
    this process? Every time you add some code, run `golint` for the packages and
    satisfy any suggestions that emerge. It cares a lot about exported items having
    no documentation, so adding simple comments in the correct format will keep it
    happy. To learn more about `golint` , see [https://github.com/golang/lint](https://github.com/golang/lint)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this would likely evolve into just that later, maybe even with the
    ability for users to create and share their own journeys. Since we are exposing
    our data via an API, we are free to change the internal implementation without
    affecting the interface, so this approach is great for a version 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using a slice of type `[]interface{}` because we will later implement
    a general way of exposing public data regardless of actual types.
  prefs: []
  type: TYPE_NORMAL
- en: A romantic journey consists of a visit first to a park, then a bar, a movie
    theater, then a restaurant, before a visit to a florist, and finally a taxi ride
    home; you get the general idea. Feel free to get creative and add others by consulting
    the supported types in the Google Places API.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that since we are containing our code inside a package
    called `meander` (rather than `main` ), our code can never be run as a tool like
    the other APIs we have written so far. Create a new folder called `cmd` inside
    `meander` ; this will house the actual command-line tool that exposes the `meander`
    package's capabilities via an HTTP endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `cmd` folder, add the following code to the `main.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You will recognize this as a simple API endpoint program, mapping to the `/journeys`
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You'll have to import the `encoding/json` , `net/http` , and `runtime` packages,
    along with the `meander` package you created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The `runtime.GOMAXPROCS` call sets the maximum number of CPUs that our program
    can use, and we tell it to use them all. We then set the value of `APIKey` in
    the `meander` package (which is commented out for now, since we have yet to implement
    it) before calling the familiar `HandleFunc` function on the `net/http` package
    to bind our endpoint, which then just responds with the `meander.Journeys` variable.
    We borrow the abstract responding concept from the previous chapter by providing
    a `respond` function that encodes the specified data to the `http.ResponseWriter`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run our API program by navigating to the `cmd` folder in a terminal
    and using `go run` . We don''t need to build this into an executable file at this
    stage since it''s just a single file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Hit the `http://localhost:8080/journeys` endpoint, and notice that our `Journeys`
    data payload is served, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is perfectly acceptable, but there is one major flaw: it exposes internals
    about our implementation. If we changed the `PlaceTypes` field name to `Types`
    , our API would change and it''s important that we avoid this.'
  prefs: []
  type: TYPE_NORMAL
- en: Projects evolve and change over time, especially successful ones, and as developers
    we should do what we can to protect our customers from the impact of the evolution.
    Abstracting interfaces is a great way to do this, as is taking ownership of the
    public-facing view of our data objects.
  prefs: []
  type: TYPE_NORMAL
- en: Public views of Go structs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to control the public view of structs in Go, we need to invent a way
    to allow individual `journey` types to tell us how they want to be exposed. In
    the `meander` folder, create a new file called `public.go` , and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `Facade` interface exposes a single `Public` method, which will return the
    public view of a struct. The `Public` function takes any object and checks to
    see whether it implements the `Facade` interface (does it have a `Public() interface{}`
    method?); and if it is implemented, calls the method and returns the result—otherwise
    it just returns the original object untouched. This allows us to pass anything
    through the `Public` function before writing the result to the `ResponseWriter`
    object, allowing individual structs to control their public appearance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement a `Public` method for our `j` type by adding the following
    code to `journeys.go` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The public view of our `j` type joins the `PlaceTypes` field into a single string
    separated by the pipe character, as per our API design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head back to `cmd/main.go` and replace the `respond` method with one that makes
    use of our new `Public` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we iterate over the data slice calling the `meander.Public` function for
    each item, building the results into a new slice of the same size. In the case
    of our `j` type, its `Public` method will be called to serve the public view of
    the data, rather than the default view. In a terminal, navigate to the `cmd` folder
    again and run `go run main.go` before hitting `http://localhost:8080/journeys`
    again. Notice that the same data has now changed to a new structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Generating random recommendations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to obtain the places from which our code will randomly build up recommendations,
    we need to query the Google Places API. In the `meander` folder, add the following
    `query.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code defines the structures we will need to parse the JSON response from
    the Google Places API into usable objects.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Head over to the Google Places API documentation for an example of the response
    we are expecting. See [http://developers.google.com/places/documentation/search](http://developers.google.com/places/documentation/search)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Most of the preceding code will be obvious, but it's worth noticing that the
    `Place` type embeds the `googleGeometry` type, which allows us to represent the
    nested data as per the API, while essentially flattening it in our code. We do
    the same with `googleLocation` inside `googleGeometry` , which means that we will
    be able to access the `Lat` and `Lng` values directly on a `Place` object, even
    though they're technically nested in other structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we want to control how a `Place` object appears publically, let''s
    give this type the following `Public` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to run `golint` on this code to see which comments need to be added
    to the exported items.
  prefs: []
  type: TYPE_NORMAL
- en: Google Places API key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like with most APIs, we will need an API key in order to access the remote services.
    Head over to the Google APIs Console, sign in with a Google account, and create
    a key for the Google Places API. For more detailed instructions, see the documentation
    on Google's developer website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have your key, let''s make a variable inside the `meander` package
    that can hold it. At the top of `query.go` , add the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now nip back into `main.go` , remove the double slash `//` from the `APIKey`
    line, and replace the `TODO` value with the actual key provided by the Google
    APIs console.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerators in Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To handle the various cost ranges for our API, it makes sense to use an enumerator
    (or **enum** ) to denote the various values and to handle conversions to and from
    string representations. Go doesn't explicitly provide enumerators, but there is
    a neat way of implementing them, which we will explore in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple flexible checklist for writing enumerators in Go is:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a new type, based on a primitive integer type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use that type whenever you need users to specify one of the appropriate values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `iota` keyword to set the values in a `const` block, disregarding the
    first zero value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a map of sensible string representations to the values of your enumerator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a `String` method on the type that returns the appropriate string
    representation from the map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a `ParseType` function that converts from a string to your type using
    the map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we will write an enumerator to represent the cost levels in our API. Create
    a new file called `cost_level.go` inside the `meander` folder and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here we define the type of our enumerator, which we have called `Cost` , and
    since we only need to represent a few values, we have based it on an `int8` range.
    For enumerators where we need larger values, you are free to use any of the integer
    types that work with `iota` . The `Cost` type is now a real type in its own right,
    and we can use it wherever we need to represent one of the supported values—for
    example, we can specify a `Cost` type as an argument in functions, or use it as
    the type for a field in a struct.
  prefs: []
  type: TYPE_NORMAL
- en: We then define a list of constants of that type, and use the `iota` keyword
    to indicate that we want incrementing values for the constants. By disregarding
    the first `iota` value (which is always zero), we indicate that one of the specified
    constants must be explicitly used, rather than the zero value.
  prefs: []
  type: TYPE_NORMAL
- en: To provide a string representation of our enumerator, we need only add a `String`
    method to the `Cost` type. This is a useful exercise even if you don't need to
    use the strings in your code, because whenever you use the print calls from the
    Go standard library (such as `fmt.Println` ), the numerical values will be used
    by default. Often those values are meaningless and will require you to look them
    up, and even count the lines to determine the numerical value for each item.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about the `String()` method in Go, see the `Stringer` and
    `GoStringer` interfaces in the `fmt` package at [http://golang.org/pkg/fmt/#Stringer](http://golang.org/pkg/fmt/#Stringer)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven enumerator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To be sure that our enumerator code is working correctly, we are going to write
    unit tests that make some assertions about expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alongside `cost_level.go` , add a new file called `cost_level_test.go` , and
    add the following unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You will need to run `go get` to get the CheekyBits' `is` package (from [github.com/cheekybits/is](http://github.com/cheekybits/is)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `is` package is an alternative testing helper package, but this one is ultra-simple
    and deliberately bare-bones. You get to pick your favorite when you write your
    own projects.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, we wouldn't worry about the actual integer value of constants in our
    enumerator, but since the Google Places API uses numerical values to represent
    the same thing, we need to care about the values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have noticed something strange about this test file that breaks from
    convention. Although it is inside the `meander` folder, it is not a part of the
    `meander` package; rather it's in `meander_test` .
  prefs: []
  type: TYPE_NORMAL
- en: In Go, this is an error in every case except for tests. Because we are putting
    our test code into its own package, it means that we no longer have access to
    the internals of the `meander` package—notice how we have to use the package prefix.
    This may seem like a disadvantage, but in fact it allows us to be sure that we
    are testing the package as though we were a real user of it. We may only call
    exported methods and only have visibility into exported types; just like our users.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests by running `go test` in a terminal, and notice that it passes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another test to make assertions about the string representations
    for each `Cost` constant. In `cost_level_test.go` , add the following unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This test asserts that calling the `String` method for each constant yields
    the expected value. Running these tests will of course fail, because we haven't
    yet implemented the `String` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Underneath the `Cost` constants, add the following map and the `String` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `map[string]Cost` variable maps the cost values to the string representation,
    and the `String` method iterates over the map to return the appropriate value.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our case, a simple return `strings.Repeat("$", int(l))` would work just as
    well (and wins because it's simpler code), but it often won't, therefore this
    section explores the general approach.
  prefs: []
  type: TYPE_NORMAL
- en: Now if we were to print out the `Cost3` value, we would actually see `$$$` ,
    which is much more useful than numerical vales. However, since we do want to use
    these strings in our API, we are also going to add a `ParseCost` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `cost_value_test.go` , add the following unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here we assert that calling `ParseCost` will in fact yield the appropriate value
    depending on the input string.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `cost_value.go` , add the following implementation code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Parsing a `Cost` string is very simple since this is how our map is laid out.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we need to represent a range of cost values, let''s imagine a `CostRange`
    type, and write the tests out for how we intend to use it. Add the following tests
    to `cost_value_test.go` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We specify that passing in a string with two dollar characters first, followed
    by three dots and then three dollar characters should create a new `meander.CostRange`
    type that has `From` set to `meander.Cost2` , and `To` set to `meander.Cost3`
    . The second test does the reverse by testing that the `CostRange.String` method
    returns the appropriate value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our tests pass, add the following `CostRange` type and associated `String`
    and `ParseString` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to convert a string such as `$...$$$$$` to a structure that contains
    two `Cost` values; a `From` and `To` set and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Querying the Google Places API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we are capable of representing the results of the API, we need a way
    to represent and initiate the actual query. Add the following structure to `query.go`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This structure contains all the information we will need to build up the query,
    all of which will actually come from the URL parameters in the requests from the
    client. Next, add the following `find` method, which will be responsible for making
    the actual request to Google''s servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: First we build the request URL as per the Google Places API specification, by
    appending the `url.Values` encoded string of the data for `lat` , `lng` , `radius`
    , and of course the `APIKey` values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `url.Values` type is actually a `map[string][]string` type, which is why
    we use `make` rather than `new` .
  prefs: []
  type: TYPE_NORMAL
- en: The `types` value we specify as an argument represents the kind of business
    to look for. If there is a `CostRangeStr` , we parse it and set the `minprice`
    and `maxprice` values, before finally calling `http.Get` to actually make the
    request. If the request is successful, we defer the closing of the response body
    and use a `json.Decoder` method to decode the JSON that comes back from the API
    into our `googleResponse` type.
  prefs: []
  type: TYPE_NORMAL
- en: Building recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next we need to write a method that will allow us to make many calls to find,
    for the different steps in a journey. Underneath the `find` method, add the following
    `Run` method to the `Query` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is set the random seed to the current time in nanoseconds
    past since January 1, 1970 UTC. This ensures that every time we call the `Run`
    method and use the `rand` package, the results will be different. If we didn't
    do this, our code would suggest the same recommendations every time, which defeats
    the object.
  prefs: []
  type: TYPE_NORMAL
- en: Since we need to make many requests to Google—and since we want to make sure
    this is as quick as possible—we are going to run all the queries at the same time
    by making concurrent calls to our `Query.find` method. So we next create a `sync.WaitGroup`
    method, and a map to hold the selected places along with a `sync.Mutex` method
    to allow many go routines to access the map concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: We then iterate over each item in the `Journey` slice, which might be `bar`
    , `cafe` , `movie_theater` . For each item, we add `1` to the `WaitGroup` object,
    and call a goroutine. Inside the routine, we first defer the `w.Done` call informing
    the `WaitGroup` object that this request has completed, before calling our `find`
    method to make the actual request. Assuming no errors occurred, and it was indeed
    able to find some places, we iterate over the results and build up a usable URL
    for any photos that might be present. According to the Google Places API, we are
    given a `photoreference` key, which we can use in another API call to get the
    actual image. To save our clients from having to have knowledge of the Google
    Places API at all, we build the complete URL for them.
  prefs: []
  type: TYPE_NORMAL
- en: We then lock the map locker and with a call to `rand.Intn` , pick one of the
    options at random and insert it into the right position in the `places` slice,
    before unlocking the `sync.Mutex` method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we wait for all goroutines to complete with a call to `w.Wait` , before
    returning the places.
  prefs: []
  type: TYPE_NORMAL
- en: Handlers that use query parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we need to wire up our `/recommendations` call, so head back to `main.go`
    in the `cmd` folder, and add the following code inside the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This handler is responsible for preparing the `meander.Query` object and calling
    its `Run` method, before responding with the results. The `http.Request` type's
    URL value exposes the `Query` data that provides a `Get` method that, in turn,
    looks up a value for a given key.
  prefs: []
  type: TYPE_NORMAL
- en: The journey string is translated from the `bar|cafe|movie_theater` format to
    a slice of strings, by splitting on the pipe character. Then a few calls to functions
    in the `strconv` package turn the string latitude, longitude, and radius values
    into numerical types.
  prefs: []
  type: TYPE_NORMAL
- en: CORS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final piece of the first version of our API will be to implement CORS as
    we did in the previous chapter. See if you can solve this problem yourself before
    reading on to the solution in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are going to tackle this yourself, remember that your aim is to set the
    `Access-Control-Allow-Origin` response header to `*` . Also consider the `http.HandlerFunc`
    wrapping we did in the previous chapter. The best place for this code is probably
    in the `cmd` program, since that is what exposes the functionality through an
    HTTP endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main.go` , add the following `cors` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This familiar pattern takes in an `http.HandlerFunc` type and returns a new
    one that sets the appropriate header before calling the passed-in function. Now
    we can modify our code to make sure the `cors` function gets called for both of
    our endpoints. Update the appropriate lines in the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now calls to our API will be allowed from any domain without a cross-origin
    error occurring.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we are ready to test our API, head to a console and navigate to the
    `cmd` folder. Because our program imports the `meander` package, building the
    program will automatically build our `meander` package too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To see meaningful results from our API, let's take a minute to find your actual
    latitude and longitude. Head over to [http://mygeoposition.com/](http://mygeoposition.com/)
    and use the web tools to get the `x,y` values for a location you are familiar
    with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or pick from these popular cities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'London, England: `51.520707 x 0.153809`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New York, USA: `40.7127840 x -74.0059410`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tokyo, Japan: `35.6894870 x 139.6917060`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'San Francisco, USA: `37.7749290 x -122.4194160`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now open a web browser and access the `/recommendations` endpoint with some
    appropriate values for the fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows what a sample recommendation around London might
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing our API](img/Image00013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Feel free to play around with the values in the URL to see how powerful the
    simple API is by trying various journey strings, tweaking the locations, and trying
    different cost range value strings.
  prefs: []
  type: TYPE_NORMAL
- en: Web application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are going to download a complete web application built to the same API specifications,
    and point it at our implementation to see it come to life before our eyes. Head
    over to [https://github.com/matryer/goblueprints/tree/master/chapter7/meanderweb](https://github.com/matryer/goblueprints/tree/master/chapter7/meanderweb)
    and download the `meanderweb` project into your `GOPATH` .
  prefs: []
  type: TYPE_NORMAL
- en: 'In a terminal, navigate to the `meanderweb` folder, and build and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will start a website running on `localhost:8081` , which is hardcoded to
    look for the API running at `localhost:8080` . Because we added the CORS support,
    this won't be a problem despite them running on different domains.
  prefs: []
  type: TYPE_NORMAL
- en: Open a browser to `http://localhost:8081/` and interact with the application,
    while somebody else built the UI it would be pretty useless without the API that
    we built powering it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built an API that consumes and abstracts the Google Places
    API to provide a fun and interesting way of letting users plan their days and
    evenings.
  prefs: []
  type: TYPE_NORMAL
- en: We started by writing some simple and short user stories that described at a
    really high level what we wanted to achieve, without trying to design the implementation
    up front. In order to parallelize the project, we agreed the meeting point of
    the project as the API design, and we built towards it (as would our partners).
  prefs: []
  type: TYPE_NORMAL
- en: We embedded data directly in code, avoiding the need to investigate, design,
    and implement a data store in the early stages of a project. By caring instead
    about how that data is accessed (via the API endpoint), we allowed our future
    selves to completely change how and where the data is stored, without breaking
    any apps that have been written to our API.
  prefs: []
  type: TYPE_NORMAL
- en: We implemented the `Facade` interface, which allows our structs and other types
    to provide public representations of them, without revealing messy or sensitive
    details about our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Our foray into enumerators gave us a useful starting point to build enumerated
    types, even though there is no official support for them in the language. The
    `iota` keyword that we used lets us specify constants of our own numerical type,
    with incrementing values. The common `String` method that we implemented showed
    us how to make sure our enumerated types don't become obscure numbers in our logs.
    At the same time, we also saw a real-world example of TDD, and red/green programming
    where we wrote unit tests that first fail, but which we then go on to make pass
    by writing the implementation code.
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

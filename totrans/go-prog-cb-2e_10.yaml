- en: Parallelism and Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipes in this chapter cover worker pools, wait groups for asynchronous
    operations, and the use of the `context` package. Parallelism and concurrency
    are some of the most advertised and promoted features of the Go language. This
    chapter will offer a number of useful patterns to get you started and help you
    understand these features.
  prefs: []
  type: TYPE_NORMAL
- en: Go provides primitives that make parallel applications possible. Goroutines
    allow any function to become asynchronous and concurrent. Channels allow an application
    to set up communication with Goroutines. One of the famous sayings in Go is, "*Do
    not communicate by sharing memory; instead, share memory by communicating*", and
    is from [https://blog.golang.org/share-memory-by-communicating](https://blog.golang.org/share-memory-by-communicating).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using channels and the select statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing async operations with sync.WaitGroup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using atomic operations and mutex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the context package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing state management for channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the worker pool design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using workers to create pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to proceed with all the recipes in this chapter, configure your environment
    according to these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install Go 1.12.6 or greater on your operating system from [https://golang.org/doc/install](https://golang.org/doc/install).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a Terminal or console application, and create and navigate to a project
    directory such as `~/projects/go-programming-cookbook`. All the code will be run
    and modified from this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clone the latest code into `~/projects/go-programming-cookbook-original` and
    (optionally) work from that directory, rather than typing in the examples manually:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Using channels and the select statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go channels, in combination with Goroutines, are first-class citizens for asynchronous
    communication. Channels become especially powerful when we use select statements.
    These statements allow a Goroutine to intelligently handle requests from multiple
    channels at once.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter10/channels` and
    navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a file called `go.mod` that contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter10/channels`,
    or use this as an opportunity to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `sender.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `printer.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the following output, but the print ordering may differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe demonstrates two ways to launch a worker process that either reads
    or writes to a channel, and may potentially do both. The worker will terminate
    when the `done` channel is written to, or when `context` is cancelled through
    the calling of the cancel function or by timing out. The *Using the context package*
    recipe will cover the `context` package in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The `main` package is used to wire together the separate functions; thanks to
    this, it is possible to set up multiple pairs as long as the channels are not
    shared. In addition to this, it's possible to have multiple Goroutines listening
    on the same channel, as we'll explore in the *Using the worker pool design pattern*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, due to the asynchronous nature of Goroutines, it can be tricky to establish
    cleanup and terminate conditions; for example, a common mistake is to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: By putting the `Tick` in the `select` statement, it's possible to prevent this
    case from ever occurring. There's also no simple way to prioritize traffic in
    a `select` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Performing async operations with sync.WaitGroup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it is useful to perform a number of operations asynchronously, and
    then wait until they complete before moving on. For example, if an operation requires
    pulling information from multiple APIs and aggregating that information, it can
    be helpful to make those client requests asynchronously. This recipe will explore
    using `sync.WaitGroup` to orchestrate non-dependent tasks in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter10/waitgroup` and
    navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a file called `go.mod` that contains the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter10/waitgroup`,
    or use this as an opportunity to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `tasks.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `process.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to use `waitgroups` as a synchronization mechanism
    when waiting for work. In essence, `waitgroup.Wait()` will wait until its internal
    counter has reached `0`. The `waitgroup.Add(int)` method will increment the counter
    by the amount that's entered, and `waitgroup.Done()` will decrement the counter
    by `1`. Because of this, it is necessary to asynchronously `Wait()` while the
    various Goroutines mark `waitgroup` as `Done()`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we increment before dispatching each HTTP request and then call
    a defer `wg.Done()` method so that we can decrement whenever the Goroutine terminates.
    We then wait for all Goroutines to finish before returning our aggregated results.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, it's better to use channels for passing the errors and responses
    around.
  prefs: []
  type: TYPE_NORMAL
- en: When performing operations asynchronously like this, you should consider thread
    safety for things such as modifying a shared map. If you keep this in mind, `waitgroups`
    are a useful feature for waiting on any kind of asynchronous operation.
  prefs: []
  type: TYPE_NORMAL
- en: Using atomic operations and mutex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a language such as Go, where you can build in asynchronous operations and
    parallelism, it becomes important to consider things such as thread safety. For
    example, it is dangerous to access a map from multiple Goroutines simultaneously.
    Go provides a number of helpers in the `sync` and `sync/atomic` packages to make
    sure that certain events occur only once, or that Goroutines can serialize on
    an operation.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will demonstrate the use of these packages to safely modify a map
    with various Goroutines and to keep a global ordinal value that can be safely
    accessed by numerous Goroutines. It will also showcase the `Once.Do` method, which
    can be used to ensure that something is only done by a Go application once, such
    as reading a configuration file or initializing a variable.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter10/atomic` and
    navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a file called `go.mod` that contains the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter10/atomic`,
    or use this as an opportunity to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `map.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `ordinal.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our map recipe, we used a `ReadWrite` mutex. The idea behind this mutex
    is that any number of readers can acquire a read lock, but only one writer can
    acquire a write lock. Additionally, a writer cannot acquire a lock when anyone
    else (a reader or a writer) has one. This is useful because reads are very fast
    and non-blocking, compared to a standard mutex. Whenever we want to set data,
    we use the `Lock()` object, and whenever we want to read data, we use `RLock()`.
    It is critical that you use `Unlock()` or `RUnlock()` eventually so that you don't
    deadlock your application. A deferred `Unlock()` object can be useful, but may
    be slower than calling `Unlock()` manually.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern may not be flexible enough when you want to group additional actions
    with the locked value. For example, in some cases, you may want to lock, do some
    additional processing, and only after you've completed this will you unlock. It's
    important to consider this for your designs.
  prefs: []
  type: TYPE_NORMAL
- en: The `sync/atmoic` package is used by `Ordinal` to get and set values. There
    are also atomic comparison operations, such as `atomic.CompareAndSwapUInt64()`,
    which are extremely valuable. This recipe allows `Init` to be called on an `Ordinal`
    object only once; otherwise, it can only be incremented and does so atomically.
  prefs: []
  type: TYPE_NORMAL
- en: We loop and create 10 Goroutines (synchronizing with `sync.Waitgroup`) and show
    that the ordinal correctly incremented 10 times and that every key in our map
    was appropriately set.
  prefs: []
  type: TYPE_NORMAL
- en: Using the context package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several recipes throughout this book make use of the `context` package. This
    recipe will explore the basics of creating and managing contexts. A good reference
    for understanding context is [https://blog.golang.org/context](https://blog.golang.org/context).
    Since this blog post was written, context moved from `net/context` to a package
    called `context`. This still occasionally causes problems when interacting with
    third-party libraries such as GRPC.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will explore setting and getting values for contexts, cancellation,
    and timeouts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter10/context` and
    navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a file called `go.mod` that contains the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter10/context`,
    or use this as an exercise to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `values.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `exec.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with context values, it's good to create a new type to represent
    the key. In this case, we created a `key` type, then declared some corresponding
    `const` values to represent all of our possible keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we initialize all our key/value pairs at the same time using
    the `Setup()` function. When modifying contexts, functions generally take a `context`
    argument and return a `context` value. So, the signature often looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, these methods also return an error or the `cancel()` function, such
    as in the cases of `context.WithCancel`, `context.WithTimeout`, and `context.WithDeadline`.
    All child contexts inherit the attributes of the parent.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we created two child contexts, one with a deadline and one with
    a timeout. We set these to timeout to be random ranges, then terminated when either
    is received. Lastly, we extracted a value given a set key and printed it.
  prefs: []
  type: TYPE_NORMAL
- en: Executing state management for channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Channels can be any type in Go. A channel of structs allows you to pass a lot
    of state with a single message. This recipe will explore the use of channels to
    pass around complex request structures and return their results in complex response
    structs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, *Using the worker pool design pattern*, the value of this
    becomes even more apparent as you can create general purpose workers capable of
    performing a variety of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter10/state` and
    navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a file called `go.mod` that contains the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter10/state`,
    or use this as an opportunity to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `state.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `processor.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `process.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Processor()` function in this recipe is a function that loops forever until
    its context is canceled, either through explicit calls to cancel or via timeout.
    It dispatches all work to `Process()`, which can handle different functions when
    given various operations. It would also be possible to have each of these cases
    dispatch another function for even more modular code.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the response is returned to a response channel, and we loop over
    and print all the results at the very end. We also demonstrate an error case in
    the `divide by 0` example.
  prefs: []
  type: TYPE_NORMAL
- en: Using the worker pool design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The worker pool design pattern is one where you dispatch long-running Goroutines
    as workers. These workers can process a variety of work either using multiple
    channels, or by using a stateful request structure that specifies the type, as
    described in the preceding recipe. This recipe will create stateful workers and
    demonstrate how to coordinate and spin up multiple workers who are all handling
    requests concurrently on the same channel. These workers will be `crypto` workers,
    as in a web authentication application. Their purpose will be to hash plaintext
    strings using the `bcrypt` package and compare a text password against a hash.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter10/pool` and
    navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a file called `go.mod` that contains the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter10/pool`,
    or use this as an opportunity to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `worker.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `work.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `crypto.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe uses the `Dispatch()` method to create a number of workers on a
    single input channel, output channel, and those attached to a single `cancel()`
    function. This can be used if you want to make different pools for different purposes.
    For example, you can create 10 `crypto` and 20 `compare` workers by using separate
    pools. For this recipe, we use a single pool, send hash requests to the workers,
    retrieve the responses, and then send `compare` requests to the same pool. Because
    of this, the worker performing the work will be different each time, but they're
    all capable of performing either type of work.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this approach is that both requests allow for parallelism and
    can also control the maximum concurrency. Bounding the maximum number of Goroutines
    can also be important for limiting memory. I chose `crypto` for this recipe because
    `crypto` is a good example of code that can overwhelm your CPU or memory if you
    spin up a new Goroutine for every new request; for example, in a web service.
  prefs: []
  type: TYPE_NORMAL
- en: Using workers to create pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe demonstrates creating groups of worker pools and connecting them
    together to form a pipeline. For this recipe, we link together two pools, but
    the pattern can be used for much more complex operations, similar to middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Worker pools can be useful for keeping workers relatively simple and to also
    further control concurrency. For example, it may be useful to serialize logging
    while parallelizing other operations. It may also be useful to have a smaller
    pool for more expensive operations so that you don't overload machine resources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps cover writing and running your application:'
  prefs: []
  type: TYPE_NORMAL
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter10/pipeline` and
    navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a file called `go.mod` that contains the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter10/pipeline`,
    or use this as an opportunity to write some of your own code!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file called `worker.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `print.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `encode.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `pipeline.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Create a new directory named `example` and navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `main.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Run `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may also run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `main` package creates a pipeline consisting of 10 encoders and 2 printers.
    It enqueues 20 strings on the in channel and waits for 20 responses on the out
    channel. If messages reach the out channel, it indicates that they've gone through
    the entire pipeline successfully.
  prefs: []
  type: TYPE_NORMAL
- en: The `NewPipeline` function is used to wire up the pools. It ensures that the
    channels are created with the properly buffered sizes and that the output channels
    of some pools are connected to the appropriate input channels of other pools.
    It's also possible to fan out the pipeline by using an array of in channels and
    an array of out channels on each worker, multiple named channels, or maps of channels.
    This would allow for things such as sending messages to a logger at each step.
  prefs: []
  type: TYPE_NORMAL

- en: Processes and Signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we talked about many interesting topics including working
    with Unix system files, dealing with dates and times in Go, finding information
    about file permissions and users as well as regular expressions and pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: The central subject of this chapter is developing Go applications that can handle
    the Unix signals that can be caught and handled. Go offers the `os/signal` package
    for dealing with signals, which uses Go channels. Although channels are fully
    explored in the next chapter, this will not stop you from learning how to work
    with Unix signals in Go programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, you will learn how to create Go command-line utilities that can
    work with Unix pipes, how to draw bar charts in Go, and how to implement a Go
    version of the `cat(1)` utility. So, in this chapter you will learn about the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Listing the processes of a Unix machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signal handling in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The signals that a Unix machine supports as well as how to use the `kill(1)`
    command to send these signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making signals do the work you want
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a simple version of the `cat(1)` utility in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plotting data in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using pipes in order to send the output of one program to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a big program into two smaller ones that will cooperate with the
    help of Unix pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a client for a Unix socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About Unix processes and signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strictly speaking, a **process** is an execution environment that contains instructions,
    user-data and system-data parts, and other kinds of resources that are obtained
    during runtime, whereas a **program** is a file that contains instructions and
    data, which are used for initializing the instruction and user-data parts of a
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Process management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go is not that good at dealing with processes and process management in general.
    Nevertheless, this section will present a small Go program that lists all the
    processes of a Unix machine by executing a Unix command and getting its output.
    The name of the program will be `listProcess.go`. It works on both Linux and macOS
    systems, and will be presented in three parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of `listProcess.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you first need to get the path of the executable file using
    `exec.LookPath()` to make sure that you are not going to accidentally execute
    another binary file and then define the command you want to execute, including
    the parameters of the command, using a slice. Next, you will have to read the
    Unix environment using `os.Environ()`. Also, you execute the desired command using
    `syscall.Exec()`, which will automatically print its output, which is not a very
    elegant way to execute commands because you have no control over the task and
    because you are calling processes at the lowest level instead of using a higher
    level library such as `os/exec`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the program is for printing the error message of the previous
    code, in case there is one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `listProcess.go` will generate the following output: the `head(1)`
    utility is used to get a smaller output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: About Unix signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever pressed *Ctrl* + *C* in order to stop a program from running?
    If yes, then you are already familiar with signals because *Ctrl* + *C* sends
    the `SIGINT` signal to the program.
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, Unix **signals** are software interrupts that can be accessed
    either by a name or number and offer a way of handling asynchronous events such
    as when a child process exits or a process is told to pause on a Unix system.
  prefs: []
  type: TYPE_NORMAL
- en: A program cannot handle all signals; some of them are non-catchable and non-ignorable.
    The `SIGKILL` and `SIGSTOP` signals cannot be caught, blocked, or ignored. The
    reason for this is that they provide the kernel and the root user a way of stopping
    any process. The `SIGKILL` signal, which is also known by the number 9, is usually
    called in extreme conditions where you need to act fast; so, it is the only signal
    that is usually called by number because it is quicker to do so. The most important
    thing to remember here is that not all Unix signals can be handled!
  prefs: []
  type: TYPE_NORMAL
- en: Unix signals in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go provides the `os/signal` package to programmers to help them handle incoming
    signals. However, we will start the discussion about handling by presenting the
    `kill(1)` utility.
  prefs: []
  type: TYPE_NORMAL
- en: The kill(1) command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `kill(1)` command is used for either terminating a process or sending a
    less cruel signal to it. Keep in mind that the fact that you can send a signal
    to a process does not mean that the process can or has code to handle this signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `kill(1)` sends the `SIGTERM` signal. If you want to find out all
    the supported signals of your Unix machine, you should execute the `kill -l` command.
    On a macOS Sierra machine, the output of `kill -l` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you execute the same command on a Debian Linux machine, you will get a more
    enriched output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to kill or send another signal to the process of another user without
    having the required permissions, which most likely will happen if you are not
    the *root* user, `kill(1)` will not do the job and you will get an error message
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A simple signal handler in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This subsection will present a naive Go program that handles only the `SIGTERM`
    and `SIGINT` signals. The Go code of `h1s.go` will be presented in three parts;
    the first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Apart from the preamble of the program, there is also a function named `handleSignal()`
    that will be called when the program receives any of the two supported signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `h1s.go` contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The previous code uses a **goroutine** and a Go **channel**, which are Go features
    that have not been discussed in this book. Unfortunately, you will have to wait
    until [Chapter 9](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml)*,* *Goroutines -
    Basic Features*, to learn more about both of them. Note that although `os.Interrupt`
    and `syscall.SIGTERM` belong to different Go packages, they are both signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, understanding the technique is important; it includes three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The definition of a channel, which acts as a way of passing data around, that
    is required for the technique (`sigs`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling `signal.Notify()` in order to define the list of signals you want to
    be able to catch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The definition of an anonymous function that runs in a goroutine (`go func()`)
    right after `signal.Notify()`, which is used for deciding what you are going to
    do when you get any of the desired signals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this case, the `handleSignal()` function will be called. The `for` loop inside
    the anonymous function is used to make the program to keep handling all signals
    and not stop after receiving its first signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `h1s.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an endless `for` loop that delays the ending of the program forever:
    in its place you would most likely put the actual code of your program. Executing
    `h1s.go` and sending signals to it from another Terminal will make `h1s.go` generate
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The bad thing here is that `h1s.go` will stop when it receives the `SIGHUP`
    signal because the default action for `SIGHUP` when it is not being specifically
    handled by a program is to kill the process! The next subsection will show how
    to handle three signals in a better way, and the subsection after that will teach
    you how to handle all signals that can be handled.
  prefs: []
  type: TYPE_NORMAL
- en: Handling three different signals!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This subsection will teach you how to create a Go application that can handle
    three different signals: the name of the program will be `h2s.go`, and it will
    handle the `SIGTERM`, `SIGINT`, and `SIGHUP` signals.'
  prefs: []
  type: TYPE_NORMAL
- en: The Go code of `h2s.go` will be presented in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the program contains the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, the last statement tells you that the program will only handle the `os.Interrupt`,
    `syscall.SIGTERM`, and `syscall.SIGHUP` signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `h2s.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that it is not compulsory to call a separate function when
    a given signal is caught; it is also allowed to handle it inside the `for` loop
    as it happens with `syscall.SIGHUP`. However, I find the use of a named function
    better because it makes the Go code easier to read and modify. The good thing
    is that Go has a central place for handling all signals, which makes it easy to
    find out what is going on with your program.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, `h2s.go` specifically handles the `SIGHUP` signal, although a
    `SIGHUP` signal will still terminate the program; however, this time this is our
    decision.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that it is considered good practice to make one of the signal handlers
    to stop the program because otherwise you will have to terminate it by issuing
    a `kill -9` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `h2s.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `h2s.go` and sending four signals to it (`SIGINT`, `SIGTERM`, `SIGHUP`,
    and `SIGKILL`) from another shell will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for building `h2s.go` is that it is easier to find the process ID
    of an autonomous program: the `go run` command builds a temporary executable program
    behind the scenes, which in this case offers less flexibility. If you want to
    improve `h2s.go`, you can make it call `os.Getpid()` in order to print its process
    ID, which will save you from having to find it on your own.'
  prefs: []
  type: TYPE_NORMAL
- en: The program handles three signals before getting a `SIGKILL` that cannot be
    handled and therefore terminates it!
  prefs: []
  type: TYPE_NORMAL
- en: Catching every signal that can be handled
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This subsection will present a simple technique that allows you to catch every
    signal that can be handled: once again, you should keep in mind that you cannot
    handle all signals! The program will stop once it gets a `SIGTERM` signal.'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the program will be `catchAll.go` and will be presented in three
    parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, all the difference is made by the way you call `signal.Notify()`
    in your code. As you do not define any particular signals, the program will be
    able to handle any signal that can be handled. However, the `for` loop inside
    the anonymous function only takes care of three signals while ignoring the remaining
    ones! Note that I believe that this is the best way to handle signals in Go: catch
    everything while processing only the signals that interest you. However, some
    people believe that being explicit about what you handle is a better approach.
    There is no right or wrong here.'
  prefs: []
  type: TYPE_NORMAL
- en: The `catchAll.go` program will not terminate when it gets `SIGHUP` because the
    `default` case of the `switch` block handles it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is the expected call to the `time.Sleep()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `catchAll.go` will create the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Rotating log files revisited!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I told you back in [Chapter 7](a013a7ab-3736-4ea0-a8e7-ec72eb01b0c5.xhtml)*,*
    *Working with System Files*, this chapter will present you with a technique that
    will allow you to end the program and rotate log files in a more conventional
    way with the help of signals and signal handling.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the new version of `rotateLog.go` will be `rotateSignals.go` and
    will be presented in four parts. Moreover, when the utility receives `os.Interrupt`,
    it will rotate the current log file, whereas when it receives `syscall.SIGTERM`,
    it will terminate its execution. Every other signal that can be handled will create
    a log entry without any other action.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the `rotateSignals.go` is the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of `rotateSignals.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You have just defined two functions here that perform two tasks. The third
    part of `rotateSignals.go` contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, all signals will be caught. The last part of `rotateSignals.go`
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `rotateSignals.go` records information about the signals it
    has received by writing one log entry for each signal. Although presenting the
    entire code of `rotateSignals.go` is good, it would be very educational to see
    the output of the `diff(1)` utility to show the code differences between `rotateLog.go`
    and `rotateSignals.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The good thing here is that the use of signals in `rotateSignals.go` makes most
    of the global variables used in `rotateLog.go` unnecessary because you can now
    control the utility by sending signals. Additionally, the design and the structure
    of `rotateSignals.go` are simpler than `rotateLog.go` because you only have to
    understand what the anonymous function does.
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing `rotateSignals.go` and sending some signals to it, the contents
    of `/tmp/myLog.log` will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, you will have the following files inside `/tmp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Improving file copying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The original `cp(1)` utility prints useful information when it receives a `SIGINFO`
    signal, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: So, the rest of this section will implement the same functionality to the Go
    implementation of the `cp(1)` command. The Go code in this section will be based
    on the `cp.go` program because it can be very slow when used with a small buffer
    size giving us time for testing. The name of the new copy utility will be `cpSignal.go`
    and will be presented in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental difference between `cpSignal.go` and `cp.go` is that `cpSignal.go`
    should find the size of the input file and keep the number of bytes that have
    been written at a given point. Apart from those modifications there is nothing
    else that you should worry about because the core functionality of the two versions,
    which is copying a file, is exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In order to make things simpler for the developer, the program introduces two
    global variables called `FILESIZE` and `BYTESWRITTEN` and these keep the size
    of the input file and the number of bytes that have been written, respectively.
    Both variables are used by the function that handles the `SIGINFO` signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, you use the `sourceFileStat.Size()` function to get the size of the input
    file and set the value of the `FILESIZE` global variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part is where you define the signal handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, you choose to catch all signals. However, the Go code of the anonymous
    function will only call `progressInfo()` after receiving a `syscall.SIGINFO` signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to have a way of gracefully terminating the program, you might
    want to use the `SIGINT` signal because when capturing all signals, gracefully
    terminating a program is no longer possible: you will need to send a `SIGKILL`
    in order to terminate your program, which is a little cruel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `cpSignal.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `cpSignal.go` and sending two `SIGINFO` signals to it will generate
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Plotting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The utility that will be developed in this section will read multiple log files
    and will create a graphical image with as many bars as the number of log files
    read. Each bar will represent the number of times a given IP address has been
    found in a log file.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the Unix philosophy tells us that instead of developing a single utility,
    we should make two distinct utilities: one for processing the log files and creating
    a report and another for plotting the data generated by the first utility: the
    two utilities will communicate using Unix pipes. Although this section will implement
    the first approach, you will see the implementation of the second approach later
    in *TheÂ * `plotIP.go` *utility revisited* section of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea for the presented utility came from a tutorial that I wrote for a
    magazine where I developed a small Go program that did some plotting: even small
    and naive programs can inspire you to develop bigger things, so do not underestimate
    their power.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of the utility will be `plotIP.go`, and it will be presented in seven
    parts: the good thing is that `plotIP.go` will reuse some of the code of `countIP.go`
    and `findIP.go`. The only thing that `plotIP.go` does not do is writing text to
    the image, so you can only plot the bars without knowing the actual values or
    the corresponding log file of a particular bar: you can try to add text capabilities
    to the program as an exercise.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, `plotIP.go` will require at least three parameters, which are the width
    and height of the image and the name of the log file that will be used: in order
    to make `plotIP.go` smaller, `plotIP.go` will not use the `flag` package and assume
    that you will give its parameters in the correct order. If you give it more parameters,
    it will consider them as log files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `plotIP.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: These global variables related to the dimensions of the image (`x` and `y`),
    the image as a Go variable (`m`), and the width of one of its bars (`barWidth`)
    that depends on the size of the image and the number of the bars that will be
    plotted. Note that using `x` and `y` as variable names instead of something like
    `IMAGEWIDTH` and `IMAGEHEIGHT` might be a little wrong and dangerous here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, you implement a Go function named `plotBar()` that does the plotting of
    each bar, given its height, its width, and its color of the bar. This function
    is the most challenging part of `plotIP.go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This function lets you define the colors that will be present in the output:
    you can change them if you want.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, you read the desired IP address, which is saved in the `WANTED` variable
    and you read the dimensions of the generated PNG image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fifth part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you process the input log files one by one and store the values you calculate
    in the `data` slice. Error messages are printed to `os.Stderr`: the main advantage
    you get from printing error messages to `os.Stderr` is that you can easily redirect
    error messages to a file while using data written to `os.Stdout` in a different
    way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The sixth part of `plotIP.go` contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, you calculate things about the plot and create the output image file using
    `os.OpenFile()`. The PNG file generated by the `plotIP.go` utility is named after
    the given IP address to make things simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the Go code of `plotIP.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, you read the values of the `data` slice and create a bar for each one
    of them by calling the `plotBar()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `plotIP.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'However, apart from the generated text output, what is important is the produced
    PNG file that can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0705a55e-044d-4918-bfea-70d6b7d9377e.png)'
  prefs: []
  type: TYPE_IMG
- en: The output generated by the plotIP.go utility
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to save the error messages to a different file, you can use a variation
    of the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command discards all error messages by sending them to `/dev/null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Unix pipes in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We first talked about pipes in [Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml)*,*
    *File Input and Output*. Pipes have two serious limitations: first, they usually
    communicate in one direction, and second, they can only be used between processes
    that have a common ancestor.'
  prefs: []
  type: TYPE_NORMAL
- en: The general idea behind pipes is that if you do not have a file to process,
    you should wait to get your input from standard input. Similarly, if you are not
    told to save your output to a file, you should write your output to standard output,
    either for the user to see it or for another program to process it. As a result,
    pipes can be used for streaming data between two processes without creating any
    temporary files.
  prefs: []
  type: TYPE_NORMAL
- en: This section will present some simple utilities written in Go that use Unix
    pipes for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from standard input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing that you need to know in order to develop Go applications that
    support Unix pipes is how to read from standard input.
  prefs: []
  type: TYPE_NORMAL
- en: The developed program is named `readSTDIN.go` and will be presented in three
    parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the program is the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of `readSTDIN.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, you resolve whether you have an actual file to process, which can be determined
    by the number of the command-line arguments of your program. If you do not have
    a file to process, you will try to read data from `os.Stdin`. Make sure that you
    understand the presented technique because it will be used many times in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `readSTDIN.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This code is the same whether you are processing an actual file or `os.Stdin`,
    which happens because everything in Unix is a file. Note that the program output
    begins with the `>` character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `readSTDIN.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last case, `readSTDIN.go` echoes each line it reads because the input
    is read line by line: the `cat(1)` utility works the same way.'
  prefs: []
  type: TYPE_NORMAL
- en: Sending data to standard output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This subsection will show you how to send data to standard output in a better
    way than just using `fmt.Println()` or any other function from the `fmt` standard
    Go package. The Go program will be named `writeSTDOUT.go` and will be presented
    to you in three parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of `writeSTDOUT.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of `writeSTDOUT.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The only subtle thing is that you need to put your text into a slice before
    using `io.WriteString()` to write data to `os.Stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `writeSTDOUT.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Implementing cat(1) in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This subsection will present a Go version of the `cat(1)` command-line utility.
    If you give one or more command-line arguments to `cat(1)`, then `cat(1)` will
    print their contents on the screen. However, if you just type `cat(1)` on your
    Unix shell, then `cat(1)` will wait for your input, which will be terminated when
    you type *Ctrl* + *D*.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the Go implementation will be `cat.go` and will be presented in
    three parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of `cat.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `catFile()` function is called when the `cat.go` utility has to process
    real files. Having a function to do your job makes the design of the program better.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: So, if the program has no arguments, then it assumes that it has to read `os.Stdin`.
    In that case, it just echoes each line you give to it. If the program has arguments,
    then it processes the first argument as a file using the `catFile()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `cat.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The plotIP.go utility revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As promised in a previous section of this chapter, this section will create
    two separate utilities, which when combined will implement the functionality of
    `plotIP.go`. Personally, I prefer to have two separate utilities and combine them
    when needed than having just one utility that does two or more tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The names of the two utilities will be `extractData.go` and `plotData.go`. As
    you can easily understand, only the second utility would have to be able to get
    input from standard input as long as the first utility prints its output on standard
    output either using `os.Stdout`, which is the correct way, or using `fmt.Println()`,
    which usually does the job.
  prefs: []
  type: TYPE_NORMAL
- en: 'I think that I should now tell you my little secret: I created `extractData.go`
    and `plotData.go` first and then developed `plotIP.go` because it is easier to
    develop two separate utilities than a bigger one that does everything! Additionally,
    the use of two different utilities allows you to filter the output of `extractData.go`
    using standard Unix utilities such as `tail(1)`, `sort(1)`, and `head(1)`, which
    means that you can modify your data in different ways without the need for writing
    any extra Go code.'
  prefs: []
  type: TYPE_NORMAL
- en: Taking two command-line utilities and creating one utility that implements the
    functionality of both utilities is easier than taking one big utility and dividing
    its functionality into two or more distinct utilities because the latter usually
    requires more variables and more error checking.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `extractData.go` utility will be presented in four parts; the first part
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of `extractData.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: You should be familiar with the `findIP()` function, which you saw in `findIP.go`
    in [Chapter 7](a013a7ab-3736-4ea0-a8e7-ec72eb01b0c5.xhtml)*,* *Working with System
    files*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part of `extractData.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of the `buf` variable is redundant here because `filename` is a string
    and `io.WriteString()` expects a string: it is just my habit to put the value
    of `filename` into a byte slice. You can remove it if you want.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, most of the Go code is from the `plotIP.go` utility. The last part
    of `extractData.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `extractData.go` writes its output to standard output (`os.Stdout`) instead
    of using the functions of the `fmt` package in order to be more compatible with
    pipes. The `extractData.go` utility requires at least two parameters: an IP address
    and a log file, but it can process as many log files as you wish.'
  prefs: []
  type: TYPE_NORMAL
- en: You might want to move the printing of the `filename` value from the third part
    here in order to have all printing commands at the same place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `extractData.go` will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Although `extractData.go` prints two values in each line, only the second field
    will be used by `plotData.go`. The best way to do that is filter the output of
    `extractData.go` using `awk(1)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As you can understand, `awk(1)` allows you to do many more things with the generated
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `plotData.go` utility will also be presented in six parts; its first part
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the use of global variables is for avoiding the passing of too many
    arguments to some of the functions of the utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `plotData.go` contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The third part of `plotData.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The fourth part of `plotData.go` contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The fifth part of `plotData.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of `plotData.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Although you can use `plotData.go` on its own, using the output of `extractData.go`
    as the input to `plotData.go` is as easy as executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The graphical output from the previous command can be an image like the one
    you can see in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee09e9bd-e219-47d1-98f4-47de7bc75848.png)'
  prefs: []
  type: TYPE_IMG
- en: The output generated by the plotData.go utility
  prefs: []
  type: TYPE_NORMAL
- en: Unix sockets in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There exist two kinds of sockets: Unix sockets and network sockets. Network
    sockets will be explained in [Chapter 12](fe18fc6b-5b18-4a49-ad25-78909d80232f.xhtml)*,*
    *Network Programming*, whereas Unix sockets will be briefly explained in this
    section. However, as the presented Go functions also work with TCP/IP sockets,
    you will still have to wait till [Chapter 12](fe18fc6b-5b18-4a49-ad25-78909d80232f.xhtml),
    *Network Programming*, in order to fully understand them as they will not be explained
    here. So, this section will just present the Go code of a Unix socket client,
    which is a program that uses a Unix socket, which is a special Unix file, to read
    and write data. The name of the program will be `readUNIX.go` and will be presented
    in three parts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part of `readUNIX.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The use of `readUNIX.go` requires the presence of another process that also
    reads and writes to the same socket file (`/tmp/aSocket.sock`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated output depends on the implementation of the other part: in this
    case, that output was the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'If the socket file cannot be found or if no program is watching it, you will
    get the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: RPC in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RPC stands for **Remote Procedure Call** and is a way of executing function
    calls to a remote server and getting the answer back in your clients. Once again,
    you will have to wait until [Chapter 12](fe18fc6b-5b18-4a49-ad25-78909d80232f.xhtml)*,*
    *Network Programming*, in order to learn how to develop an RPC server and an RPC
    client in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Programming a Unix shell in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will briefly and naively present Go code that can be used as the
    foundation for the development of a Unix shell. Apart from the `exit` command,
    the only other command that the program can recognize is the `version` command
    that just prints the version of the program. All other user input will be echoed
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go code of `UNIXshell.go` will be presented in three parts. However, before
    that I will present to you the first version of the shell, which mainly contains
    comments in order to better understand how I usually start the implementation
    of a relatively challenging program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This is more or less the algorithm that I would use as a starting point: the
    good thing is that the comments briefly show how the program will operate. Keep
    in mind that the algorithm does not depend on the programming language. After
    that, it is easier to start implementing things because you know what you want
    to do.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the first part of the final version of the shell is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Here, you just read the input from the user line by line and find out the first
    word of the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `UNIXshell.go` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The aforementioned Go code checks the command that the user gave and acts accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `UNIXshell.go` and interacting with it will generate the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Should you wish to learn more about creating your own Unix shell in Go, you
    can visit [https://github.com/elves/elvish](https://github.com/elves/elvish).
  prefs: []
  type: TYPE_NORMAL
- en: Yet another minor Go update
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While I was writing this chapter, Go was updated: this is a minor update, which
    mainly fixes bugs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Put the plotting functionality of `plotIP.go` into a Go package and use that
    package to rewrite both `plotIP.go` and `plotData.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the Go code of `ddGo.go` from [Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml)*,*
    *File Input and Output*, in order to print information about its progress when
    receiving a `SIGINFO` signal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Go code of `cat.go` to add support for multiple input files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the code of `plotData.go` in order to print gridlines to the generated
    image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the code of `plotData.go` in order to leave a little space between the
    bars of the plot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to make the `UNIXshell.go` program a little better by adding new features
    to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about many interesting and handy topics, including
    signal handling and creating graphical images in Go. Additionally, we taught you
    how to add support for Unix pipes in your Go programs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about the most unique feature of Go, which
    is goroutines. You will learn what a goroutine is, how to create and synchronize
    them as well as how to create channels and pipelines. Have in mind that many people
    come to Go in order to learn a modern and safe programming language, but stay
    for its goroutines!
  prefs: []
  type: TYPE_NORMAL

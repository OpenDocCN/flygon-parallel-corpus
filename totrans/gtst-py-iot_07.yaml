- en: Using Python to Drive Hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling an LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding to a button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The controlled shutdown button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GPIO keypad input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplexed color LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing messages using persistence of vision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key features of a Raspberry Pi computer that sets it apart from most
    other home/office computers is that it has the ability to directly interface with
    other hardware. The **general-purpose input/output** (**GPIO**) pins on the Raspberry
    Pi can control a wide range of low-level electronics, from **light-emitting diodes**
    (**LEDs**) to switches, sensors, motors, servos, and even extra displays.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus on connecting the Raspberry Pi with some simple circuits
    and getting to grips with using Python to control and respond to the connected
    components.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi hardware interface consists of 40 pins located along one side
    of the board.
  prefs: []
  type: TYPE_NORMAL
- en: The GPIO pins and their layout will vary slightly according to the particular
    model you have.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi 3, Raspberry Pi 2, and Raspberry Pi B+ all have the same 40-pin
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: The older Raspberry Pi 1 models (nonplus types) have a 26-pin header, which
    is the same as the 1-26 pins of the newer models.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/86db1046-6cb8-41d1-a4f1-dd1254bc656b.png)Raspberry Pi 2, Raspberry
    Pi B+, and Raspberry Pi Model Plus GPIO header pins (pin functions)'
  prefs: []
  type: TYPE_IMG
- en: The layout of the connector is shown in the preceding diagram; the pin numbers
    are shown as seen from pin 1 of the GPIO header.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pin 1** is at the end that is nearest to the SD card, as shown in the following
    photo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/54a256bf-7a6a-411b-b7eb-c5f6110d50f1.png)The Raspberry Pi GPIO header
    location'
  prefs: []
  type: TYPE_NORMAL
- en: Care should be taken when using the GPIO header, since it also includes power
    pins (3V3 and 5 V), as well as **ground** (**GND**) pins. All of the GPIO pins
    can be used as standard GPIO, but several also have special functions; these are
    labeled and highlighted with different colors.
  prefs: []
  type: TYPE_NORMAL
- en: It is common for engineers to use a 3V3 notation to specify values in schematics
    in order to avoid using decimal places that could easily be missed (using 33V
    rather than 3.3V would cause severe damage to the circuitry). The same can be
    applied to the values of other components, such as resistors, for example, 1.2K
    ohms can be written as 1K2 ohms.
  prefs: []
  type: TYPE_NORMAL
- en: The **TX** and **RX** pins are used for serial communications, and with the
    aid of a voltage-level converter, information can be transferred via a serial
    cable to another computer or device.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have the **SDA** and **SCL** pins, which are able to support a two-wire
    bus communication protocol called **I**²**C** (there are two I²C channels on Raspberry
    Pi 3 and Model Plus boards: **channel 1 ARM**, which is for general use, and **channel
    0 VC**, which is typically used for identifying **hardware attached on top** (**HAT**)
    modules). There are also the **SPI MOSI**, **SPI MISO**, **SPI SCLK**, **SPI CE0**,
    and **SPI CE1** pins, which support another type of bus protocol called **SPI**
    for high-speed data. Finally, we have the **PWM0/1** pin, which allows a **pulse-width
    modulation** signal to be generated, which is useful for servos and generating
    analog signals.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we will focus on using just the standard GPIO functions in this chapter.
    The GPIO pin layout is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/eff316c1-171e-4607-b246-83e8f241b01e.png)Raspberry Pi GPIO header
    pins (GPIO.BOARD and GPIO.BCM)'
  prefs: []
  type: TYPE_IMG
- en: 'The Raspberry Pi Rev 2 (pre-July 2014) has the following differences compared
    to the Raspberry Pi 2 GPIO layout:'
  prefs: []
  type: TYPE_NORMAL
- en: 26-GPIO-pin header (matching the first 26 pins).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An additional secondary set of eight holes (P5) located next to the pin header.
    The details are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](Images/089cf669-1f47-4da7-888a-fa1442f03fd1.png)Raspberry Pi Rev 2 P5 GPIO
    header pins'
  prefs: []
  type: TYPE_NORMAL
- en: 'The original Raspberry Pi Rev 1 (pre-October 2012) has only 26 GPIO pins in
    total, (matching the first 26 pins of the current Raspberry Pi, except for the
    following details:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](Images/ec7fdb0c-b61f-4108-b924-a6162d59bf0e.png)Raspberry Pi Rev 1 GPIO
    header differences'
  prefs: []
  type: TYPE_NORMAL
- en: The `RPi.GPIO` library can reference the pins on the Raspberry Pi using one
    of two systems. The numbers shown in the center refer to the physical position
    of the pins, and are also the numbers referenced by the `RPi.GPIO` library when
    in **GPIO.BOARD** mode. The numbers on the outside (**GPIO.BCM**) are the actual
    reference numbers of the physical ports of the processor that indicate which of
    the pins are wired (which is why they are not in any specific order). They are
    used when the mode is set to **GPIO.BCM**, and they allow control of the GPIO
    header pins as well as any peripherals connected to other GPIO lines. This includes
    the LED on the add-on camera on BCM GPIO 4 and the status LED on the board. However,
    this can also include the GPIO lines used for reading/writing to the SD card,
    which would cause serious errors if interfered with.
  prefs: []
  type: TYPE_NORMAL
- en: If you use other programming languages to access the GPIO pins, the numbering
    scheme may be different, so it will be helpful if you are aware of the BCM GPIO
    references, which refer to the physical GPIO ports of the processor.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to check out the Appendix, *Hardware and Software List*, which lists
    all the items used in this chapter and the places that you can obtain them from.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling an LED
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The hardware equivalent of `hello world` is an LED flash, which is a great test
    to ensure that everything is working and that you have wired it correctly. To
    make it a little more interesting, I've suggested using a **red, blue, and green**
    (**RGB**) LED, but feel free to use separate LEDs if that is all you have available.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following equipment:'
  prefs: []
  type: TYPE_NORMAL
- en: 4 x DuPont female-to-male patch wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mini breadboard (170 tie points) or a larger one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RGB LED (common cathode)/3 standard LEDs (ideally red, green, and blue)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breadboard wire (solid core)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3 x 470 ohm resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of the preceding components shouldn''t cost many dollars and can be reused
    for other projects afterwards. The breadboard is a particularly useful item that
    allows you to try out your own circuits without needing to solder them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f9a79a3b-7ca0-4c4e-b4e6-a4d6ff9c69fb.png)Diagrams of an RGB LED,
    a standard LED, and an RGB circuit'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the breadboard circuitry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/88293cf3-b0ab-45fc-999f-af4c445e2e1d.png)The wiring of an RGB LED/standard
    LEDs connected to the GPIO headerThere are several different kinds of RGB LEDs
    available, so check the datasheet of your component to confirm the pin order and
    type you have. Some are RGB, so ensure that you wire accordingly or adjust the
    `RGB_` pin settings in the code. You can also get common anode variants, which
    will require the anode to be connected to 3V3 (GPIO-pin 1) for it to light up
    (and they will also require `RGB_ENABLE` and `RGB_DISABLE` to be set to `0` and
    `1` `respectively`).'
  prefs: []
  type: TYPE_NORMAL
- en: The breadboard and component diagrams of this book have been created using a
    free tool called **Fritzing** ([www.fritzing.org](http://www.fritzing.org)); it
    is great for planning your own Raspberry Pi projects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the `ledtest.py` script as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RPi.GPIO` library will require `sudo` permissions to access the GPIO pin
    hardware, so you will need to run the script using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When you run the script, you should see the red, green, and blue parts of the
    LED (or each LED, if you're using separate ones) light up in turn. If not, double-check
    your wiring or confirm that the LED is working by temporarily connecting the red,
    green, or blue wire to the 3V3 pin (pin 1 of the GPIO header).
  prefs: []
  type: TYPE_NORMAL
- en: The `sudo` command is required for most hardware-related scripts because it
    isn't normal for users to directly control hardware at such a low level. For example,
    setting or clearing a control pin that is part of the SD card controller could
    corrupt data being written to it. Therefore, for security purposes, superuser
    permissions are required to stop programs from using hardware by accident (or
    with malicious intent).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To access the GPIO pins using Python, we import the `RPi.GPIO` library, which
    allows direct control of the pins through the module functions. We also require
    the `time` module to pause the program for a set number of seconds.
  prefs: []
  type: TYPE_NORMAL
- en: We then define values for the LED wiring and active states (see *Controlling
    the GPIO current* segment in the *There's more...* section of this recipe).
  prefs: []
  type: TYPE_NORMAL
- en: Before the GPIO pins are used by the program, we need to set them up by specifying
    the numbering method—`GPIO.BOARD`—and the direction—`GPIO.OUT` or `GPIO.IN` (in
    this case, we set all the RGB pins to outputs). If a pin is configured as an output,
    we will be able to set the pin state; similarly, if it is configured as an input,
    we will be able to read the pin state.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we control the pins using `GPIO.ouput()` by stating the number of the
    GPIO pin and the state we want it to be in (`1` = high/on and `0` = low/off).
    We switch each LED on, wait five seconds, and then switch it back off.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use `GPIO.cleanup()` to return the GPIO pins back to their original
    default state and release control of the pins for use by other programs.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the GPIO pins on the Raspberry Pi must be done with care since these pins
    are directly connected to the main processor of the Raspberry Pi without any additional
    protection. Caution must be used as any incorrect wiring will probably damage
    the Raspberry Pi processor and cause it to stop functioning altogether.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you could use one of the many modules available that plug directly
    into the GPIO header pins (reducing the chance of wiring mistakes):'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the Pi-Stop is a simple pre-built LED board that simulates a set
    of traffic lights, designed to be a stepping stone for those who are interested
    in controlling hardware but want to avoid the risk of damaging their Raspberry
    Pi. After the basics have been mastered, it also makes an excellent indicator
    to aid debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Just ensure that you update the `LED CONFIG` pin references in the `ledtest.py`
    script to reference the pin layout and location used for the hardware you are
    using.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ad34ee37-0365-4a28-a71c-578b0daa28e3.png)'
  prefs: []
  type: TYPE_IMG
- en: See the Appendix, *Hardware and Software List*, for a list of Raspberry Pi hardware
    retailers.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the GPIO current
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each GPIO pin is only able to handle a certain current before it burns out (a
    maximum of 16 mA from a single pin or 30 mA in total), and similarly, the RGB
    LED should be limited to no more than 100 mA. By adding a resistor before or after
    an LED, we will be able to limit the current that will be passed through it and
    control how bright it is (more current will equal a brighter LED).
  prefs: []
  type: TYPE_NORMAL
- en: Since we may wish to power more than one LED at a time, we typically aim to
    set the current as low as we can get away with while still providing enough power
    to light up the LED.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use Ohm''s law to tell us how much resistance to use to provide a particular
    current. The law is as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f3fc16b6-3b93-46ac-9491-565b179ecd6a.png)Ohm''s law: The relationship
    between the current, resistance, and voltage in electrical circuits'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will aim for a minimum current (3 mA) and maximum current (16 mA), while
    still producing a reasonably bright light from each of the LEDs. To get a balanced
    output for the RGB LEDs, I tested different resistors until they provided a near
    white light (when viewed through a card). A 470 ohm resistor was selected for
    each one (your LEDs may differ slightly):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/64bf4bbc-c955-45b6-9567-4372306aa5d1.png)Resistors are needed to
    limit the current that passes through the LEDs'
  prefs: []
  type: TYPE_NORMAL
- en: 'The voltage across the resistor is equal to the GPIO voltage (**Vgpio** = 3.3V)
    minus the voltage drop on the particular LED (**Vfwd**); we can then use this
    resistance to calculate the current used by each of the LEDs, as shown in the
    following formulas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6a89db2a-ff7b-4579-b310-230c7c9c9ca4.png)We can calculate the current
    drawn by each of the LEDs'
  prefs: []
  type: TYPE_NORMAL
- en: Responding to a button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many applications using the Raspberry Pi require that actions are activated
    without requiring a keyboard and screen to be attached to it. The GPIO pins provide
    an excellent way for the Raspberry Pi to be controlled by your own buttons and
    switches without a mouse/keyboard and screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following equipment:'
  prefs: []
  type: TYPE_NORMAL
- en: 2 x DuPont female-to-male patch wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mini breadboard (170 tie points) or a larger one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Push-button switch (momentary close) or a wire connection to make/break the
    circuit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breadboard wire (solid core)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1K ohm resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The switches are as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/325f711c-c617-4bcb-b66a-1b17ab3f2080.png)The push-button switch
    and other types of switchThe switches used in the following examples are **single-pole,
    single-throw** (**SPST**), momentary close, push-button switches. **Single pole**
    (**SP**) means that there is one set of contacts that makes a connection. In the
    case of the push switch used here, the legs on each side are connected together
    with a single-pole switch in the middle. A **double-pole** (**DP**) switch acts
    just like a SP switch, except that the two sides are separated electrically, allowing
    you to switch two separate components on/off at the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single throw** (**ST**) means the switch will make a connection with just
    one position; the other side will be left open. **Double throw** (**DT**) means
    both positions of the switch will connect to different parts.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Momentary close** means that the button will close the switch when pressed
    and automatically open it when released. A **latched** push-button switch will
    remain closed until it is pressed again.'
  prefs: []
  type: TYPE_NORMAL
- en: Trying a speaker or headphone with Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](Images/c54871b1-71d9-4932-9f4b-d212a53578d3.png)The layout of the button
    circuit'
  prefs: []
  type: TYPE_NORMAL
- en: We will use sound in this example, so you will also need speakers or headphones
    attached to the audio socket of the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to install a program called `flite` using the following command,
    which will let us make the Raspberry Pi talk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After it has been installed, you can test it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is a little too quiet (or too loud), you can adjust the volume (0-100
    percent) using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the `btntest.py` script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As in the previous recipe, we set up the GPIO pin as required, but this time
    as an input, and we also enable the internal pull-up resistor (see *Pull-up and
    pull-down resistor circuits* in the *There''s more...* section of this recipe
    for more information) using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After the GPIO pin is set up, we create a loop that will continuously check
    the state of `BTN` using `GPIO.input()`. If the value returned is `false`, the
    pin has been connected to 0V (ground) through the switch, and we will use `flite`
    to count out loud for us each time the button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have called the main function from within a `try`/`finally` condition,
    it will still call `GPIO.cleanup()` even if we close the program using *Ctrl*
    + *Z*.
  prefs: []
  type: TYPE_NORMAL
- en: We use a short delay in the loop; this ensures that any noise from the contacts
    on the switch is ignored. This is because when we press the button, there isn't
    always perfect contact as we press or release it, and it may produce several triggers
    if we press it again too quickly. This is known as **software debouncing**; we
    ignore the bounce in the signal here.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Raspberry Pi GPIO pins must be used with care; voltages used for inputs
    should be
  prefs: []
  type: TYPE_NORMAL
- en: within specific ranges, and any current drawn from them should be minimized
    using
  prefs: []
  type: TYPE_NORMAL
- en: protective resistors.
  prefs: []
  type: TYPE_NORMAL
- en: Safe voltages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We must ensure that we only connect inputs that are between 0 (ground) and 3V3\.
    Some processors use voltages between 0V and 5V, so extra components are required
    to interface safely with them. Never connect an input or component that uses 5V
    unless you are certain it is safe, or you will damage the GPIO ports of the Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Pull-up and pull-down resistor circuits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous code sets the GPIO pins to use an internal pull-up resistor. Without
    a pull-up resistor (or pull-down resistor) on the GPIO pin, the voltage is free
    to float somewhere between 3V3 and 0V, and the actual logical state remains undetermined
    (sometimes 1 and sometimes 0).
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi's internal pull-up resistors are 50K ohm-65K ohm, and the pull-down
    resistors are 50K ohm-65K ohm. External pull-up/pull-down resistors are often
    used in GPIO circuits (as shown in the following diagram), typically using 10K
    ohm or larger for similar reasons (giving a very small current draw when they
    are not active).
  prefs: []
  type: TYPE_NORMAL
- en: 'A pull-up resistor allows a small amount of current to flow through the GPIO
    pin and will provide a high voltage when the switch isn''t pressed. When the switch
    is pressed, the small current is replaced by the larger one flowing to 0V, so
    we get a low voltage on the GPIO pin instead. The switch is active low and logic
    0 when pressed. It works as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/29c4c4eb-9bc8-4f96-bd07-7c8206af9a32.png)A pull-up resistor circuit'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pull-down resistors work in the same way, except the switch is active high
    (the GPIO pin is logic 1 when pressed). It works as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b8708774-f896-4447-acc1-a829863676d1.png)A pull-down resistor circuit'
  prefs: []
  type: TYPE_NORMAL
- en: Protection resistors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the switch, the circuit includes a resistor in series with the
    switch to protect the GPIO pin, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f47a0106-2712-472d-a88b-7efea679d893.png)A GPIO protective current-limiting
    resistor'
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the protection resistor is to protect the GPIO pin if it is accidentally
    set as an output rather than an input. Imagine, for instance, that we have our
    switch connected between the GPIO and ground. Now the GPIO pin is set as an output
    and switched on (driving it to 3V3) as soon as we press the switch, without a
    resistor present, the GPIO pin will be directly connected to 0V. The GPIO will
    still try to drive it to 3V3; this will cause the GPIO pin to burn out (since
    it will use too much current to drive the pin to the high state). If we use a
    1K ohm resistor here, the pin is able to be driven high using an acceptable amount
    of current (I = V/R = 3.3/1K = 3.3 mA).
  prefs: []
  type: TYPE_NORMAL
- en: A controlled shutdown button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Raspberry Pi should always be shut down correctly to avoid the SD card being
    corrupted (by losing power while performing a write operation to the card). This
    can pose a problem if you don't have a keyboard or screen connected (you might
    be running an automated program or controlling it remotely over a network and
    forget to turn it off) as you can't type the command or see what you are doing.
    By adding our own buttons and LED indicator, we can easily command a shutdown
    and reset, and then start up again to indicate when the system is active.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following equipment:'
  prefs: []
  type: TYPE_NORMAL
- en: 3 x DuPont female-to-male patch wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mini breadboard (170 tie points) or a larger one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Push-button switch (momentary close)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General-purpose LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 x 470 ohm resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breadboard wire (solid core)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The entire layout of the shutdown circuit will look as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/32384f24-fc03-40a6-953b-a4e9a263e4ab.png)The controlled shutdown
    circuit layout'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the `shtdwn.py` script as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To get this script to run automatically (once we have tested it), we can place
    the script in the `~/bin` (we can use `cp` instead of `mv` if we just want to
    copy it) and add it to `crontab` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the file, we add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This time, when we set up the GPIO pin, we define the pin connected to the shutdown
    button as an input and the pin connected to the LED as an output. We turn the
    LED on to indicate that the system is running.
  prefs: []
  type: TYPE_NORMAL
- en: By setting the `DEBUG` flag to `True`, we can test the functionality of our
    script without causing an actual shutdown (by reading the terminal messages);
    we just need to ensure that we set `DEBUG` to `False` when using the script for
    real.
  prefs: []
  type: TYPE_NORMAL
- en: We enter a `while` loop and check the pin every second to see whether the GPIO
    pin is set to `LOW` (that is, to check whether the switch has been pressed); if
    so, we enter the `doShutdown()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The program will wait for three seconds and then test again to see whether the
    button is still being pressed. If the button is no longer being pressed, we return
    to the previous `while` loop. However, if it is still being pressed after three
    seconds, the program will flash the LED and trigger the shutdown (and also provide
    an audio warning using `flite`).
  prefs: []
  type: TYPE_NORMAL
- en: When we are happy with how the script is operating, we can disable the `DEBUG`
    flag (by setting it to `False`) and add the script to `crontab`. `crontab` is
    a special program that runs in the background and allows us to schedule (at specific
    times, dates, or periodically) programs and actions when the system is started
    (`@reboot`). This allows the script to be started automatically every time the
    Raspberry Pi is powered up. When we press and hold the shutdown button for more
    than three seconds, it safely shuts down the system and enters a low power state
    (the LED switches off just before this, indicating that it is safe to remove the
    power shortly after). To restart the Raspberry Pi, we briefly remove the power;
    this will restart the system, and the LED will light up when the Raspberry Pi
    has loaded.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can extend this example further using the reset header by adding extra functionality
    and making use of additional GPIO connections (if available).
  prefs: []
  type: TYPE_NORMAL
- en: Resetting and rebooting Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Raspberry Pi has holes for mounting a reset header (marked **RUN** on the
    Raspberry Pi 3/2 and **P6** on the Raspberry Pi 1 Model A and Model B Rev 2).
    The reset pin allows the device to be reset using a button rather than removing
    the micro USB connector each time to cycle the power:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/842a26a3-f0cc-4e68-993c-b5b9fda3ab38.png)Raspberry Pi reset headers
    - on the left, Raspberry Pi Model A/B (Rev2), and on the right, Raspberry Pi 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of it, you will need to solder a wire or pin header to the Raspberry
    Pi and connect a button to it (or briefly touch a wire between the two holes each
    time). Alternatively, we can extend our previous circuit, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7f05b9ba-5dc4-4c35-a484-fbb8c67ff403.png)The controlled shutdown
    circuit layout and reset button'
  prefs: []
  type: TYPE_NORMAL
- en: We can add this extra button to our circuit, which can be connected to the reset
    header (this is the hole nearest the middle on the Raspberry Pi 3 or closest to
    the edge on other models). This pin, when temporarily pulled low by connecting
    to ground (such as the hole next to it or by another ground point, such as pin
    6 of the GPIO header), will reset the Raspberry Pi and allow it to boot up again
    following a shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: Adding extra functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we now have the script monitoring the shutdown button all the time, we
    can add extra buttons/switches/jumpers to be monitored at the same time. This
    will allow us to trigger specific programs or set up particular states just by
    changing the inputs. The following example allows us to easily switch between
    automatic DHCP networking (the default networking setup) and using a direct IP
    address, as used in the *Networking directly to a laptop or computer* recipe of
    Chapter 1, *Getting Started with a Raspberry Pi 3 Computer*, for direct LAN connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following components to the previous circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: A 470 ohm resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two pin headers with a jumper connector (or, optionally, a switch)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breadboard wire (solid core)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After adding the preceding components, our controlled shutdown circuit now
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/16390e01-579c-4baa-9947-a171dfde83ac.png)The controlled shutdown
    circuit layout, reset button, and jumper pins'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous script, we add an additional input to detect the status of
    the `LAN_SWA` pin (the jumper pins we added to the circuit) using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that it is set up as an input (with a pull-up resistor) in the `gpio_setup()`
    function using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new function to switch between the LAN modes and read out the new IP
    address. The `doChangeLAN()` function checks whether the status of the `LAN_SWA`
    pin has changed since the last call, and if so, it sets the network adapter to
    DHCP or sets the direct LAN settings accordingly (and uses `flite` to speak the
    new IP setting, if available). Finally, the LAN being set for direct connection
    causes the LED to flash slowly while that mode is active. Use the following code
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Add another function, `flashled()`, which will just toggle the state of the
    LED each time it is called. The code for this function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we adjust the main loop to also call `doChangeLAN()` and use the result
    to decide whether we call `flashled()` using `ledon` to keep track of the LED''s
    previous state each time. The `main()` function should now be updated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The GPIO keypad input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how we can monitor inputs on the GPIO to launch applications and
    control the Raspberry Pi; however, sometimes we need to control third-party programs.
    Using the `uInput` library, we can emulate key presses from a keyboard (or even
    mouse movement) to control any program using our own custom hardware.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about using `uInput`, visit [http://tjjr.fi/sw/python-uinput/](http://tjjr.fi/sw/python-uinput/).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to install `uInput`:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to download `uInput`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will need to download the `uInput` Python library from GitHub (~50 KB)
    using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The library will unzip to a directory called `python-uinput-master`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once completed, you can remove the ZIP file using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the required packages using the following commands (if you have installed
    them already, the `apt-get` command will ignore them):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and install `uInput` using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we load the new `uinput` kernel module using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure it is loaded upon startup, we can add `uinput` to the `modules` file
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Put `uinput` on a new line in the file and save it (*Ctrl* + *X*, *Y*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following circuit using the following equipment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Breadboard (half-sized or larger)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7 x DuPont female-to-male patch wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Six push buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6 x 470 ohm resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breadboarding wire (solid core)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](Images/a4eac434-a135-49ff-bdb7-e4b98accf7ae.png)GPIO keypad circuit layout'
  prefs: []
  type: TYPE_NORMAL
- en: 'The keypad circuit can also be built into a permanent circuit by soldering
    the components into a Vero prototype board (also known as a stripboard), as shown
    in the following photo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/121e0320-e6c0-4ade-b143-64e253df5e16.png)GPIO keypad Pi hardware
    moduleThis circuit is available as a solder-yourself kit from [PiHardware.com](http://pihardware.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the circuit to the Raspberry Pi GPIO pins by matching the appropriate
    buttons with the appropriate pins, as shown in the following table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '|  | **Button** | **GPIO pin** |'
  prefs: []
  type: TYPE_TB
- en: '| GND |  | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| v | B_DOWN | 22 |'
  prefs: []
  type: TYPE_TB
- en: '| < | B_LEFT | 18 |'
  prefs: []
  type: TYPE_TB
- en: '| ^ | B_UP | 15 |'
  prefs: []
  type: TYPE_TB
- en: '| > | B_RIGHT | 13 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | B_1 | 11 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | B_2 | 7 |'
  prefs: []
  type: TYPE_TB
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a `gpiokeys.py` script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we import `uinput` and define the wiring of the keypad buttons. For each
    of the buttons in `BTN`, we enable them as inputs, with internal pull-ups enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set up `uinput`, defining the keys we want to emulate and adding them
    to the `uinput.Device()` function. We wait a few seconds to allow `uinput` to
    initialize, set the initial button and key states, and start our `main` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` loop is split into two sections: the first section checks through
    the buttons and records the states in `btn_state`, and the second section compares
    the `btn_state` with the current `key_state` array. This way, we can detect a
    change in `btn_state` and call `device.emit()` to toggle the state of the key.'
  prefs: []
  type: TYPE_NORMAL
- en: To allow us to run this script in the background, we can run it with `&`, as
    shown in the
  prefs: []
  type: TYPE_NORMAL
- en: 'following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `&` character allows the command to run in the background, so we can continue
    with the command line to run other programs. You can use `fg` to bring it back
    to the foreground, or `%1`, `%2`, and so on if you have several commands running.
    Use `jobs` to get a list.
  prefs: []
  type: TYPE_NORMAL
- en: You can even put a process/program on hold to get to Command Prompt by pressing
    *Ctrl* + *Z* and then resume it with `bg` (which will let it run in the background).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can do more using `uinput` to provide hardware control for other programs,
    including those that require mouse input.
  prefs: []
  type: TYPE_NORMAL
- en: Generating other key combinations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can create several different key mappings in your file to support different
    programs. For instance, the `events_z80` key mapping would be useful for a spectrum
    emulator, such as **Fuse** (browse to [http://raspi.tv/2012/how-to-install-fuse-zx-spectrum-emulator-on-raspberry-pi](http://raspi.tv/2012/how-to-install-fuse-zx-spectrum-emulator-on-raspberry-pi)
    for more details). The `events_omx` key mappings are suitable for controlling
    video played through the OMXPlayer using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can get a list of keys supported by `omxplayer` by using the `-k` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the line that defines the `events` list with a new key mapping, and
    select different ones by assigning them to events using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find all the `KEY` definitions in the `input.h` file; you can view
    it using the `less` command (press *Q* to exit), as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Emulating mouse events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `uinput` library can emulate mouse and joystick events, as well as keyboard
    presses. To use the buttons to simulate a mouse, we can adjust the script to use
    mouse events (as well as defining `mousemove` to set the step size of the movement)
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to modify the button handling to provide continuous movement,
    as we don''t need to keep track of the state of the keys for the mouse. To do
    so, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Multiplexed color LEDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next example in this chapter demonstrates that some seemingly simple hardware
    can produce some impressive results if controlled with software. For this, we
    will go back to using RGB LEDs. We will use five RGB LEDs that are wired so that
    we only need to use eight GPIO pins to control their red, green, and blue elements
    using a method called **hardware multiplexing** (see the *Hardware multiplexing*
    subsection in the *There's more...* section of this recipe).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the RGB LED module shown in the following picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f240314f-3d20-4e18-839d-b4bea49a7025.png)The RGB LED module from
    PiHardware.com'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding photo, the RGB LED module from [http://pihardware.com/](http://pihardware.com/) comes
    with GPIO pins and a DuPont female-to-female cable for connecting it. Although
    there are two sets of pins labelled from 1 to 5, only one side needs to be connected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can recreate your own with the following circuit using five
    common cathode RGB LEDs, 3 x 470 ohm resistors, and a Vero prototype board (or
    large breadboard). The circuit will look as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2e014247-64dd-4885-a536-b51c3b1454b0.png)Circuit diagram for the
    RGB LED moduleStrictly speaking, we should use 15 resistors in this circuit (one
    for each RGB LED element), which will avoid interference from LEDs sharing the
    same resistor, and will also prolong the life of the LEDs themselves if switched
    on together. However, there is only a slight advantage in using this, particularly
    since we intend to drive each RGB LED independently of the other four to achieve
    multi-color effects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to connect the circuit to the Raspberry Pi GPIO header as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **RGB LED** |  |  |  |  |  | 1 |  | 2 | 3 |  | 4 |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Rpi GPIO pin** | 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 | 20 | 22 | 24
    | 26 | 28 | 30 | 32 | 34 | 36 | 38 | 40 |'
  prefs: []
  type: TYPE_TB
- en: '| **Rpi GPIO pin** | 1 | 3 | 5 | 7 | 9 | 11 | 13 | 15 | 17 | 19 | 21 | 23 |
    25 | 27 | 29 | 31 | 33 | 35 | 37 | 39 |'
  prefs: []
  type: TYPE_TB
- en: '| **RGB LED** |  |  |  | 5 |  | R | G | B |  |  |  |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the `rgbled.py` script and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import all the required modules and define the values to be used with the help
    of the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Define functions to set up the GPIO pins using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Define our utility functions to help control the LEDs using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a test function to demonstrate the functionality of the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start with, we define the hardware setup by defining the states required
    to **Enable** and **Disable** the LED depending on the type of RGB LED (common
    cathode) used. If you are using a common anode device, just reverse the **Enable**
    and **Disable** states.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define the GPIO mapping to the pins to match the wiring we did previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also define some basic color combinations by combining red, green, and/or
    blue together, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7e1997f5-945b-402a-8cfe-8be0de9ea29d.png)LED color combinations'
  prefs: []
  type: TYPE_NORMAL
- en: We define a series of useful functions, the first being `led_setup()`, which
    will set the GPIO numbering to `GPIO.BOARD` and define all the pins that are to
    be used as outputs. We also call a function named `led_clear()`, which will set
    the pins to the default state with all the pins disabled.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the LED pins, 1-5 (the common cathode on each LED), are set
    to `HIGH`, while the RGB pins (the separate anodes for each color) are set to
    `LOW`.
  prefs: []
  type: TYPE_NORMAL
- en: We create a function called `led_gpiocontrol()` that will allow us to set the
    state of one or more pins. The `isinstance()` function allows us to test a value
    to see whether it matches a particular type (in this case, a single integer);
    then we can either set the state of that single pin or iterate through the list
    of pins and set each one.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define two functions, `led_activate()` and `led_deactivate()`, which
    will enable and disable the specified LED and color. Finally, we define `led_time()`,
    which will allow us to specify an LED, color, and time to switch it on for.
  prefs: []
  type: TYPE_NORMAL
- en: We also create `led_cleanup()` to reset the pins (and LEDs) to the default values
    and call `GPIO.cleanup()` to release the GPIO pins in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'This script is intended to become a library file, so we will use the `if __name__==''__main__''`
    check to only run our test code when running the file directly:'
  prefs: []
  type: TYPE_NORMAL
- en: By checking the value of `__name__`, we can determine whether the file was run
    directly (it will equal `__main__`) or whether it was imported by another Python
    script.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to define a special test code that is only executed when we directly
    load and run the file. If we include this file as a module in another script,
    then this code will not be executed.
  prefs: []
  type: TYPE_NORMAL
- en: As before, we will use `try`/`finally` to allow us to always perform cleanup
    actions, even if we exit early.
  prefs: []
  type: TYPE_NORMAL
- en: To test the script, we will set the LEDs to light up in various colors, one
    after another.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can create a few different colors by switching on one or more parts of the
    RGB LED at a time. However, with some clever programming, we can create a whole
    spectrum of colors. Also, we can display different colors on each LED, seemingly
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware multiplexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An LED requires a high voltage on the anode side and a lower voltage on the
    cathode side in order to light up. The RGB LEDs used in the circuit are common
    cathodes, so we must apply a high voltage (3V3) on the RGB pins and a low voltage
    (0V) on the cathode pin (wired to pins 1 to 5 for each of the LEDs).
  prefs: []
  type: TYPE_NORMAL
- en: 'The cathode and RGB pin states are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c3aaca65-07d4-4d44-b773-91f3cb7f242f.png)Cathode and RGB pin states'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we can enable one or more of the RGB pins, but still control which
    of the LEDs are lit. We enable the pins of the LEDs we want to light up and disable
    the ones we don't. This allows us to use far fewer pins than we would need to
    control each of the 15 RGB lines separately.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying random patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can add new functions to our library to produce different effects, such
    as generating random colors. The following function uses `randint()` to get a
    value between 1 and the number of colors. We ignore any values that are over the
    number of the available colors so that we can control how often the LEDs are switched
    off. Perform the following steps to add the required functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `randint()` function from the `random` module to the `rgbled.py` script
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add `led_rgbrandom()` using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Use the following commands in the `main()` function to create a series of
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'flashing LEDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Mixing multiple colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have only displayed a single color at a time on one or more of
    the LEDs. If you consider how the circuit is wired up, you might wonder how we
    can get one LED to display one color and another a different one at the same time.
    The simple answer is that we don't need to-we just do it quickly!
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is display one color at a time, but change it back and forth,
    so quickly that the color looks like a mix of the two (or even a combination of
    the three red/green/blue LEDs). Fortunately, this is something that computers
    such as the Raspberry Pi can do very easily, even allowing us to combine the RGB
    elements to make multiple shades of colors across all five LEDs. Perform the following
    steps to mix the colors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add combo color definitions to the top of the `rgbled.py` script, after the
    definition of the mixed colors, using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will provide the combination of colors needed to create our
    shades, with `RGB_COLORS` providing a smooth progression through the shades.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create a function called `led_combo()` to handle single or
    multiple colors. The code for the function will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create a new script, `rgbledrainbow.py`, to make use of the new
    functions in our `rgbled.py` module. The `rgbledrainbow.py` script will be as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main()` function will first cycle through the LEDs, setting each color
    from the `RGB_COLORS` array on all the LEDs. Then, it will cycle through the colors,
    creating a rainbow effect across the LEDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2709e07f-71c2-43ff-b175-3bc84d4e4c45.png)Cycling through multiple
    colors on the five RGB LEDs'
  prefs: []
  type: TYPE_NORMAL
- en: Writing messages using persistence of vision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Persistence of vision** (**POV**) displays can produce an almost magical
    effect, displaying images in the air by moving a line of LEDs back and forth very
    quickly or around in circles. The effect works because your eyes are unable to
    adjust fast enough to separate out the individual flashes of light, and so you
    observe a merged image (the message or picture being displayed):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/221d8d87-7773-4f9b-91eb-d4d610adade4.png)Persistence of vision using
    RGB LEDs'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe uses the RGB LED kit used in the previous recipe; you will also
    need the following additional items:'
  prefs: []
  type: TYPE_NORMAL
- en: Breadboard (half-sized or larger)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 x DuPont female-to-male patch wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tilt switch (the ball-bearing type is suitable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x 470 ohm resistor (R_Protect)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breadboard wire (solid core)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The tilt switch should be added to the RGB LED (as described in the *Getting
    ready* section of the *Multiplexed color LEDs* recipe). The tilt switch is wired
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/60548e93-3f4c-411f-9f5a-76df3d0b07d4.png)The tilt switch is connected
    to GPIO Input (GPIO pin 24) and Gnd (GPIO pin 6)'
  prefs: []
  type: TYPE_IMG
- en: 'To reproduce the POV image, you will need to be able to quickly move the LEDs
    and tilt the switch back and forth. Note how the tilt switch is mounted angled
    to the side, so the switch will open when moved to the left. It is recommended
    that the hardware is mounted onto a length of wood or similar piece of equipment.
    You can even use a portable USB battery pack along with a Wi-Fi dongle to power
    and control the Raspberry Pi through a remote connection (see the *Connecting
    Remotely to the Raspberry Pi over the Network using SSH (and X11 forwarding) recipe
    in *Chapter 1, *Getting Started with a Raspberry Pi 3 Computer*, for details):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dd5c1ecb-a851-40a1-b565-38d5f70b6666.png)Persistence of vision hardware
    setup'
  prefs: []
  type: TYPE_NORMAL
- en: You will also need the completed `rgbled.py` file, which we will extend further
    in the *How to do it*... section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a script called `tilt.py` to report the state of the tilt switch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test the script by running it directly with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following `rgbled_pov()` function to the `rgbled.py` script we created
    previously; this will allow us to display a single line of our image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now create the following file, called `rgbledmessage.py`, to perform
    the required actions to display our message. First, we will import the modules
    used: the updated `rgbled` module, the new `tilt` module, and the Python `os`
    module. Initially, we set `DEBUG` to `True`, so the Python terminal will display
    additional information while the script is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `readMessageFile()` function to read the content of the `letters.txt`
    file and then add `processFileContent()` to generate a **Python dictionary** of
    the LED patterns for each letter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `createBuffer()` function, which will convert a message into a series
    of LED patterns for each letter (assuming the letter is defined by the `letters.txt`
    file):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a `displayBuffer()` function to display the LED patterns using
    the `rgbled_pov()` function in the `rgbled` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a `main()` function to perform each of the required steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the hardware components (RGB LEDs and the tilt switch).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the `letters.txt` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the dictionary of LED letter patterns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a buffer to represent the required message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Display the buffer using the `rgbled` module and control it with the `tilt`
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the following file, called `letters.txt`, to define the LED patterns
    needed to display the example `''_COOKBOOK_''` message. Note that this file only
    needs to define a pattern for each unique letter or symbol in the message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first function, `readMessageFile()`, will open and read the contents of
    a given file. This will then use `processFileContent()` to return a Python dictionary
    containing the corresponding patterns for the letters defined in the file provided.
    Each line in the file is processed, ignoring any line containing a `#` character
    and checking for `"` characters to indicate the name of the LED pattern that follows
    after. After the file has been processed, we end up with a Python dictionary that
    contains LED patterns for the `''_''`, `''C''`, `''B''`, `''K''`, and `''O''`
    characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a selection of letters to choose from, we can create a sequence
    of LED patterns using the `createBuffer()` function. As the name suggests, the
    function will build up a buffer of LED patterns by looking up each letter in the
    message and adding the related pattern row by row. If a letter isn't found in
    the dictionary, then a space will be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we now have a list of LED patterns ready to display. To control when
    we start the sequence, we will use the TILT module and check the status of the
    tilt switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4ef4e458-9ff9-4541-ada9-c2a44883485b.png)The tilt switch position
    when not moving (left) and moving (right)'
  prefs: []
  type: TYPE_IMG
- en: 'The tilt switch consists of a small ball bearing enclosed in a hollow, insulated
    cylinder; the connection between the two pins is closed when the ball is resting
    at the bottom of the cylinder. The tilt switch is open when the ball is moved
    to the other end of the cylinder, out of contact of the pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4019aa2d-ac1f-4e3d-a52a-9f27c1ceb08b.jpg)The tilt switch circuit
    with the switch closed and with the switch open'
  prefs: []
  type: TYPE_NORMAL
- en: The tilt switch circuit shown previously will allow GPIO pin 24 to be connected
    to the ground when the switch is closed. Then, if we read the pin, it will return
    `False` when it is at rest. By setting the GPIO pin as an input and enabling the
    internal pull-up resistor, when the tilt switch is open, it will report `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the tilt switch is open (reporting `True`), then we will assume the unit
    is being moved and begin displaying the LED sequences, incrementing the current
    position each time we display a row of the LED pattern. Just to make the pattern
    a little more colorful (just because we can!) we repeat each row in another color.
    As soon as the `TILT.tilt_moving()` function reports that we have stopped moving
    or that we are moving in the opposite direction, we will reset the current position,
    ready to start the whole pattern all over again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/198791cb-60b0-4dcf-8f12-6438943efa7e.png)The message is displayed
    by the RGB LEDs - here, we are using green and blue together'
  prefs: []
  type: TYPE_NORMAL
- en: When the RGB LED module and tilt switch are moved back and forth, we should
    see the message displayed in the air!
  prefs: []
  type: TYPE_NORMAL
- en: Try experimenting with different color combinations, speeds, and arm waviness
    to see what effects you can produce. You could even create a similar setup mounted
    on a wheel to produce a continuous POV effect.
  prefs: []
  type: TYPE_NORMAL

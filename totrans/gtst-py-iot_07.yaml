- en: Using Python to Drive Hardware
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python驱动硬件
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Controlling an LED
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制LED
- en: Responding to a button
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应按钮
- en: The controlled shutdown button
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制关机按钮
- en: The GPIO keypad input
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPIO键盘输入
- en: Multiplexed color LEDs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多路复用彩色LED
- en: Writing messages using persistence of vision
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视觉持久性编写消息
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: One of the key features of a Raspberry Pi computer that sets it apart from most
    other home/office computers is that it has the ability to directly interface with
    other hardware. The **general-purpose input/output** (**GPIO**) pins on the Raspberry
    Pi can control a wide range of low-level electronics, from **light-emitting diodes**
    (**LEDs**) to switches, sensors, motors, servos, and even extra displays.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派计算机的一个关键特性是它能够直接与其他硬件进行接口。树莓派上的通用输入/输出（GPIO）引脚可以控制各种低级电子设备，从发光二极管（LED）到开关、传感器、电机、伺服和额外的显示器。
- en: This chapter will focus on connecting the Raspberry Pi with some simple circuits
    and getting to grips with using Python to control and respond to the connected
    components.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍如何连接树莓派与一些简单的电路，并掌握使用Python来控制和响应连接的组件。
- en: The Raspberry Pi hardware interface consists of 40 pins located along one side
    of the board.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派硬件接口由板子一侧的40个引脚组成。
- en: The GPIO pins and their layout will vary slightly according to the particular
    model you have.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO引脚及其布局将根据您拥有的特定型号略有不同。
- en: The Raspberry Pi 3, Raspberry Pi 2, and Raspberry Pi B+ all have the same 40-pin
    layout.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派3、树莓派2和树莓派B+都具有相同的40针布局。
- en: The older Raspberry Pi 1 models (nonplus types) have a 26-pin header, which
    is the same as the 1-26 pins of the newer models.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派1代老款（非plus型号）有一个26针的引脚，与新款模型的1-26针相同。
- en: '![](Images/86db1046-6cb8-41d1-a4f1-dd1254bc656b.png)Raspberry Pi 2, Raspberry
    Pi B+, and Raspberry Pi Model Plus GPIO header pins (pin functions)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: 树莓派2、树莓派B+和树莓派Plus GPIO引脚（引脚功能）
- en: The layout of the connector is shown in the preceding diagram; the pin numbers
    are shown as seen from pin 1 of the GPIO header.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 连接器的布局如上图所示；引脚编号从GPIO引脚的引脚1开始。
- en: '**Pin 1** is at the end that is nearest to the SD card, as shown in the following
    photo:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚1位于最靠近SD卡的一端，如下图所示：
- en: '![](Images/54a256bf-7a6a-411b-b7eb-c5f6110d50f1.png)The Raspberry Pi GPIO header
    location'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派GPIO引脚位置
- en: Care should be taken when using the GPIO header, since it also includes power
    pins (3V3 and 5 V), as well as **ground** (**GND**) pins. All of the GPIO pins
    can be used as standard GPIO, but several also have special functions; these are
    labeled and highlighted with different colors.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用GPIO引脚时应当小心，因为它还包括电源引脚（3V3和5V），以及地线（GND）引脚。所有的GPIO引脚都可以用作标准GPIO，但其中一些还具有特殊功能；这些被标记并用不同颜色突出显示。
- en: It is common for engineers to use a 3V3 notation to specify values in schematics
    in order to avoid using decimal places that could easily be missed (using 33V
    rather than 3.3V would cause severe damage to the circuitry). The same can be
    applied to the values of other components, such as resistors, for example, 1.2K
    ohms can be written as 1K2 ohms.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师通常使用3V3标记来指定原理图中的值，以避免使用可能被忽略的小数位（使用33V而不是3.3V会对电路造成严重损坏）。同样的方法也可以应用于其他组件的值，比如电阻，例如，1.2K欧姆可以写成1K2欧姆。
- en: The **TX** and **RX** pins are used for serial communications, and with the
    aid of a voltage-level converter, information can be transferred via a serial
    cable to another computer or device.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: TX和RX引脚用于串行通信，借助电压级转换器，信息可以通过串行电缆传输到另一台计算机或设备。
- en: 'We also have the **SDA** and **SCL** pins, which are able to support a two-wire
    bus communication protocol called **I**²**C** (there are two I²C channels on Raspberry
    Pi 3 and Model Plus boards: **channel 1 ARM**, which is for general use, and **channel
    0 VC**, which is typically used for identifying **hardware attached on top** (**HAT**)
    modules). There are also the **SPI MOSI**, **SPI MISO**, **SPI SCLK**, **SPI CE0**,
    and **SPI CE1** pins, which support another type of bus protocol called **SPI**
    for high-speed data. Finally, we have the **PWM0/1** pin, which allows a **pulse-width
    modulation** signal to be generated, which is useful for servos and generating
    analog signals.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有SDA和SCL引脚，它们能够支持一种名为I²C的双线总线通信协议（树莓派3和Plus板上有两个I²C通道：通道1 ARM，用于通用用途，通道0
    VC，通常用于识别HAT模块上连接的硬件）。还有SPI MOSI、SPI MISO、SPI SCLK、SPI CE0和SPI CE1引脚，支持另一种名为SPI的高速数据总线协议。最后，我们有PWM0/1引脚，允许生成脉冲宽度调制信号，对于伺服和生成模拟信号非常有用。
- en: 'However, we will focus on using just the standard GPIO functions in this chapter.
    The GPIO pin layout is shown in the following diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本章中，我们将专注于使用标准的GPIO功能。GPIO引脚布局如下图所示：
- en: '![](Images/eff316c1-171e-4607-b246-83e8f241b01e.png)Raspberry Pi GPIO header
    pins (GPIO.BOARD and GPIO.BCM)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: 树莓派GPIO引脚（GPIO.BOARD和GPIO.BCM）
- en: 'The Raspberry Pi Rev 2 (pre-July 2014) has the following differences compared
    to the Raspberry Pi 2 GPIO layout:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派Rev 2（2014年7月之前）与树莓派2 GPIO布局相比有以下不同：
- en: 26-GPIO-pin header (matching the first 26 pins).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 26个GPIO引脚的引脚头（匹配前26个引脚）。
- en: 'An additional secondary set of eight holes (P5) located next to the pin header.
    The details are as follows:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引脚头旁边的另一组八个孔（P5）。详细信息如下：
- en: '![](Images/089cf669-1f47-4da7-888a-fa1442f03fd1.png)Raspberry Pi Rev 2 P5 GPIO
    header pins'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派Rev 2 P5 GPIO引脚
- en: 'The original Raspberry Pi Rev 1 (pre-October 2012) has only 26 GPIO pins in
    total, (matching the first 26 pins of the current Raspberry Pi, except for the
    following details:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始的树莓派Rev 1（2012年10月之前）总共只有26个GPIO引脚（匹配当前树莓派的前26个引脚），除了以下细节：
- en: '![](Images/ec7fdb0c-b61f-4108-b924-a6162d59bf0e.png)Raspberry Pi Rev 1 GPIO
    header differences'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/ec7fdb0c-b61f-4108-b924-a6162d59bf0e.png)树莓派Rev 1 GPIO引脚头的差异'
- en: The `RPi.GPIO` library can reference the pins on the Raspberry Pi using one
    of two systems. The numbers shown in the center refer to the physical position
    of the pins, and are also the numbers referenced by the `RPi.GPIO` library when
    in **GPIO.BOARD** mode. The numbers on the outside (**GPIO.BCM**) are the actual
    reference numbers of the physical ports of the processor that indicate which of
    the pins are wired (which is why they are not in any specific order). They are
    used when the mode is set to **GPIO.BCM**, and they allow control of the GPIO
    header pins as well as any peripherals connected to other GPIO lines. This includes
    the LED on the add-on camera on BCM GPIO 4 and the status LED on the board. However,
    this can also include the GPIO lines used for reading/writing to the SD card,
    which would cause serious errors if interfered with.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`RPi.GPIO`库可以使用两种系统之一引用树莓派上的引脚。中间显示的数字是引脚的物理位置，也是在**GPIO.BOARD**模式下`RPi.GPIO`库引用的数字。外部的数字（**GPIO.BCM**）是处理器物理端口的实际引用数字，指示哪些引脚被连接（这就是为什么它们没有特定的顺序）。当模式设置为**GPIO.BCM**时使用它们，并且它们允许控制GPIO引脚以及连接到其他GPIO线的任何外围设备。这包括BCM
    GPIO 4上的附加摄像头上的LED和板上的状态LED。但是，这也可能包括用于读/写SD卡的GPIO线，如果干扰会导致严重错误。'
- en: If you use other programming languages to access the GPIO pins, the numbering
    scheme may be different, so it will be helpful if you are aware of the BCM GPIO
    references, which refer to the physical GPIO ports of the processor.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用其他编程语言访问GPIO引脚，编号方案可能会有所不同，因此如果您了解BCM GPIO引用，将会很有帮助，它们指的是处理器的物理GPIO端口。
- en: Be sure to check out the Appendix, *Hardware and Software List*, which lists
    all the items used in this chapter and the places that you can obtain them from.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必查看附录*硬件和软件清单*，其中列出了本章中使用的所有物品以及您可以从哪里获得它们。
- en: Controlling an LED
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制LED
- en: The hardware equivalent of `hello world` is an LED flash, which is a great test
    to ensure that everything is working and that you have wired it correctly. To
    make it a little more interesting, I've suggested using a **red, blue, and green**
    (**RGB**) LED, but feel free to use separate LEDs if that is all you have available.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件上的“hello world”等同于LED闪烁，这是一个很好的测试，可以确保一切正常工作，并且你已经正确地连接了它。为了让它更有趣，我建议使用**红色、蓝色和绿色**（RGB）LED，但如果你只有单独的LED也可以。
- en: Getting ready
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need the following equipment:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下设备：
- en: 4 x DuPont female-to-male patch wires
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 x 杜邦母对公补丁线
- en: Mini breadboard (170 tie points) or a larger one
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迷你面包板（170个连接点）或更大的面包板
- en: RGB LED (common cathode)/3 standard LEDs (ideally red, green, and blue)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RGB LED（共阴）/3个标准LED（最好是红色、绿色和蓝色）
- en: Breadboard wire (solid core)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板线（实心线）
- en: 3 x 470 ohm resistors
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 x 470欧姆电阻
- en: 'Each of the preceding components shouldn''t cost many dollars and can be reused
    for other projects afterwards. The breadboard is a particularly useful item that
    allows you to try out your own circuits without needing to solder them:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的每个组件成本都不会太高，并且可以在其他项目中重复使用。面包板是一个特别有用的物品，可以让你在不需要焊接的情况下尝试自己的电路：
- en: '![](Images/f9a79a3b-7ca0-4c4e-b4e6-a4d6ff9c69fb.png)Diagrams of an RGB LED,
    a standard LED, and an RGB circuit'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/f9a79a3b-7ca0-4c4e-b4e6-a4d6ff9c69fb.png)RGB LED、标准LED和RGB电路的图表'
- en: 'The following diagram shows the breadboard circuitry:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了面包板电路：
- en: '![](Images/88293cf3-b0ab-45fc-999f-af4c445e2e1d.png)The wiring of an RGB LED/standard
    LEDs connected to the GPIO headerThere are several different kinds of RGB LEDs
    available, so check the datasheet of your component to confirm the pin order and
    type you have. Some are RGB, so ensure that you wire accordingly or adjust the
    `RGB_` pin settings in the code. You can also get common anode variants, which
    will require the anode to be connected to 3V3 (GPIO-pin 1) for it to light up
    (and they will also require `RGB_ENABLE` and `RGB_DISABLE` to be set to `0` and
    `1` `respectively`).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/88293cf3-b0ab-45fc-999f-af4c445e2e1d.png)连接到GPIO引脚的RGB LED/标准LED的接线图有几种不同类型的RGB
    LED可用，因此请检查您组件的数据表以确认引脚顺序和类型。有些是RGB的，所以确保你按照相应的方式连接引脚，或者在代码中调整`RGB_`引脚设置。你也可以获得共阳极变种，这将需要阳极连接到3V3（GPIO引脚1）才能点亮（它们还需要将`RGB_ENABLE`和`RGB_DISABLE`设置为`0`和`1`）。'
- en: The breadboard and component diagrams of this book have been created using a
    free tool called **Fritzing** ([www.fritzing.org](http://www.fritzing.org)); it
    is great for planning your own Raspberry Pi projects.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的面包板和组件图是使用一个名为**Fritzing**（[www.fritzing.org](http://www.fritzing.org)）的免费工具创建的；它非常适合规划您自己的树莓派项目。
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create the `ledtest.py` script as follows:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`ledtest.py`脚本如下：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `RPi.GPIO` library will require `sudo` permissions to access the GPIO pin
    hardware, so you will need to run the script using the following command:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RPi.GPIO`库将需要`sudo`权限来访问GPIO引脚硬件，因此您需要使用以下命令运行脚本：'
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you run the script, you should see the red, green, and blue parts of the
    LED (or each LED, if you're using separate ones) light up in turn. If not, double-check
    your wiring or confirm that the LED is working by temporarily connecting the red,
    green, or blue wire to the 3V3 pin (pin 1 of the GPIO header).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本时，您应该看到LED的红色、绿色和蓝色部分（或者如果您使用单独的LED，则分别点亮）。如果没有，请仔细检查您的接线或确认LED是否正常工作，方法是暂时将红色、绿色或蓝色线连接到3V3引脚（GPIO引脚1）。
- en: The `sudo` command is required for most hardware-related scripts because it
    isn't normal for users to directly control hardware at such a low level. For example,
    setting or clearing a control pin that is part of the SD card controller could
    corrupt data being written to it. Therefore, for security purposes, superuser
    permissions are required to stop programs from using hardware by accident (or
    with malicious intent).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数与硬件相关的脚本都需要`sudo`命令，因为用户通常不会直接在这么低的层次上控制硬件。例如，设置或清除作为SD卡控制器一部分的控制引脚可能会损坏正在写入的数据。因此，出于安全目的，需要超级用户权限，以防止程序意外（或恶意）使用硬件。
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: To access the GPIO pins using Python, we import the `RPi.GPIO` library, which
    allows direct control of the pins through the module functions. We also require
    the `time` module to pause the program for a set number of seconds.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Python访问GPIO引脚，我们导入`RPi.GPIO`库，该库允许通过模块函数直接控制引脚。我们还需要`time`模块来暂停程序一定数量的秒。
- en: We then define values for the LED wiring and active states (see *Controlling
    the GPIO current* segment in the *There's more...* section of this recipe).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为LED的接线和激活状态定义值（请参阅本食谱的*有更多...*部分中的*控制GPIO电流*段）。
- en: Before the GPIO pins are used by the program, we need to set them up by specifying
    the numbering method—`GPIO.BOARD`—and the direction—`GPIO.OUT` or `GPIO.IN` (in
    this case, we set all the RGB pins to outputs). If a pin is configured as an output,
    we will be able to set the pin state; similarly, if it is configured as an input,
    we will be able to read the pin state.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序使用GPIO引脚之前，我们需要通过指定编号方法（`GPIO.BOARD`）和方向（`GPIO.OUT`或`GPIO.IN`）来设置它们（在这种情况下，我们将所有RGB引脚设置为输出）。如果引脚配置为输出，我们将能够设置引脚状态；同样，如果它配置为输入，我们将能够读取引脚状态。
- en: Next, we control the pins using `GPIO.ouput()` by stating the number of the
    GPIO pin and the state we want it to be in (`1` = high/on and `0` = low/off).
    We switch each LED on, wait five seconds, and then switch it back off.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`GPIO.ouput()`来控制引脚，指定GPIO引脚的编号和我们希望它处于的状态（`1` = 高/开启，`0` = 低/关闭）。我们打开每个LED，等待五秒，然后关闭它。
- en: Finally, we use `GPIO.cleanup()` to return the GPIO pins back to their original
    default state and release control of the pins for use by other programs.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`GPIO.cleanup()`将GPIO引脚恢复到它们的原始默认状态，并释放对引脚的控制，以供其他程序使用。
- en: There's more...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有更多...
- en: Using the GPIO pins on the Raspberry Pi must be done with care since these pins
    are directly connected to the main processor of the Raspberry Pi without any additional
    protection. Caution must be used as any incorrect wiring will probably damage
    the Raspberry Pi processor and cause it to stop functioning altogether.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在树莓派上使用GPIO引脚必须小心，因为这些引脚直接连接到树莓派的主处理器，没有额外的保护。必须小心使用，因为任何错误的接线可能会损坏树莓派处理器，并导致其完全停止工作。
- en: 'Alternatively, you could use one of the many modules available that plug directly
    into the GPIO header pins (reducing the chance of wiring mistakes):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用许多直接插入GPIO引脚排针的模块之一（减少接线错误的机会）：
- en: For example, the Pi-Stop is a simple pre-built LED board that simulates a set
    of traffic lights, designed to be a stepping stone for those who are interested
    in controlling hardware but want to avoid the risk of damaging their Raspberry
    Pi. After the basics have been mastered, it also makes an excellent indicator
    to aid debugging.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Pi-Stop是一个简单的预制LED板，模拟了一组交通信号灯，旨在成为那些对控制硬件感兴趣但又想避免损坏树莓派的人的一个过渡阶段。掌握了基础知识后，它也是一个出色的指示器，有助于调试。
- en: Just ensure that you update the `LED CONFIG` pin references in the `ledtest.py`
    script to reference the pin layout and location used for the hardware you are
    using.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 只需确保您在`ledtest.py`脚本中更新`LED CONFIG`引脚引用，以引用您使用的硬件的引脚布局和位置。
- en: '![](Images/ad34ee37-0365-4a28-a71c-578b0daa28e3.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ad34ee37-0365-4a28-a71c-578b0daa28e3.png)'
- en: See the Appendix, *Hardware and Software List*, for a list of Raspberry Pi hardware
    retailers.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅附录中的*硬件和软件清单*，了解树莓派硬件零售商的清单。
- en: Controlling the GPIO current
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制GPIO电流
- en: Each GPIO pin is only able to handle a certain current before it burns out (a
    maximum of 16 mA from a single pin or 30 mA in total), and similarly, the RGB
    LED should be limited to no more than 100 mA. By adding a resistor before or after
    an LED, we will be able to limit the current that will be passed through it and
    control how bright it is (more current will equal a brighter LED).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每个GPIO引脚在烧毁之前只能处理一定电流（单个引脚最大16mA，总共30mA），同样，RGB LED的电流应限制在100mA以下。通过在LED之前或之后添加电阻，我们将能够限制通过LED的电流并控制其亮度（更大的电流将使LED更亮）。
- en: Since we may wish to power more than one LED at a time, we typically aim to
    set the current as low as we can get away with while still providing enough power
    to light up the LED.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可能希望同时点亮多个LED，因此我们通常会尽量将电流设置得尽可能低，同时仍然提供足够的功率点亮LED。
- en: 'We can use Ohm''s law to tell us how much resistance to use to provide a particular
    current. The law is as shown in the following diagram:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用欧姆定律来告诉我们需要多少电阻来提供特定的电流。该定律如下图所示：
- en: '![](Images/f3fc16b6-3b93-46ac-9491-565b179ecd6a.png)Ohm''s law: The relationship
    between the current, resistance, and voltage in electrical circuits'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/f3fc16b6-3b93-46ac-9491-565b179ecd6a.png)欧姆定律：电路中电流、电阻和电压之间的关系'
- en: 'We will aim for a minimum current (3 mA) and maximum current (16 mA), while
    still producing a reasonably bright light from each of the LEDs. To get a balanced
    output for the RGB LEDs, I tested different resistors until they provided a near
    white light (when viewed through a card). A 470 ohm resistor was selected for
    each one (your LEDs may differ slightly):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以最小电流（3mA）和最大电流（16mA）为目标，同时仍然从每个LED产生相当明亮的光。为了获得RGB LED的平衡输出，我测试了不同的电阻，直到它们提供了接近白光（通过卡片查看）。每个LED选择了470欧姆的电阻（您的LED可能略有不同）：
- en: '![](Images/64bf4bbc-c955-45b6-9567-4372306aa5d1.png)Resistors are needed to
    limit the current that passes through the LEDs'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/64bf4bbc-c955-45b6-9567-4372306aa5d1.png)需要电阻器来限制通过LED的电流'
- en: 'The voltage across the resistor is equal to the GPIO voltage (**Vgpio** = 3.3V)
    minus the voltage drop on the particular LED (**Vfwd**); we can then use this
    resistance to calculate the current used by each of the LEDs, as shown in the
    following formulas:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻器上的电压等于GPIO电压（**Vgpio** = 3.3V）减去特定LED的电压降（**Vfwd**）；然后我们可以使用这个电阻来计算每个LED使用的电流，如下面的公式所示：
- en: '![](Images/6a89db2a-ff7b-4579-b310-230c7c9c9ca4.png)We can calculate the current
    drawn by each of the LEDs'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/6a89db2a-ff7b-4579-b310-230c7c9c9ca4.png)我们可以计算每个LED的电流'
- en: Responding to a button
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应按钮
- en: Many applications using the Raspberry Pi require that actions are activated
    without requiring a keyboard and screen to be attached to it. The GPIO pins provide
    an excellent way for the Raspberry Pi to be controlled by your own buttons and
    switches without a mouse/keyboard and screen.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 许多使用树莓派的应用程序要求在不需要连接键盘和屏幕的情况下激活操作。 GPIO引脚为树莓派提供了一种优秀的方式，使其可以通过您自己的按钮和开关进行控制，而无需鼠标/键盘和屏幕。
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need the following equipment:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要以下设备：
- en: 2 x DuPont female-to-male patch wires
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x DuPont母对公跳线
- en: Mini breadboard (170 tie points) or a larger one
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迷你面包板（170个连接点）或更大的面包板
- en: Push-button switch (momentary close) or a wire connection to make/break the
    circuit
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮开关（瞬时闭合）或导线连接以打开/关闭电路
- en: Breadboard wire (solid core)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板导线（实心线）
- en: 1K ohm resistor
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1K欧姆电阻器
- en: 'The switches are as shown in the following diagram:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 开关如下图所示：
- en: '![](Images/325f711c-c617-4bcb-b66a-1b17ab3f2080.png)The push-button switch
    and other types of switchThe switches used in the following examples are **single-pole,
    single-throw** (**SPST**), momentary close, push-button switches. **Single pole**
    (**SP**) means that there is one set of contacts that makes a connection. In the
    case of the push switch used here, the legs on each side are connected together
    with a single-pole switch in the middle. A **double-pole** (**DP**) switch acts
    just like a SP switch, except that the two sides are separated electrically, allowing
    you to switch two separate components on/off at the same time.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/325f711c-c617-4bcb-b66a-1b17ab3f2080.png)按钮开关和其他类型的开关以下示例中使用的开关是**单极，单刀**（**SPST**），瞬时闭合，按钮开关。**单极**（**SP**）意味着有一组使连接的触点。在这里使用的按钮开关的情况下，每侧的腿与中间的单极开关连接在一起。**双极**（**DP**）开关的作用就像单极开关，只是两侧在电上是分开的，允许您同时打开/关闭两个独立的组件。'
- en: '**Single throw** (**ST**) means the switch will make a connection with just
    one position; the other side will be left open. **Double throw** (**DT**) means
    both positions of the switch will connect to different parts.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**单刀**（**ST**）意味着开关将仅在一个位置进行连接；另一侧将保持开放。**双刀**（**DT**）意味着开关的两个位置将连接到不同的部分。'
- en: '**Momentary close** means that the button will close the switch when pressed
    and automatically open it when released. A **latched** push-button switch will
    remain closed until it is pressed again.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**瞬时闭合**意味着按下按钮时将关闭开关，并在释放时自动打开。**锁定**按钮开关将保持关闭状态，直到再次按下。'
- en: Trying a speaker or headphone with Raspberry Pi
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试使用树莓派的扬声器或耳机
- en: '![](Images/c54871b1-71d9-4932-9f4b-d212a53578d3.png)The layout of the button
    circuit'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/c54871b1-71d9-4932-9f4b-d212a53578d3.png)按钮电路的布局'
- en: We will use sound in this example, so you will also need speakers or headphones
    attached to the audio socket of the Raspberry Pi.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将使用声音，因此您还需要将扬声器或耳机连接到树莓派的音频插孔。
- en: 'You will need to install a program called `flite` using the following command,
    which will let us make the Raspberry Pi talk:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用以下命令安装名为`flite`的程序，这将让我们让树莓派说话：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After it has been installed, you can test it with the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，您可以使用以下命令进行测试：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If it is a little too quiet (or too loud), you can adjust the volume (0-100
    percent) using the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果太安静（或太吵），您可以使用以下命令调整音量（0-100％）：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create the `btntest.py` script as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`btntest.py`脚本如下：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As in the previous recipe, we set up the GPIO pin as required, but this time
    as an input, and we also enable the internal pull-up resistor (see *Pull-up and
    pull-down resistor circuits* in the *There''s more...* section of this recipe
    for more information) using the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个示例一样，我们根据需要设置GPIO引脚，但这次是作为输入，并且还启用了内部上拉电阻器（有关更多信息，请参阅本示例的*更多内容...*部分中的*上拉和下拉电阻器电路*）使用以下代码：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After the GPIO pin is set up, we create a loop that will continuously check
    the state of `BTN` using `GPIO.input()`. If the value returned is `false`, the
    pin has been connected to 0V (ground) through the switch, and we will use `flite`
    to count out loud for us each time the button is pressed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了GPIO引脚之后，我们创建一个循环，将不断检查`BTN`的状态，使用`GPIO.input()`。如果返回的值为`false`，则表示通过开关将引脚连接到0V（地），我们将使用`flite`每次按下按钮时为我们大声计数。
- en: Since we have called the main function from within a `try`/`finally` condition,
    it will still call `GPIO.cleanup()` even if we close the program using *Ctrl*
    + *Z*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`try`/`finally`条件中调用了主函数，即使我们使用*Ctrl* + *Z*关闭程序，它仍将调用`GPIO.cleanup()`。
- en: We use a short delay in the loop; this ensures that any noise from the contacts
    on the switch is ignored. This is because when we press the button, there isn't
    always perfect contact as we press or release it, and it may produce several triggers
    if we press it again too quickly. This is known as **software debouncing**; we
    ignore the bounce in the signal here.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在循环中使用短延迟；这可以确保忽略开关上的接触产生的任何噪音。这是因为当我们按下按钮时，按下或释放时并不总是完美接触，如果我们再次按下它，可能会产生多个触发。这被称为**软件去抖动**；我们在这里忽略了信号中的弹跳。
- en: There's more...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The Raspberry Pi GPIO pins must be used with care; voltages used for inputs
    should be
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派GPIO引脚必须小心使用；用于输入的电压应该是
- en: within specific ranges, and any current drawn from them should be minimized
    using
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定范围内，并且从中抽取的任何电流应该最小化使用
- en: protective resistors.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 保护电阻。
- en: Safe voltages
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全电压
- en: We must ensure that we only connect inputs that are between 0 (ground) and 3V3\.
    Some processors use voltages between 0V and 5V, so extra components are required
    to interface safely with them. Never connect an input or component that uses 5V
    unless you are certain it is safe, or you will damage the GPIO ports of the Raspberry
    Pi.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保只连接在0（地）和3V3之间的输入。一些处理器使用0V到5V之间的电压，因此需要额外的组件才能安全地与它们接口。除非确定安全，否则永远不要连接使用5V的输入或组件，否则会损坏树莓派的GPIO端口。
- en: Pull-up and pull-down resistor circuits
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上拉和下拉电阻电路
- en: The previous code sets the GPIO pins to use an internal pull-up resistor. Without
    a pull-up resistor (or pull-down resistor) on the GPIO pin, the voltage is free
    to float somewhere between 3V3 and 0V, and the actual logical state remains undetermined
    (sometimes 1 and sometimes 0).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码设置了GPIO引脚使用内部上拉电阻。如果GPIO引脚上没有上拉电阻（或下拉电阻），电压可以在3V3和0V之间自由浮动，实际逻辑状态保持不确定（有时为1，有时为0）。
- en: Raspberry Pi's internal pull-up resistors are 50K ohm-65K ohm, and the pull-down
    resistors are 50K ohm-65K ohm. External pull-up/pull-down resistors are often
    used in GPIO circuits (as shown in the following diagram), typically using 10K
    ohm or larger for similar reasons (giving a very small current draw when they
    are not active).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派的内部上拉电阻为50K欧姆至65K欧姆，下拉电阻为50K欧姆至65K欧姆。外部上拉/下拉电阻通常用于GPIO电路（如下图所示），通常使用10K欧姆或更大的电阻出于类似的原因（当它们不活动时提供非常小的电流吸收）。
- en: 'A pull-up resistor allows a small amount of current to flow through the GPIO
    pin and will provide a high voltage when the switch isn''t pressed. When the switch
    is pressed, the small current is replaced by the larger one flowing to 0V, so
    we get a low voltage on the GPIO pin instead. The switch is active low and logic
    0 when pressed. It works as shown in the following diagram:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上拉电阻允许通过GPIO引脚流动少量电流，并且在开关未按下时提供高电压。当按下开关时，小电流被流向0V的大电流所取代，因此我们在GPIO引脚上得到低电压。开关在按下时为活动低电平和逻辑0。它的工作原理如下图所示：
- en: '![](Images/29c4c4eb-9bc8-4f96-bd07-7c8206af9a32.png)A pull-up resistor circuit'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/29c4c4eb-9bc8-4f96-bd07-7c8206af9a32.png)上拉电阻电路'
- en: 'Pull-down resistors work in the same way, except the switch is active high
    (the GPIO pin is logic 1 when pressed). It works as shown in the following diagram:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下拉电阻的工作方式相同，只是开关为活动高电平（按下时GPIO引脚为逻辑1）。它的工作原理如下图所示：
- en: '![](Images/b8708774-f896-4447-acc1-a829863676d1.png)A pull-down resistor circuit'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/b8708774-f896-4447-acc1-a829863676d1.png)下拉电阻电路'
- en: Protection resistors
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护电阻
- en: 'In addition to the switch, the circuit includes a resistor in series with the
    switch to protect the GPIO pin, as shown in the following diagram:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了开关外，电路还包括与开关串联的电阻，以保护GPIO引脚，如下图所示：
- en: '![](Images/f47a0106-2712-472d-a88b-7efea679d893.png)A GPIO protective current-limiting
    resistor'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/f47a0106-2712-472d-a88b-7efea679d893.png)GPIO保护限流电阻'
- en: The purpose of the protection resistor is to protect the GPIO pin if it is accidentally
    set as an output rather than an input. Imagine, for instance, that we have our
    switch connected between the GPIO and ground. Now the GPIO pin is set as an output
    and switched on (driving it to 3V3) as soon as we press the switch, without a
    resistor present, the GPIO pin will be directly connected to 0V. The GPIO will
    still try to drive it to 3V3; this will cause the GPIO pin to burn out (since
    it will use too much current to drive the pin to the high state). If we use a
    1K ohm resistor here, the pin is able to be driven high using an acceptable amount
    of current (I = V/R = 3.3/1K = 3.3 mA).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 保护电阻的目的是保护GPIO引脚，如果它被意外设置为输出而不是输入。例如，假设我们的开关连接在GPIO和地之间。现在GPIO引脚被设置为输出并打开（驱动到3V3），一旦我们按下开关，没有电阻的情况下，GPIO引脚将直接连接到0V。
    GPIO仍然会尝试将其驱动到3V3；这将导致GPIO引脚烧毁（因为它将使用太多电流来驱动引脚到高状态）。如果我们在这里使用1K欧姆电阻，引脚可以使用可接受的电流驱动高（I
    = V/R = 3.3/1K = 3.3毫安）。
- en: A controlled shutdown button
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 受控关机按钮
- en: The Raspberry Pi should always be shut down correctly to avoid the SD card being
    corrupted (by losing power while performing a write operation to the card). This
    can pose a problem if you don't have a keyboard or screen connected (you might
    be running an automated program or controlling it remotely over a network and
    forget to turn it off) as you can't type the command or see what you are doing.
    By adding our own buttons and LED indicator, we can easily command a shutdown
    and reset, and then start up again to indicate when the system is active.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派应该始终正确关机，以避免SD卡损坏（在对卡进行写操作时断电）。如果您没有连接键盘或屏幕（可能正在运行自动化程序或通过网络远程控制），这可能会造成问题，因为您无法输入命令或查看您正在做什么。通过添加我们自己的按钮和LED指示灯，我们可以轻松地命令关机和重启，然后再次启动以指示系统处于活动状态。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need the following equipment:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要以下设备：
- en: 3 x DuPont female-to-male patch wires
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 x DuPont母对公跳线
- en: Mini breadboard (170 tie points) or a larger one
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迷你面包板（170个连接点）或更大的面包板
- en: Push-button switch (momentary close)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮开关（瞬时闭合）
- en: General-purpose LED
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用LED
- en: 2 x 470 ohm resistors
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x 470欧姆电阻
- en: Breadboard wire (solid core)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板导线（实心）
- en: 'The entire layout of the shutdown circuit will look as shown in the following
    figure:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 关机电路的整个布局将如下图所示：
- en: '![](Images/32384f24-fc03-40a6-953b-a4e9a263e4ab.png)The controlled shutdown
    circuit layout'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/32384f24-fc03-40a6-953b-a4e9a263e4ab.png)受控关机电路布局'
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create the `shtdwn.py` script as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`shtdwn.py`脚本如下：
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To get this script to run automatically (once we have tested it), we can place
    the script in the `~/bin` (we can use `cp` instead of `mv` if we just want to
    copy it) and add it to `crontab` with the following code:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使这个脚本自动运行（一旦我们测试过它），我们可以将脚本放在`~/bin`中（如果只想复制它，可以使用`cp`而不是`mv`），并使用以下代码将其添加到`crontab`中：
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At the end of the file, we add the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件末尾，我们添加以下代码：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This time, when we set up the GPIO pin, we define the pin connected to the shutdown
    button as an input and the pin connected to the LED as an output. We turn the
    LED on to indicate that the system is running.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当我们设置GPIO引脚时，我们将与关机按钮连接的引脚定义为输入，与LED连接的引脚定义为输出。我们打开LED以指示系统正在运行。
- en: By setting the `DEBUG` flag to `True`, we can test the functionality of our
    script without causing an actual shutdown (by reading the terminal messages);
    we just need to ensure that we set `DEBUG` to `False` when using the script for
    real.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`DEBUG`标志设置为`True`，我们可以测试脚本的功能，而不会导致实际关闭（通过读取终端消息）；我们只需要确保在实际使用脚本时将`DEBUG`设置为`False`。
- en: We enter a `while` loop and check the pin every second to see whether the GPIO
    pin is set to `LOW` (that is, to check whether the switch has been pressed); if
    so, we enter the `doShutdown()` function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入一个`while`循环，并每秒检查引脚，以查看GPIO引脚是否设置为`LOW`（即检查开关是否被按下）；如果是，我们就进入`doShutdown()`函数。
- en: The program will wait for three seconds and then test again to see whether the
    button is still being pressed. If the button is no longer being pressed, we return
    to the previous `while` loop. However, if it is still being pressed after three
    seconds, the program will flash the LED and trigger the shutdown (and also provide
    an audio warning using `flite`).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将等待三秒，然后再次测试按钮是否仍然被按下。如果按钮不再被按下，我们将返回到之前的`while`循环。但是，如果在三秒后它仍然被按下，程序将闪烁LED并触发关闭（还会使用`flite`提供音频警告）。
- en: When we are happy with how the script is operating, we can disable the `DEBUG`
    flag (by setting it to `False`) and add the script to `crontab`. `crontab` is
    a special program that runs in the background and allows us to schedule (at specific
    times, dates, or periodically) programs and actions when the system is started
    (`@reboot`). This allows the script to be started automatically every time the
    Raspberry Pi is powered up. When we press and hold the shutdown button for more
    than three seconds, it safely shuts down the system and enters a low power state
    (the LED switches off just before this, indicating that it is safe to remove the
    power shortly after). To restart the Raspberry Pi, we briefly remove the power;
    this will restart the system, and the LED will light up when the Raspberry Pi
    has loaded.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对脚本的运行状态感到满意时，我们可以禁用`DEBUG`标志（将其设置为`False`），并将脚本添加到`crontab`中。`crontab`是一个在后台运行的特殊程序，允许我们在系统启动时（`@reboot`）安排程序和操作的特定时间、日期或周期性。这使得脚本可以在每次树莓派上电时自动启动。当我们按住关机按钮超过三秒时，它会安全地关闭系统并进入低功耗状态（LED在此之前会关闭，表明很快就可以拔掉电源）。要重新启动树莓派，我们简单地拔掉电源；这将重新启动系统，当树莓派加载完成时，LED会亮起。
- en: There's more...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can extend this example further using the reset header by adding extra functionality
    and making use of additional GPIO connections (if available).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加额外的功能并利用额外的GPIO连接（如果可用）来进一步扩展这个示例。
- en: Resetting and rebooting Raspberry Pi
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重置和重新启动树莓派
- en: 'The Raspberry Pi has holes for mounting a reset header (marked **RUN** on the
    Raspberry Pi 3/2 and **P6** on the Raspberry Pi 1 Model A and Model B Rev 2).
    The reset pin allows the device to be reset using a button rather than removing
    the micro USB connector each time to cycle the power:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派上有用于安装复位标头的孔（在树莓派3/2上标有**RUN**，在树莓派1型A和B Rev 2上标有**P6**）。复位引脚允许使用按钮而不是每次都拔掉微型USB连接器来重置设备的电源：
- en: '![](Images/842a26a3-f0cc-4e68-993c-b5b9fda3ab38.png)Raspberry Pi reset headers
    - on the left, Raspberry Pi Model A/B (Rev2), and on the right, Raspberry Pi 3'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/842a26a3-f0cc-4e68-993c-b5b9fda3ab38.png)树莓派复位标头-左边是树莓派A/B型（Rev2），右边是树莓派3'
- en: 'To make use of it, you will need to solder a wire or pin header to the Raspberry
    Pi and connect a button to it (or briefly touch a wire between the two holes each
    time). Alternatively, we can extend our previous circuit, as shown in the following
    diagram:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，您需要将一根导线或引脚排焊接到树莓派上，并连接一个按钮（或每次在两个孔之间短暂触碰一根导线）。或者，我们可以扩展我们之前的电路，如下图所示：
- en: '![](Images/7f05b9ba-5dc4-4c35-a484-fbb8c67ff403.png)The controlled shutdown
    circuit layout and reset button'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/7f05b9ba-5dc4-4c35-a484-fbb8c67ff403.png)受控关闭电路布局和复位按钮'
- en: We can add this extra button to our circuit, which can be connected to the reset
    header (this is the hole nearest the middle on the Raspberry Pi 3 or closest to
    the edge on other models). This pin, when temporarily pulled low by connecting
    to ground (such as the hole next to it or by another ground point, such as pin
    6 of the GPIO header), will reset the Raspberry Pi and allow it to boot up again
    following a shutdown.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个额外的按钮添加到我们的电路中，它可以连接到复位标头（这是树莓派3上最靠近中间的孔，其他型号上最靠近边缘的孔）。当暂时将此引脚拉低连接到地（例如旁边的孔或GPIO标头的第6引脚等其他地点），将重置树莓派并允许它在关闭后再次启动。
- en: Adding extra functions
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加额外功能
- en: Since we now have the script monitoring the shutdown button all the time, we
    can add extra buttons/switches/jumpers to be monitored at the same time. This
    will allow us to trigger specific programs or set up particular states just by
    changing the inputs. The following example allows us to easily switch between
    automatic DHCP networking (the default networking setup) and using a direct IP
    address, as used in the *Networking directly to a laptop or computer* recipe of
    Chapter 1, *Getting Started with a Raspberry Pi 3 Computer*, for direct LAN connections.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在脚本一直监视关机按钮，我们可以同时添加额外的按钮/开关/跳线来监视。这将允许我们通过改变输入来触发特定程序或设置特定状态。以下示例允许我们轻松地在自动DHCP网络（默认网络设置）和使用直接IP地址之间进行切换，就像第1章“使用树莓派3计算机入门”中的“直接连接到笔记本电脑或计算机”配方中使用的那样。
- en: 'Add the following components to the previous circuit:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下组件添加到上一个电路中：
- en: A 470 ohm resistor
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个470欧姆电阻
- en: Two pin headers with a jumper connector (or, optionally, a switch)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个带跳线连接器的引脚头（或者，可选地，一个开关）
- en: Breadboard wire (solid core)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板导线（实心线）
- en: 'After adding the preceding components, our controlled shutdown circuit now
    looks as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了上述组件之后，我们的受控关机电路现在如下所示：
- en: '![](Images/16390e01-579c-4baa-9947-a171dfde83ac.png)The controlled shutdown
    circuit layout, reset button, and jumper pins'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/16390e01-579c-4baa-9947-a171dfde83ac.png)受控关机电路布局、复位按钮和跳线引脚'
- en: 'In the previous script, we add an additional input to detect the status of
    the `LAN_SWA` pin (the jumper pins we added to the circuit) using the following
    code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个脚本中，我们添加了一个额外的输入来检测`LAN_SWA`引脚的状态（我们添加到电路中的跳线引脚），使用以下代码：
- en: '[PRE10]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Ensure that it is set up as an input (with a pull-up resistor) in the `gpio_setup()`
    function using the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在`gpio_setup()`函数中设置为输入（带上拉电阻）使用以下代码：
- en: '[PRE11]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add a new function to switch between the LAN modes and read out the new IP
    address. The `doChangeLAN()` function checks whether the status of the `LAN_SWA`
    pin has changed since the last call, and if so, it sets the network adapter to
    DHCP or sets the direct LAN settings accordingly (and uses `flite` to speak the
    new IP setting, if available). Finally, the LAN being set for direct connection
    causes the LED to flash slowly while that mode is active. Use the following code
    to do this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新的功能来在LAN模式之间切换并读取新的IP地址。`doChangeLAN()`函数检查`LAN_SWA`引脚的状态是否自上次调用以来发生了变化，如果是，则将网络适配器设置为DHCP，或者相应地设置直接LAN设置（如果可用，则使用`flite`来朗读新的IP设置）。最后，设置LAN为直接连接会导致LED在该模式激活时缓慢闪烁。使用以下代码来实现这一点：
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add another function, `flashled()`, which will just toggle the state of the
    LED each time it is called. The code for this function is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 添加另一个函数`flashled()`，每次调用时切换LED的状态。该函数的代码如下：
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we adjust the main loop to also call `doChangeLAN()` and use the result
    to decide whether we call `flashled()` using `ledon` to keep track of the LED''s
    previous state each time. The `main()` function should now be updated as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调整主循环，也调用`doChangeLAN()`，并使用结果决定是否使用`ledon`调用`flashled()`来跟踪LED的上一个状态。`main()`函数现在应该更新如下：
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The GPIO keypad input
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GPIO键盘输入
- en: We have seen how we can monitor inputs on the GPIO to launch applications and
    control the Raspberry Pi; however, sometimes we need to control third-party programs.
    Using the `uInput` library, we can emulate key presses from a keyboard (or even
    mouse movement) to control any program using our own custom hardware.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何监视GPIO上的输入来启动应用程序和控制树莓派；然而，有时我们需要控制第三方程序。使用`uInput`库，我们可以模拟键盘（甚至鼠标移动）来控制任何程序，使用我们自己的自定义硬件。
- en: For more information about using `uInput`, visit [http://tjjr.fi/sw/python-uinput/](http://tjjr.fi/sw/python-uinput/).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用`uInput`的更多信息，请访问[http://tjjr.fi/sw/python-uinput/](http://tjjr.fi/sw/python-uinput/)。
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Perform the following steps to install `uInput`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤安装`uInput`：
- en: First, we need to download `uInput`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要下载`uInput`。
- en: 'You will need to download the `uInput` Python library from GitHub (~50 KB)
    using the following commands:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用以下命令从GitHub下载`uInput` Python库（约50 KB）：
- en: '[PRE15]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The library will unzip to a directory called `python-uinput-master`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该库将解压缩到一个名为`python-uinput-master`的目录中。
- en: 'Once completed, you can remove the ZIP file using the following command:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，可以使用以下命令删除ZIP文件：
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Install the required packages using the following commands (if you have installed
    them already, the `apt-get` command will ignore them):'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装所需的软件包（如果已经安装了它们，`apt-get`命令将忽略它们）：
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Compile and install `uInput` using the following commands:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令编译和安装`uInput`：
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we load the new `uinput` kernel module using the following command:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下命令加载新的`uinput`内核模块：
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To ensure it is loaded upon startup, we can add `uinput` to the `modules` file
    using the following command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在启动时加载，我们可以使用以下命令将`uinput`添加到`modules`文件中：
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Put `uinput` on a new line in the file and save it (*Ctrl* + *X*, *Y*).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中新建一行并保存（*Ctrl* + *X*, *Y*）。
- en: 'Create the following circuit using the following equipment:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下设备创建以下电路：
- en: Breadboard (half-sized or larger)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板（半尺寸或更大）
- en: 7 x DuPont female-to-male patch wires
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7根DuPont母对公排线
- en: Six push buttons
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六个按钮
- en: 6 x 470 ohm resistors
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6个470欧姆电阻
- en: Breadboarding wire (solid core)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板导线（实心线）
- en: '![](Images/a4eac434-a135-49ff-bdb7-e4b98accf7ae.png)GPIO keypad circuit layout'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/a4eac434-a135-49ff-bdb7-e4b98accf7ae.png)GPIO键盘电路布局'
- en: 'The keypad circuit can also be built into a permanent circuit by soldering
    the components into a Vero prototype board (also known as a stripboard), as shown
    in the following photo:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘电路也可以通过将组件焊接到Vero原型板（也称为条板）中，制成永久电路，如下图所示：
- en: '![](Images/121e0320-e6c0-4ade-b143-64e253df5e16.png)GPIO keypad Pi hardware
    moduleThis circuit is available as a solder-yourself kit from [PiHardware.com](http://pihardware.com/).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/121e0320-e6c0-4ade-b143-64e253df5e16.png)GPIO键盘Pi硬件模块这个电路可以从[PiHardware.com](http://pihardware.com/)购买成套焊接套件。'
- en: 'Connect the circuit to the Raspberry Pi GPIO pins by matching the appropriate
    buttons with the appropriate pins, as shown in the following table:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将适当的按钮与适当的引脚相匹配，将电路连接到树莓派GPIO引脚，如下表所示：
- en: '|  | **Button** | **GPIO pin** |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '|  | **按钮** | **GPIO引脚** |'
- en: '| GND |  | 6 |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| GND |  | 6 |'
- en: '| v | B_DOWN | 22 |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| v | B_DOWN | 22 |'
- en: '| < | B_LEFT | 18 |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| < | B_LEFT | 18 |'
- en: '| ^ | B_UP | 15 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| ^ | B_UP | 15 |'
- en: '| > | B_RIGHT | 13 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| > | B_RIGHT | 13 |'
- en: '| 1 | B_1 | 11 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 1 | B_1 | 11 |'
- en: '| 2 | B_2 | 7 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 2 | B_2 | 7 |'
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a `gpiokeys.py` script as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`gpiokeys.py`的脚本，如下所示：
- en: '[PRE21]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we import `uinput` and define the wiring of the keypad buttons. For each
    of the buttons in `BTN`, we enable them as inputs, with internal pull-ups enabled.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入“uinput”并定义键盘按钮的接线。对于`BTN`中的每个按钮，我们将它们启用为输入，并启用内部上拉。
- en: Next, we set up `uinput`, defining the keys we want to emulate and adding them
    to the `uinput.Device()` function. We wait a few seconds to allow `uinput` to
    initialize, set the initial button and key states, and start our `main` loop.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置`uinput`，定义我们想要模拟的键，并将它们添加到`uinput.Device()`函数中。我们等待几秒钟，以便`uinput`初始化，设置初始按钮和键状态，并启动我们的`main`循环。
- en: 'The `main` loop is split into two sections: the first section checks through
    the buttons and records the states in `btn_state`, and the second section compares
    the `btn_state` with the current `key_state` array. This way, we can detect a
    change in `btn_state` and call `device.emit()` to toggle the state of the key.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`循环分为两个部分：第一部分检查按钮并记录`btn_state`中的状态，第二部分将`btn_state`与当前的`key_state`数组进行比较。这样，我们可以检测到`btn_state`的变化，并调用`device.emit()`来切换键的状态。'
- en: To allow us to run this script in the background, we can run it with `&`, as
    shown in the
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们能够在后台运行此脚本，我们可以使用`&`运行它，如下所示
- en: 'following command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令：
- en: '[PRE22]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `&` character allows the command to run in the background, so we can continue
    with the command line to run other programs. You can use `fg` to bring it back
    to the foreground, or `%1`, `%2`, and so on if you have several commands running.
    Use `jobs` to get a list.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: “&”字符允许命令在后台运行，因此我们可以继续使用命令行运行其他程序。您可以使用`fg`将其带回前台，或者如果有多个命令正在运行，则可以使用`%1`，`%2`等。使用`jobs`获取列表。
- en: You can even put a process/program on hold to get to Command Prompt by pressing
    *Ctrl* + *Z* and then resume it with `bg` (which will let it run in the background).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以通过按下*Ctrl* + *Z*将进程/程序暂停以进入命令提示符，然后使用`bg`恢复它（这将使其在后台运行）。
- en: There's more...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多信息...
- en: We can do more using `uinput` to provide hardware control for other programs,
    including those that require mouse input.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用“uinput”来为其他程序提供硬件控制，包括那些需要鼠标输入的程序。
- en: Generating other key combinations
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成其他按键组合
- en: 'You can create several different key mappings in your file to support different
    programs. For instance, the `events_z80` key mapping would be useful for a spectrum
    emulator, such as **Fuse** (browse to [http://raspi.tv/2012/how-to-install-fuse-zx-spectrum-emulator-on-raspberry-pi](http://raspi.tv/2012/how-to-install-fuse-zx-spectrum-emulator-on-raspberry-pi)
    for more details). The `events_omx` key mappings are suitable for controlling
    video played through the OMXPlayer using the following command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在文件中创建几种不同的键映射以支持不同的程序。例如，`events_z80`键映射对于像**Fuse**这样的光谱模拟器非常有用（浏览[http://raspi.tv/2012/how-to-install-fuse-zx-spectrum-emulator-on-raspberry-pi](http://raspi.tv/2012/how-to-install-fuse-zx-spectrum-emulator-on-raspberry-pi)获取更多详细信息）。`events_omx`键映射适用于使用以下命令控制通过OMXPlayer播放的视频：
- en: '[PRE23]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can get a list of keys supported by `omxplayer` by using the `-k` parameter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`-k`参数获取`omxplayer`支持的键列表。
- en: 'Replace the line that defines the `events` list with a new key mapping, and
    select different ones by assigning them to events using the following code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 用新的键映射替换定义“events”列表的行，并通过以下代码将它们分配给事件来选择不同的键：
- en: '[PRE24]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can find all the `KEY` definitions in the `input.h` file; you can view
    it using the `less` command (press *Q* to exit), as shown in the following command:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`input.h`文件中找到所有的`KEY`定义；您可以使用`less`命令查看它（按*Q*退出），如下所示：
- en: '[PRE25]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Emulating mouse events
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟鼠标事件
- en: 'The `uinput` library can emulate mouse and joystick events, as well as keyboard
    presses. To use the buttons to simulate a mouse, we can adjust the script to use
    mouse events (as well as defining `mousemove` to set the step size of the movement)
    using the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: “uinput”库可以模拟鼠标和操纵杆事件，以及键盘按键。要使用按钮模拟鼠标，我们可以调整脚本以使用鼠标事件（以及定义`mousemove`来设置移动的步长），使用以下代码：
- en: '[PRE26]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We also need to modify the button handling to provide continuous movement,
    as we don''t need to keep track of the state of the keys for the mouse. To do
    so, use the following code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改按钮处理以提供连续移动，因为我们不需要跟踪鼠标键的状态。为此，请使用以下代码：
- en: '[PRE27]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Multiplexed color LEDs
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多路复用的彩色LED
- en: The next example in this chapter demonstrates that some seemingly simple hardware
    can produce some impressive results if controlled with software. For this, we
    will go back to using RGB LEDs. We will use five RGB LEDs that are wired so that
    we only need to use eight GPIO pins to control their red, green, and blue elements
    using a method called **hardware multiplexing** (see the *Hardware multiplexing*
    subsection in the *There's more...* section of this recipe).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的下一个示例演示了一些看似简单的硬件如果通过软件控制可以产生一些令人印象深刻的结果。为此，我们将回到使用RGB LED。我们将使用五个RGB LED，这些LED被布线，以便我们只需要使用八个GPIO引脚来控制它们的红色、绿色和蓝色元素，使用一种称为**硬件多路复用**的方法（请参阅本食谱的*硬件多路复用*子部分中的*更多信息*部分）。
- en: Getting ready
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need the RGB LED module shown in the following picture:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要以下图片中显示的RGB LED模块：
- en: '![](Images/f240314f-3d20-4e18-839d-b4bea49a7025.png)The RGB LED module from
    PiHardware.com'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/f240314f-3d20-4e18-839d-b4bea49a7025.png)PiHardware.com的RGB LED模块'
- en: As you can see in the preceding photo, the RGB LED module from [http://pihardware.com/](http://pihardware.com/) comes
    with GPIO pins and a DuPont female-to-female cable for connecting it. Although
    there are two sets of pins labelled from 1 to 5, only one side needs to be connected.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上面的照片中所看到的，来自[http://pihardware.com/](http://pihardware.com/)的RGB LED模块带有GPIO引脚和杜邦母对母电缆用于连接。虽然有两组从1到5标记的引脚，但只需要连接一侧。
- en: 'Alternatively, you can recreate your own with the following circuit using five
    common cathode RGB LEDs, 3 x 470 ohm resistors, and a Vero prototype board (or
    large breadboard). The circuit will look as shown in the following diagram:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用五个共阳极RGB LED、3个470欧姆电阻和一个Vero原型板（或大型面包板）来重新创建自己的电路。电路将如下图所示：
- en: '![](Images/2e014247-64dd-4885-a536-b51c3b1454b0.png)Circuit diagram for the
    RGB LED moduleStrictly speaking, we should use 15 resistors in this circuit (one
    for each RGB LED element), which will avoid interference from LEDs sharing the
    same resistor, and will also prolong the life of the LEDs themselves if switched
    on together. However, there is only a slight advantage in using this, particularly
    since we intend to drive each RGB LED independently of the other four to achieve
    multi-color effects.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/2e014247-64dd-4885-a536-b51c3b1454b0.png)RGB LED模块的电路图严格来说，我们应该在这个电路中使用15个电阻（每个RGB
    LED元件一个），这样可以避免LED共用同一个电阻的干扰，并且在一起开启时也会延长LED的寿命。然而，使用这种方法只有轻微的优势，特别是因为我们打算独立驱动每个RGB
    LED，以实现多种颜色效果。'
- en: 'You will need to connect the circuit to the Raspberry Pi GPIO header as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将电路连接到树莓派GPIO引脚头，连接方式如下：
- en: '| **RGB LED** |  |  |  |  |  | 1 |  | 2 | 3 |  | 4 |  |  |  |  |  |  |  |  |  |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| **RGB LED** |  |  |  |  |  | 1 |  | 2 | 3 |  | 4 |  |  |  |  |  |  |  |  |  |'
- en: '| **Rpi GPIO pin** | 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 | 20 | 22 | 24
    | 26 | 28 | 30 | 32 | 34 | 36 | 38 | 40 |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| **Rpi GPIO引脚** | 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 | 20 | 22 | 24 |
    26 | 28 | 30 | 32 | 34 | 36 | 38 | 40 |'
- en: '| **Rpi GPIO pin** | 1 | 3 | 5 | 7 | 9 | 11 | 13 | 15 | 17 | 19 | 21 | 23 |
    25 | 27 | 29 | 31 | 33 | 35 | 37 | 39 |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| **Rpi GPIO引脚** | 1 | 3 | 5 | 7 | 9 | 11 | 13 | 15 | 17 | 19 | 21 | 23 | 25
    | 27 | 29 | 31 | 33 | 35 | 37 | 39 |'
- en: '| **RGB LED** |  |  |  | 5 |  | R | G | B |  |  |  |  |  |  |  |  |  |  |  |  |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| **RGB LED** |  |  |  | 5 |  | R | G | B |  |  |  |  |  |  |  |  |  |  |  |  |'
- en: How to do it...
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create the `rgbled.py` script and perform the following steps:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`rgbled.py`脚本，并执行以下步骤：
- en: 'Import all the required modules and define the values to be used with the help
    of the following code:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '导入所有所需的模块，并使用以下代码定义要使用的值： '
- en: '[PRE28]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Define functions to set up the GPIO pins using the following code:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义使用以下代码设置GPIO引脚的函数：
- en: '[PRE29]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Define our utility functions to help control the LEDs using the following code:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码定义我们的实用程序函数来帮助控制LED：
- en: '[PRE30]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a test function to demonstrate the functionality of the module:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试函数来演示模块的功能：
- en: '[PRE31]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To start with, we define the hardware setup by defining the states required
    to **Enable** and **Disable** the LED depending on the type of RGB LED (common
    cathode) used. If you are using a common anode device, just reverse the **Enable**
    and **Disable** states.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过定义所需的状态来定义硬件设置，以便根据使用的RGB LED（共阳极）的类型来**启用**和**禁用**LED。如果您使用的是共阳极设备，只需颠倒**启用**和**禁用**状态。
- en: Next, we define the GPIO mapping to the pins to match the wiring we did previously.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义GPIO映射到引脚，以匹配我们之前进行的接线。
- en: 'We also define some basic color combinations by combining red, green, and/or
    blue together, as shown in the following diagram:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过组合红色、绿色和/或蓝色来定义一些基本的颜色组合，如下图所示：
- en: '![](Images/7e1997f5-945b-402a-8cfe-8be0de9ea29d.png)LED color combinations'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/7e1997f5-945b-402a-8cfe-8be0de9ea29d.png)LED颜色组合'
- en: We define a series of useful functions, the first being `led_setup()`, which
    will set the GPIO numbering to `GPIO.BOARD` and define all the pins that are to
    be used as outputs. We also call a function named `led_clear()`, which will set
    the pins to the default state with all the pins disabled.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一系列有用的函数，首先是`led_setup()`，它将把GPIO编号设置为`GPIO.BOARD`，并定义所有要用作输出的引脚。我们还调用一个名为`led_clear()`的函数，它将把引脚设置为默认状态，所有引脚都被禁用。
- en: This means that the LED pins, 1-5 (the common cathode on each LED), are set
    to `HIGH`, while the RGB pins (the separate anodes for each color) are set to
    `LOW`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着LED引脚1-5（每个LED的共阳极）被设置为`HIGH`，而RGB引脚（每种颜色的单独阳极）被设置为`LOW`。
- en: We create a function called `led_gpiocontrol()` that will allow us to set the
    state of one or more pins. The `isinstance()` function allows us to test a value
    to see whether it matches a particular type (in this case, a single integer);
    then we can either set the state of that single pin or iterate through the list
    of pins and set each one.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个名为`led_gpiocontrol()`的函数，它将允许我们设置一个或多个引脚的状态。`isinstance()`函数允许我们测试一个值，看它是否匹配特定类型（在本例中是单个整数）；然后我们可以设置单个引脚的状态，或者遍历引脚列表并设置每个引脚的状态。
- en: Next, we define two functions, `led_activate()` and `led_deactivate()`, which
    will enable and disable the specified LED and color. Finally, we define `led_time()`,
    which will allow us to specify an LED, color, and time to switch it on for.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义两个函数，`led_activate()`和`led_deactivate()`，它们将启用和禁用指定的LED和颜色。最后，我们定义`led_time()`，它将允许我们指定LED、颜色和开启时间。
- en: We also create `led_cleanup()` to reset the pins (and LEDs) to the default values
    and call `GPIO.cleanup()` to release the GPIO pins in use.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建`led_cleanup()`来将引脚（和LED）重置为默认值，并调用`GPIO.cleanup()`来释放正在使用的GPIO引脚。
- en: 'This script is intended to become a library file, so we will use the `if __name__==''__main__''`
    check to only run our test code when running the file directly:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本旨在成为一个库文件，因此我们将使用`if __name__=='__main__'`检查，只有在直接运行文件时才运行我们的测试代码：
- en: By checking the value of `__name__`, we can determine whether the file was run
    directly (it will equal `__main__`) or whether it was imported by another Python
    script.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查`__name__`的值，我们可以确定文件是直接运行的（它将等于`__main__`），还是被另一个Python脚本导入的。
- en: This allows us to define a special test code that is only executed when we directly
    load and run the file. If we include this file as a module in another script,
    then this code will not be executed.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够定义一个特殊的测试代码，只有在直接加载和运行文件时才执行。如果我们将此文件作为另一个脚本中的模块包含，那么此代码将不会被执行。
- en: As before, we will use `try`/`finally` to allow us to always perform cleanup
    actions, even if we exit early.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们将使用`try`/`finally`来允许我们始终执行清理操作，即使我们提前退出。
- en: To test the script, we will set the LEDs to light up in various colors, one
    after another.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试脚本，我们将设置LED依次以各种颜色点亮。
- en: There's more...
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can create a few different colors by switching on one or more parts of the
    RGB LED at a time. However, with some clever programming, we can create a whole
    spectrum of colors. Also, we can display different colors on each LED, seemingly
    at the same time.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一次打开RGB LED的一个或多个部分来创建几种不同的颜色。然而，通过一些巧妙的编程，我们可以创建整个颜色谱。此外，我们可以似乎同时在每个LED上显示不同的颜色。
- en: Hardware multiplexing
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件复用
- en: An LED requires a high voltage on the anode side and a lower voltage on the
    cathode side in order to light up. The RGB LEDs used in the circuit are common
    cathodes, so we must apply a high voltage (3V3) on the RGB pins and a low voltage
    (0V) on the cathode pin (wired to pins 1 to 5 for each of the LEDs).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: LED需要在阳极侧施加高电压，在阴极侧施加低电压才能点亮。电路中使用的RGB LED是共阳极的，因此我们必须在RGB引脚上施加高电压（3V3），在阴极引脚上施加低电压（0V）（分别连接到每个LED的1到5引脚）。
- en: 'The cathode and RGB pin states are as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 阴极和RGB引脚状态如下：
- en: '![](Images/c3aaca65-07d4-4d44-b773-91f3cb7f242f.png)Cathode and RGB pin states'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/c3aaca65-07d4-4d44-b773-91f3cb7f242f.png)阴极和RGB引脚状态'
- en: Therefore, we can enable one or more of the RGB pins, but still control which
    of the LEDs are lit. We enable the pins of the LEDs we want to light up and disable
    the ones we don't. This allows us to use far fewer pins than we would need to
    control each of the 15 RGB lines separately.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以启用一个或多个RGB引脚，但仍然控制点亮哪个LED。我们启用我们想要点亮的LED的引脚，并禁用我们不想点亮的引脚。这使我们可以使用比控制每个RGB线需要的引脚少得多的引脚。
- en: Displaying random patterns
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示随机图案
- en: 'We can add new functions to our library to produce different effects, such
    as generating random colors. The following function uses `randint()` to get a
    value between 1 and the number of colors. We ignore any values that are over the
    number of the available colors so that we can control how often the LEDs are switched
    off. Perform the following steps to add the required functions:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向我们的库中添加新的函数以产生不同的效果，例如生成随机颜色。以下函数使用`randint()`来获取1到颜色数量之间的值。我们忽略任何超出可用颜色数量的值，以便我们可以控制LED关闭的频率。执行以下步骤以添加所需的函数：
- en: 'Add the `randint()` function from the `random` module to the `rgbled.py` script
    using the following code:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码将`random`模块中的`randint()`函数添加到`rgbled.py`脚本中：
- en: '[PRE32]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now add `led_rgbrandom()` using the following code:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用以下代码添加`led_rgbrandom()`：
- en: '[PRE33]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Use the following commands in the `main()` function to create a series of
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中使用以下命令创建一系列
- en: 'flashing LEDs:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 闪烁LED：
- en: '[PRE34]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Mixing multiple colors
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合多种颜色
- en: Until now, we have only displayed a single color at a time on one or more of
    the LEDs. If you consider how the circuit is wired up, you might wonder how we
    can get one LED to display one color and another a different one at the same time.
    The simple answer is that we don't need to-we just do it quickly!
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在一个或多个LED上一次显示一种颜色。如果考虑电路的接线方式，您可能会想知道我们如何让一个LED同时显示一种颜色，而另一个显示不同的颜色。简单的答案是我们不需要-我们只是快速地做到这一点！
- en: 'All we need to do is display one color at a time, but change it back and forth,
    so quickly that the color looks like a mix of the two (or even a combination of
    the three red/green/blue LEDs). Fortunately, this is something that computers
    such as the Raspberry Pi can do very easily, even allowing us to combine the RGB
    elements to make multiple shades of colors across all five LEDs. Perform the following
    steps to mix the colors:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需要做的就是一次显示一种颜色，但来回变换，变换得如此之快，以至于颜色看起来像两种颜色的混合（甚至是三种红/绿/蓝LED的组合）。幸运的是，树莓派等计算机可以很容易地做到这一点，甚至允许我们组合RGB元素以在所有五个LED上制作多种颜色。执行以下步骤来混合颜色：
- en: 'Add combo color definitions to the top of the `rgbled.py` script, after the
    definition of the mixed colors, using the following code:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`rgbled.py`脚本的顶部添加组合颜色定义，在混合颜色的定义之后，使用以下代码：
- en: '[PRE35]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding code will provide the combination of colors needed to create our
    shades, with `RGB_COLORS` providing a smooth progression through the shades.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将提供创建我们所需的颜色组合，`RGB_COLORS`提供了对颜色的平滑过渡。
- en: 'Next, we need to create a function called `led_combo()` to handle single or
    multiple colors. The code for the function will be as follows:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个名为`led_combo()`的函数来处理单个或多个颜色。该函数的代码如下：
- en: '[PRE36]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we can create a new script, `rgbledrainbow.py`, to make use of the new
    functions in our `rgbled.py` module. The `rgbledrainbow.py` script will be as
    follows:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个新的脚本`rgbledrainbow.py`，以利用我们`rgbled.py`模块中的新功能。`rgbledrainbow.py`脚本将如下所示：
- en: '[PRE37]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `main()` function will first cycle through the LEDs, setting each color
    from the `RGB_COLORS` array on all the LEDs. Then, it will cycle through the colors,
    creating a rainbow effect across the LEDs:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数将首先循环遍历LED，将`RGB_COLORS`数组中的每种颜色设置在所有LED上。然后，它将循环遍历颜色，在LED上创建彩虹效果：'
- en: '![](Images/2709e07f-71c2-43ff-b175-3bc84d4e4c45.png)Cycling through multiple
    colors on the five RGB LEDs'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/2709e07f-71c2-43ff-b175-3bc84d4e4c45.png)在五个RGB LED上循环显示多种颜色'
- en: Writing messages using persistence of vision
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用视觉持久性编写消息
- en: '**Persistence of vision** (**POV**) displays can produce an almost magical
    effect, displaying images in the air by moving a line of LEDs back and forth very
    quickly or around in circles. The effect works because your eyes are unable to
    adjust fast enough to separate out the individual flashes of light, and so you
    observe a merged image (the message or picture being displayed):'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**视觉持续性**（**POV**）显示可以产生一种几乎神奇的效果，通过快速来回移动一行LED或在圆圈中移动LED来在空中显示图像。这种效果的原理是因为您的眼睛无法调整得足够快，以分离出单独的闪光，因此您观察到一个合并的图像（显示的消息或图片）：'
- en: '![](Images/221d8d87-7773-4f9b-91eb-d4d610adade4.png)Persistence of vision using
    RGB LEDs'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](Images/221d8d87-7773-4f9b-91eb-d4d610adade4.png)使用RGB LED的视觉持续性
- en: Getting ready
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe uses the RGB LED kit used in the previous recipe; you will also
    need the following additional items:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方使用了前一个配方中使用的RGB LED套件；您还需要以下额外的物品：
- en: Breadboard (half-sized or larger)
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板（半尺寸或更大）
- en: 2 x DuPont female-to-male patch wires
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x DuPont母对公跳线
- en: Tilt switch (the ball-bearing type is suitable)
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 倾斜开关（适合滚珠类型）
- en: 1 x 470 ohm resistor (R_Protect)
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x 470欧姆电阻（R_Protect）
- en: Breadboard wire (solid core)
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板线（实心线）
- en: 'The tilt switch should be added to the RGB LED (as described in the *Getting
    ready* section of the *Multiplexed color LEDs* recipe). The tilt switch is wired
    as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 倾斜开关应添加到RGB LED（如*准备工作*部分的*多路复用彩色LED*配方中所述）。倾斜开关的接线如下：
- en: '![](Images/60548e93-3f4c-411f-9f5a-76df3d0b07d4.png)The tilt switch is connected
    to GPIO Input (GPIO pin 24) and Gnd (GPIO pin 6)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: ！[](Images/60548e93-3f4c-411f-9f5a-76df3d0b07d4.png)倾斜开关连接到GPIO输入（GPIO引脚24）和Gnd（GPIO引脚6）
- en: 'To reproduce the POV image, you will need to be able to quickly move the LEDs
    and tilt the switch back and forth. Note how the tilt switch is mounted angled
    to the side, so the switch will open when moved to the left. It is recommended
    that the hardware is mounted onto a length of wood or similar piece of equipment.
    You can even use a portable USB battery pack along with a Wi-Fi dongle to power
    and control the Raspberry Pi through a remote connection (see the *Connecting
    Remotely to the Raspberry Pi over the Network using SSH (and X11 forwarding) recipe
    in *Chapter 1, *Getting Started with a Raspberry Pi 3 Computer*, for details):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重现POV图像，您需要能够快速移动LED并来回倾斜开关。请注意倾斜开关安装在侧面倾斜，因此当向左移动时开关将打开。建议将硬件安装在一根木头或类似设备上。您甚至可以使用便携式USB电池组和Wi-Fi
    dongle来通过远程连接为树莓派供电和控制（有关详细信息，请参见*第1章*中的*通过网络远程连接树莓派使用SSH（和X11转发）*配方）：
- en: '![](Images/dd5c1ecb-a851-40a1-b565-38d5f70b6666.png)Persistence of vision hardware
    setup'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](Images/dd5c1ecb-a851-40a1-b565-38d5f70b6666.png)持续视觉硬件设置
- en: You will also need the completed `rgbled.py` file, which we will extend further
    in the *How to do it*... section.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要已完成的`rgbled.py`文件，我们将在*如何操作*...部分进一步扩展它。
- en: How to do it...
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a script called `tilt.py` to report the state of the tilt switch:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`tilt.py`的脚本来报告倾斜开关的状态：
- en: '[PRE38]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can test the script by running it directly with the following command:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过直接运行以下命令来测试脚本：
- en: '[PRE39]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add the following `rgbled_pov()` function to the `rgbled.py` script we created
    previously; this will allow us to display a single line of our image:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`rgbled_pov()`函数添加到我们之前创建的`rgbled.py`脚本中；这将允许我们显示图像的单行：
- en: '[PRE40]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will now create the following file, called `rgbledmessage.py`, to perform
    the required actions to display our message. First, we will import the modules
    used: the updated `rgbled` module, the new `tilt` module, and the Python `os`
    module. Initially, we set `DEBUG` to `True`, so the Python terminal will display
    additional information while the script is running:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建以下文件，名为`rgbledmessage.py`，以执行显示我们的消息所需的操作。首先，我们将导入所使用的模块：更新的`rgbled`模块，新的`tilt`模块和Python
    `os`模块。最初，我们将`DEBUG`设置为`True`，这样Python终端在脚本运行时将显示额外的信息：
- en: '[PRE41]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add a `readMessageFile()` function to read the content of the `letters.txt`
    file and then add `processFileContent()` to generate a **Python dictionary** of
    the LED patterns for each letter:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`readMessageFile()`函数来读取`letters.txt`文件的内容，然后添加`processFileContent()`来为每个字母生成一个LED模式的**Python字典**：
- en: '[PRE42]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add a `createBuffer()` function, which will convert a message into a series
    of LED patterns for each letter (assuming the letter is defined by the `letters.txt`
    file):'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`createBuffer()`函数，它将把消息转换为每个字母的LED模式系列（假设该字母由`letters.txt`文件定义）：
- en: '[PRE43]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we define a `displayBuffer()` function to display the LED patterns using
    the `rgbled_pov()` function in the `rgbled` module:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`displayBuffer()`函数，使用`rgbled`模块中的`rgbled_pov()`函数来显示LED模式：
- en: '[PRE44]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we create a `main()` function to perform each of the required steps:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个`main()`函数来执行所需的每个步骤：
- en: Set up the hardware components (RGB LEDs and the tilt switch).
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置硬件组件（RGB LED和倾斜开关）。
- en: Read the `letters.txt` file.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读`letters.txt`文件。
- en: Define the dictionary of LED letter patterns.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义LED字母模式的字典。
- en: Generate a buffer to represent the required message.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个缓冲区来表示所需的消息。
- en: 'Display the buffer using the `rgbled` module and control it with the `tilt`
    module:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`rgbled`模块显示缓冲区，并使用`tilt`模块进行控制：
- en: '[PRE45]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create the following file, called `letters.txt`, to define the LED patterns
    needed to display the example `''_COOKBOOK_''` message. Note that this file only
    needs to define a pattern for each unique letter or symbol in the message:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下文件，名为`letters.txt`，以定义显示示例`'_COOKBOOK_'`消息所需的LED模式。请注意，此文件只需要为消息中的每个唯一字母或符号定义一个模式：
- en: '[PRE46]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The first function, `readMessageFile()`, will open and read the contents of
    a given file. This will then use `processFileContent()` to return a Python dictionary
    containing the corresponding patterns for the letters defined in the file provided.
    Each line in the file is processed, ignoring any line containing a `#` character
    and checking for `"` characters to indicate the name of the LED pattern that follows
    after. After the file has been processed, we end up with a Python dictionary that
    contains LED patterns for the `''_''`, `''C''`, `''B''`, `''K''`, and `''O''`
    characters:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数“readMessageFile（）”将打开并读取给定文件的内容。然后使用“processFileContent（）”返回一个包含文件中定义的字母对应的LED图案的Python字典。处理文件时，会处理文件中的每一行，忽略包含“＃”字符的任何行，并检查“”字符以指示接下来的LED图案的名称。处理文件后，我们得到一个包含LED图案的Python字典，其中包含“'_'”、“'C'”、“'B'”、“'K'”和“'O'”字符。
- en: '[PRE47]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now that we have a selection of letters to choose from, we can create a sequence
    of LED patterns using the `createBuffer()` function. As the name suggests, the
    function will build up a buffer of LED patterns by looking up each letter in the
    message and adding the related pattern row by row. If a letter isn't found in
    the dictionary, then a space will be used instead.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一系列可供选择的字母，我们可以使用“createBuffer（）”函数创建LED图案序列。正如其名称所示，该函数将通过查找消息中的每个字母并逐行添加相关的图案来构建LED图案的缓冲区。如果在字典中找不到字母，则将使用空格代替。
- en: 'Finally, we now have a list of LED patterns ready to display. To control when
    we start the sequence, we will use the TILT module and check the status of the
    tilt switch:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们现在有一系列准备显示的LED图案。为了控制我们何时开始序列，我们将使用TILT模块并检查倾斜开关的状态：
- en: '![](Images/4ef4e458-9ff9-4541-ada9-c2a44883485b.png)The tilt switch position
    when not moving (left) and moving (right)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: 当倾斜开关不移动时的位置（左）和移动时的位置（右）
- en: 'The tilt switch consists of a small ball bearing enclosed in a hollow, insulated
    cylinder; the connection between the two pins is closed when the ball is resting
    at the bottom of the cylinder. The tilt switch is open when the ball is moved
    to the other end of the cylinder, out of contact of the pins:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 倾斜开关由一个小滚珠封闭在一个空心绝缘圆柱体中组成；当球静止在圆柱体底部时，两个引脚之间的连接闭合。当球移动到圆柱体的另一端，远离引脚的接触时，倾斜开关打开：
- en: '![](Images/4019aa2d-ac1f-4e3d-a52a-9f27c1ceb08b.jpg)The tilt switch circuit
    with the switch closed and with the switch open'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 倾斜开关电路，开关闭合和开关打开时
- en: The tilt switch circuit shown previously will allow GPIO pin 24 to be connected
    to the ground when the switch is closed. Then, if we read the pin, it will return
    `False` when it is at rest. By setting the GPIO pin as an input and enabling the
    internal pull-up resistor, when the tilt switch is open, it will report `True`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 先前显示的倾斜开关电路将在开关闭合时将GPIO引脚24连接到地。然后，如果我们读取引脚，当它静止时将返回“False”。通过将GPIO引脚设置为输入并启用内部上拉电阻，当倾斜开关打开时，它将报告“True”。
- en: 'If the tilt switch is open (reporting `True`), then we will assume the unit
    is being moved and begin displaying the LED sequences, incrementing the current
    position each time we display a row of the LED pattern. Just to make the pattern
    a little more colorful (just because we can!) we repeat each row in another color.
    As soon as the `TILT.tilt_moving()` function reports that we have stopped moving
    or that we are moving in the opposite direction, we will reset the current position,
    ready to start the whole pattern all over again:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果倾斜开关是打开的（报告“True”），那么我们将假设单位正在移动，并开始显示LED序列，每次显示LED图案的一行时递增当前位置。为了使图案更加丰富多彩（只是因为我们可以！），我们会用另一种颜色重复每一行。一旦“TILT.tilt_moving（）”函数报告我们已经停止移动或者我们正在向相反方向移动，我们将重置当前位置，准备重新开始整个图案：
- en: '![](Images/198791cb-60b0-4dcf-8f12-6438943efa7e.png)The message is displayed
    by the RGB LEDs - here, we are using green and blue together'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 消息由RGB LED显示 - 在这里，我们一起使用绿色和蓝色
- en: When the RGB LED module and tilt switch are moved back and forth, we should
    see the message displayed in the air!
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当RGB LED模块和倾斜开关来回移动时，我们应该看到消息在空中显示！
- en: Try experimenting with different color combinations, speeds, and arm waviness
    to see what effects you can produce. You could even create a similar setup mounted
    on a wheel to produce a continuous POV effect.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试尝试不同的颜色组合、速度和手臂挥动，看看你能产生什么效果。你甚至可以创建一个类似的设置，安装在车轮上，产生连续的POV效果。

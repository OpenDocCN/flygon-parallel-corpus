- en: Sensing and Displaying Real-World Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using devices with the I²C bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading analog data using an analog-to-digital converter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging and plotting data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the Raspberry Pi GPIO with an I/O expander
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing data in an SQLite database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing data from your own web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sensing and sending data to online services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to collect analog data from the real world
    and process it so we can display, log, graph, and share the data and make use
    of it in our programs.
  prefs: []
  type: TYPE_NORMAL
- en: We will extend the capabilities of the Raspberry Pi by interfacing with **analog-to-digital
    converters** (**ADCs**), LCD alphanumeric displays, and digital port expanders
    using Raspberry Pi's GPIO connections.
  prefs: []
  type: TYPE_NORMAL
- en: Using devices with the I2C bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Raspberry Pi can support several higher-level protocols that a wide range of
    devices can easily be connected to. In this chapter, we shall focus on the most
    common bus, called **I-squared-C** (**I²C**). It provides a medium-speed bus for
    communicating with devices over two wires. In this section, we shall use I²C to
    interface with an 8-bit ADC. This device will measure an analog signal, convert
    it to a relative value between 0 and 255, and send the value as a digital signal
    (represented by 8-bits) over the I²C bus to the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of I²C can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Maintains a low pin/signal count, even with numerous devices on the bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapts to the needs of different slave devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readily supports multiple masters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporates ACK/NACK functionality for improved error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The I²C bus is not enabled in all Raspberry Pi images; therefore, we need to
    enable the module and install some supporting tools. Newer versions of Raspbian
    use **device trees** to handle hardware peripherals and drivers.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make use of the I²C bus, we need to enable the ARM I²C in the `bootconfig.txt`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this automatically using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Select Advanced Options from the menu and then select I²C, as shown in the
    following screenshot. When asked, select Yes to enable the interface and then
    click Yes to load the module by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/de619297-5684-41b7-8733-887b49dc9185.png)The raspi-config menu'
  prefs: []
  type: TYPE_NORMAL
- en: From the menu, select I2C and select Yes to enable the interface and to load
    the module by default.
  prefs: []
  type: TYPE_NORMAL
- en: The `raspi-config` program enables the `I2C_ARM` interface by altering `/boot/config.txt`
    to include `dtparam=i2c_arm=on`. The other bus (I2C_VC) is typically reserved
    for interfacing with Raspberry Pi HAT add-on boards (to read the configuration
    information from the on-board memory devices); however, you can enable this using
    `dtparam=i2c_vc=on`.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish, you can also enable the SPI using the `raspi-config` list, which
    is another type of bus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we should include the I²C module to be loaded upon turning the Raspberry
    Pi on, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following on separate lines and save (*Ctrl* + *X*, *Y*, *Enter*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we can also enable the SPI module by adding `spi-bcm2708`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will install some tools to use I²C devices directly from the command
    line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, shut down the Raspberry Pi before attaching the hardware in order
    to allow the changes to be applied, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need a PCF8591 module (retailers of these are listed in the Appendix, *Hardware
    and Software List*) or you can obtain the PCF8591 chip separately and build your
    own circuit (see the *There''s more...* section for details on the circuit):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/41781e79-5740-4a5f-a202-14e498aae716.png)The PCF8591 ADC and sensor
    module from dx.com'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the GND, VCC, SDA, and SCL pins to the Raspberry Pi GPIO header as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e4093aac-4d52-4588-8bbf-7e2bb556d812.png)I2C connections on the
    Raspberry Pi GPIO headerYou can use the same I²C tools/code with other I²C devices
    by studying the datasheet of the device to find out what messages to send/read
    and which registers are used to control your device.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `i2cdetect` command is used to detect the I²C devices (the `--y` option
    skips any warnings about possible interference with other hardware that could
    be connected to the I²C bus). The following commands are used to scan both the
    buses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on your Raspberry Pi board revision, the address of the device should
    be listed on bus 0 (for Model B Rev1 boards) or bus 1 (for Raspberry Pi 2 and
    3, and Raspberry Pi 1 Model A and Model B Revision 2). By default, the PCF8591
    address is `0x48`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **I²C bus number to use** | **Bus 00** | **Bus 11** |'
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi 2 and 3 | HAT ID (I2C_VC) | GPIO (I2C_ARM) |'
  prefs: []
  type: TYPE_TB
- en: '| Model A and Model B Revision 2 | P5 | GPIO |'
  prefs: []
  type: TYPE_TB
- en: '| Model B Revision 1 | GPIO | N/A |'
  prefs: []
  type: TYPE_TB
- en: 'The following screenshot shows the output of `i2cdetect`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/987cdc05-6091-4931-be83-02cbe8e5871f.png)The PCF8591 address (48)
    is displayed here on bus 1'
  prefs: []
  type: TYPE_NORMAL
- en: If nothing is listed, shut down and double-check your connections (the ADC module
    from [www.dx.com](http://www.dx.com/) will switch on a red LED when powered).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you receive an error stating that the `/dev/i2c1` bus doesn''t exist, you
    can perform the following checks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that the `/etc/modprobe.d/raspi-blacklist.conf` file is empty (that
    is, that the modules haven''t been blacklisted), using the following command to
    view the file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`           sudo nano /etc/modprobe.d/raspi-blacklist.conf`'
  prefs: []
  type: TYPE_NORMAL
- en: If there is anything in the file (such as `blacklist i2c-bcm2708`), remove it
    and save
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check `/boot/config` and ensure there isn't a line that contains `device_tree_param=`
    (this will disable support for the new device tree configurations and disable
    support for some Raspberry Pi HAT add-on boards)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether the modules have been loaded by using `lsmod` and look for `i2c-bcm2708`
    and `i2c_dev`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the detected bus number (`0` or `1`) and the device address (`0x48`),
    use `i2cget` to read from the device (after a power up or channel change, you
    will need to read the device twice to see the latest value), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To read from channel `1` (this is the temperature sensor on the module), we
    can use `i2cset` to write `0x01` to the PCF8591 control register. Again, use two
    reads to get a new sample from channel `1`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To cycle through each of the input channels, use `i2cset` to set the control
    register to `0x04`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also control the AOUT pin using the following command to set it fully
    on (lighting up the LED D1):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use the following command to set it fully off (switching off
    the LED D1):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first read from the device after it has been switched on will return `0x80`
    and will also trigger the new sample from channel 0\. If you read it a second
    time, it will return the sample previously read and generate a fresh sample. Each
    reading will be an 8-bit value (ranging from `0` to `255`), representing the voltage
    to VCC (in this case, 0 V to 3.3 V). On the [www.dx.com](http://www.dx.com) module,
    channel 0 is connected to a light sensor, so if you cover up the module with your
    hand and resend the command, you will observe a change in the values (darker means
    a higher value and lighter means a lower one). You will find that the readings
    are always one behind; this is because, as it returns the previous sample, it
    captures the next sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the following command to specify a particular channel to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This changes the channel that is read to channel 1 (this is marked as **AIN1**
    on the module). Remember, you will need to perform two reads before you see data
    from the newly selected channel. The following table shows the channels and pin
    names, as well as which jumper connectors enable/disable each of the sensors:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Channel** | **0** | **1** | **2** | **3** |'
  prefs: []
  type: TYPE_TB
- en: '| Pin Name | AIN0 | AIN1 | AIN2 | AIN3 |'
  prefs: []
  type: TYPE_TB
- en: '| Sensor | Light-Dependent Resistor | Thermistor | External Pin | Potentiometer
    |'
  prefs: []
  type: TYPE_TB
- en: '| Jumper | P5 | P4 |  | P6 |'
  prefs: []
  type: TYPE_TB
- en: 'Next, we control the AOUT pin by setting the analog output enable flag (bit
    6) of the control register and using the next value to set the analog voltage
    (0V-3.3V, 0x00-0xFF), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can set bit 2 (`0x04`) to auto increment and cycle through the
    input channels as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Each time you run `i2cget -y 1 0x48`, the next channel will be selected, starting
    with channel AIN0, then running from AIN1 through to AIN3 and back to AIN0 again.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how to set a particular bit in a value, it helps to look at the
    binary representation of the number. The 8-bit value `0x04` can be written as
    `b0000 0100` in binary (`0x` indicates the value is written in hexadecimal, or
    hex, and b indicates a binary number).
  prefs: []
  type: TYPE_NORMAL
- en: Bits within binary numbers are counted from right to left, starting with 0 -
    that is, MSB 7 6 5 4 3 2 1 0 LSB.
  prefs: []
  type: TYPE_NORMAL
- en: Bit 7 is known as the **most significant bit** (**MSB**) and bit 0 is known
    as the **least significant bit** (**LSB**). Therefore, by setting bit 2, we end
    up with `b0000 0100` (which is `0x04`).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The I²C bus allows us to easily connect multiple devices using only a few wires.
    The PCF8591 chip can be used to connect your own sensors to the module or just
    the chip.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple I2C devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All commands on the I²C bus are addressed to a specific I²C device (many have
    the option to set some pins high or low to select additional addresses and allow
    multiple devices to exist on the same bus). Each device must have a unique address
    so that only one device will respond at any one time. The PCF8591 starting address
    is `0x48`, with additional addresses selectable by the three address pins to `0x4F`.
    This allows up to eight PCF8591 devices to be used on the same bus.
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to use the I2C_VC bus that is located on GPIO pins 27 and 2828
    (or on the P5 header on Model A and Revision 2 Model B devices), you may need
    to add a 1k8 ohm pull-up resistor between the I²C lines and 3.3 V. These resistors
    are already present on the I²C bus on the GPIO connector. However, some I²C modules,
    including the PCF8591 module, have their own resistors fitted, so it will work
    without the extra resistors.
  prefs: []
  type: TYPE_NORMAL
- en: I2C bus and level shifting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The I²C bus consists of two wires, one data (SDA), and one clock (SCL). Both
    are passively pulled to VCC (on the Raspberry Pi, this is 3.3 V) with pull-up
    resistors. The Raspberry Pi will control the clock by pulling it low every cycle
    and the data line can be pulled low by Raspberry Pi to send commands or by the
    connected device to respond with data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/11df565b-2693-41b3-a66f-6bd9b04650f1.png)The Raspberry Pi I²C pins
    include pull-up resistors on SDA and SCL'
  prefs: []
  type: TYPE_NORMAL
- en: Since the slave devices can only pull the data line to **GND**, the device may
    be powered by 3.3 V or even 5 V without the risk of driving the GPIO pins too
    high (remember that the Raspberry Pi GPIO is not able to handle voltages over
    3.3 V). This should work as long as the I²C bus of the device can recognize the
    logic maximum a 3.3 V rather than 5 V. The I²C device must not have its own pull-up
    resistors fitted, as this will cause the GPIO pins to be pulled to the supply
    voltage of the I²C device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the PCF8591 module used in this chapter has resistors fitted; therefore,
    we must only use **VCC = 3V3**. A bidirectional logic level converter can be used
    to overcome any issues with logic levels. One such device is the **Adafruit**
    I²C bidirectional logic level translator module, which is shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/56cec6a4-4017-44e6-a92f-0c7477a90691.png)Adafruit I²C Bidirectional
    logic level translator module'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to ensuring that any logic voltages are at suitable levels for the
    device you are using, it will allow the bus to be extended over longer wires (the
    level shifter will also act as a bus repeater).
  prefs: []
  type: TYPE_NORMAL
- en: Using just the PCF8591 chip or adding alternative sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A circuit diagram of the PCF8591 module without the sensors attached is shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/74186137-d1fd-441d-ae48-799f6c5ef883.png)Circuit diagram of the
    PCF8591 module without sensor attachment'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, excluding the sensors, there are only five additional components.
    We have a power-filtering capacitor (C1) and a power-indicating LED (D2) with
    a current-limiting resistor (R5), all of which are optional.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the module includes two 10K pull-up resistors (R8 and R9) for SCL
    and SDA signals. However, since the GPIO I²C connections on the Raspberry Pi also
    include pull-up resistors, these are not needed on the module (and could be removed).
    It also means we should only connect this module to VCC = 3.3 V (if we use 5 V,
    then voltages on SCL and SDA will be around 3.56 V, which is too high for the
    Raspberry Pi GPIO pins).
  prefs: []
  type: TYPE_NORMAL
- en: 'The sensors on the PCF891 module are all resistive, so the voltage level that
    is present on the analog input will change between **GND** and **VCC** as the
    resistance of the sensor changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c955d053-69ec-4060-a84d-a776759f5e74.png)A potential divider circuit.
    This provides voltage proportional to the sensor''s resistance.'
  prefs: []
  type: TYPE_NORMAL
- en: The module uses a circuit known as a potential divider. The resistor at the
    top balances the resistance provided by the sensor at the bottom to provide a
    voltage that is somewhere between **VCC** and **GND.**
  prefs: []
  type: TYPE_NORMAL
- en: 'The output voltage (*V[out]*) of the potential divider can be calculated as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f5739d01-f1d4-4ce7-b689-dbd73ca2705b.png)'
  prefs: []
  type: TYPE_IMG
- en: R[t] and R[b] are the resistance values at the top and bottom, respectively,
    and VCC is the supply voltage.
  prefs: []
  type: TYPE_NORMAL
- en: The potentiometer in the module has the 10K ohm resistance split between the
    top and bottom, depending on the position of the adjuster. So, halfway, we have
    5K ohm on each side and an output voltage of 1.65 V; a quarter of the way (clockwise),
    we have 2.5K ohm and 7.5K ohm, producing 0.825 V.
  prefs: []
  type: TYPE_NORMAL
- en: I haven't shown the AOUT circuit, which is a resistor and LED. However, as you
    will find, an LED isn't suited to indicate an analog output (except to show the
    on/off states).
  prefs: []
  type: TYPE_NORMAL
- en: For more sensitive circuits, you can use more complex circuits, such as a **Wheatstone
    bridge** (which allows the detection of very small changes in resistance), or
    you can use dedicated sensors that output an analog voltage based on their readings
    (such as a **TMP36** temperature sensor). The PCF891 also supports the differential
    input mode, where the input of one channel can be compared to the input of another
    (the resultant reading will be the difference between the two).
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the PCF8591 chip, refer to the datasheet at [http://www.nxp.com/documents/data_sheet/PCF8591.pdf](http://www.nxp.com/documents/data_sheet/PCF8591.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Reading analog data using an analog-to-digital converter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The I²C tools (used in the previous section) are very useful for debugging I²C
    devices in the command line, but they are not practical for use within Python,
    as they would be slow and require significant overhead to use. Fortunately, there
    are several Python libraries that provide I²C support, allowing the efficient
    use of I²C to communicate with connected devices and providing easy operation.
  prefs: []
  type: TYPE_NORMAL
- en: We will use such a library to create our own Python module that will allow us
    to quickly and easily obtain data from the ADC device and use it in our programs.
    The module is designed in such a way that other hardware or data sources may be
    put in its place without impacting the remaining examples.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use the I²C bus using Python 3, we will use *Gordon Henderson's* WiringPi2
    (see [http://wiringpi.com/](http://wiringpi.com/) for more details).
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to install `wiringpi2` is by using `pip` for Python 3\. The `pip`
    is a package manager for Python that works in a similar way to `apt-get`. Any
    packages you wish to install will be automatically downloaded and installed from
    an online repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `pip`, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, install `wiringpi2` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation has completed, you should see the following, indicating
    success:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e0d4f643-b6ce-4174-8a8c-023b23a47d99.png)Successfully installed
    WiringPi2'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need the PCF8591 module wired as it was previously used in the I²C
    connections of the Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c3aa40b6-c765-446b-b1d2-7941f47ea5df.png)The PCF8591 module and
    pin connections to the Raspberry Pi GPIO connector'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next section, we shall write a script to allow us to gather data that
    we will then use later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following script, `data_adc.py`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the modules and create the variables we will use, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `device` class with a constructor to initialize it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the class, define a function to provide a list of channel names, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Define another function (still as part of the class) to return a new set of
    samples from the ADC channels, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, after the device class, create a test function to exercise our new
    `device` class, as follows. This is only to be run when the script is executed
    directly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the test function of this module using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start by importing `wiringpi2` so we can communicate with our I²C device
    later on. We will create a class to contain the required functionality to control
    the ADC. When we create the class, we can initialize `wiringpi2` in such a way
    that it is ready to use the I²C bus (using `wiringpi2.I2C()`), and we will set
    up a generic I²C device with the chip's bus address (using `self.i2c.setup(0x48)`).
  prefs: []
  type: TYPE_NORMAL
- en: '`wiringpi2` also has a dedicated class to use with the PCF8591 chip; however,
    in this case, it is more useful to use the standard I²C functionality to illustrate
    how any I²C device can be controlled using `wiringpi2`. By referring to the device
    datasheet, you can use similar commands to communicate to any connected I²C device
    (whether it is directly supported or not).'
  prefs: []
  type: TYPE_NORMAL
- en: As before, we perform a device read and configure the ADC to cycle through the
    channels, but instead of `i2cget` and `i2cset`, we use the `wiringpi2` read and
    write functions of the `I2C` object. Once initialized, the device will be ready
    to read the analog signals on each of the channels.
  prefs: []
  type: TYPE_NORMAL
- en: The class will also have two member functions. The first function, `getName()`,
    returns a list of channel names (which we can use to correlate our data to its
    source) and the second function, `getNew()`, returns a new set of data from all
    the channels. The data is read from the ADC using the `i2c.read()` function, and
    since we have already put it into cycle mode, each read will be from the next
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: As we plan to reuse this class later on, we will use the `if __name__` test
    to allow us to define a code to run when we execute the file directly. Within
    our `main()` function, we create the ADC, which is an instance of our new device
    class. We can choose to select a non-default address if we need to; otherwise,
    the default address for the chip will be used. We use the `getName()` function
    to print out the names of the channels and then we can collect data from the `ADC`
    (using `getNew()`) and display them.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following allows us to define an alternative version of the device class
    in `data_adc.py` so it can be used in place of the ADC module. This will allow
    the remaining sections of the chapter to be tried without needing any specific
    hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering analog data without hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you don't have an ADC module available, there is a wealth of data available
    from within Raspberry Pi that you can use instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `data_local.py` script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding script allows us to gather system information from the Raspberry
    Pi using the following commands (the `subprocess` module allows us to capture
    the results and process them):'
  prefs: []
  type: TYPE_NORMAL
- en: 'CPU speed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'CPU load:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Core temperature (scaled by 1,000):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Drive info:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'RAM info:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Each data item is sampled using one of the functions. In the case of the drive
    and RAM information, we split the response into a list (separated by spaces) and
    select the items that we want to monitor (such as available memory and used drive
    space).
  prefs: []
  type: TYPE_NORMAL
- en: This is all packaged up to function in the same way as the `data_adc.py` file
    and the `device` class (so you can choose to use either in the following examples
    just by swapping the `data_adc` include with `data_local`).
  prefs: []
  type: TYPE_NORMAL
- en: Logging and plotting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are able to sample and collect a lot of data, it is important that
    we can capture and analyze it. For this, we will make use of a Python library
    called `matplotlib`, which includes lots of useful tools for manipulating, graphing,
    and analyzing data. We will use `pyplot` (which is a part of `matplotlib`) to
    produce graphs of our captured data. For more information on `pyplot`, go to [http://matplotlib.org/users/pyplot_tutorial.html](http://matplotlib.org/users/pyplot_tutorial.html).
  prefs: []
  type: TYPE_NORMAL
- en: It is a MATLAB-style data visualization framework for Python.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use `pyplot`, we will need to install `matplotlib`.
  prefs: []
  type: TYPE_NORMAL
- en: Because of a problem with the `matplotlib` installer, performing the installation
    using `pip-3.2` doesn't always work correctly. The method that follows will overcome
    this problem by performing all the steps `pip` does manually; however, this can
    take over 30 minutes to complete.
  prefs: []
  type: TYPE_NORMAL
- en: To save time, you can try the `pip` installation, which is much quicker. If
    it doesn't work, you can install it using the aforementioned manual method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following commands to try to install `matplotlib` using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`  sudo apt-get install tk-dev python3-tk libpng-dev`'
  prefs: []
  type: TYPE_NORMAL
- en: '`  sudo pip-3.2 install numpy`'
  prefs: []
  type: TYPE_NORMAL
- en: '`  sudo pip-3.2 install matplotlib`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can confirm that `matplotlib` has been installed by running `python3` and
    trying to import it from the Python Terminal, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If the installation fails, it will respond with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`  ImportError: No module named matplotlib`'
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, there will be no errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following steps to install `matplotlib` manually:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the support packages as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Download the source files from the Git repository (the command should be a
    single line) as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Unzip and open the `matplotlib-master` folder that is created, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the setup file to build (this will take a while) and install it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Test the installation in the same way as the automated install.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will either need the PCF8591 ADC module (and `wiringpi2`, installed as before),
    or we can use the `data_local.py` module from the previous section (just replace
    `data_adc` with `data_local` in the import section of the script). We also need
    to have `data_adc.py` and `data_local.py` in the same directory as the new script,
    depending on which you use.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a script called `log_adc.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a second script called `log_graph.py`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first script, `log_adc.py`, allows us to collect data and write it to a
    log file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the ADC device by importing `data_adc` as the `dataDevice`, or we
    can import `data_local` to use the system data. The numbers given to `VAL0` through
    `VAL3` allow us to change the order of the channels (and, if using the `data_local`
    device, select the other channels). We can also define the format string for the
    header and each line in the log file (to create a file with data separated by
    tabs) using `%s`, `%d`, and `%f` to allow us to substitute strings, integers,
    and float values, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dc5e9dc1-c3b0-43e5-be73-bcce7a60ad1d.png)The table of data captured
    from the ADC sensor module'
  prefs: []
  type: TYPE_NORMAL
- en: When logging in to the file (when `FILE=True`), we open `data.log` in write
    mode using the `'w'` option (this will overwrite any existing files; to append
    to a file, use `'a'`).
  prefs: []
  type: TYPE_NORMAL
- en: As part of our data log, we generate `timestamp` using `time` and `datetime`
    to get the current **epoch time** (this is the number of milliseconds since January
    1, 1970) using the `time.time()` command. We convert the value into a more friendly
    `year-month-day hour:min:sec` format using `strftime()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` function starts by creating an instance of our `device` class (we
    made this in the previous example), which will supply the data. We fetch the channel
    names from the `data` device and construct the `header` string. If `DEBUG` is
    set to `True`, the data is printed to the screen; if `FILE` is set to `True`,
    it will be written to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main loop, we use the `getNew()` function of the device to collect data
    and format it to display on the screen or be logged to the file. The `main()`
    function is called using the `try: finally:` command, which will ensure that when
    the script is aborted, the file will be closed correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second script, `log_graph.py`, allows us to read the log file and produce
    a graph of the recorded data, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ec2f4f51-eed4-46d3-8679-b60c386d6df6.png)Graphs produced by log_graph.py
    from the light and temperature sensors'
  prefs: []
  type: TYPE_NORMAL
- en: We start by opening up the log file and reading the first line; this contains
    the header information (which we can then use to identify the data later on).
    Next, we use `numpy`, a specialist Python library that extends how we can manipulate
    data and numbers. In this case, we use it to read in the data from the file, split
    it up based on the tab delimiter, and provide identifiers for each of the data
    channels.
  prefs: []
  type: TYPE_NORMAL
- en: We define a figure to hold our graphs, adding two subplots (located in a 2 x
    1 grid at positions 1 and 2 in the grid - set by the values `211` and `212`).
    Next, we define the values we want to plot, providing the `x` values (`data['sample']`),
    the `y` values (`data['DATA0']`), the `color` value (`'r'` for `Red` or `'b'`
    for `Blue`), and `label` (set to the heading text we read previously from the
    top of the file).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set a title and the `x` and `y` labels for each subplot, enable
    legends (to show the labels), and display the plot (using `plt.show()`).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the ability to see the data we have been capturing, we can
    take things even further by displaying it as we sample it. This will allow us
    to instantly see how the data reacts to changes in the environment or stimuli.
    We can also calibrate our data so that we can assign the appropriate scaling to
    produce measurements in real units.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting live data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides plotting data from files, we can use `matplotlib` to plot sensor data
    as it is sampled. To achieve this, we can use the `plot-animation` feature, which
    automatically calls a function to collect new data and update our plot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following script, called `live_graph.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining our `dataDevice` object and creating an empty array, `dispdata[]`,
    which will hold all the data which has been collected. Next, we define our subplot
    and the line we are going to plot.
  prefs: []
  type: TYPE_NORMAL
- en: The `FuncAnimation()` function allows us to update a figure (`fig`) by defining
    an update function and a generator function. The generator function (`data_gen()`)
    will be called every interval (1,000 ms) and will produce a data value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example uses the core temperature reading that, when divided by 1,000,
    gives the actual temperature in `degC`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the ADC data instead, change the import for `dataDevice` to `data_adc`
    and adjust the following line to use a channel other than `[1]` and apply a scaling
    that is different from 1,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '`yield myData.getNew()[1]/1000`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f4dabe2e-4897-4ffd-9f8d-d95e6260dee1.png)Raspberry Pi plotting in
    real time'
  prefs: []
  type: TYPE_NORMAL
- en: The data value is passed to the `update()` function, which allows us to add
    it to our `dispdata[]` array that will contain all the data values to be displayed
    in the plot. We adjust the *x* axis range to be near the `min` and `max` values
    of the data. We also adjust the *y* axis to grow as we continue to sample more
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The `FuncAnimation()` function requires the `data_gen()` object to be a special
    type of function called a `generator`. A `generator` function produces a continuous
    series of values each time it is called, and can even use its previous state to
    calculate the next value if required. This is used to perform continuous calculations
    for plotting; this is why it is used here. In our case, we just want to run the
    same sampling function (`new_data()`) continuously so that each time it is called,
    it will yield a new sample.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we update the *x* and *y* axes data with our `dispdata[]` array (using
    the `set_data()` function), which will plot our samples against the number of
    seconds we are sampling. To use other data, or to plot data from the ADC, adjust
    the import for `dataDevice` and select the required channel (and scaling) in the
    `data_gen()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling and calibrating data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that it can sometimes be difficult to interpret data read
    from an ADC, since the value is just a number. A number isn't much help on its
    own; all it can tell you is that the environment is slightly hotter or slightly
    darker than the previous sample. However, if you can use another device to provide
    comparable values (such as the current room temperature), you can then calibrate
    your sensor data to provide more useful real-world information.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain a rough calibration, we shall use two samples to create a linear
    fit model that can then be used to estimate real-world values for other ADC readings
    (this assumes the sensor itself is mostly linear in its response). The following
    diagram shows a linear fit graph using two readings at 25 and 30 degrees Celsius,
    providing estimated ADC values for other temperatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/47102c86-e5f9-4c4d-b4ac-f5f297865ded.png)Samples are used to linearly
    calibrate temperature sensor readings'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can calculate our model using the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This will return `cal`, which will contain the model slope (`A`) and offset
    (`C`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use the following function to calculate the value of any reading
    by using the calculated `cal` values for that channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: For more accuracy, you can take several samples and use linear interpolation
    between the values (or fit the data to other, more complex mathematical models),
    if required.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the Raspberry Pi GPIO with an I/O expander
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, making use of the higher-level bus protocols allows us to connect
    to more complex hardware quickly and easily. The I²C can be put to great use by
    using it to expand the available I/O on the Raspberry Pi, as well as providing
    additional circuit protection (and, in some cases, additional power to drive more
    hardware).
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of devices available that provide I/O expansion over the I²C
    bus (and also SPI), but the most commonly used is a 28-pin device, MCP23017, which
    provides 16 additional digital input/output pins. Being an I²C device, it only
    requires the two signals (SCL and SDA connections, plus ground, and power) and
    will happily function with other I²C devices on the same bus.
  prefs: []
  type: TYPE_NORMAL
- en: We shall see how the Adafruit I²C 16x2 RGB LCD Pi Plate makes use of one of
    these chips to control an LCD alphanumeric display and keypad over the I²C bus
    (without the I/O expander, this would normally require up to 15 GPIO pins).
  prefs: []
  type: TYPE_NORMAL
- en: Boards from other manufacturers will also work. A 16x2 LCD module and I²C-to-serial
    interface module can be combined to have our own low cost I²C LCD module.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the Adafruit I²C 16x2 RGB LCD Pi Plate (which also includes five
    keypad buttons), shown in the following photo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ae827aa6-e260-42a8-a195-2a15b0ca1d68.png)Adafruit I²C 16x2 RGB LCD
    Pi Plate with keypad buttons'
  prefs: []
  type: TYPE_NORMAL
- en: The Adafruit I²C 16x2 RGB LCD Pi Plate directly connects to the GPIO connector
    of Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: As before, we can use the PCF8591 ADC module or use the `data_local.py` module
    from the previous section (use `data_adc` or `data_local` in the import section
    of the script). The `data_adc.py` and `data_local.py` files should be in the same
    directory as the new script.
  prefs: []
  type: TYPE_NORMAL
- en: The LCD Pi Plate only requires four pins (SDA, SCL, GND, and 5V); it connects
    over the whole GPIO header. If we want to use it with other devices, such as the
    PCF8591 ADC module, then something similar to a TriBorg from PiBorg (which splits
    the GPIO port into three) can be used to add ports.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the following script, called `lcd_i2c.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'With the LCD module connected, run the script as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Select the data channel you want to display using the left and right buttons
    and press the SELECT button to exit.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `wiringpi2` library has excellent support for I/O expander chips, like
    the one used for the Adafruit LCD character module. To use the Adafruit module,
    we need to set up the pin mapping for all the pins of MCP23017 Port A, as shown
    in the following table (then, we set up the I/O expander pins with an offset of
    `100`):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **SELECT** | **RIGHT** | **DOWN** | **UP** | **LEFT** | **GREEN**
    | **BLUE** | **RED** |'
  prefs: []
  type: TYPE_TB
- en: '| MCP23017 Port A | A0 | A1 | A2 | A3 | A4 | A6 | A7 | A8 |'
  prefs: []
  type: TYPE_TB
- en: '| WiringPi pin | 100 | 101 | 102 | 103 | 104 | 106 | 107 | 108 |'
  prefs: []
  type: TYPE_TB
- en: 'The pin mapping for all of MCP23017 Port B''s pins is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **DB7** | **DB6** | **DB5** | **DB4** | **E** | **RW** | **RS**
    |'
  prefs: []
  type: TYPE_TB
- en: '| MCP23017 Port B | B1 | B2 | B3 | B4 | B5 | B6 | B7 |'
  prefs: []
  type: TYPE_TB
- en: '| WiringPi pin | 109 | 110 | 111 | 112 | 113 | 114 | 115 |'
  prefs: []
  type: TYPE_TB
- en: To set up the LCD screen, we initialize `wiringPiSetup()` and the I/O expander,
    `mcp23017Setup()`. We then specify the pin offset and bus address of the I/O expander.
    Next, we set all the hardware buttons as inputs (using `pinMode(pin number,0)`),
    and the RW pin of the LCD to an output. The `wiringpi2` LCD library expects the
    RW pin to be set to `LOW` (forcing it into read-only mode), so we set the pin
    to `LOW` (using `digitalWrite(AF_RW,0)`).
  prefs: []
  type: TYPE_NORMAL
- en: We create an `lcd` object by defining the number of rows and columns of the
    screen and stating whether we are using a 4- or 8-bit data mode (we are using
    four of the eight data lines, so we will be using 4-bit mode). We also provide
    the pin mapping of the pins we are using (the last four are set to `0` since we
    are only using four data lines).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will create a function called `PrintLCD()`, which will allow us to send
    strings to show on each line of the display. We use `lcdPosition()` to set the
    cursor position on the `lcd` object for each line and then print the text for
    each line. We also add some blank spaces at the end of each line to ensure the
    full line is overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: The next function, `checkBtn()`, briefly checks the left/right and select buttons
    to see if they have been pressed (using the `digitalRead()` function). If the
    left/right button has been pressed, then the index is set to the previous/next
    item in the array. If the SELECT button is pressed, then the `run` flag is set
    to `False` (this will exit the main loop, allowing the script to finish).
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` function calls `gpiosetup()` to create our `lcd` object; then,
    we create our `dataDevice` object and fetch the data names. Within the main loop,
    we get new data; then, we use our `printLCD()` function to display the data name
    on the top line and the data value on the second line. Finally, we check to see
    whether the buttons have been pressed and set the index to our data as required.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using an expander chip such as the MCP23017 provides an excellent way to increase
    the amount of hardware connectivity to the Raspberry Pi while also providing an
    additional layer of protection (it is cheaper to replace the expander chip Raspberry
    Pi).
  prefs: []
  type: TYPE_NORMAL
- en: I/O expander voltages and limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The port expander only uses a small amount of power when in use, but if you
    are powering it using the 3.3 V supply, then you will still only be able to draw
    a maximum of 50 mA in total from all the pins. If you draw too much power, then
    you may experience system freezes or corrupted read/writes on the SD card.
  prefs: []
  type: TYPE_NORMAL
- en: If you power the expander using the 5V supply, then you can draw up to the maximum
    power the expander can support (around a maximum of 25 mA per pin and 125 mA in
    total), as long as your USB power supply is powerful enough.
  prefs: []
  type: TYPE_NORMAL
- en: We must remember that if the expander is powered with a 5 V supply, the inputs/outputs
    and interrupt lines will also be 5 V and should never be connected back to the
    Raspberry Pi (without using level shifters to translate the voltage down to 3.3
    V).
  prefs: []
  type: TYPE_NORMAL
- en: 'By changing the wiring of the address pins (A0, A1, and A2) on the expander
    chip, up to eight modules can be used on the same I²C bus simultaneously. To ensure
    there is enough current available for each, we would need to use a separate 3.3
    V supply. A linear regulator such as LM1117-3.3 would be suitable (this would
    provide up to 800 mA at 3.3 V, 100 mA for each), and only needs the following
    simple circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f17c86f4-937c-42b6-a2b7-9bbe74e089a4.png)The LM1117 linear voltage
    regulator circuit'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how a voltage regulator can be connected to the
    I/O expander (or other device) to provide more current for driving extra hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/596bf4cd-d3a3-4ac6-a961-c7aabfe61b8b.png)Using a voltage regulator
    with the Raspberry Pi'
  prefs: []
  type: TYPE_NORMAL
- en: The input voltage (Vin) is provided by the Raspberry Pi (for example, from the
    GPIO pin header, such as 5 V pin 2). However, Vin could be provided by any other
    power supply (or battery pack) as long as it is between 4.5 V and 15 V and is
    able to provide enough current. The important part is to ensure that the ground
    connections (GND) of the Raspberry Pi, the power supply (if a separate one is
    used), the regulator, and the I/O expander are all connected together (as a common
    ground).
  prefs: []
  type: TYPE_NORMAL
- en: Using your own I/O expander module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use one of the I/O expander modules that are available (or just the
    MCP23017 chip in the following circuit) to control most HD44780-compatible LCD
    displays:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/418d237b-b8ec-45b3-b519-48ac23a76624.png)The I/O expander and a
    HD44780-compatible display'
  prefs: []
  type: TYPE_NORMAL
- en: The D-Pad circuit, u*sing Python-to-drive hardware*, can also be connected to
    the remaining port A pins of the expander (`PA0` to button 1, `PA1` to right,
    `PA2` to down, `PA3` to up, `PA4` to left, and `PA5` to button 2). As in the previous
    example, the buttons will be `PA0` to `PA4` (WiringPi pin number 100 to 104);
    apart from these, we have the second button added to `PA5` (WiringPi pin number
    105).
  prefs: []
  type: TYPE_NORMAL
- en: Directly controlling an LCD alphanumeric display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Alternatively, you can also drive the screen directly from the Raspberry Pi
    with the following connections:'
  prefs: []
  type: TYPE_NORMAL
- en: We are not using the I²C bus here.
  prefs: []
  type: TYPE_NORMAL
- en: '| **LCD** | **VSS** | **VDD** | **V0** | **RS** | **RW** | **E** | **DB4**
    | **DB5** | **DB6** | **DB7** |'
  prefs: []
  type: TYPE_TB
- en: '| **LCD Pin** | 1 | 2 | 3 | 4 | 5 | 6 | 11 | 12 | 13 | 14 |'
  prefs: []
  type: TYPE_TB
- en: '| **Raspberry Pi GPIO** | 6 (GND) | 2 (5V) | Contrast | 11 | 13 (GND) | 15
    | 12 | 16 | 18 | 22 |'
  prefs: []
  type: TYPE_TB
- en: The preceding table lists the connections required between the Raspberry Pi
    and the HD44780-compatible, alphanumeric display module.
  prefs: []
  type: TYPE_NORMAL
- en: The contrast pin (V0) can be connected to a variable resistor as before (with
    one side connected to the 5 V supply and the other to GND); although, depending
    on the screen, you may find you can connect directly to GND/5 V to obtain the
    maximum contrast.
  prefs: []
  type: TYPE_NORMAL
- en: The `wiringpi2` LCD library assumes that the RW pin is connected to GND (read
    only); this avoids the risk that the LCD will send data back if it is connected
    directly to the Raspberry Pi (this would be a problem since the screen is powered
    by 5 V and will send data using 5 V logic).
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you update the code with the new `AF_XX` references and refer to
    the physical pin number by changing the setup within the `gpiosetup()` function.
    We can also skip the setup of the MCP23017 device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the preceding commands with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we only need to change the pin references to switch between
    using the I/O expander and not using it, which shows how convenient the `wiringpi2`
    implementation is.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing data in an SQLite database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Databases are a perfect way to store lots of structured data while maintaining
    the ability to access and search for specific data. **Structured Query Language**
    (**SQL**) is a standardized set of commands to update and query databases. For
    this example, we will use SQLite (a lightweight, self-contained implementation
    of an SQL database system).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will gather raw data from our ADC (or local data source)
    and build our own database. We can then use a Python library called `sqlite3`
    to add data to a database and then query it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To capture data in our database, we will install SQLite so that it is ready
    to be used with Python''s `sqlite3` built-in module. Use the following command
    to install SQLite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will perform some basic operations with SQLite to see how to use SQL
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run SQLite directly, creating a new `test.db` database file with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This will open an SQLite console, within which we enter SQL commands directly.
    For example, the following commands will create a new table, add some data, display
    the content, and then remove the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You will need the same hardware setup as the previous recipe, as detailed in
    the *Getting ready* section of the *Using devices with the I²C bus* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the following script, called `mysqlite_adc.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not have the ADC module hardware, you can capture local data by setting
    the `dataDevice` module as `data_local`. Ensure you have `data_local.py` (from
    the *There''s more...* section in the *Reading analog data using an analog-to-digital
    converter* recipe) in the same directory as the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import data_local as dataDevice`'
  prefs: []
  type: TYPE_NORMAL
- en: This will capture the local data (RAM, CPU activity, temperature, and so on)
    to the SQLite database instead of ADC samples.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the script is first run, it will create a new SQLite database file called
    `mydatabase.db`, which will add a table named `recordeddata`. The table is generated
    by `createTable()`, which runs the following SQLite command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The new table will contain the following data items:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `itm_date` | Used to store the date of the data sample. When the data record
    is created, the current date (using `date(''now'',''localtime'')`) is applied
    as the default value. |'
  prefs: []
  type: TYPE_TB
- en: '| `itm_time` | Used to store the time of the data sample. When the data record
    is created, the current time (using `time(''now'',''localtime'')`) is applied
    as the default value. |'
  prefs: []
  type: TYPE_TB
- en: '| `itm_name` | Used to record the name of the sample. |'
  prefs: []
  type: TYPE_TB
- en: '| `itm_value` | Used to keep the sampled value. |'
  prefs: []
  type: TYPE_TB
- en: 'We then use the same method to capture 10 data samples from the ADC as we did
    in the *Logging and plotting **data* recipe previously (as shown in the `captureSamples()`
    function). However, this time, we will then add the captured data into our new
    SQLite database table, using the following SQL command (applied using `cursor.execute(sqlquery)`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The current date and time will be added by default to each record as it is
    created. We end up with a set of 40 records (4 records for every cycle of ADC
    samples captured), which are now stored in the SQLite database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b1090b4d-96d0-4c69-85ba-45afc253bfb8.png)Eight ADC samples have
    been captured and stored in the SQLite database'
  prefs: []
  type: TYPE_NORMAL
- en: After the records have been created, we must remember to call `cursor.commit()`,
    which will save all the new records to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the script calls `displayAll()`, which will use the following
    SQL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This will select all of the data records in the `recordeddata` table, and we
    use `cursor.fetch()` to provide the selected data as a list we can iterate through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to print out the full contents of the database, displaying the
    captured data.
  prefs: []
  type: TYPE_NORMAL
- en: Note that here we use the `try`, `except`, and `finally` constructs in this
    script to attempt to handle the mostly likely scenario that users will face when
    running the script.
  prefs: []
  type: TYPE_NORMAL
- en: First, we ensure that if the database directory doesn't exist, we create it.
    Next, we try opening the database file; this process will automatically create
    a new database file if one doesn't already exist. If either of these initial steps
    fail (because they don't have read/write permissions, for example) we cannot continue,
    so we report that we cannot open the database and simply exit the script.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we try to open the required table within the database and display it.
    If the database file is brand new, this operation will always fail, as it will
    be empty. However, if this occurs, we just catch the exception and create the
    table before continuing with the script to add our sampled data to the table and
    display it.
  prefs: []
  type: TYPE_NORMAL
- en: This allows the script to gracefully handle potential problems, take corrective
    action, and then continue smoothly. The next time the script is run, the database
    and table will already exist, so we won't need to create them a second time, and
    we can append the sample data to the table within the same database file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many variants of SQL servers available (such as MySQL, Microsoft
    SQL Server, and PostgreSQL), however they should at least have the following primary
    commands (or equivalent):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You should find that even if you choose to use a different SQL server to the
    SQLite one used here, the SQL commands will be relatively similar.
  prefs: []
  type: TYPE_NORMAL
- en: The CREATE TABLE command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CREATE TABLE` command is used to define a new table by specifying the
    column names (and also to set default values, if desired):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The previous SQL command will create a new table called `table_name`, containing
    three data items. One column will contain text, other integers (for example, 1,
    3, -9), and finally, one column will contain real numbers (for example, 5.6, 3.1749,
    1.0).
  prefs: []
  type: TYPE_NORMAL
- en: The INSERT command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `INSERT` command will add a particular entry to a table in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This will enter the values provided into the corresponding columns in the table.
  prefs: []
  type: TYPE_NORMAL
- en: The SELECT command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `SELECT` command allows us to specify a particular column or columns from
    the database table, returning a list of records with the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also allow us to select all of the items, using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The WHERE command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `WHERE` command is used to specify specific entries to be selected, updated,
    or deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This will `SELECT` any records where the `column_name1` matches `'Terry Pratchett'`.
  prefs: []
  type: TYPE_NORMAL
- en: The UPDATE command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `UPDATE` command will allow us to change (`SET`) the values of data in
    each of the specified columns. We can also combine this with the `WHERE` command
    to limit the records the change is applied to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The DELETE command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DELETE` command allows any records selected using `WHERE` to be removed
    from the specified table. However, if the whole table is selected, using `DELETE
    * FROM table_name` will delete the entire contents of the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The DROP command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DROP` command allows a table to be removed completely from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Be warned that this will permanently remove all the data that was stored in
    the specified table and the structure.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing data from your own webserver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gathering and collecting information into databases is very helpful, but if
    it is locked inside a database or a file, it isn't of much use. However, if we
    allow the stored data to be viewed via a web page, it will be far more accessible;
    not only can we view the data from other devices, but we can also share it with
    others on the same network.
  prefs: []
  type: TYPE_NORMAL
- en: 'We shall create a local web server to query and display the captured SQLite
    data and allow it to be viewed through a PHP web interface. This will allow the
    data to be viewed, not only via the web browser on the Raspberry Pi, but also
    on other devices, such as cell phones or tablets, on the local network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0722af98-22cb-45da-b77e-f039fb491c8d.png)Data captured in the SQLite
    database displayed via a web page'
  prefs: []
  type: TYPE_NORMAL
- en: Using a web server to enter and display information is a powerful way to allow
    a wide range of users to interact with your projects. The following example demonstrates
    a web server setup that can be customized for a variety of uses.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensure you have completed the previous recipe so that the sensor data has been
    collected and stored in the SQLite database. We need to install a web server (**Apache2**)
    and enable PHP support to allow SQLite access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use these commands to install a web server and PHP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `/var/www/` directory is used by the web server; by default, it will load
    `index.html` (or `index.php`) – otherwise, it will just display a list of the
    links to the files within the directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether the web server is running, create a default `index.html` page.
    To do this, you will need to create the file using `sudo` permissions (the `/var/www/`
    directory is protected from changes made by normal users). Use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `index.html` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Close and save the file (using *Ctrl* + *X*, *Y* and *Enter*).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using the Raspberry Pi with a screen, you can check whether it is
    working by loading the desktop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open the web browser (**epiphany-browser**) and enter `http://localhost`
    as the address. You should see the following test page, indicating that the web
    server is active:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8e497ae9-d176-410b-ae38-0bfc5a9b6181.png)Raspberry Pi browser displaying
    the test page, located at http://localhost'
  prefs: []
  type: TYPE_NORMAL
- en: If you are using the Raspberry Pi remotely or it is connected to your network,
    you should also be able to view the page on another computer on your network.
    First, identify the IP address of the Raspberry Pi (using `sudo hostname -I`)
    and then use this as the address in your web browser. You may even find you can
    use the actual hostname of the Raspberry Pi (by default, this is `http://raspberrypi/`).
  prefs: []
  type: TYPE_NORMAL
- en: If you are unable to see the web page from another computer, ensure that you
    do not have a firewall enabled (on the computer itself, or on your router) that
    could be blocking it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can test that PHP is operating correctly. We can create a web page
    called `test.php`, and ensure that it is located in the `/var/www/ directory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The PHP web page to view the data in the SQLite database has the following
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5e5b4d29-1b48-400f-b29b-292129ae3652.png)Viewing the test.php page
    at http://localhost/test.php'
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to write our own PHP web page to view the data in the SQLite
    database.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create the following PHP files and save them in the web server directory named
    `/var/www/./`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following command to create the PHP file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `show_data_lite.php` file should contain the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to create the PHP file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for the PHP code to delete the table within the database, it needs
    to be writable by the web server. Use the following command to allow it to be
    writable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo chown www-data /var/databases/datasite -R`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `show_data_lite.php` file will appear as a web page if you open it in a
    web browser by using the following address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can open the web page (on another computer within your network,
    if you wish) by referencing the IP address of the Raspberry Pi (use `hostname
    -I` to confirm the IP address):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: You may be able to use the hostname instead (by default, this would make the
    address `http://raspberrypi/show_data_lite.php`). However, this may depend upon
    your network setup.
  prefs: []
  type: TYPE_NORMAL
- en: If there is no data present, ensure that you run the `mysqlite_adc.py` script
    to capture additional data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the `show_data_lite.php` page display automatically when you visit
    the web address of your Raspberry Pi (instead of the *It works!* page), we can
    change the `index.html` to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This will automatically redirect the browser to load our `show_data_lite.php`
    page.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `show_data_lite.php` file shall display the temperature data that has been
    stored within the SQLite database (either from the ADC samples or local data sources).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `show_data_lite.php` file consists of standard HTML code, as well as a
    special PHP code section. The HTML code sets `ACD Data` as the title on the head
    section of the page and uses the following command to make the page automatically
    reload every 10 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a `Delete` button, which will load the `del_data_lite.php`
    page when clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we use the PHP code section to load the SQLite database and display
    the Channel 0 data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the following PHP command to open the SQLite database we have previously
    stored data in (located at `/var/databases/testsites/mydatabase.db`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use the following SQLite query to select all the entries where the
    zone includes `0:` in the text (for example, `0:Light`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Note that even though we are now using PHP, the queries we use with the SQLite
    database are the same as we would use when using the `sqlite3` Python module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now collect the query result in the `$response` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The `del_data_lite.php` file is fairly similar; it starts by reopening the `mydatabase.db`
    file as before. It then executes the following SQLite query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: As described in the *There's more...* section, this will remove the `recordeddata`
    table from the database. If the `response` isn't equal to 1, the action was not
    completed. The most likely reason for this is that the directory that contains
    the `mydatabase.db` file isn't writable by the web server (see the note in the
    *How to do it...* section about changing the file owner to `www-data`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we provide another button that will take the user back to the `show_data_lite.php`
    page (which will show that the recorded data has now been cleared):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/30098cc2-0e88-427e-bb10-2b8e1445ca72.png)Show_data_lite.php'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that this recipe has focused more on HTML and PHP than
    Python (yes, check the cover – this is still a book for Python programmers!).
    However, it is important to remember that a key part of engineering is integrating
    and combining different technologies to produce the desired results.
  prefs: []
  type: TYPE_NORMAL
- en: By design, Python lends itself well to this kind of task since it allows easy
    customization and integration with a huge range of other languages and modules.
    We could just do it all in Python but why not make use of the existing solutions,
    instead? After all, they are usually well documented, have undergone extensive
    testing, and often meet industry standards.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL databases are used in many places to store a wide range of information,
    from product information to customer details. In such circumstances, users may
    be required to enter information that is then formed into SQL queries. In a poorly
    implemented system, a malicious user may be able to include additional SQL syntax
    in their response, allowing them to compromise the SQL database (perhaps by accessing
    sensitive information, altering it, or simply deleting it).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when asking for a username within a web page, the user could enter
    the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'If this was used directly to construct the SQL query, we would end up with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We have just allowed the attacker to delete everything in the `CurrentOrders`
    table!
  prefs: []
  type: TYPE_NORMAL
- en: Using user input to form part of SQL queries means we have to be careful what
    commands we allow to be executed. In this example, the user may be able to wipe
    out potentially important information, which could be very costly for a company
    and its reputation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique is called SQL injection, and is easily protected against by
    using the parameters option of the SQLite `execute()` function. We can replace
    our Python SQLite query with a safer version, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Instead of blindly building the SQL query, the SQLite module will first check
    that the provided parameters are valid values to enter into the database. Then,
    it will ensure that no additional SQL actions will result from inserting them
    into the command. Finally, the value of the `dataName` and `data[i]` parameters
    will be used to replace the `?` characters to generate the final safe SQLite query.
  prefs: []
  type: TYPE_NORMAL
- en: Using MySQL instead
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLite, which is used in this recipe, is just one of many SQL databases available.
    It is helpful for small projects that only require relatively small databases
    and minimal resources. However, for larger projects that require additional features
    (such as user accounts to control access and additional security), you can use
    alternatives, such as MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: To use a different SQL database, you will need to adjust the Python code that
    we used to capture the entries using a suitable Python module.
  prefs: []
  type: TYPE_NORMAL
- en: For MySQL (`mysql-server`), we can use a Python-3-compatible library called
    **PyMySQL** to interface with it. See the PyMySQL website ([https://github.com/PyMySQL/PyMySQL](https://github.com/PyMySQL/PyMySQL))
    for additional information about how to use this library.
  prefs: []
  type: TYPE_NORMAL
- en: To use PHP with MySQL, you will also need PHP MySQL (`php5-mysql`); for more
    information, see the excellent resource at W3 Schools ([http://www.w3schools.com/php/php_mysql_connect.asp](http://www.w3schools.com/php/php_mysql_connect.asp)).
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that although there are small differences between SQL implementations,
    the general concepts and commands should now be familiar to you, whichever one
    you select.
  prefs: []
  type: TYPE_NORMAL
- en: Sensing and sending data to online services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we shall make use of an online service called Xively. The service
    allows us to connect, transmit, and view data online. Xively makes use of a common
    protocol that is used for transferring information over HTTP called **REpresentational
    State Transfer** (**REST**). REST is used by many services, such as Facebook and
    Twitter, using various keys and access tokens to ensure data is transferred securely
    between authorized applications and verified sites.
  prefs: []
  type: TYPE_NORMAL
- en: You can perform most REST operations (methods such as `POST`, `GET`, `SET`,
    and so on) manually using a Python library called `requests` ([http://docs.python-requests.org](http://docs.python-requests.org)).
  prefs: []
  type: TYPE_NORMAL
- en: However, it is often easier to make use of specific libraries available for
    the service you intend to use. They will handle the authorization process and
    provide access functions, and if the service changes, the library can be updated
    rather than your code.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `xively-python` library, which provides Python functions to
    allow us to easily interact with the site.
  prefs: []
  type: TYPE_NORMAL
- en: For details about the `xively-python` library, refer to [http://xively.github.io/xively-python/](http://xively.github.io/xively-python/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The data collected by Xively is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e1e1b35d-5143-4696-94bb-89c7e335ec3d.png)Xively collects and graphs
    data transferred using REST'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need to create an account at [www.xively.com](http://www.xively.com),
    which we will use to receive our data. Go to the site and sign up for a free developer
    account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/171e04cc-7068-4787-8d92-52d677a2d662.png)Signing up and creating
    a Xively account'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have registered and verified your account, you can follow the instructions
    that will take you through a test drive example. This will demonstrate how you
    can link to data from your smartphone (gyroscopic data, location, and so on),
    which will give you a taste of what we can do with the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you log in, you will be taken to the Development Devices dashboard (located
    in the WebTools drop-down menu):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/56379efd-0385-4ae2-84ad-c91271596a48.png)Adding a new device'
  prefs: []
  type: TYPE_NORMAL
- en: Select +Add Device and fill in the details, giving your device a name and setting
    Device as Private.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will now see the control page for your remote device, which contains all
    the information you need to connect it and also where your data will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/201ad47f-347f-475a-8408-26c5b4b09e9f.png)Example API key and feed
    number (this will be unique for your device)'
  prefs: []
  type: TYPE_IMG
- en: 'Although there is a lot of information on this page, you only need two key
    pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The API key (which is the long code in the `API Keys` section), as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The feed number (referred to in the `API Keys` section and also listed at the
    top of the page), as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the details we need to connect with Xively, we can focus on
    the Raspberry Pi side of things.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use `pip-3.2` to install Xively, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that the following is reported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: You are now ready to send some data from your Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the following script, called `xivelyLog.py`. Ensure that you set `FEED_ID`
    and `API_KEY` within the code to match the device you created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we initialize the Xively API client, to which we supply the `API_KEY`
    (this authorizes us to send data to the `Xively` device we created previously).
    Next, we use `FEED_ID` to link us to the specific feed we want to send the data
    to. Finally, we request the data stream to connect to (if it doesn't already exist
    in the feed, the `get_datastream()` function will create one for us).
  prefs: []
  type: TYPE_NORMAL
- en: For each data stream in the feed, we supply a `name` function and `tags` (these
    are keywords that help us identify the data; we can use our data names for this).
  prefs: []
  type: TYPE_NORMAL
- en: Once we have defined our data streams, we enter the `main` loop. Here, we gather
    our data values from `dataDevice`. We then set the `current_value` function and
    also the timestamp of the data for each data item and apply them to our data stream
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when all the data is ready, we update each of the data streams and
    the data is sent to Xively, appearing within a few moments on the dashboard of
    the device.
  prefs: []
  type: TYPE_NORMAL
- en: We can log in to our Xively account and view data as it comes in, using a standard
    web browser. This provides the means to send data and remotely monitor it anywhere
    in the world (perhaps from several Raspberry Pis at once, if required). The service
    even supports the creation of triggers that can send additional messages back
    if certain items go out of expected ranges, reach specific values, or match set
    criteria. The triggers can, in turn, be used to control other devices or raise
    alerts, and so on. They can also be used in other platforms, such as ThingSpeak
    or plot.ly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AirPi Air Quality and Weather project ([http://airpi.es](http://airpi.es))
    shows you how to add your own sensors or use their AirPi kit to create your own
    air quality and weather station (with data logging to your own Xively account).
    The site also allows you to share your Xively data feeds with others around the
    world.
  prefs: []
  type: TYPE_NORMAL

- en: Making a Gardener Robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All right my friends, you have understood some of the basics of input and output;
    now it's the time to make something to which we can hand over some of our daily
    responsibilities. This robot might not really look like a robot, but trust me,
    it will make your life easier. Most of all the plants in your garden will be blessing
    you for making it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with solenoids
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making it more intelligent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making it truly intelligent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with solenoids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we are going to make is an automation system that will water your plants
    whenever they need it. So technically, once it is set up, you don't really have
    to worry ever about watering your green creatures. Whether you are at your home,
    at the office, or on a vacation, this will keep doing its job no matter what.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you must be wondering how it will water the plants, so let me tell you,
    for every problem in this world, there exists a solution. In our case, that solution
    is called a solenoid valve. What it essentially does is switch the flow of liquids.
    There are various solenoid valves available in the market; some of the identifying
    features are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Size**: They come in various sizes such as half an inch, three quarters of
    an inch, 1 inch, and so on. This basically will determine the flow rate of the
    solenoid valve.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Medium**: Whether it is meant for fluid, gas, vapor, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Normal condition**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Normally opened**: This valve will allow the flow of liquids in the off state—when
    no power is supplied to the valve'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Normally closed**: This valve will stop the flow of liquids in the off state—when
    no power is supplied to the valve'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Number of ways**: A simple valve will have an inlet and an outlet. So, when
    it is open, it will allow the liquid to flow from the inlet to the outlet. However,
    there can be other types of valve such as a three-way valve which might have two
    outlets and one inlet. It would regulate where the flow of the liquid would happen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There can be some more specifics in terms of the valves as well, but for now
    that's all we need to know. One thing to notice about the solenoid valve is that
    these valves can either be opened or closed. Achieving any state in between or
    controlling flow via these valves is not possible. For this we can use a servo
    valve or motor valve. But as of now, we don't need it.
  prefs: []
  type: TYPE_NORMAL
- en: What we will be using in this chapter is a half inch valve for water/fluid,
    which is normally closed. When you look closely at this valve you will see that
    it operates at 12 volts and the current consumption is close to 1 amp. This is
    a lot of current for Raspberry Pi. The upper limit of current that Raspberry Pi
    can provide per pin is about 50 milliamp. So if we connect this valve to Raspberry
    Pi then it's surely not going to work.
  prefs: []
  type: TYPE_NORMAL
- en: What do we do now? The answer to this question is a relay. The basic job of
    a relay is to re-lay the circuits. Basically, it's an electronically controlled
    switch. The basic job of a relay is to switch devices that have a higher current/voltage
    consumption than what can be given by a controlling unit on and off. This is a
    fairly simple device, as you can see in the diagram. There are two circuits. One
    is depicted in blue, which is a low voltage and low current circuit. This circuit
    is powering up a coil. The other circuit is depicted in red and black. This circuit
    is a high voltage, high current circuit.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the initial stages, as you can see, the high voltage high current circuit
    is not complete and the oven will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0045c276-12d5-466a-b712-5ae02a54e2e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, in this second diagram, you can see that the blue circuit is connected
    to the 5V power source and that the coil is energized. Whenever a coil gets energized,
    it forms an electromagnet and attracts the metal leaf of the high power circuit
    to make the circuit complete, hence powering up the oven:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/761c5221-8448-48a8-a7d4-3bd0e7711f4b.png)'
  prefs: []
  type: TYPE_IMG
- en: This is how a solenoid works. The consumption of the coil is hardly a few milliamps,
    hence it is very easy to actuate a coil via a micro-controller. This in turn makes
    a contact between the final circuit.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various kinds of relays available on the market; some of the identifying
    features are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Max output voltage**: The maximum voltage that it can handle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maximum output current**: The maximum current that it can bear for any output
    device connected to it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signal voltage**: The voltage that it requires switch the components on or
    off'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Normal condition**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Normal off**: This will not allow any current to flow until the time the
    signal is not received'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Normal on**: It will allow the current to flow until the time the signal
    is not received'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, coming back to our gardening robot, the solenoid attached to it will be
    working on 1 amp and 12V, so any relay which can supply equal to or more than
    1 amp and 12V would work.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly, the relays available on the market are 120V and 12 amp DC. One important
    thing to remember is that there will be two separate ratings for AC and DC voltage
    and current. As our solenoid will be working at 12V, we will only be considering
    the DC upper limit.
  prefs: []
  type: TYPE_NORMAL
- en: Making the robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s get down to making the robot. Firstly, you need to make the water
    connection from the tap to the solenoid and from the solenoid to the sprinkler.
    You also have to make the connection, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a2fe556c-551e-4c36-a0bd-eeafc2fcea3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s start programming. We will be interfacing a soil moisture sensor
    in this robot. The job of this sensor is to determine the amount of water in the
    soil. By determining this, we can understand if the garden needs water or not.
    This soil moisture sensor is an analogue sensor, hence we will be using an ADC
    to convert the analogue reading to Pi-understandable digital values. So let''s
    get going:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you run this code, let''s understand what it is actually doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`moisture_percentage = 20` is the percentage that will act as a threshold;
    if the moisture level in the soil becomes less than 20% then your garden needs
    water. It is this condition that your robot will keep looking for; once this condition
    is met then appropriate action can be taken. This percentage can also be changed
    to `30`, `40`, or any other value as per your garden''s needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The ADC is a 16-bit device—there are 16 binary digits that can represent a
    value. Hence, the value can be between `0` and `2^(15)` or, in other words, between
    `0` and `32768`. Now, it is simple math that for every percentage of moisture
    the ADC will give the following reading: `32768/100`, or `327.68`. Hence, to find
    out the percentage of moisture in the soil, we would have to divide the actual
    value given by the ADC by `327.68`.'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code is fairly simple and, once you go through it, it won't
    be very hard for you to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Making it more intelligent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations on making your first robot! But did you notice one problem?
    The robot we made was continuously looking for a moisture value and, as soon as
    it noticed that the moisture value was low, it suddenly pumped water and made
    sure that the humidity of the soil was always more than 20%. However, this is
    not required. In general, we water the garden once or twice a day. If we water
    it more then it might not be good for the plants.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's go ahead and make it slightly more intelligent and make it water the
    plants only when the moisture level is low at a certain time. This time, we won't
    need to make any changes to the hardware; we simply need to tweak the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and upload the following code, and then see what exactly happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This code might look a little alien to you, but trust me, it is as simple as
    it can get. Let''s see what''s happening step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This line of code is importing daytime instances from the date time library.
    This is a library which is by default in Python. All we need to do is to call
    it. Now, what it does is that without any hustle and bustle, it helps us determine
    the time within our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are several times when we have to do something over and over again. These
    sets of code can be a few repetitive lines or multiple pages of code. Hence, rewriting
    that code doesn't make sense at all. We can create a function. In this function,
    we can define what will happen whenever it is called. Here in this line, we have
    created a function by the name of `check_moisture()`; now, whenever this function
    is called within a program, there will be a set of activities that will be performed.
    The set of activities that will be performed is defined by the user. So, whenever
    we write `def`, then it means that we are defining a function; thereafter, we
    write the name of the function that needs to be defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once done, then whatever we write in the indentation following it will be done
    once the function is called. Do remember that whenever we call or define a function,
    it is denoted by an open and a closed `()` bracket at the end of the name of the
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`adc.get_last_result()` is a function of `adc`. The activity it does is to
    simply take the result from the pin defined earlier (pin number `0`) and fetch
    the reading to a variable `moisture_value`. So, after the line `moisture_value`
    will be the reading of the pin number `0` of the ADC or, in other words, the reading
    of the moisture sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The code `datetime` is an instance and a method of `.now()`. What this function
    does is that it updates the time. Now, the `date time.now()` has updated all the
    parameters of date and time which includes the hours, minutes, seconds, and even
    the date. It is up to us whether we want all of it or any specific part of the
    date and time. At present, we want to put the value of hours in the variable `H`,
    hence we are using a `.strftime(''%H'')` method. `strftime` stands for string
    format of time. So whatever value it outputs is in string format. `(''%H'') `
    means that it will give us the value of the hours only. Similarly, we can also
    get the time in minutes by using `(''%M'')` and `(''%S)`. We can also get the
    value of the date, month, and year with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: For getting the date:  `('%d')`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For getting the month: `('%m')`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For getting the year:  `('%Y')`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding condition, we are checking if the time is 7 o'clock or not;
    further, we are also checking if the time is less than or equal to 10 minutes
    or not. So this piece of code will only run the statement in the `if` statement
    when the time is `7` hours and between `0` and `10` minutes.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to particularly note is that we have used an `and` between both the
    conditions, hence it will only run the code inside it once both the statements
    are absolutely true. There are some other statements we can use inside it, as
    well, such as `or`, in which case it will run the code if either of the statements
    is true.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we replace `and` with `or` in this `if` statement, then it will run the
    code for every 0 to 10 minutes of every hour and will run the code continuously
    for the entire time between 7:00 a.m. and 7:59 a.m.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you may remember, previously we defined a function by the name of `check_moisture()`.
    While defining that function, we had also defined the set of activities that would
    happen every time this function is called.
  prefs: []
  type: TYPE_NORMAL
- en: Now is the time to call that function. As soon as the program reaches this end
    of the code, it will execute the set of activities that was earlier defined in
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: So there we have it. Now, as soon as you run this code, it will wait for the
    time defined by you in the program. Once the specific time has been reached, then
    it will check for the moisture. If the moisture is less than the set value then
    it will start to water the plants until the time the moisture reaches above that
    threshold.
  prefs: []
  type: TYPE_NORMAL
- en: Making it truly intelligent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazing work! We have started building things that are smarter than us by ourselves.
    But now we want to take it a step further and make it even smarter than us—that's
    what robots are here for. Not only to do what we do but to do all that in a better
    way.
  prefs: []
  type: TYPE_NORMAL
- en: So, what can we improve? Well, we do not require a lot of water on a chilly
    winter day, but when it's summertime we need way more than what we drink in winter.
    The same thing happens with plants as well.
  prefs: []
  type: TYPE_NORMAL
- en: In winter, the amount of water they need is way less. Furthermore, even the
    rate of evaporation of water in the soil is slower. Hence, in both the conditions,
    we need to supply varying amounts of water to the garden. The question is, how
    do we do that?
  prefs: []
  type: TYPE_NORMAL
- en: Well, firstly, to know if it's hot or cold outside we require a sensor. We will
    be using a sensor named DHT11\. It is a cheap yet robust sensor that gives us
    the readings of both the temperature and humidity. The best part is, it is super
    cheap at a rate of around $2.
  prefs: []
  type: TYPE_NORMAL
- en: It has four pins. But if you presume that it will work to I2C protocols, then
    you would be wrong. It has its own data transfer methodology. It is good to have
    one single protocol for all the sensors, but often you will also find that there
    are various sensors or devices which work on a different or an altogether new
    protocol. DHT11 is one such sensor. In this case, we have the choice of either
    understanding the entire methodology of communication or to simply get the library
    from the manufacturer and use it at our disposal. At present we will be opting
    for the latter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see what the pins of the DHT11 look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ca6928e6-75fe-41ad-b639-20471e708ddb.png)'
  prefs: []
  type: TYPE_IMG
- en: What you can see here is that there is only one signal pin which will do all
    the communication digitally. There are two pins for power and one of the pin is
    not in use. I.e. there is no significant purpose of the pin. It might be there
    just for soldering or for future use. This sensor works on a 5V supply and only
    needs a few milliamps, hence we can simply power it up by using Raspberry Pi.
    Now, for the data communication, we will connect the signal pin to GPIO pin number
    `4`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start writing the code, let's first install the libraries for the
    communication between DHT11 and Raspberry Pi. We have done this before with the
    library of ADS1115, but in this one there are a few little tricks that we need
    to take care of. So let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we need to make sure that the operating system of your Raspberry Pi
    is up to date. So connect Raspberry Pi to the internet, open the command prompt
    in Raspberry Pi, and type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will update the raspbian OS of your Raspberry Pi automatically. Then
    go ahead and type in this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this command, we are installing the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build-essential`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`python-dev`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`python-openssl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must be wondering why we are installing all of these. Well, to cut a long
    story short, these are the dependencies for the library that we are about to install
    for the communication of DHT11\. We will not be able to use the library if these
    packages are not installed on Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have to install the library; this is a generic library in which
    the function of communicating with the DHT11 sensor is also available. This should
    suffice for our needs of easy communication. Here is the command to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'All right then, we are good to go. Our system is ready to talk to DHT11\. Let''s
    first just see if what we have done up until now works the way we want. To do
    that, connect the DHT11 as follows; you can leave the rest of the components such
    as the solenoid and the soil humidity sensor connected as they are. They should
    not interfere. Now upload the the following code in Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you upload this code, you will see readings of the sensor on your screen.
    This code is simply providing you with the raw readings of the sensor. This code
    is super simple and everything written here will be well understood by you, except
    for a few lines of the code, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this line of the code, we are importing the `Adafruit_DHT` library in our
    code. This is the same library that will be used to communicate with the DHT11
    sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There are different versions of DHT available, such as DHT11, DHT22, and so
    on. We need to tell the program which sensor we are using. Hence, we have allotted
    a value to the variable sensor. Later, you will see how we will be using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this line, we are assigning the value `4` to a variable called `pin`. This
    variable will be used to tell the program on which pin of the Raspberry Pi we
    have connected the DHT11:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this line, we are using a method of the `Adafruit` library named `Adafruit_DHT.read_retry()`.
    Now, what this does is that it reads the DHT sensor and gives the reading of the
    sensor to the variables `humidity` and `temperature`. One thing to note is that
    the DHT11 gives a reading which is updated every 2 seconds. Hence, the readings
    that you will be receiving will be refresh after every 2 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this code is through, then we can be sure that the sensor is working the
    way we want. Finally, the time has come to integrate all of the sensors together
    and make an entirely intelligent robot. As the solenoid, humidity sensor, and
    temperature sensors are already connected, all we need to do is to upload the
    code over to Pi and see the magic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Pretty long code, right? It might look so, but once you write it line by line,
    you will certainly understand that it might be longer than all the code we have
    written so far, but it''s anything but complex. You might have understood most
    of the program, however let me explain a few new things that we have used here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this line, we are defining a function named `check_moisture()`. Previously,
    if you remember, while we were making the function `check_moisture`, we were basically
    checking if the moisture value was either more or less than 20%. What if we have
    to check the moisture for 30%, 40%, and 50%? Would we make a separate function
    for that?
  prefs: []
  type: TYPE_NORMAL
- en: Obviously not! What we do is we pass an argument to the function,  an argument
    is basically a variable placed within the brackets of the function. Now we can
    assign values to this variable for, for example, `check_moisture(30)`—now the
    value of the `m` will be `30` during the time that function is executing. Then
    again, if you call it as `check_moisture(40)` then the value of that `m` would
    be `40`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as you can see, we are comparing values of `m` throughout the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement will be checking the value of the `m` which is assigned while
    calling the function. This makes our job very easy and simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what the rest of the program is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time the desired time is reached it will go ahead and check for the temperature.
    If the temperature is less than `15` it will call the function `check_moisture `
    with the value of the argument as `20`. Hence, if the moisture is less than 20%,
    then the water will be fed to the garden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `elif` or the `else if` statement is used after an `if` statement. This
    in common words means that if the previous `if` statement is not true, then it
    will check for this `if` statement. So, in the preceding line it will check if
    the temperature is between `15` and `28` degrees Celsius. If that is true, then
    it will check the moisture of the soil. The argument to the function is `30` in
    this line. Hence, it will check if the moisture is less than `30`. If so, then
    it will supply the water to the garden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, in this line of code we are checking the temperature, and if it is
    equal to or more than `28` degrees Celsius then it will pass the value `40` as
    an argument to the function `check_moisture`. Hence this time it will check for
    moisture if it is `28` or more than that.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, now the system will be checking the ambient temperature and,
    based on that, the amount of water to the plants is regulated. The best part is
    that it is consistent and will provide the right amount of water needed by the
    plants.
  prefs: []
  type: TYPE_NORMAL
- en: The values mentioned in this entire chapter are simply assumed values. I would
    strongly recommend to tweak it based on where you live and what kind of plants
    you have in your garden to get the best out of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered certain topics such as solenoid integration and
    soil humidity sensors to build a robot that waters your backyard garden automatically.
    Next up, we will cover the basics of motors.
  prefs: []
  type: TYPE_NORMAL

- en: Sensor Interface for Obstacle Avoidance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make a robotic vehicle that drives itself, we need to first understand how
    humans drive a vehicle. When we drive a car, we constantly analyze the space and
    the distance to other objects. Thereafter, we make a decision if we can go through
    it or not. This happens constantly with our brain – eye coordination. Similarly,
    a robot would have to do the same sort of thing.
  prefs: []
  type: TYPE_NORMAL
- en: In our previous chapters, you learned that we can find the proximity of objects
    around us, using sensors. These sensors can tell us how far an object is, and
    based on it, we can make decisions. We have done using an ultrasonic sensor primarily
    because it is extremely cheap. However, as you remember, it was slightly cumbersome
    to attach ultrasonic sensors and to run its code. It's time that we take a much
    simpler sensor and attach it to the car.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Infrared proximity sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autonomous emergency braking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Giving it self-steering capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making it fully autonomous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrared proximity sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following photo depicts an infrared proximity sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7608bfcf-f3d8-49e1-b982-1db4a12c2bdf.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It consists of two major parts—the sensor and the transmitter. The transmitter
    emits IR waves; these **Infrared** (**IR**) waves then hit the object and come
    back to the sensor, as depicted in the following diagram..
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8432224f-a4c0-45d9-ac6a-d0f80cd21fa1.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, as you can see in the preceding diagram, the emitted IR waves bounces back
    from a surface at a different distance from the sensor, then they makes an angular
    approach to the sensor. Now, because the distance between the transmitter and
    the sensor is fixed at all points of time, the angle corresponding to reflected
    IR waves would be proportional to the distance it has traveled before bouncing
    off. There are ultraprecise sensors in the IR proximity sensors that are capable
    of sensing the angle at which the IR waves approach it. By this angle, it gives
    the user a value of distance corresponding to it. This method of finding distance
    is named **triangulation**, and it has been used widely in the industry. One more
    thing we need to keep in mind is that we are all surrounded by IR radiation as
    we mentioned earlier in the chapters; any object above absolute zero temperature
    would have corresponding waves emitted to it. Also, the sunlight around us is
    having ample amount of IR radiations. Hence, these sensors have a built-in circuitry
    to compensate for it; however, there is only so much it can do. That's why, this
    solution might have some trouble when dealing with direct sunlight.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, enough of the theory, let''s see how the car actually works. The IR proximity
    sensor we are using in this example is an analog sensor by Sharp with part code
    GP2D12\. It has an effective sensing range of 1000-800 mm. The range is also dependent
    on the reflectivity of the surface of the object in question. The darker the object,
    the shorter the range. This sensor has three pins. As you might have guessed,
    there is one for VCC, another for ground, and the last for the signal. This is
    an analog sensor; hence, the distance reading would be given based on the voltage.
    Generally with most analog sensors you would get a graph which will depict the
    various voltages at various sensing ranges. The output is basically depending
    on the internal hardware of the sensor and its construction so it can be vastly
    different. Below is a graph for our sensor and its output :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9c9e2a5f-92fd-497a-9e13-31ab428dce10.png)'
  prefs: []
  type: TYPE_IMG
- en: Okay then, so far so good. As we know that Raspberry Pi does not accept analog
    input; hence, we will go ahead and use what we have used earlier as well, an ADC.
    We will be using the same ADC we have used before.
  prefs: []
  type: TYPE_NORMAL
- en: Autonomous emergency braking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a new technology that newer cars are equipped with. It's called **autonomous
    emergency braking**; no matter how serious we are while driving, we do get distractions,
    such as Facebook or WhatsApp notifications, which tempt us to look away from the
    road onto the screen of our phones. This can be a leading cause of road accidents;
    hence, car manufacturers are using autonomous braking technology. This generally
    relies on long range and short range radars and it detects the proximity of other
    objects around the car, and in the case of an eminent collision, it applies the
    brakes to the car autonomously preventing them from colliding from other cars
    or pedestrians. This is a really cool technology, but what's interesting is that
    we would be making it today with our own bare hands.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this, we will be using the IR proximity sensor to sense the proximity
    of objects around it. Now go ahead, grab a double-sided tape, and attach the IR
    distance sensor at the front of the car. Once this is done, connect the circuit
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ef0c2188-ae4d-490b-b00c-af05811945b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'All right then, we are all set up to code it up. The following is the code,
    and just copy it into your Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's see what's actually happening in this code. Everything is very much
    elementary; the IR proximity sensor is sensing the proximity of objects in front
    of it and gives the corresponding distance value in the form of analog signals.
    These signals are then taken by the ADC, and they are converted into digital values.
    These digital values are finally transferred to Raspberry Pi via the I2C protocol.
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good. But you must be wondering what this line is doing?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There is not much we are doing here, we are simply taking the digital values
    given by ADC, and using this formula, we are covering that digital value to understandable
    distance values in the unit of centimeters. This calculation is provided by the
    manufacturer, and we really don't have to get our head into this. Most of the
    sensors have these calculations provided. However, if you want to go and understand
    how and why we are using this formula, then I would recommend you go through the
    data sheet of the sensor. The data sheet is available easily online on the following
    link: [https://engineering.purdue.edu/ME588/SpecSheets/sharp_gp2d12.pdf](https://engineering.purdue.edu/ME588/SpecSheets/sharp_gp2d12.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, the main part of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is again very simple. We have entered a distance value, which in this program,
    we have set to `20`. So, whenever the value of `F`  (the distance accrued by IR
    proximity sensor) is smaller than `20`, then a `stop()` function is called. The
    `stop` function simply stalls the car and stops it from colliding with anything.
  prefs: []
  type: TYPE_NORMAL
- en: Let's upload the code and see if it actually works! Make sure that you run this
    car indoors; otherwise, you would have a tough time trying to stop this car if
    it does not get any obstacles. Have fun!
  prefs: []
  type: TYPE_NORMAL
- en: Giving the car self-steering capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope that you are having fun with this little zippy thing. It is interesting
    how simple the application of sensors can be and how much difference it can make.
    As you have learned the basics, it's now time to move ahead and give the car some
    more powers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous code, we just made the robot stop in front of the obstacles,
    why don''t we make it steer around the car? It''s going to be super simple yet
    super fun. All we need to do is to tweak the function `stop()` and make it able
    to turn. Obviously, we will also change the name of the function from `stop()`
    to `turn()` just for the sake of clarity. One thing to remember that you won''t
    have to rewrite the code; all we need to do is some minor tweaking. So, let''s
    see the code and then I will tell you what exactly has changed and why:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you would have noted, everything remains pretty much the same except for
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This part of the code is defining the `turn()` function in which the opposite
    side wheels of the vehicles would be spinning in the opposite direction; hence,
    making the car turn on its own axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now this is the main part of the program; in this part, we are defining what
    the car would do if it encounters any sort of obstacle in front of it. In our
    previous programs, we were primarily just telling the robot to stop as soon as
    it encounters any obstacle; however, now we are chaining the `stop` function with
    a `turn` function, which we have defined previously in the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'We simply put in a condition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Then, it would turn just for a fraction of seconds, as the microcontroller would
    parse through the code and execute it and get out of the condition. To do this,
    our Raspberry Pi would hardly take a couple of microseconds. So, we might not
    even able to see what has happened. Hence, in our program, we have used a `while`
    loop. This essentially keeps the loops running till the time condition is fulfilled.
    Our condition is `while F < min_dist:`, so till the time the robot is detecting
    an object in front of it, it will keep executing the function inside it, which
    in our case is, the `turn()` function. So in simple words, till the time it has
    not turned enough to avoid the obstacle, the vehicle would keep turning and then
    once the loop is executed, it will again jump back to the main program and keep
    going straight.
  prefs: []
  type: TYPE_NORMAL
- en: Simple isn't it? That's the beauty about programming!
  prefs: []
  type: TYPE_NORMAL
- en: Making it fully autonomous
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, you must have understood the basics of autonomous driving using a simple
    proximity sensor. Now is the time when we make it fully autonomous. To make it
    fully autonomous, we must understand and map our surroundings rather than to just
    turn the vehicle till the time it encounters an obstacle. We basically need to
    divide this whole activity in the following two basic parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Scanning the environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deciding what to do with the perceived data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s first write the code and then see what we need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now most of the program is just like all of our previous programs; in this
    program, we have defined the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`forward()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`right()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`left()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is not much I need to tell you about defining the functions, so let's
    move ahead and see what else do we have in stock for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main action is going on in our infinite loop `while True:`. Let''s see
    what exactly is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what this part of code is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that is executed as soon as our program enters the infinite
    loop is the `forward()` function; that is, as soon as the infinite loop is executed,
    the vehicle will start to go forward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thereafter, `F_value = adc.get_last_result()` is taking the reading from ADC
    and storing it in a variable named `F_value`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F = (1.0/(F-value/13.15))-0.35` is calculating the distance into understandable
    metric distance value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min_dist = 20` , we have simply defined the minimum distance that we will
    be using later'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once this part of code is done, then the `if` statement will check whether `F
    < min_dist:`. If it is so, then the code that is under the `if` statement will
    start to execute. The first line of this will be the `stop()` function. So whenever
    the vehicle encounters any obstacle in front of it, the first thing it will do
    is stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as I mentioned, the first part of our code is to understand the environment,
    so let''s go ahead and see how we do it :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After the vehicle has stopped, it will immediately turn right. As you can see,
    the next line of code is `time.sleep(1)`, so for another `1` second, the vehicle
    will keep turning right. We have randomly picked a time of `1` second, you can
    tweak it later.
  prefs: []
  type: TYPE_NORMAL
- en: Once it has turned right, it will again take the reading from the proximity
    sensor, and in using this code `R=F`, we are storing that value in a variable
    named `R`.
  prefs: []
  type: TYPE_NORMAL
- en: After it has done that, the car will turn to the other side, that is, toward
    left side using the `left()` function, and it will keep turning left for `2` seconds
    as we have `time.sleep(2)`. This will turn the car toward left of the obstacle.
    Once it has turned left, it will again take in the value of proximity sensor and
    store the value in a variable `L` using the code `L = F`.
  prefs: []
  type: TYPE_NORMAL
- en: So essentially what we have done is that we have scanned the areas around us.
    In the center, we have an obstacle. It will first turn right and take the distance
    value of the right side; thereafter, we will turn left and take the distance value
    of the left side. So we essentially know the environment around the obstacle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we come to the part where we have to make a decision, in which direction
    we have to go forward. Let''s see how we will do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using an `if` statement, we are comparing the values of the proximity sensor
    for the right and left of the obstacle by this code `if L < R:`. If `L` is smaller
    than `R`, then the vehicle will turn right for `2` seconds. If the condition is
    not true, then the `else:` statement would come into action, which will in turn
    make the vehicle go forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if we see the code in a larger picture, the following things are happening:'
  prefs: []
  type: TYPE_NORMAL
- en: The vehicle would go forward until it encounters an obstacle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon encountering an obstacle, the robot will stop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will first turn right and measure the distance to objects in front of it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, it will turn left and measure the distance to objects in front of it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this, it will compare the distance of both left and right and choose which
    direction it has to go in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it has to go right, it will turn right and then go forward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it has to go left, then it would already be in the left turned orientation,
    so it simply has to go straight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's upload the code and see whether things happen according to plan or not.
    Remember this, though every environment is different and every vehicle is different,
    so you may have to tweak the code to make it work smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Now I will leave you with a problem. What if in both case the reading of the
    sensor is infinity or the maximum possible value that it can give? What will the
    robot do?
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead, do some brainstorming and see what we can do to solve this problem!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, using all basics that you learned so far and also by introducing
    IR proximity sensor, we were able to take an advanced step of developing our robotic
    car to detect obstacles and accordingly change the directions. In the next chapter,
    we will study how to make our own area scanner—see you there!
  prefs: []
  type: TYPE_NORMAL

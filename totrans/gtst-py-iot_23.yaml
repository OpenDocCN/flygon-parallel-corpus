- en: Making Your Own Area Scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Motors are amazing things; they come in all shapes and sizes. Primarily, they
    can be considered the backbone of most robots. However, nothing is perfect in
    this world. There must be some drawbacks to these motors as well. By now, you
    might have figured out some by yourself. In the previous chapter, when we made
    the car turn, you might have seen that the angle of turn was never really the
    same. Also when the vehicle was given the command to go straight, it really would
    not do so. Rather it would try to run slight, toward one side.
  prefs: []
  type: TYPE_NORMAL
- en: Say hello to the first problem—precision. The motors are exceptionally simple
    to control, but the problem with these motors come when we have to rotate the
    motors only till a specific angle. If you need to rotate the motor of your robotic
    vehicle only by 90 degrees, then how would you do it? The first and foremost thing
    that might come to your mind would be to fiddle with the timings of the motors.
    You might be right here. But still, it would be impossible to make sure that it
    is exactly 90 degrees every single time.
  prefs: []
  type: TYPE_NORMAL
- en: But when we talk about robots, accuracy of even 1 degree may not be enough.
    Roboticists these days are looking forward to accuracy within the magnitude of
    two decimal digits. So, the precision we are talking about is close to 0.01 degrees.
    What do you think now? How do we achieve this level of accuracy with motors?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answers to all these questions will be answered in this chapter through
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Servo motor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LIDAR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Servo motor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, let me introduce you to *servo motor*. Servo motor is basically a motor
    with a few added components. Now to understand what those added components, let''s
    first go through this example. Let''s say that you want to go to London. Now to
    see how you have to go there and what would be the route to reach London, the
    first thing you need to know is that where exactly you are now. If you don''t
    know where you are currently, it is impossible to calculate a route. Similarly,
    if we want to reach a certain position of motor, we need to know where the shaft
    of the motor is standing right now. To do this, we use a **potentiometer**. A
    potentiometer is basically a variable resistor that essentially has a shaft that
    when rotated changes the value of resistance. A variable resistor looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f982d278-8b3c-45b1-8280-67f23461fbeb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the value of resistor change, then the output voltage from the resistor
    will also change. The interesting thing is that if the input voltage to the potentiometer
    is well known, then the output voltage from it can be used to infer where the
    shaft is. Let''s see how:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5e54a397-af93-4c44-8c7b-4fcf74a10a7b.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's say at a position of 0 degrees, the output voltage for the potentiometer
    is 4.8V; when we move it up to 90 degrees, the value changes to around 3.2V, and
    upon turning entirely 180 degrees, the voltage reduces to a mere 2V due to the
    change in resistance.
  prefs: []
  type: TYPE_NORMAL
- en: Without really looking at the shaft of the potentiometer, we can easily derive
    that if the voltage output from the resistor is 4.8V, then the shaft must be at
    a position of 0 degrees. Similarly, we can say that it is at 90 degrees if the
    voltage is 3.2V and at 180 degrees when the voltage is 2V.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have just plotted three points, but for any given point on the potentiometer,
    there would be a very specific resistance corresponding to it. Through this we
    can precisely calculate where the shaft of the potentiometer would be. Now, let''s
    put it in an interesting combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f099b21d-72be-42ac-bc4f-1a754d738656.png)'
  prefs: []
  type: TYPE_IMG
- en: Now what we have is a motor coupled with potentiometer through multiple reducing
    gears that will reduce the speed of the motor and increase the torque. Further
    at the final gear, a shaft is mounted outward to the body coupled with a potentiometer.
  prefs: []
  type: TYPE_NORMAL
- en: So as you learned, the potentiometer will be able to sense at which angle the
    output shaft is pointing. The potentiometer is then connected to a control circuit
    that takes the reading from the potentiometer and further guides the motor on
    how much more to move to reach the goal position. Due to this closed loop arrangement
    in which the control circuit knows where the shaft is, it could calculate how
    much it has to move the motor to reach the goal position. Hence, this arrangement
    is able to turn the output shaft to any given position precisely.
  prefs: []
  type: TYPE_NORMAL
- en: 'This arrangement is typically known as a **servo motor**. Throughout the robotics
    industry, it is one of the most widely used hardware to control precise movements.
    Essentially, there are three wires going into the control circuit—VCC, ground,
    and signal. The signal line will receive the data from our Raspberry Pi, and upon
    receiving, it will do the necessary motor movement to make the shaft reach the
    desired position. An image of a servo motor is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d29c7091-5e71-476a-9560-458e8548d3db.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These can start from being extremely inexpensive, around $4 to $5, but they
    can go up to thousands of dollars. But what really decides the pricing of these
    servo motors? There are several factors that we need to keep in mind while choosing
    a servo motor, but the most important of it is **torque**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Torque is a basically a turning force by which a motor can turn the output
    shaft. This is measured usually in kg·cm or N·m. Now what does this actually mean?  Let''s
    see the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8f141cf1-1546-4aa6-b001-a25230a76c6c.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's say in the preceding diagram, we have a motor that has a torque of 10
    kg·cm and the rotor attached to it is of 1 cm. So, it should be able to pull up
    a weight of 10 kg perpendicularly up from the ground. However, when we change
    the radius of the rotor to 2 cm, then the weight that can be lifted gets halved. Similarly,
    if the radius increases to 10 cm, then the weight that can be lifted would only
    reduce to 1 kg. So basically, the weight that can be lifted would be torque/radius.
  prefs: []
  type: TYPE_NORMAL
- en: 'But for most of our purposes, we would not be using a mechanism as shown previously,
    so let''s look at the next diagram to see how the calculations can be made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f16efa7c-28dc-4e55-b304-677c5cc3bd63.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's say we have a shaft of length **L** and a load at the extreme edge
    of the shaft. For ease of calculation purposes, we would consider the weight of
    shaft to be negligible. Now if the servo is having a torque of 100 kg·cm and the
    length of shaft (**L**) is 10 cm, then by simple calculation, the load that we
    can pick up would be 100/10 = 10 kg. Similarly, if the length increases to 100
    cm, the load that can be lifted would reduce to a mere 1 kg.
  prefs: []
  type: TYPE_NORMAL
- en: OK then; we have had a good amount of exposure to servo motors. Now the question
    is how do we control a servo motor? As I mentioned, there are different types
    of servo motors that are available that can be addressed by various means. However,
    the most common one used for hobby purposes is a digital servo motor. These servo
    motors require **PWM**, and based on the duty cycle of PWM, the angle of the shaft
    changes. So, let's see how it happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, most of these servos have a frequency of 50 Hz. So basically the
    length of every pulse would be 1/50 = 0.02 seconds or in other words 20 ms. Further,
    the duty cycle that can be given to theses servo motors can be 2.5% to 12.5%,
    which basically means pulse width of 0.5 ms to 2.5 ms. Now let''s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6bf9dcb1-8667-43f3-a692-7512b4b9ff8a.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, when given a duty cycle of 2.5%, the shaft gets down to the
    minimum position of 0 degrees, and when the duty cycle is increased to 7.5%, the
    shaft goes to the middle position of 90 degrees. Finally, when the duty cycle
    is increased to 12.5%, the shaft goes to the maximum position of 180 degrees.
    If you want any position in between, then you can simply choose the PWM corresponding
    to it, and it will change the position of servo to the desired angle.
  prefs: []
  type: TYPE_NORMAL
- en: But you may be thinking what if we want to take it beyond 180 degrees? Well,
    good question, but most of the digital servos only come with a range of 180 degrees
    of rotation. There are servos that can rotate completely its axis, that is, 360
    degrees; however, their addressing is slightly different. After this chapter,
    you can pretty much go ahead check out any digital servo motor's data sheet and
    control it the way you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'All right, enough of theory; it''s time to do some fun. So, let''s go ahead
    and set up the hardware and control a servo by our bare hands! Connect the servo
    to Raspberry Pi as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/33afed26-fe51-481c-a42e-ca52ceedebf4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The color coding of the wires is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/54d5c3d3-abad-46a3-9b00-b633d33d4a28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to upload the following code and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you run this program, you will see the shaft of the servo moving
    from left to right, making steps at 0 degrees, 45 degrees, 90 degrees, 135 degrees,
    and finally 180 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what we have done in the program to achieve it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With the line `pwm = GPIO.PWM(14, 50)`, we have defined that GPIO pin number
    `14` will be used for PWM and the frequency of PWM will be `50`. We have used
    the line `pwm.start(0)` in earlier chapters as well. It basically sets the PWM
    pin to `0` that is no duty cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: No all the earlier program is in the `while` loop, that is, it will be executed
    over and over until the program is forced to quit. Now the line `pwm.ChangeDutyCycle(2.5)`
    sends a PWM of 2.5% duty cycle to the servo motor. This will simply turn the servo
    motor to 0 degree angle. Next, we use the good old `time.sleep(2)`, which we all
    know would halt the program that line for two seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The same cycle is being repeated with different PWM values of 5%, which would
    turn the shaft to 45 degrees, 7.5% for 90 degrees, 10% for 135 degrees, 12.5 %
    for 180 degrees. It's a very simple program that would clear out our basics of
    the servo motor.
  prefs: []
  type: TYPE_NORMAL
- en: 'So by now, you have learned how to control servo motor and move it in the direction
    in which we want. Now, let''s go a step ahead and change the code slightly to
    make the servo run smoothly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'What happened when you uploaded this code in your Pi? You would have noted
    that the servo is swiping from left to right very smoothly and then right to left.
    We have done a very simple trick; let''s see what it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are running a loop that will run till the time the value of `i<=12.5`,
    as we have defined earlier in the program the value of `i` has been set to `2.5`
    as default in the starting of the program. Thereafter every time the code runs,
    the duty cycle is set to the value of `I` , the program halts for 0.1 seconds
    and then the value of `i` is incremented by a value of `0.1`. This is increasing
    the duty cycle of the PWM. Once the value reaches 12.5, the loop exits.
  prefs: []
  type: TYPE_NORMAL
- en: The entire PWM range we have is 2.5% to 12.5%, so we have a space of 10% to
    play with. Now if we map it to the angular rotation of the servo motor, then every
    percent of PWM corresponds to a change of 180/10 = 18 degrees. Similarly, every
    0.1% of the change would result in a change of 180/100 = 1.8 degrees. Hence, with
    every 0.1 seconds, we are adding duty cycle by 0.1%, or in other words, we are
    increasing the angle by 1.8 degrees. Hence, we find this action extremely smooth.
  prefs: []
  type: TYPE_NORMAL
- en: We are doing the similar thing in the next portion of the program; however,
    we are doing it for the reverse motion.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All right then, we are quite sure on how to use the servo and have a controlled
    motion as per our needs. Now it's time to move forward and understand another
    concept that we would be using greatly. It's named **arrays**. If you have programmed
    in any other language, you must be familiar with it. But we need to understand
    a few basics concepts of it, which will make our lives a lot easier. So, let's
    get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'First things, first. Arrays in Python are not named arrays, rather it is named
    as **lists**. List is basically a data structure that can store multiple elements
    at the same time. The only limitation being is that the elements must be of the
    same data type. Such as if you are storing integers, then all the values should
    be `int`. Similarly, if you are storing a character, then every element of the
    list should be `char`. To define a list, all you need to do is name the list such
    as we have done by doing `myList`; the name of the list could be anything next
    we need to tell the compiler that it is actually a list. To do that, we need to
    put values inside square brackets. It would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing to keep in mind is that every value should be separated with commas. Whenever
    we want to address any single element of the list, we can simply use it by calling
    their index number. This is based on the position of the element in the list.
    The index value in Python list starts from 0\. So as per the preceding declaration
    at the index 0, the value would be `14`, and at the address 4, the value would
    be `9`. Now when we need to print these elements in between our program, we need
    to write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once we write this, the program will print the value of the second value in
    the list. In our case, it would be `35`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this is one way to access the elements of the list; we can however access
    it in reverse order as well. So, let''s say you want to access the last item of
    the array. Then, we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code will return the value of the last element of the array. Now whenever
    we use the negative values in the lists, then it would start the indexing in the
    reverse order. So, let's say if we type in `print myList[-2]`, this will give
    us the value of the second last value in the array. One thing to remember in this
    whole schematic is that the numbering would start from 0, whereas when we start
    it in the reverse order, then the numbering would start from -1.
  prefs: []
  type: TYPE_NORMAL
- en: Python is really interesting and quite simple if you know the right tools. The
    developers of Python have included some really helpful functions that can be used
    over lists. So, let's go and explore them a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is to add elements to the array. For this, we use a function
    named `append()`. What the `append()` function does is that it adds the value,
    which would want at the end of the array. So, write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'What this would do is that it would add the element `45` at the end of `myList`.
    So now the list would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Easy, isn''t it ? But what if you want to add an element in between the list?
    Obviously, the developer won''t leave you dry. They have included a function for
    that as well; it''s named `insert(index, element)`. Now whenever you are using
    this function, you need to make sure that you mention the index where you want
    this element to be and second, the element that you want to put. So it looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have used this function, the array will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, whenever the developer has given the function to add an element,
    then they would have certainly given a function to remove the elements as well.
    But the trick is that you can do it two ways. First, the common way. We simply
    select the index number and delete it. We are going to do it now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now what this will do is that it would delete the second element of the array,
    so after doing this operation, the array will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'But now here comes the real trick; you can also delete the element by simply
    specifying the element. This is how it''s done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now the moment you do this, it will find wherever the element `9` is in your
    list and delete it from the positions. So you don't have to care about where the
    element is; this function will say, I will find you and I will kill you!
  prefs: []
  type: TYPE_NORMAL
- en: Looking around
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay then enough of movie quotes. We can talk about many other functions that
    we can use over lists, but what we have done is enough for now. We will see the
    rest of them as the need arise. But for now let's take the things a step further
    in robotics. You might have seen a rotating object on top of many autonomous cars.
    The production cars generally don't tend to have primarily due to its high price,
    but research purpose cars are always loaded with it.
  prefs: []
  type: TYPE_NORMAL
- en: So what is this device? It's named **LIDAR**; it is an acronym for **Light Detection
    and Ranging**. I know bad acronym. There is a reason for LIDAR to be very common.
    It gives distance reading of the areas around it in a very precise way. However,
    buying it for our projects would slightly overkill as a good one would cost you
    close $500 to $10,000\. If you still think that it's in your budget, then you
    would be very lucky! But for those who don't want to buy it. I have a good news
    for you. Today, we are going to build our own LIDAR scanner. So to make an area
    scanner, we need a servo over which we will mount our IR proximity sensor. Now
    to do this, we would need a slight makeshift arrangement. You can take a cardboard
    and fix it like we have done in the picture here, or otherwise, you can also use
    a right-angled aluminum and drill it to fix the components if you want it to do
    the pro way. The one thing to remember that the sensor must be facing exactly
    parallel to the ground and not up or down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the mounting is done, then it''s time to connect the rest of the hardware.
    So go ahead and connect the hardware, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/100d1350-9710-4ddf-910a-13518c62bf16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'OK, so let''s see what this thing can do, so get ready and upload this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: What did the code do? If it ran fine, then it should return you the scanned
    readings entire 180 degree broken down into 10 even steps. Go ahead—try it out
    and then return to see what actually is happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now most of the code is elementary, and you must have also got an idea of what
    this code is actually doing. However, let''s get deeper into it and see the specifics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this part of the program, we have defined a function named `Distance()`.
    As you can see, it is simply getting the reading from the ADC in the step `D_value
    = adc0.get_last_result()`; thereafter, this is the value procured that is stored
    in a variable `D` is then computed in the line `D = (1.0/F-value/13.15)) - 0.35`
    to get the metric reading from the ADC reading. Finally, using the line `Return
    D`, we are returning the value `D` from the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We have declared two lists: `distLR`, namely for distance for left to right
    swipe of the servo and `distRL` for the distance received in right to left swipe
    of the servo. You might be wondering how is it that there is nothing inside these
    brackets. It is completely normal to have an empty array declared. There is no
    need for them to have value initially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now this is where the real action is happening. The `while` loop will be executed
    only till the time the value of `k` is less than or equal to `12.5`. In the next
    line `servo.ChangeDutyCycle(k)`, the value of the duty cycle will be whatever
    the value of `k` would be. Initially, the value of `k` would be `2.5` as we have
    already defined in the beginning of the program. Now we add another line `time
    sleep(.1)`, which will make the program halt for `.1` second. This is necessary;
    otherwise, the program would parse through this loop within milliseconds and the
    servo would not be able to cope up with it. Hence, this is a short delay. In the
    next line, we have `distLR.insert(I,Distance())`. This line of program is doing
    a lot of things. First, as we have named a `Distance()` function inside this line.
    As we defined, it would calculate the distance using the ADC and the IR proximity
    sensor. Thereafter, it would insert that distance value inside an the list `distLR`
    at the position `I`. Previously in our program, we have already assigned the value `i
    = 0`; hence, the distance value would be put up in the first position in the array.
    Once this entire process is done, then we move forward and increment the value
    by one in this line `k = k + 1`; thereafter, we do the same thing in `I = I +
    1`. Now finally, once this loop''s executed, the values of the list is printed
    using the line `print distLR`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this line, we are simply resetting the values of `i = 0` and `k = 0` for
    the next loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This may be slightly new for you.  Whenever we use a colon inside a bracket,
    that basically means that the entire elements of the array would be deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the same thing is happening that we did for the left to right
    swipe; the only difference being is that we are saving it a new list named `distRL`,
    and the swipe starts from 12.5% duty cycle and ends at 2.5%:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When we have printed all the values, we again reset the values of `i = 1`, `k
    = 2.5`, and `j = 12.5` so that our first loop can start seamlessly further to
    it we are also making sure that there is nothing left inside the list `distRL`.
  prefs: []
  type: TYPE_NORMAL
- en: So this is how our code was working, straight and simple!
  prefs: []
  type: TYPE_NORMAL
- en: LIDAR on an autonomous vehicle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember the last time we made autonomous car. It was cool, and surely it might
    be something you can show off to your friends. However, now what we are about
    to make is surely cooler than anything we have ever done till now.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to put this area scanner over our robotic vehicle. But wait, didn't
    we scan the area earlier using the same sensor and turning the car to other sides.
    We did it and it worked fine, almost fine. I bet sometimes it wasn't as accurate
    as you thought it would be. But that's not the real problem. The main problem
    is that it was not seamless. It has to stop in between check for spaces and then
    move in either direction. What we are going to do now is something that is a step
    ahead. So before doing any more explanation, let's go ahead and make this new
    robotic vehicle and then you be the judge to decide whether it is cooler.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to make it, you need to mount the area scanner on the vehicle. It''s advisable
    that you set it up at the frontend of the vehicle and make sure that the arm of
    the servo is able to rotate 180 degrees. You can use the similar method that we
    did to fix the IR sensor on top of the servo. While you are doing all of this,
    try using cable ties to make sure the cables are not messy and also make sure
    to leave some slack for the movement of the shaft and the sensor on top of it.
    These cable ties can make your life really simple. Once we are all set up, you
    should connect the IR proximity using an ADS1115 to the Raspberry Pi and then
    connect the motor driver, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6dcbf2c2-2bde-4c2f-a9a9-c7a48760fd99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we are done go ahead and upload the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Phew! That was long wasn''t it? But trust me it might be long, but not tough.
    So let''s see what this code is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This stuff might look pretty new to you. Though it isn't. What we are doing
    is that we are defining which pin number will be operating at what PWM frequency.
    Also, we have named every GPIO pins that is being used for motor control. OK then,
    it is fine that we are doing all this, but why have we suddenly started to give
    PWM to motor drivers. Were we not happy giving a simple high pulse?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is very straightforward. With the use of PWM, we were able to change
    the brightness of an LED in previous chapters. Similarly, by changing the PWM
    output to the control pins of the motor driver, you cannot only define which direction
    to spin in. But also the speed at which it can spin. This is all done with PWM.
    So let''s say pin number `20` is getting a PWM at 50% duty cycle. So it basically
    means that the motor which is attached to it will get half the input voltage that
    the motor driver is receiving. So now we can not only control which direction
    we want the motor to spin but also at what speed we can do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this statement, we have defined a function `direction(index)`. What this
    does is that it compares the value of index and based on it. The power will be
    given to the motors. So lets say that the index is 0\. In this case the wheel
    on the left side would move in reverse direction whereas the right wheel would
    move in the reverse direction this will turn the robot on its axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next statement, we have written an `elif` statement, so if the `else` statement
    is not true, then it will check for the rest `else if` statement in the body.
    There are four `elif` statements in the entire definition of `direction(index)`,
    which basically means that it will check for each one of it and do either of the
    activities based on the value of the argument. In this case, it is the index.
    Further, there is a final `else` statement, which would be done if none of the
    cases are true. So according to the statement, it will call a function of stop.
    That would stop the vehicle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This line is pretty interesting as we are using another fun part of the lists
    that we have used. So, with the `max()` method, we can find the largest value
    inside a list. So, in this line, we are simply finding the max value and putting
    it in a variable named `max_dist1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The beauty of lists just doesn''t seem to end. In this line, we are using another
    method named `index()`; this method gives us the index of the value inside the
    list. So, we can know where the value exists in the list. Hence, in this line,
    we are proving the value of `max_dist1`. The method `index()` searches the index
    number and stores that value down into a variable named `max_dist1_index`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As we have already defined the function `Direction()`, now all we are doing
    is calling the function to decide which direction to go in. Prefect then, power
    up your vehicles and see how well they are driving and do not forget to shoot
    a video and post it online.
  prefs: []
  type: TYPE_NORMAL
- en: Have fun!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Professional laser scanners are super expensive, so, in this chapter, we went
    on to build an alternative by ourselves and mounted it on our vehicle. In the
    next chapter, we will cover topics such as vision processing, and object detection,
    object tracking, which will enable us to do basic vision processing and to make
    the car move in the direction of a specific object such as a ball.
  prefs: []
  type: TYPE_NORMAL
